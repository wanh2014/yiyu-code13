.版本 2

.DLL命令 ZwWow64ReadVirtualMemory64, 整数型, "ntdll.dll", "ZwWow64ReadVirtualMemory64"
    .参数 ProcessHandle, 整数型, , 对象句柄
    .参数 BaseAddress, 长整数型, , 内存地址
    .参数 Buffer, 字节集, , 返回缓冲区
    .参数 BufferSize, 长整数型, , 写入大小
    .参数 NumberOfBytesRead, 长整数型, 传址, 实际写入大小

.DLL命令 ZwWow64WriteVirtualMemory64, 整数型, "ntdll.dll", "ZwWow64WriteVirtualMemory64"
    .参数 ProcessHandle, 整数型, , 对象句柄
    .参数 BaseAddress, 长整数型, , 内存地址
    .参数 Buffer, 字节集, , 返回缓冲区
    .参数 BufferSize, 长整数型, , 写入大小
    .参数 NumberOfBytesRead, 长整数型, 传址, 实际写入大小

.DLL命令 CopyMemory_DRAWITEMSTRUCT, , "kernel32.dll", "RtlMoveMemory"
    .参数 pDest, DRAWITEMSTRUCT
    .参数 pSrc, 整数型
    .参数 ByteLen, 整数型

.DLL命令 SendMessage_HDITEM, 整数型, "user32.dll", "SendMessageA", , 调用一个窗口的窗口函数，将一条消息发给那个窗口。除非消息处理完毕，否则该函数不会返回。
    .参数 hwnd, 整数型, , 要接收消息的那个窗口的句柄
    .参数 wMsg, 整数型, , 消息的标识符
    .参数 wParam, 整数型, , 具体取决于消息
    .参数 lParam, HDITEM, , 具体取决于消息;

.DLL命令 HeapSize, 整数型, "kernel32.dll", "HeapSize", 公开, 返回堆对象的大小
    .参数 hHeap, 整数型
    .参数 dwFlags, 整数型
    .参数 lpMem, 整数型

.DLL命令 GetOEMCP, 整数型, "kernel32.dll", "GetOEMCP", 公开, 判断在OEM和ANSI字符集间转换的windows代码页

.DLL命令 GdipDeleteBrush, 整数型, "GdiPlus.dll", "GdipDeleteBrush", 公开
    .参数 brush, 整数型

.DLL命令 SendMessageWINDOWPOS, 整数型, "user32.dll", "SendMessageA"
    .参数 hWnd, 整数型
    .参数 Msg, 整数型
    .参数 wParam, 整数型
    .参数 lParam, WINDOWPOS

.DLL命令 SetConsoleMode, 逻辑型, "kernel32.dll", "SetConsoleMode", 公开, 对输入句柄的工作模式进行设置
    .参数 hConsoleHandle, 整数型, , 控制台句柄
    .参数 dwMode, 整数型

.DLL命令 GetConsoleMode, 逻辑型, "kernel32.dll", "GetConsoleMode", 公开
    .参数 hConsoleHandle, 整数型, , 0
    .参数 lpMode, 整数型, , 0

.DLL命令 InvalidateRect_逻辑型, 逻辑型, "user32.dll", "InvalidateRect"
    .参数 hWnd, 整数型
    .参数 lpRect, 整数型
    .参数 bErase, 逻辑型

.DLL命令 InvalidateRect, 整数型, "user32.dll", "InvalidateRect", 公开, 这个函数屏蔽一个窗口客户区的全部或部分区域。这会导致窗口在事件期间部分重画  非零表示成功，零表示失败
    .参数 hWnd, 整数型, , 待屏蔽窗口的句柄
    .参数 lpRect, 整数型, , RECT，用于描述待屏蔽矩形部分的一个矩形结构。可用InvalidateRectBynum函数，同时将lpRect设为零（Long数据类型），从而屏蔽（或禁用）整个窗口
    .参数 bErase, 整数型, , TRUE（非零）导致指定的区域在重画前先删除;

.DLL命令 GdipSaveImageToStream, 整数型, "gdiplus.dll", "GdipSaveImageToStream"
    .参数 image, 整数型
    .参数 stream, 整数型
    .参数 clsidEncoder, 字节集
    .参数 encoderParams, EncoderParameters

.DLL命令 CLSIDFromString_字节集传址2, 整数型, "ole32.dll", "CLSIDFromString"
    .参数 lpsz, 字节集
    .参数 pclsid, 字节集, 传址

.DLL命令 CLSIDFromString_字节, 整数型, "ole32.dll", "CLSIDFromString"
    .参数 lpsz, 字节集
    .参数 pclsid, 字节型, 传址 数组

.DLL命令 CLSIDFromString_GUID, 整数型, "ole32.dll", "CLSIDFromString"
    .参数 lpsz, 字节集
    .参数 pclsid, GUID

.DLL命令 CopyMemory_SYSTEM_PROCESSES, , "kernel32.dll", "RtlMoveMemory"
    .参数 Destination, SYSTEM_PROCESSES
    .参数 Source, 整数型
    .参数 Length, 整数型

.DLL命令 CoInternetSetFeatureEnabled, , "urlmon.dll", "CoInternetSetFeatureEnabled", 公开, 初始化浏览器属性
    .参数 FeatureEntry, 整数型
    .参数 dwFlags, 整数型
    .参数 Enable, 逻辑型

.DLL命令 GetVolumeInformationA, 逻辑型, "kernel32.dll", "GetVolumeInformationA", 公开
    .参数 lpRootPathName, 文本型, , 0
    .参数 lpVolumeNameBuffer, 文本型, , 0
    .参数 nVolumeNameSize, 整数型, , 0
    .参数 lpVolumeSerialNumber, 整数型, 传址, 0
    .参数 lpMaximumComponentLength, 整数型, 传址, 0
    .参数 lpFileSystemFlags, 整数型, 传址, 0
    .参数 lpFileSystemNameBuffer, 文本型, 传址, 0
    .参数 nFileSystemNameSize, 整数型, , 0

.DLL命令 GetFileAttributesA, 整数型, "kernel32.dll", "GetFileAttributesA", 公开
    .参数 lpFileName, 文本型, , 0

.DLL命令 StringFromGUID2, 整数型, "ole32.dll", "StringFromGUID2"
    .参数 rguid, 字节集
    .参数 lpsz, 字节集
    .参数 cchMax, 整数型

.DLL命令 CreateIconFromResourceEx, 整数型, "user32.dll", "CreateIconFromResourceEx"
    .参数 presbits, 整数型
    .参数 dwResSize, 整数型
    .参数 fIcon, 整数型
    .参数 dwVer, 整数型
    .参数 cxDesired, 整数型
    .参数 cyDesired, 整数型
    .参数 Flags, 整数型

.DLL命令 RtlMoveMemory_IconDirEntry, , "kernel32.dll", "RtlMoveMemory"
    .参数 Destination, IconDirEntry
    .参数 Source, 整数型
    .参数 Length, 整数型

.DLL命令 DefWindowProc, 整数型, "user32.dll", "DefWindowProcA"
    .参数 hwnd, 整数型
    .参数 wMsg, 整数型
    .参数 wParam, 整数型
    .参数 lParam, 整数型

.DLL命令 SetRect, 整数型, "user32.dll", "SetRect"
    .参数 lpRect, 整数型
    .参数 X1, 整数型
    .参数 Y1, 整数型
    .参数 X2, 整数型
    .参数 Y2, 整数型

.DLL命令 RtlMoveMemory_bytes, , "kernel32.dll", "RtlMoveMemory"
    .参数 Destination, 字节型, 数组
    .参数 Source, 字节集
    .参数 Length, 整数型

.DLL命令 RtlMoveMemory_THUMBBUTTON2ptr, , "kernel32.dll", "RtlMoveMemory"
    .参数 Destination, 整数型
    .参数 Source, THUMBBUTTON
    .参数 Length, 整数型

.DLL命令 RegisterWindowMessage, 整数型, "user32.dll", "RegisterWindowMessageA"
    .参数 lpString, 文本型

.DLL命令 LocalSize_IP_ADDR_STRING, 整数型, "kernel32.dll", "LocalSize", 公开
    .参数 hMem, IP_ADDR_STRING, 传址

.DLL命令 DestroyIcon, 逻辑型, "User32.dll", "DestroyIcon"
    .参数 hIcon, 整数型

.DLL命令 CopyMemory_IP_ADDR_STRING, , "kernel32.dll", "RtlMoveMemory", 公开
    .参数 Destination, IP_ADDR_STRING, 传址
    .参数 Source, 整数型
    .参数 Length, 整数型

.DLL命令 CopyMemory_P2IP_ADAPTER_INFO, , "kernel32.dll", "RtlMoveMemory"
    .参数 pDest, IP_ADAPTER_INFO_彗星
    .参数 pSrc, 整数型
    .参数 ByteLen, 整数型

.DLL命令 LocalSize_IP_ADAPTER_INFO, 整数型, "kernel32.dll", "LocalSize", 公开, 返回本地内存块大小,类似sizeof
    .参数 hMem, IP_ADAPTER_INFO_彗星, 传址

.DLL命令 GetPtr_IP_ADAPTER_INFO, 整数型, "kernel32.dll", "lstrcpynA", 公开, , 取指针
    .参数 lpString1, IP_ADAPTER_INFO_彗星, 传址
    .参数 lpString2, IP_ADAPTER_INFO_彗星, 传址
    .参数 iMaxLength, 整数型, , 传递0

.DLL命令 lstrcpynA_Bin, 整数型, "kernel32.dll", "lstrcpynA"
    .参数 lpString1, 字节集
    .参数 lpString2, 字节集
    .参数 iMaxLength, 整数型

.DLL命令 GetPtr_Bin, 整数型, "kernel32.dll", "lstrcpynA", 公开, 取指针
    .参数 lpString1, 字节集, 传址
    .参数 lpString2, 字节集, 传址
    .参数 iMaxLength, 整数型, , 传递0

.DLL命令 EnumDisplayDevicesA, 逻辑型, "user32.dll", "EnumDisplayDevicesA"
    .参数 lpDevice, 整数型
    .参数 iDevNum, 整数型
    .参数 lpDisplayDevice, DISPLAY_DEVICEA
    .参数 DWORD, 整数型

.DLL命令 SetSecurityInfo, 整数型, "advapi32.dll", "SetSecurityInfo"
    .参数 handle, 整数型
    .参数 ObjectType, 整数型, , SE_KERNEL_OBJECT
    .参数 SecurityInfo, 整数型, , DACL_SECURITY_INformATION
    .参数 ppsidOwner, 整数型
    .参数 ppsidGrou, 整数型
    .参数 ppDacl, 字节集
    .参数 ppSacl, 整数型

.DLL命令 InitializeAcl, 逻辑型, "Advapi32.dll", "InitializeAcl"
    .参数 pAcl, 字节集
    .参数 nAclLength, 短整数型
    .参数 dwAclRevision, 短整数型

.DLL命令 SetProcessDPIAware, 逻辑型, "user32.dll", "SetProcessDPIAware", 公开, user32.dll的一个API函数,可用于防止UI自动放大

.DLL命令 StrToIntExA_整数, 整数型, "shlwapi.dll", "StrToIntExA"
    .参数 pszString, 整数型
    .参数 dwFlags, 整数型
    .参数 piRet, 整数型, 传址

.DLL命令 strrchr, 整数型, "ntdll.dll", "@strrchr", 公开
    .参数 s, 整数型
    .参数 c, 字节型

.DLL命令 strchr, 整数型, "ntdll.dll", "@strchr", 公开
    .参数 s, 整数型
    .参数 c, 字节型

.DLL命令 RtlMoveMemory_LDR_DATA_TABLE_ENTRY64, , "kernel32.dll", "RtlMoveMemory"
    .参数 目的地址, LDR_DATA_TABLE_ENTRY64, , any
    .参数 源地址, 字节集, , any
    .参数 复制尺寸, 整数型

.DLL命令 wvsprintfA_整数型, 整数型, "user32.dll", "wvsprintfA"
    .参数 lpstr, 整数型
    .参数 lpcstr, 文本型
    .参数 OptionalArguments, 整数型, 传址

.DLL命令 wvsprintf, 整数型, "user32.dll", "wvsprintfA"
    .参数 lpstr, 文本型
    .参数 lpcstr, 文本型
    .参数 OptionalArguments, 长整数型, 传址

.DLL命令 RtlMoveMemory_BITMAPFILEHEADER_整数1, , "kernel32.dll", "RtlMoveMemory", , 　
    .参数 pBlock, 整数型
    .参数 缓冲区, BITMAPFILEHEADER
    .参数 尺寸, 整数型

.DLL命令 RtlMoveMemory_BITMAPINFOHEADER_整数, , "kernel32.dll", "RtlMoveMemory", , 　
    .参数 pBlock, 整数型
    .参数 缓冲区, BITMAPINFOHEADER
    .参数 尺寸, 整数型

.DLL命令 LoadString, 整数型, "user32.dll", "LoadStringA", , 装入字符串资源
    .参数 hInstance, 整数型
    .参数 wID, 整数型
    .参数 lpBuffer, 文本型
    .参数 nBufferMax, 整数型

.DLL命令 LoadStringW, 整数型, "user32.dll", "LoadStringW"
    .参数 hInstance, 整数型
    .参数 uID, 整数型
    .参数 lpBuffer, 整数型
    .参数 cchBufferMax, 整数型

.DLL命令 获取设备GammaRamp, 逻辑型, "gdi32.dll", "GetDeviceGammaRamp", 公开
    .参数 hdc, 整数型
    .参数 lpv, 短整数型, 数组

.DLL命令 设置设备GammaRamp, 逻辑型, "gdi32.dll", "SetDeviceGammaRamp", 公开
    .参数 hdc, 整数型
    .参数 lpv, 短整数型, 数组

.DLL命令 Beep, 逻辑型, "kernel32.dll", "Beep", 公开
    .参数 dwFreq, 整数型
    .参数 dwDuration, 整数型

.DLL命令 ReadProcessMemory_TRAYDATA, 整数型, "kernel32.dll", "ReadProcessMemory", , 在进程中读内存
    .参数 hProcess, 整数型
    .参数 lpBaseAddress, 整数型
    .参数 lpBuffer, TRAYDATA, 传址
    .参数 nSize, 整数型
    .参数 lpNumberOfBytesWritten, 整数型, 传址

.DLL命令 ReadProcessMemory_Bin, 整数型, "kernel32.dll", "ReadProcessMemory", , 在进程中读内存
    .参数 hProcess, 整数型
    .参数 lpBaseAddress, 整数型
    .参数 lpBuffer, 字节集, 传址
    .参数 nSize, 整数型
    .参数 lpNumberOfBytesWritten, 整数型, 传址

.DLL命令 ReadProcessMemory_BButton, 整数型, "kernel32.dll", "ReadProcessMemory", , 在进程中读内存
    .参数 hProcess, 整数型
    .参数 lpBaseAddress, 整数型
    .参数 lpBuffer, TBBUTTON, 传址
    .参数 nSize, 整数型
    .参数 lpNumberOfBytesWritten, 整数型, 传址

.DLL命令 ZwQuerySystemInformation_x, 整数型, "ntdll.dll", "ZwQuerySystemInformation"
    .参数 SystemInformationClass, 整数型, , 未知类型：SYSTEM_INFORMATION_CLASS。
    .参数 SystemInformation, 字节集, , any
    .参数 SystemInformationLength, 整数型
    .参数 ReturnLength, 整数型, 传址

.DLL命令 取指针_字节集, 整数型, "Kernel32.dll", "lstrcpyn", 公开, 常规API
    .参数 欲取其指针, 字节集, 传址
    .参数 欲取其指针, 字节集, 传址
    .参数 保留, 整数型, , 0

.DLL命令 RtlMoveMemory_整数传址1, 整数型, "kernel32.dll", "RtlMoveMemory", 公开, 常规API,从地址读一个整数
    .参数 dest, 整数型, 传址
    .参数 Source, 整数型
    .参数 len, 整数型, , 4

.DLL命令 ZwOpenProcess, 整数型, "ntdll.dll", "ZwOpenProcess", 公开
    .参数 hProcess, 整数型, 传址
    .参数 DesiredAccess, 整数型
    .参数 ObjectAttributes, OBJECT_ATTRIBUTES
    .参数 ClientId, CLIENT_ID

.DLL命令 RtlMoveMemory_SYSTEM_HANDLE_TABLE_ENTRY_INFO, 整数型, "kernel32.dll", "RtlMoveMemory", , SYSTEM_HANDLE_TABLE_ENTRY_INFO
    .参数 dest, SYSTEM_HANDLE_TABLE_ENTRY_INFO
    .参数 Source, 整数型
    .参数 len, 整数型, , 284

.DLL命令 ZwDuplicateObject, 整数型, "ntdll.dll", "ZwDuplicateObject", 公开
    .参数 SourceProcessHandle, 整数型
    .参数 SourceHandle, 整数型
    .参数 TargetProcessHandle, 整数型
    .参数 TargetHandle, 整数型, 传址
    .参数 DesiredAccess, 整数型
    .参数 HandleAttributes, 整数型
    .参数 Options, 整数型

.DLL命令 ZwCreateJobObject, 整数型, "ntdll.dll", "ZwCreateJobObject", 公开
    .参数 JobHandle, 整数型, 传址
    .参数 DesiredAccess, 整数型
    .参数 ObjectAttributes, OBJECT_ATTRIBUTES

.DLL命令 ZwAssignProcessToJobObject, 整数型, "ntdll.dll", "ZwAssignProcessToJobObject", 公开
    .参数 JobHandle, 整数型
    .参数 ProcessHandle, 整数型

.DLL命令 ZwTerminateJobObject, 整数型, "ntdll.dll", "ZwTerminateJobObject", 公开
    .参数 JobHandle, 整数型
    .参数 ExitStatus, 整数型

.DLL命令 ZwTerminateProcess, 整数型, "ntdll.dll", "ZwTerminateProcess", 公开
    .参数 ProcessHandle, 整数型
    .参数 ExitStatus, 整数型

.DLL命令 ZwClose, 整数型, "ntdll.dll", "ZwClose", 公开
    .参数 hnd

.DLL命令 GetProcessImageFileNameA, 整数型, "psapi.dll", "GetProcessImageFileNameA", 公开
    .参数 hProcess, 整数型
    .参数 lpImageFileName, 文本型
    .参数 nSize, 整数型

.DLL命令 关闭内核对象_, 整数型, "kernel32.dll", "CloseHandle", 公开, $(b)非零表示成功，零表示失败
    .参数 对象句柄, 整数型, , hObject，欲关闭的一个对象的句柄

.DLL命令 QueryDosDeviceA, 整数型, "kernel32.dll", "QueryDosDeviceA", 公开
    .参数 lpDeviceName, 文本型
    .参数 lpTargetPath, 文本型
    .参数 ucchMax, 整数型

.DLL命令 RtlMoveMemory_IP_PER_ADAPTER_INFO, , "kernel32.dll", "RtlMoveMemory"
    .参数 Destination, IP_PER_ADAPTER_INFO, 传址
    .参数 Source, 整数型
    .参数 Length, 整数型

.DLL命令 GetPerAdapterInfo, 整数型, "IPHlpApi.dll", "GetPerAdapterInfo"
    .参数 IfIndex, 整数型
    .参数 pPerAdapterInfo, 字节集
    .参数 pOutBufLen, 整数型, 传址

.DLL命令 RtlMoveMemory_IP_ADAPTER_INFO, , "kernel32.dll", "RtlMoveMemory"
    .参数 Destination, IP_ADAPTER_INFO, 传址
    .参数 Source, 整数型
    .参数 Length, 整数型

.DLL命令 取变量地址_字节集, 整数型, "kernel32.dll", "lstrcpynA"
    .参数 变量, 字节集, 传址
    .参数 变量, 字节集, 传址
    .参数 保留, 整数型, , 0

.DLL命令 SetThreadContext, 整数型, "kernel32.dll", "SetThreadContext"
    .参数 hThread, 整数型
    .参数 lpContext, CONTEXT86, 传址

.DLL命令 Len_ish, 整数型, "kernel32.dll", "LocalSize"
    .参数 hMem, IMAGE_SECTION_HEADER, 传址

.DLL命令 RtlMoveMemory_IMAGE_SECTION_HEADER, , "kernel32.dll", "RtlMoveMemory"
    .参数 Dest, IMAGE_SECTION_HEADER, 传址
    .参数 Src, 字节型, 传址
    .参数 L, 整数型

.DLL命令 ZwUnmapViewOfSection, 整数型, "ntdll.dll", "ZwUnmapViewOfSection"
    .参数 hProcess, 整数型
    .参数 BaseAddress, 整数型, 传址

.DLL命令 ReadProcessMemory, 整数型, "kernel32.dll", "ReadProcessMemory"
    .参数 hProcess, 整数型
    .参数 lpBaseAddress, 整数型
    .参数 lpBuffer, 整数型, 传址
    .参数 nSize, 整数型
    .参数 lpNumberOfBytesWritten, 整数型, 传址

.DLL命令 WriteProcessMemory_整数35, 整数型, "kernel32.dll", "WriteProcessMemory"
    .参数 hProcess, 整数型
    .参数 lpBaseAddress, 整数型
    .参数 lpBuffer, 整数型, 传址
    .参数 nSize, 整数型
    .参数 lpNumberOfBytesWritten, 整数型, 传址

.DLL命令 WriteProcessMemory, 整数型, "kernel32.dll", "WriteProcessMemory"
    .参数 hProcess, 整数型
    .参数 lpBaseAddress, 整数型
    .参数 lpBuffer, 字节型, 传址
    .参数 nSize, 整数型
    .参数 lpNumberOfBytesWritten, 整数型, 传址

.DLL命令 GetThreadContext, 整数型, "kernel32.dll", "GetThreadContext"
    .参数 hThread, 整数型
    .参数 lpContext, CONTEXT86, 传址

.DLL命令 Len_inh, 整数型, "kernel32.dll", "LocalSize"
    .参数 hMem, IMAGE_NT_HEADERS, 传址

.DLL命令 RtlMoveMemory_IMAGE_NT_HEADERS, , "kernel32.dll", "RtlMoveMemory"
    .参数 Dest, IMAGE_NT_HEADERS, 传址
    .参数 Src, 字节型, 传址
    .参数 L, 整数型

.DLL命令 Len_idh, 整数型, "kernel32.dll", "LocalSize"
    .参数 hMem, IMAGE_DOS_HEADER, 传址

.DLL命令 RtlMoveMemory_IMAGE_DOS_HEADER, , "kernel32.dll", "RtlMoveMemory", 公开
    .参数 Dest, IMAGE_DOS_HEADER, 传址
    .参数 Src, 字节型, 传址
    .参数 L, 整数型

.DLL命令 CoCreateGuid, , "ole32.dll", "CoCreateGuid", 公开
    .参数 guid, 字节集

.DLL命令 RtlMoveMemory_字节集传址1, , "kernel32.dll", "RtlMoveMemory", 公开, 内存拷贝
    .参数 Destination, 字节集, 传址
    .参数 字节集指针, 整数型
    .参数 数据长度, 整数型

.DLL命令 HeapDestroy, 逻辑型, "Kernel32.dll", "HeapDestroy", 公开, 释放堆
    .参数 hHeap, 整数型, , 堆句柄

.DLL命令 HeapCreate, 整数型, "kernel32.dll", "HeapCreate", 公开, 创建一个堆
    .参数 dwFlags, 整数型, , 创建方式 内存块标志。 为1 不检测独占
    .参数 len, 整数型, , 默认大小
    .参数 Exlen, 整数型, , 扩展大小 0为无限制

.DLL命令 InitializeCriticalSection_临界许可, , "kernel32.dll", "InitializeCriticalSection", 公开, 创建许可证
    .参数 lpCriticalSection, 临界许可, 传址

.DLL命令 DeleteCriticalSection_临界许可, 整数型, "kernel32.dll", "DeleteCriticalSection", 公开, 销毁许可证
    .参数 lpCriticalSection, 临界许可, 传址

.DLL命令 EnterCriticalSection_临界许可, , "kernel32.dll", "EnterCriticalSection", 公开, 进入许可区
    .参数 lpCriticalSection, 临界许可, 传址

.DLL命令 LeaveCriticalSection_临界许可, , "kernel32.dll", "LeaveCriticalSection", 公开, 退出许可区
    .参数 lpCriticalSection, 临界许可, 传址

.DLL命令 RtlMoveMemory_Eint_int, 逻辑型, "kernel32.dll", "RtlMoveMemory", 公开, 移动内存
    .参数 Dest, 整数型, , 目标地址
    .参数 Src, 整数型, 传址, 原地址
    .参数 length, 整数型, , 长度

.DLL命令 RtlMoveMemory_Ebin_int, 逻辑型, "kernel32.dll", "RtlMoveMemory", 公开, 移动内存
    .参数 Dest, 整数型, , 目标地址
    .参数 Src, 字节集, 传址, 原地址
    .参数 length, 整数型, , 长度

.DLL命令 RtlMoveMemory_Estr_int, 逻辑型, "kernel32.dll", "RtlMoveMemory", 公开, 移动内存
    .参数 Dest, 整数型, , 目标地址
    .参数 Src, 文本型, 传址, 原地址
    .参数 length, 整数型, , 长度

.DLL命令 AccessibleChildren, 整数型, "OLEACC.DLL", "AccessibleChildren", 公开
    .参数 paccContainer, 整数型
    .参数 iChildStart, 整数型
    .参数 cChildren, 整数型
    .参数 rgvarChildren, 变体型, 数组
    .参数 pcObtained, 整数型, 传址

.DLL命令 AccessibleObjectFromWindow, 整数型, "OLEACC.DLL", "AccessibleObjectFromWindow", 公开
    .参数 hwnd, 整数型
    .参数 dwId, 整数型
    .参数 riid, 字节集
    .参数 ppvObject, 整数型

.DLL命令 RtlMoveMemory_obj2pint, , "kernel32.dll", "RtlMoveMemory", 公开
    .参数 Destination, 整数型, 传址
    .参数 Source, 对象
    .参数 Length, 整数型

.DLL命令 GetStateText, 整数型, "OLEACC.DLL", "GetStateTextA", 公开
    .参数 lStateBit, 整数型
    .参数 lpszState, 文本型
    .参数 cchState, 整数型

.DLL命令 GetStateText_int, 整数型, "OLEACC.DLL", "GetStateTextA", 公开
    .参数 lStateBit, 整数型
    .参数 lpszState, 整数型
    .参数 cchState, 整数型

.DLL命令 GetRoleText, 整数型, "OLEACC.DLL", "GetRoleTextA", 公开
    .参数 lRole, 整数型
    .参数 lpszRole, 文本型
    .参数 cchRoleMax, 整数型

.DLL命令 GetRoleText_int, 整数型, "OLEACC.DLL", "GetRoleTextA", 公开
    .参数 lRole, 整数型
    .参数 lpszRole, 整数型
    .参数 cchRoleMax, 整数型

.DLL命令 WindowFromAccessibleObject, , "OLEACC.DLL", "WindowFromAccessibleObject", 公开
    .参数 TIAccessible, 整数型
    .参数 phwnd, 整数型, 传址

.DLL命令 AccessibleObjectFromPoint, 整数型, "OLEACC.DLL", "AccessibleObjectFromPoint", 公开
    .参数 ptScreenx, 整数型
    .参数 ptScreeny, 整数型
    .参数 ppacc, 整数型
    .参数 pvarChild, 变体型, 传址

.DLL命令 BlockInput, 整数型, "user32.dll", "BlockInput", 公开
    .参数 fBlock, , , 1.锁定，0.解除

.DLL命令 GetShortPathName, 整数型, "kernel32.dll", "GetShortPathNameA", 公开
    .参数 lpszLongPath, 文本型
    .参数 lpszShortPath, 文本型
    .参数 cchBuffer, 整数型

.DLL命令 mciSendString, 整数型, "winmm.dll", "mciSendStringA"
    .参数 lpstrCommand, 文本型
    .参数 lpstrReturnString, 文本型
    .参数 uReturnLength, 整数型
    .参数 hwndCallback, 整数型

.DLL命令 CryptDecrypt_x, 逻辑型, "advapi32.dll", "CryptDecrypt"
    .参数 hKey, 整数型
    .参数 hHash, 整数型
    .参数 Final, 逻辑型
    .参数 dwFlags, 整数型
    .参数 pbData, 字节集, 传址
    .参数 pdwDataLen, 整数型, 传址

.DLL命令 CryptEncrypt_x, 逻辑型, "advapi32.dll", "CryptEncrypt"
    .参数 hKey, 整数型
    .参数 hHash, 整数型
    .参数 Final, 逻辑型
    .参数 dwFlags, 整数型
    .参数 pbData, 字节集, 传址
    .参数 pdwDataLen, 整数型, 传址
    .参数 dwBufLen, 整数型

.DLL命令 CryptGetHashParam_x, 逻辑型, "advapi32.dll", "CryptGetHashParam"
    .参数 hHash, 整数型
    .参数 dwParam, 整数型
    .参数 pByte, 整数型
    .参数 pdwDataLen, 整数型, 传址
    .参数 dwFlags, 整数型

.DLL命令 CryptHashData_x, 逻辑型, "advapi32.dll", "CryptHashData", 公开
    .参数 hHash, 整数型
    .参数 pbData, 字节集, 传址
    .参数 dwDataLen, 整数型
    .参数 dwFlags, 整数型

.DLL命令 CryptReleaseContext_x, 逻辑型, "advapi32.dll", "CryptReleaseContext", 公开
    .参数 hProv, 整数型
    .参数 dwFlags, 整数型

.DLL命令 CryptCreateHash_x, 逻辑型, "advapi32.dll", "CryptCreateHash", 公开
    .参数 hProv, 整数型
    .参数 Algid, 整数型
    .参数 hKey, 整数型
    .参数 dwFlags, 整数型
    .参数 phHash, 整数型, 传址

.DLL命令 CryptAcquireContext_x, 逻辑型, "advapi32.dll", "CryptAcquireContextA", 公开
    .参数 phProv, 整数型, 传址
    .参数 pszContainer, 文本型
    .参数 pszProvider, 文本型
    .参数 dwProvType, 整数型
    .参数 dwFlags, 整数型

.DLL命令 CryptGetKeyParam, 逻辑型, "advapi32.dll", "CryptGetKeyParam"
    .参数 hKey, 整数型
    .参数 dwParam, 整数型
    .参数 pbData, 字节集, 传址
    .参数 pdwDataLen, 整数型, 传址
    .参数 dwFlags, 整数型

.DLL命令 CryptSetKeyParam, 逻辑型, "advapi32.dll", "CryptSetKeyParam"
    .参数 hKey, 整数型
    .参数 dwParam, 整数型
    .参数 pbData, 字节集
    .参数 dwFlags, 整数型

.DLL命令 取得物理字体信息_, 整数型, "gdi32.dll", "GetTextMetricsA"
    .参数 设备场景, 整数型
    .参数 属性信息, 物理字体属性信息_

.DLL命令 CryptImportKey, 逻辑型, "advapi32.dll", "CryptImportKey"
    .参数 hProv, 整数型
    .参数 pbData, 字节集
    .参数 dwDataLen, 整数型
    .参数 hPubKey, 整数型
    .参数 dwFlags, 整数型
    .参数 phKey, 整数型, 传址

.DLL命令 SetMapMode, 整数型, "gdi32.dll", "SetMapMode", , 设置指定设备场景的映射模式  执行成功为设备场景原来的映射模式，失败为0
    .参数 hdc, 整数型, , 设备场景句柄
    .参数 nMapMode, 整数型, , 下列常数之一：;MM_ANISOTROPIC：视口和窗口范围可完全任意;MM_HIENGLISH：逻辑单元为0.001 inch，起点在左下角;MM_HIMETRIC：逻辑单元为0.01 millimeter，起点在左下角;MM_ISOTROPIC：视口和窗口范围任意，只是x和y逻辑单元尺寸要相同;MM_LOENGLISH：逻辑单元为0.01 inch，起点在左下角;MM_HIMETRIC：逻辑单元为0.1 millimeter，起点在左下角;MM_TEXT：逻辑单元为一个像素;MM_TWIPS：逻辑单元为1 twip (1/1440 inch)，起点在左下角;

.DLL命令 取屏幕句柄_, 整数型, "user32.dll", "GetDesktopWindow"

.DLL命令 取窗口全部设备场景_, 整数型, "user32.dll", "GetWindowDC"
    .参数 窗口句柄, 整数型

.DLL命令 释放设备场景_, 整数型, "user32.dll", "ReleaseDC", , ReleaseDC
    .参数 窗口句柄, 整数型, , hwnd，要释放的设备场景相关的窗口句柄
    .参数 设备场景, 整数型, , hdc，要释放的设备场景句柄

.DLL命令 NtReadVirtualMemory_Bin, 整数型, "ntdll.dll", "NtReadVirtualMemory", 公开
    .参数 句柄, 整数型
    .参数 地址, 整数型
    .参数 缓冲区, 字节集
    .参数 读取长度, 整数型
    .参数 实际读取长度, 整数型, 传址

.DLL命令 ZwQueryInformationProcess, 整数型, "NTDLL.DLL", "ZwQueryInformationProcess"
    .参数 ProcessHandle, 整数型
    .参数 ProcessInformationClass, 整数型
    .参数 ProcessInformation, PROCESS_BASIC_INFORMATION
    .参数 ProcessInformationLength, 整数型
    .参数 ReturnLength, 整数型, 传址

.DLL命令 LookupAccountSidA, 逻辑型, "Advapi32.dll", "LookupAccountSidA"
    .参数 lpSystemName, 整数型
    .参数 Sid, 整数型
    .参数 Name, 整数型
    .参数 cchName, 整数型, 传址
    .参数 ReferencedDomainName, 整数型
    .参数 cchReferencedDomainName, 整数型, 传址
    .参数 peUse, 整数型, 传址

.DLL命令 WinStationGetProcessSid, 整数型, "Winsta.dll", "WinStationGetProcessSid"
    .参数 hServer, 整数型
    .参数 ProcessId, 整数型
    .参数 ProcessStartTime, 长整数型
    .参数 pProcessUserSid, 整数型
    .参数 dwSidSize, 整数型, 传址

.DLL命令 RtlMoveMemory_SYSTEM_PROCESSES, , "kernel32.dll", "RtlMoveMemory"
    .参数 Destination, SYSTEM_PROCESS_INFORMATION_ex
    .参数 Source, 整数型
    .参数 Length, 整数型

.DLL命令 NtWow64QueryInformationProcess64_Basic, 整数型, "ntdll.dll", "NtWow64QueryInformationProcess64"
    .参数 hProcess, 整数型
    .参数 ProcessInfoclass, 整数型
    .参数 pBuffer, PROCESS_BASIC_INFORMATION64
    .参数 nSize, 整数型
    .参数 nReturnSize, 整数型

.DLL命令 NtWow64ReadVirtualMemory64_LDR, 整数型, "ntdll.dll", "NtWow64ReadVirtualMemory64"
    .参数 hProcess, 整数型
    .参数 pMemAddress, 长整数型
    .参数 pBuffer, PEB_LDR_DATA
    .参数 nSize, 长整数型
    .参数 nReturnSize, 整数型

.DLL命令 NtWow64ReadVirtualMemory64_Process, 整数型, "ntdll.dll", "NtWow64ReadVirtualMemory64"
    .参数 hProcess, 整数型
    .参数 pMemAddress, 长整数型
    .参数 pBuffer, RTL_USER_PROCESS_PARAMETERS
    .参数 nSize, 长整数型
    .参数 nReturnSize, 整数型

.DLL命令 NtWow64ReadVirtualMemory64_bin, 整数型, "ntdll.dll", "NtWow64ReadVirtualMemory64"
    .参数 hProcess, 整数型
    .参数 pMemAddress, 长整数型
    .参数 pBuffer, 字节集
    .参数 nSize, 长整数型
    .参数 nReturnSize, 整数型

.DLL命令 lms520_SendMessageTimeout, 整数型, "user32.dll", "SendMessageTimeoutA", , SendMessageTimeout，Long，成功时返回TRUE，失败时返回FALSE。会设置GetLastError
    .参数 窗口句柄, 整数型, , hwnd，要接收消息的一个窗口的句柄
    .参数 标识符, 整数型, , msg，消息的标识符
    .参数 消息1, 整数型, , wparam，由消息决定
    .参数 消息2, 整数型, , lparam，由消息决定
    .参数 类型, 整数型, , fuflags，下述常数的一个或多个SMTO_ABORTIFHUNG如目标进程挂起，则函数立即返回
    .参数 超时值, 整数型, , utimeout，超时值，采用毫秒为单位
    .参数 结果, 整数型, , lpdwresult，用于装载函数结果的一个变量

.DLL命令 GetQueuedCompletionStatus, 整数型, "kernel32.dll", "GetQueuedCompletionStatus", 公开, 函数有个OVERLAPPED结构，很多资料上都采用不同的结构体来扩展该结构，比如有的资料定义：
    .参数 CompletionPort, 整数型
    .参数 lpNumberOfBytesTransferred, 整数型, 传址
    .参数 lpCompletionKey, 整数型, 传址
    .参数 lpOverlapped, 整数型, 传址
    .参数 dwMilliseconds, 整数型

.DLL命令 SHChangeNotify, , "shell32.dll", "SHChangeNotify", 公开, 刷新关联图标
    .参数 SHCNE_ASSOCCHANGED, 整数型, , 134217728
    .参数 SHCNF_IDLIST, 整数型, , 0
    .参数 nil, 整数型, , 0
    .参数 nil, 整数型, , 0

.DLL命令 ScreenToClient, 整数型, "user32.dll", "ScreenToClient", , 该函数把屏幕上指定点的屏幕坐标转换成用户坐标。 判断屏幕上一个指定点的客户区坐标　非零表示成功，零表示失败
    .参数 hwnd, 整数型, , 一个窗口的句柄，该窗口定义了要使用的客户区坐标系统
    .参数 lpPoint, 精易_坐标, , POINTAPI，屏幕坐标系统中包含了屏幕点的结构。这个函数会随同相应的客户区坐标（由hwnd决定）载入结构;

.DLL命令 ChildWindowFromPointEx, 整数型, "user32.dll", "ChildWindowFromPointEx", , 返回父窗口中包含了指定点的第一个子窗口的句柄   
    .参数 hWnd, 整数型, , 说明 http://topic.csdn.net/t/20021107/17/1157529.html
    .参数 x, 整数型
    .参数 y, 整数型
    .参数 un, 整数型, , CWP_ALL(0) = 测试所有窗口

.DLL命令 GetFileTitleA, 整数型, "Comdlg32.dll", "GetFileTitleA", 公开
    .参数 lpszFile, 文本型
    .参数 lpszTitle, 文本型
    .参数 cbBuf, 整数型

.DLL命令 CreateIoCompletionPort, 整数型, "kernel32.dll", "CreateIoCompletionPort", 公开, 函数关联一个已打开的文件实例和新建的或已存在的I/0完成端口，或者创建一个未关联任何文件的I/O完成端口。
    .参数 Handle, 整数型
    .参数 ExistingCompletionPort, 整数型
    .参数 CompletionKey, 整数型
    .参数 NumberOfConcurrentThreads, 整数型

.DLL命令 PostQueuedCompletionStatus, 整数型, "kernel32.dll", "PostQueuedCompletionStatus", 公开, 在进行重叠I/O操作的同时，强行释放一个OVERLAPPED结构，最好的方法是针对每一个套接字句柄，调用CloseSocket函数。任何尚未进行的重叠I/O操作都会完成。一旦所有套接字关闭，便需在完成端口上，终止所有工作者线程。这时候需要使用PostQueuedCompletionStatus 。
    .参数 CompletionPort, 整数型
    .参数 dwNumberOfBytesTransferred, 整数型
    .参数 dwCompletionKey, 整数型
    .参数 lpOverlapped, 整数型

.DLL命令 RemovePropA, 整数型, "user32.dll", "RemovePropA", 公开, 该函数从指定的窗口的属性表中删除一项。指定的字符串标识了要删除的项。 
    .参数 hWnd, 整数型, , 指向要改变属性项的窗口的句柄。
    .参数 lpString, 文本型, , 指向以null结尾的字符串指针，或者包含一个标识字符串的原子。如果该参数是一个原子，那么它必须是使用AddAtom函数创建的。原子是16位的数据值，它必须是放置在lpString参数的低位字中， 

.DLL命令 SetPropA, 逻辑型, "user32.dll", "SetPropA", 公开, 该函数在指定窗口的属性表中增加一个新项，或者修改一个现有项。如果指定的字符串不在属性表中，那么就增加该新的项，新项中包含该字符串和句柄，否则就用指定的句柄替换该字符串的全前句柄。 
    .参数 hWnd, 整数型, , 指向窗口的句柄，该窗口的属性表要接收一个新项。 
    .参数 lpString, 文本型, , 指向以null结尾的字符串指针，或者包含一个标识字符串的原子。如果该参数是一个原子，么它必须是以前使用GlobalAddAtom函数创建的。原子是16位的数据值，它必须是放置在lpstring参数低位字中，而高位字必须为O。 
    .参数 hData, 整数型, , 指向要拷贝到属性表中的数据的句柄。该数据句柄可以标识任何对应用程序有用的值。 

.DLL命令 GetPropA, 整数型, "user32.dll", "GetPropA", 公开, 该函数从给定窗口的属性列表中检索数据句柄。给定的字符串标识了要检索的句柄。该字符串和句柄必须在前一次调用SetProp函数时已经加到属性表中。 
    .参数 hWnd, 整数型, , 指向要搜索属性表的窗口。 返回值：如果属性表中包含了给定的字符串，那么返回值为相关的数据句柄。否则，返回值为NULL。
    .参数 lpString, 文本型, , 指向以null结尾的字符串指针，或者包含一个标识字符串的原子。如果该参数是一个原子，那么它必须是使用GlobalAddAtom函数创建的。原子是16位的数据值，它必须是放置在lpstring参数的低位率中，而高位字必须为O。 

.DLL命令 WriteFile, 逻辑型, "kernel32.dll", "WriteFile", 公开
    .参数 hFile, 整数型, , 一个文件的句柄
    .参数 lpBuffer, 字节集, , 要写入的一个数据缓冲区
    .参数 nNumberOfBytesToWrite, 整数型, , 要写入数据的字节数量。如写入零字节，表示什么都不写入，但会更新文件的“上一次修改时间”。针对位于远程系统的命名管道，限制在65535个字节以内
    .参数 lpNumberOfBytesWritten, 整数型, 传址, 实际写入文件的字节数量
    .参数 lpOverlapped, 整数型

.DLL命令 GetScrollPos, 整数型, "user32.dll", "GetScrollPos", 公开
    .参数 hWnd, 整数型
    .参数 nBar, 整数型

.DLL命令 DeleteUrlCacheEntry, , "wininet.dll", "DeleteUrlCacheEntry", 公开, ,删除Url缓存入口_
    .参数 Url名称, 文本型, , lpszUrlName

.DLL命令 FindFirstUrlCacheEntryA, 整数型, "wininet.dll", "FindFirstUrlCacheEntryA", 公开, 寻找第一个Url缓存入口_
    .参数 寻找样式, 文本型, , lpszUrlSearchPattern
    .参数 第一个Url缓存入口信息, 字节集, , lpFirstCacheEntryInfo
    .参数 第一个Url缓存入口信息大小, 整数型, 传址, lpdwFirstCacheEntryInfoBufferSize

.DLL命令 FindNextUrlCacheEntryA, 整数型, "wininet.dll", "FindNextUrlCacheEntryA", 公开, 寻找下一个Url缓存入口_
    .参数 下一个Url缓存入口信息, 整数型, , lpNextCacheEntryInfo
    .参数 lpNextCacheEntryInfo, 字节集, , Any型,根据需要可以设置成不同的类型
    .参数 下一个Url缓存入口信息大小, 整数型, 传址, lpdwNextCacheEntryInfoBufferSize

.DLL命令 FindCloseUrlCache, 整数型, "wininet.dll", "FindCloseUrlCache", 公开, 关闭寻找缓存_
    .参数 枚举句柄, 整数型, , hEnumHandle

.DLL命令 SHFileOperationA, 整数型, "Shell32.dll", "SHFileOperationA", 公开
    .参数 文件参数, SHFILEOPSTRUCT

.DLL命令 SHFileOperationW, 整数型, "Shell32.dll", "SHFileOperationW"
    .参数 lpFileOp, SHFILEOPSTRUCT

.DLL命令 gethostbyname, 整数型, "ws2_32.dll", "gethostbyname", 公开, 成功返回内存指针
    .参数 name, 文本型, , 机器名称

.DLL命令 UpdateWindow, 整数型, "user32.dll", "UpdateWindow", 公开, 强制立即更新窗口，窗口中以前屏蔽的所有区域都会重画（在vb里使用：如vb窗体或控件的任何部分需要更新，可考虑直接使用refresh方法  非零表示成功，零表示失败
    .参数 hwnd, 整数型, , 欲更新窗口的句柄;

.DLL命令 gethostname, 整数型, "ws2_32.dll", "gethostname", 公开, 取本机名，失败返回-1，成功返回0。
    .参数 name, 文本型, 传址, 给变量，用于存放名称
    .参数 namelen, 整数型, , 上一个参数的长度

.DLL命令 sendto, 整数型, "ws2_32.dll", "sendto", 公开, 发送数据(UDP)
    .参数 s, 整数型, , 套接字描述符
    .参数 buf, 字节集, 传址, 数据
    .参数 len, 整数型, , 数据长度
    .参数 flags, 整数型, , 0
    .参数 to, 套接字地址, 传址, 目标地址信息
    .参数 tolen, 整数型, , 地址信息长度

.DLL命令 recvfrom, 整数型, "ws2_32.dll", "recvfrom", , 接收数据(UDP)
    .参数 s, 整数型, , 套接字描述符
    .参数 buf, 字节集, 传址, 数据(提供变量)
    .参数 len, 整数型, , 数据长度
    .参数 flags, 整数型, , 0
    .参数 from, 套接字地址, 传址, 来源地址信息(提供变量)
    .参数 fromlen, 整数型, 传址, 地址信息长度(提供变量)

.DLL命令 connect, 整数型, "ws2_32.dll", "connect", 公开, 连接到服务器(TCP)
    .参数 s, 整数型, , 网络通讯标识符
    .参数 name, 整数型, , 名称结构
    .参数 namelen, 整数型, , 名称结构长度

.DLL命令 select, 整数型, "ws2_32.dll", "select", 公开
    .参数 nfds, 整数型
    .参数 readfds, fd_set, 传址, 指向一组等待可读性检查的套接口
    .参数 writefds, fd_set, 传址, 指向一组等待可写性检查的套接口
    .参数 exceptfds, fd_set, 传址, 指向一组等待错误检查的套接口
    .参数 timeout, 整数型, 传址

.DLL命令 InternetOpenUrlA, 整数型, "wininet.dll", "InternetOpenUrlA", 公开
    .参数 Internet句柄, 整数型
    .参数 Url地址, 文本型
    .参数 头文本, 文本型
    .参数 头文本长度, 整数型
    .参数 标志, 整数型
    .参数 定义值, 整数型

.DLL命令 WSAAsyncSelect, 整数型, "ws2_32.dll", "WSAAsyncSelect", 公开, 异步选择_ 本函数自动将套接口设置为非阻塞模式  0  表明是成功的
    .参数 网络通讯标识符, 整数型, , s标识一个需要事件通知的套接口的描述符
    .参数 窗口句柄, 整数型, , hWnd标识一个在网络事件发生时需要接收消息的窗口句柄
    .参数 消息值, 整数型, , wMsg在网络事件发生时要接收的消息
    .参数 事件, 整数型, , lEvent位屏蔽码,用于指明应用程序感兴趣的网络事件集合.

.DLL命令 getpeername, 整数型, "ws2_32.dll", "getpeername", 公开, 获取远端信息（已连接对方IP和端口）。成功返回0
    .参数 句柄, 整数型
    .参数 name, 套接字地址, 传址, 地址信息
    .参数 namelen, 整数型, 传址, name长度,Sockaddr_in长度为16

.DLL命令 GetsockName, 整数型, "ws2_32.dll", "getsockname", 公开, 获取本地接口的地址信息（IP和端口）。成功返回0
    .参数 s, 整数型, , 句柄
    .参数 name, 套接字地址, 传址, 地址信息
    .参数 namelen, 整数型, 传址, name长度,Sockaddr_in长度为16

.DLL命令 recv_字节集, 整数型, "ws2_32.dll", "recv", 公开, 接收字节集数据(TCP，当数据这次未接收完时返回剩余字节数)
    .参数 网络通讯标识符, 整数型, , s
    .参数 缓冲区, 字节集, 传址, buf数据(提供变量)
    .参数 缓冲区长度, 整数型, , lLen
    .参数 标志, 整数型, , flags

.DLL命令 recv_文本型, 整数型, "ws2_32.dll", "recv", , 接收字节集数据(TCP，当数据这次未接收完时返回剩余字节数)
    .参数 网络通讯标识符, 整数型, , s
    .参数 缓冲区, 文本型, 传址, buf数据(提供变量)
    .参数 缓冲区长度, 整数型, , lLen
    .参数 标志, 整数型, , flags

.DLL命令 send, 整数型, "ws2_32.dll", "send", 公开, 已发送长度
    .参数 s, 整数型, , 套接字
    .参数 buf, 整数型, , 封包指针
    .参数 len, 整数型, , 封包长度
    .参数 flags, 整数型, , 标志0

.DLL命令 ntohs, 短整数型, "ws2_32.dll", "ntohs", 公开, 转换为端口号-网络转换到本机
    .参数 十六位网络端口, 短整数型, , netshort欲转换值

.DLL命令 inet_ntoa, 整数型, "ws2_32.dll", "inet_ntoa", 公开, 将整数格式IP地址转换为点数格式（返回值是内存地址指针）
    .参数 网络地址, 整数型, , lIn欲转换整数格式IP地址

.DLL命令 accept, 整数型, "ws2_32.dll", "accept", 公开, 等待用户进入并接受连接
    .参数 s, 整数型, , 套接字描述符
    .参数 addr, 套接字地址, 传址, 地址信息
    .参数 addrlen, 整数型, 传址, 地址信息长度（长度为16）

.DLL命令 listen, 整数型, "ws2_32.dll", "listen", 公开, 监听
    .参数 sockfd, 整数型, , 套接字描述符
    .参数 backlog, 整数型, , 最多容纳客户请求数

.DLL命令 bind, 整数型, "ws2_32.dll", "bind", 公开, 绑定一个地址和端口
    .参数 套接字描述符, 整数型
    .参数 地址结构, 套接字地址, 传址, 地址信息
    .参数 结构大小, 整数型, , 地址信息长度(长度16

.DLL命令 htons, 短整数型, "ws2_32.dll", "htons", 公开, 转换为network 排列方式的数目
    .参数 十六位主机命令, 短整数型, , hostshort端口号

.DLL命令 socket, 整数型, "ws2_32.dll", "socket", 公开, 创建套接字
    .参数 协议族, 整数型, , af使用的通信协议的协议族
    .参数 类型, 整数型, , lType流套接字类型
    .参数 协议, 整数型, , protocol使用的通信协议

.DLL命令 closesocket, 整数型, "ws2_32.dll", "closesocket", 公开, 销毁套接字
    .参数 套接字描述符, 整数型

.DLL命令 WSACleanup, 整数型, "ws2_32.dll", "WSACleanup", 公开, 卸载Winsocket服务

.DLL命令 WSAStartup, 整数型, "ws2_32.dll", "WSAStartup", 公开, 初始化WnSocket服务
    .参数 必需版本, 整数型, , wVersionRequired
    .参数 服务信息, 套接字信息, , lpWSAData

.DLL命令 SendARP, 整数型, "IPHLPAPI.DLL", "SendARP", 公开
    .参数 目标IP, 整数型
    .参数 本机IP, 整数型
    .参数 MAC缓冲, 字节型, 传址 数组
    .参数 长度, 整数型, 传址

.DLL命令 inet_addr, 整数型, "ws2_32.dll", "inet_addr", 公开
    .参数 IP, 文本型

.DLL命令 IsWow64Process_a, 整数型, "kernel32.dll", "IsWow64Process"
    .参数 hProcess, 整数型
    .参数 Wow64Process, 整数型, 传址

.DLL命令 IsWow64Process, 逻辑型, "kernel32.dll", "IsWow64Process", 公开
    .参数 hProcess, 整数型
    .参数 Wow64Process, 逻辑型, 传址

.DLL命令 QueryPerformanceFrequency, 整数型, "kernel32.dll", "QueryPerformanceFrequency", 公开, 返回计数频率
    .参数 lpFrequency, 长整数型, 传址

.DLL命令 QueryPerformanceCounter, 整数型, "kernel32.dll", "QueryPerformanceCounter", 公开, 获取计数值
    .参数 lpPerformanceCount, 长整数型, 传址

.DLL命令 ActivateKeyboardLayout, 整数型, "user32.dll", "ActivateKeyboardLayout", 公开, 输入法激活
    .参数 hkl, 整数型
    .参数 flags, 整数型

.DLL命令 ImmInstallIMEA, 整数型, "imm32.dll", "ImmInstallIMEA", 公开, 安装输入法
    .参数 文件名, 文本型
    .参数 输入法名称, 文本型

.DLL命令 UnloadKeyboardLayout, 整数型, "user32.dll", "UnloadKeyboardLayout", 公开, 缷载已有的键盘布局，成功则返回键盘布局句柄，失败返回0。
    .参数 HKL, 整数型, , 键盘布局句柄

.DLL命令 GetKeyboardLayoutList, 整数型, "user32.dll", "GetKeyboardLayoutList", 公开, 获得系统适用的所有键盘布局的一个列表，成功则返回键盘布局数量，失败返回0。
    .参数 nBuff, 整数型, , 如设为0，表示获取可用键盘布局的最大数量
    .参数 lpList, 整数型, 数组, 缓存数组指针，这个数组会随同句柄载入可用的键盘布局。

.DLL命令 LoadKeyboardLayoutA, 整数型, "user32.dll", "LoadKeyboardLayoutA", 公开, 载入一个键盘布局，并返回键盘布局句柄。0表示出错。
    .参数 pwszKLID, 文本型, , 一个8字符字串，用于描述键盘布局的名称。
    .参数 flags, 整数型, , 参考“KLF”常量。

.DLL命令 IMESetPubString, , "imedllhost09.ime", "IMESetPubString", 公开, 输入法注入
    .参数 dll文件名, 文本型, , 要注入的dll
    .参数 是否退出时卸载, 整数型, , 输入法退出时是否同时卸载注入的DLL（0-是，1-否）
    .参数 是否自动切换, 整数型, , 当切换到目标输入法时自动切换到下一个输入法（0-否，1-是）
    .参数 参数一, 整数型, , 0
    .参数 参数二, 整数型, , 0
    .参数 参数三, 整数型, , 0

.DLL命令 IMEClearPubString, 逻辑型, "imedllhost09.ime", "IMEClearPubString", 公开, 输入法停止注入

.DLL命令 RtlMoveMemory_MSG2, , "kernel32.dll", "RtlMoveMemory"
    .参数 Destination, 整数型
    .参数 Source, MSG, 传址
    .参数 Length, 整数型

.DLL命令 RtlMoveMemory_MSG1, , "kernel32.dll", "RtlMoveMemory"
    .参数 Destination, MSG, 传址
    .参数 Source, 整数型
    .参数 Length, 整数型

.DLL命令 GetGUIThreadInfo, 整数型, "user32.dll", "GetGUIThreadInfo", 公开, 　
    .参数 idThread, 整数型
    .参数 pgui, PGUITHREADINFO, 传址

.DLL命令 GetAsyncKeyState, 整数型, "user32.dll", "GetAsyncKeyState", 公开, 取键状态
    .参数 键代码, 整数型, , vKey Long，欲测试的虚拟键的键码

.DLL命令 StretchBlt, , "gdi32.dll", "StretchBlt", 公开, 伸缩复制图象
    .参数 目标设备场景, 整数型
    .参数 目标位置横坐标, 整数型
    .参数 目标位置纵坐标, 整数型
    .参数 目标图像宽, 整数型
    .参数 目标图像高, 整数型
    .参数 源设备场景, 整数型
    .参数 源位置横坐标, 整数型
    .参数 源位置纵坐标, 整数型
    .参数 源图像宽, 整数型
    .参数 源图像高, 整数型
    .参数 光栅运算, 整数型

.DLL命令 FindWindowA, 整数型, "user32.dll", "FindWindowA", 公开, 寻找窗口列表中第一个符合指定条件的顶级窗口
    .参数 窗口类名, 文本型
    .参数 窗口标题, 文本型

.DLL命令 GetAncestor, 整数型, "user32.dll", "GetAncestor", 公开, 取出指定窗口的最顶级父窗口
    .参数 hwnd, 整数型, , 子窗口句柄
    .参数 gaFlags, 整数型

.DLL命令 GetParent, 整数型, "user32.dll", "GetParent", 公开, 取父句柄
    .参数 hwnd, 整数型

.DLL命令 CallWindowProcA, 整数型, "user32.dll", "CallWindowProcA", 公开
    .参数 窗口程序指针, 整数型
    .参数 hwnd, 整数型
    .参数 消息值, 整数型
    .参数 参数1, 整数型
    .参数 参数2, 整数型

.DLL命令 CallWindowProcW, 整数型, "User32.dll", "CallWindowProcW"
    .参数 lpPrevWndFunc, 整数型
    .参数 hWnd, 整数型
    .参数 Msg, 整数型
    .参数 wParam, 整数型
    .参数 lParam, 整数型

.DLL命令 GetWindow, 整数型, "user32.dll", "GetWindow", 公开, 获得一个窗口的句柄，该窗口与某源窗口有特定的关系
    .参数 源窗口, 整数型
    .参数 关系, 整数型, , 0：为一个源子窗口寻找第一个兄弟（同级）窗口，或寻找第一个顶级窗口  1：为一个源子窗口寻找最后一个兄弟（同级）窗口，或寻找最后一个顶级窗口  2：为源窗口寻找下一个兄弟窗口  3：为源窗口寻找前一个兄弟窗口  4：寻找窗口的所有者  5：寻找源窗口的第一个子窗口

.DLL命令 MessageBoxA, 整数型, "user32.dll", "MessageBoxA", 公开, 显示和操作一个消息框。该消息框包含一个应用程序定义的消息和标题，加上预定义的图标和按钮的任意组合。 wLanguageId参数指定为预定义的按钮使用的语言资源集。
    .参数 hwnd, 整数型, , 要创建的消息框的所有者窗口的句柄。如果这个参数为NULL，则消息框没有所有者窗口
    .参数 neirong, 文本型
    .参数 title, 文本型
    .参数 nom, 整数型

.DLL命令 LoadLibraryA, 整数型, "kernel32.dll", "LoadLibraryA", 公开, 载入指定的动态链接库，并将它映射到当前进程使用的地址空间。成功则返回库模块的句柄，零表示失败。
    .参数 动态链接库路径, 文本型, , 指定要载入的动态链接库的名称(全路径)

.DLL命令 LoadLibraryW, 整数型, "kernel32.dll", "LoadLibraryW"
    .参数 lpLibFileName, 整数型

.DLL命令 FreeLibrary, 逻辑型, "kernel32.dll", "FreeLibrary", 公开, 释放动态链接库
    .参数 动态链接库句柄, 整数型, , 使用LoadLibraryA命令返回的

.DLL命令 GetProcAddress, 整数型, "kernel32.dll", "GetProcAddress", 公开, 取动态链接库函数入口地址
    .参数 模块句柄, 整数型, , 通过LoadLibraryA命令取得
    .参数 接口名称, 文本型

.DLL命令 GetLastInputInfo, 整数型, "User32.dll", "GetLastInputInfo", , 检索键盘与鼠标功能的最后一次输入事件
    .参数 plii, PLASTINPUTINFO

.DLL命令 GetTickCount, 整数型, "kernel32.dll", "GetTickCount"

.DLL命令 DoOrganizeFavDlg, 整数型, "shdocvw.dll", "DoOrganizeFavDlg", 公开, 整理收藏夹
    .参数 hwnd, 整数型
    .参数 root, 文本型

.DLL命令 DoAddToFavDlg, 逻辑型, "shdocvw.dll", "DoAddToFavDlg", 公开, 添加到收藏夹
    .参数 hwnd, 整数型
    .参数 网址, 文本型
    .参数 缓存大小, 整数型
    .参数 标题, 文本型
    .参数 缓存, 整数型
    .参数 pid, 整数型

.DLL命令 SHGetSpecialFolderLocation, 整数型, "shell32.dll", "SHGetSpecialFolderLocation", 公开, 取收藏夹PID
    .参数 hwnd, 整数型
    .参数 type, 整数型
    .参数 pid, 整数型, 传址

.DLL命令 CoTaskMemFree, 整数型, "ole32.dll", "CoTaskMemFree", , 清除PID
    .参数 pid, 整数型

.DLL命令 CreateWaitableTimerA, 整数型, "kernel32.dll", "CreateWaitableTimerA", 公开, 程序延时
    .参数 lpTimerAttributes, 整数型
    .参数 bManualReset, 逻辑型
    .参数 lpTimerName, 整数型

.DLL命令 SetWaitableTimer, 整数型, "kernel32.dll", "SetWaitableTimer", 公开
    .参数 hTimer, 整数型
    .参数 pDueTime, 程序延时
    .参数 lPeriod, 整数型
    .参数 pfnCompletionRoutine, 整数型
    .参数 lpArgToCompletionRoutine, 整数型
    .参数 fResume, 逻辑型

.DLL命令 MsgWaitForMultipleObjects, 整数型, "User32.dll", "MsgWaitForMultipleObjects", 公开
    .参数 nCount, 整数型
    .参数 pHandles, 整数型, 传址
    .参数 fWaitAll, 逻辑型
    .参数 dwMilliseconds, 整数型
    .参数 dwWakeMask, 整数型

.DLL命令 CryptAcquireContextA, 整数型, "advapi32.dll", "CryptAcquireContextA", 公开
    .参数 phProv, 整数型, 传址
    .参数 pszContainer, 文本型
    .参数 pszProvider, 文本型
    .参数 dwProvType, 整数型
    .参数 dwFlags, 整数型

.DLL命令 CryptCreateHash, 整数型, "advapi32.dll", "CryptCreateHash", 公开
    .参数 hProv, 整数型
    .参数 Algid, 整数型
    .参数 hKey, 整数型
    .参数 dwFlags, 整数型
    .参数 phHash, 整数型, 传址

.DLL命令 CryptReleaseContext, 整数型, "advapi32.dll", "CryptReleaseContext", 公开
    .参数 hProv, 整数型
    .参数 dwFlags, 整数型

.DLL命令 CryptDestroyHash, 整数型, "advapi32.dll", "CryptDestroyHash", 公开
    .参数 hHash, 整数型

.DLL命令 CryptHashData, 整数型, "advapi32.dll", "CryptHashData", 公开
    .参数 hHash, 整数型
    .参数 pbData, 字节集, 传址
    .参数 dwDataLen, 整数型
    .参数 dwFlags, 整数型

.DLL命令 CryptGetHashParam, 整数型, "advapi32.dll", "CryptGetHashParam", 公开
    .参数 hHash, 整数型
    .参数 dwParam, 整数型
    .参数 pByte, 字节集
    .参数 pdwDataLen, 整数型, 传址
    .参数 dwFlags, 整数型

.DLL命令 GetSystemMetrics, 整数型, "User32.dll", "GetSystemMetrics", 公开, 获取windows环境信息
    .参数 nIndex, 整数型

.DLL命令 ExtractAssociatedIconA, 整数型, "shell32.dll", "ExtractAssociatedIconA", 公开, 如果找到任何图标，就返回图标的句柄；否则返回零,这个函数可判断一个可执行程序或DLL中是否存在图标，或是否有图标与系统注册表中指定的文件存在关联。随后，它允许我们提取出那些图标
    .参数 程序句柄, 整数型
    .参数 文件名, 文本型
    .参数 图标类型, 整数型, 传址

.DLL命令 DrawIcon, , "user32.dll", "DrawIcon", 公开, 在指定的位置画一个图标
    .参数 设备句柄, 整数型
    .参数 横向位置, 整数型
    .参数 纵向位置, 整数型
    .参数 图标句柄, 整数型

.DLL命令 LoadImage, 整数型, "user32.dll", "LoadImageA", 公开, 载入一个位图、图标或指针  执行成功则返回对象的一个句柄；零表示失败
    .参数 实例句柄, 整数型, , 要从其中载入图象的DLL或应用程序模块或实例句柄。零表示装载一幅固有图象
    .参数 图象标志符, 文本型, , 欲载入图象的名字。如指定了hInst，就用这个参数指定资源或资源的标志符（标志符是一个长整数）。如hInst为空，而且已指定了LR_LOADFROMFILE，那么这个参数代表文件名（位图、图标或指针文件）。如果是个Long型值，这个参数就代表固有位图、图标或指针的编号
    .参数 图象类型, 整数型, , 下述常数之一，指定了欲载入的图象类型：IMAGE_BITMAP， IMAGE_CURSOR， IMAGE_ICON
    .参数 图象宽度, 整数型, , 要求的图象宽度和高度。图象会根据情况自动伸缩。如设为零，表示用图象的默认大小
    .参数 图象高度, 整数型, , 同上
    .参数 常数组合, 整数型, , 下述常数的任意组合，它们都在api32.txt文件中得到了定义：;LR_DEFAULTCOLOR：以常规方式载入图象;LR_LOADREALSIZE：不对图象进行缩放处理。忽略n1和n2的设置;LR_CREATEDIBSECTION：如果指定了IMAGE_BITMAP，就返回DIBSection的句柄，而不是位图的句柄;LR_DEFAULTSIZE：如果n1和n2为零，就使用由系统定义的图象默认大小，而不是图象本身定义的大小;LR_LOADFROMFILE：如hInst为零，lpsz就代表要载入适当类型的一个文件的名字，仅适用于Win95;LR_LOADMAP3DCOLORS：将图象中的深灰、灰、以及浅灰像素都替换成COLOR_3DSHADOW，COLOR_3DFACE以及COLOR_3DLIGHT的当前设置;LR_LOADTRANSPARENT：与图象中第一个像素相符的所有像素都由系统替换;LR_MONOCHROME：将图象转换成单色;LR_SHARED：将图象作为一个共享资源载入。在NT 4.0中装载固有资源时要用到这个设置;

.DLL命令 HeapAlloc, 整数型, "kernel32.dll", "HeapAlloc", 公开, 从堆栈分配内存
    .参数 堆栈句柄, 整数型, , hHeap
    .参数 标志, 整数型, , dwFlags
    .参数 分配大小, 整数型, , dwBytes

.DLL命令 GetProcessHeap, 整数型, "kernel32.dll", "GetProcessHeap", 公开, _取进程堆栈句柄, 获取调用过程堆句柄

.DLL命令 SetMenuItemBitmaps, 逻辑型, "user32.dll", "SetMenuItemBitmaps", 公开, 设置菜单图标
    .参数 菜单句柄, 整数型
    .参数 位置, 整数型
    .参数 标志, 整数型
    .参数 未选图标句柄, 整数型
    .参数 已选图标句柄, 整数型

.DLL命令 InsertMenuA, 逻辑型, "user32.dll", "InsertMenuA", 公开
    .参数 菜单句柄, 整数型
    .参数 位置, 整数型
    .参数 标志, 整数型
    .参数 ID, 整数型
    .参数 标题, 文本型

.DLL命令 CreatePopupMenu, 整数型, "user32.dll", "CreatePopupMenu", 公开, 创建空白弹出式菜单

.DLL命令 ModifyMenuA, 逻辑型, "user32.dll", "ModifyMenuA", 公开, 修改菜单标题
    .参数 菜单句柄, 整数型
    .参数 标识符, 整数型, , nPosition，欲改变的菜单条目的标识符
    .参数 常数标志, 整数型, , wFlags，一系列常数标志的组合
    .参数 新命令ID, 整数型, , wIDNewItem，指定菜单条目的新命令ID
    .参数 标志, 文本型, , any，位图句柄或菜单文本

.DLL命令 DrawMenuBar, 逻辑型, "user32.dll", "DrawMenuBar", 公开, 为指定的窗口重画菜单
    .参数 hwnd, 整数型, , hwnd,要重画菜单栏的窗口的句柄

.DLL命令 GetMenuItemCount, 整数型, "user32.dll", "GetMenuItemCount", 公开, 菜单取数量
    .参数 hMenu, 整数型

.DLL命令 RemoveMenu, 逻辑型, "user32.dll", "RemoveMenu", 公开, 删除菜单，非零表示成功，零表示失败。会设置GetLastError
    .参数 菜单句柄, 整数型, , hmenu，菜单的句柄
    .参数 标识符, 整数型, , nPosition，欲改变的菜单条目的标识符。如在wFlags参数中指定了MF_BYCOMMAND，这个参数就代表欲改变的菜单条目的命令ID。如设置的是MF_BYPOSITION，这个参数就代表菜单条目在菜单中的位置（第一个条目的位置为零）
    .参数 标识符类型, 整数型, , wflags，常数MF_BYCOMMAND或MF_BYPOSITION，取决于nPosition参数

.DLL命令 AppendMenuA, 逻辑型, "user32.dll", "AppendMenuA", 公开, 添加菜单
    .参数 菜单句柄, 整数型, , hMenu,菜单句柄
    .参数 菜单常数标志, 整数型, , wFlags,参见相关帮助
    .参数 新菜单条目ID, 整数型, , wIDNewItem,指定菜单条目的新命令ID
    .参数 标志值, 文本型, , lpNewItem,参见相关帮助

.DLL命令 GetMenu, 整数型, "user32.dll", "GetMenu", 公开, 取指定窗口的菜单条句柄
    .参数 hwnd, 整数型

.DLL命令 GetSubMenu, 整数型, "user32.dll", "GetSubMenu", 公开, 取子菜单句柄
    .参数 菜单句柄, 整数型
    .参数 位置, 整数型

.DLL命令 InsertMenu, 逻辑型, "user32.dll", "InsertMenu", 公开
    .参数 hMenu, 整数型, , 手柄以被改变的菜单
    .参数 uPosition, 整数型, , 之前要插入新的菜单项所确定的uFlags参数指定的菜单项
    .参数 uFlags, 整数型
    .参数 uIDNewItem, 整数型, , 指定的标识符的新的菜单项，或如果uFlags参数的MF_POPUP的标志位，下拉菜单或子菜单的句柄
    .参数 lpNewItem, 整数型

.DLL命令 IsMenu, 逻辑型, "user32.dll", "IsMenu", 公开, 是否为菜单句柄
    .参数 hMenu, 整数型, , 手柄以被改变的菜单

.DLL命令 GetMenuStringA, 整数型, "user32.dll", "GetMenuStringA", 公开, 菜单取标题
    .参数 菜单句柄, 整数型
    .参数 项目索引, 整数型
    .参数 菜单标题, 文本型
    .参数 标题长度, 整数型
    .参数 操作标志, 整数型

.DLL命令 DestroyMenu, 逻辑型, "user32.dll", "DestroyMenu", 公开, 清除菜单
    .参数 hMenu, 整数型

.DLL命令 GetMenuItemID, 整数型, "user32.dll", "GetMenuItemID", 公开, 取菜单ID
    .参数 菜单句柄, 整数型
    .参数 位置, 整数型

.DLL命令 GdiplusStartup, 整数型, "gdiplus.dll", "GdiplusStartup", 公开, GDI启动 图像转换类
    .参数 token, 整数型, 传址
    .参数 inputbuf, GdiplusStartupInput
    .参数 outputbuf, 整数型

.DLL命令 GdiplusShutdown, , "gdiplus.dll", "GdiplusShutdown", 公开, _GDI关闭
    .参数 token, 整数型

.DLL命令 GdipSaveImageToFile_EncoderParameters, 整数型, "gdiplus.dll", "GdipSaveImageToFile"
    .参数 image, 整数型
    .参数 filename, 字节集
    .参数 clsidEncoder, 字节集
    .参数 encoderParams, EncoderParameters

.DLL命令 GdipSaveImageToFile, 整数型, "gdiplus.dll", "GdipSaveImageToFile", , 图像转换类
    .参数 image
    .参数 filename, 字节集
    .参数 clsidEncoder, 字节集
    .参数 encoderParams, 整数型

.DLL命令 InternetFindNextFileA, 整数型, "WinInet.dll", "InternetFindNextFileA", 公开
    .参数 hFind, 整数型
    .参数 lpvFindData, 查找的文件信息, 传址

.DLL命令 FtpFindFirstFileA, 整数型, "WinInet.dll", "FtpFindFirstFileA", 公开, _FTP查找文件
    .参数 hFtp, 整数型
    .参数 lpszSearchFile, 文本型
    .参数 lpFindFileData, 查找的文件信息
    .参数 dwFlags, 整数型
    .参数 dwContext, 整数型

.DLL命令 FtpGetFileA, 逻辑型, "WinInet.dll", "FtpGetFileA", 公开, _FTP文件下载
    .参数 hFtp, 整数型
    .参数 lpszRemoteFile, 文本型
    .参数 lpszNewFile, 文本型
    .参数 fFailIfExists, 整数型
    .参数 dwFlagsAndAttributes, 整数型
    .参数 dwFlags, 整数型
    .参数 dwContext, 整数型

.DLL命令 FtpPutFileA, 逻辑型, "WinInet.dll", "FtpPutFileA", 公开, _FTP文件上传
    .参数 连接句柄, 整数型
    .参数 本地文件名, 文本型
    .参数 FTP文件路径, 文本型
    .参数 文件传输方式, 整数型
    .参数 dwContext, 整数型

.DLL命令 FtpDeleteFileA, 逻辑型, "WinInet.dll", "FtpDeleteFileA", 公开
    .参数 hFtp, 整数型
    .参数 lpszKillFile, 文本型

.DLL命令 FtpSetCurrentDirectoryA, 逻辑型, "WinInet.dll", "FtpSetCurrentDirectoryA", 公开, _FTP置现行目录
    .参数 hFtp, 整数型
    .参数 lpszDirectory, 文本型

.DLL命令 FtpGetCurrentDirectoryA, 整数型, "WinInet.dll", "FtpGetCurrentDirectoryA", 公开, _FTP取现行目录
    .参数 hFtp, 整数型
    .参数 lpszDirectory, 文本型, 传址
    .参数 BuffLength, 整数型, 传址

.DLL命令 FtpRenameFileA, 逻辑型, "WinInet.dll", "FtpRenameFileA", 公开, _FTP文件改名
    .参数 hFtp, 整数型
    .参数 lpszCurFile, 文本型
    .参数 lpszNewFile, 文本型

.DLL命令 PathIsDirectoryA, 整数型, "shlwapi.dll", "PathIsDirectoryA", 公开, 目录是否存在
    .参数 lpszPath, 文本型

.DLL命令 PathIsDirectoryW, 整数型, "shlwapi.dll", "PathIsDirectoryW"
    .参数 pszPath, 字节集

.DLL命令 FtpCreateDirectoryA, 逻辑型, "WinInet.dll", "FtpCreateDirectoryA", 公开, _FTP创建目录
    .参数 hFtp, 整数型
    .参数 lpszNewDir, 文本型

.DLL命令 FtpGetFileSize, 整数型, "wininet.dll", "FtpGetFileSize", 公开, _FTP取文件大小
    .参数 hFile, 整数型
    .参数 lpdwFileSizeHigh, 整数型, 传址

.DLL命令 FtpOpenFileA, 整数型, "wininet.dll", "FtpOpenFileA", 公开, _FTP打开文件
    .参数 hConnect, 整数型
    .参数 lpszFileName, 文本型
    .参数 dwAccess, 整数型
    .参数 dwFlags, 整数型
    .参数 dwContext, 整数型

.DLL命令 RemoveDirectoryA, 整数型, "kernel32.dll", "RemoveDirectoryA", 公开, _FTP删除目录1
    .参数 lpPathName, 文本型

.DLL命令 FtpRemoveDirectoryA, 逻辑型, "WinInet.dll", "FtpRemoveDirectoryA", 公开, _FTP删除目录
    .参数 hFtp, 整数型
    .参数 lpszKillDir, 文本型

.DLL命令 _GetHGlobalFromStream, , "ole32.dll", "GetHGlobalFromStream", , 图像转换类
    .参数 pstm, 对象, , 未知类型：ISTREAM。
    .参数 phglobal, 整数型, 传址

.DLL命令 VirtualAllocEx_a, 整数型, "kernel32.dll", "VirtualAllocEx"
    .参数 hProcess, 整数型
    .参数 lpAddress, 整数型
    .参数 dwSize, 整数型, 传址
    .参数 flAllocationType, 整数型
    .参数 flProtect, 整数型

.DLL命令 VirtualAllocEx, 整数型, "kernel32.dll", "VirtualAllocEx", 公开, 分配外部指针
    .参数 hProcess, 整数型
    .参数 lpAddress, 整数型
    .参数 dwSize, 整数型
    .参数 flAllocationType, 整数型
    .参数 flProtect, 整数型

.DLL命令 GetLocalTime, 整数型, "kernel32.dll", "GetLocalTime", 公开, ,
    .参数 系统时间格式, 精易_时间, 传址

.DLL命令 GlobalSize, 整数型, "kernel32.dll", "GlobalSize", 公开, 返回全局内存块大小
    .参数 hMem, 整数型

.DLL命令 lstrcpyn_文本型, 整数型, "kernel32.dll", "lstrcpyn", 公开, 取指针地址
    .参数 目标, 文本型, 传址
    .参数 源, 文本型, 传址
    .参数 长度, 整数型

.DLL命令 lstrcpyn_日期时间型, 整数型, "kernel32.dll", "lstrcpyn", 公开
    .参数 目的指针, 日期时间型, 传址
    .参数 源指针, 日期时间型, 传址
    .参数 复制长度, 整数型, , 0

.DLL命令 lstrcpyn_整数型, 整数型, "kernel32.dll", "lstrcpyn", 公开
    .参数 目标, 整数型, 传址
    .参数 源, 整数型, 传址
    .参数 长度, 整数型

.DLL命令 lstrcpyn_子程序指针, 整数型, "kernel32.dll", "lstrcpyn", 公开
    .参数 目标, 子程序指针, 传址
    .参数 源, 子程序指针, 传址
    .参数 长度, 整数型

.DLL命令 lstrcpyn_小数型, 整数型, "kernel32.dll", "lstrcpyn", 公开
    .参数 目标, 小数型, 传址
    .参数 源, 小数型, 传址
    .参数 长度, 整数型

.DLL命令 lstrcpyn_双精度小数型, 整数型, "kernel32.dll", "lstrcpyn", 公开
    .参数 目标, 双精度小数型, 传址
    .参数 源, 双精度小数型, 传址
    .参数 长度, 整数型

.DLL命令 lstrcpyn_短整数型, 整数型, "kernel32.dll", "lstrcpyn", 公开
    .参数 目标, 短整数型, 传址
    .参数 源, 短整数型, 传址
    .参数 长度, 整数型

.DLL命令 lstrcpyn_长整数型, 整数型, "kernel32.dll", "lstrcpyn", 公开
    .参数 目标, 长整数型, 传址
    .参数 源, 长整数型, 传址
    .参数 长度, 整数型

.DLL命令 SetHandleCount_字节型, 整数型, "kernel32.dll", "SetHandleCount", 公开, 设置进程的文件句柄数
    .参数 字节集数据, 字节型, 传址

.DLL命令 lstrcpyn_字节型, 整数型, "kernel32.dll", "lstrcpyn", 公开
    .参数 目标, 字节型, 传址
    .参数 源, 字节型, 传址
    .参数 长度, 整数型

.DLL命令 lstrcpyn_字节集, 整数型, "kernel32.dll", "lstrcpyn", 公开, 字节集
    .参数 欲取其指针, 字节集, 传址
    .参数 欲取其指针, 字节集, 传址
    .参数 保留, 整数型, , 0

.DLL命令 lstrcpyn_对象, 整数型, "kernel32.dll", "lstrcpyn", 公开, 图像转换类
    .参数 lpString1, 对象, 传址
    .参数 lpString2, 对象, 传址
    .参数 iMaxLength, 整数型

.DLL命令 GDIpCreateBitmapFromStream, 整数型, "gdiplus.dll", "GdipCreateBitmapFromStream", , 图像转换类
    .参数 stream, 整数型, , 图像转换类
    .参数 bitmap, 整数型, 传址

.DLL命令 GdipCreateHBITMAPFromBitmap, 整数型, "gdiplus.dll", "GdipCreateHBITMAPFromBitmap", 公开
    .参数 Bitmap
    .参数 hBmpReturn, , 传址
    .参数 Background

.DLL命令 GdipCreateBitmapFromHBITMAP, 整数型, "gdiplus.dll", "GdipCreateBitmapFromHBITMAP", 公开
    .参数 hbm
    .参数 hPal
    .参数 BITMAP, , 传址

.DLL命令 GlobalFree, 整数型, "kernel32.dll", "GlobalFree", 公开, 释放全局内存块
    .参数 hMem, 整数型

.DLL命令 CreateStreamOnHGlobal_整数型, 整数型, "ole32.dll", "CreateStreamOnHGlobal"
    .参数 hGlobal, 整数型
    .参数 fDeleteOnRelease, 整数型
    .参数 ppstm, 整数型, 传址

.DLL命令 CreateStreamOnHGlobal, 整数型, "Ole32.dll", "CreateStreamOnHGlobal", 公开
    .参数 hGlobal, 整数型
    .参数 fDeleteOnRelease, 逻辑型
    .参数 ppstm, 整数型, 传址

.DLL命令 _CreateStreamOnHGlobal_int, 整数型, "ole32.dll", "CreateStreamOnHGlobal", , 图像转换类
    .参数 hGlobal
    .参数 fDeleteOnRelease, 逻辑型
    .参数 ppstm, , 传址

.DLL命令 GdipSaveImageToStream_字节集, 整数型, "GdiPlus.dll", "GdipSaveImageToStream"
    .参数 image, 整数型
    .参数 stream, 整数型
    .参数 clsidEncoder, 字节集
    .参数 encoderParams, 整数型

.DLL命令 GDIpSaveImageToStream_GUID, 整数型, "gdiplus.dll", "GdipSaveImageToStream", 公开, 图像转换类
    .参数 image, 整数型
    .参数 stream, 整数型
    .参数 clsidEncoder, GUID
    .参数 encoderParams, 整数型

.DLL命令 GetHGlobalFromStream, 整数型, "ole32.dll", "GetHGlobalFromStream", , 图像转换类
    .参数 pstm, 整数型, , 未知类型：ISTREAM。
    .参数 phglobal, 整数型, 传址

.DLL命令 RtlMoveMemory_int2Bytes, 整数型, "kernel32.dll", "RtlMoveMemory", 公开, 内存拷贝
    .参数 Destination, 字节集
    .参数 字节集指针, 整数型
    .参数 数据长度, 整数型

.DLL命令 RtlMoveMemory_MSG0, , "kernel32.dll", "RtlMoveMemory"
    .参数 Destination, MSG
    .参数 Source, 整数型
    .参数 cbCopy, 整数型

.DLL命令 CallNextHookEx, 整数型, "user32.dll", "CallNextHookEx", 公开, 下一个钩子
    .参数 hHook, 整数型
    .参数 icode, 整数型
    .参数 wParam, 整数型
    .参数 lParam, 整数型

.DLL命令 SetWindowsHookExA, 整数型, "User32.dll", "SetWindowsHookExA", 公开, 安装钩子
    .参数 ihook, 整数型
    .参数 lpfunc, 子程序指针
    .参数 hin, 整数型
    .参数 threadid, 整数型

.DLL命令 UnhookWindowsHookEx, 逻辑型, "User32.dll", "UnhookWindowsHookEx", 公开, 卸载钩子
    .参数 hHook, 整数型

.DLL命令 WriteProcessMemory_文本型, 逻辑型, "kernel32.dll", "WriteProcessMemory", 公开, 写文本内存
    .参数 hProcess, 整数型
    .参数 pBaseAddress, 整数型, , 内存地址
    .参数 lpBuffer, 文本型, 传址, 数据指针
    .参数 nSize, 整数型, , 长度
    .参数 lpNumberOfBytesWritten, 整数型, , 实际写出长度

.DLL命令 LocalSize_SHELLEXECUTEINFOA, 整数型, "kernel32.dll", "LocalSize", 公开, 返回本地内存块大小　
    .参数 hMem, SHELLEXECUTEINFOA

.DLL命令 LocalSize, 整数型, "kernel32.dll", "LocalSize", 公开, 返回本地内存块大小
    .参数 hMem, 整数型

.DLL命令 RtlMoveMemory_字节集, , "kernel32.dll", "RtlMoveMemory", 公开, 写内存_字节集
    .参数 Destination, 整数型
    .参数 Source, 字节集
    .参数 Length, 整数型

.DLL命令 SetDIBits, 整数型, "Gdi32.dll", "SetDIBits"
    .参数 hdc, 整数型
    .参数 hBitmap, 整数型
    .参数 nStartScan, 整数型
    .参数 nNumScans, 整数型
    .参数 lpBits, 字节集, 传址
    .参数 lpBI, BITMAPINFO
    .参数 wUsage, 整数型

.DLL命令 RtlMoveMemory_Bin_To_BITMAPINFO, 整数型, "kernel32.dll", "RtlMoveMemory"
    .参数 Destination, BITMAPINFO, 传址
    .参数 Source, 字节集, 传址
    .参数 Length, 整数型

.DLL命令 RtlMoveMemory_BITMAPINFO, 整数型, "kernel32.dll", "RtlMoveMemory", 公开, _内存图像截图1
    .参数 Destination, 字节集
    .参数 Source, BITMAPINFO
    .参数 Length, 整数型

.DLL命令 RtlMoveMemory_BITMAPFILEHEADER, 整数型, "kernel32.dll", "RtlMoveMemory", 公开, _内存图像截图
    .参数 Destination, 字节集
    .参数 Source, BITMAPFILEHEADER
    .参数 Length, 整数型

.DLL命令 GetDIBColorTable, , "gdi32.dll", "GetDIBColorTable", 公开, 取得颜色表信息
    .参数 hDC, 整数型, , Long，已选入了一个DIBSection对象的设备场景
    .参数 un1, 整数型, , Long，颜色表中欲取回的第一个条目的索引
    .参数 un2, 整数型, , Long，欲取回的条目数量
    .参数 pRGBQuad, 字节集, 传址, RGBQUAD，这个结构数组用于装载颜色表信息的第一个条目

.DLL命令 RtlMoveMemory_位图信息, 整数型, "kernel32.dll", "RtlMoveMemory", 公开, 内存拷贝_
    .参数 Destination, 字节集
    .参数 Source, 位图信息_
    .参数 Length, 整数型

.DLL命令 GetBitmapBits, , "gdi32.dll", "GetBitmapBits", 公开, 复制二进制位图_
    .参数 位图句柄, 整数型
    .参数 字节限制, 整数型
    .参数 缓冲区, 字节集, 传址

.DLL命令 CreateDIBSection1, 整数型, "gdi32.dll", "CreateDIBSection", 公开,  创建GDI对象2_
    .参数 设备场景句柄, 整数型
    .参数 位图数据, 字节集, 传址
    .参数 常数, 整数型
    .参数 内存地址, 整数型, 传址
    .参数 文件映射句柄, 整数型
    .参数 偏移量, 整数型

.DLL命令 CreateDIBSection, 整数型, "gdi32.dll", "CreateDIBSection", 公开, 创建一个DIBSection。这是一个GDI对象，可象一幅与设备有关位图那样使用。但是，它在内部作为一幅与设备无关位图保存  执行成功返回DIBSection位图的句柄，零表示失败。会设置GetLastError
    .参数 设备场景句柄, 整数型, , 一个设备场景的句柄。如dw设为DIB_PAL_COLORS，那么DIB颜色表就会用来自逻辑调色板的颜色进行初始化
    .参数 pBitmapInfo, 位图信息_, , BITMAPINFO，这个结构初始化成欲创建的那幅位图的配置数据
    .参数 常数, 整数型, , 下述常数之一：;DIB_PAL_COLORS：BITMAPINFO包含了一个16位调色板索引的数组;DIB_RGB_COLORS：BITMAPINFO包含了一个颜色表，其中保存有32位颜色（RGBQUAD）
    .参数 内存地址, 整数型, , 用于载入DIBSection数据区的内存地址
    .参数 文件映射句柄, 整数型, , 指向一个文件映射对象的可选句柄，位图将在其中创建。如设为零，Windows会自动分配内存
    .参数 偏移量, 整数型, , 如指定了句柄，就用这个参数指定位图数据在文件映射对象中的偏移量;

.DLL命令 RtlMoveMemory_BITMAPFILEHEADER_字节型, , "kernel32.dll", "RtlMoveMemory", 公开
    .参数 Dest, 字节型, 传址
    .参数 Src, BITMAPFILEHEADER
    .参数 len, 整数型

.DLL命令 RtlMoveMemory_BITMAPINFOHEADER, , "kernel32.dll", "RtlMoveMemory", 公开
    .参数 Dest, 字节型, 传址
    .参数 Src, BITMAPINFOHEADER
    .参数 len, 整数型

.DLL命令 RtlFillMemory_字节, 整数型, "kernel32.dll", "RtlFillMemory", , 填充内存字节
    .参数 Destination, 整数型, , 指针地址
    .参数 Length, 整数型, , 长度
    .参数 Fill, 字节型, , 字节数据

.DLL命令 LsaFreeMemory, 整数型, "ADVAPI32.DLL", "LsaFreeMemory", 公开
    .参数 Buffer, 字节集, 传址

.DLL命令 LsaClose, 整数型, "ADVAPI32.DLL", "LsaClose", 公开
    .参数 ObjectHandle, 整数型

.DLL命令 RtlMoveMemory_取硬盘特征号3, 整数型, "kernel32.dll", "RtlMoveMemory"
    .参数 lpvDest, 取硬盘特征号3, 传址
    .参数 lpvSource, 字节集
    .参数 cbCopy, 整数型

.DLL命令 RtlMoveMemory_NMLVCUSTOMDRAW, , "kernel32.dll", "RtlMoveMemory", 公开
    .参数 Destination, NMLVCUSTOMDRAW
    .参数 Source, 整数型
    .参数 Length, 整数型

.DLL命令 RtlMoveMemory_NMLVCUSTOMDRAW2, , "kernel32.dll", "RtlMoveMemory"
    .参数 Destination, 整数型
    .参数 Source, NMLVCUSTOMDRAW
    .参数 Length, 整数型

.DLL命令 DrawText_RECT, 整数型, "user32.dll", "DrawTextA", , 将文本描绘到指定的矩形中  描绘文字的高度
    .参数 hdc, 整数型, , 欲在其中显示文字的一个设备场景的句柄
    .参数 lpStr, 文本型, , 欲描绘的文本字串
    .参数 nCount, 整数型, , 欲描绘的字符数量。如果要描绘整个字串（直到空中止符），则可将这个参数设为-1
    .参数 lpRect, RECT, , RECT，指定用于绘图的一个格式化矩形（采用逻辑坐标）
    .参数 wFormat, 整数型, , 一个标志位数组，决定了以何种形式执行绘图。参考下面总结的常数类型列表标志常数说明DT_BOTTOM必须同时指定DT_SINGLE。指示文本对齐格式化矩形的底边DT_CALCRECT象下面这样计算格式化矩形：多行绘图时矩形的底边根据需要进行延展，以便容下所有文字；单行绘图时，延展矩形的右侧。不描绘文字。由lpRect参数指定的矩形会载入计算出来的值DT_CENTER文本垂直居中DT_EXPANDTABS描绘文字的时候，对制表站进行扩展。默认的制表站间距是8个字符。但是，可用DT_TABSTOP标志改变这项设定DT_EXTERNALLEADING计算文本行高度的时候，使用当前字体的外部间距属性（the external leading attribute）DT_LEFT文本左对齐DT_NOCLIP描绘文字时不剪切到指定的矩形DT_NOPREFIX通常，函数认为 & 字符表示应为下一个字符加上下划线。该标志禁止这种行为DT_RIGHT文本右对齐DT_SINGLELINE只画单行DT_TABSTOP指定新的制表站间距，采用这个整数的高8位DT_TOP必须同时指定DT_SINGLE。指示文本对齐格式化矩形的顶部DT_VCENTER必须同时指定DT_SINGLE。指示文本对齐格式化矩形的中部DT_WORDBREAK进行自动换行。如用SetTextAlign函数设置了TA_UPDATECP标志，这里的设置则无效;

.DLL命令 DrawText, 整数型, "user32.dll", "DrawTextA", 公开, 将文本描绘到指定的矩形中  描绘文字的高度
    .参数 设备场景句柄, 整数型, , 欲在其中显示文字的一个设备场景的句柄
    .参数 描绘的字串, 文本型, , 欲描绘的文本字串
    .参数 描绘的字串数量, 整数型, , 欲描绘的字符数量。如果要描绘整个字串（直到空中止符），则可将这个参数设为-1
    .参数 描绘文本区域, 精易_矩形, , RECT，指定用于绘图的一个格式化矩形（采用逻辑坐标）
    .参数 格式, 整数型, , 一个标志位数组，决定了以何种形式执行绘图。参考下面总结的常数类型列表标志常数说明DT_BOTTOM必须同时指定DT_SINGLE。指示文本对齐格式化矩形的底边DT_CALCRECT象下面这样计算格式化矩形：多行绘图时矩形的底边根据需要进行延展，以便容下所有文字；单行绘图时，延展矩形的右侧。不描绘文字。由lpRect参数指定的矩形会载入计算出来的值DT_CENTER文本垂直居中DT_EXPANDTABS描绘文字的时候，对制表站进行扩展。默认的制表站间距是8个字符。但是，可用DT_TABSTOP标志改变这项设定DT_EXTERNALLEADING计算文本行高度的时候，使用当前字体的外部间距属性（the external leading attribute）DT_LEFT文本左对齐DT_NOCLIP描绘文字时不剪切到指定的矩形DT_NOPREFIX通常，函数认为 & 字符表示应为下一个字符加上下划线。该标志禁止这种行为DT_RIGHT文本右对齐DT_SINGLELINE只画单行DT_TABSTOP指定新的制表站间距，采用这个整数的高8位DT_TOP必须同时指定DT_SINGLE。指示文本对齐格式化矩形的顶部DT_VCENTER必须同时指定DT_SINGLE。指示文本对齐格式化矩形的中部DT_WORDBREAK进行自动换行。如用SetTextAlign函数设置了TA_UPDATECP标志，这里的设置则无效;

.DLL命令 WriteProcessMemory_写字节, 逻辑型, "kernel32.dll", "WriteProcessMemory", 公开
    .参数 hProcess, 整数型
    .参数 pBaseAddress, 整数型, , 内存地址
    .参数 lpBuffer, 字节型, 传址, 数据指针
    .参数 nSize, 整数型, , 长度
    .参数 lpNumberOfBytesWritten, 整数型, , 实际写出长度

.DLL命令 ReadProcessMemory_字节型, 逻辑型, "Kernel32.dll", "ReadProcessMemory", 公开, 读内存字节
    .参数 hProcess, 整数型
    .参数 lpBaseAddress, 整数型, , 内存地址
    .参数 lpBuffer, 字节型, 传址, 数据指针
    .参数 nSize, 整数型, , 长度
    .参数 lpNumberOfBytesWritten, 整数型, , 实际写出长度

.DLL命令 VirtualProtectEx, 整数型, "kernel32.dll", "VirtualProtectEx", 公开, 修改虚拟保护
    .参数 进程句柄, 整数型
    .参数 内存地址, 整数型
    .参数 内存大小, 整数型
    .参数 属性, 整数型
    .参数 保存之前属性, 整数型, 传址

.DLL命令 VirtualProtect, 逻辑型, "kernel32.dll", "VirtualProtect", 公开, _修改内存属性
    .参数 lpAddress, 整数型
    .参数 dwSize, 整数型
    .参数 flNewProtect, 整数型
    .参数 lpflOldProtect, 整数型, 传址

.DLL命令 VirtualQueryEx32, 整数型, "kernel32.dll", "VirtualQueryEx"
    .参数 hProcess, 整数型
    .参数 lpAddress, 整数型
    .参数 info, MEMORY_BASIC_INFORMATION, 传址
    .参数 dwLength, 整数型

.DLL命令 VirtualQueryEx, 整数型, "kernel32.dll", "VirtualQueryEx", 公开, 取内存属性,返回虚拟保护
    .参数 hProcess, 整数型
    .参数 lpAddress, 整数型
    .参数 lpBuffer, 精易_内存属性
    .参数 dwLength, 整数型

.DLL命令 WriteProcessMemory_整数5, 整数型, "kernel32.dll", "WriteProcessMemory"
    .参数 hProcess, 整数型
    .参数 lpBaseAddress, 整数型
    .参数 lpBuffer, 整数型
    .参数 nSize, 整数型
    .参数 lpNumberOfBytesWritten, 整数型, 传址

.DLL命令 WriteProcessMemory_整数3, 逻辑型, "kernel32.dll", "WriteProcessMemory", 公开, 内存写整数,有传址
    .参数 hProcess, 整数型
    .参数 内存地址, 整数型
    .参数 数据指针, 整数型, 传址
    .参数 数据长度, 整数型
    .参数 实际写出长度, 整数型

.DLL命令 WriteProcessMemory_整数型, 整数型, "kernel32.dll", "WriteProcessMemory", , 内存写整数，没传址
    .参数 hProcess, 整数型
    .参数 内存地址, 整数型
    .参数 数据指针, 整数型
    .参数 数据长度, 整数型
    .参数 实际写出长度, 整数型

.DLL命令 ReadProcessMemory_整数型, 逻辑型, "kernel32.dll", "ReadProcessMemory", 公开, 内存读整数,有传址
    .参数 hProcess, 整数型
    .参数 内存地址, 整数型
    .参数 数据指针, 整数型, 传址
    .参数 数据长度, 整数型
    .参数 实际写出长度, 整数型

.DLL命令 ReadProcessMemory_短整数型, 逻辑型, "kernel32.dll", "ReadProcessMemory", 公开, 内存读整数,有传址
    .参数 hProcess, 整数型
    .参数 内存地址, 整数型
    .参数 数据指针, 短整数型, 传址
    .参数 数据长度, 整数型
    .参数 实际写出长度, 整数型

.DLL命令 ReadProcessMemory_长整数型, 逻辑型, "kernel32.dll", "ReadProcessMemory", 公开, 内存读整数,有传址
    .参数 hProcess, 整数型
    .参数 内存地址, 整数型
    .参数 数据指针, 长整数型, 传址
    .参数 数据长度, 整数型
    .参数 实际写出长度, 整数型

.DLL命令 WriteProcessMemory_小数型, 逻辑型, "kernel32.dll", "WriteProcessMemory", 公开, 内存写小数,有传址
    .参数 hProcess, 整数型
    .参数 内存地址, 整数型
    .参数 数据指针, 小数型, 传址
    .参数 数据长度, 整数型
    .参数 实际写出长度, 整数型

.DLL命令 ReadProcessMemory_小数型, 逻辑型, "kernel32.dll", "ReadProcessMemory", 公开, 内存读小数,有传址
    .参数 hProcess, 整数型
    .参数 内存地址, 整数型
    .参数 数据指针, 小数型, 传址
    .参数 数据长度, 整数型
    .参数 实际写出长度, 整数型

.DLL命令 ReadProcessMemory_整数型1, 整数型, "kernel32.dll", "ReadProcessMemory", 公开, 内存读整数，没传址
    .参数 hProcess, 整数型
    .参数 内存地址, 整数型
    .参数 数据指针, 整数型
    .参数 数据长度, 整数型
    .参数 实际写出长度, 整数型

.DLL命令 ReadProcessMemory_整数型2, 整数型, "kernel32.dll", "ReadProcessMemory", 公开, 内存读整数,有传址
    .参数 hProcess, 整数型
    .参数 内存地址, 整数型
    .参数 数据指针, 整数型, 传址
    .参数 数据长度, 整数型
    .参数 实际写出长度, 整数型, 传址

.DLL命令 CreateMutexA, 整数型, "kernel32.dll", "CreateMutexA", 公开
    .参数 互斥体结构, 整数型
    .参数 拥有互斥体, 整数型
    .参数 互斥体对象的名字, 文本型

.DLL命令 WriteProcessMemory_字节集, 逻辑型, "kernel32.dll", "WriteProcessMemory", 公开
    .参数 hProcess, 整数型
    .参数 内存地址, 整数型
    .参数 数据指针, 字节集
    .参数 数据长度, 整数型
    .参数 实际写出长度, 整数型

.DLL命令 ReadProcessMemory_文本型, 逻辑型, "Kernel32.dll", "ReadProcessMemory"
    .参数 hProcess, 整数型
    .参数 内存地址, 整数型
    .参数 数据指针, 文本型, 传址
    .参数 数据长度, 整数型
    .参数 读取的长度, 整数型, 传址

.DLL命令 ReadProcessMemory_字节集, 逻辑型, "Kernel32.dll", "ReadProcessMemory", 公开, 内存读字节集
    .参数 hProcess, 整数型
    .参数 内存地址, 整数型
    .参数 数据指针, 字节集, 传址
    .参数 数据长度, 整数型
    .参数 读取的长度, 整数型, 传址

.DLL命令 Module32First, 整数型, "Kernel32.dll", "Module32First", 公开, 第一个模块，查找模块
    .参数 快照句柄, 整数型
    .参数 模块信息, 精易_模块信息

.DLL命令 Module32Next, 整数型, "kernel32.dll", "Module32Next", 公开, 下一个模块
    .参数 快照句柄, 整数型
    .参数 模块信息, 精易_模块信息

.DLL命令 GetModuleHandleA1, 整数型, "kernel32.dll", "GetModuleHandleA", 公开, 取模块句柄
    .参数 lpModuleName, 整数型

.DLL命令 GetModuleHandleA, 整数型, "kernel32.dll", "GetModuleHandleA", 公开, 取模块句柄
    .参数 lpModuleName, 文本型

.DLL命令 GetModuleHandleW, 整数型, "kernel32.dll", "GetModuleHandleW"
    .参数 lpModuleName, 整数型

.DLL命令 PathFindExtensionA, 文本型, "shlwapi.dll", "PathFindExtensionA", 公开, 文件_取扩展名, 无扩展名返回空
    .参数 文件路径, 文本型, , pszPath

.DLL命令 PathRenameExtensionA, 逻辑型, "shlwapi.dll", "PathRenameExtensionA", 公开, 文件_改扩展名
    .参数 文件名, 文本型, , pszPath
    .参数 扩展名, 文本型, , pszExt

.DLL命令 PathRemoveFileSpec, 整数型, "Shlwapi.dll", "PathRemoveFileSpecA", 公开, 删除结尾的文件名和反斜杠路径，如果有他们。
    .参数 pszPath, 文本型

.DLL命令 PathMatchSpec, 逻辑型, "shlwapi.dll", "PathMatchSpecA", 公开, 搜索的字符串，使用DOS通配符匹配类型。
    .参数 pszFile, 文本型
    .参数 pszSpec, 文本型

.DLL命令 PathFindFileNameA, 文本型, "shlwapi.dll", "PathFindFileNameA", 公开, 文件_取文件名, 成功返回路径文本指针地址
    .参数 路径文本, 文本型

.DLL命令 DeleteFileA, 逻辑型, "Kernel32.dll", "DeleteFileA", 公开, 删除指定文件
    .参数 文件名, 文本型, , lpFileName,欲删除文件的名字

.DLL命令 DeleteFileW, 逻辑型, "Kernel32.dll", "DeleteFileW"
    .参数 lpFileName, 字节集

.DLL命令 SetEndOfFile, 整数型, "Kernel32.dll", "SetEndOfFile", 公开
    .参数 hfile, 整数型

.DLL命令 SetFilePointer, 整数型, "Kernel32.dll", "SetFilePointer", 公开
    .参数 hFile, 整数型
    .参数 lDistanceToMove, 整数型
    .参数 lpDistanceToMoveHigh, 整数型, 传址
    .参数 dwMoveMethod, 整数型

.DLL命令 CreateFileA, 整数型, "kernel32.dll", "CreateFileA", 公开, 文件取句柄 如执行成功，则返回文件句柄
    .参数 指向文件名的指针, 文本型, , 指向文件名的指针
    .参数 访问模式_写与读, 整数型, , 访问模式（写/读）
    .参数 共享模式, 整数型, , 共享模式，0=不共享，FILE_SHARE_READ 和/或 FILE_SHARE_WRITE 表示允许对文件进行共享访问
    .参数 指向安全属性的指针, 整数型, , 指向安全属性的指针
    .参数 如何创建, 整数型, , 如何创建 3=直接打开文件
    .参数 文件属性, 整数型, , 文件属性
    .参数 用于复制文件句柄, 整数型, , 用于复制文件句柄

.DLL命令 CreateFileW, 整数型, "kernel32.dll", "CreateFileW"
    .参数 lpFileName, 字节集
    .参数 dwDesiredAccess, 整数型
    .参数 dwShareMode, 整数型
    .参数 lpSecurityAttributes, 整数型
    .参数 dwCreationDisposition, 整数型
    .参数 dwFlagsAndAttributes, 整数型
    .参数 hTemplateFile, 整数型

.DLL命令 GetFileTime, 逻辑型, "kernel32.dll", "GetFileTime", , _文件取时间
    .参数 hFile, 整数型
    .参数 创建时间, FILETIME, , 创建时间
    .参数 访问时间, FILETIME, , 访问时间
    .参数 修改时间, FILETIME, , 修改时间

.DLL命令 LocalFileTimeToFileTime, 整数型, "kernel32.dll", "LocalFileTimeToFileTime", , _文件时间转移为UTC文件时间 将本地文件时间转移为UTC文件时间
    .参数 lpLocalFileTime, FILETIME
    .参数 lpFileTime, FILETIME

.DLL命令 MapViewOfFile, 整数型, "kernel32.dll", "MapViewOfFile", 公开, _查看文件映射对象 将一个文件映射对象映射到当前应用程序的地址空间
    .参数 hFileMappingObject, 整数型
    .参数 dwDesiredAccess, 整数型
    .参数 dwFileOffsetHigh, 整数型
    .参数 dwFileOffsetLow, 整数型
    .参数 dwNumberOfBytesToMap, 整数型

.DLL命令 InternetSetOptionA2, 逻辑型, "Wininet.dll", "InternetSetOptionA", , 设置IE属性
    .参数 hInternet, 整数型
    .参数 dwOption, 整数型
    .参数 lpBuffer, INTERNET_PROXY_INFO
    .参数 dwBufferLength, 整数型

.DLL命令 InternetSetOptionA, 逻辑型, "wininet.dll", "InternetSetOptionA", 公开, _设置IE
    .参数 hInternet, 整数型
    .参数 dwOption, 整数型
    .参数 lpBuffer, 整数型
    .参数 dwBufferLength, 整数型

.DLL命令 InternetSetOptionA_传址, 逻辑型, "wininet.dll", "InternetSetOptionA", 公开, _设置IE
    .参数 hInternet, 整数型
    .参数 dwOption, 整数型
    .参数 lpBuffer, 整数型, 传址
    .参数 dwBufferLength, 整数型

.DLL命令 DoFileDownload, 整数型, "shdocvw.dll", "DoFileDownload", 公开, _下载文件1
    .参数 网址, 字节集, 传址

.DLL命令 SetFileTime, 逻辑型, "kernel32.dll", "SetFileTime", , _文件置时间 设置文件的创建、访问及上次修改时间  非零表示成功，零表示失败。会设置GetLastError
    .参数 hFile, 整数型, , 系统文件句柄
    .参数 lpCreationTime, FILETIME, , FILETIME，文件的创建时间
    .参数 lpLastAccessTime, FILETIME, , FILETIME，文件上一次访问的时间
    .参数 lpLastWriteTime, FILETIME, , FILETIME，文件最近一次修改的时间;

.DLL命令 CopyFileA, 逻辑型, "kernel32.dll", "CopyFileA", 公开, 文件_复制
    .参数 源文件名, 文本型, , lpExistingFileName，被复制的文件名
    .参数 目标文件名, 文本型, , lpNewFileName，目标文件名
    .参数 是否覆盖, 整数型, , bFailIfExists，非0不覆盖，0覆盖

.DLL命令 CopyFileW, 逻辑型, "kernel32.dll", "CopyFileW"
    .参数 lpExistingFileName, 字节集
    .参数 lpNewFileName, 字节集
    .参数 bFailIfExists, 逻辑型

.DLL命令 ShellExecuteA, 整数型, "shell32.dll", "ShellExecuteA", 公开, 文件_执行
    .参数 hwnd, 整数型, , 指定一个窗口的句柄，有些时候，Windows程序有必要在创建自己的主窗口前显示一个消息框。
    .参数 lpOperation, 文本型, , 指定字串“Open”来打开lpFlie文档；或指定“Print”来打印它。也可设为vbNullString，表示默认为“Open”
    .参数 lpFile, 文本型, , 想用关联的程序打印或打开的一个程序名或文件名
    .参数 lpParameters, 文本型, , 如lpFile是一个可执行文件，则这个字串包含了传递给执行程序的参数。如lpFile引用的是一个文档文件，或者不需要使用参数，则设为vbNullString
    .参数 lpDirectory, 文本型, , 想使用的默认路径完整路径
    .参数 nShowCmd, 整数型, , 定义了如何显示启动程序的常数值。参考ShowWindow函数的nCmdShow参数

.DLL命令 MoveFileExA, 整数型, "kernel32.dll", "MoveFileExA", 公开
    .参数 文件名, 文本型
    .参数 新文件名, 文本型
    .参数 常数, 整数型

.DLL命令 MoveFileA, 逻辑型, "kernel32.dll", "MoveFileA", 公开, 文件_移动
    .参数 欲移动的文件名, 文本型, , 如:C:\001.txt
    .参数 目标文件名, 文本型, , 如:D:\001.txt , 表示把C:\001.txt移动到D:\001.txt

.DLL命令 MoveFileW, 逻辑型, "kernel32.dll", "MoveFileW"
    .参数 lpExistingFileName, 字节集
    .参数 lpNewFileName, 字节集

.DLL命令 PostMessageA, 逻辑型, "user32.dll", "PostMessageA", 公开, 投递消息
    .参数 hwnd, 整数型
    .参数 消息号, 整数型
    .参数 消息参数1, 整数型
    .参数 消息参数2, 整数型

.DLL命令 PostMessageW, 逻辑型, "user32.dll", "PostMessageW"
    .参数 hWnd, 整数型
    .参数 Msg, 整数型
    .参数 wParam, 整数型
    .参数 lParam, 整数型

.DLL命令 CreateSolidBrush, 整数型, "gdi32.dll", "CreateSolidBrush", 公开, 用纯色创建一个刷子　如执行成功，返回新刷子的一个句柄；否则返回零
    .参数 crColor, 整数型, , 数字的RGB彩色;  

.DLL命令 GdiFlush, 整数型, "gdi32.dll", "GdiFlush", 公开, 处理绘图操作_gdi32.dll 执行任何未决的绘图操作,如所有未决的绘图操作都成功完成，就返回TRUE（非零）。如任何一个操作失败，就返回零值

.DLL命令 FillRect_RECT, 整数型, "user32.dll", "FillRect", , 用指定的刷子填充一个矩形  非零表示成功，零表示失败。会设置GetLastError
    .参数 hdc, 整数型, , 设备场景的句柄
    .参数 lpRect, RECT, , RECT，对填充区域进行描述的一个矩形，采用逻辑坐标
    .参数 hBrush, 整数型, , 欲使用的刷子的句柄;

.DLL命令 FillRect, 整数型, "user32.dll", "FillRect", 公开, 该函数用指定的画刷填充矩形，此函数包括矩形的左上边界，但不包括矩形的右下边界。如果函数调用成功，返回值非零；如果函数调用失败，返回值是0。 
    .参数 hdc, 整数型, , 设备环境句柄。
    .参数 lpRect, 精易_矩形, 传址, 指向含有将填充矩形的逻辑坐标的RECT结构的指针。 
    .参数 hBrush, 整数型, , 用来填充矩形的画刷的句柄。用CreateSolidBrush创建返回的句柄

.DLL命令 DeleteObject, 整数型, "gdi32.dll", "DeleteObject", 公开, 删除对象 用这个函数删除GDI对象，比如画笔、刷子、字体、位图、区域以及调色板等等。对象使用的所有系统资源都会被释放，不要删除一个已选入设备场景的画笔、刷子或位图。如删除以位图为基础的阴影（图案）刷子，位图不会由这个函数删除——只有刷子被删掉
    .参数 对象句柄, 整数型, , 一个GDI对象的句柄

.DLL命令 InternetOpenA, 整数型, "wininet.dll", "InternetOpenA", 公开, Internet激活
    .参数 句柄名称, 文本型, 传址
    .参数 连接类型, 整数型, , 1直接连接;3代理连接
    .参数 代理地址, 文本型, 传址
    .参数 代理掩码, 文本型, 传址
    .参数 dwFlags, 整数型, , 0

.DLL命令 InternetConnectA, 整数型, "wininet.dll", "InternetConnectA", 公开, Internet建立连接
    .参数 Internet句柄, 整数型
    .参数 域名, 文本型, 传址
    .参数 服务器端口, 整数型, , 80HTTP;21FTP;
    .参数 用户名, 文本型, 传址, 空
    .参数 用户口令, 文本型, 传址, 空
    .参数 服务类型, 整数型, , 1FTP;3HTTP
    .参数 dwFlags, 整数型, , 0http;134217728被动FTP模式
    .参数 dwContext, 整数型, , 0

.DLL命令 InternetSetOption, 逻辑型, "Wininet.dll", "InternetSetOptionA", 公开, 设置选项
    .参数 hInternet, 整数型, , 句柄
    .参数 dwOption, 整数型, , 选项值
    .参数 lpBuffer, 整数型, 传址, 缓冲区
    .参数 dwBufferLength, 整数型, , 缓冲区长度

.DLL命令 InternetCloseHandle, 逻辑型, "wininet.dll", "InternetCloseHandle", 公开, Internet关闭句柄
    .参数 句柄, 整数型

.DLL命令 HttpQueryInfoA, 逻辑型, "wininet.dll", "HttpQueryInfoA", 公开, HTTP查询信息
    .参数 Internet请求句柄, 整数型
    .参数 待查信息, 整数型, , 22返回所有信息;43SET_COOKIE;+2147483648返回文本
    .参数 返回容器, 文本型, 传址
    .参数 返回容器长度, 整数型, 传址
    .参数 lpdwIndex, 整数型

.DLL命令 InternetReadFile, 逻辑型, "wininet.dll", "InternetReadFile", 公开, Internet读文件
    .参数 HTTP请求句柄, 整数型
    .参数 sBuffer, 字节集, 传址
    .参数 lNumBytesToRead, 整数型
    .参数 lNumberOfBytesRead, 整数型, 传址

.DLL命令 InternetReadFile_Byte, 逻辑型, "wininet.dll", "InternetReadFile", , Internet读文件
    .参数 HTTP请求句柄, 整数型
    .参数 sBuffer, 字节型, 传址 数组
    .参数 lNumBytesToRead, 整数型
    .参数 lNumberOfBytesRead, 整数型, 传址

.DLL命令 HttpOpenRequestA, 整数型, "wininet.dll", "HttpOpenRequestA", 公开, Http创建请求
    .参数 Internet连接句柄, 整数型, , 由Internet建立连接返回
    .参数 访问方式, 文本型, 传址, "GET" or "POST"为空默认GET
    .参数 页面路径, 文本型, 传址, 简短路径,不带域名
    .参数 协议版本, 文本型, 传址, 为空默认HTTP/1.1
    .参数 引用页, 文本型, 传址, 可为空
    .参数 识别类型, 文本型, 传址, 可为空
    .参数 dwFlags, 整数型, , 2147483648更新下载
    .参数 dwContext, 整数型, , 0

.DLL命令 HttpSendRequestA, 逻辑型, "wininet.dll", "HttpSendRequestA", 公开, Http发送请求
    .参数 HTTP请求句柄, 整数型
    .参数 附加协议头, 文本型
    .参数 附加协议头长度, 整数型
    .参数 提交信息, 整数型
    .参数 提交信息长度, 整数型

.DLL命令 InflateRect, 整数型, "user32.dll", "InflateRect", 公开, 这个函数用于增大或减小一个矩形的大小。x加在右侧区域，并从左侧区域减去；如x为正，则能增大矩形的宽度；如x为负，则能减小它。y对顶部与底部区域产生的影响是是类似的　非零表示成功，零表示失败。会设置GetLastError
    .参数 lpRect, 精易_矩形, , RECT，欲修改的矩形
    .参数 x, 整数型, , 用这个数字修改宽度
    .参数 y, 整数型, , 用这个数字修改高度;  

.DLL命令 ChangeWindowMessageFilter, 逻辑型, "user32.dll", "ChangeWindowMessageFilter", 公开
    .参数 message, 整数型
    .参数 dwflag, 整数型

.DLL命令 SendMessageW, 整数型, "User32.dll", "SendMessageW", 公开
    .参数 hWnd, 整数型
    .参数 uMsg, 整数型
    .参数 wParam, 整数型
    .参数 lParam, 整数型

.DLL命令 LocalAlloc, 整数型, "kernel32.dll", "LocalAlloc", 公开, _从局部堆分配内存(申请内存)
    .参数 uFlags, 整数型
    .参数 uBytes, 整数型

.DLL命令 LocalFree, 整数型, "kernel32.dll", "LocalFree", 公开, _释放本地内存信息
    .参数 hMem, 整数型

.DLL命令 IsWindowEnabled, 整数型, "user32.dll", "IsWindowEnabled", 公开, 判断窗口是否处于活动状态（在vb里使用：针对vb窗体和控件，请用enabled属性）  非零表示成功，零表示失败
    .参数 hWnd, 整数型

.DLL命令 SHGetFileInfo, 整数型, "shell32.dll", "SHGetFileInfoA"
    .参数 pszPath, 文本型
    .参数 dwFileAttributes, 整数型
    .参数 psfi, SHFILEINFO
    .参数 cbFileInfo, 整数型
    .参数 uFlags, 整数型

.DLL命令 GetClassLongA, 整数型, "user32.dll", "GetClassLongA", 公开
    .参数 hwnd
    .参数 m

.DLL命令 取内存变量地址_TVITEMEX, 整数型, "kernel32.dll", "lstrcpyn"
    .参数 目标, TVITEMEX, 传址
    .参数 源, TVITEMEX, 传址
    .参数 长度, 整数型

.DLL命令 取内存变量地址_TVINSERTSTRUCT, 整数型, "kernel32.dll", "lstrcpyn"
    .参数 目标, TVINSERTSTRUCT, 传址
    .参数 源, TVINSERTSTRUCT, 传址
    .参数 长度, 整数型

.DLL命令 取内存变量地址_TVITEMEX2, 整数型, "kernel32.dll", "lstrcpyn"
    .参数 目标, TVITEMEX2, 传址
    .参数 源, TVITEMEX2, 传址
    .参数 长度, 整数型

.DLL命令 取数据地址3, 整数型, "kernel32.dll", "lstrcpyn"
    .参数 目标, 文本型, 传址
    .参数 源, 文本型, 传址
    .参数 长度, 整数型

.DLL命令 取内存变量地址_TVINSERTSTRUCT2, 整数型, "kernel32.dll", "lstrcpyn"
    .参数 目标, TVINSERTSTRUCT2, 传址
    .参数 源, TVINSERTSTRUCT2, 传址
    .参数 长度, 整数型

.DLL命令 SendMessageA, 整数型, "user32.dll", "SendMessageA", 公开
    .参数 hWnd, 整数型
    .参数 Msg, 整数型, , 消息的标识符
    .参数 wParam, 整数型, , 具体取决于消息
    .参数 lParam, 整数型, , 具体取决于消息

.DLL命令 GetSystemMenu, 整数型, "user32.dll", "GetSystemMenu", 公开, 取系统菜单句柄
    .参数 hwnd, 整数型
    .参数 bRevert, 整数型

.DLL命令 CreateFileMappingA, 整数型, "kernel32.dll", "CreateFileMappingA", 公开, 创建一个新的文件映射对象　新建文件映射对象的句柄；零意味着出错。会设置GetLastError。即使函数成功，但倘若返回的句柄属于一个现成的文件映射对象，那么GetLastError也会设置成ERROR_ALREADY_EXISTS。在这种情况下，文件映射的长度就是现有对象的长度，而不是这个函数指定的尺寸
    .参数 文件映射句柄, 整数型, , 指定欲在其中创建映射的一个文件句柄。&HFFFFFFFF&表示在内存中创建一个文件映射
    .参数 安全对象, 整数型, , SECURITY_ATTRIBUTES，指定一个安全对象，在创建文件映射时使用。如果为NULL（用ByVal As Long传递零），表示使用默认安全对象
    .参数 打开映射方式, 整数型, , 下述常数之一：;PAGE_READONLY：以只读方式打开映射;PAGE_READWRITE：以可读、可写方式打开映射;PAGE_WRITECOPY：为写操作留下备份可组合使用下述一个或多个常数;SEC_COMMIT：为文件映射一个小节中的所有页分配内存;SEC_IMAGE：文件是个可执行文件;SEC_RESERVE：为没有分配实际内存的一个小节保留虚拟内存空间
    .参数 文件映射最大长度, 整数型, , 文件映射的最大长度（高32位）
    .参数 文件映射的最小长度, 整数型, , 文件映射的最小长度（低32位）。如这个参数和dwMaximumSizeHigh都是零，就用磁盘文件的实际长度
    .参数 映射对象名, 文本型, , 指定文件映射对象的名字。如存在这个名字的一个映射，函数就会打开它。用vbNull创建一个无名的文件映射;

.DLL命令 SetDIBitsToDevice, 整数型, "gdi32.dll", "SetDIBitsToDevice", 公开, 置位图到设备场景_GDI32.DLL将一幅与设备无关位图的全部或部分数据直接复制到一个设备。这个函数在设备中定义了一个目标矩形，以便接收位图数据。它也在DIB中定义了一个源矩形，以便从中提取数据  执行成功则返回扫描线的数量，零表示失败。会设置GetLastError
    .参数 设备场景句柄, 整数型, , hdc，一个设备场景的句柄。该场景用于接收位图数据
    .参数 目标矩形横坐标, 整数型, , x，用逻辑坐标表示的目标矩形的起点
    .参数 目标矩形纵坐标, 整数型, , y，用逻辑坐标表示的目标矩形的起点
    .参数 目标矩形宽度, 整数型, , dx，用目标矩形的设备单位表示的宽度及高度
    .参数 目标矩形高度, 整数型, , dy，用目标矩形的设备单位表示的宽度及高度
    .参数 源矩形横坐标, 整数型, , SrcX，用设备坐标表示的源矩形在DIB中的起点
    .参数 源矩形纵坐标, 整数型, , SrcY，用设备坐标表示的源矩形在DIB中的起点
    .参数 扫描线初始编号, 整数型, , Scan，Bits数组中第一条扫描线的编号。如BitsInfo之BITMAPINFOHEADER部分的biHeight字段是正数，那么这条扫描线就会从位图的底部开始计算；如果是负数，就从顶部开始计算
    .参数 扫描线数量, 整数型, , NumScans，欲复制的扫描线数量
    .参数 缓冲区指针, 字节型, 传址, Bits，指向一个缓冲区的指针。这个缓冲区包含了以DIB格式描述的位图数据；这种格式是由BitsInfo指定的
    .参数 位图结构, 位图信息_, , BitsInfo，对Bits DIB的格式和颜色进行描述的一个结构
    .参数 常量标志, 整数型, , wUsage，常数

.DLL命令 SHGetPathFromIDListA, 整数型, "shell32.dll", "SHGetPathFromIDListA", 公开, _从列表id取路径
    .参数 pIdl, 整数型
    .参数 pszPath, 文本型, 传址

.DLL命令 SHGetPathFromIDListW, 逻辑型, "shell32.dll", "SHGetPathFromIDListW"
    .参数 pIdl, 整数型
    .参数 pszPath, 整数型

.DLL命令 SetBkMode, 整数型, "gdi32.dll", "SetBkMode", 公开, gdi32.dll指定阴影刷子、虚线画笔以及字符中的空隙的填充方式　前一个背景模式的值
    .参数 hdc, 整数型, , 设备场景的句柄
    .参数 nBkMode, 整数型, , 下述常数之一：;OPAQUE：用当前的背景色填充虚线画笔、阴影刷子以及字符的空隙;TRANSPARENT：透明处理，即不作上述填充;  

.DLL命令 TextOutA, 整数型, "gdi32.dll", "TextOutA", 公开, _文本绘图gdi32.dll文本绘图函数。也请参考SetTextAlign　非零表示成功，零表示失败。会设置GetLastError
    .参数 设备场景, 整数型, , 设备场景的句柄
    .参数 横, 整数型, , 绘图的起点，采用逻辑坐标
    .参数 纵, 整数型, , 同上
    .参数 内容, 文本型, , 欲描绘的字串
    .参数 内容数量, 整数型, , 字串中要描绘的字符数量;  

.DLL命令 SetTextColor, 整数型, "gdi32.dll", "SetTextColor", 公开, gdi32.dll设置当前文本颜色。这种颜色也称为“前景色”　文本色的前一个RGB颜色设定。CLR_INVALID表示失败。会设置GetLastError
    .参数 设备场景, 整数型, , 设备场景的句柄
    .参数 颜色, 整数型, , 新的文本色在VB里使用如改变了这个设置，注意恢复VB窗体或控件原始的文本颜色;

.DLL命令 SelectObject, 整数型, "gdi32.dll", "SelectObject", 公开, 选入设备场景
    .参数 hdc, 整数型
    .参数 hgdiobj, 整数型

.DLL命令 CreateCompatibleBitmap, 整数型, "gdi32.dll", "CreateCompatibleBitmap", 公开, 创建设备位图
    .参数 设备场景句柄, 整数型
    .参数 位图宽度, 整数型
    .参数 位图高度, 整数型

.DLL命令 CreateFontA, 整数型, "gdi32.dll", "CreateFontA", 公开, g创建字体_ di32.dll用指定属性创建逻辑字体_,执行成功则返回逻辑字体的句柄零表示失败——返回值：如果函数调用成功，返回值是一种逻辑字体句柄；如果函数调用失败，返回值为NULL。备注：当一种字体不再使用时，可用DeleteObject来删除。为保护那些提供字体给Windows和Windows NT的卖主的版权，基于Win32的应用程序总是列出所选择字体的准确名字。由于不同的系统会使用不同的字体，不要认为所选择字体就是要求的字体。例如，如果要求名叫Palatino的字体，但系统没提供那样一种字体，则字体映射器将会以一种不同名但有相似属性的字体取而代之。系统总是将用户选择的字体名报告出来。
    .参数 字体高度, 整数型, , Height字体高度指定字体的字符单元或字符的逻辑单位高度，字符的高度值（也被称为em高度）是指字符单元高度值减去内部标头值。字体映射器以如下方式解释nHeight指定的值，各值含义为：
    .参数 字体宽度, 整数型, , Width指定所要求字体的字符的逻辑单位的平均宽度。如果此值为0，字体映射器选择一个closest match值，closest match值是由比较当前设备的特征系数与可使用字体的数字化特征系数之差的绝对值而确定的
    .参数 旋转, 整数型, , Escapement指定移位向量和设备X轴之间的一个角度，以十分之一度为单位。移位向量平行于正文行的基线。Windows NT：当图形设备设置为GM_ADVANCED时，可以不依赖字符串的字符的定位角而指定字符串的移位角.当图形模式被设置为GM_COMPATIBLE时，nEscapement同时指定移位角和定位角，可以设置nEscapement和nOrientation为相同的值。Windows 95：nEscapement同时指定移位角和定位角，可设置nEscapement和nOrientation为相同的值。
    .参数 Orientation, 整数型, , 指定每个字符的基线和设备X轴之间的角度
    .参数 加粗, 整数型, , Weight在0到1000之间指定字体的权值，如400表示标准体，700表示黑（粗）体，如果此值为0，则使用缺省的权值。    为方便定义，可使用如下值：
    .参数 倾斜, 逻辑型, , Italic如果设置为TRUE则指定斜体
    .参数 下划线, 逻辑型, , Underline如果设置为TRUE，则指定加下划线的字全
    .参数 删除线, 逻辑型, , StrikeOut如果设置为TRUE，则strikeout指定字体。
    .参数 内码, 整数型, , CharSetfdwCharSet：指定字符集，下列值是预定义的：
    .参数 OutputPrecision, 整数型, , fdwOutputPrecision：指定输出精度，输出精度义输出与要求的字体高度、宽度、字符定位、移位、字符间距和字符类型的匹配程序，它可取下列值之一：
    .参数 CP, 整数型, , ClipPrecision指定裁剪精度，裁剪精度定义如何裁剪部分超出裁剪区的字符，它可取一个或多个下列值：
    .参数 输出质量, 整数型, , fdwQuality指向输出质量，输出质量定义GDI如何仔细地将逻辑字体属性与实际物理字体属性相匹配。它可取下列值之一：
    .参数 PAF, 整数型, , PitchAndFamily指定字体间距和字体族，低端二位指定字体的字符间距，它可取下列值之一：
    .参数 新字体名, 文本型, , FaceName指向指定字体的字样名的、以\0结束的字符串指针，字符串的长度不能超过32个字符（包括字符\0），函数EnumFontFamilies可用来列举所有当前可用字体的字样名。如果lpszFace为NULL或指向一个空串，GDI使用能匹配其他属性的第一种字体。

.DLL命令 IsDebuggerPresent, 逻辑型, "kernel32.dll", "IsDebuggerPresent", 公开, 程序是否被调试

.DLL命令 CreateCompatibleDC, 整数型, "gdi32.dll", "CreateCompatibleDC", 公开, 创建内存场景
    .参数 hdc, 整数型

.DLL命令 CreateEvent, 整数型, "Kernel32.dll", "CreateEventA", 公开, 创建事件同步对象
    .参数 lpEventAttributes, 整数型
    .参数 bManualReset, 逻辑型
    .参数 bInitialState, 逻辑型
    .参数 lpName, 文本型

.DLL命令 CreateEventW, 整数型, "Kernel32.dll", "CreateEventW"
    .参数 lpEventAttributes, 整数型
    .参数 bManualReset, 逻辑型
    .参数 bInitialState, 逻辑型
    .参数 lpName, 字节集

.DLL命令 LookupPrivilegeValueA, 逻辑型, "advapi32.dll", "LookupPrivilegeValueA", , _恢复权限
    .参数 lpSystemName, 整数型
    .参数 lpName, 文本型
    .参数 lpLuid, LUID

.DLL命令 OpenEventA, 整数型, "kernel32.dll", "OpenEventA", 公开, 打开事件同步对象
    .参数 dwDesiredAccess, 整数型
    .参数 bInheritHandle, 逻辑型
    .参数 lpName, 文本型

.DLL命令 OpenEventW, 整数型, "Kernel32.dll", "OpenEventW"
    .参数 dwDesiredAccess, 整数型
    .参数 bInheritHandle, 逻辑型
    .参数 lpName, 字节集

.DLL命令 lstrcpynA_字节集, 整数型, "kernel32.dll", "lstrcpynA", 公开
    .参数 lpString1, 字节集, 传址
    .参数 lpString2, 字节集, 传址
    .参数 iMaxLength, 整数型

.DLL命令 lstrcpynA_整数数组, 整数型, "kernel32.dll", "lstrcpynA", 公开, ,
    .参数 数据1, 整数型, 数组, lpString1
    .参数 数据2, 整数型, 数组, lpString2
    .参数 数据长度, 整数型, , iMaxLength

.DLL命令 lstrcpynA_整数传址, 整数型, "kernel32.dll", "lstrcpynA"
    .参数 lpString1, 整数型, 传址
    .参数 lpString2, 整数型, 传址
    .参数 iMaxLength, 整数型

.DLL命令 lstrcpynA_字节型, 文本型, "kernel32.dll", "lstrcpynA", 公开
    .参数 lpString1, 字节型, 数组
    .参数 lpString2, 字节型
    .参数 iMaxLength, 整数型

.DLL命令 lstrcpynA_指针, 子程序指针, "kernel32.dll", "lstrcpynA", 公开
    .参数 参数1, 整数型
    .参数 参数2, 整数型
    .参数 保留, 整数型

.DLL命令 lstrcpynA_文本, 整数型, "kernel32.dll", "lstrcpynA", 公开, _复制字符串
    .参数 lpString1, 文本型, 传址
    .参数 lpString2, 文本型, 传址
    .参数 iMaxLength, 整数型

.DLL命令 SwapMouseButton, 逻辑型, "user32.dll", "SwapMouseButton", 公开, 鼠标左右键交换
    .参数 鼠标按钮方式, 逻辑型, , bSwap，Long，倘若为TRUE（非零），则互换两个鼠标按钮的功能。FALSE则恢复正常状态

.DLL命令 ZwResumeProcess, , "NTDLL.DLL", "ZwResumeProcess", 公开, 进程恢复
    .参数 进程句柄

.DLL命令 ZwSuspendProcess, , "NTDLL.DLL", "ZwSuspendProcess", 公开, 进程暂停
    .参数 进程句柄

.DLL命令 ResumeThread, 整数型, "kernel32.dll", "ResumeThread", 公开, 线程_恢复   恢复执行用SuspendThread挂起的一个线程,Long，调用这个函数前的挂起计数。&HFFFFFFFF表示出错。会设置GetLastError
    .参数 hThread, 整数型

.DLL命令 SuspendThread, 整数型, "kernel32.dll", "SuspendThread", 公开, 线程_挂起  将指定线程的执行挂起，调用这个函数前的挂起计数。&HFFFFFFFF表示出错。会设置GetLastError
    .参数 hThread, 整数型

.DLL命令 WaitForSingleObject, 整数型, "kernel32.dll", "WaitForSingleObject", 公开, 线程等待
    .参数 hHandle, 整数型, , 线程句柄
    .参数 dwMilliseconds, 整数型, , 值为:4294967295

.DLL命令 InitializeCriticalSection, , "kernel32.dll", "InitializeCriticalSection", 公开, 创建许可证
    .参数 lpCriticalSection, 线程许可证, 传址

.DLL命令 DeleteCriticalSection, , "kernel32.dll", "DeleteCriticalSection", 公开, _删除许可证
    .参数 lpCriticalSection, 线程许可证, 传址

.DLL命令 EnterCriticalSection, , "kernel32.dll", "EnterCriticalSection", 公开, _进入许可区
    .参数 lpCriticalSection, 线程许可证, 传址

.DLL命令 LeaveCriticalSection, , "kernel32.dll", "LeaveCriticalSection", 公开, 退出许可区
    .参数 lpCriticalSection, 线程许可证, 传址

.DLL命令 DuplicateHandle, 整数型, "kernel32.dll", "DuplicateHandle", 公开, 复制对象句柄
    .参数 源进程句柄, 整数型, , hSourceProcessHandle,参见相关帮助
    .参数 现句柄, 整数型, , hSourceHandle,指定对象的现有句柄
    .参数 新进程句柄, 整数型, , hTargetProcessHandle,参见相关帮助
    .参数 转载句柄变量, 整数型, 传址, lpTargetHandle,指定用于装载新句柄的长整型变量
    .参数 新句柄安全访问级别, 整数型, , dwDesiredAccess,新句柄要求的安全访问级别
    .参数 继承句柄, 整数型, , bInheritHandle Long，参见相关帮助
    .参数 复选项, 整数型, , dwOptions

.DLL命令 CloseHandle, 逻辑型, "kernel32.dll", "CloseHandle", 公开, 关闭一个内核对象。其中包括文件、文件映射、进程、线程、安全和同步对象等。涉及文件处理时，这个函数通常与vb的close命令相似。应尽可能的使用close，因为它支持vb的差错控制。注意这个函数使用的文件句柄与vb的文件编号是完全不同的  非零表示成功，零表示失败。会设置GetLastError
    .参数 对象句柄, 整数型, , 欲关闭的一个对象的句柄;

.DLL命令 lstrlen, 整数型, "kernel32.dll", "lstrlenW", 公开, 取字节长度　
    .参数 lpString, 整数型

.DLL命令 _设备操作3, 整数型, "kernel32.dll", "DeviceIoControl"
    .参数 hDevice, 整数型
    .参数 dwIoControlCode, 整数型
    .参数 lpInBuffer, SCIP, 传址
    .参数 nInBufferSize, 整数型
    .参数 lpOutBuffer, 字节集, 传址
    .参数 nOutBufferSize, 整数型
    .参数 lpBytesReturned, 整数型, 传址
    .参数 lpOverlapped, 整数型

.DLL命令 DeviceIoControl1, 逻辑型, "kernel32.dll", "DeviceIoControl", 公开, 设备操作4
    .参数 hDevice, 整数型
    .参数 dwIoControlCode, 整数型
    .参数 lpInBuffer, 整数型
    .参数 nInBufferSize, 整数型
    .参数 lpOutBuffer, 整数型
    .参数 nOutBufferSize, 整数型
    .参数 lpBytesReturned, 整数型, 传址
    .参数 lpOverlapped, 整数型

.DLL命令 Process32Next, 整数型, "kernel32.dll", "Process32Next", 公开, 取下一个进程
    .参数 h, 整数型
    .参数 p, 精易_进程信息列表

.DLL命令 GetModuleFileNameExA, 整数型, "Psapi.dll", "GetModuleFileNameExA", 公开, _进程取全路径名
    .参数 hProcess, 整数型
    .参数 hModule, 整数型, , 0
    .参数 lpFilename, 文本型, , 1000
    .参数 nSize, 整数型, , 1000

.DLL命令 GetModuleFileNameExW, 整数型, "Psapi.dll", "GetModuleFileNameExW"
    .参数 hProcess, 整数型
    .参数 hModule, 整数型
    .参数 lpFilename, 整数型
    .参数 nSize, 整数型

.DLL命令 Process32First, 整数型, "kernel32.dll", "Process32First", 公开, 取第一个进程
    .参数 hSnapshot, 整数型
    .参数 lppe, 精易_进程信息列表

.DLL命令 OpenProcess, 整数型, "kernel32.dll", "OpenProcess", 公开, 打开进程
    .参数 进程对象, 整数型
    .参数 继承句柄, 整数型
    .参数 进程标识符, 整数型

.DLL命令 AdjustTokenPrivileges, 逻辑型, "Advapi32.dll", "AdjustTokenPrivileges", , 使能/取消令牌特权 _进程置权限
    .参数 令牌句柄, 整数型
    .参数 DisableAllPrivileges, 逻辑型
    .参数 NewState, TOKEN_PRIVILEGES
    .参数 BufferLength, 整数型
    .参数 PreviousState, 整数型
    .参数 ReturnLength, 整数型

.DLL命令 TerminateProcess, 逻辑型, "kernel32.dll", "TerminateProcess", 公开, _进程终止
    .参数 hProcess, 整数型, , PID
    .参数 uExitCode, 整数型

.DLL命令 GetCurrentProcessId, 整数型, "kernel32.dll", "GetCurrentProcessId", 公开, 取自进程ID

.DLL命令 CreateToolhelp32Snapshot, 整数型, "kernel32.dll", "CreateToolhelp32Snapshot", 公开, 创建进程快照
    .参数 falg, 整数型
    .参数 id, 整数型

.DLL命令 GetWindowThreadProcessId, 整数型, "user32.dll", "GetWindowThreadProcessId", 公开, 线程_取ID
    .参数 hWnd, 整数型, , 指定窗口句柄
    .参数 lpdwProcessId, 整数型, 传址, 用于装载进程ID的变量

.DLL命令 LBItemFromPt, 整数型, "comctl32.dll", "LBItemFromPt", 公开, 列表框_鼠标坐标取项目索引
    .参数 hwnd, 整数型, , hwnd
    .参数 横向位置, 整数型, , ptx
    .参数 纵向位置, 整数型, , pty
    .参数 自动滚动, 逻辑型, , bAutoScroll

.DLL命令 ShowWindow, 逻辑型, "user32.dll", "ShowWindow", 公开, 窗口_置状态
    .参数 hwnd, 整数型, , 窗口句柄，要向这个窗口应用由命令
    .参数 nCmdShow, 整数型, , 为窗口指定的一个命令。请用下述任何一个常数:0 隐藏取消激活  1 还原激活 2 最小化激活 3 最大化激活 4 还原 6 最小化取消激活 7 最小化 9 还原激活

.DLL命令 SetWindowPos, 整数型, "user32.dll", "SetWindowPos", 公开, _窗口置最前
    .参数 hwnd, 整数型, , 欲定位的窗口
    .参数 hWndInsertAfter, 整数型
    .参数 x, 整数型, , 窗口新的x坐标。如hwnd是一个子窗口，则x用父窗口的客户区坐标表示
    .参数 y, 整数型, , 窗口新的y坐标。如hwnd是一个子窗口，则y用父窗口的客户区坐标表示
    .参数 cx, 整数型, , 指定新的窗口宽度
    .参数 cy, 整数型, , 指定新的窗口高度
    .参数 wFlags, 整数型

.DLL命令 CloseWindow, 整数型, "user32.dll", "CloseWindow", 公开, 窗口_最小化, 非0表示成功，0表示失败
    .参数 hwnd, 整数型, , hwnd，欲最小化窗口的窗口句柄

.DLL命令 ShowWindowAsync, 逻辑型, "user32.dll", "ShowWindowAsync", 公开, 窗口_显示隐藏
    .参数 hWnd, 整数型, , 欲接收ShowWindow命令的窗口
    .参数 nCmdShow, 逻辑型, , 与ShowWindow相同

.DLL命令 BringWindowToTop, 逻辑型, "user32.dll", "BringWindowToTop", 公开, 窗口置顶
    .参数 hwnd, 整数型, , hwnd,欲带至顶部的那个窗口的句柄

.DLL命令 EnableWindow, 逻辑型, "user32.dll", "EnableWindow", , 窗口_锁住解锁, 在指定的窗口里允许或禁止所有鼠标及键盘输入
    .参数 hwnd, 整数型, , hwnd，窗口句柄
    .参数 标识符, 逻辑型, , fEnable，非零允许，零禁止

.DLL命令 GetForegroundWindow, 整数型, "user32.dll", "GetForegroundWindow", 公开, ,窗口_取顶端窗口句柄

.DLL命令 ExtractIconExA, 整数型, "shell32.dll", "ExtractIconExA", 公开, 提取图标扩展
    .参数 文件名, 文本型, , lpszFile
    .参数 图标索引, 整数型, , nIconIndex
    .参数 大图标句柄, 整数型, 传址, phiconLarge
    .参数 小图标句柄, 整数型, , phiconSmall
    .参数 图标数量, 整数型, , nIcons

.DLL命令 MoveWindow, 逻辑型, "user32.dll", "MoveWindow", 公开, 窗口_置位置和大小
    .参数 hwnd, 整数型
    .参数 左侧位置, 整数型
    .参数 顶部位置, 整数型
    .参数 新宽度, 整数型
    .参数 新高度, 整数型
    .参数 是否重画, 逻辑型

.DLL命令 GetWindowRect, 逻辑型, "user32.dll", "GetWindowRect", 公开,    获得整个窗口的范围矩形，窗口的边框、标题栏、滚动条及菜单等都在这个矩形内
    .参数 句柄, 整数型, , Long，想获得范围矩形的那个窗口的句柄
    .参数 大小, 精易_矩形, 传址, RECT，屏幕坐标中随同窗口装载的矩形(左边,顶边,右边,底边)

.DLL命令 IsZoomed, 逻辑型, "user32.dll", "IsZoomed", 公开, 窗口_是否最大化 判断窗口是否已最大化 非零表示成功，零表示失败
    .参数 hwnd, 整数型, , 要测试的那个窗口的句柄

.DLL命令 IsIconic, 逻辑型, "user32.dll", "IsIconic", 公开, 窗口_是否最小化 判断窗口是否已最小化 非零表示成功，零表示失败
    .参数 hwnd, 整数型, , 要测试的那个窗口的句柄

.DLL命令 IsWindowVisible, 逻辑型, "user32.dll", "IsWindowVisible", 公开, 窗口_是否可见  判断窗口是否可见  返回真为可见，否则为不可见
    .参数 hwnd, 整数型, , 要测试的那个窗口的句柄

.DLL命令 StrTrimA, 整数型, "shlwapi.dll", "StrTrimA", 公开, _文本修剪
    .参数 psz, 文本型
    .参数 pszTrimChars, 文本型

.DLL命令 FlashWindow, 逻辑型, "user32.dll", "FlashWindow", 公开, 窗口_闪动
    .参数 hwnd, 整数型
    .参数 bInvert, 逻辑型, , 是否闪动窗口

.DLL命令 lstrlenA, 整数型, "kernel32.dll", "lstrlenA", 公开
    .参数 lpString, 整数型

.DLL命令 PathRemoveBlanksA, 整数型, "shlwapi.dll", "PathRemoveBlanksA", , 文本_删首尾空, 删除文本首部尾部的空格
    .参数 文本, 整数型, , pszPath

.DLL命令 WideCharToMultiByte, 整数型, "kernel32.dll", "WideCharToMultiByte", 公开
    .参数 CodePage, 整数型
    .参数 dwFlags, 整数型
    .参数 lpWideCharStr, 整数型
    .参数 cchWideChar, 整数型
    .参数 lpMultiByteStr, 整数型
    .参数 cbMultiByte, 整数型
    .参数 lpDefaultChar, 整数型
    .参数 lpUsedDefaultChar, 整数型

.DLL命令 _文本简繁体转换, 整数型, "kernel32.dll", "LCMapStringA"
    .参数 Locale, 整数型
    .参数 dwMapFlags, 整数型
    .参数 lpSrcStr, 文本型
    .参数 cchSrc, 整数型
    .参数 lpDestStr, 文本型
    .参数 ByVal, 整数型

.DLL命令 GetDC, 整数型, "user32.dll", "GetDC", 公开, 取设备场景
    .参数 hwnd, 整数型

.DLL命令 ReleaseDC, 整数型, "user32.dll", "ReleaseDC", 公开, 释放设备场景
    .参数 hwnd, 整数型
    .参数 设备句柄, 整数型

.DLL命令 GetPixel, 整数型, "gdi32.dll", "GetPixel", 公开, 鼠标取坐标颜色
    .参数 设备句柄, 整数型
    .参数 横坐标, 整数型
    .参数 纵坐标, 整数型

.DLL命令 _位图复制2, 整数型, "gdi32.dll", "GetDIBits", , _位图复制2 将来自一幅位图的二进制位复制到一幅与设备无关的位图里　非零表示成功，零表示失败。在Windows 95中，返回值是返回的扫描线数量
    .参数 aHDC, 整数型, , 定义了与设备有关位图hBitmap的配置信息的一个设备场景的句柄
    .参数 hBitmap, 整数型, , 源位图的句柄。绝对不能将这幅位图选入设备场景
    .参数 nStartScan, 整数型, , 欲复制到DIB中的第一条扫描线的编号
    .参数 nNumScans, 整数型, , 欲复制的扫描线数量
    .参数 lpBits, 整数型, , 指向一个缓冲区的指针。这个缓冲区将用于装载采用DIB格式的信息，但不取回数据（用ByVal传递零值）
    .参数 lpBI, _验证码取图, , BITMAPINFO，对lpBits DIB的格式及颜色进行说明的一个结构。在BITMAPINFOHEADER结构中，从biSize到biCompression之间的所有字段都必须初始化
    .参数 wUsage, 整数型, , 下述常数之一：;DIB_PAL_COLORS：在颜色表中装载一个16位所以数组，它们与当前选定的调色板有关;DIB_RGB_COLORS：在颜色表中装载RGB颜色;  

.DLL命令 GetDIBits2, 整数型, "gdi32.dll", "GetDIBits", 公开
    .参数 aHDC, 整数型
    .参数 hBitmap, 整数型
    .参数 nStartScan, 整数型
    .参数 nNumScans, 整数型
    .参数 lpBits, 字节型, 传址
    .参数 lpBI, 字节型, 传址
    .参数 wUsage, 整数型

.DLL命令 GetDIBits_x, 整数型, "gdi32.dll", "GetDIBits", , 将来自一幅位图的二进制位复制到一幅与设备无关的位图里　非零表示成功，零表示失败。在Windows 95中，返回值是返回的扫描线数量
    .参数 aHDC, 整数型, , 定义了与设备有关位图hBitmap的配置信息的一个设备场景的句柄
    .参数 hBitmap, 整数型, , 源位图的句柄。绝对不能将这幅位图选入设备场景
    .参数 nStartScan, 整数型, , 欲复制到DIB中的第一条扫描线的编号
    .参数 nNumScans, 整数型, , 欲复制的扫描线数量
    .参数 lpBits, 整数型, , 指向一个缓冲区的指针。这个缓冲区将用于装载采用DIB格式的信息，但不取回数据（用ByVal传递零值）
    .参数 lpBI, BITMAPINFOHEADER, , BITMAPINFO，对lpBits DIB的格式及颜色进行说明的一个结构。在BITMAPINFOHEADER结构中，从biSize到biCompression之间的所有字段都必须初始化
    .参数 wUsage, 整数型, , 下述常数之一：;DIB_PAL_COLORS：在颜色表中装载一个16位所以数组，它们与当前选定的调色板有关;DIB_RGB_COLORS：在颜色表中装载RGB颜色;  

.DLL命令 GetDIBits1, 整数型, "gdi32.dll", "GetDIBits", 公开, _位图复制1
    .参数 HDC, 整数型
    .参数 hBitmap, 整数型
    .参数 nStartScan, 整数型
    .参数 nNumScans, 整数型
    .参数 lpBits, 整数型
    .参数 lpBI, BITMAPINFO
    .参数 wUsage, 整数型

.DLL命令 GetDIBits, 整数型, "gdi32.dll", "GetDIBits", 公开, _位图复制 将来自一幅位图的二进制位复制到一幅与设备无关的位图里
    .参数 HDC, 整数型
    .参数 hBitmap, 整数型
    .参数 nStartScan, 整数型
    .参数 nNumScans, 整数型
    .参数 lpBits, 字节集
    .参数 lpBI, BITMAPINFO
    .参数 wUsage, 整数型

.DLL命令 BitBlt, 逻辑型, "gdi32.dll", "BitBlt", 公开, 复制场景位图
    .参数 目标设备场景, 整数型
    .参数 目标横坐标, 整数型
    .参数 目标纵坐标, 整数型
    .参数 传输图像宽度, 整数型
    .参数 传输图像高度, 整数型
    .参数 源设备场景, 整数型
    .参数 源横坐标, 整数型
    .参数 源纵坐标, 整数型
    .参数 光栅运算方式, 整数型

.DLL命令 VirtualAlloc, 整数型, "Kernel32.dll", "VirtualAlloc", 公开
    .参数 lpAddress, 整数型
    .参数 dwSize, 整数型
    .参数 flAllocationType, 整数型
    .参数 flProtect, 整数型

.DLL命令 MultiByteToWideChar, 整数型, "Kernel32.dll", "MultiByteToWideChar", 公开, 该函数映射一个字符串到一个宽字符（unicode）的字符
    .参数 CodePage, 整数型
    .参数 dwFlags, 整数型
    .参数 lpMultiByteStr, 整数型
    .参数 cchMultiByte, 整数型
    .参数 lpWideCharStr, 整数型
    .参数 cchWideChar, 整数型

.DLL命令 API_文本小写, 文本型, "ntdll.dll", "@_strlwr", , API转换文本为小写
    .参数 原始文本, 文本型, 传址

.DLL命令 API_查找文本, 整数型, "ntdll.dll", "@strstr"
    .参数 原始文本, 整数型
    .参数 查找内容, 文本型, 传址

.DLL命令 CharUpperA, 文本型, "user32.dll", "CharUpperA", 公开, 把字符串中的字母都转换成大写的
    .参数 str, 文本型

.DLL命令 CharLowerA, 文本型, "user32.dll", "CharLowerA", 公开, 把字符串中的字母都转换成小写的
    .参数 str, 文本型

.DLL命令 GetClientRect, 逻辑型, "user32.dll", "GetClientRect", 公开, ,窗口_取控件大小
    .参数 hwnd, 整数型
    .参数 矩形区域, 精易_矩形, 传址

.DLL命令 IsChild, 逻辑型, "user32.dll", "IsChild", 公开, 窗口_是否子窗口 user32.dll判断一个窗口是否为另一窗口的子或隶属窗口
    .参数 父窗口的句柄, 整数型, , 父窗口的句柄
    .参数 欲判断的窗口句柄, 整数型, , 欲判断的窗口句柄

.DLL命令 SetParent, 整数型, "user32.dll", "SetParent", 公开, 窗口_置父   指定一个窗口的新父(返回  前一个父窗口的句柄)
    .参数 子窗口句柄, 整数型
    .参数 父窗口句柄, 整数型

.DLL命令 IsWindow, 整数型, "user32.dll", "IsWindow", 公开, 窗口_句柄是否有效  判断一个窗口句柄是否有效(非零表示成功，零表示失败)
    .参数 hwnd, 整数型

.DLL命令 EnumChildWindows_整数, 逻辑型, "user32.dll", "EnumChildWindows", 公开
    .参数 hWndParent, 整数型, , 0
    .参数 lpEnumFunc, 整数型, , 0
    .参数 lParam, 整数型, , 0

.DLL命令 EnumChildWindows, 逻辑型, "user32.dll", "EnumChildWindows", 公开
    .参数 父窗口句柄, 整数型
    .参数 函数指针, 子程序指针
    .参数 自定义值, 整数型

.DLL命令 EnumWindows, 逻辑型, "user32.dll", "EnumWindows", 公开, 窗口_枚举
    .参数 枚举过程, 子程序指针
    .参数 参数, 整数型

.DLL命令 SetActiveWindow, 整数型, "user32.dll", "SetActiveWindow", 公开, 激活窗口
    .参数 hwnd, 整数型

.DLL命令 RedrawWindow, 逻辑型, "user32.dll", "RedrawWindow", 公开, 窗口_重画
    .参数 hwnd, 整数型
    .参数 矩形, 精易_矩形
    .参数 区域, 整数型
    .参数 旗帜, 整数型

.DLL命令 EnableMenuItem, 整数型, "user32.dll", "EnableMenuItem", 公开, 窗口禁止关闭
    .参数 hMenu, 整数型
    .参数 wIDEnableItem, 整数型
    .参数 wEnable, 整数型

.DLL命令 OpenIcon, 逻辑型, "user32.dll", "OpenIcon", 公开, 窗口_还原   恢复一个最小化的程序，并将其激活
    .参数 hwnd, 整数型

.DLL命令 GetFocus, 整数型, "user32.dll", "GetFocus", 公开, 窗口_取焦点句柄, GetFocus，获得自身拥有输入焦点的窗口的句柄

.DLL命令 GetDesktopWindow, 整数型, "user32.dll", "GetDesktopWindow", 公开, 窗口_取屏幕句柄

.DLL命令 ChildWindowFromPoint, 整数型, "user32.dll", "ChildWindowFromPoint", 公开, 窗口_取坐标子句柄 user32.dll取父窗口中包含了指定坐标的第一个子窗口句柄(与其它取窗口句柄不同的是:可取出不可视或透明的窗口)
    .参数 父窗口句柄, 整数型, , 欲取坐标句柄所在的父窗口句柄
    .参数 横坐标, 整数型, , 指定横坐标
    .参数 纵坐标, 整数型, , 指定纵坐标

.DLL命令 GetClassNameA, 整数型, "user32.dll", "GetClassNameA", 公开, 窗口_取类名 为指定的窗口取得类名　以字节数表示的类名长度；排除最后的空中止字符。零表示出错。会设置GetLastError
    .参数 句柄, 整数型, , 欲获得类名的那个窗口的句柄
    .参数 文本, 文本型, 传址, 随同类名载入的缓冲区。预先至少必须分配nMaxCount+1个字符
    .参数 文本长度, 整数型, , 由lpClassName提供的缓冲区长度;

.DLL命令 SetWindowRgn, 整数型, "user32.dll", "SetWindowRgn", 公开, 为区域指定的所有坐标都以窗口坐标（不是客户坐标）表示，它们以整个窗口（包括标题栏和边框）的左上角为起点
    .参数 hwnd, 整数型, , 将设置其区域的窗口
    .参数 区域, 整数型, , 将设置的区域的句柄，一旦设置了该区域，就不能使用或修改该区域句柄，也不要删除它
    .参数 自动刷新, 逻辑型, , Boolean，若为TRUE，则立即重画窗口

.DLL命令 AtlAxWinInit, , "atl.dll", "AtlAxWinInit", 公开

.DLL命令 AtlAxGetControl, 整数型, "atl.dll", "AtlAxGetControl", 公开
    .参数 h, 整数型
    .参数 x, 对象

.DLL命令 GetTextExtentPointA, , "gdi32.dll", "GetTextExtentPointA", 公开
    .参数 hdc, 整数型
    .参数 lpString, 文本型
    .参数 cbString, 整数型
    .参数 lpSize, 精易_坐标

.DLL命令 CreateWindowExA, 整数型, "user32.dll", "CreateWindowExA", 公开, 创建窗口_
    .参数 扩展风格, 整数型
    .参数 类名, 文本型, , 刚才注册的类名
    .参数 窗口标题, 文本型
    .参数 风格, 整数型
    .参数 屏幕横坐标, 整数型
    .参数 屏幕纵坐标, 整数型
    .参数 宽度, 整数型
    .参数 高度, 整数型
    .参数 父窗口句柄, 整数型, , 没有就写0
    .参数 菜单句柄, 整数型
    .参数 模块句柄, 整数型
    .参数 参数, 整数型

.DLL命令 CreateWindowExW, 整数型, "user32", "CreateWindowExW", 公开, 创建窗口
    .参数 dwExStyle, 整数型, , 窗口的扩展风格
    .参数 lpClassName, 字节集, , 注册类名
    .参数 lpWindowName, 字节集, , 窗口名称
    .参数 dwStyle, 整数型, , 窗口风格
    .参数 x, 整数型, , 窗口的水平位置
    .参数 y, 整数型, , 窗口的垂直位置
    .参数 nWidth, 整数型, , 窗口的宽度
    .参数 nHeight, 整数型, , 窗口的高度
    .参数 hWndParent, 整数型, , 父窗口的句柄
    .参数 hMenu, 整数型, , 菜单的句柄或是子窗口的标识符
    .参数 hInstance, 整数型, , 应用程序实例的句柄
    .参数 lpParam, 整数型, , 指向窗口的创建数据

.DLL命令 GetWindowLongA, 整数型, "user32.dll", "GetWindowLongA", 公开, 获取窗口信息
    .参数 hwnd, 整数型
    .参数 属性, 整数型

.DLL命令 GetWindowLongW, 整数型, "User32.dll", "GetWindowLongW"
    .参数 hWnd, 整数型
    .参数 nIndex, 整数型

.DLL命令 GetWindowTextA, 整数型, "user32.dll", "GetWindowTextA", 公开, 窗口_取标题
    .参数 hwnd, 整数型
    .参数 标题名, 文本型, 传址
    .参数 长度, 整数型

.DLL命令 GetWindowTextW, 整数型, "user32.dll", "GetWindowTextW", 公开, 窗口_取标题W
    .参数 hwnd, 整数型
    .参数 标题名, 整数型
    .参数 长度, 整数型

.DLL命令 Thread32Next, 逻辑型, "Kernel32.dll", "Thread32Next", 公开, _线程取第一个
    .参数 快照句柄, 整数型
    .参数 线程入口结构, 线程入口结构

.DLL命令 SHGetSpecialFolderPathA, 逻辑型, "shell32.dll", "SHGetSpecialFolderPathA", 公开, 取系统目录
    .参数 hwndOwner, 整数型
    .参数 lpszPath, 文本型
    .参数 nFolder, 整数型
    .参数 fCreate, 逻辑型

.DLL命令 GetTempPathA, 整数型, "kernel32.dll", "GetTempPathA", 公开, 取临时目录
    .参数 目录长度, 整数型
    .参数 临时目录, 文本型

.DLL命令 SHBrowseForFolderW, 整数型, "shell32.dll", "SHBrowseForFolderW"
    .参数 lpBrowseInfo, BROWSEINFOW

.DLL命令 GetSystemDirectoryA, 整数型, "kernel32.dll", "GetSystemDirectoryA", 公开, 目录_取system32目录  成功返回system32目录的全路径
    .参数 缓冲区, 文本型
    .参数 缓冲区长度, 整数型

.DLL命令 GetWindowsDirectoryA, 整数型, "kernel32.dll", "GetWindowsDirectoryA", 公开, 目录_取Windows目录  成功返回Windows目录的全路径
    .参数 缓冲区, 文本型
    .参数 尺寸, 整数型

.DLL命令 PathMakeSystemFolderA, 整数型, "shlwapi.dll", "PathMakeSystemFolderA", 公开, 设置目录的系统属性
    .参数 目录, 文本型, , pszPath

.DLL命令 PathIsSystemFolderA, 整数型, "shlwapi.dll", "PathIsSystemFolderA", 公开, 判断目录是否有系统属性
    .参数 目录, 文本型, , pszPath
    .参数 属性标志, 整数型, 传址, dwAttrb

.DLL命令 PathUnmakeSystemFolderA, 整数型, "shlwapi.dll", "PathUnmakeSystemFolderA", 公开, 取消目录的系统属性
    .参数 目录, 文本型, , pszPath

.DLL命令 PathIsDirectoryEmptyA, 逻辑型, "shlwapi.dll", "PathIsDirectoryEmptyA", 公开, 目录_是否为空
    .参数 目录路径, 文本型

.DLL命令 PathIsDirectoryEmptyW, 逻辑型, "shlwapi.dll", "PathIsDirectoryEmptyW"
    .参数 pszPath, 字节集

.DLL命令 InternetGetCookieExA, 整数型, "wininet.dll", "InternetGetCookieExA", 公开
    .参数 lpszURL, 文本型
    .参数 lpszCookieName, 文本型
    .参数 lpszCookieData, 文本型
    .参数 lpdwSize, 整数型, 传址
    .参数 dwFlags, 整数型
    .参数 lpReserved, 整数型

.DLL命令 InternetGetCookieA, 逻辑型, "wininet.dll", "InternetGetCookieA", 公开, 读取COOKIE
    .参数 域名, 文本型
    .参数 名称, 文本型
    .参数 内容, 文本型, 传址
    .参数 尺寸, 整数型, 传址

.DLL命令 InternetSetCookieA, 逻辑型, "wininet.dll", "InternetSetCookieA", 公开, 设置COOKIE
    .参数 域名, 文本型, 传址
    .参数 名称, 文本型, 传址
    .参数 内容, 文本型, 传址

.DLL命令 ChooseColorA, 整数型, "comdlg32.dll", "ChooseColorA", 公开, 打开颜色对话框
    .参数 pChoosecolor, 精易_颜色对话框, 传址

.DLL命令 SetFilePointerEx, 逻辑型, "Kernel32.dll", "SetFilePointerEx"
    .参数 hFile, 整数型
    .参数 liDistanceToMove, 长整数型
    .参数 lpNewFilePointer, 长整数型, 传址
    .参数 dwMoveMethod, 整数型

.DLL命令 PrintWindow, 逻辑型, "User32.dll", "PrintWindow", 公开, 打印窗口
    .参数 hwnd, 整数型
    .参数 hdcBlt, 整数型
    .参数 nFlags, 整数型

.DLL命令 OpenProcessToken, 逻辑型, "advapi32.dll", "OpenProcessToken", 公开, 打开过程令牌对象OpenProcessToken
    .参数 ProcessHandle, 整数型, , 进程句柄
    .参数 DesiredAccess, 整数型, , 权限
    .参数 TokenHandle, 整数型, 传址, 令牌句柄

.DLL命令 ObjectFromLresult, 整数型, "OLEACC.DLL", "ObjectFromLresult", 公开
    .参数 lResult, 整数型
    .参数 riid, 字节集
    .参数 wParam, 整数型
    .参数 ppvObject, 对象

.DLL命令 SendMessageTimeoutA, 整数型, "user32.dll", "SendMessageTimeoutA", 公开, _同步发送消息  向窗口发送一条消息。如窗口位于不同的线程中，则利用这个函数可以指定一个超时值，以便在另一个进程挂起的时候防止调用进程也永远挂起　成功时返回TRUE，失败时返回FALSE。会设置GetLastError
    .参数 hwnd, 整数型, , 要接收消息的一个窗口的句柄
    .参数 MSG, 整数型, , 消息的标识符
    .参数 wParam, 整数型, , 由消息决定
    .参数 lParam, 整数型, , 由消息决定
    .参数 fuFlags, 整数型, , 下述常数的一个或多个;SMTO_ABORTIFHUNG：如目标进程挂起，则函数立即返回;SMTO_BLOCK：除非函数返回，否则调用线程不能处理消息;SMTO_NORMAL：允许调用线程处理消息，同时保持函数继续执行
    .参数 uTimeout, 整数型, , 超时值，采用毫秒为单位
    .参数 lpdwsult, 整数型, 传址, 用于装载函数结果的一个变量;

.DLL命令 _获取权限令牌, 整数型, "advapi32.dll", "LookupPrivilegeValueA", , 返回特权名LUID
    .参数 系统服务名, 整数型, , lpSystemName
    .参数 权限名, 文本型, 传址
    .参数 权限结构, LUID, 传址

.DLL命令 RegisterWindowMessageA, 整数型, "user32.dll", "RegisterWindowMessageA", 公开, _获取消息编号  获取分配给一个字串标识符的消息编号　&C000 到 &FFFF之间的一个消息编号。零意味着出错
    .参数 消息名称, 文本型, , 注册消息的名字;  

.DLL命令 RegisterHotKey, 逻辑型, "user32.dll", "RegisterHotKey", 公开, 热键注册
    .参数 hWnd, 整数型
    .参数 id, 整数型
    .参数 fsModifoers, 整数型
    .参数 vk, 整数型

.DLL命令 UnregisterHotKey, 逻辑型, "user32.dll", "UnregisterHotKey", 公开, 撤消热键钩子
    .参数 hWnd, 整数型
    .参数 id, 整数型

.DLL命令 OpenFileMappingA, 整数型, "kernel32.dll", "OpenFileMappingA", 公开, 打开一个现成的文件映射对象　指定文件映射对象的句柄。零表示出错。会设置GetLastError
    .参数 常数, 整数型, , 带有前缀FILE_MAP_???的一个常数。参考MapViewOfFile函数的dwDesiredAccess参数的说明
    .参数 进程继承, 整数型, , 如这个函数返回的句柄能由当前进程启动的新进程继承，则这个参数为TRUE
    .参数 文件映射对象名称, 文本型, , 指定要打开的文件映射对象名称;

.DLL命令 UnmapViewOfFile, 整数型, "kernel32.dll", "UnmapViewOfFile", 公开, _取消文件映射对象 在当前应用程序的内存地址空间对一个文件映射对象的映射
    .参数 lpBaseAddress, 整数型

.DLL命令 VirtualFreeEx_a, 整数型, "kernel32.dll", "VirtualFreeEx"
    .参数 hProcess, 整数型
    .参数 lpAddress, 整数型
    .参数 dwSize, 整数型, 传址
    .参数 dwFreeType, 整数型

.DLL命令 VirtualFree, 整数型, "kernel32.dll", "VirtualFree", , 释放虚拟页
    .参数 lpAddress, 整数型
    .参数 dwSize, 整数型
    .参数 dwFreeType, 整数型

.DLL命令 VirtualFreeEx, 整数型, "kernel32.dll", "VirtualFreeEx", 公开, 销毁外部指针
    .参数 hProcess, 整数型
    .参数 lpAddress, 整数型
    .参数 dwSize, 整数型
    .参数 flAllocationType, 整数型

.DLL命令 TerminateThread, 逻辑型, "Kernel32.dll", "TerminateThread"
    .参数 hThread, 整数型, , 线程句柄
    .参数 dwExitCode, 整数型, , 填0

.DLL命令 GetCurrentProcess, 整数型, "kernel32.dll", "GetCurrentProcess", 公开, 取当前进程伪句柄

.DLL命令 CreateThread, 整数型, "kernel32.dll", "CreateThread", 公开, 线程_启动
    .参数 lpThreadAttributes, 整数型
    .参数 dwStackSize, 整数型
    .参数 lpStartAddress, 整数型
    .参数 lpParameter, 整数型
    .参数 dwCreationFlags, 整数型, , 控制线程创建的标志。如果指定了CREATE_SUSPENDED标志，是创建线程处于暂停状态，并不会运行，直到ResumeThread函数被调用。如果这个值是零，线程创建后立即运行
    .参数 lpThreadId, 整数型

.DLL命令 RtlMoveMemory_GetUrlCache, , "kernel32.dll", "RtlMoveMemory"
    .参数 Destination, INTERNET_CACHE_ENTRY_INFO, 传址
    .参数 Source, 整数型
    .参数 Length, 整数型

.DLL命令 GetUrlCacheEntryInfo, 整数型, "wininet.dll", "GetUrlCacheEntryInfoA", 公开
    .参数 lpszUrlName, 文本型, , lpszUrlSearchPattern
    .参数 第一个Url缓存入口信息, 整数型, , lpFirstCacheEntryInfo
    .参数 第一个Url缓存入口信息大小, 整数型, 传址, lpdwFirstCacheEntryInfoBufferSize

.DLL命令 PathAppendA, 逻辑型, "shlwapi.dll", "PathAppendA", 公开, 合并路径
    .参数 pszPath, 字节集, 传址
    .参数 pszMore, 字节集

.DLL命令 PathAppendW, 逻辑型, "Shlwapi.dll", "PathAppendW"
    .参数 pszPath, 字节集
    .参数 pszMore, 字节集

.DLL命令 ImmGetDescriptionA, 整数型, "imm32.dll", "ImmGetDescriptionA", 公开, _输入法取名称
    .参数 布局, 整数型
    .参数 布局名称, 文本型
    .参数 名称长度, 整数型

.DLL命令 ImmIsIME, 整数型, "imm32.dll", "ImmIsIME", 公开, _输入法判断中文键盘布局
    .参数 hkl, 整数型

.DLL命令 DeleteDC, 整数型, "gdi32.dll", "DeleteDC", 公开
    .参数 hdc, 整数型

.DLL命令 GetKeyboardLayout, 整数型, "user32.dll", "GetKeyboardLayout", 公开, _输入法取当前的序号
    .参数 布局索引, 整数型

.DLL命令 GetLogicalDriveStringsA, 整数型, "kernel32.dll", "GetLogicalDriveStringsA", 公开, _系统取所有磁盘盘符 获取一个字串，其中包含了当前所有逻辑驱动器的根驱动器路径  装载到lpBuffer的字符数量（排除空中止字符）。如缓冲区的长度不够，不能容下路径，则返回值就变成要求的缓冲区大小。零表示失败。会设置GetLastError
    .参数 缓冲器长度, 整数型, , lpBuffer字串的长度
    .参数 缓冲区, 字节集, , 用于装载逻辑驱动器名称的字串。每个名字都用一个NULL字符分隔，在最后一个名字后面用两个NULL表示中止（空中止）;

.DLL命令 GetDiskFreeSpaceExA, 逻辑型, "kernel32.dll", "GetDiskFreeSpaceExA", 公开, 系统_取磁盘大小信息
    .参数 根路径名称, 文本型, , lpRootPathName
    .参数 剩余空间, 长整数型, 传址, lpFreeBytesAvailableToCaller
    .参数 总大小, 长整数型, 传址, lpTotalNumberOfBytes
    .参数 总剩余空间, 长整数型, 传址, lpTotalNumberOfFreeBytes

.DLL命令 mciSendCommandA, 整数型, "Winmm.dll", "mciSendCommandA", , _系统光驱开关3
    .参数 IDDevice, 整数型
    .参数 uMsg, 整数型
    .参数 fdwCommand, 整数型
    .参数 dwParam, 整数型

.DLL命令 _系统光驱开关2, 整数型, "Winmm.dll", "mciSendCommandA"
    .参数 IDDevice, 整数型
    .参数 uMsg, 整数型
    .参数 fdwCommand, 整数型
    .参数 dwParam, 光驱相关2

.DLL命令 _系统光驱开关1, 整数型, "Winmm.dll", "mciSendCommandA"
    .参数 IDDevice, 整数型
    .参数 uMsg, 整数型
    .参数 fdwCommand, 整数型
    .参数 dwParam, 光驱相关1

.DLL命令 GetDriveTypeA, 整数型, "kernel32.dll", "GetDriveTypeA", 公开, _系统光驱查询
    .参数 nDrive, 文本型

.DLL命令 _关机对话框_XP, 整数型, "shell32.dll", "#60", , XP系统类型
    .参数 参数, 整数型, , YourGuess

.DLL命令 _关机对话框_WIN, 整数型, "shell32.dll", "#60", , WIN7以上的系统类型
    .参数 参数1, 整数型, , YourGuess
    .参数 参数2, 整数型

.DLL命令 LockWorkStation, , "user32.dll", "LockWorkStation", 公开, 切换系统用户

.DLL命令 SetSuspendState, 整数型, "Powrprof.dll", "SetSuspendState", 公开, 系统进入待机状态
    .参数 冬眠, 整数型, , Hibernate
    .参数 强制, 整数型, , ForceCritical
    .参数 不激发事件, 整数型, , DisableWakeEvent

.DLL命令 ExitWindowsEx, 整数型, "user32.dll", "ExitWindowsEx", 公开, 关闭系统, 退出windows，并用特定的选项重新启动
    .参数 uFlags, 整数型, , 指定一个或多个标志的组合
    .参数 dwReason, 整数型, , 保留，设为零

.DLL命令 SHEmptyRecycleBinA, 整数型, "shell32.dll", "SHEmptyRecycleBinA", 公开, 系统_清空回收站, SHEmptyRecycleBin
    .参数 hwnd, 整数型
    .参数 pszRootPath, 整数型
    .参数 dwFlags, 整数型

.DLL命令 SHFormatDrive, 逻辑型, "shell32.dll", "SHFormatDrive", 公开, _格式化软盘
    .参数 hwnd, 整数型, , hwndOwner
    .参数 驱动器, 整数型, , iDrive
    .参数 容量, 整数型, , iCapacity
    .参数 格式化类型, 整数型, , iFormatType

.DLL命令 SystemParametersInfoA, 逻辑型, "user32.dll", "SystemParametersInfoA", 公开, _系统设置桌面壁纸
    .参数 uiAction, 整数型
    .参数 uiParam, 整数型
    .参数 pvParam, 整数型
    .参数 fWinlni, 短整数型

.DLL命令 GetUserNameA, 整数型, "advapi32.dll", "GetUserNameA", 公开, 取出当前的用户名,TRUE（非零）表示成功，否则返回零。
    .参数 字串缓冲区, 文本型, , lpBuffer，随同用户名载入的字串缓冲区
    .参数 缓冲区长度, 整数型, 传址, nSize，缓冲区的长度。这个变量随同返回用户名的实际长度载入

.DLL命令 GetUserNameW, 逻辑型, "advapi32.dll", "GetUserNameW"
    .参数 lpBuffer, 字节集
    .参数 pcbBuffer, 整数型, 传址

.DLL命令 waveOutGetVolume, 整数型, "winmm.dll", "waveOutGetVolume", 公开
    .参数 设备, 整数型
    .参数 音量值, 整数型, 传址

.DLL命令 waveOutSetVolume, 整数型, "winmm.dll", "waveOutSetVolume", 公开, _系统置音量
    .参数 设备, 整数型
    .参数 音量值, 整数型

.DLL命令 ChangeDisplaySettingsA, 整数型, "user32.dll", "ChangeDisplaySettingsA", 公开, _系统置分辨率2
    .参数 lpDevMode, 短整数型, 传址
    .参数 dwFlags, 整数型

.DLL命令 GetComputerNameA, 整数型, "kernel32.dll", "GetComputerNameA", 公开, _系统取计算机名 取出当前完整的计算机名称，TRUE（非零）表示成功，否则返回零。
    .参数 字串缓冲区, 文本型, , lpBuffer，随同计算机名载入的字串缓冲区
    .参数 缓冲区长度, 整数型, 传址, nSize，缓冲区的长度。这个变量随同返回计算机名的实际长度载入

.DLL命令 EnumDisplaySettingsA, 整数型, "user32.dll", "EnumDisplaySettingsA", 公开, _系统置分辨率1
    .参数 lpszDeviceName, 整数型
    .参数 iModeNum, 整数型
    .参数 lpDevMode, 短整数型, 传址

.DLL命令 SHAppBarMessage, 整数型, "shell32.dll", "SHAppBarMessage", 公开, _系统取任务栏高度
    .参数 dwMessage
    .参数 pData, 精易_任务相关

.DLL命令 GetDateFormatA, 整数型, "kernel32.dll", "GetDateFormatA", 公开, 针对指定的“当地”格式，对一个系统日期进行格式化  格式化过后的字串的长度。
    .参数 地方ID, 整数型, , Locale，用于决定格式的地方ID。lpFormat参数中指定的任何信息（倘若不是NULL）都优先于特定于地方的信息
    .参数 标志, 整数型, , dwFlags，如指定了lpFormat，那么该参数应该为零。否则，可设为LOCALE_NOUSEROVERRIDE，强制使用系统地方参数——即使它们已由用户取代。
    .参数 日期结构, 精易_时间, , lpDate，包含了一个系统日期的结构
    .参数 格式化, 文本型, , lpFormat，String，可设为NULL，使用特定于不同地方的值（用vbNullString传递一个NULL）。否则包含一个日期格式字串。
    .参数 缓冲区文本, 文本型, , lpDateStr，指定一个缓冲区，用于容纳格式化过后的字串。注意事先对字串进行初始化
    .参数 缓冲区文本长度, 整数型, , cchDate，缓冲区的长度。如为零，表示函数会返回需要缓冲区的大小;

.DLL命令 SystemTimeToVariantTime, 整数型, "oleaut32.dll", "SystemTimeToVariantTime", 公开, _系统时间变时间
    .参数 SystemTime, 精易_时间, 传址
    .参数 vtime, 日期时间型, 传址

.DLL命令 FileTimeToSystemTime, 整数型, "kernel32.dll", "FileTimeToSystemTime", , _系统结构的内容 根据一个FILETIME结构的内容，装会设置GetLastError
    .参数 文件时间结构, FILETIME, , FILETIME，包含了文件时间的一个结构
    .参数 系统时间结构, 精易_时间, , SYSTEMTIME，用于装载系统时间信息的一个结构;

.DLL命令 SystemTimeToFileTime, 整数型, "kernel32.dll", "SystemTimeToFileTime", ,  _系统到本地时间1
    .参数 SystemTime, 精易_时间
    .参数 FileTime, FILETIME

.DLL命令 FileTimeToLocalFileTime, 整数型, "kernel32.dll", "FileTimeToLocalFileTime", , _系统到本地时间 将一个FILETIME结构转换成本地时间  非零表示成功，零表示失败。会设置GetLastError
    .参数 文件时间, FILETIME, , FILETIME，包含了UTC时间信息的一个结构
    .参数 所在文件时间, FILETIME, , FILETIME，用于装载转换过后的本地时间的结构;

.DLL命令 GetTimeFormatA, 整数型, "kernel32.dll", "GetTimeFormatA", 公开, _系统置时间进行格式化 针对指定的“当地”格式，对一个系统时间进行格式化。
    .参数 地方ID, 整数型, , Locale，用于决定格式的地方ID。lpFormat参数中指定的任何信息（倘若不是NULL）都优先于特定于地方的信息
    .参数 标志, 整数型, , dwFlags，如指定了lpFormat，那么该参数应该为零。否则，可设为LOCALE_NOUSEROVERRIDE，强制使用系统地方参数
    .参数 时间结构, 精易_时间, , lpDate，SYSTEMTIME，用于包容系统时间的一个结构
    .参数 格式化, 文本型, , lpFormat，String，可设为NULL，使用特定于不同地方的值（用vbNullString传递一个NULL）。
    .参数 缓冲区文本, 文本型, , lpDateStr，指定一个缓冲区，用于容纳格式化过后的字串。注意事先对字串进行初始化
    .参数 缓冲区文本长度, 整数型, , cchDate，缓冲区的长度。如为零，表示函数会返回需要缓冲区的大小;

.DLL命令 GetInputState, 整数型, "user32.dll", "GetInputState", 公开, 用法,如果真(我的处理事件()≠0),处理事件()    比系统自带的"处理事件"比3倍以上

.DLL命令 EnumThreadWindows, 整数型, "user32.dll", "EnumThreadWindows", 公开, _窗口枚举任务 枚举与指定任务相关的窗口　非零表示成功，零表示失败
    .参数 线程标识符, 整数型, , 某线程的标识符，它的窗口将被枚举
    .参数 函数指针, 子程序指针, , 指向一个函数的指针，要求为每个子窗口都调用这个函数。用AddressOf运算符获得函数在标准模式下的地址
    .参数 自定义数值, 整数型, , 在枚举期间，传递给dwcbkd32d.ocx定制控件之EnumWindows事件的值。这个值的含义是由程序员规定的
  

.DLL命令 CreateRoundRectRgn, 整数型, "gdi32.dll", "CreateRoundRectRgn", 公开, 创建一个圆角矩形，该矩形由X1，Y1-X2，Y2确定，并由X3，Y3确定的椭圆描述圆角弧度，不用时一定要用DeleteObject函数删除该区域用该函数创建的区域与用RoundRect API函数画的圆角矩形不完全相同，因为本矩形的右边和下边不包括在区域之内
    .参数 左上横坐标, 整数型, , X1，矩形左上角横坐标
    .参数 左上纵坐标, 整数型, , Y1，矩形左上角纵坐标
    .参数 右下横坐标, 整数型, , X2，矩形右下角横坐标
    .参数 右下纵坐标, 整数型, , Y2，矩形右下角纵坐标
    .参数 圆角椭圆的宽, 整数型, , X3，圆角椭圆的宽，其范围从0（没有圆角）到矩形宽（全圆）
    .参数 圆角椭圆的高, 整数型, , Y3，圆角椭圆的高，其范围从0（没有圆角）到矩形高（全圆）

.DLL命令 ClientToScreen, 整数型, "user32.dll", "ClientToScreen", 公开, _窗口取区域位置 非零表示成功，零表示失败
    .参数 hwnd, 整数型, , hwnd，要取出区域坐标的窗口句柄
    .参数 位置变量, 精易_坐标, , lpPoint，参见相关帮助

.DLL命令 SetFocus, 逻辑型, "user32.dll", "SetFocus", 公开, 窗口_置后台焦点 将输入焦点设到指定的窗口。如有必要，会激活窗口  (返回前一个拥有焦点的窗口的句柄)
    .参数 hwnd, 整数型, , 准备接收焦点的窗口的句柄

.DLL命令 SetForegroundWindow, 逻辑型, "user32.dll", "SetForegroundWindow", 公开, 窗口_置焦点 将窗口设为系统的前台窗口。这个函数可用于改变用户目前正在操作的应用程序
    .参数 句柄, 整数型

.DLL命令 ShowCursor, , "user32.dll", "ShowCursor", 公开, 鼠标_显示隐藏   控制鼠标指针的可视性(返回值:显示计数（参考注解）)
    .参数 bShow, 逻辑型, , （非零）显示指针，零 隐藏

.DLL命令 ClipCursor, , "user32.dll", "ClipCursor", 公开, 鼠标限制
    .参数 区域, 精易_矩形

.DLL命令 LoadCursor, 整数型, "user32.dll", "LoadCursorA", 公开, 从指定的模块或应用程序实例中载入一个鼠标指针。LoadCursorBynum是LoadCursor函数的类型安全声明　执行成功则返回已载入的指针的句柄；零表示失败。在Windows ;    95 和Win16环境中，这个函数只能载入标准尺寸的图标
    .参数 实例句柄, 整数型, , 一个DLL的模块句柄；或者一个实例句柄，指定包含了鼠标指针的可执行程序
    .参数 鼠标指针标识, 整数型, , 作为一个字串，指定欲载入的指针资源。作为一个长整数值，指定欲载入的资源ID；或者设置一个常数，代表某幅固有系统指针。如装载的是一个固有系统指针，注意hInstance参数应设为零。在api32.txt文件中以前缀IDC_ 作为标志;  

.DLL命令 SetCursor, 整数型, "user32.dll", "SetCursor", 公开, 将指定的鼠标指针设为当前指针　前一个指针的值
    .参数 指针句柄, 整数型, , 要设为当前指针的一个指针的句柄。如设为零，表示不显示任何指针;  

.DLL命令 GetDoubleClickTime, 整数型, "user32.dll", "GetDoubleClickTime", 公开, 鼠标_取双击间隔时间

.DLL命令 SetCursorPos, , "user32.dll", "SetCursorPos", 公开, 鼠标_置位置 
    .参数 横坐标, 整数型
    .参数 纵坐标, 整数型

.DLL命令 SetClassLongA, 整数型, "user32.dll", "SetClassLongA", 公开
    .参数 hwnd, 整数型
    .参数 nIndex, 整数型
    .参数 dwNewLong, 整数型, , 类信息的新值

.DLL命令 LoadCursorFromFileA, 整数型, "user32.dll", "LoadCursorFromFileA", 公开, 创建一个鼠标指针
    .参数 lpFileName, 文本型, , 包含指针的那个文件的名字

.DLL命令 SetCapture, 整数型, "user32.dll", "SetCapture", 公开, 鼠标捕获
    .参数 hwnd

.DLL命令 ReleaseCapture, 逻辑型, "user32.dll", "ReleaseCapture", 公开, 鼠标释放

.DLL命令 mouse_event, , "user32.dll", "mouse_event", 公开, 鼠标模拟
    .参数 标志组合, 整数型, , 2鼠标左键按住不放；6鼠标左键单击；24鼠标右键单击；
    .参数 水平方向, 整数型, , dx，参见相关帮助
    .参数 垂直方向, 整数型, , dy，参见相关帮助
    .参数 数据信息, 整数型, , cButtons，未使用
    .参数 扩展数据信息, 整数型, , dwExtraInfo，通常未用的一个值

.DLL命令 GetCursorPos, 整数型, "user32.dll", "GetCursorPos", , 鼠标_取鼠标位置
    .参数 位置, 精易_坐标, 传址

.DLL命令 GetClipboardOwner, 整数型, "user32.dll", "GetClipboardOwner", 公开, _剪辑板取数据权窗口句柄 返回复制该数据的窗口句柄；如：一段文字是在记事本复制的，则返回记事本的窗口句柄

.DLL命令 GetClipboardData, 整数型, "user32.dll", "GetClipboardData", 公开, 剪辑板取数据句柄
    .参数 wFormat, 整数型

.DLL命令 CloseClipboard, 整数型, "user32.dll", "CloseClipboard", 公开, 剪辑板关闭

.DLL命令 SetClipboardData, 整数型, "user32.dll", "SetClipboardData", 公开, 剪辑板置数据
    .参数 uFormat, 整数型
    .参数 hMem, 整数型

.DLL命令 GetDIBits3, 整数型, "gdi32.dll", "GetDIBits", 公开, gdi32.dll将来自一幅位图的二进制位复制到一幅与设备无关的位图里  非零表示成功，零表示失败。在Windows 95中，返回值是返回的扫描线数量
    .参数 设备场景句柄, 整数型, , aHDC，定义了与设备有关位图hBitmap的配置信息的一个设备场景的句柄
    .参数 源位图句柄, 整数型, , hBitmap，源位图的句柄。绝对不能将这幅位图选入设备场景
    .参数 扫描线初始编号, 整数型, , nStartScan，欲复制到DIB中的第一条扫描线的编号
    .参数 扫描线数量, 整数型, , nNumScans，欲复制的扫描线数量
    .参数 缓冲区指针, 字节型, 传址, lpBits，指向一个缓冲区的指针。这个缓冲区将用于装载采用DIB格式的信息，但不取回数据（用ByVal传递零值）
    .参数 位图结构, 位图信息_, , lpBI，BITMAPINFO，对lpBits DIB的格式及颜色进行说明的一个结构。在BITMAPINFOHEADER结构中，从biSize到biCompression之间的所有字段都必须初始化
    .参数 常量标志, 整数型, , wUsage，下述常数之一：;DIB_PAL_COLORS：在颜色表中装载一个16位所以数组，它们与当前选定的调色板有关;DIB_RGB_COLORS：在颜色表中装载RGB颜色;

.DLL命令 SetPixelV, 整数型, "gdi32.dll", "SetPixelV", 公开, 置场景颜色_在指定的设备场景中设置一个像素的RGB值
    .参数 hdc, 整数型
    .参数 x, 整数型
    .参数 y, 整数型
    .参数 crColor, 整数型, , 指定像素的新RGB颜色值

.DLL命令 DrawIconEx, 整数型, "user32.dll", "DrawIconEx", 公开, 描绘一个图标或鼠标指针
    .参数 hdc
    .参数 xLeft
    .参数 yTop
    .参数 hIcon
    .参数 cxWidth
    .参数 cyWidth
    .参数 istepIfAniCur
    .参数 hbrFlickerFreeDraw
    .参数 diFlags

.DLL命令 EmptyClipboard, 逻辑型, "user32.dll", "EmptyClipboard", 公开, 剪辑板清空

.DLL命令 取对象属性_, 整数型, "gdi32.dll", "GetObjectA"
    .参数 对象句柄, 整数型
    .参数 数据尺寸, 整数型
    .参数 属性, 位图结构_

.DLL命令 GetObjectA, 整数型, "gdi32.dll", "GetObjectA", 公开, _取对象属性
    .参数 hgdiobj, 整数型
    .参数 cbBuffer, 整数型
    .参数 lpvObject, BITMAP

.DLL命令 GlobalLock, 整数型, "kernel32.dll", "GlobalLock", 公开, 锁定内存对象并返回一个指针
    .参数 hMem, 整数型

.DLL命令 GlobalUnlock, 整数型, "kernel32.dll", "GlobalUnlock", 公开, 开锁全局内存块
    .参数 hMem, 整数型

.DLL命令 GlobalAlloc, 整数型, "kernel32.dll", "GlobalAlloc", 公开, 在堆中分配内存
    .参数 wFlags, 整数型
    .参数 dwBytes, 整数型

.DLL命令 IsClipboardFormatAvailable, 整数型, "user32.dll", "IsClipboardFormatAvailable", 公开, _剪贴板格式是可用
    .参数 wFormat, 整数型

.DLL命令 RegisterClipboardFormatA, 整数型, "user32.dll", "RegisterClipboardFormatA", 公开, _剪辑板注册格式
    .参数 lpString, 文本型

.DLL命令 RtlMoveMemory_字节型_数组, , "kernel32.dll", "RtlMoveMemory", 公开, 复制内存数据_MIB_IPFORWARDROW参数
    .参数 Destination, 字节型, 数组, 目标地址
    .参数 Source, 字节型, 数组, 要复制的数据MIB_IPFORWARDROW
    .参数 Length, 整数型, , 长度

.DLL命令 RtlMoveMemory_字节型, , "kernel32.dll", "RtlMoveMemory", 公开, 复制内存数据_MIB_IPFORWARDROW参数
    .参数 Destination, 字节型, 传址, 目标地址
    .参数 Source, 字节型, 传址, 要复制的数据MIB_IPFORWARDROW
    .参数 Length, 整数型, , 长度

.DLL命令 RtlMoveMemory_文本型, , "kernel32.dll", "RtlMoveMemory", 公开, 内存拷贝
    .参数 Destination, 整数型
    .参数 Source, 文本型
    .参数 Length, 整数型

.DLL命令 RtlMoveMemory_剪贴板_置文件, , "kernel32.dll", "RtlMoveMemory", 公开, _剪贴板置文件
    .参数 pDest, 整数型
    .参数 pSrc, 剪贴板_置文件, 传址
    .参数 ByteLen, 整数型

.DLL命令 DragQueryFileA, 整数型, "shell32.dll", "DragQueryFileA", 公开, _拖动查询文件
    .参数 hDrop, 整数型
    .参数 iFile, 整数型
    .参数 lpszFile, 整数型
    .参数 cch, 整数型

.DLL命令 DragQueryFileW, 整数型, "Shell32.dll", "DragQueryFileW"
    .参数 hDrop, 整数型
    .参数 iFile, 整数型
    .参数 lpszFile, 整数型
    .参数 cch, 整数型

.DLL命令 OpenClipboard, 整数型, "user32.dll", "OpenClipboard", 公开, 打开剪辑板
    .参数 句柄, 整数型

.DLL命令 keybd_event, 整数型, "user32.dll", "keybd_event", 公开, 键盘模拟
    .参数 键代码, 整数型, , bVk,欲模拟的虚拟键码
    .参数 键扫描码, 整数型, , bScan,键的OEM扫描码
    .参数 标志值, 整数型, , dwFlags,标志常数
    .参数 特定值, 整数型, , dwExtraInfo,通常不用的一个值

.DLL命令 SetLayeredWindowAttributes, 逻辑型, "user32.dll", "SetLayeredWindowAttributes", 公开, 窗口_置透明
    .参数 hwnd, 整数型, , 透明窗体的句柄
    .参数 crKey, 整数型, , 颜色值
    .参数 bAlpha, 字节型, , 透明度，取值范围是[0,255]
    .参数 dwFlags, 整数型, , 透明方式：LWA_ALPHA(2)时，crKey参数无效，bAlpha参数有效 || LWA_COLORKEY(1)时，bAlpha参数有效而窗体中的所有颜色为crKey的地方将变为透明

.DLL命令 SetWindowTextA, 逻辑型, "user32.dll", "SetWindowTextA", 公开, 窗口_置标题
    .参数 hwnd, 整数型
    .参数 窗口标题, 文本型

.DLL命令 SetWindowTextW, 逻辑型, "user32.dll", "SetWindowTextW", 公开, 改变指定窗口的标题栏的文本内容（如果窗口有标题栏）。如果指定窗口是一个控件，则改变控件的文本内容。然而，SetWindowText函数不改变其他应用程序中的控件的文本内容。
    .参数 hWnd, 整数型, , 要改变文本内容的窗口或控件的句柄。
    .参数 lpString, 字节集, , 指向一个空结束的字符串的指针，该字符串将作为窗口或控件的新文本。(注意：易语言BUG，不能直接用字节集常量)

.DLL命令 WindowFromPoint, 整数型, "user32.dll", "WindowFromPoint", 公开, 窗口_取鼠标处窗口句柄 返回包含了指定点的窗口的句柄。忽略屏蔽、隐藏以及透明窗口  包含了指定点的窗口的句柄。如指定的点处没有窗口存在，则返回零
    .参数 横坐标, 整数型
    .参数 纵坐标, 整数型

.DLL命令 ShowScrollBar, 逻辑型, "user32.dll", "ShowScrollBar", 公开, 滚动条_显示隐藏 窗口_控件显示隐藏, ShowScrollBar
    .参数 hwnd, 整数型, , hwnd
    .参数 滚动条标志, 整数型, , wBar
    .参数 显示标志, 逻辑型, , bShow

.DLL命令 SetTimer, 整数型, "user32.dll", "SetTimer", 公开, 用指定的超时值创建或替换一个定时器。如果函数成功并且hWnd参数为NULL，则返回值为标识新定时器的整数，应用程序可以将此值传递给KillTimer函数以销毁定时器。如果函数成功并且hWnd参数不为NULL，则返回值为非零整数，应用程序可以将nIDEvent参数的值传递给KillTimer函数以销毁定时器。如果函数无法创建定时器，则返回值为零。要获取扩展的错误信息，请调用GetLastError。
    .参数 hWnd, 整数型, , 与定时器关联的窗口句柄。如果将为 NULL 的 hWnd 与现有定时器的 nIDEvent 一起传递，该定时器将被替换的方式与现有的非 NULL 的 hWnd 定时器相同。
    .参数 nIDEvent, 整数型, , 非零的定时器ID。如果 hWnd 参数为 NULL，并且 nIDEvent 与现有定时器不匹配，则会忽略该参数并生成新的定时器ID。如果 hWnd 参数非 NULL，并且 hWnd 指定的窗口已具有具有值为 nIDEvent 的定时器，则现有定时器将被新定时器替换。当 SetTimer 替换定时器时，定时器将重置。因此，将在当前超时值过去之后发送一条消息，但先前设置的超时值将被忽略。如果该调用不是要替换现有的定时器，则如果 hWnd 为 NULL，则 nIDEvent 应为 0。
    .参数 uElapse, 整数型, , 超时值，以毫秒为单位。如果 uElapse 小于 USER_TIMER_MINIMUM（10），则将超时设置为 USER_TIMER_MINIMUM。如果 uElapse 大于 USER_TIMER_MAXIMUM（2147483647），则将超时设置为 USER_TIMER_MAXIMUM。
    .参数 lpTimerFunc, 整数型, , 当超时值过去时，指向要通知的函数指针。有关该函数的更多信息，请参见 TimerProc 。如果 lpTimerFunc 为 NULL，则系统将 WM_TIMER 消息发送到应用程序消息队列的 MSG 结构的 hwnd 成员包含 hWnd 参数的值。

.DLL命令 KillTimer, 逻辑型, "user32.dll", "KillTimer", 公开, 销毁指定的定时器。
    .参数 hWnd, 整数型, , 与指定定时器关联的窗口的句柄。此值必须与传递给创建定时器的SetTimer函数的hWnd值相同。
    .参数 uIDEvent, 整数型, , 要销毁的定时器。如果传递给SetTimer的窗口句柄有效，则此参数必须与传递给SetTimer的nIDEvent相同。如果应用程序调用SetTimer的hWnd设为NULL，这个参数必须由SetTimer返回的定时器ID。

.DLL命令 _设备操作0, 整数型, "kernel32.dll", "DeviceIoControl", , 对设备执行指定的操作  非零表示成功，零表示失败。会设置GetLastError
    .参数 hDevice, 整数型, , 设备句柄
    .参数 dwIoControlCode, 整数型, , 带有 FSCTL_ 前缀的常数。参考设备控制选项的部分列表
    .参数 lpInBuffer, 整数型, , 具体取决于dwIoControlCode参数。参考设备控制选项的部分列表
    .参数 nInBufferSize, 整数型, , 输入缓冲区的长度
    .参数 lpOutBuffer, 取硬盘特征号1, 传址, 具体取决于dwIoControlCode参数。参考设备控制选项的部分列表
    .参数 nOutBufferSize, 整数型, , 输出缓冲区的长度
    .参数 lpBytesReturned, 整数型, 传址, 实际装载到输出缓冲区的字节数量
    .参数 lpOverlapped, 整数型, , OVERLAPPED，这个结构用于重叠操作。针对同步操作，请用ByVal As Long传递零值;

.DLL命令 DeviceIoControl, 整数型, "kernel32.dll", "DeviceIoControl", , 对设备执行指定的操作  非零表示成功，零表示失败。会设置GetLastError
    .参数 hDevice, 整数型, , 设备句柄
    .参数 dwIoControlCode, 整数型, , 带有 FSCTL_ 前缀的常数。参考设备控制选项的部分列表
    .参数 lpInBuffer, 取硬盘特征号0, 传址, 具体取决于dwIoControlCode参数。参考设备控制选项的部分列表
    .参数 nInBufferSize, 整数型, , 输入缓冲区的长度
    .参数 lpOutBuffer, 字节集, 传址, 具体取决于dwIoControlCode参数。参考设备控制选项的部分列表
    .参数 nOutBufferSize, 整数型, , 输出缓冲区的长度
    .参数 lpBytesReturned, 整数型, 传址, 实际装载到输出缓冲区的字节数量
    .参数 lpOverlapped, 整数型, , OVERLAPPED，这个结构用于重叠操作。针对同步操作，请用ByVal As Long传递零值;

.DLL命令 _设备操作2, 整数型, "Kernel32.dll", "DeviceIoControl"
    .参数 hDevice, 整数型
    .参数 dwIoControlCode, 整数型
    .参数 lpInBuffer, 取硬盘特征号2, 传址
    .参数 nInBufferSize, 整数型
    .参数 lpOutBuffer, 字节集, 传址
    .参数 nOutBufferSize, 整数型
    .参数 lpBytesReturned, 整数型, 传址
    .参数 lpOverlapped, 整数型, , OVERLAPPED

.DLL命令 GetWindowDC, 整数型, "user32.dll", "GetWindowDC", 公开, 获取整个窗口（包括边框、滚动条、标题栏、菜单等）的设备场景  执行成功为窗口设备场景，失败则为0
    .参数 hwnd, 整数型, , 将获取其设备场景的窗口;

.DLL命令 CreatePen, 整数型, "gdi32.dll", "CreatePen", 公开, 用指定的样式、宽度和颜色创建一个画笔  如函数执行成功，就返回指向新画笔的一个句柄；否则返回零
    .参数 风格, 整数型, , 指定画笔样式，可以是下述常数之一;PS_SOLID：画笔画出的是实线;PS_DASH：画笔画出的是虚线（nWidth必须是1）;PS_DOT：画笔画出的是点线（nWidth必须是1）;PS_DASHDOT：画笔画出的是点划线（nWidth必须是1）;PS_DASHDOTDOT：画笔画出的是点-点-划线（nWidth必须是1）;PS_NULL：画笔不能画图;PS_INSIDEFRAME：画笔在由椭圆、矩形、圆角矩形、饼图以及弦等生成的封闭对象框中画图。如指定的准确RGB颜色不存在，就进行抖动处理
    .参数 宽度, 整数型, , 以逻辑单位表示的画笔的宽度
    .参数 颜色, 整数型, , 画笔的RGB颜色;

.DLL命令 GetStockObject, 整数型, "gdi32.dll", "GetStockObject", 公开, 取得一个固有对象的句柄（Stock）。这是可由任何应用程序使用的windows标准对象之一  指向指定对象的一个句柄。零表示出错
    .参数 类型, 整数型, , 下述表格中定义的任何常数之一BLACK_BRUSH黑色刷子DKGRAY_BRUSH黑灰色刷子GRAY_BRUSH灰色刷子HOLLOW_BRUSH凹刷子LTGRAY_BRUSH浅灰色刷子NULL_BRUSH空刷子WHITE_BRUSH白色刷子BLACK_PEN黑色画笔NULL_PEN空画笔WHITE_PEN白色画笔ANSI_FIXED_FONT采用windows（ANSI）字符集的等宽字体ANSI_VAR_FONT采用windows（ANSI）字符集的不等宽字体DEVICE_DEFAULT_FONT设备使用的默认字体（NT）DEFAULT_GUI_FONT用户界面的默认字体，包括菜单和对话框字体（Windows 95）OEM_FIXED_FONTOEM字符集的固有字体SYSTEM_FONT屏幕系统字体。这是用于菜单、对话框等等的默认不等宽字体SYSTEM_FIXED_FONT屏幕系统字体。这是用于菜单、对话框等等的默认等宽字体（在windows 3.0之前使用）DEFAULT_PALETTE默认调色板;

.DLL命令 SetROP2, 整数型, "gdi32.dll", "SetROP2", 公开, 设置指定设备场景的绘图模式。与vb的DrawMode属性完全一致　如执行成功，返回前一个绘图模式；零表示出错
    .参数 设备场景, 整数型
    .参数 光栅运算方式, 整数型

.DLL命令 Rectangle, 整数型, "gdi32.dll", "Rectangle", 公开, 画矩形 用当前选定的画笔描绘矩形，并用当前选定的刷子进行填充  非零表示成功，零表示失败。会设置GetLastError
    .参数 设备场景句柄, 整数型, , 设备场景的句柄
    .参数 左上角横坐标, 整数型, , 指定矩形左上角位置
    .参数 左上角纵坐标, 整数型, , 同上
    .参数 右下角横坐标, 整数型, , 指定矩形右下角位置
    .参数 右下角纵坐标, 整数型, , 同上;

.DLL命令 GetCurrentThread, 整数型, "kernel32.dll", "GetCurrentThread", 公开, 取当前线程句柄

.DLL命令 GetCurrentThreadId, 整数型, "kernel32.dll", "GetCurrentThreadId", 公开, 取当前线程ID

.DLL命令 取数据地址, 整数型, "kernel32.dll", "lstrcpyn"
    .参数 目标, TCITEM, 传址
    .参数 源, TCITEM, 传址
    .参数 长度, 整数型

.DLL命令 _取变量地址_TVITEMEX2, 整数型, "kernel32.dll", "lstrcpyn"
    .参数 目标, TVITEMEX2, 传址
    .参数 源, TVITEMEX2, 传址
    .参数 长度, 整数型

.DLL命令 _取变量地址_TVINSERTSTRUCT2, 整数型, "kernel32.dll", "lstrcpyn"
    .参数 目标, TVINSERTSTRUCT2, 传址
    .参数 源, TVINSERTSTRUCT2, 传址
    .参数 长度, 整数型

.DLL命令 CreateFontIndirectA, 整数型, "gdi32.dll", "CreateFontIndirectA", 公开, gdi32.dll用指定的属性创建一种逻辑字体　执行成功则返回逻辑字体句柄，零表示失败
    .参数 字体结构信息, LOGFONT, , LOGFONT，这个结构定义了逻辑字体请求的属性;  

.DLL命令 OpenThread, 整数型, "kernel32.dll", "OpenThread", 公开, 打开线程
    .参数 dwDesiredAccess, 整数型, , 2032639
    .参数 bInheritHandle, 整数型, , 0
    .参数 线程ID, 整数型, , 线程ID

.DLL命令 CreateDCA, 整数型, "gdi32.dll", "CreateDCA", 公开, _创建场景
    .参数 lpDriverName, 文本型
    .参数 lpDeviceName, 文本型
    .参数 lpOutput, 文本型
    .参数 lpInitData, 整数型

.DLL命令 lpRect, 整数型, "user32.dll", "IsRectEmpty", 公开, _矩形是否为空
    .参数 lpRect, 精易_矩形

.DLL命令 PatBlt, , "gdi32.dll", "PatBlt", 公开, _填充设备场景
    .参数 hdc, 整数型
    .参数 x, 整数型
    .参数 y, 整数型
    .参数 nWidth, 整数型
    .参数 nHeight, 整数型
    .参数 dwRop, 整数型

.DLL命令 GetDlgCtrlID, 整数型, "user32.dll", "GetDlgCtrlID", 公开
    .参数 hwnd, 整数型

.DLL命令 GetDlgItem, 整数型, "user32.dll", "GetDlgItem", 公开, 控件ID取窗口句柄
    .参数 父句柄, 整数型
    .参数 欲取句柄的控件ID, 整数型

.DLL命令 CoInitialize, 整数型, "ole32.dll", "CoInitialize", 公开, 加载COM
    .参数 pvReserved, 整数型, , 值为0

.DLL命令 CoUninitialize, , "ole32.dll", "CoUninitialize", 公开, 卸载COM

.DLL命令 WinExec, 整数型, "kernel32.dll", "WinExec", 公开, _服务
    .参数 lpCmdLine, 文本型
    .参数 nCmdShow, 整数型

.DLL命令 OpenSCManagerA, 整数型, "advapi32.dll", "OpenSCManagerA", 公开
    .参数 lpMachineName, 整数型
    .参数 lpDatabaseName, 整数型
    .参数 dwDesiredAccess, 整数型

.DLL命令 OpenService, 整数型, "Advapi32.dll", "OpenServiceA", 公开
    .参数 hSCManager, 整数型
    .参数 lpServiceName, 文本型
    .参数 dwDesiredAccess, 整数型

.DLL命令 ControlService, 逻辑型, "advapi32.dll", "ControlService", 公开
    .参数 hService, 整数型
    .参数 dwControl, 整数型
    .参数 lpServiceStatus, SERVICE_STATUS

.DLL命令 DeleteService, 逻辑型, "advapi32.dll", "DeleteService", 公开, ,
    .参数 hService, 整数型

.DLL命令 CloseServiceHandle, 整数型, "advapi32.dll", "CloseServiceHandle", 公开, ,
    .参数 hSCObject, 整数型

.DLL命令 StartService, 逻辑型, "advapi32.dll", "StartServiceA", 公开
    .参数 hService, 整数型
    .参数 dwNumServiceArgs, 整数型
    .参数 lpServiceArgVectors, 整数型

.DLL命令 QueryServiceStatus, 逻辑型, "advapi32.dll", "QueryServiceStatus", 公开, 4：启动　7：暂停　1：停止　0：找不到服务
    .参数 hService, 整数型
    .参数 lpServiceStatus, SERVICE_STATUS

.DLL命令 QueryServiceStatusEx, 整数型, "ADVAPI32.DLL", "QueryServiceStatusEx", 公开
    .参数 hService, 整数型
    .参数 InfoLevel, 整数型
    .参数 lpBuffer, 字节集
    .参数 cbBufSize, 整数型
    .参数 pcbBytesNeeded, 整数型, 传址

.DLL命令 ChangeServiceConfig, 逻辑型, "advapi32.dll", "ChangeServiceConfigA", 公开, 更改服务配置
    .参数 hService, 整数型
    .参数 dwServiceType, 整数型
    .参数 dwStartType, 整数型
    .参数 dwErrorControl, 整数型, , 误差控制
    .参数 lpBinaryPathName, 文本型, , 加载顺序组名称
    .参数 lpLoadOrderGroup, 文本型
    .参数 lpdwTagId, 整数型, , 标签标识
    .参数 lpDependencies, 文本型, , 依赖名称阵列
    .参数 lpServiceStartName, 文本型, , 帐户名称
    .参数 lpPassword, 文本型, , 帐户密码
    .参数 lpDisplayName, 文本型, , 显示名称

.DLL命令 CreateService, 整数型, "advapi32.dll", "CreateServiceA", 公开, 服务类
    .参数 hSCManager, 整数型
    .参数 lpServiceName, 文本型
    .参数 lpDisplayName, 文本型
    .参数 dwDesiredAccess, 整数型
    .参数 dwServiceType, 整数型
    .参数 dwStartType, 整数型
    .参数 dwErrorControl, 整数型
    .参数 lpBinaryPathName, 文本型
    .参数 lpLoadOrderGroup, 文本型
    .参数 lpdwTagId, 整数型
    .参数 lpDependencies, 文本型
    .参数 lpServiceStartName, 文本型
    .参数 lpPassword, 文本型

.DLL命令 QueryServiceConfig2, 逻辑型, "Advapi32.dll", "QueryServiceConfig2A", 公开
    .参数 hService, 整数型, , SC_HANDLE
    .参数 dwInfoLevel, 整数型
    .参数 lpBuffer
    .参数 cbBufSize, 整数型
    .参数 pcbBytesNeeded, 整数型, 传址

.DLL命令 UnlockServiceDatabase, 整数型, "advapi32.dll", "UnlockServiceDatabase", 公开, 开锁数据库
    .参数 ScLock, 整数型

.DLL命令 QueryServiceConfig2A_字节, 逻辑型, "Advapi32.dll", "QueryServiceConfig2A", 公开
    .参数 hService, 整数型, , SC_HANDLE
    .参数 dwInfoLevel, 整数型
    .参数 lpBuffer, 字节集, 传址
    .参数 cbBufSize, 整数型
    .参数 pcbBytesNeeded, 整数型, 传址

.DLL命令 ZwQuerySystemInformation, 整数型, "ntdll.dll", "ZwQuerySystemInformation", 公开, _进程隐藏 ntdll.dll
    .参数 SystemInformationClass, 整数型, , 未知类型：SYSTEM_INFORMATION_CLASS。
    .参数 SystemInformation, 整数型, , any
    .参数 SystemInformationLength, 整数型
    .参数 ReturnLength, 整数型, 传址

.DLL命令 CreateRemoteThread, 整数型, "kernel32.dll", "CreateRemoteThread", 公开, 在另一进程中建立线索　
    .参数 hProcess, 整数型
    .参数 lpThreadAttributes, 整数型
    .参数 dwStackSize, 整数型
    .参数 lpStartAddress, 整数型
    .参数 lpParameter, 整数型
    .参数 dwCreationFlags, 整数型
    .参数 lpThreadId, 整数型

.DLL命令 GetExitCodeThread, 整数型, "kernel32.dll", "GetExitCodeThread", 公开, _取中止线程退出代码
    .参数 线程句柄, 整数型
    .参数 退出代码, 整数型, 传址

.DLL命令 InternetGetConnectedStateExA, 逻辑型, "wininet.dll", "InternetGetConnectedStateExA", 公开, _取网络连接状态
    .参数 标志, 整数型, 传址, lpdwFlags
    .参数 连接名称, 文本型, , lpszConnectionName
    .参数 名称长度, 整数型, , dwNameLen
    .参数 保留参数, 整数型, , dwReserved

.DLL命令 原子递增变量, 整数型, "kernel32.dll", "InterlockedIncrement", 公开, _递增变量值
    .参数 递增变量, 整数型, 传址

.DLL命令 原子递减变量, 整数型, "kernel32.dll", "InterlockedDecrement", 公开, _递减变量值
    .参数 递减的一个变量, 整数型, 传址

.DLL命令 DragFinish, 整数型, "shell32.dll", "DragFinish", 公开, 释放文件拖放 释放分配用于托动文件的内容
    .参数 hDrop, 整数型

.DLL命令 DragAcceptFiles, , "shell32.dll", "DragAcceptFiles", 公开, 注册拖放类 登记窗口是否接受托动文件的内容
    .参数 hWnd, 整数型, , 对象句柄
    .参数 fAccept, 整数型, , 是否打开

.DLL命令 RegCloseKey, 整数型, "advapi32.dll", "RegCloseKey", 公开, _注册表_关闭项 advapi32.dll关闭系统注册表中的一个项（或键）  零（ERROR_SUCCESS）表示成功。其他任何值都代表一个错误代码
    .参数 hKey, 整数型, , 要关闭的项;

.DLL命令 RegCreateKeyA, 整数型, "advapi32.dll", "RegCreateKeyA", 公开, _注册表_创建项 advapi32.dll在指定的项下创建一个新项。如指定的项已经存在，那么函数会打开现有的项  零（ERROR_SUCCESS）表示成功。其他任何值都代表一个错误代码
    .参数 hKey, 整数型, , 要打开项的句柄，或者一个标准项名
    .参数 lpSubKey, 文本型, , 欲创建的新子项。可同时创建多个项，只需用反斜杠将它们分隔开即可。例如level1\level2\newkey
    .参数 phkResult, 整数型, 传址, 指定一个变量，用于装载新子项的句柄;

.DLL命令 RegDeleteValueA, 整数型, "advapi32.dll", "RegDeleteValueA", , _注册表_删除值删除指定项下方的一个值  零（ERROR_SUCCESS）表示成功。其他任何值都代表一个错误代码
    .参数 hKey, 整数型, , 一个已打开项的句柄，或标准项名之一
    .参数 lpValueName, 文本型, , 要删除的值名。可设为vbNull或一个空串，表示删除那个项的默认值;

.DLL命令 RegFlushKey, 整数型, "advapi32.dll", "RegFlushKey", , _注册表_实际写入将对项和它的子项作出的改动实际写入磁盘 Long，零（ERROR_SUCCESS）表示成功。其他任何值都代表一个错误代码
    .参数 hKey, 整数型, , Long，欲刷新的一个项的句柄，或指定一个标准项名

.DLL命令 RegQueryValueExA, 整数型, "advapi32.dll", "RegQueryValueExA", 公开, _注册表_取值获取一个项的设置值  零（ERROR_SUCCESS）表示成功。其他任何值都代表一个错误代码
    .参数 hKey, 整数型, , 一个已打开项的句柄，或者指定一个标准项名
    .参数 lpValueName, 文本型, , 要获取值的名字
    .参数 lpReserved, 整数型, , 未用，设为零
    .参数 lpType, 整数型, 传址, 用于装载取回数据类型的一个变量
    .参数 lpData, 字节集, 传址, 用于装载指定值的一个缓冲区
    .参数 lpcbData, 整数型, 传址, 用于装载lpData缓冲区长度的一个变量。一旦返回，它会设为实际装载到缓冲区的字节数;

.DLL命令 RegOpenCurrentUser, 整数型, "advapi32.dll", "RegOpenCurrentUser", 公开
    .参数 samDesired, 整数型
    .参数 phkResult, 整数型, 传址

.DLL命令 RegEnumValueA, 整数型, "advapi32.dll", "RegEnumValueA", 公开, _注册表_枚举值 零（ERROR_SUCCESS）表示成功。其他任何值都代表一个错误代码
    .参数 句柄, 整数型, , 一个已打开项的句柄，或者指定一个标准项名
    .参数 表项索引, 整数型, , 欲获取值的索引。注意第一个值的索引编号为零
    .参数 子键名, 文本型, , 用于装载位于指定索引处值名的一个缓冲区
    .参数 子键长度, 整数型, 传址, 用于装载lpValueName缓冲区长度的一个变量。一旦返回，它会设为实际载入缓冲区的字符数量
    .参数 lpReserved, 整数型, , 未用设为零
    .参数 键值类型, 整数型, 传址, 值的类型，用于装载值的类型代码的变量
    .参数 键值数据, 字节集, 传址, 用于装载值数据的一个缓冲区
    .参数 键值缓寸, 整数型, 传址, 用于装载lpData缓冲区长度的一个变量。一旦返回，它会设为实际载入缓冲区的字符数量

.DLL命令 API_RegEnumKey, 整数型, "advapi32.dll", "RegEnumKeyA", , 枚举指定项的子项。在Win32环境中应使用RegEnumKeyEx  零（ERROR_SUCCESS）表示成功。其他任何值都代表一个错误代码
    .参数 hKey, 整数型, , 一个已打开项的句柄，或者指定一个标准项名
    .参数 dwIndex, 整数型, , 欲获取的子项的索引。第一个子项的索引编号为零
    .参数 lpName, 文本型, , 用于装载指定索引处项名的一个缓冲区
    .参数 cbName, 整数型, , lpName缓冲区的长度;

.DLL命令 RegEnumKeyA, 整数型, "advapi32.dll", "RegEnumKeyA", 公开, _注册表_枚举子项
    .参数 hKey, 整数型
    .参数 dwIndex, 整数型
    .参数 lpName, 文本型, 传址
    .参数 cbName, 整数型

.DLL命令 RegDeleteKeyA, 整数型, "advapi32.dll", "RegDeleteKeyA", 公开, _注册表_删除项删除现有项下方一个指定的子项  零（ERROR_SUCCESS）表示成功。其他任何值都代表一个错误代码
    .参数 hKey, 整数型, , 一个已打开项的句柄，或者标准项名之一
    .参数 lpSubKey, 文本型, , 要删除项的名字。这个项的所有子项也会删除;

.DLL命令 RegOpenKeyA, 整数型, "advapi32.dll", "RegOpenKeyA", 公开, _注册表_打开项 打开一个现有的注册表项  零（ERROR_SUCCESS）表示成功。其他任何值都代表一个错误代码
    .参数 hKey, 整数型, , 一个已打开项的句柄，或指定一个标准项名
    .参数 lpSubKey, 文本型, , 要打开的项名
    .参数 phkResult, 整数型, 传址, 指定一个变量，用于装载（保存）打开注册表项的一个句柄;

.DLL命令 RegSetValueExA, 整数型, "advapi32.dll", "RegSetValueExA", 公开, _注册表_置值设置指定项的值  零（ERROR_SUCCESS）表示成功。其他任何值都代表一个错误代码
    .参数 hKey, 整数型, , 一个已打开项的句柄，或指定一个标准项名
    .参数 lpValueName, 文本型, , 要设置值的名字
    .参数 Reserved, 整数型, , 未用，设为零
    .参数 dwType, 整数型, , 要设置的数量类型
    .参数 lpData, 字节集, , 包含数据的缓冲区中的第一个字节
    .参数 cbData, 整数型, , lpData缓冲区的长度;

.DLL命令 RegSetValueExA_数值, 整数型, "advapi32.dll", "RegSetValueExA", 公开, _注册表_置值_文本型 设置指定项的值  零（ERROR_SUCCESS）表示成功。其他任何值都代表一个错误代码
    .参数 hKey, 整数型, , 一个已打开项的句柄，或指定一个标准项名
    .参数 lpValueName, 文本型, , 要设置值的名字
    .参数 Reserved, 整数型, , 未用，设为零
    .参数 dwType, 整数型, , 要设置的数量类型
    .参数 lpData, 字节集, , 包含数据的缓冲区中的第一个字节
    .参数 cbData, 整数型, , lpData缓冲区的长度;

.DLL命令 RasDialA, 整数型, "rasapi32.dll", "RasDialA", 公开, _ADSL拨号
    .参数 lprasdialextensions, 整数型, , 拔号参数
    .参数 lpszPhonebook, 整数型, , 电话本名称,0
    .参数 lprasdialparamsa, ADSL拨号0, , 拔号参数
    .参数 dwNotifierType, 整数型, , 消息通知方式
    .参数 lpvNotifier, 整数型, , 消息处理回调子程序
    .参数 lphrasconn, 整数型, 传址, 返回的成功连接的连接句柄

.DLL命令 RasHangUpA, 整数型, "rasapi32.dll", "RasHangUpA", 公开, RasApi32.DLL挂断当前拔号连接 0表示成功
    .参数 hRasConn, 整数型, , 连接句柄

.DLL命令 RasGetEntryDialParams, 整数型, "rasapi32.dll", "RasGetEntryDialParamsA", 公开
    .参数 lpszPhoneBook, 文本型, 传址
    .参数 lpDialParams, ADSL拨号0, 传址, 未知类型：TRasDialParams。
    .参数 lpfPassword, 逻辑型, 传址

.DLL命令 GlobalSize_RASDIALPARAMS, 整数型, "kernel32.dll", "GlobalSize", , 取结构尺寸
    .参数 结构, ADSL拨号0, 传址

.DLL命令 GlobalSize_取连接信息用结构, 整数型, "kernel32.dll", "GlobalSize", 公开, kernel32.dll取结构尺寸
    .参数 结构, 取连接信息用结构, 传址

.DLL命令 GetPrivateProfileInt, 整数型, "kernel32.dll", "GetPrivateProfileIntA", 公开, 读配置项数值
    .参数 小节名, 字节集
    .参数 项目名, 文本型
    .参数 默认返回值, 整数型
    .参数 文件名, 文本型, ,   

.DLL命令 ConvertSidToStringSid, 整数型, "ADVAPI32.DLL", "ConvertSidToStringSidW", 公开, 　
    .参数 Sid, 字节集, 传址
    .参数 StringSid, 整数型, 传址

.DLL命令 IsValidSid, 整数型, "advapi32.dll", "IsValidSid", 公开, 使SID有效　
    .参数 pSid, 整数型

.DLL命令 LookupAccountName, 整数型, "advapi32.dll", "LookupAccountNameA", 公开, 把帐户名转为SID　
    .参数 lpSystemName, 文本型, 传址
    .参数 lpAccountName, 文本型
    .参数 Sid, 字节集, 传址
    .参数 cbSid, 整数型, 传址
    .参数 ReferencedDomainName, 文本型
    .参数 cbReferencedDomainName, 整数型, 传址
    .参数 peUse, 整数型, 传址

.DLL命令 LsaOpenPolicy, 整数型, "ADVAPI32.DLL", "LsaOpenPolicy", 公开
    .参数 SystemName, 整数型, , 未知类型：PLSA_UNICODE_STRING。
    .参数 ObjectAttributes, LSA_OBJECT_ATTRIBUTES, , 未知类型：PLSA_OBJECT_ATTRIBUTES。
    .参数 DesiredAccess, 整数型
    .参数 PolicyHandle, 整数型, 传址, 未知类型：PLongWord。

.DLL命令 RasEnumEntrie, 整数型, "rasapi32.dll", "RasEnumEntriesA", 公开
    .参数 reserved, 整数型
    .参数 lpszPhoneBook, 整数型
    .参数 entrynamesArray, 取连接信息用结构, 传址, 未知类型：LPRasEntryNameA。
    .参数 lpcb, 整数型, 传址
    .参数 lpcEntries, 整数型, 传址

.DLL命令 RasEnumEntries, 整数型, "rasapi32.dll", "RasEnumEntriesA", 公开, rasapi32.dll 取连接信息结构,连接名称,数量等等
    .参数 lpStrNull, 整数型, , 保留字段,必须为NIL
    .参数 lpszphonebook, 整数型, , 电话本名称,在Win9X下无作用
    .参数 lprasetryname, 取连接信息用结构, 传址 数组, RASENTRYNAME类型数组的指针
    .参数 lpcb, 整数型, 传址, 接收拨号连接名称的缓冲区的大小
    .参数 lpcentries, 整数型, 传址, 实际获得的拨号连接名称的数目

.DLL命令 InternetGetConnectedStateEx, 整数型, "wininet.dll", "InternetGetConnectedStateEx", 公开, _取连接状态 wininet.dll
    .参数 lpdwFlags, 整数型, 传址
    .参数 lpszConnectionName, 文本型, 传址
    .参数 dwNameLen, 整数型
    .参数 dwReserved, 整数型

.DLL命令 RasSetEntryPropertiesA, 整数型, "rasapi32.dll", "RasSetEntryPropertiesA", 公开, _创建新拨号连接 rasapi32.dll 0=建立成功,其他为失败
    .参数 lpszPhonebook, 整数型, , 电话本名称,0
    .参数 lpszEntry, 文本型, , 连接名称
    .参数 lpRasEntry, 创建连接所用结构
    .参数 dwEntryInfoSize, 整数型
    .参数 lpbDeviceInfo, 整数型
    .参数 wDeviceInfoSize, 整数型

.DLL命令 RasSetCredentialsA, 整数型, "rasapi32.dll", "RasSetCredentialsA", 公开, _设置拨号连接 rasapi32.dll
    .参数 lpszPhonebook, 整数型, , 电话本名称,0
    .参数 lpszEntry, 文本型, , 连接名称
    .参数 lpCredentials, 设置拨号所以结构
    .参数 fClearCredentials, 整数型

.DLL命令 GetKeyState, 逻辑型, "user32.dll", "GetKeyState", 公开, _取键盘状态 针对已处理过的按键，在最近一次输入信息时，判断指定虚拟键的状态  如开关键打开，则位0设为1（开关键包括CapsLock， ;    NumLock，ScrollLock）；如某个键当时正处于按下状态，则位15为1；如已经抬起，则为0
    .参数 键代码, 整数型, , 欲测试的虚拟键键码。对字母、数字字符（A-Z、a-z、0-9），用它们实际的ASCII值;

.DLL命令 GetOpenFileNamePreview, 逻辑型, "msvfw32.dll", "GetOpenFileNamePreview", , 系统_多文件对话框
    .参数 格式, OPENFILENAME

.DLL命令 GetSaveFileNamePreview, 逻辑型, "msvfw32.dll", "GetSaveFileNamePreviewA", , 对话框_保存文件
    .参数 格式, OPENFILENAME

.DLL命令 GetOpenFileNameA, 逻辑型, "Comdlg32.dll", "GetOpenFileNameA", 公开, _打开文件对话框
    .参数 结构, OPENFILENAME

.DLL命令 GetSaveFileNameA, 逻辑型, "Comdlg32.dll", "GetSaveFileNameA", 公开, _另存文件对话框
    .参数 结构, OPENFILENAME

.DLL命令 ExtractIconA, 整数型, "shell32.dll", "ExtractIconA", 公开, _图标取数量
    .参数 实例句柄, 整数型, , 可为0
    .参数 程序的全名, 文本型
    .参数 图标的索引, 整数型, , 欲获取的图标的索引。如果为-1，表示取得文件中的图标总数

.DLL命令 SHAutoComplete, , "Shlwapi.dll", "SHAutoComplete", 公开
    .参数 编辑框句柄, 整数型
    .参数 表示IE历史, 整数型

.DLL命令 GetShortPathNameA, 整数型, "kernel32.dll", "GetShortPathNameA", 公开, 取短文件名
    .参数 lpszLongPath, 文本型, 传址
    .参数 lpszShortPath, 文本型, 传址
    .参数 cchBuffer, 整数型

.DLL命令 GetShortPathNameW, 整数型, "kernel32", "GetShortPathNameW"
    .参数 lpszLongPath, 字节集
    .参数 lpszShortPath, 字节集
    .参数 cchBuffer, 整数型

.DLL命令 GetLongPathNameA, 整数型, "kernel32.dll", "GetLongPathNameA", 公开, 取长文件名
    .参数 lpszShortPath, 文本型, 传址
    .参数 lpszLongPath, 文本型, 传址
    .参数 cchBuffer, 整数型

.DLL命令 GetAdaptersInfo_字节集, 整数型, "IPHlpApi.dll", "GetAdaptersInfo"
    .参数 IpAdapterInfo, 字节集
    .参数 pOutBufLen, 整数型, 传址

.DLL命令 GetAdaptersInfo, 整数型, "IPHlpApi.dll", "GetAdaptersInfo", 公开
    .参数 IpAdapterInfo, 整数型
    .参数 pOutBufLen, 整数型, 传址

.DLL命令 CopyMemory_ip_adapter_info, 整数型, "kernel32.dll", "RtlMoveMemory", 公开
    .参数 Destination, IP_ADAPTER_INFO
    .参数 Source, 整数型
    .参数 Length, 整数型

.DLL命令 CopyMemory_ias, , "kernel32.dll", "RtlMoveMemory", 公开
    .参数 Destination, IP_ADDR_STRING, 传址
    .参数 Source, IP_ADDR_STRING
    .参数 Length, 整数型

.DLL命令 ImageList_Read, 整数型, "comctl32.dll", "ImageList_Read", 公开, 成功返回图片组句柄
    .参数 pstm, 整数型

.DLL命令 ImageList_Write, 逻辑型, "comctl32.dll", "ImageList_Write", 公开, 成功返回真,失败返回假
    .参数 图片组句柄, 整数型, , 图片组句柄
    .参数 pstm, 整数型

.DLL命令 ImageList_Replace, 整数型, "comctl32.dll", "ImageList_Replace", 公开
    .参数 图片组句柄, 整数型
    .参数 i, 整数型
    .参数 hbmImage, 整数型
    .参数 hbmMask, 整数型

.DLL命令 ImageList_ReplaceIcon, 整数型, "comctl32.dll", "ImageList_ReplaceIcon", 公开
    .参数 图片组句柄, 整数型, , ImageList_Create创建成功后的返回值
    .参数 位置, 整数型, , 索引从0开始
    .参数 图标句柄, 整数型

.DLL命令 ImageList_AddIcon, 整数型, "comctl32.dll", "ImageList_AddIcon", 公开, 添加图标到图片组
    .参数 图片组句柄, 整数型
    .参数 ico句柄, 整数型

.DLL命令 ImageList_Add, 整数型, "comctl32.dll", "ImageList_Add", 公开
    .参数 图标列表句柄, 整数型
    .参数 位图句柄, 整数型
    .参数 掩码位位图句柄, 整数型

.DLL命令 ImageList_SetBkColor, 逻辑型, "comctl32.dll", "ImageList_SetBkColor", 公开, 设置图片组背景颜色
    .参数 图片组句柄, 整数型
    .参数 欲设置的颜色, 整数型, , 其它选项可使用 CLR_开头的常量

.DLL命令 ImageList_GetBkColor, 整数型, "comctl32.dll", "ImageList_GetBkColor", 公开, 返回图片组背景颜色
    .参数 图片组句柄, 整数型

.DLL命令 ImageList_SetIconSize, 逻辑型, "comctl32.dll", "ImageList_SetIconSize", 公开, 设置图片组图标大小
    .参数 图片组句柄, 整数型, , 图片组句柄,ImageList_Create创建成功后的返回值
    .参数 宽度, 整数型, 传址
    .参数 高度, 整数型, 传址

.DLL命令 ImageList_SetImageCount, 逻辑型, "comctl32.dll", "ImageList_SetImageCount", 公开, 设置图片组图片数
    .参数 图片组句柄, 整数型, , ImageList_Create创建成功后的返回值
    .参数 欲设置的图片数, 整数型

.DLL命令 ImageList_GetImageCount, 整数型, "comctl32.dll", "ImageList_GetImageCount", 公开, 取图片组图片数
    .参数 图片组句柄, 整数型, , 图片组句柄,ImageList_Create创建成功后的返回值

.DLL命令 ImageList_GetIconSize, 逻辑型, "comctl32.dll", "ImageList_GetIconSize", 公开, 取图片组图标大小
    .参数 图片组句柄, 整数型, , ImageList_Create创建成功后的返回值
    .参数 宽度, 整数型, 传址
    .参数 高度, 整数型, 传址

.DLL命令 ImageList_Remove, 逻辑型, "comctl32.dll", "ImageList_Remove", 公开, 删除指定图片组图片
    .参数 图片组句柄, 整数型, , 图片组句柄,ImageList_Create创建成功后的返回值
    .参数 位置, 整数型, , 位置0为第一个,如果本参数设置为-1表示删除图片组所有图标

.DLL命令 ImageList_Create, 整数型, "comctl32.dll", "ImageList_Create", 公开, 创建图片组,返回图片组句柄
    .参数 宽度, 整数型
    .参数 高度, 整数型
    .参数 位深, 整数型
    .参数 初始数量, 整数型
    .参数 是否手动销毁, 整数型

.DLL命令 ImageList_Destroy, 整数型, "comctl32.dll", "ImageList_Destroy", 公开, 销毁图片组
    .参数 图片组句柄, 整数型, , ImageList_Create创建成功后的返回值

.DLL命令 SetWindowLongA, 整数型, "user32.dll", "SetWindowLongA", 公开, 在窗口结构中为指定的窗口设置信息  指定数据的前一个值
    .参数 hwnd, 整数型, , 句柄
    .参数 nIndex, 整数型, , -16=样式，-20=扩展样式
    .参数 dwNewLong, 整数型, , 新样式

.DLL命令 SetWindowLongW, 整数型, "user32.dll", "SetWindowLongW", 公开
    .参数 hWnd, 整数型
    .参数 nIndex, 整数型
    .参数 dwNewLong, 整数型

.DLL命令 GetCommandLineA, 文本型, "kernel32.dll", "GetCommandLineA", 公开, 取命令行

.DLL命令 LsaRetrievePrivateData, 整数型, "ADVAPI32.DLL", "LsaRetrievePrivateData", 公开
    .参数 LSA_HANDLE, 整数型
    .参数 KeyName, LSA_UNICODE_STRING, , 未知类型：PLSA_UNICODE_STRING。
    .参数 PrivateData, 整数型, 传址, 未知类型：PLSA_UNICODE_STRING。

.DLL命令 RtlMoveMemory_LSA_UNICODE_STRING, , "kernel32.dll", "RtlMoveMemory", , 复制内存数据_MIB_IPFORWARDROW参数
    .参数 Destination, LSA_UNICODE_STRING, 传址, 目标地址
    .参数 Source, 字节集, , 要复制的数据MIB_IPFORWARDROW
    .参数 Length, 整数型, , 长度

.DLL命令 GetVersionEx, 逻辑型, "kernel32.dll", "GetVersionExA", 公开, 在一个OSVERSIONINFO结构中载入与平台和操作系统有关的版本信息  非零表示成功，零表示失败
    .参数 版本, OSVERSIONINFOEX, , OSVERSIONINFO，用于装载版本信息的结构。在正式调用函数之前，必须先将这个结构的dwOSVersionInfoSize字段设为结构的大小（148）;

.DLL命令 GetVersion, 整数型, "kernel32.dll", "GetVersion", 公开, ,

.DLL命令 GlobalSize_RASENTRY, 整数型, "kernel32.dll", "GlobalSize", 公开, 取结构尺寸
    .参数 结构, RasEntry, 传址

.DLL命令 RasGetEntryProperties, 整数型, "rasapi32.dll", "RasGetEntryPropertiesA", , 　
    .参数 lpcstr, 文本型
    .参数 lpcstr, 字节型, 传址 数组
    .参数 TLPRASENTRYA, RasEntry
    .参数 lpdword, 整数型, 传址
    .参数 lpbyte, 文本型
    .参数 lpdword, 整数型

.DLL命令 IsBadStringPtrA, 整数型, "kernel32.dll", "IsBadStringPtrA", 公开, 指针是否有效,无否返回1
    .参数 指针, 整数型
    .参数 ucchMax, 整数型, , 指针长度

.DLL命令 GetLastError, 整数型, "kernel32.dll", "GetLastError", 公开, 取错误信息

.DLL命令 QueryServiceConfig_字节, 整数型, "advapi32.dll", "QueryServiceConfigA", 公开, 函数检索指定服务的配置参数。使用QueryServiceConfig2功能，可选的配置参数都是可用
    .参数 hService, 整数型
    .参数 lpServiceConfig, 字节集, 传址
    .参数 cbBufSize, 整数型
    .参数 pcbBytesNeeded, 整数型, 传址

.DLL命令 QueryServiceConfig, 逻辑型, "advapi32.dll", "QueryServiceConfigA", 公开, 函数检索指定服务的配置参数。使用QueryServiceConfig2功能，可选的配置参数都是可用
    .参数 hService, 整数型
    .参数 lpServiceConfig
    .参数 cbBufSize, 整数型
    .参数 pcbBytesNeeded, 整数型, 传址

.DLL命令 GetServiceKeyName, 逻辑型, "advapi32.dll", "GetServiceKeyNameA", 公开, 通过显示名称取服务名称
    .参数 hSCManager, 整数型
    .参数 lpDisplayName, 文本型
    .参数 lpServiceName, 文本型
    .参数 lpcchBuffer, 整数型, 传址

.DLL命令 GetServiceDisplayName, 逻辑型, "advapi32.dll", "GetServiceDisplayNameA", 公开, 通过服务名称取显示名称
    .参数 hSCManager, 整数型
    .参数 lpServiceName, 文本型
    .参数 lpDisplayName, 文本型
    .参数 lpcchBuffer, 整数型, 传址

.DLL命令 LockServiceDatabase, 整数型, "advapi32.dll", "LockServiceDatabase", 公开
    .参数 hSCManager, 整数型

.DLL命令 ChangeServiceConfig2A, 逻辑型, "ADVAPI32.DLL", "ChangeServiceConfig2A", 公开
    .参数 hService, 整数型
    .参数 dwInfoLevel, 整数型
    .参数 lpInfo, , 传址

.DLL命令 StartServiceCtrlDispatcher, 整数型, "advapi32.dll", "StartServiceCtrlDispatcherA", 公开
    .参数 SERVICE_TABLE, SERVICE_Table, 数组

.DLL命令 RegisterServiceCtrlHandler, 整数型, "advapi32.dll", "RegisterServiceCtrlHandlerA", 公开
    .参数 lpServiceName, 文本型
    .参数 lpHandlerProc, 整数型

.DLL命令 SetServiceStatus, 整数型, "advapi32.dll", "SetServiceStatus", 公开
    .参数 hServiceStatus, 整数型
    .参数 lpServiceStatus, SERVICE_STATUS

.DLL命令 GdipLoadImageFromStream, 整数型, "GdiPlus.dll", "GdipLoadImageFromStream", 公开
    .参数 stream, 整数型
    .参数 image, 整数型, 传址

.DLL命令 GdipGetImageDimension, 整数型, "GdiPlus.dll", "GdipGetImageDimension", 公开
    .参数 image, 整数型
    .参数 width, 小数型, 传址
    .参数 height, 小数型, 传址

.DLL命令 GdipCreateFromHDC, 整数型, "GdiPlus.dll", "GdipCreateFromHDC", 公开
    .参数 hdc, 整数型
    .参数 graphics, 整数型, 传址

.DLL命令 GdipDrawImageRect, 整数型, "GdiPlus.dll", "GdipDrawImageRect", 公开
    .参数 graphics, 整数型
    .参数 image, 整数型
    .参数 x, 小数型
    .参数 y, 小数型
    .参数 width, 小数型
    .参数 height, 小数型

.DLL命令 GdipGetImageThumbnail, 整数型, "gdiplus.dll", "GdipGetImageThumbnail", 公开
    .参数 Image, 整数型
    .参数 thumbWidth, 整数型
    .参数 thumbHeight, 整数型
    .参数 thumbImage, 整数型, 传址
    .参数 callback, 整数型
    .参数 callbackData, 整数型

.DLL命令 GdipDisposeImage, 整数型, "gdiplus.dll", "GdipDisposeImage", 公开
    .参数 image, 整数型

.DLL命令 GdipDeleteGraphics, 整数型, "GdiPlus.dll", "GdipDeleteGraphics", 公开
    .参数 graphics, 整数型

.DLL命令 UpdateLayeredWindow, 整数型, "user32.dll", "UpdateLayeredWindow", 公开
    .参数 hWnd, 整数型
    .参数 hdcDst, 整数型
    .参数 pptDst, 整数型
    .参数 psize, Size
    .参数 hdcSrc, 整数型
    .参数 pptSrc, 精易_坐标
    .参数 crKey, 整数型
    .参数 pblend, BLENDFUNCTION
    .参数 dwFlags, 整数型

.DLL命令 RAROpenArchiveEx, 整数型, "unrar.dll", "RAROpenArchiveEx", , 打开 RAR 档案并分配内存结构，可指定 Unicode 档案名并可获取档案标志信息，返回档案打开句柄，失败返回 0
    .参数 ArchiveData, RAROpenArchiveDataEx, 传址, 打开数据结构

.DLL命令 RARSetPassword, , "unrar.dll", "RARSetPassword", , 为加密文件设置密码，无返回值
    .参数 hArcData, 整数型, , 档案打开句柄
    .参数 Password, 文本型, , 密码文本

.DLL命令 RARReadHeader, 整数型, "unrar.dll", "RARReadHeader", , 读取档案文件头，返回 0 表示成功，其他返回 ERAR_END_ARCHIVE/ERAR_BAD_DATA
    .参数 hArcData, 整数型, , 档案打开句柄
    .参数 HeaderData, RARHeaderData, 传址, 文件头数据结构

.DLL命令 RARSetCallback, , "unrar.dll", "RARSetCallback", , 设置用户定义的回调函数来处理事件，无返回值
    .参数 hArcData, 整数型, , 档案打开句柄
    .参数 CallbackProc, 子程序指针, , 回调函数指针，注意回调函数中不可使用其他 UnRAR.dll 函数
    .参数 UserData, 整数型, , 传递到回调函数的用户定义数据

.DLL命令 RARProcessFile, 整数型, "unrar.dll", "RARProcessFile", , 提取、测试并移动档案中文件位置到下一位置，实际操作要根据打开方式和指定参数决定。返回值: 0 表示成功, 失败参见 ERAR_* 错误码(仅 12-19)
    .参数 hArcData, 整数型, , 档案打开句柄
    .参数 Operation, 整数型, , 文件操作方式（RAR_SKIP/RAR_TEST/RAR_EXTRACT）
    .参数 DestPath, 文本型, , 文件提取的目标目录，留空表示提取到当前目录。该参数仅在 DestName 参数为空时有效。
    .参数 DestName, 文本型, , 文件提取的完整路径和提取文件的名称，留空则使用默认文件名。不为空则以指定名称提取档案中的文件。

.DLL命令 RARCloseArchive, 整数型, "unrar.dll", "RARCloseArchive", , 档案处理完毕后调用该函数，关闭档案文件并释放内存。成功返回 0，失败返回 ERAR_ECLOSE。
    .参数 hArcData, 整数型, , 档案打开句柄

.DLL命令 SQLAllocHandle, 短整数型, "odbc32.dll", "SQLAllocHandle"
    .参数 hType, 短整数型, , SQL_HANDLE_
    .参数 inputHandle, 整数型
    .参数 outputHandle, 整数型, 传址

.DLL命令 SQLSetEnvAttr, 短整数型, "odbc32.dll", "SQLSetEnvAttr"
    .参数 henv, 整数型
    .参数 attributes, 整数型
    .参数 valuePtr, 整数型
    .参数 strLength, 整数型

.DLL命令 SQLConnect, 短整数型, "odbc32.dll", "SQLConnect"
    .参数 ConnectionHandle, 整数型
    .参数 ServerName, 文本型
    .参数 NameLength1, 短整数型
    .参数 UserName, 文本型
    .参数 NameLength2, 短整数型
    .参数 Authentication, 文本型
    .参数 NameLength3, 短整数型

.DLL命令 SQLDriverConnect, 短整数型, "odbc32.dll", "SQLDriverConnect"
    .参数 Hdbc, 整数型
    .参数 WindowHandle, 整数型
    .参数 InConnectionString, 文本型, , 连接字符串
    .参数 StringLength1, 短整数型, , 连接字符串长度
    .参数 OutConnecctionString, 文本型, , 输出连接字符串缓冲区
    .参数 BufferLength, 短整数型, , 缓冲区长度
    .参数 StringLength2Ptr, 整数型, 传址, 返回实际长度
    .参数 DriverCompletion, 短整数型, , 指定函数执行的标志。其值可为：SQL_DRIVER_PROMPT:如果连接字符串未包括Driver，DSN，FileDSN关键字，系统会弹出Data Source窗口；SQL_DRIVER_COMPLETE或SQL_DRIVER_COMPLETE_REQUIRED:如果指定数据源，则应用程序使用此数据源，否则，系统弹出DataSource窗口；SQL_DRIVER_NOPROMPT:使用指定的数据源，不弹出Data Source窗口 

.DLL命令 SQLDisconnect, 短整数型, "odbc32.dll", "SQLDisconnect", , 断开连接
    .参数 Hdbc, 整数型

.DLL命令 SQLExecDirect, 短整数型, "odbc32.dll", "SQLExecDirect"
    .参数 StatementHandle, 整数型
    .参数 StatementText, 文本型
    .参数 TextLength, 整数型

.DLL命令 SQLFreeHandle, 短整数型, "odbc32.dll", "SQLFreeHandle"
    .参数 HandleType, 短整数型
    .参数 Handle, 整数型

.DLL命令 SQLGetDiagRec, 短整数型, "odbc32.dll", "SQLGetDiagRec"
    .参数 HandleType, 整数型
    .参数 Handle, 整数型
    .参数 RecNumber, 短整数型
    .参数 Sqlstate, 文本型, 传址
    .参数 NativeError, 整数型, 传址
    .参数 MessageText, 文本型, 传址
    .参数 BufferLength, 短整数型
    .参数 TextLength, 整数型, 传址

.DLL命令 SQLRowCount, 短整数型, "odbc32.dll", "SQLRowCount"
    .参数 StatementHandle, 整数型
    .参数 RowCount, 整数型, 传址

.DLL命令 SQLFetch, 短整数型, "odbc32.dll", "SQLFetch"
    .参数 StatementHandle, 整数型

.DLL命令 SQLGetData, 短整数型, "odbc32.dll", "SQLGetData"
    .参数 StatementHandle, 整数型
    .参数 ColumnNumber, 短整数型, , 列号，从1开始
    .参数 TargetType, 短整数型
    .参数 TargetValuePtr, 整数型
    .参数 BufferLength, 整数型
    .参数 StrLen_or_Ind, 整数型, 传址

.DLL命令 SQLNumResultCols, 短整数型, "odbc32.dll", "SQLNumResultCols"
    .参数 StatementHandle, 整数型
    .参数 ColumnCountPtr, 整数型, 传址

.DLL命令 SQLDescribeCol, 短整数型, "odbc32.dll", "SQLDescribeCol"
    .参数 StatementHandle, 整数型
    .参数 ColumnNumber, 短整数型
    .参数 ColumnName, 文本型
    .参数 BufferLength, 短整数型
    .参数 NameLengthPtr, 整数型, 传址
    .参数 DataTypePtr, 整数型, 传址
    .参数 ColumnSizePtr, 整数型, 传址
    .参数 DecimalDigitsPtr, 整数型, 传址
    .参数 NullablePtr, 整数型, 传址

.DLL命令 SQLSetConnectAttr, 短整数型, "odbc32.dll", "SQLSetConnectAttr"
    .参数 ConnectionHandle, 整数型
    .参数 Attribute, 整数型
    .参数 ValuePtr, 整数型
    .参数 StringLength, 整数型

.DLL命令 SQLGetConnectAttr, 短整数型, "odbc32.dll", "SQLGetConnectAttr"
    .参数 ConnectionHandle, 整数型
    .参数 Attribute, 整数型
    .参数 ValuePtr, 整数型
    .参数 BufferLength, 整数型
    .参数 StringLength, 整数型, 传址

.DLL命令 SQLBindParameter, 短整数型, "odbc32.dll", "SQLBindParameter"
    .参数 StatementHandle, 整数型
    .参数 ParameterNumber, 短整数型
    .参数 InputOutputType, 短整数型, , SQL_PARAM_INPUT，SQL_PARAM_OUTPUT ，SQL_PARAM_INPUT_OUTPUT
    .参数 ValueType, 短整数型
    .参数 ParameterType, 短整数型
    .参数 ColumnSize, 整数型
    .参数 DecimalDigits, 短整数型
    .参数 ParameterValuePtr, 字节集
    .参数 BufferLength, 整数型
    .参数 StrLen_or_IndPtr, 整数型, 传址

.DLL命令 SQLPrepare, 短整数型, "odbc32.dll", "SQLPrepare"
    .参数 StatementHandle, 整数型
    .参数 StatementText, 文本型
    .参数 TextLength, 整数型

.DLL命令 SQLExecute, 短整数型, "odbc32.dll", "SQLExecute"
    .参数 StatementHandle, 整数型

.DLL命令 SQLEndTran, 短整数型, "odbc32.dll", "SQLEndTran"
    .参数 HandleType, 短整数型
    .参数 Handle, 整数型
    .参数 CompletionType, 短整数型

.DLL命令 SQLSetStmtAttr, 短整数型, "odbc32.dll", "SQLSetStmtAttr"
    .参数 StatementHandle, 整数型
    .参数 Attribute, 整数型
    .参数 Value, 整数型
    .参数 StringLength, 整数型

.DLL命令 SQLFetchScroll, 短整数型, "odbc32.dll", "SQLFetchScroll"
    .参数 StatementHandle, 整数型
    .参数 FetchOrientation, 短整数型
    .参数 FetchOffset, 整数型

.DLL命令 SQLGetStmtAttr, 短整数型, "odbc32.dll", "SQLGetStmtAttr"
    .参数 StatementHandle, 整数型
    .参数 Attribute, 整数型
    .参数 Value, 整数型, 传址
    .参数 BufferLength, 整数型
    .参数 StringLength, 整数型, 传址

.DLL命令 SQLBindCol, 短整数型, "odbc32.dll", "SQLBindCol"
    .参数 StatementHandle, 整数型
    .参数 ColumnNumber, 短整数型
    .参数 TargetType, 短整数型
    .参数 TargetValue, 整数型
    .参数 BufferLength, 整数型
    .参数 StrLen_or_Ind, 整数型, 传址

.DLL命令 InitCompression, 整数型, "gzip.dll", "InitCompression", 公开

.DLL命令 CreateCompression, 整数型, "gzip.dll", "CreateCompression", 公开
    .参数 context, 整数型, 传址
    .参数 flags, 整数型

.DLL命令 Compress, 整数型, "gzip.dll", "Compress", 公开, 压缩
    .参数 context, 整数型
    .参数 inBytes, 字节集
    .参数 input_size, 整数型
    .参数 outBytes, 字节集
    .参数 output_size, 整数型
    .参数 input_used, 整数型, 传址
    .参数 output_used, 整数型, 传址
    .参数 compressionLevel, 整数型

.DLL命令 DestroyCompression, 整数型, "gzip.dll", "DestroyCompression", 公开
    .参数 context, 整数型

.DLL命令 InitDecompression, 整数型, "gzip.dll", "InitDecompression", 公开, gzip.dll 请自行到这里来下载http://pan.baidu.com/share/link?shareid=222122&uk=2013335237

.DLL命令 CreateDecompression, 整数型, "gzip.dll", "CreateDecompression", 公开
    .参数 context, 整数型, 传址
    .参数 flags, 整数型

.DLL命令 Decompress, 整数型, "gzip.dll", "Decompress", , 解压
    .参数 context, 整数型
    .参数 inBytes, 字节集
    .参数 input_size, 整数型
    .参数 outBytes, 字节集
    .参数 output_size, 整数型
    .参数 input_used, 整数型, 传址
    .参数 output_used, 整数型, 传址

.DLL命令 DestroyDecompression, , "gzip.dll", "DestroyDecompression", 公开
    .参数 context, 整数型

.DLL命令 lstrcpy_bin, 整数型, "kernel32.dll", "lstrcpyA", , 复制字符串
    .参数 lpString1, 字节集, 传址, 传址
    .参数 lpString2, 字节集, 传址, 传址

.DLL命令 lstrcpy_int, 整数型, "kernel32.dll", "lstrcpyA", , 复制字符串
    .参数 lpString1, 整数型, 传址, 传址
    .参数 lpString2, 整数型, 传址, 传址

.DLL命令 lstrcpy_text, 整数型, "kernel32.dll", "lstrcpyA", , 复制字符串
    .参数 lpString1, 文本型, 传址, 传址
    .参数 lpString2, 文本型, 传址, 传址

.DLL命令 RtlMoveMemory_LARGE_INTEGER, , "kernel32.dll", "RtlMoveMemory", , 拷贝内存
    .参数 Destination, LARGE_INTEGER
    .参数 Source, 长整数型, 传址
    .参数 Length, 整数型

.DLL命令 RtlMoveMemory_LARGE_DOUBLE, , "kernel32.dll", "RtlMoveMemory", , 拷贝内存
    .参数 Destination, LARGE_INTEGER
    .参数 Source, 双精度小数型, 传址
    .参数 Length, 整数型

.DLL命令 ShellExecuteEx, 整数型, "shell32.dll", "ShellExecuteEx", 公开, 　
    .参数 lpExecInfo, SHELLEXECUTEINFOA

.DLL命令 ShellExecuteExW, 逻辑型, "shell32.dll", "ShellExecuteExW"
    .参数 lpExecInfo, SHELLEXECUTEINFOW, , 0

.DLL命令 RegOpenKeyExA, 整数型, "advapi32.dll", "RegOpenKeyExA", 公开
    .参数 hKey, 整数型
    .参数 lpSubKey, 文本型
    .参数 ulOptions, 整数型
    .参数 samDesired, 整数型
    .参数 phkResult, 整数型, 传址

.DLL命令 RegCreateKeyExA, 整数型, "advapi32.dll", "RegCreateKeyExA", 公开
    .参数 hKey, 整数型
    .参数 lpSubKey, 文本型
    .参数 Reserved, 整数型
    .参数 lpClass, 整数型
    .参数 dwOptions, 整数型
    .参数 samDesired, 整数型
    .参数 lpSecurityAttributes, 整数型
    .参数 phkResult, 整数型, 传址
    .参数 lpdwDisposition, 整数型, 传址

.DLL命令 DrawTextA, 整数型, "user32.dll", "DrawTextA", 公开, 将文本描绘到指定的矩形中　描绘文字的高度
    .参数 HDC, 整数型, , 欲在其中显示文字的一个设备场景的句柄
    .参数 String, 文本型, , 欲描绘的文本字串
    .参数 StringCount, 整数型, , 欲描绘的字符数量。如果要描绘整个字串（直到空中止符），则可将这个参数设为-1
    .参数 rect, 精易_矩形, , RECT，指定用于绘图的一个格式化矩形（采用逻辑坐标）
    .参数 format, 整数型, , 一个标志位数组，决定了以何种形式执行绘图。参考下面总结的常数类型列表标志常数说明DT_BOTTOM必须同时指定DT_SINGLE。指示文本对齐格式化矩形的底边DT_CALCRECT象下面这样计算格式化矩形：多行绘图时矩形的底边根据需要进行延展，以便容下所有文字；单行绘图时，延展矩形的右侧。不描绘文字。由lpRect参数指定的矩形会载入计算出来的值DT_CENTER文本垂直居中DT_EXPANDTABS描绘文字的时候，对制表站进行扩展。默认的制表站间距是8个字符。但是，可用DT_TABSTOP标志改变这项设定DT_EXTERNALLEADING计算文本行高度的时候，使用当前字体的外部间距属性（the external leading attribute）DT_LEFT文本左对齐DT_NOCLIP描绘文字时不剪切到指定的矩形DT_NOPREFIX通常，函数认为 & 字符表示应为下一个字符加上下划线。该标志禁止这种行为DT_RIGHT文本右对齐DT_SINGLELINE只画单行DT_TABSTOP指定新的制表站间距，采用这个整数的高8位DT_TOP必须同时指定DT_SINGLE。指示文本对齐格式化矩形的顶部DT_VCENTER必须同时指定DT_SINGLE。指示文本对齐格式化矩形的中部DT_WORDBREAK进行自动换行。如用SetTextAlign函数设置了TA_UPDATECP标志，这里的设置则无效;

.DLL命令 FindWindowExA, 整数型, "user32.dll", "FindWindowExA", 公开, 取子窗口句柄
    .参数 hWndParent, 整数型, , 父窗口要搜索其子窗口的句柄
    .参数 hWndChildAfter, 整数型, , 子窗口的句柄
    .参数 lpszClass, 整数型, , 窗口类名
    .参数 lpszWindow, 整数型, , 窗口名称

.DLL命令 capGetDriverDescriptionA, 逻辑型, "avicap32.dll", "capGetDriverDescriptionA", 公开
    .参数 dwDriverIndex, 整数型
    .参数 lpszName, 文本型
    .参数 cbName, 整数型
    .参数 lpszVer, 文本型
    .参数 cbVer, 整数型

.DLL命令 AddFontResourceA, 整数型, "gdi32.dll", "AddFontResourceA", 公开, 在Windows系统中添加一种字体资源
    .参数 LPCSTR, 文本型

.DLL命令 RemoveFontResourceA, 逻辑型, "gdi32.dll", "RemoveFontResourceA", 公开, 通常情况下，只允许卸载由“AddFontResourceA()”安装的字体资源
    .参数 LPCSTR, 文本型

.DLL命令 RtlMoveMemory_字节集2, 整数型, "kernel32.dll", "RtlMoveMemory", 公开, RtlMoveMemory
    .参数 目标数据地址, 字节集, , lpvDest
    .参数 源数据, 字节集, , lpvSource
    .参数 尺寸, 整数型, , cbCopy

.DLL命令 PathFileExistsA, 整数型, "shlwapi.dll", "PathFileExistsA", 公开
    .参数 pszPath, 文本型

.DLL命令 mciSendStringA, 整数型, "winmm.dll", "mciSendStringA", , 播放音乐文件
    .参数 lpstrCommand, 文本型
    .参数 lpstrRetumString, 文本型
    .参数 uReturnLength, 整数型
    .参数 hwndCallback, 整数型

.DLL命令 StrToIntEx, 整数型, "shlwapi.dll", "StrToIntExA", 公开
    .参数 pszString, 文本型
    .参数 dwFlags, 整数型
    .参数 piRet, 整数型, 传址

.DLL命令 lstrcmp, 整数型, "kernel32.dll", "lstrcmpA", 公开, 比较两个字符串
    .参数 lpString1, 文本型
    .参数 lpString2, 文本型

.DLL命令 Sleep, 整数型, "kernel32.dll", "Sleep", 公开, 延时
    .参数 毫秒, 整数型

.DLL命令 CreatePipe, 逻辑型, "kernel32.dll", "CreatePipe"
    .参数 phReadPipe, 整数型, 传址
    .参数 phWritePipe, 整数型, 传址
    .参数 lpPipeAttributes, SECURITY_ATTRIBUTES
    .参数 nSize, 整数型

.DLL命令 PeekNamedPipe_字节集, 逻辑型, "kernel32.dll", "PeekNamedPipe", 公开
    .参数 hNamedPipe, 整数型
    .参数 lpBuffer, 字节集
    .参数 nBufferSize, 整数型
    .参数 lpBytesRead, 整数型, 传址
    .参数 lpTotalBytesAvail, 整数型, 传址
    .参数 lpBytesLeftThisMessage, 整数型, 传址

.DLL命令 PeekNamedPipe, 逻辑型, "kernel32.dll", "PeekNamedPipe"
    .参数 hNamedPipe, 整数型
    .参数 lpBuffer, 整数型
    .参数 nBufferSize, 整数型
    .参数 lpBytesRead, 整数型
    .参数 lpTotalBytesAvail, 整数型, 传址
    .参数 lpBytesLeftThisMessage, 整数型

.DLL命令 ReadFile, 整数型, "kernel32.dll", "ReadFile"
    .参数 hFile, 整数型
    .参数 lpBuffer, 字节集, 传址
    .参数 nNumberOfBytesToRead, 整数型
    .参数 lpNumberOfBytesRead, 整数型, 传址
    .参数 lpOverlapped, 整数型

.DLL命令 GetExitCodeProcess, 整数型, "kernel32.dll", "GetExitCodeProcess"
    .参数 hProcess, 整数型
    .参数 lpExitCode, 整数型, 传址

.DLL命令 CreateProcessA, 逻辑型, "kernel32.dll", "CreateProcessA"
    .参数 lpApplicationName, 整数型
    .参数 lpCommandLine, 文本型
    .参数 lpProcessAttributes, 整数型
    .参数 lpThreadAttributes, 整数型
    .参数 bInheritHandles, 逻辑型
    .参数 dwCreationFlags, 整数型
    .参数 lpEnvironment, 整数型
    .参数 lpCurrentDriectory, 整数型
    .参数 lpStartupInfo, STARTUPINFO, 传址
    .参数 lpProcessInformation, 精易_进程结构, 传址

.DLL命令 UrlMkSetSessionOption, 整数型, "urlmon.dll", "UrlMkSetSessionOption", , 设置当前程序中浏览器的UserAgent
    .参数 dwOption, 整数型, , INTERNET_OPTION_PROXY ,INTERNET_OPTION_REFRESH ,URLMON_OPTION_USERAGENT,URLMON_OPTION_USERAGENT_REFRESH 
    .参数 pBuffer, 文本型
    .参数 dwBufferLength, 整数型, , Length
    .参数 dwReserved, 整数型, , 0

.DLL命令 GetPrivateProfileSection, 整数型, "kernel32.dll", "GetPrivateProfileSectionA", , 文件_取配置项名数组1  枚举节成员
    .参数 小节名, 文本型, , lpAppName
    .参数 返回文本, 字节集, , lpReturnedString
    .参数 返回文本大小, 整数型, , nSize
    .参数 配置项文件名, 文本型, , lpFileName

.DLL命令 WritePrivateProfileSection, 逻辑型, "kernel32.dll", "WritePrivateProfileSectionA"
    .参数 lpAppName, 文本型
    .参数 lpString, 字节集
    .参数 lpFileName, 文本型

.DLL命令 GetPrivateProfileString, 整数型, "kernel32.dll", "GetPrivateProfileStringA", , 读配置项文本
    .参数 lpApplicationName, 文本型
    .参数 lpKeyName, 文本型
    .参数 lpDefault, 文本型
    .参数 lpReturnedString, 文本型
    .参数 nSize, 整数型
    .参数 lpFileName, 文本型

.DLL命令 WritePrivateProfileString, 逻辑型, "kernel32.dll", "WritePrivateProfileStringA", , 写配置项文本
    .参数 lpApplicationName, 文本型
    .参数 lpKeyName, 文本型
    .参数 lpString, 文本型
    .参数 lpFileName, 文本型

.DLL命令 WritePrivateProfileStruct, 逻辑型, "kernel32.dll", "WritePrivateProfileStructA", , 写配置项结构
    .参数 lpszSection, 文本型
    .参数 lpszKey, 文本型
    .参数 lpStruct, 字节集
    .参数 uSizeStruct, 整数型
    .参数 szFile, 文本型

.DLL命令 GetPrivateProfileStruct, 整数型, "kernel32.dll", "GetPrivateProfileStructA", , 配置项_读配置项结构
    .参数 lpszSection, 文本型
    .参数 lpszKey, 文本型
    .参数 lpStruct, 字节集
    .参数 uSizeStruct, 整数型
    .参数 szFile, 文本型

.DLL命令 GetPrivateProfileSectionNames, 整数型, "kernel32.dll", "GetPrivateProfileSectionNamesA", , 枚举项
    .参数 lpszReturnBuffer, 字节集
    .参数 nSize, 整数型
    .参数 lpFileName, 文本型

.DLL命令 WriteProfileSection, 逻辑型, "kernel32.dll", "WriteProfileSectionA", , 写系统节
    .参数 lpAppName, 文本型
    .参数 lpString, 字节集

.DLL命令 GetProfileSection, 整数型, "kernel32.dll", "GetProfileSectionA", , 取系统项数
    .参数 lpAppName, 文本型
    .参数 lpReturnedString, 字节集
    .参数 nSize, 整数型

.DLL命令 GetProfileString, 整数型, "kernel32.dll", "GetProfileStringA", , 读系统项文本
    .参数 lpAppName, 文本型
    .参数 lpKeyName, 文本型
    .参数 lpDefault, 文本型
    .参数 lpReturnedString, 文本型
    .参数 nSize, 整数型

.DLL命令 WriteProfileString, 逻辑型, "kernel32.dll", "WriteProfileStringA", , 写系统项文本
    .参数 lpszSection, 文本型
    .参数 lpszKeyName, 文本型
    .参数 lpszString, 文本型

.DLL命令 GetProfileInt, 整数型, "kernel32.dll", "GetProfileIntA", , 读系统项数值
    .参数 lpAppName, 文本型
    .参数 lpKeyName, 文本型
    .参数 nDefault, 整数型

.DLL命令 InternetTimeFromSystemTime, 逻辑型, "wininet.dll", "InternetTimeFromSystemTime", , 时间_转为GMT格式1
    .参数 pst, 精易_时间
    .参数 dwRFC, 整数型
    .参数 lpszTime, 文本型
    .参数 cbTime, 整数型

.DLL命令 InternetTimeToSystemTime, 逻辑型, "wininet.dll", "InternetTimeToSystemTime", , 时间_GMT转为时间
    .参数 lpszTime, 文本型
    .参数 pst, 精易_时间
    .参数 dwReserved, 整数型

.DLL命令 WinHttpTimeFromSystemTime, 逻辑型, "Winhttp.dll", "WinHttpTimeFromSystemTime", , 时间_转为GMT格式2
    .参数 pst, 精易_时间
    .参数 pwszTime, 字节集

.DLL命令 WinHttpTimeToSystemTime, 逻辑型, "Winhttp.dll", "WinHttpTimeToSystemTime", , 时间_GMT转为时间1
    .参数 pwszTime, 字节集
    .参数 pst, 精易_时间

.DLL命令 CommandLineToArgvW, 整数型, "Shell32.dll", "CommandLineToArgvW", , 程序_取命令行 ()
    .参数 lpCmdLine, 整数型
    .参数 pNumArgs, , 传址

.DLL命令 GetCommandLineW, 整数型, "Kernel32.dll", "GetCommandLineW", , 程序_取命令行 ()

.DLL命令 PeekMessage, 逻辑型, "user32.dll", "PeekMessageA", , 系统_处理事件1
    .参数 lpMsg, MSG
    .参数 hwnd, 整数型
    .参数 wMsgFilterMin, 整数型
    .参数 wMsgFilterMax, 整数型
    .参数 wRemoveMsg, 整数型

.DLL命令 TranslateMessage, 逻辑型, "user32.dll", "TranslateMessage", , 系统_处理事件1
    .参数 消息结构, MSG, , lpMsg

.DLL命令 DispatchMessage, 整数型, "user32.dll", "DispatchMessageA", , 系统_处理事件1
    .参数 消息结构, MSG, , lpMsg

.DLL命令 NetJoinDomain, 整数型, "NETAPI32.DLL", "NetJoinDomain"
    .参数 lpServer
    .参数 lpDomain, 字节集
    .参数 lpAccountOU
    .参数 lpAccount, 字节集
    .参数 lpPassword, 字节集
    .参数 fJoinOptions, 整数型

.DLL命令 NetUnjoinDomain, 整数型, "NETAPI32.DLL", "NetUnjoinDomain"
    .参数 lpServer
    .参数 lpAccount, 字节集
    .参数 lpPassword, 字节集
    .参数 fUnjoinOptions

.DLL命令 SRSetRestorePoint, 逻辑型, "SrClient.dll", "SRSetRestorePointA", , 创建还原点
    .参数 pRestorePtSpec, RESTOREPTINFO
    .参数 pSMgrStatus, SMGRSTATUS

.DLL命令 SRRemoveRestorePoint, 整数型, "SrClient.dll", "SRRemoveRestorePoint", , 删除还原点
    .参数 dwRPNum, 整数型

.DLL命令 lstrcpy_bytes, 整数型, "kernel32.dll", "lstrcpyA", , 创建还原点
    .参数 文本1, 字节型, 传址 数组, RetVal
    .参数 文本2, 文本型, , Ptr

.DLL命令 GetFontResourceInfoW, 逻辑型, "gdi32.dll", "GetFontResourceInfoW", , 系统_取字体名
    .参数 pwszFontPath, 字节集
    .参数 lLen, 整数型, 传址
    .参数 fontRes, FONT_RESOURCE
    .参数 dwType, 整数型

.DLL命令 GetNativeSystemInfo, 整数型, "kernel32.dll", "GetNativeSystemInfo", , 系统_取CPU占用率
    .参数 lpSystemInfo, SYSTEM_INFO

.DLL命令 GetSystemInfo, 整数型, "kernel32.dll", "GetSystemInfo", , 系统_取CPU占用率
    .参数 系统信息, SYSTEM_INFO

.DLL命令 NtQuerySystemInformation, 整数型, "ntdll.dll", "NtQuerySystemInformation", ,  系统_取CPU占用率
    .参数 SystemInformationClass, 整数型
    .参数 SystemInformation, 整数型
    .参数 SystemInformationLength, 整数型
    .参数 ReturnLength, 整数型, 传址

.DLL命令 RtlAdjustPrivilege, 整数型, "ntdll.dll", "RtlAdjustPrivilege", 公开
    .参数 Privilege, 整数型, , #Se
    .参数 Enable, 字节型
    .参数 CurrentThread, 字节型
    .参数 Enabled, 整数型, 传址

.DLL命令 ZwShutdownSystem, 整数型, "ntdll.dll", "ZwShutdownSystem", , 系统_关电源
    .参数 参数

.DLL命令 FlashWindowEx, 逻辑型, "user32.dll", "FlashWindowEx"
    .参数 pfwi, PFLASHWINFO

.DLL命令 SysAllocString, 整数型, "OleAut32.dll", "SysAllocString"
    .参数 psz, 字节集

.DLL命令 GdipLoadImageFromFile, 整数型, "gdiplus.dll", "GdipLoadImageFromFile", ,  
    .参数 filename, 字节集
    .参数 image, 整数型, 传址

.DLL命令 CLSIDFromString, 整数型, "ole32.dll", "CLSIDFromString"
    .参数 lpsz, 整数型
    .参数 pclsid, 字节集

.DLL命令 IIDFromString, 整数型, "ole32.dll", "IIDFromString", , StringtoIID
    .参数 lpsz, 字节集
    .参数 lpiid, GUID

.DLL命令 CoInitializeEx, 整数型, "ole32.dll", "CoInitializeEx"
    .参数 pvReserved, 整数型
    .参数 dwCoInit, 整数型

.DLL命令 CoInitializeSecurity, 整数型, "ole32.dll", "CoInitializeSecurity"
    .参数 pSecDesc
    .参数 cAuthSvc, 整数型
    .参数 asAuthSvc
    .参数 pReserved1, 整数型
    .参数 dwAuthnLevel, 整数型
    .参数 dwImpLevel, 整数型
    .参数 pAuthList, 整数型
    .参数 dwCapabilities, 整数型
    .参数 pReserved3, 整数型

.DLL命令 CoCreateInstance_字节集, 整数型, "ole32.dll", "CoCreateInstance"
    .参数 rclsid, 字节集
    .参数 pUnkOuter, 整数型
    .参数 dwClsContext, 整数型
    .参数 riid, 字节集
    .参数 ppv, 对象, 传址

.DLL命令 CoCreateInstance, 整数型, "ole32.dll", "CoCreateInstance", , 窗口_在任务栏中显示
    .参数 rclsid, GUID
    .参数 pUnkOuter, 整数型
    .参数 dwClsContext, 整数型
    .参数 riid, GUID
    .参数 ppv, 整数型, 传址

.DLL命令 CoCreateInstance1, 整数型, "Ole32.dll", "CoCreateInstance"
    .参数 rclsid, 整数型
    .参数 pUnkOuter, 整数型
    .参数 dwClsContext, 整数型
    .参数 riid, 整数型
    .参数 ppv, 整数型, 传址

.DLL命令 CoSetProxyBlanket, 整数型, "ole32.dll", "CoSetProxyBlanket"
    .参数 pProxy, 整数型
    .参数 dwAuthnSvc, 整数型
    .参数 dwAuthzSvc, 整数型
    .参数 pServerPrincName
    .参数 dwAuthnLevel, 整数型
    .参数 dwImpLevel, 整数型
    .参数 pAuthInfo, 整数型
    .参数 dwCapabilities, 整数型

.DLL命令 CoTaskMemAlloc, 整数型, "ole32.dll", "CoTaskMemAlloc"
    .参数 cb, 整数型

.DLL命令 lstrcat, 文本型, "kernel32.dll", "lstrcatA", , 文本_指针到文本
    .参数 内存指针, 整数型
    .参数 lpString2, 整数型, 传址

.DLL命令 GetTimeZoneInformation, 整数型, "kernel32.dll", "GetTimeZoneInformation", , 系统_取系统时区
    .参数 时区结构设置, 时区信息_

.DLL命令 GetLocaleInfo, 整数型, "kernel32.dll", "GetLocaleInfoA"
    .参数 地方ID, 整数型
    .参数 类型, 整数型
    .参数 数据, 文本型
    .参数 数据尺寸, 整数型

.DLL命令 GetWindowInfo, 逻辑型, "user32.dll", "GetWindowInfo", , 窗口_是否激活
    .参数 hwnd, 整数型
    .参数 pwi, WINDOWINFO

.DLL命令 RtlAllocateHeap, , "ntdll.dll", "RtlAllocateHeap", , 堆内存分配
    .参数 hHeap, , , 堆句柄;可用GetProcessHeap()获取
    .参数 dwFlags, , , 标志
    .参数 dwBytes, , , 长度；单位为字节

.DLL命令 MakeSureDirectoryPathExists, 逻辑型, "dbghelp.dll", "MakeSureDirectoryPathExists", , 目录_创建
    .参数 DirPath, 文本型

.DLL命令 ILCreateFromPathA, 整数型, "Shell32.dll", "ILCreateFromPathA", 公开, 文件_定位
    .参数 lpFileName, 文本型

.DLL命令 ILCreateFromPathW, 整数型, "Shell32.dll", "ILCreateFromPathW"
    .参数 pszPath, 字节集

.DLL命令 ILFree, , "Shell32.dll", "ILFree", 公开, 文件_定位
    .参数 lngPidl, 整数型

.DLL命令 SHOpenFolderAndSelectItems, 整数型, "shell32.dll", "SHOpenFolderAndSelectItems", 公开, 文件_定位
    .参数 pidlfolder, 整数型
    .参数 cidl, 整数型
    .参数 apidl, 整数型
    .参数 dwFlags, 整数型

.DLL命令 GetFileInformationByHandle, 逻辑型, "kernel32.dll", "GetFileInformationByHandle", 公开, 文件_句柄取路径
    .参数 hFile, 整数型
    .参数 lpFileInformation, BY_HANDLE_FILE_INFORMATION

.DLL命令 GetVolumeInformation, 逻辑型, "kernel32.dll", "GetVolumeInformationA", 公开, 文件_句柄取路径
    .参数 lpRootPathName, 文本型
    .参数 lpVolumeNameBuffer, 文本型
    .参数 nVolumeNameSize, 整数型
    .参数 lpVolumeSerialNumber, 整数型, 传址
    .参数 lpMaximumComponentLength, 整数型, 传址
    .参数 lpFileSystemFlags, 整数型, 传址
    .参数 lpFileSystemNameBuffer, 文本型, 传址
    .参数 nFileSystemNameSize, 整数型

.DLL命令 ZwQueryInformationFile, 整数型, "ntdll.dll", "ZwQueryInformationFile", 公开, 文件_句柄取路径
    .参数 FileHandle
    .参数 IoStatusBlock, IO_STATUS_BLOCK
    .参数 FileInformation
    .参数 Length
    .参数 FileInformationClass

.DLL命令 GetFileAttributes, 整数型, "kernel32.dll", "GetFileAttributesA", 公开, 文件_取属性
    .参数 文件名, 文本型

.DLL命令 EnumProcesses, 逻辑型, "Psapi.dll", "EnumProcesses", 公开
    .参数 lpidProcess, 整数型
    .参数 cb, 整数型
    .参数 lpcbNeeded, 整数型, 传址

.DLL命令 GetNetworkParams, 整数型, "IPHLPAPI.DLL", "GetNetworkParams", 公开, 系统_取网络主机名
    .参数 pFixedInfo
    .参数 pOutBufLen, 整数型, 传址

.DLL命令 PathFindFileName, 文本型, "shlwapi.dll", "PathFindFileNameA"
    .参数 pszPath, 文本型

.DLL命令 GetPriorityClass, 整数型, "kernel32.dll", "GetPriorityClass", , 进程_取优先级
    .参数 hProcess, 整数型

.DLL命令 SetPriorityClass, 逻辑型, "kernel32.dll", "SetPriorityClass", , 进程_置优先级
    .参数 hProcess, 整数型
    .参数 dwPriorityClass, 整数型

.DLL命令 GetActiveWindow, 整数型, "user32.dll", "GetActiveWindow", , 窗口_取激活句柄

.DLL命令 GetProcessHandleCount, 逻辑型, "Kernel32.dll", "GetProcessHandleCount", , 进程_取句柄数
    .参数 hProcess
    .参数 pdwHandleCount, , 传址

.DLL命令 GetProcessIoCounters, 逻辑型, "kernel32.dll", "GetProcessIoCounters", , 进程_取IO写入计数  进程_取IO写入字节 
    .参数 hProcess, 整数型
    .参数 lpIoCounters, IO_COUNTERS

.DLL命令 CopyMemory_Bytes2int, 整数型, "kernel32.dll", "RtlMoveMemory", 公开, 内存拷贝
    .参数 Destination, 整数型
    .参数 字节集指针, 字节集
    .参数 数据长度, 整数型

.DLL命令 WinHelpA, 整数型, "user32.dll", "WinHelpA", 公开, 系统_调用帮助
    .参数 窗口句柄, 整数型, , hwnd
    .参数 帮助文件, 文本型, , lpHelpFile
    .参数 命令, 整数型, , wCommand
    .参数 数据, 整数型, , dwData

.DLL命令 GetMessageA, 逻辑型, "user32.dll", "GetMessageA", 公开
    .参数 lpMsg, MSG
    .参数 hwnd, 整数型
    .参数 wMsgFilterMin, 整数型
    .参数 wMsgFilterMax, 整数型

.DLL命令 GetEnvironmentVariable, 整数型, "kernel32.dll", "GetEnvironmentVariableA", 公开, 类_环境存取->读环境变量
    .参数 lpName, 文本型
    .参数 lpBuffer, 文本型
    .参数 nSize, 整数型

.DLL命令 GetEnvironmentVariableW, 整数型, "kernel32.dll", "GetEnvironmentVariableW"
    .参数 lpName, 字节集, , 0
    .参数 lpBuffer, 字节集, , 0
    .参数 nSize, 整数型, , 0

.DLL命令 SetEnvironmentVariable, 逻辑型, "kernel32.dll", "SetEnvironmentVariableA", 公开, 类_环境存取->写环境变量
    .参数 lpName, 文本型
    .参数 lpValue, 文本型

.DLL命令 GetEnvironmentStrings, 整数型, "kernel32.dll", "GetEnvironmentStringsA"

.DLL命令 CopyMemory_objcet2int, 整数型, "kernel32.dll", "RtlMoveMemory", 公开
    .参数 Destination, 整数型, 传址
    .参数 Source, 对象
    .参数 Length, 整数型

.DLL命令 lstrcat_int2variant, 整数型, "kernel32.dll", "lstrcatA", 公开
    .参数 lpString1, 变体型, 传址
    .参数 lpString2, 整数型, 传址

.DLL命令 GetCurrentDirectory, 整数型, "kernel32.dll", "GetCurrentDirectoryA", 公开
    .参数 nBufferLength, 整数型
    .参数 lpBuffer, 文本型

.DLL命令 GetCurrentDirectoryW, 整数型, "Kernel32.dll", "GetCurrentDirectoryW"
    .参数 nBufferLength, 整数型
    .参数 lpBuffer, 整数型

.DLL命令 CopyMemory_int2minmaxinfo, 整数型, "kernel32.dll", "RtlMoveMemory"
    .参数 Destination, MINMAXINFO
    .参数 Source, 整数型
    .参数 Length, 整数型

.DLL命令 CopyMemory_minmaxinfo2int, 整数型, "kernel32.dll", "RtlMoveMemory"
    .参数 Destination, 整数型
    .参数 Source, MINMAXINFO
    .参数 Length, 整数型

.DLL命令 MD5Init, , "Cryptdll.dll", "MD5Init"
    .参数 context, MD5_CTX

.DLL命令 MD5Update, , "Cryptdll.dll", "MD5Update"
    .参数 context, MD5_CTX
    .参数 input, 整数型
    .参数 inlen, 整数型

.DLL命令 MD5Update_bin, , "Cryptdll.dll", "MD5Update"
    .参数 context, MD5_CTX
    .参数 input, 字节集
    .参数 inlen, 整数型

.DLL命令 MD5Final, , "Cryptdll.dll", "MD5Final"
    .参数 context, MD5_CTX

.DLL命令 WinHttpCrackUrl, 逻辑型, "Winhttp.dll", "WinHttpCrackUrl", 公开
    .参数 pwszUrl, 字节集
    .参数 dwUrlLength
    .参数 dwFlags
    .参数 lpUrlComponents, URL_COMPONENTS

.DLL命令 MessageBoxTimeoutA, 整数型, "user32.dll", "MessageBoxTimeoutA", 公开, 系统_信息框Ex
    .参数 hwnd, 整数型, , 父窗口句柄
    .参数 lpText, 文本型, , 文本
    .参数 lpCaption, 文本型, , 标题
    .参数 wtype, 整数型, , 按钮类型
    .参数 wlange, 整数型
    .参数 dwtimeout, 整数型, , 毫秒

.DLL命令 IsDBCSLeadByteEx, 逻辑型, "kernel32.dll", "IsDBCSLeadByteEx"
    .参数 CodePage, 整数型
    .参数 TestChar, 字节型

.DLL命令 IsCharAlpha, 逻辑型, "user32.dll", "IsCharAlphaA"
    .参数 cChar, 字节型

.DLL命令 MulDiv, 整数型, "kernel32.dll", "MulDiv", , 通用对话框控件->选择字体
    .参数 nNumber, 整数型
    .参数 nNumerator, 整数型
    .参数 nDenominator, 整数型

.DLL命令 CopyMemory_logfont2int, 整数型, "kernel32.dll", "RtlMoveMemory", , 对话框_选择字体
    .参数 目标数据地址, 整数型
    .参数 源数据, LOGFONT
    .参数 尺寸, 整数型

.DLL命令 ChooseFont, 逻辑型, "comdlg32.dll", "ChooseFontA", , 对话框_选择字体
    .参数 pChoosefont, CHOOSEFONT

.DLL命令 CopyMemory_int2logfont, 整数型, "kernel32.dll", "RtlMoveMemory", , 对话框_选择字体
    .参数 目的地址, LOGFONT, ,  
    .参数 源地址, 整数型, ,  
    .参数 复制尺寸, 整数型

.DLL命令 CreateTimerQueueTimer, 逻辑型, "kernel32.dll", "CreateTimerQueueTimer", 公开, 控件_时钟
    .参数 phNewTimer, 整数型, 传址
    .参数 TimerQueue, 整数型
    .参数 Callback, 整数型, , 时钟回调
    .参数 Parameter, 整数型, , 传递给时钟回调的参数
    .参数 DueTime, 整数型, , 首次触发时钟的延时
    .参数 Period, 整数型, , 时钟周期
    .参数 Flags, 整数型

.DLL命令 CreateTimerQueue, 整数型, "kernel32.dll", "CreateTimerQueue", 公开, 控件_时钟

.DLL命令 DeleteTimerQueueTimer, 逻辑型, "kernel32.dll", "DeleteTimerQueueTimer", 公开, 控件_时钟
    .参数 TimerQueue, 整数型
    .参数 Timer, 整数型
    .参数 CompletionEvent, 整数型

.DLL命令 DeleteTimerQueue, 逻辑型, "kernel32.dll", "DeleteTimerQueue", 公开, 控件_时钟
    .参数 TimerQueue, 整数型

.DLL命令 ChangeTimerQueueTimer, 逻辑型, "kernel32.dll", "ChangeTimerQueueTimer", 公开, 控件_时钟
    .参数 TimerQueue, 整数型
    .参数 Timer, 整数型
    .参数 DueTime, 整数型
    .参数 Period, 整数型

.DLL命令 PathIsURL, 逻辑型, "shlwapi.dll", "PathIsURLA", 公开
    .参数 pszPath, 文本型

.DLL命令 CryptDeriveKey, 逻辑型, "advapi32.dll", "CryptDeriveKey"
    .参数 hProv, 整数型
    .参数 Algid, 整数型
    .参数 hBaseData, 整数型
    .参数 dwFlags, 整数型
    .参数 phKey, 整数型, 传址

.DLL命令 CryptEncrypt, 逻辑型, "advapi32.dll", "CryptEncrypt", ,  
    .参数 hKey, 整数型
    .参数 hHash, 整数型
    .参数 Final, 整数型
    .参数 dwFlags, 整数型
    .参数 pbData, 字节集
    .参数 pdwDataLen, 整数型, 传址
    .参数 dwBufLen, 整数型

.DLL命令 CryptDestroyKey, 逻辑型, "advapi32.dll", "CryptDestroyKey", ,  
    .参数 hKey, 整数型

.DLL命令 CryptDecrypt, 逻辑型, "advapi32.dll", "CryptDecrypt", ,  
    .参数 hKey, 整数型
    .参数 hHash, 整数型
    .参数 Final, 整数型
    .参数 dwFlags, 整数型
    .参数 pbData, 字节集
    .参数 pdwDataLen, 整数型, 传址

.DLL命令 CopyMemory_IconDirEntry, 整数型, "kernel32.dll", "RtlMoveMemory"
    .参数 Destination, IconDirEntry
    .参数 Source, 字节集
    .参数 cbCopy, 整数型

.DLL命令 CreateIconFromResource, 整数型, "user32.dll", "CreateIconFromResource"
    .参数 presbits, 字节集
    .参数 dwResSize
    .参数 fIcon, 逻辑型
    .参数 dwVer

.DLL命令 Shell_NotifyIcon, 逻辑型, "shell32.dll", "Shell_NotifyIconA", 公开
    .参数 dwMessage, 整数型
    .参数 lpData, NOTIFYICONDATA

.DLL命令 GetTopWindow, 整数型, "user32.dll", "GetTopWindow", 公开
    .参数 hwnd, 整数型

.DLL命令 GetNextWindow, 整数型, "user32.dll", "GetWindow", 公开
    .参数 hwnd, 整数型
    .参数 wFlag, 整数型

.DLL命令 GetWindowTextLengthA, 整数型, "user32.dll", "GetWindowTextLengthA", 公开
    .参数 hwnd, 整数型

.DLL命令 GetWindowTextLengthW, 整数型, "user32.dll", "GetWindowTextLengthW", 公开
    .参数 hwnd, 整数型

.DLL命令 AttachThreadInput, 逻辑型, "user32.dll", "AttachThreadInput", 公开
    .参数 idAttach, 整数型
    .参数 idAttachTo, 整数型
    .参数 fAttach, 逻辑型

.DLL命令 Thread32First, 逻辑型, "KERNEL32.DLL", "Thread32First", 公开
    .参数 hSnapshot, 整数型
    .参数 lpte, 线程入口结构

.DLL命令 gethostbyaddr, 整数型, "wsock32.dll", "gethostbyaddr", 公开
    .参数 addr, 整数型, 传址
    .参数 len, 整数型, 传址
    .参数 type, 整数型, 传址

.DLL命令 CopyMemory_int2hostent, 整数型, "kernel32.dll", "RtlMoveMemory", 公开
    .参数 目标数据地址, hostent
    .参数 源数据, 整数型
    .参数 尺寸, 整数型

.DLL命令 IcmpCreateFile, 整数型, "iphlpapi.dll", "IcmpCreateFile", 公开

.DLL命令 IcmpSendEcho, 整数型, "ICMP.DLL", "IcmpSendEcho", 公开
    .参数 IcmpHandle, 整数型
    .参数 DestinationAddress, 整数型
    .参数 RequestData, 文本型
    .参数 RequestSize, 短整数型
    .参数 RequestOptions, 整数型
    .参数 ReplyBuffer, ICMP_ECHO_REPLY
    .参数 ReplySize, 整数型
    .参数 Timeout, 整数型

.DLL命令 IcmpCloseHandle, 整数型, "ICMP.DLL", "IcmpCloseHandle", 公开
    .参数 IcmpHandle, 整数型

.DLL命令 waveOutGetDevCaps, 整数型, "winmm.dll", "waveOutGetDevCapsA"
    .参数 uDeviceID, 整数型
    .参数 lpCaps, WAVEOUTCAPS
    .参数 uSize, 整数型

.DLL命令 SysFreeString, 整数型, "oleaut32.dll", "SysFreeString"
    .参数 bstr

.DLL命令 WinHttpCheckPlatform, 逻辑型, "Winhttp.dll", "WinHttpCheckPlatform", 公开, BOOL WinHttpCheckPlatform(void);

.DLL命令 WinHttpOpen, 整数型, "Winhttp.dll", "WinHttpOpen", 公开, HINTERNET WINAPI WinHttpOpen
    .参数 pwszUserAgent, 整数型, , __in_opt  LPCWSTR pwszUserAgent
    .参数 dwAccessType, 整数型, , __in      DWORD dwAccessType
    .参数 pwszProxyName, 字节集, , __in      LPCWSTR pwszProxyName
    .参数 pwszProxyBypass, 整数型, , __in      LPCWSTR pwszProxyBypass
    .参数 dwFlags, 整数型, , __in      DWORD dwFlags

.DLL命令 WinHttpConnect, 整数型, "Winhttp.dll", "WinHttpConnect", 公开, HINTERNET WINAPI WinHttpConnect
    .参数 hSession, 整数型, , __in        HINTERNET hSession
    .参数 pswzServerName, 字节集, , __in        LPCWSTR pswzServerName
    .参数 nServerPort, 整数型, , __in        INTERNET_PORT nServerPort
    .参数 dwReserved, 整数型, , __reserved  DWORD dwReserved

.DLL命令 WinHttpOpenRequest, 整数型, "Winhttp.dll", "WinHttpOpenRequest", 公开, HINTERNET WINAPI WinHttpOpenRequest
    .参数 hConnect, 整数型, , __in  HINTERNET hConnect
    .参数 pwszVerb, 字节集, , __in  LPCWSTR pwszVerb
    .参数 pwszObjectName, 字节集, , __in  LPCWSTR pwszObjectName
    .参数 pwszVersion, , , __in  LPCWSTR pwszVersion
    .参数 pwszReferrer, 整数型, , __in  LPCWSTR pwszReferrer
    .参数 ppwszAcceptTypes, 整数型, , __in  LPCWSTR *ppwszAcceptTypes
    .参数 dwFlags, 整数型, , __in  DWORD dwFlags

.DLL命令 WinHttpCloseHandle, 逻辑型, "Winhttp.dll", "WinHttpCloseHandle", 公开, BOOL WINAPI WinHttpCloseHandle
    .参数 hInternet, 整数型, , __in  HINTERNET hInternet

.DLL命令 WinHttpSetTimeouts, 逻辑型, "Winhttp.dll", "WinHttpSetTimeouts", 公开, BOOL WINAPI WinHttpSetTimeouts
    .参数 hInternet, 整数型, , __in  HINTERNET hInternet
    .参数 dwResolveTimeout, 整数型, , __in  int dwResolveTimeout
    .参数 dwConnectTimeout, 整数型, , __in  int dwConnectTimeout
    .参数 dwSendTimeout, 整数型, , __in  int dwSendTimeout
    .参数 dwReceiveTimeout, 整数型, , __in  int dwReceiveTimeout

.DLL命令 WinHttpSetCredentials, 逻辑型, "Winhttp.dll", "WinHttpSetCredentials", , BOOL WINAPI WinHttpSetCredentials
    .参数 hRequest, 整数型, , __in        HINTERNET hRequest
    .参数 AuthTargets, 整数型, , __in        DWORD AuthTargets
    .参数 AuthScheme, 整数型, , __in        DWORD AuthScheme
    .参数 pwszUserName, 字节集, , __in        LPCWSTR pwszUserName
    .参数 pwszPassword, 字节集, , __in        LPCWSTR pwszPassword
    .参数 pAuthParams, 整数型, , __reserved  LPVOID pAuthParams

.DLL命令 WinHttpSetOption, 逻辑型, "Winhttp.dll", "WinHttpSetOption", 公开, BOOL WINAPI WinHttpSetOption
    .参数 hInternet, 整数型, , __in  HINTERNET hInternet
    .参数 dwOption, 整数型, , __in  DWORD dwOption
    .参数 lpBuffer, 整数型, 传址, __in  LPVOID lpBuffer
    .参数 dwBufferLength, 整数型, , __in  DWORD dwBufferLength

.DLL命令 WinHttpAddRequestHeaders, 逻辑型, "Winhttp.dll", "WinHttpAddRequestHeaders", 公开, BOOL WINAPI WinHttpAddRequestHeaders
    .参数 hRequest, 整数型, , __in  HINTERNET hRequest
    .参数 pwszHeaders, 字节集, , __in  LPCWSTR pwszHeaders
    .参数 dwHeadersLength, 整数型, , __in  DWORD dwHeadersLength
    .参数 dwModifiers, 整数型, , __in  DWORD dwModifiers

.DLL命令 WinHttpSendRequest, 逻辑型, "Winhttp.dll", "WinHttpSendRequest", 公开, BOOL WINAPI WinHttpSendRequest
    .参数 hRequest, 整数型, , __in      HINTERNET hRequest
    .参数 pwszHeaders, 整数型, , __in_opt  LPCWSTR pwszHeaders
    .参数 dwHeadersLength, 整数型, , __in      DWORD dwHeadersLength
    .参数 lpOptional, 字节集, , __in_opt  LPVOID lpOptional
    .参数 dwOptionalLength, 整数型, , __in      DWORD dwOptionalLength
    .参数 dwTotalLength, 整数型, , __in      DWORD dwTotalLength
    .参数 dwContext, 整数型, , __in      DWORD_PTR dwContext

.DLL命令 WinHttpReceiveResponse, 逻辑型, "Winhttp.dll", "WinHttpReceiveResponse", 公开, BOOL WINAPI WinHttpReceiveResponse
    .参数 hRequest, 整数型, , __in        HINTERNET hRequest
    .参数 lpReserved, 整数型, , __reserved  LPVOID lpReserved

.DLL命令 WinHttpQueryDataAvailable, 逻辑型, "Winhttp.dll", "WinHttpQueryDataAvailable", 公开, 查询是否有可读数据
    .参数 hRequest, 整数型, , 请求句柄
    .参数 lpdwNumberOfBytesAvailable, 整数型, 传址, 可读数据长度

.DLL命令 WinHttpReadData, 逻辑型, "Winhttp.dll", "WinHttpReadData", 公开, BOOL WINAPI WinHttpReadData
    .参数 hRequest, 整数型, , __in   HINTERNET hRequest
    .参数 lpBuffer, 字节集, , __out  LPVOID lpBuffer
    .参数 dwNumberOfBytesToRead, 整数型, , __in   DWORD dwNumberOfBytesToRead
    .参数 lpdwNumberOfBytesRead, 整数型, 传址, __out  LPDWORD lpdwNumberOfBytesRead

.DLL命令 WinHttpQueryHeaders, 逻辑型, "Winhttp.dll", "WinHttpQueryHeaders", 公开, BOOL WINAPI WinHttpQueryHeaders
    .参数 hRequest, 整数型, , __in      HINTERNET hRequest
    .参数 dwInfoLevel, 整数型, , __in      DWORD dwInfoLevel
    .参数 pwszName, 整数型, , __in_opt  LPCWSTR pwszName
    .参数 lpBuffer, 字节集, , __out     LPVOID lpBuffer
    .参数 lpdwBufferLength, 整数型, 传址, __inout   LPDWORD lpdwBufferLength
    .参数 lpdwIndex, 整数型, 传址, __inout   LPDWORD lpdwIndex

.DLL命令 GetCalendarInfo, 整数型, "kernel32.dll", "GetCalendarInfoA", 公开
    .参数 Locale, 整数型
    .参数 Calendar, 整数型
    .参数 CalType, 整数型
    .参数 lpCalData, 文本型
    .参数 cchData, 整数型, 传址
    .参数 lpValue, 整数型

.DLL命令 GetCompressedFileSize, 整数型, "kernel32.dll", "GetCompressedFileSizeA", 公开
    .参数 lpFileName, 文本型
    .参数 lpFileSizeHigh, 整数型, 传址

.DLL命令 RtlGetNtProductType, 逻辑型, "ntdll.dll", "RtlGetNtProductType", 公开, 系统_取系统版本
    .参数 wProductType, , 传址

.DLL命令 RtlGetProductInfo, 整数型, "ntdll.dll", "RtlGetProductInfo", 公开, 系统_取系统版本，不支持XP
    .参数 dwOSMajorVersion
    .参数 dwOSMinorVersion
    .参数 dwSpMajorVersion
    .参数 dwSpMinorVersion
    .参数 pdwReturnedProductType, , 传址

.DLL命令 RtlGetNtVersionNumbers, 整数型, "ntdll.dll", "RtlGetNtVersionNumbers", 公开, 系统_取系统版本
    .参数 major, , 传址
    .参数 minor, , 传址
    .参数 build, 短整数型, 传址

.DLL命令 InternetQueryOption, 逻辑型, "wininet.dll", "InternetQueryOptionA", 公开
    .参数 hInternet, 整数型
    .参数 dwOption, 整数型
    .参数 lpBuffer, 整数型
    .参数 lpdwBufferLength, 整数型, 传址

.DLL命令 RegQueryInfoKey, 整数型, "advapi32.dll", "RegQueryInfoKeyA", , 注册表_取子项数  注册表_取修改时间
    .参数 hKey, 整数型
    .参数 lpClass, 文本型
    .参数 lpcbClass, 文本型
    .参数 lpReserved, 整数型
    .参数 lpcSubKeys, 整数型, 传址
    .参数 lpcbMaxSubKeyLen, 整数型, 传址
    .参数 lpcbMaxClassLen, 整数型, 传址
    .参数 lpcValues, 整数型, 传址
    .参数 lpcbMaxValueNameLen, 整数型, 传址
    .参数 lpcbMaxValueLen, 整数型, 传址
    .参数 lpcbSecurityDescriptor, 整数型, 传址
    .参数 lpftLastWriteTime, FILETIME

.DLL命令 CopyMemory_system_process_information, 整数型, "kernel32.dll", "RtlMoveMemory"
    .参数 pDest, SYSTEM_PROCESS_INFORMATION
    .参数 pSrc, 整数型
    .参数 ByteLen, 整数型

.DLL命令 CreateMailslot, 整数型, "kernel32.dll", "CreateMailslotA", , 邮槽服务端->创建
    .参数 lpName, 文本型
    .参数 nMaxMessageSize, 整数型
    .参数 lReadTimeout, 整数型
    .参数 lpSecurityAttributes

.DLL命令 GetMailslotInfo, 逻辑型, "kernel32.dll", "GetMailslotInfo", , 邮槽服务端->读数据
    .参数 hMailslot, 整数型
    .参数 lpMaxMessageSize, 整数型, 传址
    .参数 lpNextSize, 整数型, 传址
    .参数 lpMessageCount, 整数型, 传址
    .参数 lpReadTimeout, 整数型, 传址

.DLL命令 ReadFile_字节集, 逻辑型, "kernel32.dll", "ReadFile", 公开
    .参数 hFile, 整数型
    .参数 lpBuffer, 字节集
    .参数 nNumberOfBytesToRead, 整数型
    .参数 lpNumberOfBytesRead, 整数型, 传址
    .参数 lpOverlapped, 整数型

.DLL命令 ReadFile_整数型, 逻辑型, "kernel32.dll", "ReadFile"
    .参数 hFile, 整数型
    .参数 lpBuffer, 整数型
    .参数 nNumberOfBytesToRead, 整数型
    .参数 lpNumberOfBytesRead, 整数型, 传址
    .参数 lpOverlapped, 整数型

.DLL命令 HeapFree, 整数型, "kernel32.dll", "HeapFree"
    .参数 hHeap, 整数型
    .参数 dwFlags, 整数型
    .参数 lpMem, 整数型

.DLL命令 VariantTimeToSystemTime, 整数型, "oleaut32.dll", "VariantTimeToSystemTime"
    .参数 vtime, 日期时间型
    .参数 lpSystemTime, 精易_时间

.DLL命令 SetThreadAffinityMask, 整数型, "kernel32.dll", "SetThreadAffinityMask"
    .参数 hThread, 整数型
    .参数 dwThreadAffinityMask, 整数型

.DLL命令 IsNTAdmin, 逻辑型, "advpack.dll", "IsNTAdmin"
    .参数 dwReserved, 整数型
    .参数 lpdwReserved, 整数型, 传址

.DLL命令 CryptBinaryToStringA, 逻辑型, "Crypt32.dll", "CryptBinaryToStringA", , 编码_BASE64编码A
    .参数 pbBinary, 字节集, , 需要转换的数据
    .参数 cbBinary, 整数型, , 数据长度
    .参数 dwFlags, 整数型, , 解码标志
    .参数 pszString, 整数型, , 数据缓存
    .参数 pcchString, 整数型, 传址, 返回长度

.DLL命令 CryptStringToBinaryA, 逻辑型, "Crypt32.dll", "CryptStringToBinaryA", , 编码_BASE64解码A
    .参数 pszString, 字节集, , 需要转换的数据
    .参数 cchString, 整数型, , 数据长度
    .参数 dwFlags, 整数型, , 编码标志
    .参数 pbBinary, 整数型, , 数据缓存
    .参数 pcbBinary, 整数型, 传址, 返回长度
    .参数 pdwSkip, 整数型
    .参数 pdwFlags, 整数型

.DLL命令 EnumProcessModulesEx, 逻辑型, "psapi.dll", "EnumProcessModulesEx", , 窗口_句柄取文件路径
    .参数 hProcess, 整数型
    .参数 lphModule, 整数型
    .参数 cb, 整数型
    .参数 lpcbNeeded, 整数型, 传址
    .参数 dwFilterFlag, 整数型

.DLL命令 InternetCheckConnection, 逻辑型, "wininet.dll", "InternetCheckConnectionA", , 系统_是否已联网
    .参数 lpszUrl, 文本型
    .参数 dwFlags, 整数型
    .参数 dwReserved, 整数型

.DLL命令 CopyMemory_QUERY_SERVICE_CONFIG, 整数型, "kernel32.dll", "RtlMoveMemory", , 系统服务_枚举系统服务
    .参数 目标数据地址, QUERY_SERVICE_CONFIG, , lpvDest
    .参数 源数据, 整数型, , lpvSource
    .参数 尺寸, 整数型, , cbCopy

.DLL命令 EnumServicesStatus, 逻辑型, "advapi32.dll", "EnumServicesStatusA", , 系统服务_枚举系统服务
    .参数 SC管理者句柄, 整数型, , hSCManager
    .参数 服务类型, 整数型, , dwServiceType
    .参数 服务状态, 整数型, , dwServiceState
    .参数 服务, , , any，lpServices
    .参数 缓冲区大小, 整数型, , cbBufSize
    .参数 需求字节数, 整数型, 传址, pcbBytesNeeded
    .参数 返回服务名, 整数型, 传址, lpServicesReturned
    .参数 返回句柄, 整数型, , lpResumeHandle

.DLL命令 EnumServicesStatusEx, 逻辑型, "ADVAPI32.DLL", "EnumServicesStatusExA"
    .参数 hSCManager, 整数型
    .参数 InfoLevel
    .参数 dwServiceType, 整数型
    .参数 dwServiceState, 整数型
    .参数 lpServices
    .参数 cbBufSize, 整数型
    .参数 pcbBytesNeeded, 整数型, 传址
    .参数 lpServicesReturned, 整数型, 传址
    .参数 lpResumeHandle, 整数型
    .参数 pszGroupName, 文本型

.DLL命令 CopyMemory_enum_service_status_process, 整数型, "kernel32.dll", "RtlMoveMemory"
    .参数 目标数据地址, ENUM_SERVICE_STATUS_PROCESS
    .参数 源数据, 字节集
    .参数 尺寸, 整数型

.DLL命令 EnumDependentServices, 逻辑型, "advapi32.dll", "EnumDependentServicesA"
    .参数 hService, 整数型
    .参数 dwServiceState, 整数型
    .参数 lpServices
    .参数 cbBufSize, 整数型
    .参数 pcbBytesNeeded, 整数型, 传址
    .参数 lpServicesReturned, 整数型, 传址

.DLL命令 CopyMemory_ENUM_SERVICE_STATUS, 整数型, "kernel32.dll", "RtlMoveMemory", , 系统服务_枚举系统服务
    .参数 目标数据地址, ENUM_SERVICE_STATUS, , lpvDest
    .参数 源数据, 字节集, , lpvSource
    .参数 尺寸, 整数型, , cbCopy

.DLL命令 AllocConsole, 逻辑型, "kernel32.dll", "AllocConsole"

.DLL命令 GetStdHandle, 整数型, "kernel32.dll", "GetStdHandle"
    .参数 nStdHandle, 整数型

.DLL命令 SetConsoleTitleA, 逻辑型, "kernel32.dll", "SetConsoleTitleA"
    .参数 lpConsoleTitle, 文本型

.DLL命令 SetConsoleTextAttribute, 逻辑型, "kernel32.dll", "SetConsoleTextAttribute"
    .参数 hConsoleOutput, 整数型
    .参数 wAttributes, 整数型

.DLL命令 WriteConsoleA, 逻辑型, "kernel32.dll", "WriteConsoleA"
    .参数 hConsoleOutput, 整数型
    .参数 lpBuffer, 文本型
    .参数 nNumberOfCharsToWrite, 整数型
    .参数 lpNumberOfCharsWritten, 整数型
    .参数 lpReserved, 整数型

.DLL命令 OutputDebugStringA, , "kernel32.dll", "OutputDebugStringA"
    .参数 lpOutputString, 文本型

.DLL命令 FreeConsole, 整数型, "kernel32.dll", "FreeConsole"

.DLL命令 GdipGetImageWidth, 整数型, "gdiplus.dll", "GdipGetImageWidth", ,  
    .参数 image
    .参数 width, , 传址

.DLL命令 GdipGetImageHeight, 整数型, "gdiplus.dll", "GdipGetImageHeight", ,  
    .参数 image
    .参数 height, , 传址

.DLL命令 GetFileSizeEx, 逻辑型, "kernel32.dll", "GetFileSizeEx", , 取文件长度
    .参数 hFile, 整数型
    .参数 lpFileSizeHigh, 整数型

.DLL命令 _lopen, 整数型, "kernel32.dll", "_lopen", , 打开文件
    .参数 lpPathName, 文本型
    .参数 iReadWrite, 整数型

.DLL命令 _lclose, 整数型, "kernel32.dll", "_lclose", , 文件_取尺寸
    .参数 文件句柄, 整数型

.DLL命令 StrFormatByteSize64A, 整数型, "shlwapi.dll", "StrFormatByteSize64A", , 文件_格式化字节Ex
    .参数 数值, 长整数型, , qdw
    .参数 文本缓冲区, 文本型, , szBuf
    .参数 文本缓冲区大小, 整数型, , uiBufSize

.DLL命令 CopyMemory_LongLongToFiletime, 整数型, "kernel32.dll", "RtlMoveMemory"
    .参数 pDest, FILETIME
    .参数 pSrc, 长整数型, 传址
    .参数 ByteLen, 整数型

.DLL命令 SQLBrowseConnect, 整数型, "odbc32.dll", "SQLBrowseConnect"
    .参数 hdbc, 整数型
    .参数 szConnStrIn, 文本型
    .参数 cbConnStrIn, 短整数型
    .参数 szConnStrOut, 文本型
    .参数 cbConnStrOutMax, 短整数型
    .参数 pcbConnStrOut, 短整数型, 传址

.DLL命令 ImmConfigureIME, 逻辑型, "imm32.dll", "ImmConfigureIMEA"
    .参数 hkl, 整数型
    .参数 hwnd, 整数型
    .参数 dwMode, 整数型
    .参数 lpData

.DLL命令 CopyMemory_SERVICE_DESCRIPTION, 整数型, "kernel32.dll", "RtlMoveMemory"
    .参数 目标数据地址, SERVICE_DESCRIPTION, , lpvDest
    .参数 源数据, 整数型, , lpvSource
    .参数 尺寸, 整数型, , cbCopy

.DLL命令 GetFileVersionInfoSize, 整数型, "version.dll", "GetFileVersionInfoSizeA"
    .参数 文件路径, 文本型
    .参数 保留, 整数型

.DLL命令 GetFileVersionInfo, 逻辑型, "version.dll", "GetFileVersionInfoA"
    .参数 文件路径, 文本型
    .参数 保留, 整数型
    .参数 缓冲区长度, 整数型, , 通过GetFileVersionInfoSize获取的长度
    .参数 数据, 字节集, 传址

.DLL命令 VerQueryValue_x, 整数型, "VERSION.DLL", "VerQueryValueA"
    .参数 内存块首区域位置, 字节集, 传址
    .参数 版本信息相对路径, 文本型, 传址
    .参数 装载缓冲变量, 整数型, 传址
    .参数 缓冲变量长度, 整数型, 传址

.DLL命令 VerQueryValue, 逻辑型, "version.dll", "VerQueryValueA"
    .参数 pBlock, 字节集, 传址
    .参数 lpSubBlock, 文本型
    .参数 lplpBuffer, 整数型, 传址
    .参数 puLen, 整数型, 传址

.DLL命令 lstrcpy, 整数型, "Kernel32.dll", "lstrcpyA"
    .参数 lpString1, 文本型
    .参数 lpString2, 整数型

.DLL命令 GetProcessMemoryInfo, 整数型, "psapi.dll", "GetProcessMemoryInfo", , 取进程内存信息_
    .参数 Process, 整数型, , 进程句柄
    .参数 ppsmemCounters, 整数型, , 进程内存结构
    .参数 cb, 整数型, , 结构大小

.DLL命令 CreateSemaphore, 整数型, "kernel32.dll", "CreateSemaphoreA", 公开, 创建一个新的信号机  如执行成功，返回信号机对象的句柄；零表示出错。会设置GetLastError。即使返回一个有效的句柄，但倘若它指出同名的一个信号机已经存在，那么GetLastError也会返回ERROR_ALREADY_EXISTS
    .参数 信号量安全特性, 整数型, , 安全结构。默认可不写，留0即可。
    .参数 信号量初始计数, 整数型, , 设置信号机的初始计数。
    .参数 信号量最大计数, 整数型, , 设置信号机的最大计数
    .参数 信号量对象的名称, 文本型, , 指定信号机对象的名称。名字是用作多进程同步的，一般不使用。

.DLL命令 OpenSemaphore, 整数型, "kernel32.dll", "OpenSemaphoreA", 公开, 打开命名信号量对象
    .参数 dwDesiredAccess, 整数型, , 权限,2031619
    .参数 是否继承, 逻辑型, , 是否继承句柄
    .参数 lpName, 文本型, , 名称

.DLL命令 ReleaseSemaphore, 逻辑型, "kernel32.dll", "ReleaseSemaphore", 公开, 释放信号量对象
    .参数 hSemaphore, 整数型, , 句柄
    .参数 lReleaseCount, 整数型, , 增加的数量
    .参数 lpPreviousCount, 整数型, 传址, 之前的数量

.DLL命令 COM_创建GUID_, 整数型, "ole32.dll", "CoCreateGuid", , CoCreateGuid
    .参数 GUID, GUID, 传址

.DLL命令 StringFromGUID, 整数型, "ole32.dll", "StringFromGUID2", , GUID到文本ID...把一个GUID转转成文本型.返回值如 {72C24DD5-D70A-438B-8A42-98424B88AFB8}
    .参数 GUID, GUID
    .参数 宽文, 字节集, , 宽文本型
    .参数 长度, 整数型

.DLL命令 GetDeviceCaps, 整数型, "gdi32.dll", "GetDeviceCaps", 公开, 获取系统DPI大小
    .参数 HDC, 整数型, , 0
    .参数 int, 整数型, , 0

.DLL命令 WaitForInputIdle, 整数型, "user32.dll", "WaitForInputIdle"
    .参数 hProcess, 整数型, , 0
    .参数 dwMilliseconds, 整数型, , 0

.DLL命令 GetDeviceGammaRamp, 逻辑型, "gdi32.dll", "GetDeviceGammaRamp"
    .参数 HDC, 整数型, , 0
    .参数 LPVOID, 整数型, , 0

.DLL命令 IsBadReadPtr, 逻辑型, "kernel32.dll", "IsBadReadPtr"
    .参数 lpMemory, 整数型, , 目标地址指针
    .参数 dwSize, 整数型, , 长度

.DLL命令 IsBadCodePtr, 逻辑型, "kernel32.dll", "IsBadCodePtr"
    .参数 lpMemory, 整数型, , 目标内存地址指针

.DLL命令 RtlMoveMemory_MOUSEHOOKSTRUCT, 整数型, "kernel32.dll", "RtlMoveMemory"
    .参数 Destination, MOUSEHOOKSTRUCT
    .参数 Source, 整数型
    .参数 cbCopy, 整数型

.DLL命令 GetInterfaceInfo, 整数型, "IPHLPAPI.DLL", "GetInterfaceInfo", , 　
    .参数 pIfTable, 整数型
    .参数 dwOutBufLen, 整数型, 传址

.DLL命令 LocalSize_IP_INTERFACE_INFO, 整数型, "kernel32.dll", "LocalSize", , 返回本地内存块大小,类似sizeof
    .参数 hMem, IP_INTERFACE_INFO, 传址

.DLL命令 LocalSize_IP_ADAPTER_INDEX_MAP, 整数型, "kernel32.dll", "LocalSize", , 返回本地内存块大小,类似sizeof
    .参数 hMem, IP_ADAPTER_INDEX_MAP, 传址

.DLL命令 CopyMemory_P2IP_INTERFACE_INFO, , "kernel32.dll", "RtlMoveMemory"
    .参数 pDest, IP_INTERFACE_INFO, 传址
    .参数 pSrc, 整数型
    .参数 ByteLen, 整数型

.DLL命令 CopyMemory_P2IP_ADAPTER_INDEX_MAP_Array, , "kernel32.dll", "RtlMoveMemory"
    .参数 pDest, IP_ADAPTER_INDEX_MAP, 传址 数组
    .参数 pSrc, 整数型
    .参数 ByteLen, 整数型

.DLL命令 LocalSize_IP_PER_ADAPTER_INFO, 整数型, "kernel32.dll", "LocalSize", , 返回本地内存块大小,类似sizeof
    .参数 hMem, IP_PER_ADAPTER_INFO_彗星, 传址

.DLL命令 CopyMemory_P2IP_PER_ADAPTER_INFO, , "kernel32.dll", "RtlMoveMemory"
    .参数 pDest, IP_PER_ADAPTER_INFO_彗星
    .参数 pSrc, 整数型
    .参数 ByteLen, 整数型

.DLL命令 GetPerAdapterInfo_Ptr, 整数型, "IPHLPAPI.DLL", "GetPerAdapterInfo", , 　
    .参数 IfIndex, 整数型
    .参数 pPerAdapterInfo, 整数型
    .参数 pOutBufLen, 整数型, 传址

.DLL命令 MprConfigGetFriendlyName, 整数型, "mprapi.dll", "MprConfigGetFriendlyName", , 　
    .参数 hMprConfig, 整数型
    .参数 pszGuidName, 字节集
    .参数 pszBuffer, 字节集
    .参数 dwBufferSize, 整数型

.DLL命令 MprConfigServerConnect, 整数型, "mprapi.dll", "MprConfigServerConnect", , 　
    .参数 lpwsServerName, 整数型
    .参数 phMprConfig, 整数型, 传址

.DLL命令 FormatMessageA, 整数型, "kernel32.dll", "FormatMessageA"
    .参数 dwFlags, 整数型
    .参数 lpSource, 整数型
    .参数 dwMessageId, 整数型
    .参数 dwLanguageId, 整数型
    .参数 lpBuffer, 整数型
    .参数 nSize, 整数型
    .参数 Arguments, 整数型

.DLL命令 SendMessageTimeoutW, 整数型, "user32.dll", "SendMessageTimeoutW", , 同步发送消息
    .参数 hWnd, 整数型, , 要接收消息的一个窗口的句柄
    .参数 Msg, 整数型, , 消息的标识符
    .参数 wParam, 整数型, , 消息1
    .参数 lParam, 整数型, , 消息2
    .参数 fuFlags, 整数型, , 下述常数的一个或多个SMTO_ABORTIFHUNG如目标进程挂起
    .参数 uTimeout, 整数型, , 超时值
    .参数 lpdwResult, 整数型, , 用于装载函数结果的一个变量

.DLL命令 lstrlenW, 整数型, "kernel32.dll", "lstrlenW"
    .参数 lpString, 整数型

.DLL命令 EnumClipboardFormats, 整数型, "user32.dll", "EnumClipboardFormats"
    .参数 format, 整数型

.DLL命令 GetClipboardFormatNameA, 整数型, "user32.dll", "GetClipboardFormatNameA", 公开
    .参数 iFormat, 整数型
    .参数 psBuffer, 文本型
    .参数 iMaxCount, 整数型

.DLL命令 RtlMoveMemory, 整数型, "kernel32.dll", "RtlMoveMemory", 公开
    .参数 Destination, 整数型
    .参数 Source, 整数型
    .参数 Length, 整数型

.DLL命令 DwmUpdateThumbnailProperties, 整数型, "Dwmapi.dll", "DwmUpdateThumbnailProperties", 公开, 更新桌面窗口管理器（DWM）缩略图的属性  返回0为成功
    .参数 HTHUMBNAIL, 整数型, , hThumbnailId  略缩图指针
    .参数 DWM_THUMBNAIL_PROPERTIES, 缩略图属性, , 略缩图属性

.DLL命令 DwmUnregisterThumbnail, 整数型, "Dwmapi.dll", "DwmUnregisterThumbnail", 公开, 删除由DwmRegisterThumbnail函数创建的桌面窗口管理器（DWM）缩略图关系
    .参数 HTHUMBNAIL, 整数型, , hThumbnailId 略缩图指针

.DLL命令 DwmSetIconicThumbnail, 整数型, "Dwmapi.dll", "DwmSetIconicThumbnail", 公开, 在窗口或选项卡上设置静态的图标位图，以用作缩略图表示。任务栏可以将此位图用作窗口或选项卡的缩略图切换目标
    .参数 HWND, 整数型
    .参数 HBITMAP, 整数型, , 位图句柄
    .参数 DWORD, 整数型, , 显示选项 0=无框架；1=有框架

.DLL命令 DwmRegisterThumbnail, 整数型, "Dwmapi.dll", "DwmRegisterThumbnail", 公开, 在目标窗口和源窗口之间创建桌面窗口管理器（DWM）缩略图关系
    .参数 HWND, 整数型, , hwndDestination
    .参数 HWND, 整数型, , hwndSource
    .参数 PHTHUMBNAIL, 整数型, 传址, phThumbnailId  略缩图指针

.DLL命令 DwmIsCompositionEnabled, 整数型, "Dwmapi.dll", "DwmIsCompositionEnabled", 公开, 获取一个值，该值指示是否启用了桌面窗口管理器（DWM）组合。运行Windows 7或更早版本的计算机上的应用程序可以通过处理WM_DWMCOMPOSITIONCHANGED通知来侦听组合状态更改。
    .参数 pfEnabled, 逻辑型, 传址, 指向一个值的指针，当该函数成功返回时，如果启用了DWM组合，则该值为TRUE ; 否则，FALSE。

.DLL命令 DwmEnableComposition, 整数型, "Dwmapi.dll", "DwmEnableComposition", 公开, 启用或禁用桌面窗口管理器（DWM）组合。
    .参数 uCompositionAction, 整数型

.DLL命令 DwmExtendFrameIntoClientArea, 整数型, "Dwmapi.dll", "DwmExtendFrameIntoClientArea", 公开, 将窗口框架扩展到客户端区域。
    .参数 hWnd, 整数型
    .参数 pMarInset, 精易_位置和大小, 传址

.DLL命令 CreateStreamOnHGlobal_Object, 整数型, "ole32.dll", "CreateStreamOnHGlobal"
    .参数 hGlobal, 整数型
    .参数 fDeleteOnRelease, 逻辑型
    .参数 ppstm, 对象, 传址

.DLL命令 GdipCreateBitmapFromScan0, 整数型, "GdiPlus.dll", "GdipCreateBitmapFromScan0"
    .参数 width, 整数型
    .参数 height, 整数型
    .参数 stride, 整数型
    .参数 format, 整数型
    .参数 scan0, 整数型
    .参数 bitmap, 整数型, 传址

.DLL命令 GdipCreateSolidFill, 整数型, "GdiPlus.dll", "GdipCreateSolidFill"
    .参数 color, 整数型
    .参数 brush, 整数型, 传址

.DLL命令 GdipDrawImageRectRect_NULL, 整数型, "GdiPlus.dll", "GdipDrawImageRectRect"
    .参数 graphics, 整数型
    .参数 image, 整数型
    .参数 dstx, 小数型
    .参数 dsty, 小数型
    .参数 dstwidth, 小数型
    .参数 dstheight, 小数型
    .参数 srcx, 小数型
    .参数 srcy, 小数型
    .参数 srcwidth, 小数型
    .参数 srcheight, 小数型
    .参数 srcUnit, 整数型
    .参数 imageAttributes, 整数型
    .参数 callback, 整数型
    .参数 callbackData, 整数型

.DLL命令 GdipFillRectangle, 整数型, "GdiPlus.dll", "GdipFillRectangle"
    .参数 graphics, 整数型
    .参数 brush, 整数型
    .参数 x, 小数型
    .参数 y, 小数型
    .参数 width, 小数型
    .参数 height, 小数型

.DLL命令 GdipGetImageGraphicsContext, 整数型, "GdiPlus.dll", "GdipGetImageGraphicsContext"
    .参数 image, 整数型
    .参数 graphics, 整数型, 传址

.DLL命令 GetObjectPtr, 整数型, "Kernel32.dll", "lstrcpyn"
    .参数 lpString1, 对象, 传址
    .参数 lpString2, 对象, 传址
    .参数 iMaxLength, 整数型

.DLL命令 DwmEnableBlurBehindWindow, 整数型, "Dwmapi.dll", "DwmEnableBlurBehindWindow", 公开, 在指定窗口上启用模糊效果。
    .参数 hWnd, 整数型
    .参数 pBlurBehind, 模糊属性, 传址

.DLL命令 GdipGetPropertyItemSize, 整数型, "gdiplus.dll", "GdipGetPropertyItemSize", 公开
    .参数 Image, 整数型
    .参数 propId, 整数型
    .参数 size, 整数型, 传址

.DLL命令 GdipGetPropertyItem, 整数型, "gdiplus.dll", "GdipGetPropertyItem", 公开
    .参数 Image, 整数型
    .参数 propId, 整数型
    .参数 propSize, 整数型
    .参数 buffer, 字节集

.DLL命令 GetScrollInfo, 整数型, "user32.dll", "GetScrollInfo", , 　
    .参数 hWnd, 整数型
    .参数 n, 整数型
    .参数 lpScrollInfo, SCROLLINFO

.DLL命令 LocalSize_SCROLLBARINFO, 整数型, "kernel32.dll", "LocalSize", , 返回本地内存块大小　
    .参数 hMem, SCROLLBARINFO

.DLL命令 GetScrollBarInfo, 整数型, "user32.dll", "GetScrollBarInfo", , 　
    .参数 hwnd, 整数型
    .参数 idObject, 整数型
    .参数 psbi, SCROLLBARINFO

.DLL命令 LocalSize_SCROLLINFO, 整数型, "kernel32.dll", "LocalSize", , 返回本地内存块大小　
    .参数 hMem, SCROLLINFO

.DLL命令 GetCaretPos, 整数型, "user32.dll", "GetCaretPos", 公开, 将插入标记的位置（按客户区坐标）信息拷贝到指定的POINT结构中
    .参数 IpPoint, 精易_坐标

.DLL命令 EnumDisplayMonitors, 整数型, "user32.dll", "EnumDisplayMonitors", 公开, ,
    .参数 hdc, 整数型
    .参数 lprcClip, 整数型
    .参数 lpfnEnum, 整数型
    .参数 dwData, 整数型

.DLL命令 ChangeClipboardChain, 逻辑型, "user32.dll", "ChangeClipboardChain", 公开, 从剪贴板查看器链中删除指定的窗口。
    .参数 hWndRemove, 整数型, , 要从链中移除的窗口的句柄。句柄必须已传递给SetClipboardViewer函数。
    .参数 hWndNewNext, 整数型, , 剪贴板查看器链中hWndRemove窗口后面的窗口句柄 。（这是SetClipboardViewer返回的句柄，除非响应WM_CHANGECBCHAIN消息更改了序列。）

.DLL命令 SetClipboardViewer, 整数型, "user32.dll", "SetClipboardViewer", 公开, 将指定的窗口添加到剪贴板查看器链。每当剪贴板的内容发生变化时，剪贴板查看器窗口将收到WM_DRAWCLIPBOARD消息。
    .参数 hWndNewViewer, 整数型, , 标识要添加到剪贴板链的窗口。

.DLL命令 GetClipboardViewer, 整数型, "user32.dll", "GetClipboardViewer", 公开, 检索剪贴板查看器链中第一个窗口的句柄。

.DLL命令 GetSystemTime, 整数型, "kernel32.dll", "GetSystemTime", , 获取当前系统时间
    .参数 lpSystemTime, 精易_时间, 传址

.DLL命令 SHGetFolderPathA, 整数型, "Shell32.dll", "SHGetFolderPathA", 公开
    .参数 hWnd, 整数型
    .参数 csidl, 整数型
    .参数 hToken, 整数型
    .参数 dwFlags, 整数型
    .参数 pszPath, 整数型

.DLL命令 GetComboBoxInfo, 逻辑型, "user32.dll", "GetComboBoxInfo", 公开, ,
    .参数 hwndCombo, 整数型, , 0
    .参数 pcbi, COMBOBOXINFO, , 0

.DLL命令 GetExtendedTcpTable, 整数型, "iphlpapi.dll", "GetExtendedTcpTable", , https://msdn.microsoft.com/en-us/library/aa365928.aspx
    .参数 pTcpTable, 整数型, , 指向表结构的指针，其中包含应用程序可用的已过滤TCP端点。有关如何确定基于特定输入参数组合返回的表的类型的信息，请参阅本文档后面的备注部分。
    .参数 pdwSize, 整数型, 传址, pTcpTable中返回的结构的估计大小（以字节为单位）。如果此值设置得太小，则此函数将返回ERROR_INSUFFICIENT_BUFFER，此字段将包含正确的结构大小。
    .参数 bOrder, 逻辑型, , 指定TCP连接表是否应该排序的值。如果此参数设置为TRUE，则表中的TCP端点按升序排列，从本地IP地址开始。如果此参数设置为FALSE，表中的TCP端点将按照它们被检索的顺序显示。
    .参数 ulAf, 整数型, , TCP端点使用的IP版本#AF_INET=使用IPv4。#AF_INET6=使用IPv6。
    .参数 TableClass, 整数型, , 要检索的TCP表结构的类型。此参数可以是TCP_TABLE_CLASS枚举中的值之一。
    .参数 Reserved, 整数型, , 保留。该值必须为零。

.DLL命令 GetExtendedUdpTable, 整数型, "iphlpapi.dll", "GetExtendedUdpTable", , https://msdn.microsoft.com/en-us/library/aa365930(v=vs.85).aspx
    .参数 pUdpTable, 整数型, , 指向表结构的指针，其中包含应用程序可用的已过滤TCP端点。有关如何确定基于特定输入参数组合返回的表的类型的信息，请参阅本文档后面的备注部分。
    .参数 pdwSize, 整数型, 传址, pTcpTable中返回的结构的估计大小（以字节为单位）。如果此值设置得太小，则此函数将返回ERROR_INSUFFICIENT_BUFFER，此字段将包含正确的结构大小。
    .参数 bOrder, 逻辑型, , 指定TCP连接表是否应该排序的值。如果此参数设置为TRUE，则表中的TCP端点按升序排列，从本地IP地址开始。如果此参数设置为FALSE，表中的TCP端点将按照它们被检索的顺序显示。
    .参数 ulAf, 整数型, , TCP端点使用的IP版本#AF_INET=使用IPv4。#AF_INET6=使用IPv6。
    .参数 TableClass, 整数型, , 要检索的TCP表结构的类型。此参数可以是TCP_TABLE_CLASS枚举中的值之一。
    .参数 Reserved, 整数型, , 保留。该值必须为零。

.DLL命令 IsTextUnicode, 逻辑型, "advapi32", "IsTextUnicode", , IsTextUnicode 函数是确定一个缓冲区是否可能包含 Unicode 文本，包含Unicode 文本返回真。
    .参数 lpv, 字节集, , 指向要检查的输入缓冲区
    .参数 iSize, 整数型, , 由lpv指向的缓冲区大小，以字节为单位。
    .参数 lpiResult, 整数型, 传址, 返回值，是Unicode 文本返回非零值，不是返回0

.DLL命令 PostThreadMessageA, 逻辑型, "user32.dll", "PostThreadMessageA"
    .参数 idThread, 整数型, , 0
    .参数 Msg, 整数型, , 0
    .参数 wParam, 整数型, , 0
    .参数 lParam, 整数型, , 0

.DLL命令 LoadCursorW, 整数型, "user32.dll", "LoadCursorW", , 该函数从一个与应用事例相关的可执行文件（EXE文件）中载入指定的光标资源。该函数已被Loadlmage函数替代。
    .参数 hInstance, 整数型, , 标识一个模块事例，它的可执行文件包含要载入的光标
    .参数 lpCursorName, 整数型, , 指向以NULL结束的字符串的指针，该字符串存有等载入的光标资源名。常量 #IDC_ 开头

.DLL命令 SetWindowCompositionAttribute, 逻辑型, "user32.dll", "SetWindowCompositionAttribute"
    .参数 hwnd, 整数型
    .参数 pAttrData, WINDOWCOMPOSITIONATTRIBDATA

.DLL命令 IsDBCSLeadByte, 逻辑型, "kernel32.dll", "IsDBCSLeadByte"
    .参数 TestChar, 字节型

.DLL命令 MprConfigServerDisconnect, , "Mprapi.dll", "MprConfigServerDisconnect"
    .参数 hMprConfig, 整数型, , 0

.DLL命令 DeviceIoControl_DESCRIPTOR, 逻辑型, "Kernel32.dll", "DeviceIoControl"
    .参数 Handle, 整数型
    .参数 dwIoControlCode, 整数型
    .参数 lpInBuffer, STORAGE_PROPERTY_QUERY, 传址
    .参数 nInBufferSize, 整数型
    .参数 lpOutBuffer, STORAGE_DEVICE_DESCRIPTOR, 传址
    .参数 nOutBufferSize, 整数型
    .参数 lpBytesReturned, 整数型, 传址
    .参数 lpOverlapped, 整数型

.DLL命令 Wow64DisableWow64FsRedirection, 逻辑型, "Kernel32.dll", "Wow64DisableWow64FsRedirection", , 禁用调用线程的文件系统重定向
    .参数 OldValue, 整数型

.DLL命令 Wow64RevertWow64FsRedirection, 逻辑型, "Kernel32.dll", "Wow64RevertWow64FsRedirection", , 恢复调用线程的文件系统重定向
    .参数 OldValue, 整数型

.DLL命令 malloc, 整数型, "msvcrt.dll", "@malloc"
    .参数 size, 整数型

.DLL命令 free, 整数型, "msvcrt.dll", "@free"
    .参数 ptr, 整数型

.DLL命令 _vsnprintf_s, 整数型, "msvcrt.dll", "@_vsnprintf_s"
    .参数 _Buffer, 整数型, , 缓冲区指针
    .参数 _BufferCount, 整数型, , 缓冲区长度
    .参数 _MaxCount, 整数型, , 缓冲区字符最大长度
    .参数 _Format, 整数型, , 格式化文本
    .参数 _ArgList, 整数型, , va_list

.DLL命令 _vsnwprintf_s, 整数型, "msvcrt.dll", "@_vsnwprintf_s"
    .参数 _Buffer, 整数型, , 缓冲区指针
    .参数 _BufferCount, 整数型, , 缓冲区长度
    .参数 _MaxCount, 整数型, , 缓冲区字符最大长度
    .参数 _Format, 整数型, , 格式化文本
    .参数 _ArgList, 整数型, , va_list

.DLL命令 CreateDirectoryW, 逻辑型, "Kernel32.dll", "CreateDirectoryW"
    .参数 bFolderName, 整数型
    .参数 lpSecurityAttributes, 整数型

.DLL命令 SetThreadExecutionState, 整数型, "kernel32.dll", "SetThreadExecutionState"
    .参数 esFlags, 整数型

.DLL命令 WTSRegisterSessionNotification, 逻辑型, "wtsapi32.dll", "WTSRegisterSessionNotification"
    .参数 hWnd, 整数型, , HWND
    .参数 dwFlags, 整数型, , DWORD #NOTIFY_FOR_*

.DLL命令 WTSUnRegisterSessionNotification, 逻辑型, "wtsapi32.dll", "WTSUnRegisterSessionNotification"
    .参数 hWnd, 整数型, , HWND

.DLL命令 GetSystemFirmwareTable, 整数型, "Kernel32.dll", "GetSystemFirmwareTable"
    .参数 FirmwareTableProviderSignature, 整数型
    .参数 FirmwareTableID, 整数型
    .参数 pFirmwareTableBuffer, 整数型
    .参数 BufferSize, 整数型

.DLL命令 NetUserEnum, 整数型, "Netapi32.dll", "NetUserEnum"
    .参数 servername, 整数型
    .参数 level, 整数型
    .参数 filter, 整数型
    .参数 bufptr, 整数型
    .参数 prefmaxlen, 整数型
    .参数 entriesread, 整数型, 传址
    .参数 totalentries, 整数型, 传址
    .参数 OPTIONAL, 整数型, 传址

.DLL命令 NetApiBufferFree, 整数型, "Netapi32.dll", "NetApiBufferFree"
    .参数 Buffer, 整数型

.DLL命令 GetProcessTimes, 逻辑型, "kernel32.dll", "GetProcessTimes"
    .参数 hProcess, 整数型
    .参数 lpCreationTime, FILETIME
    .参数 lpExitTime, FILETIME
    .参数 lpKernelTime, FILETIME
    .参数 lpUserTime, FILETIME

.DLL命令 SetThreadPriority, 逻辑型, "kernel32.dll", "SetThreadPriority", , 如果函数成功，返回值是非零的。如果函数失败，返回值为零。
    .参数 hThread, 整数型, , 一个要设置优先级值的线程的句柄。这个句柄必须有THREAD_SET_INFORMATION或THREAD_SET_LIMITED_INFORMATION的权限。
    .参数 nPriority, 整数型, , THREAD_MODE_BACKGROUND_BEGIN 0x00010000 开始后台处理模式系统降低了线程的资源调度优先级，这样它就可以在不显著影响前台活动的情况下执行后台工作。这个值只能在hThread是当前线程的句柄时指定。如果线程已经处于后台处理模式，该函数将失败。Windows Server 2003和Windows XP/2000:不支持此值。THREAD_MODE_BACKGROUND_END 0x00020000 结束后台处理模式。系统恢复线程进入后台处理模式之前的资源调度优先级。这个值只能在hThread是当前线程的句柄时指定。如果线程不在后台处理模式下，函数将失败。Windows Server 2003和Windows XP/2000:不支持此值。THREAD_PRIORITY_ABOVE_NORMAL 1 priority类上1点。比优先级类低1点。优先级比优先级类高2点。THREAD_PRIORITY_IDLE - 15idle_priority_class的基优先级为1，低于NORMAL_PRIORITY_CLASS、NORMAL_PRIORITY_CLASS、高于NORMAL_PRIORITY_CLASS或HIGH_PRIORITY_CLASS进程的基优先级为16,REALTIME_PRIORITY_CLASS进程的基优先级为16。比优先级类低2点。优先级类的0Normal优先级。THREAD_PRIORITY_TIME_CRITICAL处理IDLE_PRIORITY_CLASS的基优先级为15，低于NORMAL_PRIORITY_CLASS、NORMAL_PRIORITY_CLASS、ABOVE_NORMAL_PRIORITY_CLASS或HIGH_PRIORITY_CLASS处理的基优先级为31,REALTIME_PRIORITY_CLASS处理的基优先级为31。

.DLL命令 ExitProcess, , "kernel32.dll", "ExitProcess"
    .参数 uExitCode, 整数型, , 0

.DLL命令 GetModuleFileNameA, 整数型, "kernel32.dll", "GetModuleFileNameA"
    .参数 hModule, 整数型
    .参数 lpFilename, 文本型
    .参数 nSize, 整数型

.DLL命令 GetModuleFileNameW, 整数型, "kernel32.dll", "GetModuleFileNameW"
    .参数 hModule, 整数型
    .参数 lpFilename, 字节集
    .参数 nSize, 整数型

.DLL命令 Process32FirstW, 逻辑型, "kernel32.dll", "Process32FirstW"
    .参数 hSnapshot, 整数型, , 0
    .参数 lppe, PROCESSENTRY32W, , 0

.DLL命令 Process32NextW, 逻辑型, "kernel32.dll", "Process32NextW"
    .参数 hSnapshot, 整数型, , 0
    .参数 lppe, PROCESSENTRY32W, , 0

.DLL命令 GetProcessImageFileNameW, 整数型, "psapi.dll", "GetProcessImageFileNameW"
    .参数 hProcess, 整数型
    .参数 lpImageFileName, 字节集
    .参数 nSize, 整数型

.DLL命令 QueryDosDeviceW, 整数型, "kernel32.dll", "QueryDosDeviceW"
    .参数 lpDeviceName, 字节集
    .参数 lpTargetPath, 字节集
    .参数 ucchMax, 整数型

.DLL命令 FindFirstFileW, 整数型, "kernel32.dll", "FindFirstFileW"
    .参数 lpFileName, 字节集
    .参数 lpFindFileData, WIN32_FIND_DATAW

.DLL命令 FindNextFileW, 逻辑型, "kernel32.dll", "FindNextFileW"
    .参数 hFindFile, 整数型
    .参数 lpFindFileData, WIN32_FIND_DATAW

.DLL命令 FindClose, 逻辑型, "kernel32.dll", "FindClose"
    .参数 hFindFile, 整数型

.DLL命令 wcslen, 整数型, "msvcrt.dll", "@wcslen", 公开
    .参数 _String, 字节集

.DLL命令 wcscmp, 整数型, "ntdll.dll", "@wcscmp", 公开
    .参数 _String1, 字节集
    .参数 _String2, 字节集

.DLL命令 RegOpenKeyExW, 整数型, "advapi32.dll", "RegOpenKeyExW"
    .参数 hKey, 整数型
    .参数 lpSubKey, 字节集
    .参数 ulOptions, 整数型
    .参数 samDesired, 整数型
    .参数 phkResult, 整数型, 传址

.DLL命令 RegQueryValueExW, 整数型, "advapi32.dll", "RegQueryValueExW"
    .参数 hKey, 整数型
    .参数 lpValueName, 字节集
    .参数 lpReserved, 整数型
    .参数 lpType, 整数型, 传址
    .参数 lpData, 整数型
    .参数 lpcbData, 整数型, 传址

.DLL命令 RegSetValueExW, 整数型, "advapi32.dll", "RegSetValueExW"
    .参数 hKey, 整数型
    .参数 lpValueName, 字节集
    .参数 Reserved, 整数型
    .参数 dwType, 整数型
    .参数 lpData, 整数型
    .参数 cbData, 整数型

.DLL命令 MapVirtualKeyA, 整数型, "user32.dll", "MapVirtualKeyA"
    .参数 uCode, 整数型
    .参数 uMapType, 整数型

.DLL命令 GetKeyNameTextA, 整数型, "user32.dll", "GetKeyNameTextA"
    .参数 lParam, 整数型
    .参数 lpString, 文本型
    .参数 nSize, 整数型

.DLL命令 RegCreateKeyExW, 整数型, "advapi32.dll", "RegCreateKeyExW"
    .参数 hKey, 整数型
    .参数 lpSubKey, 字节集
    .参数 Reserved, 整数型
    .参数 lpClass, 整数型
    .参数 dwOptions, 整数型
    .参数 samDesired, 整数型
    .参数 lpSecurityAttributes, 整数型
    .参数 phkResult, 整数型, 传址
    .参数 lpdwDisposition, 整数型

.DLL命令 GetSystemDEPPolicy, 整数型, "Kernel32.dll", "GetSystemDEPPolicy", , 获取系统的数据执行保护（DEP）策略设置

.DLL命令 SetProcessDEPPolicy, 逻辑型, "Kernel32.dll", "SetProcessDEPPolicy", , 更改32位进程的数据执行保护（DEP）和DEP-ATL转换模拟设置
    .参数 dwFlags, 整数型

.DLL命令 GetSystemTimeAsFileTime, 整数型, "kernel32.dll", "GetSystemTimeAsFileTime", , 获取当前系统时间
    .参数 lpSystemTimeAsFileTime, 整数型, , 指向一个用于装载系统时间的 FILETIME 结构

.DLL命令 SetWindowDisplayAffinity, 逻辑型, "User32.dll", "SetWindowDisplayAffinity"
    .参数 hWnd, 整数型
    .参数 dwAffinity, 整数型

.DLL命令 SetScrollPos, , "user32.dll", "SetScrollPos"
    .参数 hwnd, 整数型
    .参数 Nbar, 整数型
    .参数 nPos, 整数型
    .参数 bRedraw, 逻辑型

.DLL命令 memset, 整数型, "msvcrt.dll", "@memset", 公开
    .参数 p, 整数型
    .参数 by, 字节型
    .参数 size, 整数型

.DLL命令 strlen, 整数型, "msvcrt.dll", "@strlen"
    .参数 lpsz, 整数型

.DLL命令 memcpy, 整数型, "msvcrt.dll", "@memcpy", 公开
    .参数 p, 整数型
    .参数 p, 整数型
    .参数 size, 整数型

.DLL命令 RtlInitUnicodeString, , "ntdll.dll", "RtlInitUnicodeString"
    .参数 DestinationString, UNICODE_STRING
    .参数 SourceString, 字节集

.DLL命令 NtRenameKey, 整数型, "ntdll.dll", "NtRenameKey"
    .参数 KeyHandle, 整数型
    .参数 ReplacementName, UNICODE_STRING

.DLL命令 waveInGetNumDevs, 整数型, "winmm.dll", "waveInGetNumDevs"

.DLL命令 ShellExecuteExA, 逻辑型, "shell32.dll", "ShellExecuteExA"
    .参数 lpExecInfo, 整数型, , 0

.DLL命令 NtQueryInformationProcess, 整数型, "ntdll.dll", "NtQueryInformationProcess"
    .参数 ProcessHandle, 整数型
    .参数 ProcessInformationClass, 整数型, , #Process***
    .参数 ProcessInformation, 整数型
    .参数 ProcessInformationLength, 整数型
    .参数 ReturnLength, 整数型, 传址

.DLL命令 sprintf, 整数型, "ntdll.dll", "@sprintf"
    .参数 _Buffer, 整数型
    .参数 _Format, 文本型
    .参数 _Arg, 整数型

.DLL命令 SwitchToThisWindow, , "User32.dll", "SwitchToThisWindow"
    .参数 hwnd, 整数型
    .参数 fUnknown, 逻辑型

.DLL命令 PathFileExistsW, 逻辑型, "shlwapi.dll", "PathFileExistsW"
    .参数 pszPath, 字节集

.DLL命令 ShellExecuteW, 整数型, "shell32.dll", "ShellExecuteW", , 查找与指定文件关联在一起的程序的文件名,并执行相关操作，成功则返一个大于31的值。
    .参数 hwnd, 整数型, , 用来指定被执行文件显示的窗口所属的父窗口句柄，可以为NULL
    .参数 lpOperation, 字节集, , 指向一个表示执行方式的字符串
    .参数 lpFile, 字节集, , 用来指定文件名,文件名既可以是可执行文件也可以是数据文件,或可执行文件．
    .参数 lpParameters, 字节集, , 当lpFile参数指定了一个可执行文件(open),本参数用来指定命令行参数.如果lpFile参数指定是数据文件或其它,那么本参数必须是NULL
    .参数 lpDirctory, 字节集, , 执行或打开文件时使用的默认目录，如果lpFile同时指定了文件名(夹)的目录，此参数无效．
    .参数 nShowCmd, 整数型, , 如果函数执行了一个可执行文件,这个参数是指定窗口的打开方式,这个参数定义同ShowWindow函数中的dwCmdShow参数

.DLL命令 GetFileAttributesW, 整数型, "kernel32.dll", "GetFileAttributesW"
    .参数 lpFileName, 字节集, , 指定欲获取属性的一个文件的名字

.DLL命令 RemoveDirectoryW, 逻辑型, "kernel32", "RemoveDirectoryW"
    .参数 lpPathName, 字节集

.DLL命令 SetFileAttributesW, 逻辑型, "kernel32", "SetFileAttributesW"
    .参数 lpFileName, 字节集
    .参数 dwFileAttributes, 整数型

.DLL命令 SHGetSpecialFolderPathW, 逻辑型, "Shell32.dll", "SHGetSpecialFolderPathW"
    .参数 hwnd, 整数型
    .参数 pszPath, 整数型
    .参数 csidl, 整数型
    .参数 fCreate, 逻辑型

.DLL命令 GetTempPathW, 整数型, "Kernel32.dll", "GetTempPathW"
    .参数 nBufferLength, 整数型
    .参数 lpBuffer, 整数型

.DLL命令 sscanf, 整数型, "ntdll.dll", "@sscanf"
    .参数 _Buffer, 整数型
    .参数 _Format, 文本型
    .参数 _Result, 字节型, 传址

.DLL命令 CreateDesktopW, 整数型, "user32.dll", "CreateDesktopW"
    .参数 lpszDesktop, 字节集
    .参数 lpszDevice, 整数型
    .参数 pDevmode, 整数型
    .参数 dwFlags, 整数型
    .参数 dwDesiredAccess, 整数型
    .参数 lpsa, 整数型

.DLL命令 CloseDesktop, 逻辑型, "User32.dll", "CloseDesktop"
    .参数 hDesktop, 整数型

.DLL命令 CreateProcessW, 逻辑型, "kernel32.dll", "CreateProcessW"
    .参数 lpApplicationName, 整数型
    .参数 lpCommandLine, 整数型
    .参数 lpProcessAttributes, 整数型
    .参数 lpThreadAttributes, 整数型
    .参数 bInheritHandles, 逻辑型
    .参数 dwCreationFlags, 整数型
    .参数 lpEnvironment, 整数型
    .参数 lpCurrentDirectory, 整数型
    .参数 lpStartupInfo, STARTUPINFO
    .参数 lpProcessInformation, PROCESS_INFORMATION

.DLL命令 ProcessIdToSessionId, 逻辑型, "kernel32.dll", "ProcessIdToSessionId", , 检索与指定进程关联的远程桌面服务会话。
    .参数 dwProcessId, 整数型, , 指定进程标识符。使用 GetCurrentProcessId函数检索当前进程的进程标识符。
    .参数 pSessionId, 整数型, 传址, 指向一个变量的指针，该变量接收在其下运行指定进程的远程桌面服务会话的标识符。若要检索当前附加到控制台的会话的标识符，请使用WTSGetActiveConsoleSessionId 函数。

.DLL命令 WinStationOpenServerW, 整数型, "winsta.dll", "WinStationOpenServerW", , 打开服务器,返回打开后的标识
    .参数 ServerName, 整数型

.DLL命令 WinStationNameFromLogonIdW, 逻辑型, "winsta.dll", "WinStationNameFromLogonIdW", , 从远程会话ID获得身份名称
    .参数 hServer, 整数型, , 打开的服务器标识
    .参数 SessionID, 整数型, , 会话ID , 可通过ProcessIdToSessionId 获得
    .参数 pWinStationName, 字节集, , 返回获得到的标识 UNICODE编码的,需要解码

.DLL命令 WinStationCloseServer, 逻辑型, "winsta.dll", "WinStationCloseServer"
    .参数 hServer, 整数型

.DLL命令 SHGetDesktopFolder, 整数型, "shell32", "SHGetDesktopFolder"
    .参数 ppshf, 整数型, 传址

.DLL命令 SHGetMalloc, 整数型, "shell32", "SHGetMalloc"
    .参数 ppMalloc, 整数型, 传址

.DLL命令 SHGetFolderLocation, 整数型, "Shell32.dll", "SHGetFolderLocation"
    .参数 hwnd, 整数型
    .参数 csidl, 整数型
    .参数 hToken, 整数型
    .参数 dwFlags, 整数型
    .参数 ppidl, 整数型, 传址

.DLL命令 ExpandEnvironmentStringsW, 整数型, "Kernel32.dll", "ExpandEnvironmentStringsW"
    .参数 lpSrc, 字节集
    .参数 lpDst, 整数型
    .参数 nSize, 整数型

.DLL命令 GetAdaptersAddresses, 整数型, "Iphlpapi.dll", "GetAdaptersAddresses"
    .参数 Family, 整数型
    .参数 Flags, 整数型
    .参数 Reserved, 整数型
    .参数 AdapterAddresses, 整数型
    .参数 SizePointer, 整数型, 传址

.DLL命令 inet_ntop, 整数型, "Ws2_32.dll", "inet_ntop"
    .参数 Family, 整数型
    .参数 pAddr, 整数型
    .参数 pStringBuf, 整数型
    .参数 StringBufSize, 整数型

.DLL命令 ConvertLengthToIpv4Mask, 整数型, "Iphlpapi.dll", "ConvertLengthToIpv4Mask"
    .参数 MaskLength, 整数型
    .参数 Mask, 整数型, 传址

.DLL命令 ZwQueryKey, 整数型, "ntdll.dll", "ZwQueryKey"
    .参数 KeyHandle, 整数型
    .参数 KeyInformationClass, 整数型, , #Keyxxx
    .参数 KeyInformation, 整数型
    .参数 Length, 整数型
    .参数 ResultLength, 整数型, 传址

.DLL命令 GetModuleHandleExA, 逻辑型, "kernel32.dll", "GetModuleHandleExA"
    .参数 dwFlags, 整数型, , #GET_MODULE_HANDLE_EX_FLAG_*
    .参数 lpModuleName, 整数型, 传址
    .参数 phModule, 整数型, 传址

.DLL命令 GetModuleBaseNameA, 整数型, "psapi.dll", "GetModuleBaseNameA"
    .参数 hProcess, 整数型
    .参数 hModule, 整数型
    .参数 lpBaseName, 文本型
    .参数 nSize, 整数型

.DLL命令 RtlMoveMemory_KBDLLHOOKSTRUCT, 整数型, "kernel32.dll", "RtlMoveMemory"
    .参数 Destination, KBDLLHOOKSTRUCT
    .参数 Source, 整数型
    .参数 Length, 整数型

.DLL命令 RtlMoveMemory_MSLLHOOKSTRUCT, 整数型, "kernel32.dll", "RtlMoveMemory"
    .参数 Destination, MSLLHOOKSTRUCT
    .参数 Source, 整数型
    .参数 Length, 整数型

.DLL命令 SHFreeNameMappings, , "Shell32.dll", "SHFreeNameMappings"
    .参数 hNameMappings, 整数型

.DLL命令 GetProcessId, 整数型, "Kernel32.dll", "GetProcessId"
    .参数 hProcess, 整数型

.DLL命令 CheckRemoteDebuggerPresent, 逻辑型, "Kernel32.dll", "CheckRemoteDebuggerPresent"
    .参数 hProcess, 整数型
    .参数 pbDebuggerPresent, 逻辑型, 传址

.DLL命令 RtlMoveMemory_WIN32_FIND_DATAW, 整数型, "kernel32.dll", "RtlMoveMemory"
    .参数 Destination, WIN32_FIND_DATAW
    .参数 Source, 整数型
    .参数 Length, 整数型

.DLL命令 SHGetFileInfoW, 整数型, "Shell32.dll", "SHGetFileInfoW"
    .参数 pszPath, 整数型
    .参数 dwFileAttributes, 整数型
    .参数 psfi, 整数型
    .参数 cbFileInfo, 整数型
    .参数 uFlags, 整数型

.DLL命令 EnumFontFamiliesExW, 整数型, "Gdi32.dll", "EnumFontFamiliesExW"
    .参数 hdc, 整数型
    .参数 lpLogfont, 整数型
    .参数 lpProc, 整数型
    .参数 lParam, 整数型
    .参数 dwFlags, 整数型

.DLL命令 sprintf_长整数型, 整数型, "ntdll.dll", "@sprintf"
    .参数 _Buffer, 整数型
    .参数 _Format, 文本型
    .参数 _Arg, 长整数型

.DLL命令 EnumDisplayDevicesW, 逻辑型, "User32.dll", "EnumDisplayDevicesW"
    .参数 lpDevice, 整数型
    .参数 iDevNum, 整数型
    .参数 lpDisplayDevice, 整数型
    .参数 dwFlags, 整数型

.DLL命令 EnumDisplaySettingsW, 逻辑型, "User32.dll", "EnumDisplaySettingsW"
    .参数 lpszDeviceName, 整数型
    .参数 iModeNum, 整数型
    .参数 lpDevMode, 整数型

.DLL命令 ChangeDisplaySettingsExW, 整数型, "User32.dll", "ChangeDisplaySettingsExW"
    .参数 lpszDeviceName, 整数型
    .参数 lpDevMode, 整数型
    .参数 hwnd, 整数型
    .参数 dwFlags, 整数型
    .参数 lParam, 整数型

.DLL命令 SystemParametersInfoW, 逻辑型, "User32.dll", "SystemParametersInfoW"
    .参数 uiAction, 整数型
    .参数 uiParam, 整数型
    .参数 pvParam, 整数型
    .参数 fWinIni, 整数型

.DLL命令 InternetOpenW, 整数型, "Wininet.dll", "InternetOpenW"
    .参数 lpszAgent, 整数型
    .参数 dwAccessType, 整数型
    .参数 lpszProxy, 整数型
    .参数 lpszProxyBypass, 整数型
    .参数 dwFlags, 整数型

.DLL命令 InternetOpenUrlW, 整数型, "Wininet.dll", "InternetOpenUrlW"
    .参数 hInternet, 整数型
    .参数 lpszUrl, 整数型
    .参数 lpszHeaders, 整数型
    .参数 dwHeadersLength, 整数型
    .参数 dwFlags, 整数型
    .参数 dwContext, 整数型

.DLL命令 HttpQueryInfoW, 逻辑型, "Wininet.dll", "HttpQueryInfoW"
    .参数 hRequest, 整数型
    .参数 dwInfoLevel, 整数型
    .参数 lpBuffer, 整数型
    .参数 lpdwBufferLength, 整数型, 传址
    .参数 lpdwIndex, 整数型, 传址

.DLL命令 FindFirstChangeNotificationW, 整数型, "Kernel32.dll", "FindFirstChangeNotificationW"
    .参数 lpPathName, 字节集
    .参数 bWatchSubtree, 逻辑型
    .参数 dwNotifyFilter, 整数型

.DLL命令 FindNextChangeNotification, 逻辑型, "Kernel32.dll", "FindNextChangeNotification"
    .参数 hChangeHandle, 整数型

.DLL命令 FindCloseChangeNotification, 逻辑型, "Kernel32.dll", "FindCloseChangeNotification"
    .参数 hChangeHandle, 整数型

.DLL命令 WaitForMultipleObjects, 整数型, "Kernel32.dll", "WaitForMultipleObjects"
    .参数 nCount, 整数型
    .参数 lpHandles, 整数型
    .参数 bWaitAll, 逻辑型
    .参数 dwMilliseconds, 整数型

.DLL命令 FindFirstUrlCacheEntryW, 整数型, "Wininet.dll", "FindFirstUrlCacheEntryW"
    .参数 lpszUrlSearchPattern, 整数型
    .参数 lpFirstCacheEntryInfo, 整数型
    .参数 lpcbCacheEntryInfo, 整数型, 传址

.DLL命令 FindNextUrlCacheEntryW, 逻辑型, "Wininet.dll", "FindNextUrlCacheEntryW"
    .参数 hEnumHandle, 整数型
    .参数 lpNextCacheEntryInfo, 整数型
    .参数 lpcbCacheEntryInfo, 整数型, 传址

.DLL命令 DeleteUrlCacheEntryW, 逻辑型, "Wininet.dll", "DeleteUrlCacheEntryW"
    .参数 lpszUrlName, 整数型

.DLL命令 PathFindFileNameW, 整数型, "shlwapi.dll", "PathFindFileNameW"
    .参数 pszPath, 整数型

.DLL命令 GetLayeredWindowAttributes, 逻辑型, "User32.dll", "GetLayeredWindowAttributes"
    .参数 hwnd, 整数型
    .参数 pcrKey, 整数型, 传址
    .参数 pbAlpha, 整数型, 传址
    .参数 pdwFlags, 整数型, 传址

.DLL命令 URLDownloadToFileA, 整数型, "urlmon.dll", "URLDownloadToFileA"
    .参数 LPUNKNOWN, 整数型, , 控件的接口,如果不是控件则为0
    .参数 LPCSTR, 文本型, , 本参数指定欲读取文件在互联网上的HTTP地址(即URL),不能为空
    .参数 LPCSTR, 文本型, , 下载后保存的文件名(完整路径).例如:c:\1.exe
    .参数 DWORD, 整数型, , 保留字段,必需为0
    .参数 LPBINDSTATUSCALLBACK, 整数型, , 回调函数.若不需要填0.

.DLL命令 recv, 整数型, "ws2_32.dll", "recv"
    .参数 s, 整数型
    .参数 buf, 整数型
    .参数 len, 整数型
    .参数 flags, 整数型

.DLL命令 GetFileVersionInfoSizeW, 整数型, "version.dll", "GetFileVersionInfoSizeW"
    .参数 lptstrFilename, 字节集
    .参数 lpdwHandle, 整数型, 传址

.DLL命令 GetFileVersionInfoW, 逻辑型, "version.dll", "GetFileVersionInfoW"
    .参数 lptstrFilename, 字节集
    .参数 dwHandle, 整数型
    .参数 dwLen, 整数型
    .参数 lpData, 整数型

.DLL命令 VerQueryValueW, 逻辑型, "version.dll", "VerQueryValueW"
    .参数 pBlock, 整数型
    .参数 lpSubBlock, 字节集
    .参数 lplpBuffer, 整数型, 传址
    .参数 puLen, 整数型, 传址

.DLL命令 VerLanguageNameW, 整数型, "kernel32.dll", "VerLanguageNameW"
    .参数 wLang, 整数型
    .参数 szLang, 整数型
    .参数 cchLang, 整数型

.DLL命令 swprintf, 整数型, "ntdll.dll", "@swprintf"
    .参数 _Buffer, 字节集
    .参数 _Format, 字节集
    .参数 _Arg, 整数型

.DLL命令 getaddrinfo, 整数型, "ws2_32.dll", "getaddrinfo"
    .参数 pNodeName, 文本型
    .参数 pServiceName, 文本型
    .参数 pHints, 整数型
    .参数 ppResult, 整数型

.DLL命令 ntohl, 整数型, "Ws2_32.dll", "ntohl"
    .参数 netlong, 整数型

.DLL命令 sendto1, 整数型, "ws2_32.dll", "sendto"
    .参数 s, 整数型
    .参数 buf, 整数型
    .参数 len, 整数型
    .参数 flags, 整数型
    .参数 to, 整数型
    .参数 tolen, 整数型

.DLL命令 select1, 整数型, "ws2_32.dll", "select"
    .参数 nfds, 整数型
    .参数 readfds, 整数型
    .参数 writefds, 整数型
    .参数 exceptfds, 整数型
    .参数 timeout, 整数型

.DLL命令 recvfrom1, 整数型, "ws2_32.dll", "recvfrom"
    .参数 s, 整数型
    .参数 buf, 整数型
    .参数 len, 整数型
    .参数 flags, 整数型
    .参数 from, 整数型
    .参数 fromlen, 整数型, 传址

.DLL命令 freeaddrinfo, , "ws2_32.dll", "freeaddrinfo"
    .参数 pAddrInfo, 整数型

.DLL命令 GetTickCount64, 长整数型, "Kernel32.dll", "GetTickCount64", 公开

.DLL命令 StrFromTimeIntervalA, 整数型, "Shlwapi.dll", "StrFromTimeIntervalA"
    .参数 pszOut, 整数型
    .参数 cchMax, 整数型
    .参数 dwTimeMS, 整数型
    .参数 digits, 整数型

.DLL命令 GetNumberFormatA, 整数型, "Kernel32.dll", "GetNumberFormatA"
    .参数 Locale, 整数型
    .参数 dwFlags, 整数型
    .参数 lpValue, 文本型
    .参数 lpFormat, 整数型
    .参数 lpNumberStr, 整数型
    .参数 cchNumber, 整数型

.DLL命令 SendInput, 整数型, "User32.dll", "SendInput", 公开
    .参数 cInputs, 整数型
    .参数 pInputs, INPUT, 数组
    .参数 cbSize, 整数型

.DLL命令 CreateSymbolicLinkW, 字节型, "Kernel32.dll", "CreateSymbolicLinkW"
    .参数 lpSymlinkFileName, 字节集
    .参数 lpTargetFileName, 字节集
    .参数 dwFlags, 整数型

.DLL命令 GetWindowPlacement, 逻辑型, "User32.dll", "GetWindowPlacement", 公开
    .参数 hWnd, 整数型
    .参数 lpwndpl, 整数型, , WINDOWPLACEMENT *

.DLL命令 SetWindowPlacement, 逻辑型, "User32.dll", "SetWindowPlacement", 公开
    .参数 hWnd, 整数型
    .参数 lpwndpl, 整数型, , WINDOWPLACEMENT *

.DLL命令 SHCreateShellItem, 整数型, "Shell32.dll", "SHCreateShellItem"
    .参数 pidlParent, 整数型
    .参数 psfParent, 整数型
    .参数 pidl, 整数型
    .参数 ppsi, 整数型, 传址

.DLL命令 SHGetPropertyStoreFromParsingName, 整数型, "Shell32.dll", "SHGetPropertyStoreFromParsingName"
    .参数 pszPath, 整数型
    .参数 pbc, 整数型
    .参数 flags, 整数型
    .参数 riid, 整数型
    .参数 ppv, 整数型, 传址

.DLL命令 RegDeleteTreeW, 整数型, "Advapi32.dll", "RegDeleteTreeW"
    .参数 hKey, 整数型
    .参数 lpSubKey, 字节集

.DLL命令 GetWindowsDirectoryW, 整数型, "kernel32.dll", "GetWindowsDirectoryW"
    .参数 lpBuffer, 整数型
    .参数 uSize, 整数型

.DLL命令 SHGetPropertyStoreForWindow, 整数型, "Shell32.dll", "SHGetPropertyStoreForWindow"
    .参数 hwnd, 整数型
    .参数 riid, 整数型
    .参数 ppv, 整数型, 传址

.DLL命令 CreateProcessAsUserW, 逻辑型, "Advapi32.dll", "CreateProcessAsUserW"
    .参数 hToken, 整数型
    .参数 lpApplicationName, 整数型
    .参数 lpCommandLine, 整数型
    .参数 lpProcessAttributes, 整数型
    .参数 lpThreadAttributes, 整数型
    .参数 bInheritHandles, 逻辑型
    .参数 dwCreationFlags, 整数型
    .参数 lpEnvironment, 整数型
    .参数 lpCurrentDirectory, 整数型
    .参数 lpStartupInfo, STARTUPINFO
    .参数 lpProcessInformation, PROCESS_INFORMATION

.DLL命令 CreateProcessWithTokenW, 逻辑型, "Advapi32.dll", "CreateProcessWithTokenW"
    .参数 hToken, 整数型
    .参数 dwLogonFlags, 整数型
    .参数 lpApplicationName, 整数型
    .参数 lpCommandLine, 整数型
    .参数 dwCreationFlags, 整数型
    .参数 lpEnvironment, 整数型
    .参数 lpCurrentDirectory, 整数型
    .参数 lpStartupInfo, STARTUPINFO
    .参数 lpProcessInformation, PROCESS_INFORMATION

.DLL命令 DuplicateTokenEx, 逻辑型, "Advapi32.dll", "DuplicateTokenEx"
    .参数 hExistingToken, 整数型
    .参数 dwDesiredAccess, 整数型
    .参数 lpTokenAttributes, 整数型
    .参数 ImpersonationLevel, 整数型
    .参数 TokenType, 整数型
    .参数 phNewToken, 整数型, 传址

.DLL命令 CreateDCW, 整数型, "gdi32.dll", "CreateDCW"
    .参数 pwszDriver, 字节集
    .参数 pwszDevice, 整数型
    .参数 pszPort, 整数型
    .参数 pdm, 整数型

.DLL命令 GetObjectW, 整数型, "gdi32.dll", "GetObjectW"
    .参数 h, 整数型
    .参数 c, 整数型
    .参数 pv, 整数型

.DLL命令 SelectPalette, 整数型, "gdi32.dll", "SelectPalette"
    .参数 hdc, 整数型
    .参数 hPal, 整数型
    .参数 bForceBkgd, 逻辑型

.DLL命令 RealizePalette, 整数型, "gdi32.dll", "RealizePalette"
    .参数 hdc, 整数型

.DLL命令 GetDIBits4, 整数型, "gdi32.dll", "GetDIBits"
    .参数 hdc, 整数型
    .参数 hbm, 整数型
    .参数 start, 整数型
    .参数 cLines, 整数型
    .参数 lpvBits, 整数型
    .参数 lpbmi, 整数型
    .参数 usage, 整数型

.DLL命令 LoadBitmapA, 整数型, "User32.dll", "LoadBitmapA"
    .参数 hInstance, 整数型
    .参数 lpBitmapName, 整数型

.DLL命令 GetNamedSecurityInfoW, 整数型, "Advapi32.dll", "GetNamedSecurityInfoW"
    .参数 pObjectName, 整数型
    .参数 ObjectType, 整数型
    .参数 SecurityInfo, 整数型
    .参数 ppsidOwner, 整数型
    .参数 ppsidGroup, 整数型
    .参数 ppDacl, 整数型
    .参数 ppSacl, 整数型
    .参数 ppSecurityDescriptor, 整数型

.DLL命令 BuildExplicitAccessWithNameW, , "Advapi32.dll", "BuildExplicitAccessWithNameW"
    .参数 pExplicitAccess, 整数型
    .参数 pTrusteeName, 整数型
    .参数 AccessPermissions, 整数型
    .参数 AccessMode, 整数型
    .参数 Inheritance, 整数型

.DLL命令 SetEntriesInAclW, 整数型, "Advapi32.dll", "SetEntriesInAclW"
    .参数 cCountOfExplicitEntries, 整数型
    .参数 pListOfExplicitEntries, 整数型
    .参数 OldAcl, 整数型
    .参数 NewAcl, 整数型

.DLL命令 SetNamedSecurityInfoW, 整数型, "Advapi32.dll", "SetNamedSecurityInfoW"
    .参数 pObjectName, 整数型
    .参数 ObjectType, 整数型
    .参数 SecurityInfo, 整数型
    .参数 psidOwner, 整数型
    .参数 psidGroup, 整数型
    .参数 pDacl, 整数型
    .参数 pSacl, 整数型

.DLL命令 VerSetConditionMask, 长整数型, "Kernel32.dll", "VerSetConditionMask"
    .参数 ConditionMask, 长整数型
    .参数 TypeMask, 整数型
    .参数 Condition, 字节型

.DLL命令 VerifyVersionInfoW, 逻辑型, "Kernel32.dll", "VerifyVersionInfoW"
    .参数 lpVersionInformation, 整数型
    .参数 dwTypeMask, 整数型
    .参数 dwlConditionMask, 长整数型

.DLL命令 GetSidSubAuthority, 整数型, "advapi32.dll", "GetSidSubAuthority"
    .参数 pSid, 整数型
    .参数 nSubAuthority, 整数型

.DLL命令 GetSidSubAuthorityCount, 整数型, "advapi32.dll", "GetSidSubAuthorityCount"
    .参数 pSid, 整数型

.DLL命令 GetTokenInformation, 逻辑型, "advapi32.dll", "GetTokenInformation"
    .参数 TokenHandle, 整数型
    .参数 TokenInformationClass, 整数型
    .参数 TokenInformation, 整数型
    .参数 TokenInformationLength, 整数型
    .参数 ReturnLength, 整数型

.DLL命令 ImageRvaToVa, 整数型, "Dbghelp.dll", "ImageRvaToVa"
    .参数 NtHeaders, 整数型
    .参数 Base, 整数型
    .参数 Rva, 整数型
    .参数 LastRvaSection, 整数型, 传址

.DLL命令 CreateFileMappingW, 整数型, "kernel32.dll", "CreateFileMappingW"
    .参数 hFile, 整数型
    .参数 lpFileMappingAttributes, 整数型
    .参数 flProtect, 整数型
    .参数 dwMaximumSizeHigh, 整数型
    .参数 dwMaximumSizeLow, 整数型
    .参数 lpName, 整数型

.DLL命令 FindMimeFromData, 整数型, "Urlmon.dll", "FindMimeFromData"
    .参数 pBC, 整数型
    .参数 pwzUrl, 整数型
    .参数 pBuffer, 整数型
    .参数 cbSize, 整数型
    .参数 pwzMimeProposed, 整数型
    .参数 dwMimeFlags, 整数型
    .参数 ppwzMimeOut, 整数型, 传址
    .参数 dwReserved, 整数型

.DLL命令 AllocateAndInitializeSid, 逻辑型, "Advapi32.dll", "AllocateAndInitializeSid"
    .参数 pIdentifierAuthority, 整数型
    .参数 nSubAuthorityCount, 字节型
    .参数 nSubAuthority0, 整数型
    .参数 nSubAuthority1, 整数型
    .参数 nSubAuthority2, 整数型
    .参数 nSubAuthority3, 整数型
    .参数 nSubAuthority4, 整数型
    .参数 nSubAuthority5, 整数型
    .参数 nSubAuthority6, 整数型
    .参数 nSubAuthority7, 整数型
    .参数 pSid, 整数型, 传址

.DLL命令 EqualSid, 逻辑型, "Advapi32.dll", "EqualSid"
    .参数 pSid1, 整数型
    .参数 pSid2, 整数型

.DLL命令 FreeSid, 整数型, "Advapi32.dll", "FreeSid"
    .参数 pSid, 整数型

.DLL命令 SafeArrayDestroy, 整数型, "oleaut32.dll", "SafeArrayDestroy"
    .参数 psa, 整数型

.DLL命令 NtWow64QueryInformationProcess64, 整数型, "ntdll.dll", "NtWow64QueryInformationProcess64"
    .参数 ProcessHandle, 整数型
    .参数 ProcessInformationClass, 整数型
    .参数 ProcessInformation, 整数型
    .参数 ProcessInformationLength, 整数型
    .参数 ReturnLength, 整数型, 传址

.DLL命令 NtWow64ReadVirtualMemory64, 整数型, "ntdll.dll", "NtWow64ReadVirtualMemory64"
    .参数 ProcessHandle, 整数型
    .参数 BaseAddress, 长整数型
    .参数 Buffer, 整数型
    .参数 Size, 长整数型
    .参数 NumberOfBytesRead, 长整数型, 传址

.DLL命令 NtReadVirtualMemory, 整数型, "ntdll.dll", "NtReadVirtualMemory"
    .参数 ProcessHandle, 整数型
    .参数 BaseAddress, 整数型
    .参数 Buffer, 整数型
    .参数 Size, 整数型
    .参数 NumberOfBytesRead, 整数型, 传址

.DLL命令 GetFullPathNameW, 整数型, "Kernel32.dll", "GetFullPathNameW"
    .参数 lpFileName, 字节集
    .参数 nBufferLength, 整数型
    .参数 lpBuffer, 整数型
    .参数 lpFilePart, 整数型, 传址

.DLL命令 StrCmpLogicalW, 整数型, "shlwapi.dll", "StrCmpLogicalW"
    .参数 psz1, 字节集
    .参数 psz2, 字节集

.DLL命令 GetFileSize, 整数型, "kernel32.dll", "GetFileSize"
    .参数 hFile, 整数型
    .参数 lpFileSizeHigh, 整数型, 传址

.DLL命令 OleLoadPicture, 整数型, "olepro32.dll", "OleLoadPicture"
    .参数 lpstream, 整数型
    .参数 lSize, 整数型
    .参数 fRunmode, 逻辑型
    .参数 riid, 整数型
    .参数 lplpvObj, 整数型, 传址

.DLL命令 CopyImage, 整数型, "user32.dll", "CopyImage"
    .参数 h, 整数型
    .参数 type, 整数型
    .参数 cx, 整数型
    .参数 cy, 整数型
    .参数 flags, 整数型

.DLL命令 GetSystemPowerStatus, 逻辑型, "kernel32.dll", "GetSystemPowerStatus", 公开, 检索系统的电源状态。该状态指示系统是使用交流电源还是直流电源运行、电池当前是否正在充电、电池寿命剩余多少以及电池保护程序是打开还是关闭。
    .参数 lpSystemPowerStatus, SYSTEM_POWER_STATUS, , https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-getsystempowerstatus

.DLL命令 WSASetLastError, , "Ws2_32.dll", "WSASetLastError"
    .参数 iError, 整数型

.DLL命令 WSAAddressToStringA, 整数型, "Ws2_32.dll", "WSAAddressToStringA"
    .参数 lpsaAddress, 整数型
    .参数 dwAddressLength, 整数型
    .参数 lpProtocolInfo, 整数型
    .参数 lpszAddressString, 整数型
    .参数 lpdwAddressStringLength, 整数型, 传址

.DLL命令 InitializeProcThreadAttributeList, 逻辑型, "Kernel32.dll", "InitializeProcThreadAttributeList"
    .参数 lpAttributeList, 整数型
    .参数 dwAttributeCount, 整数型
    .参数 dwFlags, 整数型
    .参数 lpSize, 整数型, 传址

.DLL命令 DeleteProcThreadAttributeList, 整数型, "kernel32.dll", "DeleteProcThreadAttributeList"
    .参数 lpAttributeList, 整数型

.DLL命令 UpdateProcThreadAttribute, 逻辑型, "Kernel32.dll", "UpdateProcThreadAttribute"
    .参数 lpAttributeList, 整数型
    .参数 dwFlags, 整数型
    .参数 Attribute, 整数型
    .参数 lpValue, 整数型
    .参数 cbSize, 整数型
    .参数 lpPreviousValue, 整数型
    .参数 lpReturnSize, 整数型

.DLL命令 RegDeleteKeyW, 整数型, "advapi32.dll", "RegDeleteKeyW"
    .参数 hKey, 整数型
    .参数 lpSubKey, 字节集

.DLL命令 RegDeleteValueW, 整数型, "advapi32.dll", "RegDeleteValueW"
    .参数 hKey, 整数型
    .参数 lpValueName, 字节集

.DLL命令 SHOpenWithDialog, 整数型, "shell32.dll", "SHOpenWithDialog"
    .参数 hwndParent, 整数型
    .参数 poainfo, OPENASINFO

.DLL命令 WTSEnumerateProcessesW, 逻辑型, "Wtsapi32.dll", "WTSEnumerateProcessesW"
    .参数 hServer, 整数型
    .参数 Reserved, 整数型
    .参数 Version, 整数型
    .参数 ppProcessInfo, 整数型, 传址
    .参数 pCount, 整数型, 传址

.DLL命令 WTSFreeMemory, , "Wtsapi32.dll", "WTSFreeMemory"
    .参数 pMemory, 整数型

.DLL命令 LookupAccountSidW, 逻辑型, "Advapi32.dll", "LookupAccountSidW"
    .参数 lpSystemName, 整数型
    .参数 Sid, 整数型
    .参数 Name, 整数型
    .参数 cchName, 整数型, 传址
    .参数 ReferencedDomainName, 整数型
    .参数 cchReferencedDomainName, 整数型, 传址
    .参数 peUse, 整数型, 传址

.DLL命令 lstrcmpiW, 整数型, "Kernel32.dll", "lstrcmpiW"
    .参数 lpString1, 整数型
    .参数 lpString2, 字节集

.DLL命令 lstrcmpW, 整数型, "Kernel32.dll", "lstrcmpW"
    .参数 lpString1, 整数型
    .参数 lpString2, 字节集

.DLL命令 EndDialog, 逻辑型, "User32.dll", "EndDialog"
    .参数 hDlg, 整数型
    .参数 nResult, 整数型

.DLL命令 GetPerformanceInfo, 逻辑型, "psapi.dll", "GetPerformanceInfo"
    .参数 pPerformanceInformation, PERFORMANCE_INFORMATION
    .参数 cb, 整数型

.DLL命令 QueryWorkingSet, 逻辑型, "psapi.dll", "QueryWorkingSet"
    .参数 hProcess, 整数型
    .参数 pv, 整数型
    .参数 cb, 整数型

.DLL命令 ImageList_DragMove, 逻辑型, "Comctl32.dll", "ImageList_DragMove"
    .参数 x, 整数型
    .参数 y, 整数型

.DLL命令 ImageList_DragShowNolock, 逻辑型, "Comctl32.dll", "ImageList_DragShowNolock"
    .参数 fShow, 逻辑型

.DLL命令 ImageList_DragLeave, 逻辑型, "Comctl32.dll", "ImageList_DragLeave"
    .参数 hwndLock, 整数型

.DLL命令 ImageList_EndDrag, , "Comctl32.dll", "ImageList_EndDrag"

.DLL命令 ImageList_BeginDrag, 逻辑型, "Comctl32.dll", "ImageList_BeginDrag"
    .参数 himlTrack, 整数型
    .参数 iTrack, 整数型
    .参数 dxHotspot, 整数型
    .参数 dyHotspot, 整数型

.DLL命令 ImageList_DragEnter, 逻辑型, "Comctl32.dll", "ImageList_DragEnter"
    .参数 hwndLock, 整数型
    .参数 x, 整数型
    .参数 y, 整数型

.DLL命令 GetMonitorInfoA, 逻辑型, "User32.dll", "GetMonitorInfoA"
    .参数 hMonitor, 整数型
    .参数 lpmi, 整数型

.DLL命令 EnumPropsA, 整数型, "User32.dll", "EnumPropsA"
    .参数 hWnd, 整数型
    .参数 lpEnumFunc, 整数型

.DLL命令 ReadDirectoryChangesW, 逻辑型, "Kernel32.dll", "ReadDirectoryChangesW"
    .参数 hDirectory, 整数型
    .参数 lpBuffer, 整数型
    .参数 nBufferLength, 整数型
    .参数 bWatchSubtree, 逻辑型
    .参数 dwNotifyFilter, 整数型
    .参数 lpBytesReturned, 整数型
    .参数 lpOverlapped, 整数型
    .参数 lpCompletionRoutine, 整数型

.DLL命令 NtQueryInformationThread, 整数型, "ntdll.dll", "NtQueryInformationThread"
    .参数 ThreadHandle, 整数型
    .参数 ThreadInformationClass, 整数型
    .参数 ThreadInformation, 整数型
    .参数 ThreadInformationLength, 整数型
    .参数 ReturnLength, 整数型, 传址

.DLL命令 GetMappedFileNameA, 整数型, "Psapi.dll", "GetMappedFileNameA"
    .参数 hProcess, 整数型
    .参数 lpv, 整数型
    .参数 lpFilename, 文本型
    .参数 nSize, 整数型

.DLL命令 CredUIPromptForWindowsCredentialsW, 整数型, "Credui.dll", "CredUIPromptForWindowsCredentialsW"
    .参数 pUiInfo, CREDUI_INFOW
    .参数 dwAuthError, 整数型
    .参数 pulAuthPackage, 整数型, 传址
    .参数 pvInAuthBuffer, 整数型
    .参数 ulInAuthBufferSize, 整数型
    .参数 ppvOutAuthBuffer, 整数型, 传址
    .参数 pulOutAuthBufferSize, 整数型, 传址
    .参数 pfSave, 逻辑型, 传址
    .参数 dwFlags, 整数型

.DLL命令 CredUnPackAuthenticationBufferW, 整数型, "Credui.dll", "CredUnPackAuthenticationBufferW"
    .参数 dwFlags, 整数型
    .参数 pAuthBuffer, 整数型
    .参数 cbAuthBuffer, 整数型
    .参数 pszUserName, 整数型
    .参数 pcchMaxUserName, 整数型, 传址
    .参数 pszDomainName, 整数型
    .参数 pcchMaxDomainName, 整数型, 传址
    .参数 pszPassword, 整数型
    .参数 pcchMaxPassword, 整数型, 传址

.DLL命令 SetWindowTheme, 整数型, "UxTheme.dll", "SetWindowTheme", 公开
    .参数 hwnd, 整数型
    .参数 pszSubAppName, 字节集
    .参数 pszSubIdList, 字节集

.DLL命令 SetConsoleCtrlHandler, 逻辑型, "Kernel32.dll", "SetConsoleCtrlHandler", 公开
    .参数 HandlerRoutine, 整数型
    .参数 Add, 逻辑型

.DLL命令 GetFileTitleW, 短整数型, "Comdlg32.dll", "GetFileTitleW"
    .参数 lpszFile, 字节集
    .参数 lpszTitle, 字节集
    .参数 cbBuf, 整数型

.DLL命令 PathFindExtensionW, 整数型, "Shlwapi.dll", "PathFindExtensionW"
    .参数 pszPath, 字节集

.DLL命令 wcscat, 整数型, "msvcrt.dll", "@wcscat"
    .参数 _Destination, 字节集
    .参数 _Source, 字节集

.DLL命令 GetBinaryTypeW, 逻辑型, "Kernel32.dll", "GetBinaryTypeW", 公开
    .参数 lpApplicationName, 字节集
    .参数 lpBinaryType, 整数型, 传址, #SCS_*

.DLL命令 LogonUserA, 逻辑型, "Advapi32.dll", "LogonUserA"
    .参数 lpszUsername, 文本型
    .参数 lpszDomain, 文本型
    .参数 lpszPassword, 文本型
    .参数 dwLogonType, 整数型
    .参数 dwLogonProvider, 整数型
    .参数 phToken, 整数型, 传址

.DLL命令 LogonUserW, 逻辑型, "Advapi32.dll", "LogonUserW"
    .参数 lpszUsername, 字节集
    .参数 lpszDomain, 字节集
    .参数 lpszPassword, 字节集
    .参数 dwLogonType, 整数型
    .参数 dwLogonProvider, 整数型
    .参数 phToken, 整数型, 传址

.DLL命令 GetFinalPathNameByHandleW, 整数型, "Kernel32.dll", "GetFinalPathNameByHandleW"
    .参数 hFile, 整数型
    .参数 lpszFilePath, 字节集
    .参数 cchFilePath, 整数型
    .参数 dwFlags, 整数型

.DLL命令 LsaEnumerateLogonSessions, 整数型, "Secur32.dll", "LsaEnumerateLogonSessions"
    .参数 LogonSessionCount, 整数型, 传址
    .参数 LogonSessionList, 整数型, 传址

.DLL命令 LsaGetLogonSessionData, 整数型, "Secur32.dll", "LsaGetLogonSessionData"
    .参数 LogonId, 整数型
    .参数 ppLogonSessionData, 整数型, 传址

.DLL命令 LsaFreeReturnBuffer, 整数型, "Secur32.dll", "LsaFreeReturnBuffer"
    .参数 Buffer, 整数型

.DLL命令 HttpSendRequestExA, 逻辑型, "wininet.dll", "HttpSendRequestExA"
    .参数 hRequest, 整数型
    .参数 lpBuffersIn, INTERNET_BUFFERSA
    .参数 lpBuffersOut, 整数型
    .参数 dwFlags, 整数型
    .参数 dwContext, 整数型

.DLL命令 InternetWriteFile, 逻辑型, "wininet.dll", "InternetWriteFile"
    .参数 hFile, 整数型
    .参数 lpBuffer, 字节集
    .参数 dwNumberOfBytesToWrite, 整数型
    .参数 lpdwNumberOfBytesWritten, 整数型, 传址

.DLL命令 HttpEndRequestA, 逻辑型, "wininet.dll", "HttpEndRequestA"
    .参数 hRequest, 整数型
    .参数 lpBuffersOut, 整数型
    .参数 dwFlags, 整数型
    .参数 dwContext, 整数型

.DLL命令 DwmSetWindowAttribute, 整数型, "Dwmapi.dll", "DwmSetWindowAttribute"
    .参数 hwnd, 整数型
    .参数 dwAttribute, 整数型
    .参数 pvAttribute, 整数型
    .参数 cbAttribute, 整数型

.DLL命令 WinHttpWriteData, 逻辑型, "Winhttp.dll", "WinHttpWriteData"
    .参数 hRequest, 整数型
    .参数 lpBuffer, 字节集
    .参数 dwNumberOfBytesToWrite, 整数型
    .参数 lpdwNumberOfBytesWritten, 整数型, 传址

.版本 2

.全局变量 全_文本, 文本型
.全局变量 普通填表, 普通填表, 公开
.全局变量 内存, 类_内存, 公开, , 内存操作
.全局变量 POST数据类, 类_POST数据类
.全局变量 POST数据类_字节集, 类_POST数据类_字节集
.全局变量 全_Token, 整数型
.全局变量 _WIN32_WINNT, 整数型, 公开
.全局变量 m_Build, 短整数型, , , 内部版本号
.全局变量 m_CodePage, 整数型, 公开, , 代码页
.全局变量 m_stageSize, 整数型, 公开, , 分段长度
.版本 2



.常量 旧窗口过程, "“oldWndProc”", 公开
.常量 LMEM_ZEROINIT, "64", 公开

.常量 WM_NOTIFY, "78", 公开, 当某个控件的某个事件已经发生或这个控件需要得到一些信息时，发送此消息给它的父窗口
.常量 NM_CUSTOMDRAW, "-12", 公开
.常量 CDDS_PREPAINT, "1", 公开
.常量 CDRF_NOTIFYSUBITEMDRAW, "32", 公开
.常量 CDDS_ITEMPREPAINT, "65537", 公开
.常量 CDDS_SUBITEM, "131072", 公开
.常量 DT_VCENTER, "4", 公开
.常量 DT_LEFT, "0", 公开
.常量 DT_SINGLELINE, "32", 公开
.常量 CDRF_SKIPDEFAULT, "4", 公开
.常量 WS_POPUP, "-2147483648", 公开, 该窗口是一个弹出窗口。此样式不能与WS_CHILD样式一起使用。

.常量 SMTO_ABORTIFHUNG, "2", , 如果接收线程似乎没有响应或“挂起”，则该函数无需等待超时时间结束即可返回。
.常量 IMAGE_BITMAP, "0", 公开, 复制位图。
.常量 IMAGE_ICON, "1", 公开, 复制一个图标。
.常量 IMAGE_CURSOR, "2", 公开, 复制光标。

.常量 STIF_DEFAULT, "0", 公开
.常量 STIF_SUPPORT_HEX, "1", 公开
.常量 CP_gb2312, "936", 公开, ANSI/OEM Simplified Chinese (PRC, Singapore); Chinese Simplified (GB2312)
.常量 CP_UTF8, "65001", 公开, Unicode (UTF-8)
.常量 CP_BIG5, "950", 公开, 繁体中文（Big5）

.常量 GB2312_CHARSET, "134", , 此字体支持简体中文字符集

.常量 ERROR_BUFFER_OVERFLOW, "111", 公开, SizePointer参数 指示的缓冲区大小太小，无法容纳适配器信息或AdapterAddresses参数为NULL。返回的SizePointer参数指向保存适配器信息所需的缓冲区大小。
.常量 ERROR_SUCCESS, "0", 公开, 操作成功完成。
.常量 ERROR_ALREADY_EXISTS, "183", , 当文件已存在时，无法创建该文件
.常量 MIB_IF_TYPE_ETHERNET, "6", 公开, 以太网网络接口。
.常量 MIB_IF_TYPE_FDDI, "15", 公开, 光纤分布式数据接口 (FDDI) 网络接口。
.常量 MIB_IF_TYPE_LOOPBACK, "24", 公开, 软件环回网络接口。
.常量 MIB_IF_TYPE_OTHER, "1", 公开, 一些其他类型的网络接口。
.常量 MIB_IF_TYPE_PPP, "23", 公开, PPP 网络接口。
.常量 MIB_IF_TYPE_SLIP, "28", 公开, ATM 网络接口。
.常量 MIB_IF_TYPE_TOKENRING, "9", 公开, 令牌环网络接口。
.常量 MIB_IF_TYPE_IEEE80211, "71", 公开, IEEE 802.11 无线网络接口。

.常量 ERROR_INVALID_PARAMETER, "87", , 为表分配的空间不足。表的大小在pdwSize参数中返回，并且必须用于对此函数的后续调用，才能成功检索表
.常量 ERROR_INSUFFICIENT_BUFFER, "122", 公开, 一个无效参数传递给函数。如果TableClass参数包含未在TCP_TABLE_CLASS枚举中定义的值， 则返回此错误。
.常量 WSAEAFNOSUPPORT, "10047", , 使用了与请求的协议不兼容的地址。

.常量 AF_INET, "2", , IPv4
.常量 AF_INET6, "23", , IPv6

.常量 TCP_TABLE_OWNER_PID_ALL, "5", , https://msdn.microsoft.com/en-us/library/aa366386.aspx
.常量 UDP_TABLE_OWNER_PID, "1", , https://msdn.microsoft.com/en-us/library/aa366388.aspx
.常量 TH32CS_SNAPHEAPLIST, "1", , 包括快照中th32ProcessID中指定的所有进程堆。
.常量 TH32CS_SNAPPROCESS, "2", , 在快照中包括系统中的所有进程。
.常量 TH32CS_SNAPTHREAD, "4", , 在快照中包括系统中的所有线程。
.常量 TH32CS_SNAPMODULE, "8", , 包括快照中th32ProcessID中指定的进程的所有模块。
.常量 TH32CS_SNAPALL, "15", , 包括系统中的所有进程和线程，以及th32ProcessID中指定的进程的堆和模块。


.常量 WM_GETTEXTLENGTH, "14", 公开, 得到与一个窗口有关的文本的长度（不包含空字符）
.常量 SMTO_NORMAL, "0", 公开
.常量 MAXCHAR, "127", , 表示有符号字节的最大值。
.常量 MAXBYTE, "255", , 表示无符号字节的最大值。
.常量 MAXSHORT, "32767", , 表示有符号短整型的最大值。
.常量 MAXWORD, "65535", , 表示无符号短整型的最大值。
.常量 MAXLONG, "2147483647", , 表示有符号整型的最大值。
.常量 MAXDWORD, "4294967295", , 表示无符号整型的最大值。

.常量 服务器消息, "1029", 公开, 服务器消息
.常量 客户消息, "1030", 公开, 客户消息
.常量 FD_CLOSE, "32", 公开, 客户退出
.常量 FD_ACCEPT, "8", 公开, 客户进入
.常量 FD_READ, "1", 公开, 数据到达
.常量 PF_INET, "2", 公开, TCP/IP协议族
.常量 SOCK_STREAM, "1", 公开, 流套接字类型(TCP)
.常量 SOCK_DGRAM, "2", 公开, 数据报套接字类型(UDP)
.常量 IPPROTO_TCP, "6", 公开
.常量 IPPROTO_UDP, "17", 公开, 用户数据报协议（UDP/IP），一种无连接的数据报协议。
.常量 SRCCOPY, "13369376", 公开, 直接复制，不做任何修改。

.常量 网页属性_网页标题, "“title”", 公开
.常量 网页属性_网页地址, "“location”", 公开
.常量 网页属性_网页源码, "“outerHTML”", 公开, outerHTML
.常量 网页属性_网页文本, "“innerText”", 公开, innerText
.常量 网页属性_网站域名, "“domain”", 公开, domain
.常量 网页属性_访问来源, "“referrer”", 公开, referrer
.常量 网页属性_创建时间, "“fileCreatedDate”", 公开, fileCreatedDate
.常量 网页属性_修改时间, "“lastModified”", 公开, lastModified
.常量 网页属性_Cookies, "“cookie”", 公开, cookie
.常量 网页属性_编码类型, "“charset”", 公开, charset
.常量 网页属性_文档大小, "“fileSize”", 公开, fileSize

.常量 脚本类型_JavaScript, "“JavaScript”", 公开
.常量 脚本类型_VBScript, "“VBScript”", 公开

.常量 网页事件_selectedIndex, "“selectedIndex”", 公开, 组合框被选择
.常量 网页事件_onabort, "“onabort”", 公开, 当用户中断下载图像时触发。.常量 网页事件_onactivate, "“onactivate”", 公开, 当对象设置为活动元素时触发。
.常量 网页事件_onafterprint, "“onafterprint”", 公开, 对象所关联的文档打印或打印预览后立即在对象上触发。
.常量 网页事件_onafterupdate, "“onafterupdate”", 公开, 当成功更新数据源对象中的关联对象后在数据绑定对象上触发。
.常量 网页事件_onbeforeactivate, "“onbeforeactivate”", 公开, 对象要被设置为当前元素前立即触发。
.常量 网页事件_onbeforecopy, "“onbeforecopy”", 公开, 当选中区复制到系统剪贴板之前在源对象触发。
.常量 网页事件_onbeforecut, "“onbeforecut”", 公开, 当选中区从文档中删除之前在源对象触发。
.常量 网页事件_onbeforedeactivate, "“onbeforedeactivate”", 公开, 在 activeElement 从当前对象变为父文档其它对象之前立即触发。
.常量 网页事件_onbeforeeditfocus, "“onbeforeeditfocus”", 公开, 在包含于可编辑元素内的对象进入用户界面激活状态前或可编辑容器变成控件选中区前触发。
.常量 网页事件_onbeforepaste, "“onbeforepaste”", 公开, 在选中区从系统剪贴板粘贴到文档前在目标对象上触发。
.常量 网页事件_onbeforeprint, "“onbeforeprint”", 公开, 对象的关联文档打印或打印预览前在对象上触发。
.常量 网页事件_onbeforeunload, "“onbeforeunload”", 公开, 在页面将要被卸载前触发。
.常量 网页事件_onbeforeupdate, "“onbeforeupdate”", 公开, 当成功更新数据源对象中的关联对象前在数据绑定对象上触发。
.常量 网页事件_onblur, "“onblur”", 公开, 在对象失去输入焦点时触发。***************
.常量 网页事件_onbounce, "“onbounce”", 公开, 当 marquee 对象的 behavior 属性设置为“alternate”且字幕的内容到达窗口一边时触发。
.常量 网页事件_oncellchange, "“oncellchange”", 公开, 在数据供应者中的数据变更时触发。
.常量 网页事件_onchange, "“onchange”", 公开, 当对象或选中区的内容改变时触发。
.常量 网页事件_oncontextmenu, "“oncontextmenu”", 公开, 在用户使用鼠标右键单击客户区打开上下文菜单时触发。
.常量 网页事件_oncontrolselect, "“oncontrolselect”", 公开, 当用户将要对该对象制作一个控件选中区时触发。
.常量 网页事件_oncopy, "“oncopy”", 公开, 当用户复制对象或选中区，将其添加到系统剪贴板上时在源元素上触发。
.常量 网页事件_oncut, "“oncut”", 公开, 当对象或选中区从文档中删除并添加到系统剪贴板上时在源元素上触发。
.常量 网页事件_ondataavailable, "“ondataavailable”", 公开, 每当异步传输数据的数据源对象的数据到达时触发。
.常量 网页事件_ondatasetchanged, "“ondatasetchanged”", 公开, 当数据源对象对应的数据集发生变更时触发。
.常量 网页事件_ondatasetcomplete, "“ondatasetcomplete”", 公开, 触发就表明数据源对象所有数据都可用。
.常量 网页事件_ondeactivate, "“ondeactivate”", 公开, 当 activeElement 从当前对象变为父文档其它对象时触发。
.常量 网页事件_ondrag, "“ondrag”", 公开, 当进行拖曳操作时在源对象上持续触发。
.常量 网页事件_ondragend, "“ondragend”", 公开, 当用户在拖曳操作结束后释放鼠标时在源对象上触发。
.常量 网页事件_ondragenter, "“ondragenter”", 公开, 当用户拖曳对象到一个合法拖曳目标时在目标元素上触发。
.常量 网页事件_ondragleave, "“ondragleave”", 公开, 当用户在拖曳操作过程中将鼠标移出合法拖曳目标时在目标对象上触发。
.常量 网页事件_ondragover, "“ondragover”", 公开, 当用户拖曳对象划过合法拖曳目标时持续在目标元素上触发。
.常量 网页事件_ondragstart, "“ondragstart”", 公开, 当用户开始拖曳文本选中区或选中对象时在源对象上触发。
.常量 网页事件_ondrop, "“ondrop”", 公开, 当鼠标按钮在拖曳操作过程中释放时在目标对象上触发。
.常量 网页事件_onerror, "“onerror”", 公开, 当对象装载过程中发生错误时触发。
.常量 网页事件_onerrorupdate, "“onerrorupdate”", 公开, 更新数据源对象中的关联数据出错时在数据绑定对象上触发。
.常量 网页事件_onfilterchange, "“onfilterchange”", 公开, 当可视滤镜更改状态或完成转换时触发。
.常量 网页事件_onfinish, "“onfinish”", 公开, 当字幕循环完成后触发。
.常量 网页事件_onfocus, "“onfocus”", 公开, 当对象获得焦点时触发。
.常量 网页事件_onfocusin, "“onfocusin”", 公开, 当元素将要被设置为焦点之前触发。
.常量 网页事件_onfocusout, "“onfocusout”", 公开, 在移动焦点到其它元素之后立即触发于当前拥有焦点的元素上触发。
.常量 网页事件_onhelp, "“onhelp”", 公开, 当用户在浏览器为当前窗口时按
.常量 网页事件_onkeydown, "“onkeydown”", 公开, 当用户按下键盘按键时触发。
.常量 网页事件_onkeypress, "“onkeypress”", 公开, 当用户按下字面键时触发。
.常量 网页事件_onkeyup, "“onkeyup”", 公开, 当用户释放键盘按键时触发。
.常量 网页事件_onlayoutcomplete, "“onlayoutcomplete”", 公开, 当打印或打印预览版面处理完成用来自于源文档的内容填充当前
.常量 网页事件_onload, "“onload”", 公开, 在浏览器完成对象的装载后立即触发。
.常量 网页事件_onlosecapture, "“onlosecapture”", 公开, 当对象失去鼠标捕捉时触发。
.常量 网页事件_onmousedown, "“onmousedown”", 公开, 当用户用任何鼠标按钮单击对象时触发。
.常量 网页事件_onmouseenter, "“onmouseenter”", 公开, 当用户将鼠标指针移动到对象内时触发。
.常量 网页事件_onmouseleave, "“onmouseleave”", 公开, 当用户将鼠标指针移出对象边界时触发。
.常量 网页事件_onmousemove, "“onmousemove”", 公开, 当用户将鼠标划过对象时触发。
.常量 网页事件_onmouseout, "“onmouseout”", 公开, 当用户将鼠标指针移出对象边界时触发。
.常量 网页事件_onmouseover, "“onmouseover”", 公开, 当用户将鼠标指针移动到对象内时触发。
.常量 网页事件_onmouseup, "“onmouseup”", 公开, 当用户在鼠标位于对象之上时释放鼠标按钮时触发。
.常量 网页事件_onmousewheel, "“onmousewheel”", 公开, 当鼠标滚轮按钮旋转时触发。
.常量 网页事件_onmove, "“onmove”", 公开, 当对象移动时触发。
.常量 网页事件_onmoveend, "“onmoveend”", 公开, 当对象停止移动时触发。
.常量 网页事件_onmovestart, "“onmovestart”", 公开, 当对象开始移动时触发。
.常量 网页事件_onpaste, "“onpaste”", 公开, 当用户粘贴数据以便从系统剪贴板向文档传送数据时在目标对象上触发。
.常量 网页事件_onpropertychange, "“onpropertychange”", 公开, 当在对象上发生属性更改时触发。
.常量 网页事件_onreadystatechange, "“onreadystatechange”", 公开, 当对象状态变更时触发。
.常量 网页事件_onreset, "“onreset”", 公开, 当用户重置表单时触发。
.常量 网页事件_onresize, "“onresize”", 公开, 当对象的大小将要改变时触发。
.常量 网页事件_onresizeend, "“onresizeend”", 公开, 当用户更改完控件选中区中对象的尺寸时触发。
.常量 网页事件_onresizestart, "“onresizestart”", 公开, 当用户开始更改控件选中区中对象的尺寸时触发。
.常量 网页事件_onrowenter, "“onrowenter”", 公开, 触发就表明当前行已经在数据源中更改，对象上有可用的新数据值。
.常量 网页事件_onrowexit, "“onrowexit”", 公开, 当数据源控件更改对象当前行前触发。
.常量 网页事件_onrowsdelete, "“onrowsdelete”", 公开, 当行将要从记录集中被删除时触发。
.常量 网页事件_onrowsinserted, "“onrowsinserted”", 公开, 当在当前记录集中插入新行后触发。
.常量 网页事件_onscroll, "“onscroll”", 公开, 当用户滚动对象的滚动条时触发。
.常量 网页事件_onselect, "“onselect”", 公开, 当当前选中区改变时触发。
.常量 网页事件_onselectionchange, "“onselectionchange”", 公开, 当文档的选中状态改变时触发。
.常量 网页事件_onselectstart, "“onselectstart”", 公开, 对象将要被选中时触发。
.常量 网页事件_onstart, "“onstart”", 公开, 在 marquee 对象的每次循环开始时触发。
.常量 网页事件_onstop, "“onstop”", 公开, 当用户单击停止按钮或离开
.常量 网页事件_onunload, "“onunload”", 公开, 在对象卸载前立即触发。
.常量 网页事件_onsubmit, "“onsubmit”", 公开, 当表单将要被提交时触发。
.常量 网页事件_focus, "“focus”", 公开, 控件获得焦点；
.常量 网页事件_click, "“click”", 公开, 在用户用鼠标左键单击对象时触发。
.常量 网页事件_onclick, "“onclick”", 公开, 在用户用鼠标左键单击对象时触发。
.常量 网页事件_ondblclick, "“ondblclick”", 公开, 当用户用鼠标左键双击对象时触发。

.常量 PROCESS_TERMINATE, "1", , 启用TerminateProcess功能中的进程句柄来终止进程。
.常量 PROCESS_CREATE_PROCESS, "128", , 内部使用
.常量 PROCESS_VM_OPERATION, "8", 公开, 在进程的地址空间上执行操作所必需
.常量 PROCESS_CREATE_THREAD, "2", 公开, 启用在CreateRemoteThread函数中使用进程句柄来创建一个线程。
.常量 PROCESS_DUP_HANDLE, "64", 公开, 使用DuplicateHandle功能中的进程句柄作为源或目标进程来复制句柄。
.常量 INFINITE, "-1", 公开, 对于接受参数的线程处理方法，此值用于无限期挂起线程。
.常量 PROCESS_QUERY_INFORMATION, "1024", 公开, 启用GetExitCodeProcess和GetPriorityClass功能中的进程句柄来读取进程对象中的信息。
.常量 PROCESS_QUERY_LIMITED_INFORMATION, "4096", 公开, 检索有关进程的某些信息是必需的。具有PROCESS_QUERY_INFORMATION访问权限的句柄将自动授予PROCESS_QUERY_LIMITED_INFORMATION。
.常量 PROCESS_VM_READ, "16", 公开, 在使用ReadProcessMemory的进程中读取内存所必需
.常量 PROCESS_ALL_ACCESS, "2035711", 公开, 指定进程对象的所有可能的访问标志。
.常量 MEM_PRIVATE, "131072", 公开, 内存操作
.常量 PROCESS_VM_WRITE, "32", 公开, 在使用WriteProcessMemory的进程中写入内存所必需
.常量 PAGE_READONLY, "2", , 允许将视图映射为只读或写时复制访问。尝试写入特定区域会导致访问冲突。hFile参数指定的文件句柄必须使用GENERIC_READ访问权限创建。
.常量 PAGE_READWRITE, "4", 公开, 允许将视图映射为只读、写时复制或读/写访问。hFile参数指定的文件句柄必须使用 GENERIC_READ和 GENERIC_WRITE访问权限创建。
.常量 PAGE_WRITECOPY, "8", , 允许将视图映射为只读或写时复制访问。此值等效于 PAGE_READONLY。hFile参数指定的文件句柄必须使用GENERIC_READ访问权限创建 。

.常量 备份, "“SeBackupPrivilege”", 公开, 备份文件和目录
.常量 启动, "“SeRestorePrivilege”", 公开, 还原文件和目录
.常量 关机, "“SeShutdownPrivilege”", 公开, 关闭系统
.常量 调试, "“SeDebugPrivilege”", 公开, 调试程序

.常量 GENERIC_READ, "-2147483648", 公开, 指定对对象的读访问。可以从文件读取数据，文件指针可以移动。结合GENERIC_WRITE进行读写访问。
.常量 GENERIC_ALL, "268435456"
.常量 FILE_FLAG_SEQUENTIAL_SCAN, "134217728", 公开, 针对连续访问对文件缓冲进行优化
.常量 FILE_GENERIC_READ, "1179785"
.常量 GENERIC_WRITE, "1073741824", 公开, 指定对对象的写访问。数据可以写入文件，文件指针可以移动。结合GENERIC_READ进行读写访问。
.常量 OPEN_ALWAYS, "4", 公开, 4
.常量 FILE_SHARE_DELETE, "4"
.常量 FILE_ATTRIBUTE_READONLY, "1", 公开, 只读文件。应用程序可以读取文件，但不能对其进行写入或删除。
.常量 FILE_ATTRIBUTE_HIDDEN, "2", 公开, 文件或目录被隐藏。它不包含在普通目录列表中。
.常量 FILE_ATTRIBUTE_SYSTEM, "4", 公开, 操作系统使用一部分或专门使用的文件或目录。
.常量 FILE_ATTRIBUTE_DIRECTORY, "16", 公开, 标识目录的句柄
.常量 FILE_ATTRIBUTE_ARCHIVE, "32", 公开, 作为存档文件或目录的文件或目录。应用程序通常使用此属性来标记文件以进行备份或删除。
.常量 FILE_ATTRIBUTE_TEMPORARY, "256", , 用于临时存储的文件。如果有足够的高速缓存可用，文件系统避免将数据写回大容量存储，因为通常，应用程序在句柄关闭后会删除临时文件。在这种情况下，系统可以完全避免写入数据。否则，将在关闭句柄之后写入数据。
.常量 INVALID_FILE_ATTRIBUTES, "-1", , 如果函数失败，则返回值为INVALID_FILE_ATTRIBUTES。要获取扩展错误信息，请调用GetLastError。
.常量 INVALID_SET_FILE_POINTER, "-1"
.常量 FILE_LIST_DIRECTORY, "1", , 对于目录，列出目录内容的权限。
.常量 FILE_FLAG_OVERLAPPED, "1073741824", , 正在为异步 I/O 打开或创建文件或设备。
.常量 FILE_ACTION_ADDED, "1", 公开, 该文件已添加到目录中。
.常量 FILE_ACTION_REMOVED, "2", 公开, 该文件已从目录中删除。
.常量 FILE_ACTION_MODIFIED, "3", 公开, 文件已修改。这可以是时间戳或属性的更改。
.常量 FILE_ACTION_RENAMED_OLD_NAME, "4", 公开, 该文件已重命名，这是旧名称。
.常量 FILE_ACTION_RENAMED_NEW_NAME, "5", 公开, 文件已重命名，这是新名称。

.常量 INTERNET_FLAG_RELOAD, "2147483648", 公开
.常量 INTERNET_OPTION_SECURITY_FLAGS, "31", , 证书错误处理方式
.常量 INTERNET_COOKIE_THIRD_PARTY, "16", 公开, 运行第三方COOKIE
.常量 INTERNET_FLAG_NO_COOKIES, "524288", 公开
.常量 INTERNET_FLAG_NO_CACHE_WRITE, "67108864", 公开, 0x04000000
.常量 INTERNET_FLAG_NO_AUTO_REDIRECT, "2097152", 公开, HttpSendRequest、InternetOpenUrl 不自动处理重定向
.常量 INTERNET_FLAG_SECURE, "8388608", 公开, SSL访问
.常量 INTERNET_FLAG_IGNORE_REDIRECT_TO_HTTP, "32768", 公开, 禁用检测这一特殊类型的重新传入。当这个标志使用,WinINet透明允许将从HTTPS to HTTP的网址。这个标志可以使用的,HttpOpenRequest InternetOpenUrl
.常量 INTERNET_FLAG_IGNORE_REDIRECT_TO_HTTPS, "16384", 公开, 禁用检测这一特殊类型的重新传入。当这个标志使用,WinINet透明允许将从HTTP到HTTPS网址。这个标志可以使用的,HttpOpenRequest InternetOpenUrl
.常量 INTERNET_FLAG_PASSIVE, "134217728", 公开, FTP连接被动模式
.常量 INTERNET_OPTION_HTTP_DECODING, "65", 公开, Enables WinINet to perform decoding for the gzip and deflate encoding schemes. For more information, see Content Encoding

.常量 常量_SC_MANAGER_CREATE_SERVICE, "2", 公开
.常量 常量_SERVICE_ALL_ACCESS, "983551", 公开
.常量 常量_SERVICE_WIN32_OWN_PROCESS, "16", 公开
.常量 常量_SERVICE_STOPPED, "1", 公开
.常量 常量_SERVICE_ACCEPT_STOP, "1", 公开
.常量 常量_SERVICE_ACCEPT_SHUTDOWN, "4", 公开
.常量 常量_SERVICE_WIN32_SHARE_PROCESS, "32", 公开
.常量 NO_ERROR, "0"
.常量 常量_SERVICE_CONTROL_SHUTDOWN, "5", 公开, shutdown
.常量 常量_SERVICE_CONTROL_STOP, "1", 公开
.常量 常量_SERVICE_CONFIG_DESCRIPTION, "1", 公开
.常量 常量_SERVICE_ERROR_NORMAL, "1", 公开
.常量 常量_SERVICE_INTERACTIVE_PROCESS, "256", 公开
.常量 常量_SERVICE_AUTO_START, "2", 公开, 0x00000002

.常量 GENERIC_EXECUTE, "536870912", 公开, 0x20000000L
.常量 SERVICE_START, "16", 公开, 0x0010
.常量 SC_MANAGER_ALL_ACCESS, "983103", 公开, 0x000F003FL
.常量 SERVICE_QUERY_STATUS, "4", 公开, 0x0004
.常量 SERVICE_STOP, "32", 公开, 0x0020
.常量 DELETE, "65536", 公开, 0x00010000L
.常量 SC_MANAGER_LOCK, "8", 公开, 0x0008
.常量 SERVICE_CHANGE_CONFIG, "2", 公开, 0x0002
.常量 SERVICE_QUERY_CONFIG, "1", 公开, 0x0001
.常量 SERVICE_NO_CHANGE, "-1", 公开, 0xffffffff

.常量 SQL_NULL_HANDLE, "0", 公开
.常量 SQL_HANDLE_ENV, "1", 公开
.常量 SQL_HANDLE_DBC, "2", 公开
.常量 SQL_HANDLE_STMT, "3", 公开
.常量 SQL_HANDLE_DESC, "4", 公开

.常量 SQL_SUCCESS, "0", 公开
.常量 SQL_SUCCESS_WITH_INFO, "1", 公开
.常量 SQL_NO_DATA, "100", 公开
.常量 SQL_ERROR, "-1", 公开
.常量 SQL_INVALID_HANDLE, "-2", 公开
.常量 SQL_STILL_EXECUTING, "2", 公开
.常量 SQL_NEED_DATA, "99", 公开

.常量 SQL_ATTR_ODBC_VERSION, "200", 公开
.常量 SQL_ATTR_CONNECTION_POOLING, "201", 公开
.常量 SQL_ATTR_CP_MATCH, "202", 公开

.常量 SQL_OV_ODBC2, "2", 公开
.常量 SQL_OV_ODBC3, "3", 公开

.常量 SQL_IS_POINTER, "-4", 公开
.常量 SQL_IS_UINTEGER, "-5", 公开
.常量 SQL_IS_INTEGER, "-6", 公开
.常量 SQL_IS_USMALLINT, "-7", 公开
.常量 SQL_IS_SMALLINT, "-8", 公开

.常量 SQL_SIGNED_OFFSET, "-20", 公开
.常量 SQL_UNSIGNED_OFFSET, "-22", 公开
.常量 SQL_C_SLONG, "-16", 公开

.常量 SQL_DRIVER_NOPROMPT, "0", 公开
.常量 SQL_DRIVER_COMPLETE, "1", 公开
.常量 SQL_DRIVER_PROMPT, "2", 公开
.常量 SQL_DRIVER_COMPLETE_REQUIRED, "3", 公开

.常量 SQL_MAX_MESSAGE_LENGTH, "512"

.常量 SQL_C_CHAR, "1", 公开
.常量 SQL_C_LONG, "4", 公开
.常量 SQL_C_SHORT, "5", 公开
.常量 SQL_C_FLOAT, "7", 公开
.常量 SQL_C_DOUBLE, "8", 公开
.常量 SQL_C_NUMERIC, "2", 公开
.常量 SQL_C_DEFAULT, "99", 公开
.常量 SQL_C_DATE, "9", 公开
.常量 SQL_C_TIME, "10", 公开
.常量 SQL_C_TIMESTAMP, "11", 公开
.常量 SQL_C_BINARY, "-2", 公开
.常量 SQL_C_BIT, "-7", 公开
.常量 SQL_C_SBIGINT, "-22", 公开
.常量 SQL_C_UBIGINT, "-24", 公开
.常量 SQL_C_TINYINT, "-6", 公开

.常量 SQL_UNKNOWN_TYPE, "0", 公开
.常量 SQL_CHAR, "1", 公开
.常量 SQL_NUMERIC, "2", 公开
.常量 SQL_DECIMAL, "3", 公开
.常量 SQL_INTEGER, "4", 公开
.常量 SQL_SMALLINT, "5", 公开
.常量 SQL_FLOAT, "6", 公开
.常量 SQL_REAL, "7", 公开
.常量 SQL_DOUBLE, "8", 公开
.常量 SQL_DATE, "9", 公开
.常量 SQL_TIME, "10", 公开
.常量 SQL_TIMESTAMP, "11", 公开
.常量 SQL_VARCHAR, "12", 公开
.常量 SQL_LONGVARCHAR, "-1", 公开
.常量 SQL_BINARY, "-2", 公开
.常量 SQL_VARBINARY, "-3", 公开
.常量 SQL_LONGVARBINARY, "-4", 公开
.常量 SQL_BIGINT, "-5", 公开
.常量 SQL_TINYINT, "-6", 公开
.常量 SQL_BIT, "-7", 公开
.常量 SQL_GUID, "-11", 公开

.常量 SQL_ATTR_ACCESS_MODE, "101", 公开
.常量 SQL_ATTR_AUTOCOMMIT, "102", 公开
.常量 SQL_ATTR_CONNECTION_TIMEOUT, "113", 公开
.常量 SQL_ATTR_CURRENT_CATALOG, "109", 公开
.常量 SQL_ATTR_DISCONNECT_BEHAVIOR, "114", 公开
.常量 SQL_ATTR_ENLIST_IN_DTC, "1207", 公开
.常量 SQL_ATTR_ENLIST_IN_XA, "1208", 公开
.常量 SQL_ATTR_LOGIN_TIMEOUT, "103", 公开
.常量 SQL_ATTR_ODBC_CURSORS, "110", 公开
.常量 SQL_ATTR_PACKET_SIZE, "112", 公开
.常量 SQL_ATTR_QUIET_MODE, "111", 公开
.常量 SQL_ATTR_TRACE, "104", 公开
.常量 SQL_ATTR_TRACEFILE, "105", 公开
.常量 SQL_ATTR_TRANSLATE_LIB, "106", 公开
.常量 SQL_ATTR_TRANSLATE_OPTION, "107", 公开
.常量 SQL_ATTR_TXN_ISOLATION, "108", 公开
.常量 SQL_ATTR_CONNECTION_DEAD, "1209", 公开

.常量 SQL_CD_TRUE, "1", 公开
.常量 SQL_CD_FALSE, "0", 公开

.常量 SQL_PARAM_TYPE_UNKNOWN, "0", 公开
.常量 SQL_PARAM_INPUT, "1", 公开
.常量 SQL_PARAM_INPUT_OUTPUT, "2", 公开
.常量 SQL_RESULT_COL, "3", 公开
.常量 SQL_PARAM_OUTPUT, "4", 公开
.常量 SQL_RETURN_VALUE, "5", 公开

.常量 SQL_NTS, "-3", 公开

.常量 SQL_AUTOCOMMIT_OFF, "0", 公开
.常量 SQL_AUTOCOMMIT_ON, "1", 公开

.常量 SQL_COMMIT, "0", 公开
.常量 SQL_ROLLBACK, "1", 公开

.常量 SQL_ATTR_CURSOR_TYPE, "6", 公开
.常量 SQL_ATTR_ROW_NUMBER, "14", 公开
.常量 SQL_ATTR_MAX_ROWS, "1", 公开

.常量 光标类型_向前, "0", 公开, SQL_CURSOR_FORWARD_ONLY
.常量 光标类型_键集, "1", 公开, SQL_CURSOR_KEYSET_DRIVEN
.常量 光标类型_动态, "2", 公开, SQL_CURSOR_DYNAMIC
.常量 光标类型_静态, "3", 公开, SQL_CURSOR_STATIC

.常量 SQL_FETCH_NEXT, "1", 公开, 移动_下一行
.常量 SQL_FETCH_FIRST, "2", 公开, 移动_首行
.常量 SQL_FETCH_LAST, "3", 公开, 移动_尾行
.常量 SQL_FETCH_PRIOR, "4", 公开, 移动_上一行
.常量 SQL_FETCH_ABSOLUTE, "5", 公开, 移动_绝对移动
.常量 SQL_FETCH_RELATIVE, "6", 公开, 移动_相对移动

.常量 INTERNET_OPTION_PROXY, "38", 公开, Internet常量代理服务器
.常量 INTERNET_OPTION_SETTINGS_CHANGED, "39", 公开, Internet常量IE设置改变
.常量 INTERNET_OPTION_CONNECT_TIMEOUT, "2", 公开, 连接超时
.常量 INTERNET_OPTION_SEND_TIMEOUT, "5", 公开, 发送超时
.常量 INTERNET_OPTION_RECEIVE_TIMEOUT, "6", 公开, 回复超时

.常量 SQLITE_成功, "0", 公开, SQLITE_OK
.常量 SQLITE_错误, "1", 公开, SQLITE_ERROR SQL 错误或没有数据库
.常量 SQLITE_内部, "2", 公开, SQLITE_INTERNAL 一个SQLite内部的逻辑错误
.常量 SQLITE_权限, "3", 公开, SQLITE_PERM 访问权限被拒绝
.常量 SQLITE_终止, "4", 公开, SQLITE_ABORT 需要一个中断的Callback指令
.常量 SQLITE_繁忙, "5", 公开, SQLITE_BUSY 数据据库文件被锁定
.常量 SQLITE_锁定, "6", 公开, SQLITE_LOCKED 表被锁定
.常量 SQLITE_申请内存失败, "7", 公开, SQLITE_NOMEM
.常量 SQLITE_只读, "8", 公开, SQLITE_READONLY 试图写一个只读的数据库
.常量 SQLITE_中断, "9", 公开, SQLITE_INTERRUPT 操作被中断结束
.常量 SQLITE_IO错误, "10", 公开, SQLITE_IOERR 某种磁盘I/O错误发生
.常量 SQLITE_损坏, "11", 公开, SQLITE_CORRUPT 数据库磁盘镜像异常
.常量 SQLITE_为找到, "12", 公开, SQLITE_NOTFOUND 未使用。表或记录不存在
.常量 SQLITE_数据库满, "13", 公开, SQLITE_FULL 数据库满，插入失败
.常量 SQLITE_不能打开, "14", 公开, SQLITE_CANTOPEN 不能打开数据库文件
.常量 SQLITE_协议, "15", 公开, SQLITE_PROTOCOL 数据库错定协议错
.常量 SQLITE_无表, "16", 公开, SQLITE_EMPTY 数据库表为空
.常量 SQLITE_结构, "17", 公开, SQLITE_SCHEMA 数据库结构被改变
.常量 SQLITE_表太大, "18", 公开, SQLITE_TOOBIG 一个表的行数据过多
.常量 SQLITE_约束, "19", 公开, SQLITE_CONSTRAINT 由于约束冲突而中止
.常量 SQLITE_不匹配, "20", 公开, SQLITE_MISMATCH 数据类型不匹配
.常量 SQLITE_误用, "21", 公开, SQLITE_MISUSE 库被不正确使用
.常量 SQLITE_不支持OS, "22", 公开, SQLITE_NOLFS 主机不支持的OS特性
.常量 SQLITE_认证, "23", 公开, SQLITE_AUTH 授权被否定
.常量 SQLITE_格式, "24", 公开, SQLITE_FORMAT 辅助数据库格式错误
.常量 SQLITE_范围, "25", 公开, SQLITE_RANGE 绑定参数时索引超出范围
.常量 SQLITE_无数据库, "26", 公开, SQLITE_NOTADB 文件已打开但没有数据库
.常量 SQLITE_行, "100", 公开, SQLITE_ROW 有另一行就绪
.常量 SQLITE_完成, "101", 公开, SQLITE_DONE 已经完成执行

.常量 SQLITE_UTF8, "1", 公开
.常量 SQLITE_UTF16, "2", 公开
.常量 SQLITE_UTF16BE, "3", 公开
.常量 SQLITE_UTF16LE, "4", 公开
.常量 SQLITE_ANY, "5", 公开

.常量 SQLITE_OPEN_READONLY, "1", 公开
.常量 SQLITE_OPEN_READWRITE, "2", 公开
.常量 SQLITE_OPEN_CREATE, "4", 公开

.常量 S3字段类型_整型, "1", 公开, SQLITE_INTEGER
.常量 S3字段类型_浮点型, "2", 公开, SQLITE_FLOAT
.常量 S3字段类型_文本型, "3", 公开, SQLITE_TEXT
.常量 S3字段类型_字节集型, "4", 公开, SQLITE_BLOB
.常量 S3字段类型_空, "5", 公开, SQLITE_NULL

.常量 S3析构_静态, "0", 公开, SQLITE_STATIC
.常量 S3析构_临时, "-1", 公开, SQLITE_TRANSIENT

.常量 S3触发条件_插入, "0", 公开
.常量 S3触发条件_删除, "1", 公开
.常量 S3触发条件_更新, "2", 公开
.常量 S3触发条件_字段更新, "3", 公开

.常量 S3触发时间_普通模式, "0", 公开
.常量 S3触发时间_之前, "1", 公开
.常量 S3触发时间_之后, "2", 公开


.常量 SW_SHOW, "5", , 激活窗口并将其显示为当前的大小和位置
.常量 SW_SHOWMINNOACTIVE, "7", 公开, 最小化一个窗口，同时不改变活动窗口
.常量 SW_MINIMIZE, "6", , 最小化指定的窗口并以Z顺序激活下一个顶级窗口。
.常量 SW_SHOWNOACTIVATE, "4", 公开, 用最近的大小和位置显示一个窗口，同时不改变活动窗口
.常量 SW_SHOWMAXIMIZED, "3", 公开, 激活窗口并将其显示为最大化窗口。
.常量 SW_SHOWMINIMIZED, "2", 公开, 以最小化状态显示窗口，使当前活动窗口保持活动状态。
.常量 SW_SHOWNORMAL, "1", 公开, 激活并显示一个窗口。如果窗口被最小化或最大化，系统会将其恢复到其原始大小和位置。应用程序应在第一次显示窗口时指定此标志。
.常量 SW_SHOWDEFAULT, "10", 公开, 按默认状态显示
.常量 SEE_MASK_NOCLOSEPROCESS, "64", , 用于指示hProcess成员接收进程句柄。此句柄通常用于允许应用程序查明使用ShellExecuteEx创建的进程何时终止。在某些情况下，例如当通过 DDE 对话满足执行时，将不返回句柄。调用应用程序负责在不再需要时关闭句柄。
.常量 SEE_MASK_IDLIST, "4", , 使用lpIDList成员给出的项目标识符列表。所述lpIDList构件必须指向一个ITEMIDLIST结构。
.常量 SEE_MASK_INVOKEIDLIST, "12", , 使用所选项的快捷菜单处理程序的 IContextMenu 界面。使用 lpFile 通过文件系统路径标识项目，或使用 lpIDList 通过其 PIDL 标识项目。
.常量 SEE_MASK_NOASYNC, "256", , 等待执行操作完成后再返回。此标志应该由使用 ShellExecute 表单的调用者使用，这些表单可能会导致异步激活，例如 DDE，并创建一个可能在后台线程上运行的进程。（注：的ShellExecuteEx在默认情况下在后台线程运行，如果来电者的线程模型是不是公寓。）调用的ShellExecuteEx从后台线程已经运行的进程应该总是通过此标志。此外，在调用ShellExecuteEx后立即退出的应用程序应指定此标志。
.常量 SEE_MASK_FLAG_NO_UI, "1024", , 如果发生错误，则不显示错误消息框。
.常量 SEE_MASK_UNICODE, "16384", , 使用此标志来指示 Unicode 应用程序。
.常量 WAIT_TIMEOUT, "258", , 超时时间间隔已过，对象的状态为非信号状态。

.常量 ABE_LEFT, "0", , 左边缘。
.常量 ABE_TOP, "1", , 顶边。
.常量 ABE_RIGHT, "2", , 右边缘。
.常量 ABE_BOTTOM, "3", 公开, 底边。
.常量 SW_HIDE, "0", 公开, 隐藏窗口，活动状态给另一个窗口
.常量 SW_FORCEMINIMIZE, "11", 公开, 即使拥有窗口的线程未响应，也会最小化窗口。 仅当将窗口从不同的线程最小化时，才应使用此标志。
.常量 STARTF_USESHOWWINDOW, "1", 公开, 该wShowWindow成员包含更多的信息。
.常量 STARTF_USESTDHANDLES, "256", 公开
.常量 STILL_ACTIVE, "259", 公开

.常量 URLMON_OPTION_USERAGENT, "268435457", 公开

.常量 HKEY_DYN_DATA, "-2147483642", , 仅限Windows 95
.常量 HKEY_CURRENT_CONFIG, "-2147483643", 公开, 包含了当前系统配置的信息。 　
.常量 HKEY_PERFORMANCE_DATA, "-2147483644", 公开, 仅XP/winNT/win2000可用
.常量 HKEY_USERS, "-2147483645", 公开, 用作默认用户首选设置，也作为单个用户的首选设置。
.常量 HKEY_LOCAL_MACHINE, "-2147483646", 公开, 包含描述计算机及其配置的条目。其中包括关于处理器、系统主板、内存和已安装的软件和硬件的信息。 　
.常量 HKEY_CURRENT_USER, "-2147483647", 公开, 是用于当前（登录）用户的相关信息。 
.常量 HKEY_CLASSES_ROOT, "-2147483648", 公开, 是与文档类型和 OLE\COM 相关的信息的支持键。这个键是 HKEY_LOCAL_MACHINE的从属键。 

.常量 REG_OPTION_VOLATILE, "1"
.常量 KEY_ALL_ACCESS, "983103", 公开, 结合了 STANDARD_RIGHTS_REQUIRED、KEY_QUERY_VALUE、KEY_SET_VALUE、KEY_CREATE_SUB_KEY、KEY_ENUMERATE_SUB_KEYS、KEY_NOTIFY 和 KEY_CREATE_LINK 访问权限。
.常量 KEY_QUERY_VALUE, "1", , 需要查询注册表项的值。
.常量 KEY_CREATE_SUB_KEY, "4", , 创建注册表项的子项时需要。
.常量 KEY_WOW64_64KEY, "256", 公开, 使用32位或64位应用程序中的64位注册表项。
.常量 KEY_WOW64_32KEY, "512", 公开, 使用32位或64位应用程序中的32位注册表项。
.常量 KEY_READ, "131097", 公开, 组合 STANDARD_RIGHTS_READ、KEY_QUERY_VALUE、KEY_ENUMERATE_SUB_KEYS 和 KEY_NOTIFY 值。
.常量 KEY_WRITE, "131078", 公开, 结合 STANDARD_RIGHTS_WRITE、KEY_SET_VALUE 和 KEY_CREATE_SUB_KEY 访问权限。

.常量 REG_NONE, "0", 公开, 没有定义的值类型。
.常量 REG_BINARY, "3", 公开, 任何形式的二进制数据。
.常量 REG_DWORD, "4", 公开, 一个32位数字。
.常量 REG_SZ, "1", 公开, 空终止的字符串。根据您使用的是Unicode还是ANSI函数，它可以是Unicode或ANSI字符串。
.常量 REG_DWORD_LITTLE_ENDIAN, "4", 公开, 大计数法格式32位数字，一个字的有效字节是高端字
.常量 REG_DWORD_BIG_ENDIAN, "5", 公开, 大计数法格式32位数字，一个字的有效字节是低端字
.常量 REG_LINK, "6", 公开, 单一代码符号链
.常量 REG_EXPAND_SZ, "2", 公开, 空终止字符串，包括对"&TEMP&"之类环境变量的引用
.常量 REG_MULTI_SZ, "7", 公开, 定义包括空终止字符串的数组，数组被两个实际的空字符串结束

.常量 ERROR_MORE_DATA, "234", 公开, 并非所有数据都随此调用一起返回。要获取其他数据，请使用resume句柄再次调用该函数。
.常量 ERROR_NO_MORE_ITEMS, "259", 公开, 没有更多要枚举的条目。

.常量 WS_EX_TOPMOST, "8", 公开, 窗口置顶(停留在所有非最高层窗口的上面)
.常量 WS_DISABLED, "134217728", 公开, 不可用状态

.常量 CDS_FULLSCREEN, "4", 公开, 0x00000004
.常量 CDS_GLOBAL, "8", 公开, 0x00000008
.常量 CDS_UPDATEREGISTRY, "1", 公开, 0x00000001

.常量 WS_EX_ACCEPTFILES, "16", 公开, 窗口接受拖放文件

.常量 HEAP_NO_SERIALIZE, "1", , 指定在RtlAllocateHeap访问堆时不使用互斥。
.常量 HEAP_GENERATE_EXCEPTIONS, "4", , 指定系统将引发异常以指示函数失败（例如内存不足），而不是返回NULL。
.常量 HEAP_ZERO_MEMORY, "8", 公开, 指定分配的内存将初始化为零。否则，内存不会初始化为零。
.常量 REG_OPTION_NON_VOLATILE, "0", 公开, 打开或创建的密钥不是易失性的；系统重新启动时，信息将被保留。
.常量 REG_QWORD, "11", 公开, 一个64位数字。
.常量 托盘事件_移动鼠标, "512", 公开, 移动鼠标
.常量 托盘事件_按下鼠标左键, "513", 公开, 按下鼠标左键
.常量 托盘事件_释放鼠标左键, "514", 公开, 释放鼠标左键
.常量 托盘事件_双击鼠标左键, "515", 公开, 双击鼠标左键
.常量 托盘事件_按下鼠标右键, "516", 公开, 按下鼠标右键
.常量 托盘事件_释放鼠标右键, "517", 公开, 释放鼠标右键
.常量 托盘事件_双击鼠标右键, "518", 公开, 双击鼠标右键
.常量 托盘事件_按下鼠标中键, "519", 公开, 按下鼠标中键
.常量 托盘事件_释放鼠标中键, "520", 公开, 释放鼠标中键
.常量 托盘事件_双击鼠标中键, "521", 公开, 双击鼠标中键
.常量 托盘事件_任务重建, "1120", 公开
.常量 托盘事件_托盘退出, "1130", 公开

.常量 托盘图标_无图标, "0", 公开
.常量 托盘图标_信息图标, "1", 公开
.常量 托盘图标_警告图标, "2", 公开
.常量 托盘图标_错误图标, "3", 公开
.常量 WS_CHILD, "1073741824", 公开
.常量 GW_HWNDLAST, "1", 公开, 检索到的句柄标识Z顺序中最低的同一类型的窗口。如果指定的窗口是最顶部的窗口，则句柄标识Z顺序中最低的最顶部窗口。如果指定的窗口是顶级窗口，则句柄标识Z顺序中最低的顶级窗口。如果指定的窗口是子窗口，则句柄标识Z顺序中最低的同级窗口。
.常量 GW_HWNDNEXT, "2", 公开, 检索到的句柄以Z顺序标识指定窗口下面的窗口。如果指定的窗口是最上面的窗口，则句柄将标识指定窗口下面的最上面的窗口。如果指定的窗口是顶级窗口，则句柄将标识指定窗口下面的顶级窗口。如果指定的窗口是子窗口，则句柄标识指定窗口下面的同级窗口。
.常量 GW_HWNDPREV, "3", 公开, 检索到的句柄以Z顺序标识指定窗口上方的窗口。如果指定的窗口是最顶部的窗口，则句柄标识指定窗口上方的最顶部窗口。如果指定的窗口是顶级窗口，则句柄标识指定窗口上方的顶级窗口。如果指定的窗口是子窗口，则句柄标识指定窗口上方的同级窗口。
.常量 GW_CHILD, "5", 公开, 如果指定的窗口是父窗口，则检索到的句柄标识Z顺序顶部的子窗口；否则，检索到的句柄为空。函数只检查指定窗口的子窗口。它不检查子代窗口。
.常量 GW_ENABLEDPOPUP, "6", 公开, 属于指定窗口的处于状态为弹出式窗口

.常量 BM_CLICK, "245", 公开, 模拟用户点击按钮

.常量 WINHTTP_ACCESS_TYPE_NO_PROXY, "1", 公开, 直接访问，不使用代理。
.常量 WINHTTP_ACCESS_TYPE_DEFAULT_PROXY, "2", 公开, 通过静态代理或注册表配置的代理访问。不继承和不共享IE的代理设置，调用WinHttpSetDefaultProxyConfiguration进行设置。
.常量 WINHTTP_ACCESS_TYPE_NAMED_PROXY, "3", 公开, 通过指定名称的代理访问。
.常量 INTERNET_SCHEME_HTTPS, "2", 公开
.常量 INTERNET_SCHEME_HTTP, "1", 公开
.常量 WINHTTP_NO_REFERER, "0", 公开, 没有来源页面
.常量 WINHTTP_DEFAULT_ACCEPT_TYPES, "0", 公开, 默认文件类型
.常量 WINHTTP_FLAG_SECURE, "8388608", 公开, SSL/TLS安全超文本协议。
.常量 WINHTTP_AUTH_TARGET_SERVER, "0", 公开, 验证目标：网站服务器。
.常量 WINHTTP_AUTH_TARGET_PROXY, "1", 公开, 验证目标：代理服务器。
.常量 WINHTTP_AUTH_SCHEME_BASIC, "1", 公开, 基本认证方式(BASE64加密)。
.常量 WINHTTP_OPTION_DISABLE_FEATURE, "63", 公开, 禁用功能
.常量 WINHTTP_OPTION_ENABLE_FEATURE, "79", 公开
.常量 WINHTTP_DISABLE_COOKIES, "1", 公开, 禁用自动设置COOKIES
.常量 WINHTTP_DISABLE_REDIRECTS, "2", 公开, 禁用重定向
.常量 WINHTTP_OPTION_SECURITY_FLAGS, "31", 公开, 忽略证书错误 #define WINHTTP_OPTION_SECURITY_FLAGS                31


.常量 WINHTTP_ADDREQ_FLAG_ADD, "536870912", 公开, 添加一个协议头，如果协议头已存在则被新值替换，与WINHTTP_ADDREQ_FLAG_REPLACE标志一起使用。
.常量 WINHTTP_ADDREQ_FLAG_REPLACE, "-2147483648", 公开, 替换或者删除一个协议头，如果值为空则删除，否则被替换。
.常量 WINHTTP_QUERY_RAW_HEADERS_CRLF, "22", 公开, 协议头以换行符分割
.常量 WINHTTP_NO_HEADER_INDEX, "0", 公开, 没有协议索引
.常量 WINHTTP_ADDREQ_FLAG_ADD_IF_NEW, "268435456", 公开, 只有不存在的时候才添加
.常量 WINHTTP_ADDREQ_FLAG_COALESCE, "1073741824", 公开, 合并相同的名称
.常量 WINHTTP_ADDREQ_FLAG_COALESCE_WITH_COMMA, "1073741824", 公开, 合并相同的名称使用逗号
.常量 WINHTTP_ADDREQ_FLAG_COALESCE_WITH_SEMICOLON, "16777216", 公开, 合并相投的名称使用分号

.常量 VER_NT_WORKSTATION, "1", 公开, 操作系统为 Windows 8、Windows 7、Windows Vista、Windows XP Professional、Windows XP Home Edition 或 Windows 2000 Professional。
.常量 VER_NT_DOMAIN_CONTROLLER, "2", , 系统为域控制器，操作系统为Windows Server 2012、Windows Server 2008 R2、Windows Server 2008、Windows Server 2003或Windows 2000 Server。
.常量 VER_NT_SERVER, "3", , 操作系统为 Windows Server 2012、Windows Server 2008 R2、Windows Server 2008、Windows Server 2003 或 Windows 2000 Server。
.常量 SystemTimeOfDayInformation, "3", , 系统时间信息
.常量 SystemProcessInformation, "5", 公开, 进程_取父ID
.常量 WH_KEYBOARD, "2", 公开, 安装监视击键消息的钩子过程。有关更多信息，请参阅KeyboardProc hook过程。
.常量 WH_KEYBOARD_LL, "13", 公开, 安装一个钩子过程来监视低级键盘输入事件。有关更多信息，请参阅LowLevelKeyboardProc挂钩过程。
.常量 WH_MOUSE_LL, "14", 公开, 安装监视低级鼠标输入事件的钩子过程。有关更多信息，请参阅LowLevelMouseProc hook过程。
.常量 WH_MOUSE, "7", 公开, 安装监视鼠标消息的钩子过程。有关更多信息，请参阅MouseProc hook过程。
.常量 WH_CBT, "5", , 安装一个钩子程序来接收对 CBT 应用程序有用的通知。有关详细信息，请参阅CBTProc挂钩过程。
.常量 HC_ACTION, "0", 公开
.常量 INVALID_HANDLE_VALUE, "-1", 公开
.常量 SERVICE_INTERACTIVE_PROCESS, "256", 公开
.常量 SERVICE_ALL_ACCESS, "983551", 公开
.常量 SERVICE_ERROR_NORMAL, "1", 公开
.常量 SC_MANAGER_CONNECT, "1", 公开
.常量 SERVICE_ENUMERATE_DEPENDENTS, "8", 公开
.常量 SC_MANAGER_ENUMERATE_SERVICE, "4", 公开
.常量 NIF_INFO, "16", 公开
.常量 NIF_ICON, "2", 公开
.常量 NIF_TIP, "4", 公开
.常量 NIF_MESSAGE, "1", 公开
.常量 STD_OUTPUT_HANDLE, "-11", 公开
.常量 STD_INPUT_HANDLE, "-10", 公开
.常量 EM_REPLACESEL, "194", 公开
.常量 FOREGROUND_RED, "4", 公开
.常量 FOREGROUND_INTENSITY, "8", 公开
.常量 FOREGROUND_GREEN, "2", 公开
.常量 FOREGROUND_BLUE, "1", 公开
.常量 GMEM_MOVEABLE, "2", 公开
.常量 sizeof_SECURITY_ATTRIBUTES, "12", 公开
.常量 HSR_INITIATE, "8", , 迭代操作（由 HttpEndRequest 完成）。

.常量 LIST_MODULES_32BIT, "1", , 列出 32 位模块。
.常量 LIST_MODULES_64BIT, "2", , 列出 64 位模块。
.常量 LIST_MODULES_ALL, "3", , 列出所有模块。
.常量 LIST_MODULES_DEFAULT, "0", , 使用默认行为。

.常量 IP_SUCCESS, "0", 公开
.常量 TIME_FORCE24HOURFORMAT, "8", 公开, 0x00000008 ----强制使用24小时制。

.常量 GWL_EXSTYLE, "-20", 公开, 设置/获取一个新的扩展风格。
.常量 GWL_HINSTANCE, "-6", 公开, 设置/获取一个新的应用程序实例句柄。
.常量 GWL_ID, "-12", 公开, 设置/获取一个新的窗口标识符。
.常量 GWL_STYLE, "-16", 公开, 设置/获取一个新的窗口风格。
.常量 GWL_USERDATA, "-21", 公开, 设置/获取与窗口有关的32位值。每个窗口均有一个由创建该窗口的应用程序使用的32位值。
.常量 GWL_WNDPROC, "-4", 公开, 设置一个新的处理函数。/获得窗口过程的地址，或代表窗口过程的地址的句柄。必须使用CallWindowProc函数调用窗口过程。
.常量 GWL_HWNDPARENT, "-8", 公开, 设置/获取子窗口的父窗口,应使用SetParent函数。

.常量 显示rar窗口, "2", 公开, 普通激活
.常量 隐藏rar窗口, "1", 公开, 隐藏窗口

.常量 系统_ALLUSERSPROFILE, "“ALLUSERSPROFILE”", 公开, 局部 返回所有“用户配置文件”的位置。
.常量 系统_APPDATA, "“APPDATA”", 公开, 局部 返回默认情况下应用程序存储数据的位置。
.常量 系统_CD, "“CD”", 公开, 局部 返回当前目录字符串。
.常量 系统_CMDCMDLINE, "“CMDCMDLINE”", 公开, 局部 返回用来启动当前的 Cmd.exe 的准确命令行。
.常量 系统_CMDEXTVERSION, "“CMDEXTVERSION”", 公开, 系统 返回当前的“命令处理程序扩展”的版本号。
.常量 系统_COMPUTERNAME, "“COMPUTERNAME”", 公开, 系统 返回计算机的名称。
.常量 系统_COMSPEC, "“COMSPEC”", 公开, 系统 返回命令行解释器可执行程序的准确路径。
.常量 系统_DATE, "“DATE”", 公开, 系统 返回当前日期。使用与 date /t 命令相同的格式。由 Cmd.exe 生成。有关 date 命令的详细信息，请参阅 Date。
.常量 系统_ERRORLEVEL, "“ERRORLEVEL”", 公开, 系统 返回使用过的命令的错误代码。通常用非零值表示错误。
.常量 系统_HOMEDRIVE, "“HOMEDRIVE”", 公开, 系统 返回连接到用户主目录的本地工作站驱动器号。基于主目录值的设置。用户主目录是在“本地用户和组”中指定的。
.常量 系统_HOMEPATH, "“HOMEPATH”", 公开, 系统 返回用户主目录的完整路径。基于主目录值的设置。用户主目录是在“本地用户和组”中指定的。
.常量 系统_HOMESHARE, "“HOMESHARE”", 公开, 系统 返回用户的共享主目录的网络路径。基于主目录值的设置。用户主目录是在“本地用户和组”中指定的。
.常量 系统_LOGONSEVER, "“LOGONSEVER”", 公开, 局部 返回验证当前登录会话的域控制器的名称。
.常量 系统_NUMBER_OF_PROCESSORS, "“NUMBER_OF_PROCESSORS”", 公开, 系统 指定安装在计算机上的处理器的数目。
.常量 系统_OS, "“OS”", 公开, 系统 返回操作系统的名称。Windows 2000 将操作系统显示为 Windows_NT。
.常量 系统_PATH, "“PATH”", 公开, 系统 指定可执行文件的搜索路径。
.常量 系统_PATHEXT, "“PATHEXT”", 公开, 系统 返回操作系统认为可执行的文件扩展名的列表。
.常量 系统_PROCESSOR_ARCHITECTURE, "“PROCESSOR_ARCHITECTURE”", 公开, 系统 返回处理器的芯片体系结构。值: x86，IA64。
.常量 系统_PROCESSOR_IDENTIFIER, "“PROCESSOR_IDENTIFIER”", 公开, 系统 返回处理器说明。
.常量 系统_PROCESSOR_LEVEL, "“PROCESSOR_LEVEL”", 公开, 系统 返回计算机上安装的处理器的型号。
.常量 系统_PROCESSOR_REVISION, "“PROCESSOR_REVISION”", 公开, 系统 返回处理器修订号的系统变量。
.常量 系统_PROMPT, "“PROMPT”", 公开, 局部 返回当前解释程序的命令提示符设置。由 Cmd.exe 生成。
.常量 系统_RANDOM, "“RANDOM”", 公开, 系统 返回 0 到 32767 之间的任意十进制数字。由 Cmd.exe 生成。
.常量 系统_SYSTEMDRIVE, "“SYSTEMDRIVE”", 公开, 系统 返回包含 Windows XP 根目录（即系统根目录）的驱动器。
.常量 系统_SYSTEMROOT, "“SYSTEMROOT”", 公开, 系统 返回 Windows XP 根目录的位置。
.常量 系统_TEMP, "“TEMP”", 公开, and %TMP% 系统和用户 返回对当前登录用户可用的应用程序所使用的默认临时目录。有些应用程序需要 TEMP，而其它应用程序则需要 TMP。
.常量 系统_TIME, "“TIME”", 公开, 系统 返回当前时间。使用与 time /t 命令相同的格式。由 Cmd.exe 生成。有关 time 命令的详细信息，请参阅 Time。
.常量 系统_USERDOMAIN, "“USERDOMAIN”", 公开, 局部 返回包含用户帐户的域的名称。
.常量 系统_USERNAME, "“USERNAME”", 公开, 局部 返回当前登录的用户的名称。
.常量 系统_UserProfile, "“UserProfile”", 公开, 局部 返回当前用户的配置文件的位置。
.常量 系统_WINDIR, "“WINDIR”", 公开, 系统 返回操作系统目录的位置。

.常量 PKCS5_PADDING, "1", 公开
.常量 RANDOM_PADDING, "2", 公开
.常量 ZERO_PADDING, "3", 公开

.常量 KP_IV, "1", 公开
.常量 KP_SALT, "2", 公开
.常量 KP_PADDING, "3", 公开
.常量 KP_MODE, "4", 公开
.常量 KP_MODE_BITS, "5", 公开
.常量 KP_PERMISSIONS, "6", 公开
.常量 KP_ALGID, "7", 公开
.常量 KP_BLOCKLEN, "8", 公开
.常量 KP_KEYLEN, "9", 公开
.常量 KP_SALT_EX, "10", 公开
.常量 KP_P, "11", 公开
.常量 KP_G, "12", 公开
.常量 KP_Q, "13", 公开
.常量 KP_X, "14", 公开
.常量 KP_Y, "15", 公开
.常量 KP_RA, "16", 公开
.常量 KP_RB, "17", 公开
.常量 KP_INFO, "18", 公开
.常量 KP_EFFECTIVE_KEYLEN, "19", 公开
.常量 KP_SCHANNEL_ALG, "20", 公开
.常量 KP_CLIENT_RANDOM, "21", 公开
.常量 KP_SERVER_RANDOM, "22", 公开
.常量 KP_RP, "23", 公开
.常量 KP_PRECOMP_MD5, "24", 公开
.常量 KP_PRECOMP_SHA, "25", 公开
.常量 KP_CERTIFICATE, "26", 公开
.常量 KP_CLEAR_KEY, "27", 公开
.常量 KP_PUB_EX_LEN, "28", 公开
.常量 KP_PUB_EX_VAL, "29", 公开
.常量 KP_KEYVAL, "30", 公开
.常量 KP_ADMIN_PIN, "31", 公开
.常量 KP_KEYEXCHANGE_PIN, "32", 公开
.常量 KP_SIGNATURE_PIN, "33", 公开
.常量 KP_PREHASH, "34"
.常量 KP_ROUNDS, "35", 公开
.常量 KP_OAEP_PARAMS, "36", 公开
.常量 KP_CMS_KEY_INFO, "37", 公开
.常量 KP_CMS_DH_KEY_INFO, "38", 公开
.常量 KP_PUB_PARAMS, "39", 公开
.常量 KP_VERIFY_PARAMS, "40", 公开
.常量 KP_HIGHEST_VERSION, "41", 公开
.常量 KP_GET_USE_COUNT, "42", 公开

.常量 SIMPLEBLOB, "1", 公开
.常量 PUBLICKEYBLOB, "6", 公开
.常量 PRIVATEKEYBLOB, "7", 公开
.常量 PLAINTEXTKEYBLOB, "8", 公开
.常量 OPAQUEKEYBLOB, "9", 公开
.常量 PUBLICKEYBLOBEX, "10", 公开
.常量 SYMMETRICWRAPKEYBLOB, "11", 公开

.常量 CUR_BLOB_VERSION, "2", 公开

.常量 HP_HASHVAL, "2", 公开
.常量 CRYPT_MODE_CBC, "1", 公开
.常量 CRYPT_MODE_ECB, "2", 公开
.常量 CRYPT_MODE_OFB, "3", 公开
.常量 CRYPT_MODE_CFB, "4", 公开
.常量 CRYPT_MODE_CTS, "5", 公开

.常量 数据填充_NO_PADDING, "1", 公开
.常量 数据填充_ZERO_PADDING, "2", 公开
.常量 数据填充_ANSIX923_PADDING, "3", 公开
.常量 数据填充_ISO10126_PADDING, "4", 公开
.常量 数据填充_PKCS5_PADDING, "5", 公开
.常量 数据填充_PKCS7_PADDING, "7", 公开

.常量 对称算法_AES_CBC, "“AES-CBC”", 公开
.常量 对称算法_AES_ECB, "“AES-ECB”", 公开
.常量 对称算法_AES_OFB, "“AES-OFB”", 公开, win7 不支持
.常量 对称算法_AES_CFB, "“AES-CFB”", 公开
.常量 对称算法_AES_CTS, "“AES-CTS”", 公开, win7 不支持
.常量 对称算法_AES_192_CBC, "“AES192-CBC”", 公开
.常量 对称算法_AES_192_ECB, "“AES192-ECB”", 公开
.常量 对称算法_AES_192_OFB, "“AES192-OFB”", 公开, win7 不支持
.常量 对称算法_AES_192_CFB, "“AES192-CFB”", 公开
.常量 对称算法_AES_192_CTS, "“AES192-CTS”", 公开, win7 不支持
.常量 对称算法_AES_256_CBC, "“AES256-CBC”", 公开
.常量 对称算法_AES_256_ECB, "“AES256-ECB”", 公开
.常量 对称算法_AES_256_OFB, "“AES256-OFB”", 公开, win7 不支持
.常量 对称算法_AES_256_CFB, "“AES256-CFB”", 公开
.常量 对称算法_AES_256_CTS, "“AES256-CTS”", 公开, win7 不支持
.常量 对称算法_DES_CBC, "“DES-CBC”", 公开
.常量 对称算法_DES_ECB, "“DES-ECB”", 公开
.常量 对称算法_DES_OFB, "“DES-OFB”", 公开, win7 不支持
.常量 对称算法_DES_CFB, "“DES-CFB”", 公开
.常量 对称算法_DES_CTS, "“DES-CTS”", 公开, win7 不支持
.常量 对称算法_3DES_CBC, "“3DES-CBC”", 公开
.常量 对称算法_3DES_ECB, "“3DES-ECB”", 公开
.常量 对称算法_3DES_OFB, "“3DES-OFB”", 公开, win7 不支持
.常量 对称算法_3DES_CFB, "“3DES-CFB”", 公开
.常量 对称算法_3DES_CTS, "“3DES-CTS”", 公开, win7 不支持
.常量 对称算法_RC2, "“RC2”", 公开
.常量 对称算法_RC4, "“RC4”", 公开


.常量 NULL, "0", 公开
.常量 CALG_MD2, "32769", 公开
.常量 CALG_MD4, "32770", 公开
.常量 CALG_MD5, "32771", 公开
.常量 CALG_SHA, "32772", 公开
.常量 CALG_SHA1, "32772", 公开
.常量 CALG_MAC, "32773", 公开
.常量 CALG_RSA_SIGN, "9216", 公开
.常量 CALG_DSS_SIGN, "8704", 公开
.常量 CALG_NO_SIGN, "8192", 公开
.常量 CALG_RSA_KEYX, "41984", 公开
.常量 CALG_DES, "26113", 公开
.常量 CALG_3DES_112, "26121", 公开
.常量 CALG_3DES, "26115", 公开
.常量 CALG_DESX, "26116", 公开
.常量 CALG_RC2, "26114", 公开
.常量 CALG_RC4, "26625", 公开
.常量 CALG_SEAL, "26626", 公开
.常量 CALG_DH_SF, "43521", 公开
.常量 CALG_DH_EPHEM, "43522", 公开
.常量 CALG_AGREEDKEY_ANY, "43523", 公开
.常量 CALG_KEA_KEYX, "43524", 公开
.常量 CALG_HUGHES_MD5, "40963", 公开
.常量 CALG_SKIPJACK, "26122", 公开
.常量 CALG_TEK, "26123", 公开
.常量 CALG_CYLINK_MEK, "26124", 公开
.常量 CALG_SSL3_SHAMD5, "32776", 公开
.常量 CALG_SSL3_MASTER, "19457", 公开
.常量 CALG_SCHANNEL_MASTER_HASH, "19458", 公开
.常量 CALG_SCHANNEL_MAC_KEY, "19459", 公开
.常量 CALG_SCHANNEL_ENC_KEY, "19463", 公开
.常量 CALG_PCT1_MASTER, "19460", 公开
.常量 CALG_SSL2_MASTER, "19461", 公开
.常量 CALG_TLS1_MASTER, "19462", 公开
.常量 CALG_RC5, "26125", 公开
.常量 CALG_HMAC, "32777", 公开
.常量 CALG_TLS1PRF, "32778", 公开
.常量 CALG_HASH_REPLACE_OWF, "32779", 公开
.常量 CALG_AES_128, "26126", 公开
.常量 CALG_AES_192, "26127", 公开
.常量 CALG_AES_256, "26128", 公开
.常量 CALG_AES, "26129", 公开
.常量 CALG_SHA_256, "32780", 公开
.常量 CALG_SHA_384, "32781", 公开
.常量 CALG_SHA_512, "32782", 公开

.常量 CRYPT_VERIFYCONTEXT, "-268435456", 公开
.常量 CRYPT_NEWKEYSET, "8", 公开
.常量 CRYPT_DELETEKEYSET, "16", 公开
.常量 CRYPT_MACHINE_KEYSET, "32", 公开
.常量 CRYPT_SILENT, "64", 公开
.常量 CRYPT_EXPORTABLE, "1", 公开
.常量 CRYPT_USER_PROTECTED, "2", 公开
.常量 CRYPT_CREATE_SALT, "4", 公开
.常量 CRYPT_UPDATE_KEY, "8", 公开
.常量 CRYPT_NO_SALT, "16", 公开
.常量 CRYPT_PREGEN, "64", 公开
.常量 CRYPT_RECIPIENT, "16", 公开
.常量 CRYPT_INITIATOR, "64", 公开
.常量 CRYPT_ONLINE, "128", 公开
.常量 CRYPT_SF, "256", 公开
.常量 CRYPT_CREATE_IV, "512", 公开
.常量 CRYPT_KEK, "1024", 公开
.常量 CRYPT_DATA_KEY, "2048", 公开
.常量 CRYPT_VOLATILE, "4096", 公开
.常量 CRYPT_SGCKEY, "8192", 公开
.常量 CRYPT_ARCHIVABLE, "16384", 公开
.常量 RSA1024BIT_KEY, "67108864", 公开
.常量 CRYPT_SERVER, "1024", 公开
.常量 KEY_LENGTH_MASK, "-65536", 公开
.常量 CRYPT_Y_ONLY, "1", 公开
.常量 CRYPT_SSL2_FALLBACK, "2", 公开
.常量 CRYPT_DESTROYKEY, "4", 公开
.常量 CRYPT_OAEP, "64", 公开
.常量 CRYPT_BLOB_VER3, "128", 公开
.常量 CRYPT_IPSEC_HMAC_KEY, "256", 公开
.常量 CRYPT_DECRYPT_RSA_NO_PADDING_CHECK, "32", 公开
.常量 CRYPT_SECRETDIGEST, "1", 公开
.常量 CRYPT_OWF_REPL_LM_HASH, "1", 公开
.常量 CRYPT_LITTLE_ENDIAN, "1", 公开
.常量 CRYPT_NOHASHOID, "1", 公开
.常量 CRYPT_TYPE2_FORMAT, "2", 公开
.常量 CRYPT_X931_FORMAT, "4", 公开
.常量 CRYPT_MACHINE_DEFAULT, "1", 公开
.常量 CRYPT_USER_DEFAULT, "2", 公开
.常量 CRYPT_DELETE_DEFAULT, "4", 公开

.常量 PROV_RSA_FULL, "1", 公开
.常量 PROV_RSA_SIG, "2", 公开
.常量 PROV_DSS, "3", 公开
.常量 PROV_FORTEZZA, "4", 公开
.常量 PROV_MS_EXCHANGE, "5", 公开
.常量 PROV_SSL, "6", 公开
.常量 PROV_RSA_SCHANNEL, "12", 公开
.常量 PROV_DSS_DH, "13", 公开
.常量 PROV_EC_ECDSA_SIG, "14", 公开
.常量 PROV_EC_ECNRA_SIG, "15", 公开
.常量 PROV_EC_ECDSA_FULL, "16", 公开
.常量 PROV_EC_ECNRA_FULL, "17", 公开
.常量 PROV_DH_SCHANNEL, "18", 公开
.常量 PROV_SPYRUS_LYNKS, "20", 公开
.常量 PROV_RNG, "21", 公开
.常量 PROV_INTEL_SEC, "22", 公开
.常量 PROV_REPLACE_OWF, "23", 公开
.常量 PROV_RSA_AES, "24", 公开


.常量 OBJID_WINDOW, "0", 公开

.常量 ROLE_SYSTEM_TITLEBAR, "1", 公开
.常量 ROLE_SYSTEM_MENUBAR, "2", 公开
.常量 ROLE_SYSTEM_SCROLLBAR, "3", 公开
.常量 ROLE_SYSTEM_GRIP, "4", 公开
.常量 ROLE_SYSTEM_SOUND, "5", 公开
.常量 ROLE_SYSTEM_CURSOR, "6", 公开
.常量 ROLE_SYSTEM_CARET, "7", 公开
.常量 ROLE_SYSTEM_ALERT, "8", 公开
.常量 ROLE_SYSTEM_WINDOW, "9", 公开
.常量 ROLE_SYSTEM_CLIENT, "10", 公开
.常量 ROLE_SYSTEM_MENUPOPUP, "11", 公开
.常量 ROLE_SYSTEM_MENUITEM, "12", 公开
.常量 ROLE_SYSTEM_TOOLTIP, "13", 公开
.常量 ROLE_SYSTEM_APPLICATION, "14", 公开
.常量 ROLE_SYSTEM_DOCUMENT, "15", 公开
.常量 ROLE_SYSTEM_PANE, "16", 公开
.常量 ROLE_SYSTEM_CHART, "17", 公开
.常量 ROLE_SYSTEM_DIALOG, "18", 公开
.常量 ROLE_SYSTEM_BORDER, "19", 公开
.常量 ROLE_SYSTEM_GROUPING, "20", 公开
.常量 ROLE_SYSTEM_SEPARATOR, "21", 公开
.常量 ROLE_SYSTEM_TOOLBAR, "22", 公开
.常量 ROLE_SYSTEM_STATUSBAR, "23", 公开
.常量 ROLE_SYSTEM_TABLE, "24", 公开
.常量 ROLE_SYSTEM_COLUMNHEADER, "25", 公开
.常量 ROLE_SYSTEM_ROWHEADER, "26", 公开
.常量 ROLE_SYSTEM_COLUMN, "27", 公开
.常量 ROLE_SYSTEM_ROW, "28", 公开
.常量 ROLE_SYSTEM_CELL, "29", 公开
.常量 ROLE_SYSTEM_LINK, "30", 公开
.常量 ROLE_SYSTEM_HELPBALLOON, "31", 公开
.常量 ROLE_SYSTEM_CHARACTER, "32", 公开
.常量 ROLE_SYSTEM_LIST, "33", 公开
.常量 ROLE_SYSTEM_LISTITEM, "34", 公开
.常量 ROLE_SYSTEM_OUTLINE, "35", 公开
.常量 ROLE_SYSTEM_OUTLINEITEM, "36", 公开
.常量 ROLE_SYSTEM_PAGETAB, "37", 公开
.常量 ROLE_SYSTEM_PROPERTYPAGE, "38", 公开
.常量 ROLE_SYSTEM_INDICATOR, "39", 公开
.常量 ROLE_SYSTEM_GRAPHIC, "40", 公开
.常量 ROLE_SYSTEM_STATICTEXT, "41", 公开
.常量 ROLE_SYSTEM_TEXT, "42", 公开
.常量 ROLE_SYSTEM_PUSHBUTTON, "43", 公开
.常量 ROLE_SYSTEM_CHECKBUTTON, "44", 公开
.常量 ROLE_SYSTEM_RADIOBUTTON, "45", 公开
.常量 ROLE_SYSTEM_COMBOBOX, "46", 公开
.常量 ROLE_SYSTEM_DROPLIST, "47", 公开
.常量 ROLE_SYSTEM_PROGRESSBAR, "48", 公开
.常量 ROLE_SYSTEM_DIAL, "49", 公开
.常量 ROLE_SYSTEM_HOTKEYFIELD, "50", 公开
.常量 ROLE_SYSTEM_SLIDER, "51", 公开
.常量 ROLE_SYSTEM_SPINBUTTON, "52", 公开
.常量 ROLE_SYSTEM_DIAGRAM, "53", 公开
.常量 ROLE_SYSTEM_ANIMATION, "54", 公开
.常量 ROLE_SYSTEM_EQUATION, "55", 公开
.常量 ROLE_SYSTEM_BUTTONDROPDOWN, "56", 公开
.常量 ROLE_SYSTEM_BUTTONMENU, "57", 公开
.常量 ROLE_SYSTEM_BUTTONDROPDOWNGRID, "58", 公开
.常量 ROLE_SYSTEM_WHITESPACE, "59", 公开
.常量 ROLE_SYSTEM_PAGETABLIST, "60", 公开
.常量 ROLE_SYSTEM_CLOCK, "61", 公开
.常量 ROLE_SYSTEM_SPLITBUTTON, "62", 公开
.常量 ROLE_SYSTEM_IPADDRESS, "63", 公开
.常量 ROLE_SYSTEM_OUTLINEBUTTON, "64", 公开

.常量 STATE_SYSTEM_NORMAL, "0", 公开
.常量 STATE_SYSTEM_UNAVAILABLE, "1", 公开
.常量 STATE_SYSTEM_SELECTED, "2", 公开
.常量 STATE_SYSTEM_FOCUSED, "4", 公开
.常量 STATE_SYSTEM_PRESSED, "8", 公开
.常量 STATE_SYSTEM_CHECKED, "16", 公开
.常量 STATE_SYSTEM_MIXED, "32", 公开
.常量 STATE_SYSTEM_READONLY, "64", 公开
.常量 STATE_SYSTEM_HOTTRACKED, "128", 公开
.常量 STATE_SYSTEM_DEFAULT, "256", 公开
.常量 STATE_SYSTEM_EXPANDED, "512", 公开
.常量 STATE_SYSTEM_COLLAPSED, "1024", 公开
.常量 STATE_SYSTEM_BUSY, "2048", 公开
.常量 STATE_SYSTEM_FLOATING, "4096", 公开
.常量 STATE_SYSTEM_MARQUEED, "8192", 公开
.常量 STATE_SYSTEM_ANIMATED, "16384", 公开
.常量 STATE_SYSTEM_INVISIBLE, "32768", 公开
.常量 STATE_SYSTEM_OFFSCREEN, "65536", 公开
.常量 STATE_SYSTEM_SIZEABLE, "131072", 公开
.常量 STATE_SYSTEM_MOVEABLE, "262144", 公开
.常量 STATE_SYSTEM_SELFVOICING, "524288", 公开
.常量 STATE_SYSTEM_FOCUSABLE, "1048576", 公开
.常量 STATE_SYSTEM_SELECTABLE, "2097152", 公开
.常量 STATE_SYSTEM_LINKED, "4194304", 公开
.常量 STATE_SYSTEM_TRAVERSED, "8388608", 公开
.常量 STATE_SYSTEM_MULTISELECTABLE, "16777216", 公开
.常量 STATE_SYSTEM_EXTSELECTABLE, "33554432", 公开
.常量 STATE_SYSTEM_ALERT_LOW, "67108864", 公开
.常量 STATE_SYSTEM_ALERT_MEDIUM, "134217728", 公开
.常量 STATE_SYSTEM_ALERT_HIGH, "268435456", 公开
.常量 STATE_SYSTEM_PROTECTED, "536870912", 公开

.常量 SELFLAG_NONE, "0", 公开
.常量 SELFLAG_TAKEFOCUS, "1", 公开
.常量 SELFLAG_TAKESELECTION, "2", 公开
.常量 SELFLAG_EXTENDSELECTION, "4", 公开
.常量 SELFLAG_ADDSELECTION, "8", 公开
.常量 SELFLAG_REMOVESELECTION, "16", 公开

.常量 NAVDIR_MIN, "0"
.常量 NAVDIR_UP, "1", 公开
.常量 NAVDIR_DOWN, "2", 公开
.常量 NAVDIR_LEFT, "3", 公开
.常量 NAVDIR_RIGHT, "4", 公开
.常量 NAVDIR_NEXT, "5", 公开
.常量 NAVDIR_PREVIOUS, "6", 公开
.常量 NAVDIR_FIRSTCHILD, "7", 公开
.常量 NAVDIR_LASTCHILD, "8", 公开
.常量 NAVDIR_MAX, "9"

.常量 STATUS_INVALID_HANDLE, "-1073741816", , 指定了无效的句柄。
.常量 STATUS_INFO_LENGTH_MISMATCH, "-1073741820", 公开, 指定的信息记录长度与指定信息类所需的长度不匹配。
.常量 STATUS_SUCCESS, "0", 公开, 操作成功完成。
.常量 STATUS_PENDING, "259", , 请求的操作正在等待完成。
.常量 STATUS_INVALID_PARAMETER, "-1073741811", 公开
.常量 OBJ_INHERIT, "2", 公开
.常量 DUPLICATE_CLOSE_SOURCE, "1", 公开
.常量 DUPLICATE_SAME_ACCESS, "2", 公开
.常量 DUPLICATE_SAME_ATTRIBUTES, "4", 公开
.常量 OB_TYPE_PROCESS, "5", 公开
.常量 ZwGetCurrentProcess, "-1", 公开
.常量 JOB_OBJECT_ALL_ACCESS, "2031647", 公开

.常量 MEM_COMMIT, "4096", 公开, 指示已在内存或磁盘上的分页文件中为其分配物理存储的提交页。
.常量 MEM_RESERVE, "8192", , 指示保留页，其中保留了一系列进程的虚拟地址空间，而未分配任何物理存储。对于保留页，未定义保护成员中的信息。
.常量 TB_BUTTONCOUNT, "1048", 公开
.常量 TB_GETBUTTON, "1047", 公开
.常量 TB_DELETEBUTTON, "1046", 公开
.常量 TB_GETSTATE, "1042", , 取按钮状态
.常量 TB_SETSTATE, "1041", , 设置按钮状态
.常量 TB_GETBUTTONTEXTA, "1069", , 取工具条按钮标题
.常量 TB_GETHOTITEM, "1095"
.常量 TB_ENABLEBUTTON, "1025", , 取工具条按钮命令ID
.常量 MEM_RELEASE, "32768", 公开, 释放指定的页面区域或占位符
.常量 CP_ACP, "0", 公开
.常量 PAGE_EXECUTE_READWRITE, "64", 公开

.常量 CLSID_TaskbarList, "“{56FDF344-FD6D-11d0-958A-006097C9A090}”", 公开
.常量 IID_ITaskbarList, "“{56FDF342-FD6D-11d0-958A-006097C9A090}”", 公开
.常量 IID_ITaskbarList2, "“{602D4995-B13A-429b-A66E-1935E44F4317}”", 公开
.常量 IID_ITaskbarList3, "“{EA1AFB91-9E28-4B86-90E9-9E9F8A5EEFAF}”", 公开
.常量 CLSCTX_INPROC_SERVER, "1", 公开, 创建和管理此类对象的代码是一个 DLL，它与指定类上下文的函数调用者在同一进程中运行。
.常量 CLSCTX_ALL, "23", , 显示所有类上下文。

.常量 任务栏进度_无, "0", 公开, TBPF_NOPROGRESS
.常量 任务栏进度_不确定, "1", 公开, TBPF_INDETERMINATE
.常量 任务栏进度_正常, "2", 公开, TBPF_NORMAL
.常量 任务栏进度_错误, "4", 公开, TBPF_ERROR
.常量 任务栏进度_暂停, "8", 公开, TBPF_PAUSED

.常量 WM_NULL, "0", 公开
.常量 WM_DROPFILES, "563", , 当用户在应用程序的窗口上放置文件时发送，该应用程序已将自身注册为放置文件的接收者。
.常量 WM_COPYGLOBALDATA, "73"
.常量 WM_COPYDATA, "74", , 一个应用程序发送WM_COPYDATA消息以将数据传递给另一个应用程序。
.常量 WM_DESTROY, "2", 公开
.常量 MSGFLT_ADD, "1", 公开, 将消息添加到过滤器。这具有允许接收消息的效果。
.常量 WM_KEYDOWN, "256", , 当一个非系统按键被按下时(<ALT>键没有被按下),会发送本消息给拥有键盘焦点的窗口
.常量 WM_KEYUP, "257", , 当一个非系统按键被释放弹起时(<ALT>键没有被按下),会发送本消息给拥有键盘焦点的窗口
.常量 WM_CHAR, "258", , 按下某按键,并已发出WM_KEYDOWN、WM_KEYUP消息,本消息包含被按下的按键的字符码
.常量 WM_SYSKEYDOWN, "260", , 当用户按住 Alt 键，然后按另一个键时，将发布到具有键盘焦点的窗口。 
.常量 WM_SYSKEYUP, "261", , 当用户释放按下 Alt 键时按下的键时，发布到具有键盘焦点的窗口。 
.常量 WM_COMMAND, "273", 公开
.常量 WM_SYSCOMMAND, "274", , 当用户选择窗口菜单的一条命令或当用户选择最大化或最小化时那个窗口会收到此消息
.常量 WM_MOUSEMOVE, "512", , 移动鼠标
.常量 WM_WTSSESSION_CHANGE, "689", , 2B1h
.常量 WM_COPY, "769", 公开, 程序发送此消息给一个编辑框或combobox来复制当前选择的文本到剪贴板
.常量 WM_SETICON, "128", 公开, 程序发送此消息让一个新的大图标或小图标与某个窗口关联
.常量 WM_DRAWCLIPBOARD, "776", 公开, 当剪贴板的内容变化时发送此消息给剪贴板观察链的第一个窗口;它允许用剪贴板观察窗口来显示剪贴板的新内容
.常量 WM_CHANGECBCHAIN, "781", 公开, 当一个窗口从剪贴板观察链中移去时发送此消息给剪贴板观察链的第一个窗口
.常量 WM_HOTKEY, "786", , 当用户按下RegisterHotKey功能注册的热键时，会显示热键消息。该消息位于与注册热键的线程关联的消息队列的顶部。
.常量 SC_CLOSE, "61536", , 关闭窗口
.常量 SC_MINIMIZE, "61472", , 最小化窗口
.常量 SC_MAXIMIZE, "61488", , 最大化窗口
.常量 THBN_CLICKED, "6144", 公开

.常量 缩略图按钮掩码_图片索引, "1", 公开, THB_BITMAP “图片索引”成员有效
.常量 缩略图按钮掩码_图标句柄, "2", 公开, THB_ICON
.常量 缩略图按钮掩码_提示文本, "4", 公开, THB_TOOLTIP
.常量 缩略图按钮掩码_按钮风格, "8", 公开, THB_FLAGS

.常量 缩略图按钮_可用, "0", 公开, THBF_ENABLED
.常量 缩略图按钮_禁止, "1", 公开, THBF_DISABLED
.常量 缩略图按钮_点击关闭, "2", 公开, THBF_DISMISSONCLICK
.常量 缩略图按钮_无背景, "4", 公开, THBF_NOBACKGROUND
.常量 缩略图按钮_隐藏, "8", 公开, THBF_HIDDEN
.常量 缩略图按钮_无交互按钮, "16", 公开, THBF_NONINTERACTIVE

.常量 GMEM_ZEROINIT, "64", 公开

.常量 MN_GETHMENU, "481", 公开
.常量 WM_ENTERIDLE, "289", 公开
.常量 MSGF_MENU, "2", 公开
.常量 MF_SEPARATOR, "2048", 公开, 绘制一条水平分割线
.常量 MF_STRING, "0", 公开, 指定菜单项是文本字符串
.常量 WM_CONTEXTMENU, "123", 公开
.常量 WM_NCHITTEST, "132", 公开, 移动鼠标，按住或释放鼠标时发生
.常量 WM_NCLBUTTONDOWN, "161", , 当光标在一个窗口的非客户区同时按下鼠标左键时提交此消息
.常量 MF_BYPOSITION, "1024", 公开, 指示 uPosition 参数为新菜单项提供从零开始的相对位置
.常量 MF_POPUP, "16", 公开, 指定菜单项打开下拉菜单或子菜单
.常量 HTHSCROLL, "6", , 在水平滚动条中
.常量 HTVSCROLL, "7", 公开, 在垂直滚动条中

.常量 FILE_SUPPORTS_SPARSE_FILES, "64", 公开
.常量 FSCTL_SET_SPARSE, "590020", 公开
.常量 FILE_ATTRIBUTE_SPARSE_FILE, "512", 公开
.常量 GENERIC_READ_, "2147483648", 公开
.常量 FILE_SHARE_READ, "1", 公开, 在文件或设备上启用后续打开操作，以请求读取访问权限。
.常量 FILE_SHARE_WRITE, "2", 公开, 在文件或设备上启用后续打开操作以请求写访问权限。
.常量 OPEN_EXISTING, "3", 公开, 仅打开文件或设备（如果存在）。


.常量 FEATURE_DISABLE_NAVIGATION_SOUNDS, "21", 公开, 禁止跳转声音
.常量 SET_FEATURE_ON_PROCESS, "2", 公开, 仅对当前进程有效

.常量 FORMAT_MESSAGE_FROM_SYSTEM, "4096", 公开
.常量 FORMAT_MESSAGE_IGNORE_INSERTS, "512", 公开
.常量 FORMAT_MESSAGE_ALLOCATE_BUFFER, "256"
.常量 FORMAT_MESSAGE_FROM_HMODULE, "2048"

.常量 TCM_FIRST, "4864", 公开
.常量 CCM_FIRST, "8192", 公开
.常量 CCM_GETUNICODEFORMAT, "8198", 公开
.常量 CCM_SETUNICODEFORMAT, "8197", 公开

.常量 TCM_ADJUSTRECT, "4904", 公开, 调整矩形
.常量 TCM_DELETEALLITEMS, "4873", 公开, 删除全部子夹
.常量 TCM_DELETEITEM, "4872", 公开, 删除子夹
.常量 TCM_DESELECTALL, "4914", 公开, 全部取消选择
.常量 TCM_GETCURFOCUS, "4911", 公开, 获取光标焦点
.常量 TCM_GETCURSEL, "4875", 公开, 获取光标XXX？
.常量 TCM_GETEXTENDEDSTYLE, "4917", 公开, 取扩展风格
.常量 TCM_GETIMAGELIST, "4866", 公开, 取项目图片列表
.常量 TCM_GETITEMA, "4869", 公开, 取项目
.常量 TCM_GETITEMCOUNT, "4868", 公开, 取项目数
.常量 TCM_GETITEMRECT, "4874", 公开, 取项目矩形
.常量 TCM_GETROWCOUNT, "4908", 公开, 取行数
.常量 TCM_GETTOOLTIPS, "4909", 公开, 取工具条提示
.常量 TCM_GETUNICODEFORMAT, "8198", 公开, 取UNICODE格式
.常量 TCM_HIGHLIGHTITEM, "4915", 公开
.常量 TCM_HITTEST, "4877", 公开, 点击测试
.常量 TCM_INSERTITEMA, "4871", 公开, 插入子夹
.常量 TCM_REMOVEIMAGE, "4906", 公开, 移动图片
.常量 TCM_SETCURFOCUS, "4912", 公开, 置光标焦点
.常量 TCM_SETCURSEL, "4876", 公开, 置光标XXX？
.常量 TCM_SETEXTENDEDSTYLE, "4916", 公开, 置扩展风格
.常量 TCM_SETIMAGELIST, "4867", 公开, 置图片列表
.常量 TCM_SETITEMA, "4870", 公开, 置项目
.常量 TCM_SETITEMEXTRA, "4878", 公开, 置额外项目
.常量 TCM_SETITEMSIZE, "4905", 公开, 置项目尺寸
.常量 TCM_SETMINTABWIDTH, "4913", 公开, 置子夹栏最小宽度值
.常量 TCM_SETPADDING, "4907", 公开, 置子夹栏尺寸
.常量 TCM_SETTOOLTIPS, "4910", 公开, 置工具提示
.常量 TCM_SETUNICODEFORMAT, "8197", 公开, 置UNICODE格式

.常量 TCIF_IMAGE, "2", 公开, 项目图片
.常量 TCIF_PARAM, "8", 公开, 项目数值
.常量 TCIF_RTLREADING, "4", 公开, 项目右对齐
.常量 TCIF_STATE, "16", 公开, 状态
.常量 TCIF_TEXT, "1", 公开, 项目文本

.常量 WM_MEASUREITEM, "44", 公开
.常量 WM_WINDOWPOSCHANGED, "71", 公开
.常量 LVS_OWNERDRAWFIXED, "1024", 公开
.常量 CF_LIMITSIZE, "8192", 公开


.常量 HWND_TOP, "0", 公开, 将窗口置于Z顺序的顶部。
.常量 HWND_BOTTOM, "1", , 将窗口置于Z顺序的底部。如果hWnd参数标识了最顶部的窗口，则该窗口将失去其最顶部的状态，并放置在所有其他窗口的底部。
.常量 SWP_NOMOVE, "2", 公开, 维持当前位置（忽略X和Y参数）
.常量 SWP_NOSIZE, "1", 公开, 维持当前尺寸（忽略cx和Cy参数）
.常量 SWP_SHOWWINDOW, "64", , 显示窗口。
.常量 SWP_NOACTIVATE, "16", 公开, 不激活窗口。如果未设置此标志，则激活窗口并将其移到最顶层或非顶层组的顶部（取决于hWndInsertAfter参数的设置）。
.常量 SWP_HIDEWINDOW, "128", , 隐藏窗口。
.常量 SWP_NOZORDER, "4", , 保留当前的Z顺序（忽略hWndInsertAfter参数）。
.常量 HWND_TOPMOST, "-1", 公开, 将窗口置于所有非最上面的窗口上方。即使禁用窗口，窗口也将保持其最高位置。
.常量 HWND_NOTOPMOST, "-2", 公开, 将窗口置于所有非最上面的窗口上方（即，所有最上面的窗口的后面）。如果窗口已经是非最上面的窗口，则此标志无效。
.常量 WS_EX_LAYERED, "524288", 公开, 分层或透明窗口,该样式可使用混合特效
.常量 WS_EX_TRANSPARENT, "32", 公开, 透明样式,在同属窗口已重画时该窗口才可重画
.常量 WS_EX_NOACTIVATE, "134217728", 公开, 处于顶层但不激活
.常量 WM_XBUTTONDOWN, "523", , 按下了一个X鼠标键。
.常量 WM_XBUTTONUP, "524", , 释放了一个X鼠标按钮。

.常量 WM_MBUTTONDBLCLK, "521", 公开, 双击鼠标中键
.常量 WM_RBUTTONUP, "517", 公开, 释放鼠标右键
.常量 WM_MBUTTONUP, "520", 公开, 释放鼠标中键
.常量 WM_MBUTTONDOWN, "519", 公开, 按下鼠标中键
.常量 WM_RBUTTONDBLCLK, "518", 公开, 双击鼠标右键
.常量 WM_RBUTTONDOWN, "516", 公开, 按下鼠标右键
.常量 WM_LBUTTONDBLCLK, "515", 公开, 双击鼠标左键
.常量 WM_LBUTTONUP, "514", 公开, 释放鼠标左键
.常量 WM_LBUTTONDOWN, "513", 公开, 按下鼠标左键
.常量 WM_MOUSEWHEEL, "522", 公开, 当鼠标轮子转动时发送此消息个当前有焦点的控件

.常量 DWM_BB_ENABLE, "1", 公开
.常量 DWM_BB_BLURREGION, "2", 公开
.常量 DWM_BB_TRANSITIONONMAXIMIZED, "4", 公开


.常量 DWMWA_NCRENDERING_ENABLED, "1", 公开
.常量 DWMWA_NCRENDERING_POLICY, "2", 公开
.常量 DWMWA_TRANSITIONS_FORCEDISABLED, "3", 公开
.常量 DWMWA_ALLOW_NCPAINT, "4", 公开
.常量 DWMWA_CAPTION_BUTTON_BOUNDS, "5", 公开
.常量 DWMWA_NONCLIENT_RTL_LAYOUT, "6", 公开
.常量 DWMWA_FORCE_ICONIC_REPRESENTATION, "7", 公开
.常量 DWMWA_FLIP3D_POLICY, "8", 公开
.常量 DWMWA_EXTENDED_FRAME_BOUNDS, "9", 公开
.常量 DWMWA_LAST, "10", 公开
.常量 DWMWA_USE_IMMERSIVE_DARK_MODE, "20", , 启用深色模式系统设置时，允许以深色模式颜色绘制此窗口的窗口框架。

.常量 DWMNCRP_USEWINDOWSTYLE, "0", 公开
.常量 DWMNCRP_DISABLED, "1", 公开
.常量 DWMNCRP_ENABLED, "2", 公开
.常量 DWMNCRP_LAST, "3", 公开

.常量 DWMFLIP3D_DEFAULT, "0", 公开
.常量 DWMFLIP3D_EXCLUDEBELOW, "1", 公开
.常量 DWMFLIP3D_EXCLUDEABOVE, "2", 公开
.常量 DWMFLIP3D_LAST, "3", 公开

.常量 DWM_TNP_RECTDESTINATION, "1", 公开
.常量 DWM_TNP_RECTSOURCE, "2", 公开
.常量 DWM_TNP_OPACITY, "4", 公开
.常量 DWM_TNP_VISIBLE, "8", 公开
.常量 DWM_TNP_SOURCECLIENTAREAONLY, "16", 公开

.常量 DWM_SOURCE_FRAME_SAMPLING_POINT, "0", 公开
.常量 DWM_SOURCE_FRAME_SAMPLING_COVERAGE, "1", 公开
.常量 DWM_SOURCE_FRAME_SAMPLING_LAST, "2", 公开

.常量 DWM_EC_DISABLECOMPOSITION, "0", 公开
.常量 DWM_EC_ENABLECOMPOSITION, "1", 公开

.常量 单位_世界坐标, "0", 公开, // 0 -- World coordinate (non-physical unit)
.常量 单位_Display, "1", 公开, // 1 -- Variable -- for PageTransform only
.常量 单位_像素, "2", 公开, // 2 -- Each unit is one device pixel.像素
.常量 单位_点, "3", 公开, // 3 -- Each unit is a printer's point 点
.常量 单位_英寸, "4", 公开, // 4 -- Each unit is 1 inch.英寸
.常量 单位_Document, "5", 公开, // 5 -- Each unit is 1/300 inch.
.常量 单位_毫米, "6", 公开, // 6 -- Each unit is 1 millimeter.毫米


.常量 像素格式_Indexed, "65536", 公开, Indexed 该像素数据包含颜色索引值，这意味着这些值是系统颜色表中颜色的索引，而不是单个颜色值。
.常量 像素格式_GDI, "131072", 公开, Gdi 像素数据包含 GDI 颜色。
.常量 像素格式_Alpha, "262144", 公开, Alpha 像素数据包含没有进行过自左乘的 alpha 值。
.常量 像素格式_PAlpha, "524288", 公开, PAlpha 像素格式包含自左乘的 alpha 值。
.常量 像素格式_Extended, "1048576", 公开, Extended 保留。
.常量 像素格式_Canonical, "2097152", 公开, Canonical 保留。
.常量 像素格式_Undefined, "0", 公开, Undefined 未定义像素格式。
.常量 像素格式_DontCare, "0", 公开, DontCare 没有指定像素格式。
.常量 像素格式_1bppIndexed, "196865", 公开, Format1bppIndexed 指定像素格式为每像素 1 位，并指定它使用索引颜色。因此颜色表中有两种颜色。
.常量 像素格式_4bppIndexed, "197634", 公开, Format4bppIndexed 指定格式为每像素 4 位而且已创建索引。
.常量 像素格式_8bppIndexed, "198659", 公开, Format8bppIndexed 指定格式为每像素 8 位而且已创建索引。因此颜色表中有 256 种颜色。
.常量 像素格式_16bppGrayScale, "1052676", 公开, Format16bppGrayScale 像素格式为每像素 16 位。该颜色信息指定 65536 种灰色调。
.常量 像素格式_16bppRGB555, "135173", 公开, Format16bppRgb555 指定格式为每像素 16 位；红色、绿色和蓝色分量各使用 5 位。剩余的 1 位未使用。
.常量 像素格式_16bppRGB565, "135174", 公开, Format16bppRgb565 指定格式为每像素 16 位；红色分量使用 5 位，绿色分量使用 6 位，蓝色分量使用 5 位。
.常量 像素格式_16bppARGB1555, "397319", 公开, Format16bppArgb1555 像素格式为每像素 16 位。该颜色信息指定 32
.常量 像素格式_24bppRGB, "137224", 公开, Format24bppRgb 指定格式为每像素 24 位；红色、绿色和蓝色分量各使用 8 位。
.常量 像素格式_32bppRGB, "139273", 公开, Format32bppRgb 指定格式为每像素 32 位；红色、绿色和蓝色分量各使用 8 位。剩余的 8 位未使用。
.常量 像素格式_32bppARGB, "2498570", 公开, Format32bppArgb 指定格式为每像素 32 位；alpha、红色、绿色和蓝色分量各使用 8 位。
.常量 像素格式_32bppPARGB, "925707", 公开, Format32bppPArgb 指定格式为每像素 32 位；alpha、红色、绿色和蓝色分量各使用 8 位。根据 alpha 分量，对红色、绿色和蓝色分量进行自左乘。
.常量 像素格式_48bppRGB, "1060876", 公开, Format48bppRgb 指定格式为每像素 48 位；红色、绿色和蓝色分量各使用 16 位。
.常量 像素格式_64bppARGB, "3424269", 公开, Format64bppArgb 指定格式为每像素 64 位；alpha、红色、绿色和蓝色分量各使用 16 位。
.常量 像素格式_64bppPARGB, "1851406", 公开, Format64bppPArgb 指定格式为每像素 64 位；alpha、红色、绿色和蓝色分量各使用 16 位。根据 alpha 分量，对红色、绿色和蓝色分量进行自左乘。
.常量 像素格式_Max, "15", 公开, Max 此枚举的最大值。



.常量 SB_THUMBPOSITION, "4", , 用户已拖动滚动框（拇指）并释放鼠标按钮。HIWORD表示拖动操作结束时滚动框的位置。
.常量 SIF_DISABLENOSCROLL, "8", 公开
.常量 SIF_PAGE, "2", 公开
.常量 SIF_POS, "4", 公开
.常量 SIF_TRACKPOS, "16", 公开
.常量 SIF_RANGE, "1", 公开
.常量 SIF_ALL, "23", 公开
.常量 OBJID_VSCROLL, "-5", 公开

.常量 WM_SETREDRAW, "11", , 设置窗口是否能重画
.常量 TVM_GETNEXTITEM, "4362", , 检索与指定项具有指定关系的树视图项。
.常量 TVM_GETITEMA, "4364", , 检索树视图项的部分或全部属性。
.常量 TVM_GETCOUNT, "4357", , 检索树视图控件中项目的计数。
.常量 TVM_HITTEST, "4369", , 确定指定点相对于树视图控件客户区的位置。
.常量 TVM_GETITEMW, "4414", , 检索树视图项的部分或全部属性。
.常量 TVM_SETITEMW, "4415", , 该TVM_SETITEM消息设置的部分或全部树视图项的属性。
.常量 TVM_ENSUREVISIBLE, "4372", , 确保树视图项可见，如有必要，展开父项或滚动树视图控件。
.常量 TVM_EXPAND, "4354", , 该TVM_EXPAND消息展开或折叠与指定父项相关的子项，如有的名单。
.常量 TVM_GETIMAGELIST, "4360", , 检索与树视图控件关联的正常或状态图像列表的句柄。
.常量 TVM_CREATEDRAGIMAGE, "4370", , 为树视图控件中的指定项创建拖动位图。
.常量 TVM_SORTCHILDREN, "4371", , 对树视图控件中指定父项的子项进行排序。
.常量 TVM_INSERTITEMW, "4402", , 在树视图控件中插入一个新项目。
.常量 TVM_DELETEITEM, "4353", , 从树视图控件中删除项目及其所有子项。
.常量 TVM_GETITEMSTATE, "4391", , 检索树视图项的部分或全部状态属性。
.常量 TVM_SETBKCOLOR, "4381", , 设置控件的背景颜色。
.常量 TVM_GETBKCOLOR, "4383", , 检索控件的当前背景颜色。
.常量 TVM_SETITEMHEIGHT, "4379", , 设置树视图项的高度。
.常量 TVM_GETITEMHEIGHT, "4380", , 检索每个树视图项的当前高度。
.常量 TVM_SETTEXTCOLOR, "4382", , 设置控件的文本颜色。
.常量 TVM_GETTEXTCOLOR, "4384", , 设置控件的文本颜色。
.常量 TVM_SETLINECOLOR, "4392", , 所述TVM_SETLINECOLOR消息设置当前行的颜色。
.常量 TVM_GETLINECOLOR, "4393", , 该TVM_GETLINECOLOR消息获取当前线条颜色。
.常量 TVE_COLLAPSE, "1", , 折叠列表。
.常量 TVE_EXPAND, "2", , 展开列表。
.常量 TVGN_ROOT, "0", , 检索树视图控件的最顶部或第一个项目。
.常量 TVGN_PARENT, "3", , 检索指定项的父项。
.常量 TVGN_CHILD, "4", , 检索由hitem参数指定的项目的第一个子项目。
.常量 TVGN_NEXT, "1", , 检索下一个同级项。
.常量 TVGN_FIRSTVISIBLE, "5", , 检索在树视图窗口中可见的第一个项目。
.常量 TVGN_DROPHILITE, "8", , 检索作为拖放操作目标的项。
.常量 TVGN_CARET, "9", , 检索当前选定的项目。
.常量 TVIF_TEXT, "1", , 该 pszText和 cchTextMax定义成员是有效的。
.常量 TVI_ROOT, "4294901760", , 在根部插入
.常量 TVIF_PARAM, "4", , 项目数值
.常量 TVIF_IMAGE, "2", , 该 IIMAGE成员是有效的。
.常量 TVIF_SELECTEDIMAGE, "32", , 该 iSelectedImage成员是有效的。
.常量 TVI_FIRST, "4294901761", , 在列表首部加入
.常量 TVI_LAST, "4294901762", , 在列表尾部插入
.常量 TVI_SORT, "4294901763", , 插入项目时按字母顺序排列
.常量 TVIF_ALL, "39", , 全部,文本+图象+选择图象+项目数值 1+2+4+32=39
.常量 TVM_INSERTITEMA, "4352", , 在树视图控件中插入一个新项目。
.常量 TVM_SETITEMA, "4365", , 该TVM_SETITEM消息设置的部分或全部树视图项的属性。
.常量 TVM_GETVISIBLECOUNT, "4368"
.常量 TVM_SELECTITEM, "4363"
.常量 TVM_GETITEMRECT, "4356"
.常量 TVIS_BOLD, "16", , 加粗
.常量 TVIF_STATE, "8", , 状态
.常量 TVIF_HANDLE, "16", , hItem成员是有效的。
.常量 TVIF_CHILDREN, "64", , 是否有子
.常量 TVIF_INTEGRAL, "128", , iIntegral成员是有效的。
.常量 TVS_CHECKBOXES, "256", , 启用树视图控件中项目的复选框。仅当图像与项目相关联时才会显示复选框。
.常量 TVS_TRACKSELECT, "512", , 在树视图控件中启用热跟踪。
.常量 TVS_NOSCROLL, "8192", , 禁用控件中的水平和垂直滚动。该控件不会显示任何滚动条。
.常量 TVS_NOHSCROLL, "32768", , 禁用控件中的水平滚动。该控件不会显示任何水平滚动条。
.常量 TVS_FULLROWSELECT, "4096", , 在树视图中启用全行选择。所选项目的整行都将突出显示，单击项目行上的任意位置会使其被选中。此样式不能与TVS_HASLINES样式结合使用。
.常量 TVN_BEGINDRAGA, "-407", , 通知树视图控件的父窗口正在启动涉及鼠标左键的拖放操作。
.常量 TVN_BEGINDRAGW, "-456", , 通知树视图控件的父窗口，即正在启动涉及鼠标左键的拖放操作。
.常量 TVSIL_NORMAL, "0", , 指示普通图像列表，其中包含树视图控件项的选定图像、非选定图像和覆盖图像。
.常量 TVSIL_STATE, "2", , 指示状态映像列表。 可以使用状态映像来指示应用程序定义的项状态。 状态图像显示在项目所选或非选定图像的左侧。

.常量 LR_COPYRETURNORG, "4", , 如果它满足副本的标准（即正确的尺寸和颜色深度），则 返回原始hImage ，在这种情况下忽略LR_COPYDELETEORG标志。如果未指定此标志，则始终创建一个新对象。
.常量 LR_LOADMAP3DCOLORS, "4096", , 在颜色表中搜索图像并用相应的 3-D 颜色替换以下灰色阴影。如果您正在加载颜色深度大于 8bpp 的位图，请不要使用此选项。
.常量 LR_LOADFROMFILE, "16", , 从lpszName指定的文件（图标、光标或位图文件） 加载独立图像 。
.常量 WM_CTLCOLOREDIT, "307"
.常量 TRANSPARENT, "1", , 背景保持不变
.常量 NULL_BRUSH, "5"
.常量 EN_VSCROLL, "1538"
.常量 EN_HSCROLL, "1537"
.常量 EN_CHANGE, "768"
.常量 WM_ERASEBKGND, "20"
.常量 WM_VSCROLL, "277"
.常量 WM_HSCROLL, "276"
.常量 CBM_INIT, "4"

.常量 HDI_FORMAT, "4"
.常量 HDF_OWNERDRAW, "32768"
.常量 HDM_GETITEMCOUNT, "4608"
.常量 WM_DRAWITEM, "43", , 当button，combobox，listbox，menu的可视外观改变时发送
.常量 HDM_SETITEM, "4612"
.常量 HDI_TEXT, "2"
.常量 HDM_GETITEM, "4611"
.常量 DT_CENTER, "1"
.常量 HDM_LAYOUT, "4613"
.常量 WM_NCCALCSIZE, "131", , 当必须计算窗口客户区的大小和位置时发送。通过处理此消息，应用程序可以在窗口大小或位置发生变化时控制窗口客户区的内容。
.常量 WM_PAINT, "15", , 当系统或其他应用程序请求绘制应用程序窗口的一部分时，将发送WM_PAINT消息。

.常量 LVM_APPROXIMATEVIEWRECT, "4160", 公开, 超列表_计算显示一个项目所需的宽度和高度
.常量 LVM_ARRANGE, "4118", 公开, 超列表_在图象显示时自动排列
.常量 LVM_CREATEDRAGIMAGE, "4129", 公开, 超列表_为指定的项目产生一个拖曳图像列表
.常量 LVM_DELETEALLITEMS, "4105", 公开, 超列表_清空
.常量 LVM_DELETECOLUMN, "4124", 公开, 超列表_删除列
.常量 LVM_DELETEITEM, "4104", 公开, 超列表_删除行
.常量 LVM_EDITLABELW, "4214", 公开, 超列表_编辑指定位置
.常量 LVM_ENABLEGROUPVIEW, "4253", 公开, 超列表_显示或禁止项目
.常量 LVM_ENSUREVISIBLE, "4115", 公开, 超列表_保证显示
.常量 LVM_FINDITEMW, "4179", 公开, 超列表_查找
.常量 LVM_GETBKCOLOR, "4096", 公开, 取背景颜色
.常量 LVM_GETBKIMAGEW, "4235", 公开, 取背景图片
.常量 LVM_GETCALLBACKMASK, "4106", 公开, 取回调掩码
.常量 LVM_GETCOLUMNW, "4191", 公开, 超列表_取列信息
.常量 LVM_GETCOLUMNORDERARRAY, "4155", 公开, 超列表_取对齐方式
.常量 LVM_GETCOLUMNWIDTH, "4125", 公开, 超列表_取列宽
.常量 LVM_GETCOUNTPERPAGE, "4136", 公开, 取可视的项目数量
.常量 LVM_GETEDITCONTROL, "4120", 公开, 当列表框在进行编辑时，返回这引编辑框的句柄
.常量 LVM_GETEXTENDEDLISTVIEWSTYLE, "4151", 公开, 取当前扩展风格
.常量 LVM_GETGROUPINFO, "4245", 公开, 取块的信息
.常量 LVM_GETGROUPCOUNT, "4248", 公开, 获取组数。
.常量 LVM_GETGROUPINFOBYINDEX, "4249", 公开, 获取有关指定组的信息。
.常量 LVM_GETGROUPMETRICS, "4252", 公开, 取块的规格
.常量 LVM_GETHEADER, "4127", 公开, 超列表_取表头句柄
.常量 LVM_GETHOTCURSOR, "4159", 公开, 如果激活了热点跟随踪，当鼠标在某个项目上时，返回其句柄
.常量 LVM_GETHOTITEM, "4157", 公开, 取鼠标指针指向项目的索引
.常量 LVM_GETHOVERTIME, "4168", 公开, 检索鼠标光标在项目被选中之前必须悬停在项目上的时间量。
.常量 LVM_GETIMAGELIST, "4098", 公开, 取图片组
.常量 LVM_GETINSERTMARK, "4263", 公开, 取插入掩码
.常量 LVM_GETINSERTMARKCOLOR, "4267", 公开, 取插入掩码颜色
.常量 LVM_GETINSERTMARKRECT, "4265", 公开, 取插入掩码的矩形范围
.常量 LVM_GETITEMW, "4171", 公开, 超列表_取项目
.常量 LVM_GETITEMCOUNT, "4100", 公开, 超列表_取表项总数
.常量 LVM_GETITEMPOSITION, "4112", 公开, 超列表_取图标位置
.常量 LVM_GETITEMRECT, "4110", 公开, 取指定项目的矩形范围
.常量 LVM_GETITEMSPACING, "4147", 公开, 取项目之间的间隔距离
.常量 LVM_GETITEMSTATE, "4140", 公开, 超列表_取项目状态
.常量 LVM_GETITEMTEXTW, "4211", 公开, 取项目正文
.常量 LVM_GETNEXTITEM, "4108", 公开, 取下一项目
.常量 LVM_GETNUMBEROFWORKAREAS, "4169", 公开, 取当前列表框工作区中的项目数量
.常量 LVM_GETOUTLINECOLOR, "4272", 公开, 取列表框边框颜色
.常量 LVM_GETSELECTEDCOLUMN, "4270", 公开, 取选择列
.常量 LVM_GETSELECTEDCOUNT, "4146", 公开, 超列表_取被选择项目数
.常量 LVM_GETSELECTIONMARK, "4162", 公开, 超列表_取现行选中项
.常量 LVM_GETSTRINGWIDTHA, "4113", 公开, 取显示一个文本所需要的列宽度
.常量 LVM_GETSUBITEMRECT, "4152", 公开, 取子项目的矩形范围
.常量 LVM_GETTEXTBKCOLOR, "4133", 公开, 取正文背景色
.常量 LVM_GETTEXTCOLOR, "4131", 公开, 取正文颜色
.常量 LVM_GETTOOLTIPS, "4174", 公开, 取工具提示
.常量 LVM_GETTOPINDEX, "4135", 公开, 取在可视范围中第一个项目的索引
.常量 LVM_GETVIEW, "4239", 公开, 取超级列表框当前的类型
.常量 LVM_GETVIEWRECT, "4130", 公开, 取当前所有项目所占用的矩形范围
.常量 LVM_GETWORKAREAS, "4166", 公开, 取工作区的矩形范围
.常量 LVM_INSERTCOLUMNW, "4193", 公开, 超列框_插入列
.常量 LVM_INSERTGROUP, "4241", 公开, 插入块
.常量 LVM_INSERTGROUPSORTED, "4255", 公开, 插入块种类
.常量 LVM_INSERTITEMW, "4173", 公开, 超列框_插入项目
.常量 LVM_ISGROUPVIEWENABLED, "4271", 公开, 块检视是否激活
.常量 LVM_MOVEITEMTOGROUP, "4250", 公开, 移动项目到块
.常量 LVM_REDRAWITEMS, "4117", 公开, 重画项目
.常量 LVM_REMOVEALLGROUPS, "4256", 公开, 移动全部块
.常量 LVM_SCROLL, "4116", 公开, 移动滚动条
.常量 LVM_SETBKCOLOR, "4097", 公开, 设置背景色
.常量 LVM_SETBKIMAGEW, "4234", 公开, 设置背景图片
.常量 LVM_SETCALLBACKMASK, "4107", 公开, 设置回调掩码
.常量 LVM_SETCOLUMNW, "4192", 公开, 超列表_置列信息
.常量 LVM_SETCOLUMNORDERARRAY, "4154", 公开, 设置列显示的排序
.常量 LVM_SETCOLUMNWIDTH, "4126", 公开, 设置列宽
.常量 LVM_SETEXTENDEDLISTVIEWSTYLE, "4150", 公开, 设置扩展风格
.常量 LVM_SETGROUPINFO, "4243", 公开, 设置块信息
.常量 LVM_SETHOTITEM, "4156", 公开, 置鼠标指针指向项目的索引？？？
.常量 LVM_SETICONSPACING, "4149", 公开, 置图标间隔
.常量 LVM_SETIMAGELIST, "4099", 公开, 置图片组
.常量 LVM_SETINFOTIP, "4269", 公开, 置信息提示
.常量 LVM_SETINSERTMARK, "4262", 公开, 置插入掩码
.常量 LVM_SETINSERTMARKCOLOR, "4266", 公开, 置插入掩码颜色
.常量 LVM_SETITEMW, "4172", 公开, 超列表_置项目
.常量 LVM_SETITEMCOUNT, "4143", 公开, 虚拟一个列表项目总数
.常量 LVM_SETITEMPOSITION, "4111", 公开, 超列表_置表项坐标
.常量 LVM_SETITEMSTATE, "4139", 公开, 超列表_置项目状态
.常量 LVM_SETITEMTEXTA, "4142", 公开, 置项目正文
.常量 LVM_SETOUTLINECOLOR, "4273", 公开, 置列表框边框颜色
.常量 LVM_SETSELECTEDCOLUMN, "4236", 公开, 置现行选择列
.常量 LVM_SETSELECTIONMARK, "4163", 公开, 置选择标志
.常量 LVM_SETTEXTBKCOLOR, "4134", 公开, 置正文背景色
.常量 LVM_SETTEXTCOLOR, "4132", 公开, 置文本颜色
.常量 LVM_SETTOOLTIPS, "4170", 公开, 置工具条
.常量 LVM_SETVIEW, "4238", 公开, 置列表框类型
.常量 LVM_SETWORKAREAS, "4161", 公开, 置工作区
.常量 LVM_SORTGROUPS, "4254", 公开, 群（块）分类
.常量 LVM_SORTITEMS, "4144", 公开, 排序分类
.常量 LVM_SORTITEMSEX, "4177", 公开, 项目分类扩展
.常量 LVM_UPDATE, "4138", 公开, 刷新列表框
.常量 LVM_SUBITEMHITTEST, "4153", 公开, 取坐标表项索引
.常量 LVM_CANCELEDITLABEL, "4275", 公开, 取消项目文本编辑操作。
.常量 LVM_INSERTMARKHITTEST, "4264", 公开, 检索最接近指定点的插入点。
.常量 LVM_SETITEMPOSITION32, "4145", 公开, 将项目移动到列表视图控件中的指定位置（必须在图标或小图标视图中）。此消息与LVM_SETITEMPOSITION消息的不同之处在于它使用 32 位坐标。

.常量 窗口风格_单边框, "8388608", 公开, WS_BORDER
.常量 窗口风格_标题栏, "12582912", 公开, WS_CAPTION 有标题和边框（包括WS_BODER风格）。
.常量 窗口风格_子窗口, "1073741824", 公开, WS_CHILD 不能与“窗口风格_弹出式窗口”合用。
.常量 窗口风格_排除子窗口重画, "33554432", 公开, WS_CLIPCHILDREN 在创建父窗口时使用这个风格。
.常量 窗口风格_排除重叠窗口重画, "67108864", 公开, WS_CLIPSIBLINGS 使窗口排除子窗口之间的相对区域。
.常量 窗口风格_禁止, "134217728", 公开, WS_DISABLED
.常量 窗口风格_对话框边框, "4194304", 公开, WS_DLGFRAME
.常量 窗口风格_组样式, "131072", 公开, WS_GROUP
.常量 窗口风格_水平滚动条, "1048576", 公开, WS_HSCROLL
.常量 窗口风格_最大化状态, "16777216", 公开, WS_MAXIMIZE
.常量 窗口风格_最大化按钮, "65536", 公开, WS_MAXIMIZEBOX
.常量 窗口风格_最小化状态, "536870912", 公开, WS_MINIMIZE
.常量 窗口风格_最小化按钮, "131072", 公开, WS_MINIMIZEBOX
.常量 窗口风格_默认, "13565952", 公开, WS_OVERLAPPEDWINDOW具有层叠，标题框，系统菜单，可调边框，系统按钮。
.常量 窗口风格_弹出式窗口, "2147483648", 公开, WS_POPUP 不能与“窗口风格_子窗口”合用。
.常量 WS_POPUPWINDOW, "2156396544", , 具有单边框，弹出式，系统菜单样式。
.常量 窗口风格_可调边框, "262144", 公开, WS_SIZEBOX
.常量 窗口风格_系统菜单, "524288", 公开, WS_SYSMENU 必须同时设定“窗口风格_标题栏”风格。
.常量 窗口风格_可停留焦点, "65536", 公开, WS_TABSTOP
.常量 WS_TILED, "0", , 产生一个层叠的窗口。一个层叠的窗口有一个标题和一个边框。
.常量 窗口风格_层叠窗口, "13565952", 公开, WS_TILEDWINDOW 创建一个具有WS_OVERLAPPED，WS_CAPTION，WS_SYSMENU MS_THICKFRAME
.常量 窗口风格_可视, "268435456", 公开, WS_VISIBLE
.常量 窗口风格_垂直滚动条, "2097152", 公开, WS_VSCROLL
.常量 窗口风格_无边框, "2147483648", 公开, WS_POPUP 不能与“窗口风格_子窗口”合用。

.常量 窗口扩展_阴影边缘, "512", 公开, WS_EX_CLIENTEDGE
.常量 窗口扩展_双层边框, "1", 公开, WS_EX_DLGMODALFRAME
.常量 窗口扩展_凸起阴影, "768", 公开, WS_EX_OVERLAPPEDWINDOW
.常量 窗口扩展_三维边缘, "131072", 公开, WS_EX_STATICEDGE
.常量 窗口扩展_凸起边框, "256", 公开, WS_EX_WINDOWEDGE
.常量 窗口扩展_容器窗口, "65536", 公开, WS_EX_CONTROLPARENT 允许用户使用Tab键在窗口的子窗口间搜索
.常量 窗口扩展_分层, "524288", 公开, WS_EX_LAYERED 透明窗口或分层，该样式可使用混合特效
.常量 窗口扩展_总在最前, "8", 公开, WS_EX_TOPMOST
.常量 窗口扩展_工具条窗口, "128", 公开, WS_EX_TOOLWINDOW
.常量 WS_EX_NOPARENTNOTIFY, "4", , 创建/销毁时不向父窗口发送WM_PARENTNOTFY消息
.常量 窗口扩展_可接受拖放, "16", 公开, WS_EX_ACCEPTFILES 可接受拖放文件
.常量 窗口扩展_在任务栏显示, "262144", 公开, WS_EX_APPWINDOW 当窗口可见时，将一个顶层窗口放置到任务条上
.常量 窗口扩展_帮助按钮, "1024", 公开, WS_EX_CONTEXTHELP。在窗口的标题条包含一个问号标志，
.常量 窗口扩展_垂直滚动条居左, "16384", 公开, WS_EX_LEFTSCROLLBAR 垂直滚动条在窗口左边界
.常量 窗口扩展_MDI子窗口, "64", 公开, WS_EX_MDICHILD。MDI子窗口
.常量 窗口扩展_右对齐, "4096", 公开, WS_EX_RIGHT
.常量 窗口扩展_文本从右到左, "8192", 公开, WS_EX_RTLREADING 窗口文本从右到左显示
.常量 窗口扩展_透明, "32", 公开, WS_EX_TRANSPARENT。透明样式，在同属窗口已重画时，该窗口才可以重画

.常量 CB_ADDSTRING, "323", 公开, 组合框_添加项目
.常量 CB_DELETESTRING, "324", 公开, 组合框_删除项目
.常量 CB_ERR, "-1", 公开, 组合框_错误
.常量 CB_FINDSTRING, "332", 公开, 组合框_前缀查找
.常量 CB_FINDSTRINGEXACT, "344", 公开, 组合框_精确查找
.常量 CB_GETCOUNT, "326", 公开, 组合框_取项目总数
.常量 CB_GETCURSEL, "327", 公开, 组合框_取现行选中项
.常量 CB_GETDROPPEDCONTROLRECT, "338", 公开, 组合框_列表框的屏幕位置
.常量 CB_GETDROPPEDSTATE, "343", 公开, 组合框_列表框是否可见
.常量 CB_GETDROPPEDWIDTH, "351", 公开, 组合框_列表框的宽度。
.常量 CB_GETEDITSEL, "320", 公开, 组合框_编辑控件中选定内容的范围
.常量 CB_GETEXTENDEDUI, "342", 公开, 组合框_是否存在扩展界面
.常量 CB_GETITEMDATA, "336", 公开, 组合框_取项目数值
.常量 CB_GETITEMHEIGHT, "340", 公开, 组合框_取列表框项目高度
.常量 CB_GETLBTEXT, "328", 公开, 组合框_取项目文本
.常量 CB_GETLBTEXTLEN, "329", 公开, 组合框_取项目文本长度
.常量 CB_GETTOPINDEX, "347", 公开, 组合框_取组合框中列表框中第一个可见项的索引
.常量 CB_INSERTSTRING, "330", 公开, 组合框_指定位置插入字符串。
.常量 CB_LIMITTEXT, "321", 公开, 组合框_限制编辑控件文本的最大长度
.常量 CB_RESETCONTENT, "331", 公开, 组合框_清空
.常量 CB_SELECTSTRING, "333", 公开, 组合框_设定与指定字符串相匹配的列表项为选中项。
.常量 CB_SETCURSEL, "334", 公开, 组合框_置现行选中项
.常量 CB_SETDROPPEDWIDTH, "352", 公开, 组合框_列表框最大允许宽度
.常量 CB_SETEDITSEL, "322", 公开, 组合框_编辑控件中文本选定内容范围
.常量 CB_SETEXTENDEDUI, "341", 公开, 组合框_是使用默认界面或扩展界面
.常量 CB_SETHORIZONTALEXTENT, "350", 公开, 组合框_置列表宽度
.常量 CB_SETITEMDATA, "337", 公开, 组合框_置项目数值
.常量 CB_SETITEMHEIGHT, "339", 公开, 组合框_列表项显示高度
.常量 CB_SETTOPINDEX, "348", 公开, 组合框_置为列表框的第一个可见项
.常量 CB_SHOWDROPDOWN, "335", 公开, 组合框_显示列表。
.常量 CB_GETCOMBOBOXINFO, "356", 公开
.常量 CB_SETMINVISIBLE, "5889", , 设置组合框下拉列表中可见项的最小数量
.常量 CB_GETMINVISIBLE, "5890", , 获取组合框下拉列表中可见项的最小数目

.常量 en_US, "1033"
.常量 FILE_ATTRIBUTE_NORMAL, "128", 公开, 没有设置其他属性的文件。此属性仅在单独使用时才有效。
.常量 FILE_ATTRIBUTE_OFFLINE, "4096", , 文件数据无法立即使用。此属性指示文件数据已物理移动到脱机存储中。远程存储（分层存储管理软件）使用此属性。应用程序不应随意更改此属性。
.常量 FILE_ATTRIBUTE_NOT_CONTENT_INDEXED, "8192", , 内容索引服务不对文件或目录建立索引。

.常量 PBS_MARQUEE, "8", , 6.0或更高版本。进度指示器的大小不会增加，而是沿着条的长度重复移动，指示活动而不指定进度的完成比例。
.常量 PBM_SETMARQUEE, "1034", , 将进度条设置为选取框模式。这会导致进度条像选取框一样移动。

.常量 SHGFP_TYPE_CURRENT, "0", , 检索文件夹的当前路径。
.常量 SHGFP_TYPE_DEFAULT, "1", , 检索文件夹的默认路径。
.常量 SW_NORMAL, "1"
.常量 CBN_SELCHANGE, "1", , 通知父窗(通过WM_COMMAND获知),选择了组合框中的一项
.常量 HWND_BROADCAST, "65535", , 广播消息

.常量 S_OK, "0", , 正确
.常量 S_FALSE, "1", , 错误

.常量 CSIDL_DESKTOP, "0", 公开, 表示Windows桌面的虚拟文件夹，名称空间的根。
.常量 CSIDL_INTERNET, "1", 公开, Internet Explorer的虚拟文件夹。
.常量 CSIDL_PROGRAMS, "2", 公开, 包含用户程序组的文件系统目录（本身就是文件系统目录）。典型的路径是C:\Documents and Settings\用户名\Start Menu\Programs。
.常量 CSIDL_CONTROLS, "3", 公开, 包含控制面板应用程序图标的虚拟文件夹。
.常量 CSIDL_PRINTERS, "4", 公开, 包含已安装打印机的虚拟文件夹。
.常量 CSIDL_PERSONAL, "5", 公开, 代表“我的文档”桌面项目的虚拟文件夹。
.常量 CSIDL_FAVORITES, "6", 公开, 文件系统目录，用作用户喜欢的项目的公共存储库。典型路径是C:\Documents and Settings\用户名\Favorites。
.常量 CSIDL_STARTUP, "7", 公开, 与用户的启动程序组相对应的文件系统目录。每当相关联的用户登录时，系统都会启动这些程序。典型路径是C:\Documents and Settings\用户名\Start Menu\Programs\Startup。
.常量 CSIDL_RECENT, "8", 公开, 文件系统目录，其中包含用户最近使用的文档的快捷方式。典型路径是C:\Documents and Settings\用户名\My Latest Documents。要在此文件夹中创建快捷方式，请使用SHAddToRecentDocs。除了创建快捷方式外，此功能还可以更新命令行管理程序的近期文档列表，并将快捷方式添加到“开始”菜单的“我的近期文档”子菜单中。
.常量 CSIDL_SENDTO, "9", 公开, 包含“发送到”菜单项的文件系统目录。典型路径是C:\Documents and Settings\用户名\SendTo。
.常量 CSIDL_BITBUCKET, "10", 公开, 包含用户回收站中对象的虚拟文件夹。
.常量 CSIDL_STARTMENU, "11", 公开, 包含“开始”菜单项的文件系统目录。典型路径是C:\Documents and Settings\用户名\开始菜单。
.常量 CSIDL_MYMUSIC, "13", 公开, 用作音乐文件的公共存储库的文件系统目录。典型路径是C:\Documents and Settings\User\My Documents\My Music。
.常量 CSIDL_DESKTOPDIRECTORY, "16", 公开, 用于在桌面上物理存储文件对象的文件系统目录（不要与桌面文件夹本身混淆）。典型路径是C:\Documents and Settings\用户名\Desktop。
.常量 CSIDL_DRIVES, "17", 公开, 代表“我的电脑”的虚拟文件夹，其中包含本地计算机上的所有内容：存储设备，打印机和控制面板。该文件夹还可以包含映射的网络驱动器。
.常量 CSIDL_NETWORK, "18", 公开, 表示网络邻居的虚拟文件夹，网络邻居是网络名称空间层次结构的根。
.常量 CSIDL_NETHOOD, "19", 公开, 一个文件系统目录，其中包含“网上邻居”虚拟文件夹中可能存在的链接对象。它与CSIDL_NETWORK不同，后者表示网络名称空间的根。典型路径是C:\Documents and Settings\用户名\NetHood。
.常量 CSIDL_FONTS, "20", 公开, 包含字体的虚拟文件夹。典型的路径是C:\Windows\Fonts。
.常量 CSIDL_TEMPLATES, "21", 公开, 用作文档模板的公共存储库的文件系统目录。典型的路径是C:\Documents and Settings\用户名\Templates。
.常量 CSIDL_COMMON_STARTMENU, "22", 公开, 文件系统目录，其中包含出现在“开始”菜单上的所有用户的程序和文件夹。典型的路径是C:\Documents and Settings\All Users\Start Menu。
.常量 CSIDL_COMMON_PROGRAMS, "23", 公开, 文件系统目录，其中包含出现在“开始”菜单上的所有用户的通用程序组的目录。典型的路径是C:\Documents and Settings\All Users\Start Menu\Programs。
.常量 CSIDL_COMMON_STARTUP, "24", 公开, 文件系统目录，其中包含出现在所有用户的“启动”文件夹中的程序。典型的路径是C:\Documents and Settings\All Users\Start Menu\Programs\Startup。
.常量 CSIDL_COMMON_DESKTOPDIRECTORY, "25", 公开, 文件系统目录，其中包含为所有用户显示在桌面上的文件和文件夹。典型路径是C:\Documents and Settings\All Users\Desktop。
.常量 CSIDL_APPDATA, "26", 公开, 文件系统目录，用作特定于应用程序的数据的公共存储库。典型路径是C:\Documents and Settings\用户名\Application Data。
.常量 CSIDL_PRINTHOOD, "27", 公开, 包含可以在“打印机”虚拟文件夹中存在的链接对象的文件系统目录。典型的路径是C:\Documents and Settings\用户名\PrintHood。
.常量 CSIDL_LOCAL_APPDATA, "28", 公开, 用户的配置文件文件夹。典型的路径是C:\Users\username。应用程序不应在此级别创建文件或文件夹；他们应该将其数据放在CSIDL_APPDATA或CSIDL_LOCAL_APPDATA所引用的位置下。但是，如果要创建新的“已知文件夹”，则由CSIDL_PROFILE引用的配置文件根目录是合适的。
.常量 CSIDL_ALTSTARTUP, "29", 公开, 与用户的非本地化启动程序组相对应的文件系统目录。Windows Vista可以识别此值以实现向后兼容，但是文件夹本身不再存在。
.常量 CSIDL_COMMON_ALTSTARTUP, "30", 公开, 与所有用户的非本地化启动程序组相对应的文件系统目录。Windows Vista可以识别此值以实现向后兼容，但是文件夹本身不再存在。
.常量 CSIDL_COMMON_FAVORITES, "31", 公开, 文件系统目录，用作所有用户共有的收藏夹项的通用存储库。
.常量 CSIDL_INTERNET_CACHE, "32", 公开, 用作Internet临时文件的公共存储库的文件系统目录。典型路径是C:\Documents and Settings\用户名\Local Settings\Temporary Internet Files。
.常量 CSIDL_COOKIES, "33", 公开, 用作Internet cookie通用存储库的文件系统目录。典型路径是C:\Documents and Settings\用户名\Cookies。
.常量 CSIDL_HISTORY, "34", 公开, 用作Internet历史记录项目的公共存储库的文件系统目录。
.常量 CSIDL_COMMON_APPDATA, "35", 公开, 包含所有用户的应用程序数据的文件系统目录。典型的路径是C:\Documents and Settings\All Users\Application Data。该文件夹用于非特定于用户的应用程序数据。例如，应用程序可以在CSIDL_COMMON_APPDATA文件夹中存储拼写检查字典，剪贴画数据库或日志文件。此信息将不会漫游，并且使用计算机的任何人都可以使用。
.常量 CSIDL_WINDOWS, "36", 公开, Windows目录或SYSROOT。这对应于％windir％或％SYSTEMROOT％环境变量。典型路径是C:\Windows。
.常量 CSIDL_SYSTEM, "37", 公开, Windows系统文件夹。典型路径是C:\Windows\System32。
.常量 CSIDL_PROGRAM_FILES, "38", 公开, 程序文件文件夹。典型的路径是C:\Program Files。
.常量 CSIDL_MYPICTURES, "39", 公开, 用作映像文件的公共存储库的文件系统目录。典型路径是C:\Documents and Settings\用户名\My Documents\My Pictures。
.常量 CSIDL_PROFILE, "40", 公开, 用户的配置文件文件夹。典型的路径是C:\Users\username。应用程序不应在此级别创建文件或文件夹；他们应该将其数据放在CSIDL_APPDATA或CSIDL_LOCAL_APPDATA所引用的位置下。但是，如果要创建新的“已知文件夹”，则由CSIDL_PROFILE引用的配置文件根目录是合适的。
.常量 CSIDL_SYSTEMX86, "41", 公开, x86 system directory on RISC
.常量 CSIDL_PROGRAM_FILESX86, "42", 公开, x86 C:\Program Files on RISC
.常量 CSIDL_PROGRAM_FILES_COMMON, "43", 公开, 跨应用程序共享的组件的文件夹。典型路径是C:\Program Files\Common。仅对Windows XP有效。
.常量 CSIDL_PROGRAM_FILES_COMMONX86, "44", 公开, x86 Program Files\Common on RISC
.常量 CSIDL_COMMON_TEMPLATES, "45", 公开, 包含可供所有用户使用的模板的文件系统目录。典型的路径是C:\Documents and Settings\All Users\Templates。
.常量 CSIDL_COMMON_DOCUMENTS, "46", 公开, 文件系统目录，其中包含所有用户通用的文档。典型的路径是C:\Documents and Settings\All Users\Documents。
.常量 CSIDL_COMMON_ADMINTOOLS, "47", 公开, 包含计算机所有用户的管理工具的文件系统目录。All Users\Start Menu\Programs\Administrative Tools
.常量 CSIDL_ADMINTOOLS, "48", 公开, 用于存储单个用户的管理工具的文件系统目录。MMC将自定义的控制台保存到此目录，并且将与用户漫游。<user name>\Start Menu\Programs\Administrative Tools
.常量 CSIDL_CONNECTIONS, "49", 公开, 表示网络连接的虚拟文件夹，其中包含网络和拨号连接。

.常量 ERROR_FILE_NOT_FOUND, "2", , 系统找不到指定的文件。 

.常量 GA_PARENT, "1", , 检索父窗口。这不包括所有者，与GetParent函数一样。
.常量 GA_ROOT, "2", , 通过遍历父窗口链来检索根窗口。
.常量 GA_ROOTOWNER, "3", , 通过遍历GetParent返回的父窗口和所有者窗口的链来检索拥有的根窗口。

.常量 MOD_ALT, "1", 公开, 功能键_Alt
.常量 MOD_CONTROL, "2", 公开, 功能键_Ctrl
.常量 MOD_SHIFT, "4", 公开, 功能键_Shift

.常量 VK_SHIFT, "16"
.常量 VK_CONTROL, "17"
.常量 VK_MENU, "18"
.常量 VK_DIVIDE, "111", , 表示键盘上的 "/" 键。

.常量 LB_FINDSTRING, "399", , 在列表框中查找匹配字符串(忽略大小写)
.常量 LB_FINDSTRINGEXACT, "418", , 用于列表框中查找字符串(忽略大小写),与LB_FINDSTRING不同,本消息必须整个字符串相同

.常量 SB_SETTEXTA, "1025"
.常量 SB_GETTEXTA, "1026"
.常量 SB_GETTEXTLENGTHA, "1027"
.常量 SB_GETTEXT, "1037"
.常量 SB_SETBKCOLOR, "8193"

.常量 EDD_GET_DEVICE_INTERFACE_NAME, "1", , 检索 GUID_DEVINTERFACE_MONITOR 的设备接口名称
.常量 ENUM_CURRENT_SETTINGS, "-1", , 检索显示设备的当前设置。
.常量 ENUM_REGISTRY_SETTINGS, "-2", , 检索当前存储在注册表中的显示设备的设置。

.常量 WM_SETTEXT, "12", , 应用程序发送此消息来设置一个窗口的文本
.常量 WM_CLOSE, "16", , 当一个窗口或应用程序要关闭时发送一个信号
.常量 WM_QUIT, "18", , 用来结束程序运行或当程序调用postquitmessage函数
.常量 WM_FONTCHANGE, "29", , 应用程序在更改字体资源池后向系统中的所有顶级窗口发送WM_FONTCHANGE消息。

.常量 鼠标指针_标准型, "32512", 公开, 标准的箭头IDC_ARROW
.常量 鼠标指针_文本编辑型, "32513", 公开, 文本编辑IDC_IBEAM
.常量 鼠标指针_沙漏型, "32514", 公开, 沙漏IDC_WAIT
.常量 鼠标指针_十字型, "32515", 公开, 十字光标IDC_CROSS
.常量 鼠标指针_UPARROW, "32516", 公开, 向上垂直箭头IDC_UPARROW
.常量 鼠标指针_SIZENWSE, "32642", 公开, 双箭头指向西北和东南IDC_SIZENWSE
.常量 鼠标指针_SIZENESW, "32643", 公开, 双箭头指向东北和西南IDC_SIZENESW
.常量 鼠标指针_SIZEWE, "32644", 公开, 双箭头指向西和东IDC_SIZEWE
.常量 鼠标指针_SIZENS, "32645", 公开, 双箭头指向南北IDC_SIZENS
.常量 鼠标指针_四向箭头, "32646", 公开, 四向箭头指向东、西、南、北IDC_SIZEALL
.常量 鼠标指针_禁止型, "32648", 公开, 禁止圈IDC_NO
.常量 鼠标指针_手型, "32649", 公开, 手型IDC_HAND
.常量 鼠标指针_APPSTARTING, "32650", 公开, 标准的箭头和小沙漏IDC_APPSTARTING
.常量 鼠标指针_帮助, "32651", 公开, 箭头和问号IDC_HELP

.常量 HOOK状态_成功, "0", 公开
.常量 HOOK状态_修改内存保护失败, "1", 公开
.常量 HOOK状态_已HOOK, "2", 公开, 如果需要继续HOOK请先卸载
.常量 HOOK状态_欲HOOK地址为0, "3", 公开, 欲HOOK地址不能为0
.常量 HOOK状态_读取内存失败, "4", 公开, 请检查打开进程权限
.常量 HOOK状态_写入内存失败, "5", 公开, 请检查打开进程权限
.常量 HOOK状态_申请远程内存失败, "6", 公开

.常量 CF_TEXT, "1", 公开, 文字格式。每行以回车/换行（CR-LF）组合结束。空字符表示数据的结尾。对ANSI文本使用此格式。
.常量 CF_BITMAP, "2", 公开, 位图的句柄（HBITMAP）
.常量 CF_METAFILEPICT, "3", 公开, 处理由METAFILEPICT结构定义的图元文件图片格式。通过动态数据交换（DDE）传递CF_METAFILEPICT句柄时，负责删除【HMEM】的应用程序也应该释放CF_METAFILEPICT句柄引用的元文件。
.常量 CF_SYLK, "4", 公开, Microsoft符号链接（SYLK）格式。
.常量 CF_DIF, "5", 公开, 软件艺术数据交换格式。
.常量 CF_TIFF, "6", 公开, 标记图像文件格式。
.常量 CF_OEMTEXT, "7", 公开, 文字格式包含OEM字符集中的字符。每行以回车/换行（CR-LF）组合结束。空字符表示数据的结尾。
.常量 CF_DIB, "8", 公开, 一个包含BITMAPINFO结构的内存对象，后跟位图位。
.常量 CF_PALETTE, "9", 公开, 处理调色板。每当应用程序将数据放置在依赖于或假定调色板的剪贴板中时，它也应将调色板放在剪贴板上。如果剪贴板包含CF_PALETTE（逻辑调色板）格式的数据，则应用程序应使用SelectPalette和RealizePalette函数来实现（比较）剪贴板中与该逻辑调色板的任何其他数据。当显示剪贴板数据时，Windows剪贴板始终将剪贴板上的任何对象用作CF_PALETTE格式的当前调色板。
.常量 CF_PENDATA, "10", 公开, 用于Pen Computing的Microsoft Windows笔的扩展数据。
.常量 CF_RIFF, "11", 公开, 表示音频数据比CF_WAVE标准波形格式更复杂。
.常量 CF_WAVE, "12", 公开, 以诸如11 kHz或22 kHz脉冲编码调制（PCM）的标准波形格式之一表示音频数据。
.常量 CF_UNICODETEXT, "13", 公开, 仅Windows NT： Unicode文字格式。每行以回车/换行（CR-LF）组合结束。空字符表示数据的结尾。
.常量 CF_ENHMETAFILE, "14", 公开, 增强图元文件的句柄（HENHMETAFILE）。
.常量 CF_HDROP, "15", 公开, 类型为HDROP的句柄，用于标识文件列表。应用程序可以通过将句柄传递给DragQueryFile函数来检索有关文件的信息。

.常量 CREATE_SUSPENDED, "4", , 新进程的主线程在挂起状态下创建，并且直到调用ResumeThread函数才运行。
.常量 EXTENDED_STARTUPINFO_PRESENT, "524288", , 该进程是使用扩展启动信息创建的，lpStartupInfo参数指定一个STARTUPINFOEX结构。
.常量 PROC_THREAD_ATTRIBUTE_PARENT_PROCESS, "131072", , lpValue参数是一个指向进程句柄的指针，该句柄使用而不是调用进程作为正在创建的进程的父进程。要使用的进程必须具有PROCESS_CREATE_PROCESS访问权限。

.常量 CREATE_NEW, "1", , 创建一个新文件。如果指定的文件已经存在，该函数将失败。
.常量 CREATE_ALWAYS, "2", , 创建一个新文件。该函数覆盖该文件（如果存在）。

.常量 SHCNE_ASSOCCHANGED, "134217728", , 修改文件关联
.常量 SHCNF_IDLIST, "0"

.常量 MAX_PATH, "260", 公开, 编译器所支持的最长全路径名的长度

.常量 ES_CONTINUOUS, "2147483648", , 通知系统，被设置的状态应该保持有效，直到下一个调用使用。
.常量 ES_SYSTEM_REQUIRED, "1", , 通过重置系统空闲计时器来强制系统进入工作状态。
.常量 ES_DISPLAY_REQUIRED, "2", , 通过重置显示器空闲计时器来强制显示器开启。

.常量 SPI_GETKEYBOARDSPEED, "10", , 检索键盘重复速度设置，该值的范围是从 0 (大约 2.5 次每秒重复) 到 31 (大约每秒 30 次重复) 。 实际重复率取决于硬件，可能与线性比例相差多达 20%。 pvParam 参数必须指向接收设置的 DWORD 变量。
.常量 SPI_SETKEYBOARDSPEED, "11", , 设置键盘重复速度设置。 uiParam 参数必须指定介于 0 (大约每秒 2.5 次重复) 到 31 (大约每秒 30 次重复) 范围内的值。 实际重复率取决于硬件，可能与线性比例相差多达 20%。 如果 uiParam 大于 31，则 参数设置为 31。
.常量 SPI_GETSCREENSAVEACTIVE, "16", , 确定是否启用屏幕保存。如果启用了屏幕保护，则pvParam参数必须指向一个BOOL变量，该变量将接收TRUE，否则，则返回FALSE。
.常量 SPI_SETSCREENSAVEACTIVE, "17", , 设置屏幕保护程序的状态。 uiParam参数指定TRUE激活屏幕保存，或FALSE取消激活屏幕保存。
.常量 SPI_GETKEYBOARDDELAY, "22", , 检索键盘重复延迟设置，该值范围为 0 (大约 250 毫秒延迟) 到 3 (大约 1 秒延迟) 。 与每个值关联的实际延迟可能因硬件而异。 pvParam 参数必须指向接收设置的整数变量。
.常量 SPI_SETKEYBOARDDELAY, "23", , 设置键盘重复延迟设置。 uiParam 参数必须指定 0、1、2 或 3，其中 0 设置最短延迟约 250 毫秒) ，3 设置最长延迟 (大约 1 秒) 。 与每个值关联的实际延迟可能因硬件而异。
.常量 SPI_GETMOUSESPEED, "112", , 检索当前鼠标速度。鼠标速度根据鼠标移动的距离确定指针将移动多远。的pvParam参数必须指向其接收之间的范围内的值的整数1（最慢）和20（最快）。默认值为 10。该值可以由最终用户使用鼠标控制面板应用程序设置，也可以由应用程序使用SPI_SETMOUSESPEED 设置。
.常量 SPI_SETMOUSESPEED, "113", , 设置当前鼠标速度。的pvParam参数之间的整数1（最慢）和20（最快）。默认值为 10。此值通常使用鼠标控制面板应用程序设置。

.常量 NOTIFY_FOR_THIS_SESSION, "0"
.常量 NOTIFY_FOR_ALL_SESSIONS, "1"

.常量 WTS_CONSOLE_CONNECT, "1"
.常量 WTS_CONSOLE_DISCONNECT, "2"
.常量 WTS_REMOTE_CONNECT, "3"
.常量 WTS_REMOTE_DISCONNECT, "4"
.常量 WTS_SESSION_LOGON, "5"
.常量 WTS_SESSION_LOGOFF, "6"
.常量 WTS_SESSION_LOCK, "7"
.常量 WTS_SESSION_UNLOCK, "8"
.常量 WTS_SESSION_REMOTE_CONTROL, "9"
.常量 WTS_SESSION_CREATE, "10"
.常量 WTS_SESSION_TERMINATE, "11"

.常量 TBSTATE_CHECKED, "1", , 该按钮具有TBSTYLE_CHECK样式，正在被单击。
.常量 TBSTATE_PRESSED, "2", , 单击该按钮。
.常量 TBSTATE_ENABLED, "4", , 该按钮接受用户输入。没有此状态的按钮显示为灰色。
.常量 TBSTATE_HIDDEN, "8", , 该按钮不可见，无法接收用户输入。
.常量 TBSTATE_INDETERMINATE, "16", , 该按钮为灰色。
.常量 TBSTATE_WRAP, "32", , 该按钮后跟一个换行符。该按钮还必须具有TBSTATE_ENABLED状态。

.常量 MAX_PREFERRED_LENGTH, "-1"

.常量 IDLE_PRIORITY_CLASS, "64"
.常量 REALTIME_PRIORITY_CLASS, "256"
.常量 THREAD_QUERY_INFORMATION, "64", , 需要从线程对象读取某些信息
.常量 THREAD_ALL_ACCESS, "2032639", , 线程对象的所有可能的访问权限
.常量 ThreadBasicInformation, "0"
.常量 ThreadQuerySetWin32StartAddress, "9"
.常量 THREAD_PRIORITY_TIME_CRITICAL, "15"
.常量 SHCNE_DELETE, "4"
.常量 SHCNF_PATH, "1"

.常量 NIM_ADD, "0"
.常量 NIM_MODIFY, "1"
.常量 NIM_DELETE, "2"
.常量 NIM_SETFOCUS, "3"
.常量 NIM_SETVERSION, "4"

.常量 ABM_GETSTATE, "4"
.常量 ABM_GETTASKBARPOS, "5"

.常量 LOCALE_STHOUSAND, "15", , 用于分隔小数点左边的数字组的字符。此字符串允许的最大字符数为4。
.常量 LOCALE_ITIME, "35"
.常量 LOCALE_INVARIANT, "127", 公开, 用于固定区域设置的语言。
.常量 LOCALE_USER_DEFAULT, "1024", , 当前用户的默认区域设置。

.常量 WDA_NONE, "0", , 对显示窗口的位置没有任何限制。
.常量 WDA_MONITOR, "1", , 窗口内容仅显示在监视器上。在其他任何地方，该窗口均不显示任何内容。

.常量 OFASI_EDIT, "1", , 选择一个项目并将其名称置于编辑模式。正被选择的单个项目时，才能使用该标志。对于多个项目选择，将忽略它。
.常量 OFASI_OPENDESKTOP, "2", , 在桌面上而不是在Windows资源管理器窗口中选择一个或多个项目。请注意，如果在打开的窗口后遮盖了桌面，则该桌面将不可见。

.常量 MAPVK_VK_TO_VSC, "0", , 这个uCode参数是一个虚拟密钥代码，并转换为扫描代码。如果它是一个虚拟钥匙代码，不区分左右两侧的钥匙，则返回左侧扫描代码。如果没有转换，则函数返回0。
.常量 MAPVK_VSC_TO_VK, "1", , 这个uCode参数是一个扫描代码，它被转换成一个虚拟键代码，不区分左键和右键。如果没有转换，则函数返回0。
.常量 MAPVK_VK_TO_CHAR, "2", , 这个uCode参数是一个虚拟键代码，它被转换成返回值低位字中的非移位字符值。死键（音调符号）通过设置返回值的高位来指示。如果没有转换，则函数返回0。
.常量 MAPVK_VSC_TO_VK_EX, "3", , 这个uCode参数是一个扫描代码，它被转换成一个虚拟键代码，用于区分左键和右键。如果没有转换，则函数返回0。

.常量 INVALID_FILE_SIZE, "-1"
.常量 PropertyTagExifDTOrig, "36867", , 原来的日期和时间
.常量 INVALID_SOCKET, "-1", , 可以通过调用 WSAGetLastError 检索特定的错误代码。

.常量 EVENT_ALL_ACCESS, "2031619", , 指定事件对象的所有可能的访问标志
.常量 TOKEN_ASSIGN_PRIMARY, "1", , 需要将主令牌附加到进程。完成此任务还需要 SE_ASSIGNPRIMARYTOKEN_NAME 权限。
.常量 TOKEN_DUPLICATE, "2", , 需要复制访问令牌。
.常量 TOKEN_QUERY, "8", , 查询访问令牌所必需。
.常量 TOKEN_QUERY_SOURCE, "16", , 需要查询访问令牌的源。
.常量 TOKEN_ADJUST_PRIVILEGES, "32", , 需要启用或禁用访问令牌中的权限。
.常量 TOKEN_ADJUST_DEFAULT, "128", , 需要更改访问令牌的默认所有者、主要组或 DACL。
.常量 TOKEN_ADJUST_SESSIONID, "256", , 需要调整访问令牌的会话 ID。需要 SE_TCB_NAME 权限。
.常量 TOKEN_ALL_ACCESS, "983551", , 结合STANDARD_RIGHTS_REQUIRED标准访问权限和令牌的所有个人访问权限。
.常量 SE_PRIVILEGE_ENABLED, "2", , 该函数启用特权
.常量 SE_GROUP_USE_FOR_DENY_ONLY, "16", , 具有此属性的 SID 是仅拒绝 SID。当系统执行访问检查时，它会检查适用于 SID 的拒绝访问的 ACE，但它会忽略 SID 的允许访问的 ACE。如果设置了此属性，则不会设置 SE_GROUP_ENABLED 属性并且无法重新启用 SID。
.常量 SecurityImpersonation, "2", , 服务器可以模拟客户端在本地系统上的安全上下文。
.常量 TokenPrimary, "1", , 显示主令牌。

.常量 EWX_LOGOFF, "0", , 关闭在调用ExitWindowsEx函数的进程的安全上下文中运行的所有进程。然后它关闭用户。
.常量 EWX_SHUTDOWN, "1", , 将系统关闭到可以安全关闭电源的位置。所有文件缓冲区已刷新到磁盘，所有正在运行的进程已停止。
.常量 EWX_REBOOT, "2", , 关闭系统，然后重新启动系统。
.常量 EWX_FORCE, "4", , 强制进程终止。
.常量 EWX_POWEROFF, "8", , 关闭系统并关闭电源。系统必须支持关机功能。

.常量 DESKTOP_CREATEWINDOW, "2", , 在桌面上创建窗口所必需。

.常量 SHERB_NOCONFIRMATION, "1", , 不会显示确认删除对象的对话框。
.常量 SHERB_NOPROGRESSUI, "2", , 不会显示任何指示进度的对话框。
.常量 SHERB_NOSOUND, "4", , 操作完成后，将不会播放声音。

.常量 SHCONTF_FOLDERS, "32", , 在枚举中包括属于文件夹的项。
.常量 SHCONTF_NONFOLDERS, "64", , 包括枚举中不属于文件夹的项。
.常量 SHCONTF_INCLUDEHIDDEN, "128", , 在枚举中包括隐藏项。
.常量 SHGDN_NORMAL, "0", , 全名。该名称相对于桌面，而不是特定文件夹。此名称用于常规显示。

.常量 PID_DISPLACED_DATE, "3", , 删除日期

.常量 BIF_EDITBOX, "16", , 在浏览对话框中包括一个编辑控件，使用户可以键入项目的名称。
.常量 BIF_NEWDIALOGSTYLE, "64", , 使用新的用户界面。设置此标志为用户提供了一个可以调整大小的较大对话框。该对话框具有几个新功能，包括：对话框内的拖放功能，重新排序，快捷菜单，新文件夹，删除和其他快捷菜单命令。
.常量 BIF_BROWSEINCLUDEFILES, "16384", , 浏览对话框显示文件和文件夹。
.常量 BFFM_INITIALIZED, "1", , 该对话框已完成初始化。
.常量 BFFM_SETSELECTIONW, "1127", , 指定要选择的文件夹的路径。路径可以指定为字符串或PIDL。
.常量 SIGDN_DESKTOPABSOLUTEPARSING, "-2147319808", , 返回相对于桌面的解析名称。

.常量 IShellFolder_BindToObject, "5", , 检索处理程序，通常是为特定项目实现IShellFolder的Shell文件夹对象。控制处理程序构造的可选参数在绑定上下文中传递。
.常量 IShellFolder_EnumObjects, "4", , 通过创建项目标识符枚举对象并返回其IEnumIDList接口，使客户端能够确定文件夹的内容。然后，可以使用该接口支持的方法来枚举文件夹的内容。
.常量 IShellFolder_GetDisplayNameOf, "11", , 检索指定文件对象或子文件夹的显示名称。
.常量 IShellFolder2_GetDetailsEx, "17", , 获取有关Shell文件夹中项目的详细信息，该信息由属性集标识符（FMTID）和属性标识符（PID）标识。
.常量 IEnumIDList_Next, "3", , 检索枚举序列中指定数量的项目标识符，并以检索到的项目数提高当前位置。

.常量 IShellItem_BindToHandler, "3", , 绑定到处理程序 ID 值 (BHID) 指定的项目的处理程序。
.常量 IShellItem_GetParent, "4", , 获取 IShellItem 对象的父级。
.常量 IShellItem_GetDisplayName, "5", , 获取IShellItem对象的显示名称。
.常量 IShellItem_GetAttributes, "6", , 获取 IShellItem 对象的一组请求属性。
.常量 IShellItem_Compare, "7", , 比较两个 IShellItem 对象。

.常量 AF_UNSPEC, "0", , 返回与启用了IPv4或IPv6的适配器关联的IPv4和IPv6地址。
.常量 GAA_FLAG_SKIP_ANYCAST, "2", , 不要返回IPv6任播地址。
.常量 GAA_FLAG_INCLUDE_GATEWAYS, "128", , 返回默认网关的地址。
.常量 MAX_ADAPTER_ADDRESS_LENGTH, "8", , 指定适配器的硬件地址。
.常量 INET_ADDRSTRLEN, "22", , 32位ipv4地址所使用内存长度的最大值。
.常量 INET6_ADDRSTRLEN, "65", , 128位ipv6地址所使用内存长度的最大值。
.常量 IfOperStatusUp, "1", 公开, 接口已启动，并且可以传递数据包。
.常量 IfOperStatusDown, "2", 公开, 接口处于关闭状态，并且无法传递数据包。该 IfOperStatusDown状态有两个含义，这取决于的值 AdminStatus构件。如果AdminStatus未设置为 NET_IF_ADMIN_STATUS_DOWN且ifOperStatus设置为 IfOperStatusDown，则假定接口上存在故障条件。如果 AdminStatus设置为IfOperStatusDown，则 ifOperStatus通常也将设置为 IfOperStatusDown或IfOperStatusNotPresent 并且接口上不一定存在故障。
.常量 IfOperStatusTesting, "3", 公开, 接口处于测试模式。
.常量 IfOperStatusUnknown, "4", 公开, 接口的运行状态未知。
.常量 IfOperStatusDormant, "5", 公开, 该接口实际上不是在传递数据包的条件下（它不处于运行状态），而是处于挂起状态，正在等待某些外部事件。对于按需接口，此新状态标识接口正在等待事件以将其置于IfOperStatusUp状态的情况。
.常量 IfOperStatusNotPresent, "6", 公开, 对IfOperStatusDown状态的一种改进，它指示相关的接口已关闭，特别是因为受管系统中不存在某些组件（通常是硬件组件）。
.常量 IfOperStatusLowerLayerDown, "7", 公开, 对IfOperStatusDown状态的改进。此新状态指示此接口在一个或多个其他接口之上运行，并且该接口已关闭，特别是因为这些下层接口中的一个或多个已关闭。

.常量 KeyBasicInformation, "0", , 提供了KEY_BASIC_INFORMATION结构。
.常量 KeyNodeInformation, "1", , 提供了KEY_NODE_INFORMATION结构。
.常量 KeyFullInformation, "2", , 提供了KEY_FULL_INFORMATION结构。
.常量 KeyNameInformation, "3", , 提供了KEY_NAME_INFORMATION结构。
.常量 KeyCachedInformation, "4", , 提供了KEY_CACHED_INFORMATION结构。
.常量 KeyFlagsInformation, "5", , 保留供系统使用。
.常量 KeyVirtualizationInformation, "6", , 提供了KEY_VIRTUALIZATION_INFORMATION结构。
.常量 KeyHandleTagsInformation, "7", , 保留供系统使用。
.常量 MaxKeyInfoClass, "8", , 此枚举类型的最大值。

.常量 IOCTL_STORAGE_GET_DEVICE_NUMBER, "2953344", , 检索设备类型，设备号，对于可分区的设备，检索设备的分区号。

.常量 GET_MODULE_HANDLE_EX_FLAG_PIN, "1", , 无论FreeLibrary被调用多少次，模块都会保持加载状态，直到进程终止。此选项不能与 GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT 一起使用。
.常量 GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT, "2", , 模块的引用计数不递增。此选项等效于GetModuleHandle的行为 。不要将检索到的模块句柄传递给FreeLibrary函数；这样做会导致 DLL 过早地被取消映射。此选项不能与 GET_MODULE_HANDLE_EX_FLAG_PIN 一起使用。
.常量 GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS, "4", , 所述lpModuleName参数是在该模块中的地址。

.常量 VK_LBUTTON, "1", , 鼠标左键
.常量 VK_RBUTTON, "2", , 鼠标右键

.常量 KEYCODE_LBUTTON, "1", 公开, 左键
.常量 KEYCODE_RBUTTON, "2", 公开, 右键
.常量 KEYCODE_MBUTTON, "3", 公开, 中键
.常量 KEYCODE_WHEEL, "4", 公开, 滚轮
.常量 KEYCODE_SIDEKEYUP, "5", 公开, 侧键上
.常量 KEYCODE_SIDEKEYDOWN, "6", 公开, 侧键下

.常量 KEYSTATUS_DOWN, "1", 公开, 按下
.常量 KEYSTATUS_UP, "2", 公开, 弹起
.常量 KEYSTATUS_DBLCLK, "3", 公开, 双击
.常量 KEYSTATUS_WHEELUP, "4", 公开, 滚轮往上
.常量 KEYSTATUS_WHEELDOWN, "5", 公开, 滚轮往下

.常量 XBUTTON1, "1", , 按下或松开第一个 X 按钮。
.常量 XBUTTON2, "2", , 按下或松开第二个 X 按钮。
.常量 WHEEL_DELTA, "120", , 正值表示滚轮向前旋转，远离用户；负值表示轮子向后旋转，朝向用户。

.常量 FO_MOVE, "1", , 将pFrom 中指定的文件移动到pTo 中指定的位置。
.常量 FO_COPY, "2", , 将pFrom成员中指定的文件复制到pTo成员中指定的位置。
.常量 FO_DELETE, "3", , 删除pFrom 中指定的文件。
.常量 FO_RENAME, "4", , 重命名pFrom 中指定的文件。您不能使用此标志通过单个函数调用重命名多个文件。请改用FO_MOVE。
.常量 FOF_SILENT, "4", , 不显示进度对话框。

.常量 FOF_RENAMEONCOLLISION, "8", , 如果目标名称中已存在具有目标名称的文件，则在移动、复制或重命名操作中为正在操作的文件指定新名称。
.常量 FOF_NOCONFIRMATION, "16", , 对显示的任何对话框回答“全部是”。
.常量 FOF_ALLOWUNDO, "64", , 如果可能，保留撤消信息。
.常量 FOF_SIMPLEPROGRESS, "256", , 显示进度对话框，但在操作时不显示单个文件名。
.常量 FOF_NOCONFIRMMKDIR, "512", , 如果操作需要创建新目录，请不要要求用户确认创建新目录。
.常量 FOF_NOERRORUI, "1024", , 如果发生错误，不要向用户显示对话框。

.常量 ProcessBasicInformation, "0", , 检索指向可用于确定指定进程是否正在调试的 PEB 结构的指针，以及系统用于标识指定进程的唯一值。
.常量 ProcessDebugPort, "7", , 检索DWORD_PTR值，该值是进程调试器的端口号。非零值表示进程正在环 3 调试器的控制下运行。
.常量 ProcessWow64Information, "26", , 确定进程是否在 WOW64 环境中运行（WOW64 是 x86 模拟器，它允许基于 Win32 的应用程序在 64 位 Windows 上运行）。
.常量 ProcessImageFileName, "27", , 检索包含进程图像文件名称的UNICODE_STRING值。
.常量 ProcessBreakOnTermination, "29", , 检索一个ULONG值，该值指示该过程是否被认为是关键的。
.常量 ProcessImageFileNameWin32, "43"

.常量 _WIN32_WINNT_NT4, "1024", , Windows NT 4.0
.常量 _WIN32_WINNT_WIN2K, "1280", , Windows 2000
.常量 _WIN32_WINNT_WINXP, "1281", 公开, Windows XP
.常量 _WIN32_WINNT_WS03, "1282", , Windows Server 2003
.常量 _WIN32_WINNT_WIN6, "1536", , Windows Vista
.常量 _WIN32_WINNT_VISTA, "1536", 公开, Windows Vista
.常量 _WIN32_WINNT_WS08, "1536", , Windows Server 2008
.常量 _WIN32_WINNT_LONGHORN, "1536", , Windows Vista
.常量 _WIN32_WINNT_WIN7, "1537", 公开, Windows 7
.常量 _WIN32_WINNT_WIN8, "1538", 公开, Windows 8
.常量 _WIN32_WINNT_WINBLUE, "1539", 公开, Windows 8.1
.常量 _WIN32_WINNT_WINTHRESHOLD, "2560", , Windows 10
.常量 _WIN32_WINNT_WIN10, "2560", 公开, Windows 10

.常量 IUnknown_QueryInterface, "0", , 从 COM 对象请求指向指定接口的指针。
.常量 IPersistFile_Load, "5", , 打开指定的文件并从文件内容初始化一个对象。

.常量 IShellLinkW_GetPath, "3", , 获取 Shell 链接对象目标的路径和文件名。
.常量 IShellLinkW_GetIDList, "4", , 获取 Shell 链接对象目标的项标识符列表。
.常量 IShellLinkW_SetIDList, "5", , 设置指向 Shell 链接对象的项标识符列表 (PIDL) 的指针。
.常量 IShellLinkW_GetDescription, "6", , 获取 Shell 链接对象的描述字符串。
.常量 IShellLinkW_SetDescription, "7", , 设置 Shell 链接对象的描述。描述可以是任何应用程序定义的字符串。
.常量 IShellLinkW_GetWorkingDirectory, "8", , 获取 Shell 链接对象的工作目录的名称。
.常量 IShellLinkW_SetWorkingDirectory, "9", , 设置 Shell 链接对象的工作目录的名称。
.常量 IShellLinkW_GetArguments, "10", , 获取与 Shell 链接对象关联的命令行参数。
.常量 IShellLinkW_SetArguments, "11", , 设置 Shell 链接对象的命令行参数。
.常量 IShellLinkW_GetHotkey, "12", , 获取 Shell 链接对象的键盘快捷键（热键）。
.常量 IShellLinkW_SetHotkey, "13", , 为 Shell 链接对象设置键盘快捷键（热键）。
.常量 IShellLinkW_GetShowCmd, "14", , 获取 Shell 链接对象的显示命令。
.常量 IShellLinkW_SetShowCmd, "15", , 设置 Shell 链接对象的显示命令。show 命令设置窗口的初始显示状态。
.常量 IShellLinkW_GetIconLocation, "16", , 获取 Shell 链接对象图标的位置（路径和索引）。
.常量 IShellLinkW_SetIconLocation, "17", , 为 Shell 链接对象设置图标的位置（路径和索引）。
.常量 IShellLinkW_SetRelativePath, "18", , 设置 Shell 链接对象的相对路径。
.常量 IShellLinkW_Resolve, "19", , 尝试查找 Shell 链接的目标，即使它已被移动或重命名。
.常量 IShellLinkW_SetPath, "20", , 为 Shell 链接对象的目标设置路径和文件名。

.常量 STGM_READ, "0", , 文件将以只读访问权限创建或打开。
.常量 IPersistFile_Save, "6", , 将对象的副本保存到指定文件。

.常量 HOTKEYF_SHIFT, "1", 公开, SHIFT 键
.常量 HOTKEYF_CONTROL, "2", 公开, CTRL 键
.常量 HOTKEYF_ALT, "4", 公开, ALT键
.常量 HOTKEYF_EXT, "8", 公开, 扩展键

.常量 SHGFI_PIDL, "8", , 指示pszPath是ITEMIDLIST结构的地址而不是路径名。
.常量 SHGFI_DISPLAYNAME, "512", , 检索文件的显示名称，即它在 Windows 资源管理器中显示的名称。

.常量 IMMDeviceEnumerator_EnumAudioEndpoints, "3", , EnumAudioEndpoints 方法生成满足指定条件的音频端点设备的集合。
.常量 IMMDeviceEnumerator_GetDefaultAudioEndpoint, "4", , GetDefaultAudioEndpoint 方法检索指定数据流方向和角色的默认音频端点。
.常量 IMMDeviceEnumerator_GetDevice, "5", , GetDevice 方法检索由端点 ID 字符串标识的音频端点设备。
.常量 IMMDeviceEnumerator_RegisterEndpointNotificationCallback, "6", , RegisterEndpointNotificationCallback 方法注册客户端的通知回调接口。
.常量 IMMDeviceEnumerator_UnregisterEndpointNotificationCallback, "7", , UnregisterEndpointNotificationCallback 方法删除客户端在先前调用 IMMDeviceEnumerator::RegisterEndpointNotificationCallback 方法时注册的通知接口的注册。

.常量 IMMDevice_Activate, "3", , Activate 方法创建具有指定接口的 COM 对象。
.常量 IMMDevice_OpenPropertyStore, "4", , OpenPropertyStore 方法检索设备属性存储的接口。
.常量 IMMDevice_GetId, "5", , 方法检索标识音频端点设备的端点 ID 字符串。
.常量 IMMDevice_GetState, "6", , GetState 方法检索当前设备状态。

.常量 IAudioEndpointVolume_RegisterControlChangeNotify, "3", , RegisterControlChangeNotify 方法注册客户端的通知回调接口。
.常量 IAudioEndpointVolume_UnregisterControlChangeNotify, "4", , UnregisterControlChangeNotify 方法删除客户端在之前调用 IAudioEndpointVolume::RegisterControlChangeNotify 方法时注册的客户端通知回调接口的注册。
.常量 IAudioEndpointVolume_GetChannelCount, "5", , GetChannelCount 方法获取音频流中进入或离开音频端点设备的通道数。
.常量 IAudioEndpointVolume_SetMasterVolumeLevel, "6", , SetMasterVolumeLevel 方法设置进入或离开音频端点设备的音频流的主音量级别（以分贝为单位）。
.常量 IAudioEndpointVolume_SetMasterVolumeLevelScalar, "7", , SetMasterVolumeLevelScalar 方法设置进入或离开音频端点设备的音频流的主音量级别。音量级别表示为范围从 0.0 到 1.0 的标准化的音频逐渐变细的值。
.常量 IAudioEndpointVolume_GetMasterVolumeLevel, "8", , GetMasterVolumeLevel 方法获取进入或离开音频端点设备的音频流的主音量级别（以分贝为单位）。
.常量 IAudioEndpointVolume_GetMasterVolumeLevelScalar, "9", , GetMasterVolumeLevelScalar 方法获取进入或离开音频端点设备的音频流的主音量级别。音量级别表示为范围从 0.0 到 1.0 的标准化的音频逐渐变细的值。
.常量 IAudioEndpointVolume_SetChannelVolumeLevel, "10", , SetChannelVolumeLevel 方法设置进入或离开音频端点设备的音频流的指定通道的音量级别（以分贝为单位）。
.常量 IAudioEndpointVolume_SetChannelVolumeLevelScalar, "11", , SetChannelVolumeLevelScalar 方法设置进入或离开音频端点设备的音频流中指定通道的规范化、音频逐渐变细的音量级别。
.常量 IAudioEndpointVolume_GetChannelVolumeLevel, "12", , GetChannelVolumeLevel 方法获取进入或离开音频端点设备的音频流中指定通道的音量级别（以分贝为单位）。
.常量 IAudioEndpointVolume_GetChannelVolumeLevelScalar, "13", , GetChannelVolumeLevelScalar 方法获取进入或离开音频端点设备的音频流的指定通道的规范化、音频逐渐变细的音量级别。
.常量 IAudioEndpointVolume_SetMute, "14", , SetMute 方法设置进入或离开音频端点设备的音频流的静音状态。
.常量 IAudioEndpointVolume_GetMute, "15", , GetMute 方法获取进入或离开音频端点设备的音频流的静音状态。
.常量 IAudioEndpointVolume_GetVolumeStepInfo, "16", , GetVolumeStepInfo 方法获取有关音量范围中当前步长的信息。
.常量 IAudioEndpointVolume_VolumeStepUp, "17", , VolumeStepUp 方法将进入或离开音频端点设备的音频流的音量级别递增一个步骤。
.常量 IAudioEndpointVolume_VolumeStepDown, "18", , VolumeStepDown 方法将进入或离开音频端点设备的音频流的音量级别递减一级。
.常量 IAudioEndpointVolume_QueryHardwareSupport, "19", , QueryHardwareSupport 方法查询音频端点设备的硬件支持功能。
.常量 IAudioEndpointVolume_GetVolumeRange, "20", , GetVolumeRange 方法获取进入或离开音频端点设备的音频流的音量范围（以分贝为单位）。

.常量 IAudioSessionManager_GetAudioSessionControl, "3", , GetAudioSessionControl 方法检索音频会话控件。
.常量 IAudioSessionManager_GetSimpleAudioVolume, "4", , GetSimpleAudioVolume 方法检索简单的音频音量控制。

.常量 ISimpleAudioVolume_SetMasterVolume, "3", , SetMasterVolume 方法设置音频会话的主音量级别。
.常量 ISimpleAudioVolume_GetMasterVolume, "4", , GetMasterVolume 方法检索音频会话的客户端音量级别。
.常量 ISimpleAudioVolume_SetMute, "5", , SetMute 方法设置音频会话的静音状态。
.常量 ISimpleAudioVolume_GetMute, "6", , GetMute 方法检索音频会话的当前静音状态。

.常量 DEFAULT_CHARSET, "1", , 枚举所有字符集中所有唯一命名的字体。
.常量 BITSPIXEL, "12", , , 每个像素的相邻颜色位数。
.常量 PLANES, "14", , , 颜色平面的数量。
.常量 SM_CXSCREEN, "0", , , 主显示器的屏幕宽度，以像素为单位。
.常量 SM_CYSCREEN, "1", , , 主显示器的屏幕高度，以像素为单位。
.常量 DEFAULT_PALETTE, "15", , , 默认调色板。该调色板由系统调色板中的静态颜色组成。
.常量 DIB_RGB_COLORS, "0", , , 颜色表应由文字红色、绿色、蓝色 (RGB) 值组成。

.常量 CRYPT_STRING_BASE64, "1", 公开, Base64，没有标头。
.常量 CRYPT_STRING_HEX, "4", 公开, 仅十六进制。
.常量 CRYPT_STRING_HEXRAW, "12", 公开, 一个原始的十六进制字符串。Windows Server 2003 和 Windows XP：  不支持此值。
.常量 CRYPT_STRING_NOCRLF, "1073741824", 公开, 不要将任何新行字符附加到编码字符串。默认行为是使用回车/换行 (CR/LF) 对 (0x0D/0x0A) 来表示新行。Windows Server 2003 和 Windows XP：  不支持此值。
.常量 CRYPT_STRING_NOCR, "2147483648", 公开, 仅对新行使用换行 (LF) 字符 (0x0A)。默认行为是使用 CR/LF 对 (0x0D/0x0A) 来表示新行。

.常量 COINIT_MULTITHREADED, "0", , 为多线程对象并发初始化线程。
.常量 COINIT_APARTMENTTHREADED, "2", , 为单元线程对象并发初始化线程（请参阅备注）。
.常量 COINIT_DISABLE_OLE1DDE, "4", , 为 OLE1 支持禁用 DDE。
.常量 COINIT_SPEED_OVER_MEMORY, "8", , 增加内存使用量以尝试提高性能。

.常量 FOS_OVERWRITEPROMPT, "2", , 保存文件时，在覆盖现有同名文件之前提示。这是“保存”对话框的默认值。
.常量 FOS_STRICTFILETYPES, "4", , 在“保存”对话框中，仅允许用户选择具有通过IFileDialog::SetFileTypes指定的文件扩展名之一的文件。
.常量 FOS_NOCHANGEDIR, "8", , 不要更改当前工作目录。
.常量 FOS_PICKFOLDERS, "32", , 显示一个打开对话框，提供文件夹而不是文件的选择。
.常量 FOS_FORCEFILESYSTEM, "64", , 确保返回的项目是文件系统项目 ( SFGAO_FILESYSTEM )。请注意，这不适用于IFileDialog::GetCurrentSelection返回的项目。
.常量 FOS_ALLNONSTORAGEITEMS, "128", , 使用户能够选择 Shell 命名空间中的任何项目，而不仅仅是具有SFGAO_STREAM或SFAGO_FILESYSTEM属性的项目。此标志不能与 FOS_FORCEFILESYSTEM 结合使用。
.常量 FOS_NOVALIDATE, "256", , 不要检查会阻止应用程序打开所选文件的情况，例如共享冲突或访问被拒绝错误。
.常量 FOS_ALLOWMULTISELECT, "512", , 使用户能够在打开的对话框中选择多个项目。请注意，设置此标志后，必须使用IFileOpenDialog接口来检索这些项目。
.常量 FOS_PATHMUSTEXIST, "2048", , 返回的项目必须位于现有文件夹中。这是默认值。
.常量 FOS_FILEMUSTEXIST, "4096", , 返回的项目必须存在。这是打开对话框的默认值。
.常量 FOS_CREATEPROMPT, "8192", , 如果保存对话框中返回的项目不存在，则提示创建。请注意，这实际上不会创建项目。
.常量 FOS_SHAREAWARE, "16384", , 如果应用程序打开文件时发生共享冲突，请通过OnShareViolation 回调应用程序以获取指导。该标志被 FOS_NOVALIDATE 覆盖。
.常量 FOS_NOREADONLYRETURN, "32768", , 不要返回只读项目。这是“保存”对话框的默认值。
.常量 FOS_NOTESTFILECREATE, "65536", , 不要测试“保存”对话框中指定的项目创建是否会成功。如果未设置此标志，则调用应用程序必须处理创建项目时发现的错误，例如拒绝访问。
.常量 FOS_HIDEMRUPLACES, "131072", , 隐藏用户最近打开或保存项目的位置列表。自 Windows 7 起不支持此值。
.常量 FOS_HIDEPINNEDPLACES, "262144", , 隐藏视图导航窗格中默认显示的项目。此标志通常与IFileDialog::AddPlace方法结合使用，以隐藏标准位置并将其替换为自定义位置。
.常量 FOS_NODEREFERENCELINKS, "1048576", , 不应将快捷方式视为其目标项。这允许应用程序打开 .lnk 文件而不是该文件的快捷方式。
.常量 FOS_OKBUTTONNEEDSINTERACTION, "2097152", , 仅当用户在视图中执行某些操作时才启用 OK 按钮。
.常量 FOS_DONTADDTORECENT, "33554432", , 不要将正在打开或保存的项目添加到最近的文档列表 ( SHAddToRecentDocs )。
.常量 FOS_FORCESHOWHIDDEN, "268435456", , 包括隐藏和系统项目。
.常量 FOS_DEFAULTNOMINIMODE, "536870912", , 指示“另存为”对话框应以展开模式打开。扩展模式是通过单击另存为对话框左下角的按钮来设置和取消设置的模式，单击时在浏览文件夹和隐藏文件夹之间切换。自 Windows 7 起不支持此值。
.常量 FOS_FORCEPREVIEWPANEON, "1073741824", , 向“打开”对话框指示应始终显示预览窗格。
.常量 FOS_SUPPORTSTREAMABLEITEMS, "2147483648", , 指示调用者正在将文件作为流 ( BHID_Stream )打开，因此无需下载该文件。

.常量 IShellItemArray_BindToHandler, "3", , 通过指定的处理程序绑定到一个对象。
.常量 IShellItemArray_GetPropertyStore, "4", , 获取属性存储。
.常量 IShellItemArray_GetPropertyDescriptionList, "5", , 获取外壳项目数组中项目的属性描述列表。
.常量 IShellItemArray_GetAttributes, "6", , 获取包含在 IShellItemArray 中的项目集的属性。
.常量 IShellItemArray_GetCount, "7", , 获取给定 IShellItem 数组中的项目数。
.常量 IShellItemArray_GetItemAt, "8", , 获取IShellItemArray 中给定索引处的项目。
.常量 IShellItemArray_EnumItems, "9", , 获取数组中项目的枚举数。

.常量 IModalWindow_Show, "3", , 启动模态窗口。
.常量 IFileDialog_SetFileTypes, "4", , 设置对话框可以打开或保存的文件类型。
.常量 IFileDialog_SetFileTypeIndex, "5", , 设置在对话框中选择的文件类型。
.常量 IFileDialog_GetFileTypeIndex, "6", , 获取当前选择的文件类型。
.常量 IFileDialog_Advise, "7", , 分配一个事件处理程序，用于侦听来自对话框的事件。
.常量 IFileDialog_Unadvise, "8", , 移除通过 IFileDialog::Advise 方法附加的事件处理程序。
.常量 IFileDialog_SetOptions, "9", , 设置标志来控制对话框的行为。
.常量 IFileDialog_GetOptions, "10", , 获取设置为控制对话框行为的当前标志。
.常量 IFileDialog_SetDefaultFolder, "11", , 如果最近使用的文件夹值不可用，则将使用的文件夹设置为默认值。
.常量 IFileDialog_SetFolder, "12", , 设置一个在对话框打开时始终选择的文件夹，无论以前的用户操作如何。
.常量 IFileDialog_GetFolder, "13", , 获取当前在对话框中选择的文件夹，或者，如果当前未显示对话框，则获取打开对话框时要选择的文件夹。
.常量 IFileDialog_GetCurrentSelection, "14", , 获取用户在对话框中的当前选择。
.常量 IFileDialog_SetFileName, "15", , 设置打开该对话框时出现在文件名编辑框中的文件名。
.常量 IFileDialog_GetFileName, "16", , 检索当前在对话框的文件名编辑框中输入的文本。
.常量 IFileDialog_SetTitle, "17", , 设置对话框的标题。
.常量 IFileDialog_SetOkButtonLabel, "18", , 设置打开或保存按钮的文本。
.常量 IFileDialog_SetFileNameLabel, "19", , 设置文件名编辑框旁边的标签文本。
.常量 IFileDialog_GetResult, "20", , 获取用户在对话框中所做的选择。
.常量 IFileDialog_AddPlace, "21", , 将文件夹添加到可供用户打开或保存项目的位置列表。
.常量 IFileDialog_SetDefaultExtension, "22", , 设置要添加到文件名的默认扩展名。
.常量 IFileDialog_Close, "23", , 关闭对话框。
.常量 IFileDialog_SetClientGuid, "24", , 使调用应用程序能够将 GUID 与对话框的持久状态相关联。
.常量 IFileDialog_ClearClientData, "25", , 指示对话框清除所有持久状态信息。
.常量 IFileDialog_SetFilter, "26", , SetFilter 从 Windows 7 开始不再可用。

.常量 IFileOpenDialog_GetResults, "27", , 在允许多选的对话框中获取用户的选择。
.常量 IFileOpenDialog_GetSelectedItems, "28", , 获取对话框中当前选定的项目。这些项目可能是视图中选择的项目，也可能是文件名编辑框中选择的文本。

.常量 IFileSaveDialog_SetSaveAsItem, "27", , 设置一个项目以用作“另存为”对话框中的初始条目。
.常量 IFileSaveDialog_SetProperties, "28", , 提供一个属性存储，用于定义要用于保存的项目的默认值。
.常量 IFileSaveDialog_SetCollectedProperties, "29", , 指定将在保存对话框中收集哪些属性。
.常量 IFileSaveDialog_GetProperties, "30", , 检索已保存项目或正在保存的项目的属性值集。
.常量 IFileSaveDialog_ApplyProperties, "31", , 使用 Shell 的复制引擎将一组属性应用于项目。

.常量 SIGDN_FILESYSPATH, "-2147123200", , 返回项目的文件系统路径（如果有）。只有报告SFGAO_FILESYSTEM 的项目才有文件系统路径。当项目没有文件系统路径时，对该项目的IShellItem::GetDisplayName调用将失败。在 UI 中，此名称在某些情况下适合向用户显示，但请注意，可能不会为所有项目指定该名称。

.常量 DISP_CHANGE_SUCCESSFUL, "0", , 设置更改成功。
.常量 DISP_CHANGE_RESTART, "1", , 必须重新启动计算机才能使图形模式工作。
.常量 DISP_CHANGE_FAILED, "-1", , 显示驱动程序在指定的图形模式下失败。
.常量 DISP_CHANGE_BADMODE, "-2", , 不支持图形模式。
.常量 DISP_CHANGE_NOTUPDATED, "-3", , 无法将设置写入注册表。
.常量 DISP_CHANGE_BADFLAGS, "-4", , 传入了一组无效的标志。
.常量 DISP_CHANGE_BADPARAM, "-5", , 传入了无效参数。这可能包括无效标志或标志组合。
.常量 DISP_CHANGE_BADDUALVIEW, "-6", , 设置更改不成功，因为系统支持 DualView。

.常量 SPIF_UPDATEINIFILE, "1", , 将新的系统范围参数设置写入用户配置文件。
.常量 SPIF_SENDCHANGE, "2", , 在更新用户配置文件后 广播WM_SETTINGCHANGE消息。
.常量 SPIF_SENDWININICHANGE, "2", , 与SPIF_SENDCHANGE相同。

.常量 INTERNET_OPEN_TYPE_PRECONFIG, "0", , 从注册表中检索代理或直接配置。
.常量 INTERNET_OPEN_TYPE_DIRECT, "1", , 在本地解析所有主机名。
.常量 INTERNET_OPEN_TYPE_PROXY, "3", , 除非提供代理绕过列表并且要解析的名称绕过代理，否则将请求传递给代理。在这种情况下，该函数使用 INTERNET_OPEN_TYPE_DIRECT。
.常量 INTERNET_OPEN_TYPE_PRECONFIG_WITH_NO_AUTOPROXY, "4", , 从注册表中检索代理或直接配置，并阻止使用启动 Microsoft JScript 或 Internet 安装程序 (INS) 文件。

.常量 FILE_BEGIN, "0", , 起点为零或文件的开头。
.常量 FILE_CURRENT, "1", , 起点是文件指针的当前值。
.常量 FILE_END, "2", , 起点是当前的文件结束位置。
.常量 HTTP_QUERY_CONTENT_LENGTH, "5", , 检索资源的大小（以字节为单位）。
.常量 HTTP_QUERY_FLAG_NUMBER, "536870912", , 对于值为数字的标头，以32位数字的形式返回数据，例如状态代码。
.常量 HTTP_QUERY_FLAG_NUMBER64, "134217728"


.常量 FILE_NOTIFY_CHANGE_FILE_NAME, "1", , 监视目录或子树中的任何文件名更改都会导致更改通知等待操作返回。更改包括重命名、创建或删除文件名。
.常量 FILE_NOTIFY_CHANGE_DIR_NAME, "2", , 监视目录或子树中的任何目录名称更改都会导致更改通知等待操作返回。更改包括创建或删除目录。
.常量 FILE_NOTIFY_CHANGE_ATTRIBUTES, "4", , 监视目录或子树中的任何属性更改都会导致更改通知等待操作返回。
.常量 FILE_NOTIFY_CHANGE_SIZE, "8", , 监视目录或子树中的任何文件大小更改都会导致更改通知等待操作返回。仅当文件写入磁盘时，操作系统才会检测文件大小的变化。对于使用大量缓存的操作系统，仅当缓存被充分刷新时才会进行检测。
.常量 FILE_NOTIFY_CHANGE_LAST_WRITE, "16", , 对监视目录或子树中文件的上次写入时间的任何更改都会导致更改通知等待操作返回。仅当文件写入磁盘时，操作系统才会检测到上次写入时间的更改。对于使用大量缓存的操作系统，仅当缓存被充分刷新时才会进行检测。
.常量 FILE_NOTIFY_CHANGE_LAST_ACCESS, "32", , 对监视目录或子树中文件的上次访问时间的任何更改都会导致更改通知等待操作返回。
.常量 FILE_NOTIFY_CHANGE_CREATION, "64", , 对监视目录或子树中的文件创建时间的任何更改都会导致更改通知等待操作返回。
.常量 FILE_NOTIFY_CHANGE_SECURITY, "256", , 监视目录或子树中的任何安全描述符更改都会导致更改通知等待操作返回。

.常量 ASSOCF_VERIFY, "64", , 指示IQueryAssociations方法验证数据是否准确。此设置允许IQueryAssociations方法从用户的硬盘读取数据以进行验证。例如，他们可以根据存储在 .exe 文件中的名称检查注册表中的友好名称。设置此标志通常会降低方法的效率。
.常量 ASSOCF_NOFIXUPS, "256", , 指示IQueryAssociations方法不要修复注册表中的错误，例如函数的友好名称与 .exe 文件中的名称不匹配。
.常量 ASSOCSTR_EXECUTABLE, "2", , 来自 Shell 动词命令字符串的可执行文件。

.常量 ASSOCKEY_SHELLEXECCLASS, "1", , 通过SHELLEXECUTEINFO结构传递给ShellExecuteEx的键。
.常量 ASSOCKEY_APP, "2", , 文件类型的应用程序键。
.常量 ASSOCKEY_CLASS, "3", , ProgID 或类键。
.常量 ASSOCKEY_BASECLASS, "4", , 基类值。
.常量 ASSOCKEY_MAX, "5", , 枚举中的最后一项。

.常量 IQueryAssociations_Init, "3", , 初始化 IQueryAssociations 接口并将根键设置为适当的 ProgID。
.常量 IQueryAssociations_GetString, "4", , 从注册表中搜索并检索与文件或协议关联相关的字符串。
.常量 IQueryAssociations_GetKey, "5", , 从注册表中搜索并检索文件或协议关联相关的键。
.常量 IQueryAssociations_GetData, "6", , 从注册表中搜索和检索文件或协议关联相关的二进制数据。
.常量 IQueryAssociations_GetEnum, "7", , 这个方法没有实现。

.常量 IWbemLocator_ConnectServer, "3", , IWbemLocator::ConnectServer 方法通过 DCOM 创建到 strNetworkResource 参数中指定的计算机上的 WMI 命名空间的连接。

.常量 RPC_C_AUTHN_LEVEL_PKT, "4", , 每次服务器从客户端接收数据时进行身份验证。
.常量 RPC_C_AUTHN_WINNT, "10", , NT LAN Manager安全支持提供商（NTLM SSP）。
.常量 RPC_C_AUTHZ_NONE, "0", , 服务器不执行授权。
.常量 RPC_C_AUTHN_LEVEL_CALL, "3", , 每次服务器收到RPC时进行身份验证。
.常量 RPC_C_IMP_LEVEL_IMPERSONATE, "3", , 服务器可以跨一个计算机边界模拟客户端。
.常量 EOAC_NONE, "0", , 指示未设置任何功能标志。

.常量 IWbemServices_OpenNamespace, "3", , IWbemServices::OpenNamespace 方法为调用者提供了一个新的 IWbemServices 指针，该指针具有指定的子命名空间作为其操作上下文。
.常量 IWbemServices_CancelAsyncCall, "4", , IWbemServices::CancelAsyncCall 方法根据最初传递给异步方法的 IWbemObjectSink 指针取消任何当前挂起的异步调用。
.常量 IWbemServices_QueryObjectSink, "5", , IWbemServices::QueryObjectSink 方法允许调用者获取由 Windows 管理导出的通知处理程序。
.常量 IWbemServices_GetObject, "6", , IWbemServices::GetObject 方法检索类或实例。此方法仅从与当前 IWbemServices 对象关联的命名空间中检索对象。
.常量 IWbemServices_GetObjectAsync, "7", , IWbemServices::GetObjectAsync 方法根据对象的路径检索对象，类定义或实例。
.常量 IWbemServices_PutClass, "8", , IWbemServices::PutClass 方法创建一个新类或更新一个现有类。pObject 参数指定的类必须已使用所有必需的属性值正确初始化。
.常量 IWbemServices_PutClassAsync, "9", , IWbemServices::PutClassAsync 方法创建一个新类，或更新现有类。
.常量 IWbemServices_DeleteClass, "10", , IWbemServices::DeleteClass 方法从当前命名空间中删除指定的类。
.常量 IWbemServices_DeleteClassAsync, "11", , IWbemServices::DeleteClassAsync 方法从当前命名空间中删除指定的类。
.常量 IWbemServices_CreateClassEnum, "12", , IWbemServices::CreateClassEnum 方法为满足选择标准的所有类返回一个枚举器。
.常量 IWbemServices_CreateClassEnumAsync, "13", , IWbemServices::CreateClassEnumAsync 方法返回类提供程序支持的所有类的枚举。
.常量 IWbemServices_PutInstance, "14", , IWbemServices::PutInstance 方法创建或更新现有类的实例。该实例将写入 WMI 存储库。
.常量 IWbemServices_PutInstanceAsync, "15", , IWbemServices::PutInstanceAsync 方法异步创建或更新现有类的实例。更新确认或错误报告是通过调用者实现的 IWbemObjectSink 接口提供的。
.常量 IWbemServices_DeleteInstance, "16", , IWbemServices::DeleteInstance 方法删除当前命名空间中现有类的实例。
.常量 IWbemServices_DeleteInstanceAsync, "17", , IWbemServices::DeleteInstanceAsync 方法异步删除当前命名空间中现有类的实例。操作的确认或失败通过调用者实现的 IWbemObjectSink 接口上报。
.常量 IWbemServices_CreateInstanceEnum, "18", , IWbemServices::CreateInstanceEnum 方法创建一个枚举器，它根据用户指定的选择标准返回指定类的实例。
.常量 IWbemServices_CreateInstanceEnumAsync, "19", , IWbemServices::CreateInstanceEnumAsync 方法创建一个枚举器，它根据用户指定的选择标准异步返回指定类的实例。
.常量 IWbemServices_ExecQuery, "20", , IWbemServices::ExecQuery 方法执行查询以检索对象。
.常量 IWbemServices_ExecQueryAsync, "21", , IWbemServices::ExecQueryAsync 方法执行查询以异步检索对象。
.常量 IWbemServices_ExecNotificationQuery, "22", , IWbemServices::ExecNotificationQuery 方法执行查询以接收事件。调用立即返回，用户可以在事件到达时轮询返回的枚举器。释放返回的枚举数会取消查询。
.常量 IWbemServices_ExecNotificationQueryAsync, "23", , IWbemServices::ExecNotificationQueryAsync 方法执行与 IWbemServices::ExecNotificationQuery 相同的任务，除了将事件提供给指定的响应处理程序，直到调用 CancelAsyncCall 以停止事件通知。
.常量 IWbemServices_ExecMethod, "24", , 执行由 CIM 对象导出的方法。
.常量 IWbemServices_ExecMethodAsync, "25", , 异步执行由 CIM 对象导出的方法。

.常量 WBEM_FLAG_FORWARD_ONLY, "32", , 此标志导致返回仅向前的枚举数。仅转发枚举数通常比常规枚举数快得多，占用的内存更少，但不允许克隆或重置调用。
.常量 WBEM_FLAG_RETURN_IMMEDIATELY, "16", , 此标志使其成为半同步调用。有关详细信息，请参阅进行半同步调用。

.常量 IEnumWbemClassObject_Reset, "3", , IEnumWbemClassObject::Reset 方法将枚举序列重置回开头。由于 CIM 对象是动态的，因此调用此方法不一定返回您之前获得的相同对象列表。
.常量 IEnumWbemClassObject_Next, "4", , 使用 IEnumWbemClassObject::Next 方法获取一个或多个从枚举中的当前位置开始的对象。
.常量 IEnumWbemClassObject_NextAsync, "5", , 当需要将对象异步检索到接收器时，请使用 NextAsync 方法。
.常量 IEnumWbemClassObject_Clone, "6", , IEnumWbemClassObject::Clone 方法制作整个枚举器的逻辑副本，保留其在枚举中的当前位置。
.常量 IEnumWbemClassObject_Skip, "7", , 您可以使用 IEnumWbemClassObject::Skip 方法将枚举中的当前位置向前移动指定数量的对象。此外，这会影响对 NextAsync 的后续调用，但不会影响从 NextAsync 开始的挂起交付。

.常量 WBEM_INFINITE, "-1", , 调用将阻塞，直到对象可用为止。

.常量 IWbemClassObject_GetQualifierSet, "3", , IWbemClassObject::GetQualifierSet 方法返回一个接口指针，该指针允许对整个类对象的限定符集进行读写操作，无论对象是实例还是类定义。
.常量 IWbemClassObject_Get, "4", , IWbemClassObject::Get 方法检索指定的属性值（如果存在）。此方法还可以返回系统属性。
.常量 IWbemClassObject_Put, "5", , 命名属性设置为新值。
.常量 IWbemClassObject_Delete, "6", , IWbemClassObject::Delete 方法从 CIM 类定义及其所有限定符中删除指定的属性。
.常量 IWbemClassObject_GetNames, "7", , 检索对象中的属性名称。
.常量 IWbemClassObject_BeginEnumeration, "8", , 将枚举重置回枚举的开头。
.常量 IWbemClassObject_Next, "9", , IWbemClassObject::Next 方法检索以 IWbemClassObject::BeginEnumeration 开头的枚举中的下一个属性。
.常量 IWbemClassObject_EndEnumeration, "10", , IWbemClassObject::EndEnumeration 方法终止以 IWbemClassObject::BeginEnumeration 开始的枚举序列。
.常量 IWbemClassObject_GetPropertyQualifierSet, "11", , IWbemClassObject::GetPropertyQualifierSet 方法获取类对象中特定属性的限定符集。您可以将此方法与作为实例或类定义成员的属性一起使用。
.常量 IWbemClassObject_Clone, "12", , IWbemClassObject::Clone 方法返回一个新对象，它是当前对象的完整克隆。新对象的 COM 引用计数为 1。
.常量 IWbemClassObject_GetObjectText, "13", , IWbemClassObject::GetObjectText 方法以 MOF 语法返回对象的文本呈现。
.常量 IWbemClassObject_SpawnDerivedClass, "14", , 使用 IWbemClassObject::SpawnDerivedClass 方法从当前对象创建一个新的派生类对象。
.常量 IWbemClassObject_SpawnInstance, "15", , 使用 IWbemClassObject::SpawnInstance 方法创建类的新实例。
.常量 IWbemClassObject_CompareTo, "16", , IWbemClassObject::CompareTo 方法将一个对象与另一个 Windows 管理对象进行比较。请注意，在此比较过程中存在某些限制。
.常量 IWbemClassObject_GetPropertyOrigin, "17", , IWbemClassObject::GetPropertyOrigin 方法检索引入了特定属性的类的名称。
.常量 IWbemClassObject_InheritsFrom, "18", , IWbemClassObject::InheritsFrom 方法确定当前类或实例是否从指定的父类派生。
.常量 IWbemClassObject_GetMethod, "19", , 返回有关所请求方法的信息。
.常量 IWbemClassObject_PutMethod, "20", , 用于创建方法。
.常量 IWbemClassObject_DeleteMethod, "21", , 使用 IWbemClassObject::DeleteMethod 方法删除方法。仅当当前对象是 CIM 类定义时才支持此调用。无法从指向 CIM 实例的 IWbemClassObject 指针进行方法操作。
.常量 IWbemClassObject_BeginMethodEnumeration, "22", , 使用 IWbemClassObject::BeginMethodEnumeration 方法调用开始枚举可用于对象的方法。
.常量 IWbemClassObject_NextMethod, "23", , 用于检索以调用 IWbemClassObject::BeginMethodEnumeration 开始的方法枚举序列中的下一个方法。
.常量 IWbemClassObject_EndMethodEnumeration, "24", , IWbemClassObject::EndMethodEnumeration 方法用于终止以 IWbemClassObject::BeginMethodEnumeration 开始的方法枚举序列。
.常量 IWbemClassObject_GetMethodQualifierSet, "25", , IWbemClassObject::GetMethodQualifierSet 用于检索特定方法的限定符集。
.常量 IWbemClassObject_GetMethodOrigin, "26", , IWbemClassObject::GetMethodOrigin 方法用于确定为其声明方法的类。

.常量 VK_LSHIFT, "160", 公开, 左Shift键
.常量 VK_RSHIFT, "161", 公开, 右Shift键
.常量 VK_LCONTROL, "162", 公开, 左Ctrl键
.常量 VK_RCONTROL, "163", 公开, 右Ctrl键
.常量 VK_LMENU, "164", 公开, 左Alt键
.常量 VK_RMENU, "165", 公开, 右Alt键

.常量 INPUT_MOUSE, "0", , 该事件是一个鼠标事件。使用联合体的mi结构。
.常量 INPUT_KEYBOARD, "1", 公开, 该事件是一个键盘事件。使用union的ki结构。
.常量 INPUT_HARDWARE, "2", , 事件来自键盘或鼠标以外的输入硬件。使用联合体的hi结构。

.常量 KEYEVENTF_EXTENDEDKEY, "1", , 如果指定，扫描代码前面会有一个值为0xE0（224）的前缀字节。
.常量 KEYEVENTF_KEYUP, "2", 公开, 如果指定，则释放密钥。如果未指定，则按下该键。
.常量 KEYEVENTF_SCANCODE, "8", , 如果指定，wScan将标识密钥，wVK将被忽略。
.常量 KEYEVENTF_UNICODE, "4", , 如果指定，系统会合成VK_PACKET击键。该WVK参数必须为零。此标志只能与KEYEVENTF_KEYUP标志结合使用。

.常量 SYMBOLIC_LINK_FLAG_DIRECTORY, "1", , 链接目标是一个目录。
.常量 SYMBOLIC_LINK_FLAG_ALLOW_UNPRIVILEGED_CREATE, "2", , 指定此标志以允许在进程未提升时创建符号链接。必须先在机器上启用开发者模式，此选项才会起作用。

.常量 FILE_FLAG_BACKUP_SEMANTICS, "33554432", , 指示正在为备份或还原操作打开或创建文件。系统确保调用进程覆盖文件安全检查，前提是它具有必要的权限。您还可以设置此标志以获取目录句柄。目录句柄可以代替文件句柄传递给某些函数。
.常量 FILE_FLAG_OPEN_REPARSE_POINT, "2097152", , 指定此标志将禁止NTFS重分析点的重分析行为。打开文件时，将返回一个文件句柄，无论控制重分析点的筛选器是否可用。此标志不能与CREATE_ALWAYS标志一起使用。
.常量 FSCTL_GET_REPARSE_POINT, "589992", , 获取存储在现有重分析点中的信息。

.常量 GPS_READWRITE, "2", , 对调用进程的意义：可以将属性写入项目。注意：存储可能包含比只读存储更少的属性。
.常量 IPropertyStore_GetCount, "3", , 此方法返回附加到文件的属性数的计数。
.常量 IPropertyStore_GetAt, "4", , 从项目的属性数组中获取一个属性键。
.常量 IPropertyStore_GetValue, "5", , 此方法检索特定属性的数据。
.常量 IPropertyStore_SetValue, "6", , 此方法设置属性值或替换或删除现有值。
.常量 IPropertyStore_Commit, "7", , 进行更改后，此方法会保存更改。

.常量 IDispatch_GetTypeInfoCount, "3", , 检索对象提供的类型信息接口的数量（0 或 1）。
.常量 IDispatch_GetTypeInfo, "4", , 检索对象的类型信息，然后可以使用该信息获取接口的类型信息。
.常量 IDispatch_GetIDsOfNames, "5", , 将单个成员和一组可选的参数名称映射到一组相应的整数 DISPID，可用于对 Invoke 的后续调用。
.常量 IDispatch_Invoke, "6", , 提供对对象公开的属性和方法的访问。

.常量 IShellDispatch_get_Application, "7", , 包含代表应用程序的对象。
.常量 IShellDispatch_get_Parent, "8", , 检索代表当前对象的父对象的对象。
.常量 IShellDispatch_NameSpace, "9", , 为指定的文件夹创建并返回一个Folder对象。
.常量 IShellDispatch_BrowseForFolder, "10", , 创建一个对话框，使用户可以选择一个文件夹，然后返回所选文件夹的Folder对象。
.常量 IShellDispatch_Windows, "11", , 创建并返回一个ShellWindows对象。该对象表示属于 Shell 的所有打开窗口的集合。
.常量 IShellDispatch_Open, "12", , 打开指定的文件夹。
.常量 IShellDispatch_Explore, "13", , 在 Windows 资源管理器窗口中打开指定的文件夹。
.常量 IShellDispatch_MinimizeAll, "14", , 最小化桌面上的所有窗口。此方法与右键单击任务栏并在旧系统上选择最小化所有 Windows或单击任务栏上的显示桌面图标具有相同的效果。
.常量 IShellDispatch_UndoMinimizeALL, "15", , 将所有桌面窗口恢复到上次MinimizeAll命令之前的状态。此方法与右键单击任务栏并选择撤消最小化所有 Windows（在较旧的系统上）或再次单击任务栏中的显示桌面图标具有相同的效果。
.常量 IShellDispatch_FileRun, "16", , 向用户显示“运行”对话框。
.常量 IShellDispatch_CascadeWindows, "17", , 将所有窗口层叠在桌面上。
.常量 IShellDispatch_TileVertically, "18", , 垂直平铺桌面上的所有窗口。此方法与右键单击任务栏并选择“并排显示窗口”具有相同的效果。
.常量 IShellDispatch_TileHorizontally, "19", , 水平平铺桌面上的所有窗口。此方法与右键单击任务栏并选择Show windows stacked效果相同。
.常量 IShellDispatch_ShutdownWindows, "20", , 显示关闭 Windows对话框。这与单击“开始”菜单并选择“关机”相同。
.常量 IShellDispatch_Suspend, "21", , 暂停
.常量 IShellDispatch_EjectPC, "22", , 从扩展坞中弹出计算机。如果您的计算机支持此命令，这与单击“开始”菜单并选择“弹出 PC ”相同。
.常量 IShellDispatch_SetTime, "23", , 显示日期和时间对话框。此方法与在任务栏状态区右键单击时钟并选择调整日期/时间 效果相同。
.常量 IShellDispatch_TrayProperties, "24", , 显示任务栏和开始菜单属性对话框。此方法与右键单击任务栏并选择Properties具有相同的效果。
.常量 IShellDispatch_Help, "25", , 显示 Windows 帮助和支持窗口。此方法与单击“开始”菜单并选择“帮助和支持”的效果相同。
.常量 IShellDispatch_FindFiles, "26", , 显示查找：所有文件对话框。这与单击“开始”菜单然后选择“搜索”相同。
.常量 IShellDispatch_FindComputer, "27", , 显示搜索结果：计算机对话框。对话框显示指定计算机的搜索结果。
.常量 IShellDispatch_RefreshMenu, "28", , 刷新开始菜单的内容。仅用于 Windows XP 之前的系统。
.常量 IShellDispatch_ControlPanelItem, "29", , 运行指定的控制面板应用程序。如果应用程序已经打开，它将激活正在运行的实例。

.常量 Folder_get_Title, "7", , 包含文件夹的标题。
.常量 Folder_get_Application, "8", , 包含文件夹的 Application 对象。
.常量 Folder_get_Parent, "9", , 未实现。
.常量 Folder_get_ParentFolder, "10", , 包含父文件夹对象。
.常量 Folder_Items, "11", , 检索表示文件夹中项目集合的FolderItems对象。
.常量 Folder_ParseName, "12", , 创建并返回一个表示指定项目的FolderItem对象。
.常量 Folder_NewFolder, "13", , 创建一个新文件夹。
.常量 Folder_MoveHere, "14", , 将一个或多个项目移动到此文件夹。
.常量 Folder_CopyHere, "15", , 将一个或多个项目复制到文件夹。
.常量 Folder_GetDetailsOf, "16", , 检索有关文件夹中项目的详细信息。例如，它的大小、类型或上次修改的时间。

.常量 FolderItem_get_Application, "7", , 包含文件夹项目的应用程序对象。
.常量 FolderItem_get_Parent, "8", , 获取一个表示该项的父项的对象。
.常量 FolderItem_get_Name, "9", , 获取项目的名称。
.常量 FolderItem_put_Name, "10", , 设置项目的名称。
.常量 FolderItem_get_Path, "11", , 包含项目的完整路径和名称。
.常量 FolderItem_get_GetLink, "12", , 如果项目是快捷方式，则包含项目的ShellLinkObject对象。
.常量 FolderItem_get_GetFolder, "13", , 如果项目是文件夹，则包含项目的Folder对象。
.常量 FolderItem_get_IsLink, "14", , 指示项目是否为快捷方式。
.常量 FolderItem_get_IsFolder, "15", , 指示项目是否为文件夹。
.常量 FolderItem_get_IsFileSystem, "16", , 指示项目是否是文件系统的一部分。
.常量 FolderItem_get_IsBrowsable, "17", , 指示项目是否可以托管在浏览器或 Windows 资源管理器框架内。
.常量 FolderItem_get_ModifyDate, "18", , 获取文件上次修改的日期和时间。ModifyDate可用于检索文件夹上次修改的日期和时间，但不能对其进行设置。
.常量 FolderItem_put_ModifyDate, "19", , 设置文件上次修改的日期和时间。ModifyDate可用于检索文件夹上次修改的日期和时间，但不能对其进行设置。
.常量 FolderItem_get_Size, "20", , 包含项目的大小。
.常量 FolderItem_get_Type, "21", , 包含项目类型的字符串表示形式。
.常量 FolderItem_Verbs, "22", , 检索项目的FolderItemVerbs对象。这个对象是可以在项目上执行的动词的集合。
.常量 FolderItem_InvokeVerb, "23", , 在项目上执行动词。

.常量 FolderItemVerbs_get_Count, "7", , 包含集合中的项目数。
.常量 FolderItemVerbs_get_Application, "8", , 未实现。
.常量 FolderItemVerbs_get_Parent, "9", , 未实现。
.常量 FolderItemVerbs_Item, "10", , 检索集合中指定项目的FolderItemVerb对象。
.常量 FolderItemVerbs__NewEnum, "11", , 创建并返回一个新的FolderItemVerbs对象，该对象是此 FolderItemVerbs 对象的副本。

.常量 FolderItemVerb_get_Application, "7", , 未实现。
.常量 FolderItemVerb_get_Parent, "8", , 未实现。
.常量 FolderItemVerb_get_Name, "9", , 包含动词的名称。
.常量 FolderItemVerb_DoIt, "10", , 在与动词关联的FolderItem上执行动词。

.常量 ICustomDestinationList_SetAppID, "3", , 为其任务栏按钮将保存通过此接口的方法构建的自定义跳转列表的应用程序指定唯一的应用程序用户模型 ID (AppUserModelID)。此方法是可选的。
.常量 ICustomDestinationList_BeginList, "4", , 为自定义跳转列表启动构建会话。
.常量 ICustomDestinationList_AppendCategory, "5", , 定义自定义类别及其包含的目标，以包含在自定义跳转列表中。
.常量 ICustomDestinationList_AppendKnownCategory, "6", , 指定Frequent 或Recent 类别应包含在自定义跳转列表中。
.常量 ICustomDestinationList_AddUserTasks, "7", , 指定要包含在自定义跳转列表的任务类别中的项目。
.常量 ICustomDestinationList_CommitList, "8", , 声明由调用 ICustomDestinationList::BeginList 启动的跳转列表已完成并准备好显示。
.常量 ICustomDestinationList_GetRemovedDestinations, "9", , 检索用户从现有跳转列表中删除的当前目的地列表，此自定义跳转列表旨在替换该列表。
.常量 ICustomDestinationList_DeleteList, "10", , 删除指定应用程序的自定义跳转列表。
.常量 ICustomDestinationList_AbortList, "11", , 停止由 ICustomDestinationList::BeginList 启动的跳转列表构建会话，而不提交任何更改。

.常量 IObjectArray_GetCount, "3", , 提供集合中对象的计数。
.常量 IObjectArray_GetAt, "4", , 提供指向指定对象接口的指针。对象和接口由索引和接口 ID 指定。

.常量 IObjectCollection_AddObject, "5", , 将单个对象添加到集合中。
.常量 IObjectCollection_AddFromArray, "6", , 将包含在IObjectArray 中的对象添加到集合中。
.常量 IObjectCollection_RemoveObjectAt, "7", , 从集合中移除单个指定的对象。
.常量 IObjectCollection_Clear, "8", , 从集合中移除所有对象。

.常量 VARIANT_TRUE, "-1", , 该属性已被修改。
.常量 VARIANT_FALSE, "0", , 该属性尚未修改。

.常量 SeCreateTokenPrivilege, "1", , 需要创建主令牌。
.常量 SeAssignPrimaryTokenPrivilege, "2", , 需要分配进程的主令牌。
.常量 SeLockMemoryPrivilege, "3", , 需要在内存中锁定物理页。
.常量 SeIncreaseQuotaPrivilege, "4", , 需要增加分配给进程的配额。
.常量 SeUnsolicitedInputPrivilege, "5", , 需要从终端设备读取未经请求的输入。
.常量 SeMachineAccountPrivilege, "6", , 创建计算机帐户时需要。
.常量 SeTcbPrivilege, "7", , 将其持有者标识为受信任计算机库的一部分。某些受信任、受保护的子系统被授予此权限。
.常量 SeSecurityPrivilege, "8", , 需要执行许多与安全相关的功能，例如控制和查看审核消息。此权限将其持有人标识为安全操作员。
.常量 SeTakeOwnershipPrivilege, "9", , 被要求拥有一个对象的所有权而不被授予自由访问权。此权限仅允许将所有者值设置为持有者合法指定为对象所有者的值。
.常量 SeLoadDriverPrivilege, "10", , 需要加载或卸载设备驱动程序。
.常量 SeSystemProfilePrivilege, "11", , 需要收集整个系统的分析信息。
.常量 SeSystemtimePrivilege, "12", , 需要修改系统时间。
.常量 SeProfileSingleProcessPrivilege, "13", , 需要为单个进程收集分析信息。
.常量 SeIncreaseBasePriorityPrivilege, "14", , 需要增加进程的基本优先级。
.常量 SeCreatePagefilePrivilege, "15", , 创建分页文件时需要。
.常量 SeCreatePermanentPrivilege, "16", , 创建永久对象所必需的。
.常量 SeBackupPrivilege, "17", , 需要执行备份操作。
.常量 SeRestorePrivilege, "18", , 执行还原操作所需。此权限允许您将任何有效的用户或组SID设置为对象的所有者。
.常量 SeShutdownPrivilege, "19", , 需要关闭本地系统。
.常量 SeDebugPrivilege, "20", 公开, 调试进程所必需的。
.常量 SeAuditPrivilege, "21", , 需要生成审核日志项。
.常量 SeSystemEnvironmentPrivilege, "22", , 需要修改使用此类内存存储配置信息的系统的非易失性RAM。
.常量 SeChangeNotifyPrivilege, "23", , 需要接收文件或目录更改通知。此权限还会导致系统跳过所有遍历访问检查。默认情况下，它对所有用户都启用。
.常量 SeRemoteShutdownPrivilege, "24", , 需要使用网络请求关闭系统。
.常量 SeUndockPrivilege, "25", , 从扩展坞中卸下计算机时需要。
.常量 SeSyncAgentPrivilege, "26", , 需要同步目录服务数据。
.常量 SeEnableDelegationPrivilege, "27", , 必须启用计算机帐户和用户帐户以信任委派。
.常量 SeManageVolumePrivilege, "28", , 执行卷维护任务。
.常量 SeImpersonatePrivilege, "29", , 身份验证后模拟客户端。
.常量 SeCreateGlobalPrivilege, "30", , 需要在终端服务会话期间在全局命名空间中创建命名文件映射对象。默认情况下，管理员、服务和本地系统帐户会启用此权限。
.常量 SeTrustedCredManAccessPrivilege, "31", , 需要作为受信任的调用方访问凭据管理器。
.常量 SeRelabelPrivilege, "32", , 需要修改对象的强制完整性级别。
.常量 SeIncreaseWorkingSetPrivilege, "33", , 需要为在用户上下文中运行的应用程序分配更多内存。
.常量 SeTimeZonePrivilege, "34", , 需要调整与计算机内部时钟关联的时区。
.常量 SeCreateSymbolicLinkPrivilege, "35", , 需要创建符号链接。

.常量 IMAGE_NT_OPTIONAL_HDR32_MAGIC, "267", , 该文件是一个可执行映像。
.常量 IMAGE_NT_OPTIONAL_HDR64_MAGIC, "523", , 该文件是一个可执行映像。
.常量 IMAGE_ROM_OPTIONAL_HDR_MAGIC, "263", , 该文件是一个 ROM 映像。

.常量 SUB_CONTAINERS_AND_OBJECTS_INHERIT, "3", , 主对象包含的容器和非容器对象都继承了 ACE。此标志对应于 CONTAINER_INHERIT_ACE 和 OBJECT_INHERIT_ACE 标志的组合。
.常量 DACL_SECURITY_INFORMATION, "4", , 正在引用对象的 DACL。

.常量 SE_UNKNOWN_OBJECT_TYPE, "0", , 未知的对象类型。
.常量 SE_FILE_OBJECT, "1", , 表示文件或目录。
.常量 SE_SERVICE, "2", , 表示 Windows 服务。服务对象可以是本地服务，也可以是远程服务。
.常量 SE_PRINTER, "3", , 表示打印机。打印机对象可以是本地打印机，也可以是远程打印机。
.常量 SE_REGISTRY_KEY, "4", , 表示一个注册表项。注册表项对象可以位于本地注册表中或位于远程注册表中。
.常量 SE_LMSHARE, "5", , 表示网络共享。共享对象可以是本地的，也可以是远程的。
.常量 SE_KERNEL_OBJECT, "6", , 表示本地内核对象。
.常量 SE_WINDOW_OBJECT, "7", , 表示本地计算机上的窗口站或桌面对象。
.常量 SE_DS_OBJECT, "8", , 指示目录服务对象或目录服务对象的属性集或属性。
.常量 SE_DS_OBJECT_ALL, "9", , 指示目录服务对象及其所有属性集和属性。
.常量 SE_PROVIDER_DEFINED_OBJECT, "10", , 表示提供者定义的对象。
.常量 SE_WMIGUID_OBJECT, "11", , 表示 WMI 对象。
.常量 SE_REGISTRY_WOW64_32KEY, "12", , 表示 WOW64 下注册表项的对象。
.常量 SE_REGISTRY_WOW64_64KEY, "13", , 表示 WOW64 下注册表项的对象。

.常量 NOT_USED_ACCESS, "0", , 未使用的值。
.常量 GRANT_ACCESS, "1", 公开, 表示ACCESS_ALLOWED_ACE结构。新的 ACE 将指定的权利与受托人现有的任何允许或拒绝的权利相结合。
.常量 SET_ACCESS, "2", 公开, 表示允许指定权限的ACCESS_ALLOWED_ACE结构。在输入时，此值会丢弃受托人的任何现有访问控制信息。
.常量 DENY_ACCESS, "3", 公开, 表示拒绝指定权限的ACCESS_DENIED_ACE结构。
.常量 REVOKE_ACCESS, "4", , 指示删除指定受托者的所有现有ACCESS_ALLOWED_ACE或SYSTEM_AUDIT_ACE结构。
.常量 SET_AUDIT_SUCCESS, "5", , 表示SYSTEM_AUDIT_ACE结构，它为成功尝试使用指定的访问权限生成审计消息。在输入时，此值将指定的权限与受托人的任何现有审计访问权限组合在一起。
.常量 SET_AUDIT_FAILURE, "6", , 表示一个SYSTEM_AUDIT_ACE结构，它为使用指定访问权限的失败尝试生成审计消息。在输入时，此值将指定的权限与受托人的任何现有审计访问权限组合在一起。

.常量 VER_PRODUCT_TYPE, "128", , 产品类型
.常量 VER_EQUAL, "1", , 当前值必须等于指定值。

.常量 TokenGroups, "2", , 缓冲区接收包含与令牌关联的组帐户的TOKEN_GROUPS结构。
.常量 TokenIntegrityLevel, "25", , 缓冲区接收指定令牌完整性级别的TOKEN_MANDATORY_LABEL结构。
.常量 SECURITY_BUILTIN_DOMAIN_RID, "32", , 内置的系统域。
.常量 SECURITY_MANDATORY_LOW_RID, "4096", , 低MIC等级，如IE。
.常量 SECURITY_MANDATORY_MEDIUM_RID, "8192", , 中MIC等级，默认为这个等级，如Explorer。
.常量 SECURITY_MANDATORY_HIGH_RID, "12288", , 高MIC等级，以管理员身份运行的程序。
.常量 SECURITY_MANDATORY_SYSTEM_RID, "16384", , 系统MIC等级，一般是服务应用程序。
.常量 DOMAIN_ALIAS_RID_ADMINS, "544", , 域的管理员。

.常量 FILE_MAP_WRITE, "2", , 文件的读/写视图被映射。文件映射对象必须是使用PAGE_READWRITE或PAGE_EXECUTE_READWRITE保护创建的 。
.常量 FILE_MAP_READ, "4", , 文件的只读视图被映射。尝试写入文件视图会导致访问冲突。
.常量 FILE_MAP_EXECUTE, "32", , 文件的可执行视图被映射（映射的内存可以作为代码运行）。文件映射对象必须是使用PAGE_EXECUTE_READ、 PAGE_EXECUTE_WRITECOPY或PAGE_EXECUTE_READWRITE 保护创建的。
.常量 FILE_MAP_ALL_ACCESS, "983071", , 映射文件的读/写视图

.常量 IMAGE_DOS_SIGNATURE, "23117", , MZ
.常量 IMAGE_OS2_SIGNATURE, "17742", , NE
.常量 IMAGE_VXD_SIGNATURE, "17740", , LE
.常量 IMAGE_NT_SIGNATURE, "17744", , PE00

.常量 FMFD_URLASFILENAME, "1", , 将指定的pwzUrl视为文件名。

.常量 IWinHttpRequest_SetProxy, "7", , 设置代理服务器信息。
.常量 IWinHttpRequest_SetCredentials, "8", , 设置要与 HTTP 服务器（代理服务器或原始服务器）一起使用的凭据。
.常量 IWinHttpRequest_Open, "9", , 打开到 HTTP 资源的 HTTP 连接。
.常量 IWinHttpRequest_SetRequestHeader, "10", , 添加、更改或删除 HTTP 请求标头。
.常量 IWinHttpRequest_GetResponseHeader, "11", , 检索 HTTP 响应标头。
.常量 IWinHttpRequest_GetAllResponseHeaders, "12", , 检索所有 HTTP 响应标头。
.常量 IWinHttpRequest_Send, "13", , 向 HTTP 服务器发送 HTTP 请求。
.常量 IWinHttpRequest_get_Status, "14", , 上次响应的 HTTP 状态代码。
.常量 IWinHttpRequest_get_StatusText, "15", , HTTP 状态文本。
.常量 IWinHttpRequest_get_ResponseText, "16", , 响应实体主体。
.常量 IWinHttpRequest_get_ResponseBody, "17", , 响应实体主体为无符号字节数组。
.常量 IWinHttpRequest_get_ResponseStream, "18", , 作为IStream的响应实体主体。
.常量 IWinHttpRequest_get_Option, "19", , 读 WinHTTP 选项值。
.常量 IWinHttpRequest_put_Option, "20", , 写 WinHTTP 选项值。
.常量 IWinHttpRequest_WaitForResponse, "21", , 等待异步发送方法完成，具有可选的超时值，以秒为单位。
.常量 IWinHttpRequest_Abort, "22", , 中止WinHTTP Send方法。
.常量 IWinHttpRequest_SetTimeouts, "23", , 指定发送/接收操作的各个超时组件，以毫秒为单位。
.常量 IWinHttpRequest_SetClientCertificate, "24", , 选择要发送到安全超文本传输协议 (HTTPS) 服务器的客户端证书。
.常量 IWinHttpRequest_SetAutoLogonPolicy, "25", , 设置当前的自动登录策略。

.常量 WinHttpRequestOption_UserAgentString, "0", , 设置或检索包含用户代理字符串的VARIANT 。
.常量 WinHttpRequestOption_URL, "1", , 检索包含资源 URL 的VARIANT 。该值是只读的；您不能使用此属性设置 URL。在调用Open方法之前无法读取 URL 。此选项对于在Send方法完成后检查 URL 以验证是否发生了任何重定向很有用。
.常量 WinHttpRequestOption_URLCodePage, "2", , 设置或检索标识URL 字符串的代码页的VARIANT 。默认值为 UTF-8 代码页。代码页用于将在Open方法中传递的 Unicode URL 字符串转换为单字节字符串表示。
.常量 WinHttpRequestOption_EscapePercentInURL, "3", , 设置或检索一个VARIANT，它指示 URL 字符串中的百分比字符是否转换为转义序列。此选项的默认值是VARIANT_TRUE，它指定所有不安全的美国国家标准协会 (ANSI) 字符（百分比符号除外）都转换为转义序列。
.常量 WinHttpRequestOption_SslErrorIgnoreFlags, "4", , 设置或检索指示应忽略哪些服务器证书错误的VARIANT 。
.常量 WinHttpRequestOption_SelectCertificate, "5", , 设置一个VARIANT，指定发送到服务器进行身份验证的客户端证书。此选项指示以反斜杠分隔的客户端证书的位置、证书存储和主题。
.常量 WinHttpRequestOption_EnableRedirects, "6", , 设置或检索一个VARIANT ，该 VARIANT指示当服务器为资源指定新位置时是否自动重定向请求。此选项的默认值是VARIANT_TRUE表示请求被自动重定向。
.常量 WinHttpRequestOption_UrlEscapeDisable, "7", , 设置或检索一个VARIANT，它指示 URL 的路径和查询组件中的不安全字符是否转换为转义序列。此选项的默认值为VARIANT_TRUE，它指定转换路径和查询中的字符。
.常量 WinHttpRequestOption_UrlEscapeDisableQuery, "8", , 设置或检索一个VARIANT，它指示 URL 的查询组件中的不安全字符是否转换为转义序列。此选项的默认值为VARIANT_TRUE，它指定转换查询中的字符。
.常量 WinHttpRequestOption_SecureProtocols, "9", , 设置或检索指示可以使用哪些安全协议的VARIANT 。此选项选择客户端可接受的协议。该协议是在安全套接字层 (SSL) 握手期间协商的。
.常量 WinHttpRequestOption_EnableTracing, "10", , 设置或检索指示当前是否启用跟踪的VARIANT 。
.常量 WinHttpRequestOption_RevertImpersonationOverSsl, "11", , 控制WinHttpRequest对象是否在 SSL 证书身份验证操作期间临时恢复客户端模拟。WinHttpRequest对象的默认设置是TRUE。将此选项设置为FALSE以在执行证书身份验证操作时保持模拟。
.常量 WinHttpRequestOption_EnableHttpsToHttpRedirects, "12", , 控制 WinHTTP 是否允许重定向。默认情况下，所有重定向都会自动跟随，除了从安全 (https) URL 传输到非安全 (http) URL 的重定向。将此选项设置为TRUE以启用 HTTPS 到 HTTP 重定向。
.常量 WinHttpRequestOption_EnablePassportAuthentication, "13", , 启用或禁用对 Passport 身份验证的支持。默认情况下，对 Passport 身份验证的自动支持是禁用的；将此选项设置为TRUE以启用 Passport 身份验证支持。
.常量 WinHttpRequestOption_MaxAutomaticRedirects, "14", , 设置或检索 WinHTTP 遵循的最大重定向数；默认值为 10。此限制可防止未经授权的站点在大量重定向后使 WinHTTP 客户端停止。
.常量 WinHttpRequestOption_MaxResponseHeaderSize, "15", , 设置或检索服务器响应的标头部分的最大大小的绑定集。此界限可保护客户端免受恶意服务器试图通过发送包含无限量标头数据的响应来阻止客户端。默认值为 64 KB。
.常量 WinHttpRequestOption_MaxResponseDrainSize, "16", , 设置或检索将从响应中排出的数据量的界限，以便重用连接。默认值为 1 MB。
.常量 WinHttpRequestOption_EnableHttp1_1, "17", , 设置或检索一个布尔值，该值指示应该使用 HTTP/1.1 还是 HTTP/1.0。默认值为TRUE，因此默认使用 HTTP/1.1。
.常量 WinHttpRequestOption_EnableCertificateRevocationCheck, "18", , 在 SSL 协商期间启用服务器证书吊销检查。当服务器提供证书时，将执行检查以确定证书是否已被其颁发者吊销。如果证书确实被吊销了，或者吊销检查因为无法下载证书吊销列表（CRL）而失败，则请求失败；无法抑制此类撤销错误。
.常量 WinHttpRequestOption_RejectUserpwd, "19", , 拒绝的URL输入包含用户名，密码，或两者。

.常量 IPicture_get_Handle, "3", , 检索此图片对象中管理的图片的句柄到指定位置。
.常量 IPicture_get_hPal, "4", , 检索图片对象当前使用的调色板的副本。
.常量 IPicture_get_Type, "5", , 检索图片对象中包含的图片的当前类型。
.常量 IPicture_get_Width, "6", , 检索图片对象中图片的当前宽度。
.常量 IPicture_get_Height, "7", , 检索图片对象中图片的当前高度。
.常量 IPicture_Render, "8", , 渲染（绘制）由源图片的偏移量 (xSrc,ySrc) 和要复制的尺寸 (cxSrc,xySrc) 定义的图片的指定部分。
.常量 IPicture_set_hPal, "9", , 将 GDI 调色板分配给图片对象中包含的图片。
.常量 IPicture_get_CurDC, "10", , 检索当前设备上下文的句柄。该属性仅对位图图片有效。
.常量 IPicture_SelectPicture, "11", , 将位图图片选择到给定的设备上下文中，并返回先前选择图片的设备上下文以及图片的 GDI 句柄。此方法与 IPicture_get_CurDC 结合使用。
.常量 IPicture_get_KeepOriginalFormat, "12", , 检索图片的 KeepOriginalFormat 属性的当前值。
.常量 IPicture_put_KeepOriginalFormat, "13", , 设置图片的 KeepOriginalFormat 属性的值。
.常量 IPicture_PictureChanged, "14", , 通知图片对象其图片资源已更改。此方法仅使用 DISPID_PICT_HANDLE 为任何连接的接收器调用 IPropertyNotifySink::OnChanged。
.常量 IPicture_SaveAsFile, "15", , 将图片的数据保存到流中，其格式与将其保存到文件中的格式相同。位图使用 BMP 文件格式，元文件使用 WMF 格式，图标使用 ICO 格式。
.常量 IPicture_get_Attributes, "16", , 检索图片的当前位属性集。

.常量 VK_OEM_1, "186", , ;:
.常量 VK_OEM_PLUS, "187", , +
.常量 VK_OEM_COMMA, "188", , ,
.常量 VK_OEM_MINUS, "189", , -
.常量 VK_OEM_PERIOD, "190", , .
.常量 VK_OEM_2, "191", , /?
.常量 VK_OEM_3, "192", , `~

.常量 HCBT_MOVESIZE, "0", , 一个窗口即将被移动或调整大小。
.常量 HCBT_MINMAX, "1", , 一个窗口即将被最小化或最大化。
.常量 HCBT_QS, "2", , 系统已从系统消息队列中检索到WM_QUEUESYNC消息。
.常量 HCBT_CREATEWND, "3", , 即将创建一个窗口。系统在向窗口发送WM_CREATE或WM_NCCREATE消息之前调用钩子过程。如果钩子过程返回一个非零值，则系统销毁窗口；CreateWindow函数返回NULL，但WM_DESTROY消息不会发送到窗口。如果钩子过程返回零，则正常创建窗口。
.常量 HCBT_DESTROYWND, "4", , 一扇窗户即将被摧毁。
.常量 HCBT_ACTIVATE, "5", , 系统即将激活一个窗口。
.常量 HCBT_CLICKSKIPPED, "6", , 系统已从系统消息队列中删除了一条鼠标消息。收到此挂钩代码后，CBT 应用程序必须安装WH_JOURNALPLAYBACK挂钩程序以响应鼠标消息。
.常量 HCBT_KEYSKIPPED, "7", , 系统已从系统消息队列中删除了一条键盘消息。收到此挂钩代码后，CBT 应用程序必须安装WH_JOURNALPLAYBACK挂钩程序以响应键盘消息。
.常量 HCBT_SYSCOMMAND, "8", , 即将执行系统命令。这允许 CBT 应用程序通过热键来防止任务切换。
.常量 HCBT_SETFOCUS, "9", , 一个窗口即将获得键盘焦点。

.常量 OAIF_ALLOW_REGISTRATION, "1", , 启用“始终使用此程序”复选框。如果没有通过，它将被禁用。
.常量 OAIF_REGISTER_EXT, "2", , 在用户点击OK按钮后进行注册。
.常量 OAIF_EXEC, "4", , 注册后执行文件。
.常量 OAIF_FORCE_REGISTRATION, "8", , 强制选中始终使用此程序复选框。

.常量 OFN_OVERWRITEPROMPT, "2", , 如果所选文件已存在，则使“另存为”对话框生成一个消息框。用户必须确认是否覆盖文件。
.常量 OFN_HIDEREADONLY, "4", , 隐藏只读复选框。
.常量 OFN_ENABLEHOOK, "32", , 启用在lpfnHook成员中指定的钩子函数。
.常量 OFN_PATHMUSTEXIST, "2048", , 用户只能键入有效的路径和文件名。如果使用此标志并且用户在“文件名”输入字段中键入了无效的路径和文件名，则对话框功能会在消息框中显示警告。
.常量 OFN_FILEMUSTEXIST, "4096", , 用户只能在文件名输入字段中键入现有文件的名称。如果指定了此标志并且用户输入了无效名称，则对话框过程会在消息框中显示警告。
.常量 OFN_EXPLORER, "524288", , 指示对“打开”或“另存为”对话框所做的任何自定义都使用资源管理器样式的自定义方法。
.常量 OFN_ENABLESIZING, "8388608", , 允许使用鼠标或键盘调整资源管理器样式对话框的大小。

.常量 CDN_INITDONE, "-601", , 当系统完成对话框中的控件排列后，由资源管理器样式的打开或另存为对话框发送。系统移动标准控件，为子对话框的控件腾出空间。

.常量 ISpVoice_SetOutput, "13", , 设置当前输出对象。该对象可以是流、音频设备或输出音频设备的对象令牌。
.常量 ISpVoice_Speak, "20", , 说出文本字符串或文件的内容。
.常量 ISpStreamFormat_GetFormat, "14", , 传回流的缓存格式。
.常量 ISpVoice_GetOutputStream, "15", , 检索指向当前输出流的指针。
.常量 ISpStream_BindToFile, "17", , 将输入流绑定到它所标识的文件。

.常量 SPFM_CREATE_ALWAYS, "3", , 创建文件，即使文件已经存在并删除前一个文件。该标志表示文件将以读写模式打开。
.常量 SPF_DEFAULT, "0", , 指定应使用默认设置。

.常量 IFileDialogCustomize_EnableOpenDropDown, "3", , 在对话框中的“打开”或“保存”按钮上启用下拉列表。
.常量 IFileDialogCustomize_AddMenu, "4", , 向对话框添加一个菜单。
.常量 IFileDialogCustomize_AddPushButton, "5", , 向对话框中添加一个按钮。
.常量 IFileDialogCustomize_AddComboBox, "6", , 向对话框中添加一个组合框。
.常量 IFileDialogCustomize_AddRadioButtonList, "7", , 将选项按钮（也称为单选按钮）组添加到对话框。
.常量 IFileDialogCustomize_AddCheckButton, "8", , 向对话框中添加一个复选按钮（复选框）。
.常量 IFileDialogCustomize_AddEditBox, "9", , 向对话框添加一个编辑框控件。
.常量 IFileDialogCustomize_AddSeparator, "10", , 向对话框添加分隔符，允许控件的可视分隔。
.常量 IFileDialogCustomize_AddText, "11", , 将文本内容添加到对话框。
.常量 IFileDialogCustomize_SetControlLabel, "12", , 设置与控件关联的文本，例如按钮文本或编辑框标签。
.常量 IFileDialogCustomize_GetControlState, "13", , 获取给定控件的当前可见性和启用状态。
.常量 IFileDialogCustomize_SetControlState, "14", , 设置给定控件的当前可见性和启用状态。
.常量 IFileDialogCustomize_GetEditBoxText, "15", , 获取编辑框控件中的当前文本。
.常量 IFileDialogCustomize_SetEditBoxText, "16", , 设置对话框中的编辑框控件中的文本。
.常量 IFileDialogCustomize_GetCheckButtonState, "17", , 获取对话框中复选按钮（复选框）的当前状态。
.常量 IFileDialogCustomize_SetCheckButtonState, "18", , 设置对话框中复选按钮（复选框）的状态。
.常量 IFileDialogCustomize_AddControlItem, "19", , 将项添加到对话框中的容器控件。
.常量 IFileDialogCustomize_RemoveControlItem, "20", , 从对话框中的容器控件中删除项。
.常量 IFileDialogCustomize_RemoveAllControlItems, "21", , 未实现。
.常量 IFileDialogCustomize_GetControlItemState, "22", , 获取在对话框中找到的容器控件中项的当前状态。
.常量 IFileDialogCustomize_SetControlItemState, "23", , 在对话框中找到的容器控件中设置项的当前状态。
.常量 IFileDialogCustomize_GetSelectedControlItem, "24", , 从对话框中的指定容器控件中获取特定项。
.常量 IFileDialogCustomize_SetSelectedControlItem, "25", , 设置选项按钮组或对话框中的组合框中特定项的选定状态。
.常量 IFileDialogCustomize_StartVisualGroup, "26", , 在对话框中声明一个视觉组。对任何“add”方法的后续调用会将这些元素添加到该组中。
.常量 IFileDialogCustomize_EndVisualGroup, "27", , 停止向对话框中的可视组添加元素。
.常量 IFileDialogCustomize_MakeProminent, "28", , 在对话框中放置一个控件，以便与其他添加的控件相比它更加突出。
.常量 IFileDialogCustomize_SetControlItemText, "29", , 设置控件项的文本。例如，伴随单选按钮或菜单项的文本。

.常量 ISWbemDateTime_put_Value, "8", , 完整的 CIM日期时间值。
.常量 ISWbemDateTime_GetFileTime, "45", , 将表示为BSTR的FILETIME日期和时间转换为 WMI DATETIME格式。

.常量 SB_HORZ, "0", 公开, 显示或隐藏窗口的标准水平滚动条。
.常量 SB_VERT, "1", 公开, 显示或隐藏窗口的标准垂直滚动条。
.常量 SB_CTL, "2", 公开, 显示或隐藏滚动条控件。hwnd参数必须是滚动条控件的句柄 。
.常量 SB_BOTH, "3", 公开, 显示或隐藏窗口的标准水平和垂直滚动条。

.常量 CREDUIWIN_GENERIC, "1", , 调用方请求凭据提供程序以纯文本形式返回用户名和密码。此值不能与 SECURE_PROMPT结合使用。
.常量 ERROR_LOGON_FAILURE, "1326", , 提供的凭证是无效的。

.常量 CTRL_C_EVENT, "0", 公开, 从键盘输入或 GenerateConsoleCtrlEvent 函数生成的信号接收到 + 信号。CTRL + C
.常量 CTRL_BREAK_EVENT, "1", 公开, 从键盘输入或 GenerateConsoleCtrlEvent 生成的信号接收到 + 信号。CTRL + BREAK
.常量 CTRL_CLOSE_EVENT, "2", 公开, 当用户关闭控制台时，系统会向附加到控制台的所有进程发送信号（通过单击控制台窗口窗口菜单上的“关闭”，或单击任务管理器中的“结束任务”按钮命令）。
.常量 CTRL_LOGOFF_EVENT, "5", 公开, 用户注销时系统发送到所有控制台进程的信号。此信号不指示哪个用户正在注销，因此无法做出任何假设。
.常量 CTRL_SHUTDOWN_EVENT, "6", 公开, 系统关闭时系统发送的信号。当系统发送此信号时，交互式应用程序不存在，因此在这种情况下只能接收服务。服务还具有自己的关闭事件通知机制。

.常量 DLL_PROCESS_ATTACH, "1", 公开, 由于启动进程或调用 LoadLibrary，DLL 正在加载到当前进程的虚拟地址空间中。
.常量 DLL_THREAD_ATTACH, "2", 公开, 当前进程正在创建新线程。
.常量 DLL_THREAD_DETACH, "3", 公开, 线程正在完全退出。
.常量 DLL_PROCESS_DETACH, "0", 公开, DLL 正在从调用进程的虚拟地址空间中卸载。

.常量 SCS_32BIT_BINARY, "0", 公开, 基于 32 位 Windows 的应用程序
.常量 SCS_DOS_BINARY, "1", 公开, 基于 MS-DOS 的应用程序
.常量 SCS_WOW_BINARY, "2", 公开, 基于 16 位 Windows 的应用程序
.常量 SCS_PIF_BINARY, "3", 公开, 执行基于 MS-DOS 的应用程序的 PIF 文件
.常量 SCS_POSIX_BINARY, "4", 公开, 基于 POSIX 的应用程序
.常量 SCS_OS216_BINARY, "5", 公开, 基于 16 位 OS/2 的应用程序
.常量 SCS_64BIT_BINARY, "6", 公开, 基于 64 位 Windows 的应用程序

.常量 LOGON32_LOGON_INTERACTIVE, "2", , 此登录类型适用于将以交互方式使用计算机的用户
.常量 LOGON32_LOGON_NETWORK, "3", , 此登录类型适用于高性能服务器对纯文本密码进行身份验证
.常量 LOGON32_PROVIDER_DEFAULT, "0", , 对系统使用标准登录提供程序

.常量 VOLUME_NAME_DOS, "0", , 返回带驱动器号的路径
.常量 VOLUME_NAME_GUID, "1", , 返回具有卷 GUID 路径而不是驱动器名称的路径
.常量 VOLUME_NAME_NT, "2", , 返回 NT 设备对象路径
.常量 VOLUME_NAME_NONE, "4", , 返回没有驱动器信息的路径

.版本 2

.数据类型 精易_表头样式, 公开
    .成员 参_列索引, 整数型
    .成员 参_文本色, 整数型
    .成员 参_背景色, 整数型

.数据类型 DRAWITEMSTRUCT, , 12*4=48
    .成员 CtlType, 整数型, , , 控件类型
    .成员 CtlID, 整数型, , , 组合框、列表框等控件的ID标识号
    .成员 itemID, 整数型, , , 菜单项的ID标识 号或列表框、组合框中某一项的索引值
    .成员 itemAction, 整数型, , , 控件行为
    .成员 itemState, 整数型, , , 控件状态
    .成员 hwndItem, 整数型, , , 父窗口句柄或菜单句柄
    .成员 hDC, 整数型, , , 控件对应的绘图设备句柄
    .成员 rcItem, RECT, , , 控件所占据的矩形区域,注意：这里不是传址，4*4=16
    .成员 itemData, 整数型, , , 列表框或组合框中某一项的值

.数据类型 HDITEM
    .成员 mask, 整数型
    .成员 cxy, 整数型
    .成员 pszText, 字节集, , , LPSTR　字符串指针
    .成员 hbm, 整数型, , , HBITMAP　句柄
    .成员 cchTextMax, 整数型
    .成员 fmt, 整数型
    .成员 lParam, 整数型, , , LPARAM　自定义类型
    .成员 iImage, 整数型
    .成员 iOrder, 整数型
    .成员 type, 整数型
    .成员 pvFilter, 整数型, , , void　无类型指针
    .成员 state, 整数型

.数据类型 RECT, 公开
    .成员 left, 整数型
    .成员 top, 整数型
    .成员 right, 整数型
    .成员 bottom, 整数型

.数据类型 剪辑版数据, 公开
    .成员 剪辑版数据格式, 整数型
    .成员 文本型数据, 文本型
    .成员 字节集长度, 整数型
    .成员 字节集数据, 字节集

.数据类型 WINDOWPOS
    .成员 hwnd, 整数型
    .成员 hwndInsertAfter, 整数型
    .成员 x, 整数型
    .成员 y, 整数型
    .成员 cx, 整数型
    .成员 cy, 整数型
    .成员 flags, 整数型

.数据类型 NMHDR, , 12
    .成员 hWndFrom, 整数型
    .成员 idFrom, 整数型
    .成员 code, 整数型

.数据类型 NMCUSTOMDRAW, , 48
    .成员 hdr, NMHDR, , , 12
    .成员 dwDrawStage, 整数型, , , 4
    .成员 hdc, 整数型, , , 4
    .成员 rc, 矩形信息, , , 16
    .成员 dwItemSpec, 整数型, , , 4
    .成员 uItemState, 整数型, , , 4
    .成员 lItemlParam, 整数型, , , 4

.数据类型 NMLVCUSTOMDRAW, , 48+40+16=104
    .成员 nmcd, NMCUSTOMDRAW, , , 48
    .成员 clrText, 整数型, , , 4
    .成员 clrTextBk, 整数型, , , 4
    .成员 iSubItem, 整数型, , , 4
    .成员 dwItemType, 整数型, , , 4
    .成员 clrFace, 整数型, , , 4
    .成员 iIconEffect, 整数型, , , 4
    .成员 iIconPhase, 整数型, , , 4
    .成员 iPartId, 整数型, , , 4
    .成员 iStateId, 整数型, , , 4
    .成员 rcText, 矩形信息, , , 16
    .成员 uAlign, 整数型, , , 4

.数据类型 LVINFO
    .成员 窗口句柄, 整数型
    .成员 对象, 对象

.数据类型 TCITEM
    .成员 mask, 整数型
    .成员 dwState, 整数型
    .成员 dwStateMask, 整数型
    .成员 pszText, 文本型
    .成员 cchTextMax, 整数型
    .成员 iImage, 整数型
    .成员 lParam, 整数型

.数据类型 SYSTEM_PROCESSES
    .成员 NextEntryDelta, 整数型
    .成员 ThreadCount, 整数型
    .成员 Reserved1, 整数型, , "6"
    .成员 CreateTime, 长整数型
    .成员 UserTime, 长整数型
    .成员 KernelTime, 长整数型
    .成员 ProcessName, UNICODE_STRING
    .成员 BasePriority, 整数型
    .成员 ProcessID, 整数型
    .成员 InheritedFromProcessId, 整数型
    .成员 HandleCount, 整数型
    .成员 SessionId, 整数型
    .成员 Reserved2, 整数型, , "2"
    .成员 VmCounters, VM_COUNTERS
    .成员 PrivatePageCount, 整数型
    .成员 IoCounters, IO_COUNTERSEX
    .成员 Threads, SYSTEM_THREADS, , "1"

.数据类型 VM_COUNTERS, 公开, 进程_取父ID
    .成员 PeakVirtualSize, 整数型
    .成员 VirtualSize, 整数型
    .成员 PageFaultCount, 整数型
    .成员 PeakWorkingSetSize, 整数型
    .成员 WorkingSetSize, 整数型
    .成员 QuotaPeakPagedPoolUsage, 整数型
    .成员 QuotaPagedPoolUsage, 整数型
    .成员 QuotaPeakNonPagedPoolUsage, 整数型
    .成员 QuotaNonPagedPoolUsage, 整数型
    .成员 PagefileUsage, 整数型
    .成员 PeakPagefileUsage, 整数型

.数据类型 IO_COUNTERSEX
    .成员 ReadOperationCount, 长整数型
    .成员 WriteOperationCount, 长整数型
    .成员 OtherOperationCount, 长整数型
    .成员 ReadTransferCount, 长整数型
    .成员 WriteTransferCount, 长整数型
    .成员 OtherTransferCount, 长整数型

.数据类型 SYSTEM_THREADS
    .成员 KernelTime, 长整数型
    .成员 UserTime, 长整数型
    .成员 CreateTime, 长整数型
    .成员 WaitTime, 整数型
    .成员 StartAddress, 整数型
    .成员 ClientId, CLIENT_ID
    .成员 Priority, 整数型
    .成员 BasePriority, 整数型
    .成员 ContextSwitchCount, 整数型
    .成员 State, 整数型
    .成员 WaitReason, 整数型

.数据类型 菜单消息, 公开
    .成员 名称, 文本型
    .成员 是否插入, 逻辑型, , , 默认为假 假=在菜单末尾添加新的菜单
    .成员 事件, 子程序指针

.数据类型 菜单结构
    .成员 窗口句柄, 整数型
    .成员 菜单标题, 文本型
    .成员 插入位置, 整数型
    .成员 原回调地址, 整数型
    .成员 菜单数据, 菜单消息, , "1"

.数据类型 精易_任务栏缩略图按钮, 公开
    .成员 掩码, 整数型, , , “缩略图按钮掩码_”开头常量组合
    .成员 ID, 整数型
    .成员 图片索引, 整数型
    .成员 图标, 整数型
    .成员 提示文本, 文本型
    .成员 按钮风格, 整数型, , , “缩略图按钮_”开头常量组合

.数据类型 THUMBBUTTON
    .成员 dwMask, 整数型
    .成员 iId, 整数型
    .成员 iBitmap, 整数型
    .成员 hIcon, 整数型
    .成员 szTip, 字节型, , "520"
    .成员 dwFlags, 整数型

.数据类型 DISPLAY_DEVICEA, 公开
    .成员 cb, 整数型
    .成员 DeviceName, 字节型, , "32"
    .成员 DeviceString, 字节型, , "128"
    .成员 StateFlags, 整数型
    .成员 DeviceID, 字节型, , "128"
    .成员 DeviceKey, 字节型, , "128"

.数据类型 MOUSEHOOKSTRUCT, 公开
    .成员 pt, POINT
    .成员 hwnd, 整数型, , , 如果消息是WM_MOUSEWHEEL，则该成员的高位字是轮增量。低位字是保留的。正值表示车轮向前旋转，远离用户; 负值表示车轮向后旋转，朝向用户。单轮定位单击定义为WHEEL_DELTA，即120。如果消息是WM_XBUTTONDOWN，WM_XBUTTONUP，WM_XBUTTONDBLCLK，WM_NCXBUTTONDOWN，WM_NCXBUTTONUP或WM_NCXBUTTONDBLCLK，则高位字指定按下或释放哪个X按钮，并保留低位字。
    .成员 wHitTestCode, 整数型
    .成员 dwExtraInfo, 整数型

.数据类型 POINT, 公开
    .成员 X, 整数型
    .成员 Y, 整数型

.数据类型 HashMap_Str_Str_键值型
    .成员 散列值, 整数型
    .成员 键, 文本型
    .成员 值, 整数型

.数据类型 HashMap_Str_Str_节点型
    .成员 键值链数组, HashMap_Str_Str_键值型, , "1"

.数据类型 LIST_ENTRY64
    .成员 Flink, 长整数型
    .成员 Blink, 长整数型

.数据类型 LDR_DATA_TABLE_ENTRY64
    .成员 InLoadOrderLinks, LIST_ENTRY64, , , 按加载顺序
    .成员 InMemoryOrderLinks, LIST_ENTRY64, , , 按内存顺序
    .成员 InInitializationOrderLinks, LIST_ENTRY64, , , 按初始化顺序
    .成员 DllBase, 长整数型
    .成员 EntryPoint, 长整数型
    .成员 SizeOfImage, 长整数型
    .成员 FullDllName, UNICODE_STRING64
    .成员 BaseDllName, UNICODE_STRING64

.数据类型 模块信息, 公开
    .成员 模块句柄, 文本型
    .成员 模块路径, 文本型

.数据类型 位图结构_
    .成员 bmType, 整数型, , , 一定是0
    .成员 位图宽度, 整数型, , , bmWidth
    .成员 位图高度, 整数型, , , bmHeight
    .成员 bmWidthBytes, 整数型
    .成员 bmPlanes, 整数型
    .成员 bmBitsPixel, 整数型
    .成员 bmBits, 整数型

.数据类型 TRAYDATAEX
    .成员 hWnd, 整数型
    .成员 idCommand, 整数型
    .成员 strFilePath, 文本型
    .成员 strTile, 文本型

.数据类型 TRAYDATA
    .成员 hWnd, 长整数型
    .成员 uID, 整数型
    .成员 uCallbackMessage, 整数型
    .成员 Reserved, 整数型, , "2"
    .成员 hIcon, 整数型

.数据类型 TBBUTTON
    .成员 idBitMap, 整数型
    .成员 idCommand, 整数型
    .成员 fsState, 字节型
    .成员 fsStyle, 字节型
    .成员 bReserved, 字节型, , "6"
    .成员 dwData, 整数型
    .成员 iString, 整数型

.数据类型 CLIENT_ID
    .成员 UniqueProcess, 整数型
    .成员 UniqueThread, 整数型

.数据类型 OBJECT_ATTRIBUTES
    .成员 Length, 整数型
    .成员 RootDirectory, 整数型
    .成员 ObjectName, 整数型
    .成员 Attributes, 整数型
    .成员 SecurityDescriptor, 整数型
    .成员 SecurityQualityOfService, 整数型

.数据类型 SYSTEM_HANDLE_TABLE_ENTRY_INFO
    .成员 UniqueProcessId, 短整数型, , , ""
    .成员 CreatorBackTraceIndex, 短整数型, , , ""
    .成员 ObjectTypeIndex, 字节型, , , ""
    .成员 HandleAttributes, 字节型, , , ""
    .成员 HandleValue, 短整数型, , , ""
    .成员 pObject, 整数型, , , ""
    .成员 GrantedAccess, 整数型, , , ""

.数据类型 IP_ADDR_STRING
    .成员 Next, 整数型
    .成员 IpAddress, 字节型, , "16", IP_ADDRESS_STRING
    .成员 IpMask, 字节型, , "16", IP_MASK_STRING=IP_ADDRESS_STRING
    .成员 Context, 整数型

.数据类型 精易_网卡信息, 公开
    .成员 名称, 文本型
    .成员 连接名称, 文本型
    .成员 Mac, 文本型
    .成员 Ip, 文本型
    .成员 掩码, 文本型
    .成员 网关, 文本型
    .成员 DNS1, 文本型
    .成员 DNS2, 文本型

.数据类型 IMAGE_DATA_DIRECTORY
    .成员 VirtualAddress, 整数型
    .成员 Size, 整数型

.数据类型 IMAGE_OPTIONAL_HEADER
    .成员 Magic, 短整数型
    .成员 MajorLinkerVersion, 字节型
    .成员 MinorLinkerVersion, 字节型
    .成员 SizeOfCode, 整数型
    .成员 SizeOfInitializedData, 整数型
    .成员 SizeOfUnitializedData, 整数型
    .成员 AddressOfEntryPoint, 整数型
    .成员 BaseOfCode, 整数型
    .成员 BaseOfData, 整数型
    .成员 ImageBase, 整数型
    .成员 SectionAlignment, 整数型
    .成员 FileAlignment, 整数型
    .成员 MajorOperatingSystemVersion, 短整数型
    .成员 MinorOperatingSystemVersion, 短整数型
    .成员 MajorImageVersion, 短整数型
    .成员 MinorImageVersion, 短整数型
    .成员 MajorSubsystemVersion, 短整数型
    .成员 MinorSubsystemVersion, 短整数型
    .成员 W32VersionValue, 整数型
    .成员 SizeOfImage, 整数型
    .成员 SizeOfHeaders, 整数型
    .成员 CheckSum, 整数型
    .成员 SubSystem, 短整数型
    .成员 DllCharacteristics, 短整数型
    .成员 SizeOfStackReserve, 整数型
    .成员 SizeOfStackCommit, 整数型
    .成员 SizeOfHeapReserve, 整数型
    .成员 SizeOfHeapCommit, 整数型
    .成员 LoaderFlags, 整数型
    .成员 NumberOfRvaAndSizes, 整数型
    .成员 DataDirectory, IMAGE_DATA_DIRECTORY, , "16"

.数据类型 IMAGE_FILE_HEADER
    .成员 Machine, 短整数型
    .成员 NumberOfSections, 短整数型
    .成员 TimeDateStamp, 整数型
    .成员 PointerToSymbolTable, 整数型
    .成员 NumberOfSymbols, 整数型
    .成员 SizeOfOptionalHeader, 短整数型
    .成员 characteristics, 短整数型

.数据类型 FLOATING_SAVE_AREA
    .成员 ControlWord, 整数型
    .成员 StatusWord, 整数型
    .成员 TagWord, 整数型
    .成员 ErrorOffset, 整数型
    .成员 ErrorSelector, 整数型
    .成员 DataOffset, 整数型
    .成员 DataSelector, 整数型
    .成员 RegisterArea, 字节型, , "80"
    .成员 Cr0NpxState, 整数型

.数据类型 IMAGE_SECTION_HEADER
    .成员 SecName, 字节型, , "8"
    .成员 VirtualSize, 整数型
    .成员 VirtualAddress, 整数型
    .成员 SizeOfRawData, 整数型
    .成员 PointerToRawData, 整数型
    .成员 PointerToRelocations, 整数型
    .成员 PointerToLinenumbers, 整数型
    .成员 NumberOfRelocations, 短整数型
    .成员 NumberOfLinenumbers, 短整数型
    .成员 characteristics, 整数型

.数据类型 CONTEXT86
    .成员 ContextFlags, 整数型
    .成员 Dr0, 整数型
    .成员 Dr1, 整数型
    .成员 Dr2, 整数型
    .成员 Dr3, 整数型
    .成员 Dr6, 整数型
    .成员 Dr7, 整数型
    .成员 FloatSave, FLOATING_SAVE_AREA
    .成员 SegGs, 整数型
    .成员 SegFs, 整数型
    .成员 SegEs, 整数型
    .成员 SegDs, 整数型
    .成员 Edi, 整数型
    .成员 Esi, 整数型
    .成员 Ebx, 整数型
    .成员 Edx, 整数型
    .成员 Ecx, 整数型
    .成员 Eax, 整数型
    .成员 Ebp, 整数型
    .成员 Eip, 整数型
    .成员 SegCs, 整数型
    .成员 EFlags, 整数型
    .成员 Esp, 整数型
    .成员 SegSs, 整数型

.数据类型 IMAGE_NT_HEADERS
    .成员 Signature, 整数型
    .成员 FileHeader, IMAGE_FILE_HEADER
    .成员 OptionalHeader, IMAGE_OPTIONAL_HEADER

.数据类型 IMAGE_DOS_HEADER
    .成员 e_magic, 短整数型
    .成员 e_cblp, 短整数型
    .成员 e_cp, 短整数型
    .成员 e_crlc, 短整数型
    .成员 e_cparhdr, 短整数型
    .成员 e_minalloc, 短整数型
    .成员 e_maxalloc, 短整数型
    .成员 e_ss, 短整数型
    .成员 e_sp, 短整数型
    .成员 e_csum, 短整数型
    .成员 e_ip, 短整数型
    .成员 e_cs, 短整数型
    .成员 e_lfarlc, 短整数型
    .成员 e_ovno, 短整数型
    .成员 e_res, 短整数型, , "4"
    .成员 e_oemid, 短整数型
    .成员 e_oeminfo, 短整数型
    .成员 e_res2, 短整数型, , "10"
    .成员 e_lfanew, 整数型

.数据类型 临界许可, 公开, 临界许可类
    .成员 标识, 整数型, , , DebugInfo 这个只要大于0就表示许可证存在
    .成员 LockCount, 整数型
    .成员 RecursionCount, 整数型
    .成员 OwningThread, 整数型
    .成员 LockSemaphore, 整数型
    .成员 SpinCount, 整数型

.数据类型 矩形信息, 公开
    .成员 左边, 整数型
    .成员 顶边, 整数型
    .成员 宽度, 整数型
    .成员 高度, 整数型

.数据类型 精易_详细信息, 公开, 用于存放解析的自绘窗口元素信息
    .成员 子窗口数, 文本型
    .成员 控件ID, 文本型
    .成员 控件描述, 文本型
    .成员 控件名称, 文本型
    .成员 控件状态, 文本型
    .成员 控件类型, 文本型
    .成员 控件值, 文本型
    .成员 窗口位置, 文本型
    .成员 矩形信息, 矩形信息
    .成员 默认动作, 文本型
    .成员 状态标识, 文本型
    .成员 类型标识, 文本型
    .成员 屏幕位置, 文本型
    .成员 窗口大小, 文本型

.数据类型 精易_鼠标移入移出事件, 公开
    .成员 句柄, 整数型
    .成员 消息钩子句柄, 整数型
    .成员 移入事件, 子程序指针
    .成员 移出事件, 子程序指针

.数据类型 物理字体属性信息_, , TEXTMETRIC
    .成员 tmHeight, 整数型
    .成员 tmAscent, 整数型
    .成员 tmDescent, 整数型
    .成员 tmInternalLeading, 整数型
    .成员 tmExternalLeading, 整数型
    .成员 tmAveCharWidth, 整数型
    .成员 tmMaxCharWidth, 整数型
    .成员 tmWeight, 整数型
    .成员 tmOverhang, 整数型
    .成员 tmDigitizedAspectX, 整数型
    .成员 tmDigitizedAspectY, 整数型
    .成员 tmFirstChar, 字节型
    .成员 tmLastChar, 字节型
    .成员 tmDefaultChar, 字节型
    .成员 tmBreakChar, 字节型
    .成员 tmItalic, 字节型
    .成员 tmUnderlined, 字节型
    .成员 tmStruckOut, 字节型
    .成员 tmPitchAndFamily, 字节型
    .成员 tmCharSet, 字节型

.数据类型 PROCESS_BASIC_INFORMATION, 公开
    .成员 ExitStatus, 整数型
    .成员 PebBaseAddress, 整数型
    .成员 AffinityMask, 整数型
    .成员 BasePriority, 整数型
    .成员 UniqueProcessId, 整数型
    .成员 InheritedFromUniqueProcessId, 整数型

.数据类型 Process_Memory_Counters, , 进程内存统计_
    .成员 结构大小, 整数型, , , cb
    .成员 页错误数量, 整数型, , , PageFaultCount
    .成员 最高工作设置大小, 整数型, , , PeakWorkingSetSize
    .成员 当前工作设置大小, 整数型, , , WorkingSetSize
    .成员 最高页使用, 整数型, , , QuotaPeakPagedPoolUsage
    .成员 当前页使用, 整数型, , , QuotaPagedPoolUsage
    .成员 最高非页使用, 整数型, , , QuotaPeakNonPagedPoolUsage
    .成员 当前非页使用, 整数型, , , QuotaPeakNonPagedPoolUsage
    .成员 页文件使用, 整数型, , , PagefileUsage
    .成员 最高页文件使用, 整数型, , , PeakPagefileUsage

.数据类型 MEMORY_BASIC_INFORMATION
    .成员 BaseAddress, 整数型, , , 指向页面区域基地址的指针。
    .成员 AllocationBase, 整数型, , , 指向VirtualAlloc函数分配的一系列页面的基地址的指针。BaseAddress成员指向的页面包含在此分配范围内。
    .成员 AllocationProtect, 整数型, , , 最初分配区域时的内存保护选项。如果调用者无权访问，则该成员可以是 内存保护常量之一或 0。
    .成员 RegionSize, 整数型, , , 从基地址开始的区域的大小，其中所有页面具有相同的属性，以字节为单位。
    .成员 State, 整数型, , , 区域中页面的状态。
    .成员 Protect, 整数型, , , 区域内页面的访问保护。此成员是为AllocationProtect成员列出的值之一。
    .成员 Type, 整数型, , , 区域中的页面类型。

.数据类型 SYSTEM_PROCESS_INFORMATION_ex
    .成员 dwNextEntryOffset, 整数型
    .成员 dwNumberOfThreads, 整数型
    .成员 qSpareLi1, 长整数型
    .成员 qSpareLi2, 长整数型
    .成员 qSpareLi3, 长整数型
    .成员 qCreateTime, 长整数型
    .成员 qUserTime, 长整数型
    .成员 qKernelTime, 长整数型
    .成员 ImageName, UNICODE_STRING
    .成员 nBasePriority, 整数型
    .成员 dwProcessId, 整数型
    .成员 dwInheritedFromUniqueProcessId, 整数型
    .成员 dwHandleCount, 整数型
    .成员 dwSessionId, 整数型
    .成员 dwSpareUl3, 长整数型
    .成员 tPeakVirtualSize, 整数型
    .成员 tVirtualSize, 整数型
    .成员 dwPageFaultCount, 整数型
    .成员 dwPeakWorkingSetSize, 整数型
    .成员 dwWorkingSetSize, 整数型
    .成员 tQuotaPeakPagedPoolUsage, 整数型
    .成员 tQuotaPagedPoolUsage, 整数型
    .成员 tQuotaPeakNonPagedPoolUsage, 整数型
    .成员 tQuotaNonPagedPoolUsage, 整数型
    .成员 tPagefileUsage, 整数型
    .成员 tPeakPagefileUsage, 整数型
    .成员 tPrivatePageCount, 整数型
    .成员 qReadOperationCount, 长整数型
    .成员 qWriteOperationCount, 长整数型
    .成员 qOtherOperationCount, 长整数型
    .成员 qReadTransferCount, 长整数型
    .成员 qWriteTransferCount, 长整数型
    .成员 qOtherTransferCount, 长整数型

.数据类型 PROCESS_BASIC_INFORMATION64
    .成员 ExitStatus, 整数型
    .成员 Reserved0, 整数型
    .成员 PebBaseAddress, 长整数型
    .成员 AffinityMask, 长整数型
    .成员 BasePriority, 整数型
    .成员 Reserved1, 整数型
    .成员 UniqueProcessId, 长整数型
    .成员 InheritedFromUniqueProcessId, 长整数型

.数据类型 PEB_LDR_DATA
    .成员 Reserved1, 整数型, , "6"
    .成员 Ldr, 长整数型
    .成员 ProcessParameters, 长整数型

.数据类型 RTL_USER_PROCESS_PARAMETERS, , 14 
    .成员 ImagePathName, UNICODE_STRING64, , , 16
    .成员 CommandLine, UNICODE_STRING64, , , 16

.数据类型 UNICODE_STRING64
    .成员 Length, 短整数型
    .成员 MaximumLength, 短整数型
    .成员 Reserved, 整数型, , , 占位符
    .成员 Buffer, 长整数型

.数据类型 LPMODULEENTRY32, , 模块信息
    .成员 size, 整数型
    .成员 mid, 整数型, , , 模块ID
    .成员 pid, 整数型, , , 进程ID
    .成员 gusage, 整数型, , , 全局引用数
    .成员 pusage, 整数型, , , 引用数
    .成员 base, 整数型, , , 模块基址
    .成员 bsize, 整数型, , , 模块大小
    .成员 hmodule, 整数型, , , 模块句柄
    .成员 szname, 字节型, , "256", 模块名
    .成员 szpath, 字节型, , "256", 模块路径

.数据类型 SHFILEINFO
    .成员 hIcon
    .成员 iIcon
    .成员 dwAttributes
    .成员 szDisplayName, 字节型, , "260"
    .成员 szTypeName, 字节型, , "80"

.数据类型 struct
    .成员 hwnd, 整数型
    .成员 message, 整数型
    .成员 wParam, 整数型
    .成员 lParam, 整数型
    .成员 time, 整数型
    .成员 pt, 整数型

.数据类型 INTERNET_CACHE_ENTRY_INFO
    .成员 dwStructSize, 整数型, , "1", 结构尺寸
    .成员 lpszSourceUrlName, 文本型, , , url
    .成员 lpszLocalFileName, 文本型, , , 路径文件名
    .成员 CacheEntryType, 整数型, , ,  ？65是什么
    .成员 dwUseCount, 整数型, , , 缓存条目
    .成员 dwHitRate, 整数型, , , 已访问次数
    .成员 dwSizeLow, 整数型, , , 缓存文件大小
    .成员 dwSizeHigh, 整数型
    .成员 LastModifiedTime, 长整数型, , , 最后修改时间
    .成员 ExpireTime, 长整数型, , , 到期时间
    .成员 LastAccessTime, 长整数型, , , 上次访问的时间
    .成员 LastSyncTime, 长整数型, , , 最后一次缓存时间
    .成员 lpHeaderInfo, 文本型, , , 地址缓冲包含标题信息
    .成员 dwHeaderInfoSize, 整数型, , , lpHeaderInfo缓冲区大小
    .成员 lpszFileExtension, 文本型, , , 地址的一个字符串
    .成员 dwReserved, 整数型, , , 0 保留
    .成员 dwExemptDelta, 整数型, , , 访问间隔？

.数据类型 LARGE_INTEGER, , 长整数型_;
    .成员 lowpart, 整数型
    .成员 highpart, 整数型

.数据类型 INTERNET_PROXY_INFO, , 代理服务器信息
    .成员 dwAccessType, 整数型
    .成员 lpszProxy, 文本型
    .成员 lpszProxyBypass, 文本型

.数据类型 SERVICE_DESCRIPTION, , 服务描述结构
    .成员 lpDescription, 文本型

.数据类型 SERVICE_Table, , 服务表结构
    .成员 lpServiceName, 整数型
    .成员 lpServiceProc, 整数型

.数据类型 QUERY_SERVICE_CONFIG, , 服务的配置信息。
    .成员 dwServiceType, 整数型, , , 4
    .成员 dwStartType, 整数型, , , 4
    .成员 dwErrorControl, 整数型, , , 4
    .成员 lpBinaryPathName
    .成员 lpLoadOrderGroup
    .成员 dwTagId, 整数型, , , 4
    .成员 lpDependencies
    .成员 lpServiceStartName
    .成员 lpDisplayName

.数据类型 SERVICE_STATUS, , 服务状态结构
    .成员 dwServiceType, 整数型
    .成员 dwCurrentState, 整数型
    .成员 dwControlsAccepted, 整数型
    .成员 dwWin32ExitCode, 整数型
    .成员 dwServiceSpecificExitCode, 整数型
    .成员 dwCheckPoint, 整数型
    .成员 dwWaitHint, 整数型

.数据类型 SHFILEOPSTRUCT
    .成员 hwnd, 整数型
    .成员 wFunc, 整数型, , , #FO_
    .成员 pFrom, 字节集
    .成员 pTo, 字节集
    .成员 fFlags, 短整数型, , , #FOF_
    .成员 fAnyOperationsAborted, 整数型
    .成员 hNameMappings, 整数型
    .成员 lpszProgressTitle, 整数型

.数据类型 地址信息
    .成员 地址, 文本型
    .成员 端口, 整数型

.数据类型 客户信息, 公开
    .成员 IP, 文本型
    .成员 端口, 短整数型
    .成员 句柄, 整数型

.数据类型 fd_set
    .成员 fd_count, 整数型
    .成员 fd_array, 整数型

.数据类型 套接字地址, 公开, sockaddr
    .成员 常量, 短整数型, , , sin_family
    .成员 端口, 短整数型, , , sin_port
    .成员 地址, 整数型, , , sin_addr
    .成员 地址范围, 字节型, , "8", sin_zero

.数据类型 套接字信息, 公开, WSADataType
    .成员 版本, 短整数型, , , wVersion
    .成员 高版本, 短整数型, , , wHighVersion
    .成员 种类, 字节型, , "257", * WSA_DescriptionSize
    .成员 系统状态, 字节型, , "129", * WSA_SysStatusSize
    .成员 最大套接字, 短整数型, , , iMaxSockets
    .成员 最大Udp, 短整数型, , , iMaxUdpDg
    .成员 信息, 整数型, , , lpVendorInfo

.数据类型 按钮信息, , 显示或隐藏任务栏指定按钮
    .成员 cbSize, 整数型, , , 32
    .成员 dwMask, 整数型
    .成员 idCommand, 整数型
    .成员 iImage, 整数型
    .成员 fsState, 字节型
    .成员 fsStyle, 字节型
    .成员 cx, 短整数型
    .成员 lParam, 整数型
    .成员 pszText, 整数型
    .成员 cchText, 整数型

.数据类型 IDE, , 取磁盘信息
    .成员 bFeaturesReg, 字节型
    .成员 bSectorCountReg, 字节型
    .成员 bSectorNumberReg, 字节型
    .成员 bCylLowReg, 字节型
    .成员 bCylHighReg, 字节型
    .成员 bDriveHeadReg, 字节型
    .成员 bCommandReg, 字节型

.数据类型 SCIP, , 取磁盘信息
    .成员 cBufferSize, 整数型
    .成员 irDriveRegs, IDE
    .成员 bDriveNumber, 字节型
    .成员 bReserved, 字节型, , "3"
    .成员 dwReserved, 整数型, , "4"
    .成员 bBuffer, 字节型, , "1"

.数据类型 精易_磁盘信息, 公开
    .成员 型号, 文本型
    .成员 序列号, 文本型
    .成员 固件版本, 文本型

.数据类型 项目数据, 公开, 树型框操作类
    .成员 项目文本, 文本型, , , 项目文本
    .成员 图片索引, 整数型, , , 图象
    .成员 选中图片索引, 整数型, , , 选择图象
    .成员 项目数值, 整数型, , , 项目数值
    .成员 是否加粗, 逻辑型
    .成员 项目句柄, 长整数型, 传址

.数据类型 树型框结构, , 树型框操作类
    .成员 项目文本, 文本型
    .成员 图片索引, 整数型
    .成员 选中图片索引, 整数型
    .成员 项目数值, 整数型
    .成员 加粗扩展, 整数型, , , 0、普通，1、加粗，2、扩展，3、加粗+扩展
    .成员 缩进层次, 整数型

.数据类型 TVITEMEX, , 树型框操作类
    .成员 mask, 整数型, , , 掩码
    .成员 hItem, 整数型, , , 项目句柄
    .成员 state, 整数型, , , 状态
    .成员 stateMask, 整数型, , , 状态掩码
    .成员 pszText, 文本型, 传址, , 项目文本
    .成员 cchTextMax, 整数型, , , 最长文本（系统最大允许260个字符）
    .成员 iImage, 整数型, , , 图象
    .成员 iSelectedImage, 整数型, , , 选择图象
    .成员 cChildren, 逻辑型, , , 是否有子
    .成员 lParam, 整数型, , , 项目数值
    .成员 iIntegral, 整数型, , , 项目的画面高度。 这一个画面高度在标准项目画面高度的增量。

.数据类型 TVITEMEX2, , 树型框操作类
    .成员 mask, 整数型, , , 掩码
    .成员 hItem, 整数型, , , 项目句柄
    .成员 state, 整数型, , , 状态
    .成员 stateMask, 整数型, , , 状态掩码
    .成员 pszText, 整数型, , , 项目文本
    .成员 cchTextMax, 整数型, , , 最长文本（系统最大允许260个字符）
    .成员 iImage, 整数型, , , 图象
    .成员 iSelectedImage, 整数型, , , 选择图象
    .成员 cChildren, 逻辑型, , , 是否有子
    .成员 lParam, 整数型, , , 项目数值
    .成员 iIntegral, 整数型, , , 项目的画面高度。 这一个画面高度在标准项目画面高度的增量。

.数据类型 TVINSERTSTRUCT, , 树型框操作类
    .成员 hParent, 整数型, , , 父
    .成员 hInsertAfter, 整数型, , , 插入标志
    .成员 mask, 整数型, , , 掩码
    .成员 hItem, 整数型, , , 项目句柄
    .成员 state, 整数型, , , 状态
    .成员 stateMask, 整数型, , , 状态掩码
    .成员 pszText, 文本型, 传址, , 项目文本
    .成员 cchTextMax, 整数型, , , 最长文本（系统最大允许260个字符）
    .成员 iImage, 整数型, , , 图象
    .成员 iSelectedImage, 整数型, , , 选择图象
    .成员 cChildren, 逻辑型, , , 是否有子
    .成员 lParam, 整数型, , , 项目数值
    .成员 iIntegral, 整数型, , , 项目的画面高度。 这一个画面高度在标准项目画面高度的增量。

.数据类型 TVINSERTSTRUCT2, , 树型框操作类
    .成员 hParent, 整数型, , , 父
    .成员 hInsertAfter, 整数型, , , 插入标志
    .成员 mask, 整数型, , , 掩码
    .成员 hItem, 整数型, , , 项目句柄
    .成员 state, 整数型, , , 状态
    .成员 stateMask, 整数型, , , 状态掩码
    .成员 pszText, 整数型, , , 项目文本
    .成员 cchTextMax, 整数型, , , 最长文本（系统最大允许260个字符）
    .成员 iImage, 整数型, , , 图象
    .成员 iSelectedImage, 整数型, , , 选择图象
    .成员 cChildren, 逻辑型, , , 是否有子
    .成员 lParam, 整数型, , , 项目数值
    .成员 iIntegral, 整数型, , , 项目的画面高度。 这一个画面高度在标准项目画面高度的增量。

.数据类型 内存映射数据9X
    .成员 映射文件号, 整数型
    .成员 指针, 整数型

.数据类型 线程许可证, 公开
    .成员 调试信息, 整数型
    .成员 锁计数, 整数型
    .成员 递归计数, 整数型
    .成员 拥有线程, 整数型
    .成员 锁信号量, 整数型
    .成员 自旋数, 整数型

.数据类型 剪贴板_置文件
    .成员 pFiles, 整数型
    .成员 pt, 精易_坐标
    .成员 fNC, 整数型
    .成员 fWide, 整数型

.数据类型 取硬盘特征号0, , 33-1
    .成员 cBufferSize, 整数型
    .成员 bFeaturesReg, 字节型, , , IDEREGS_Begin
    .成员 bSectorCountReg, 字节型
    .成员 bSectorNumberReg, 字节型
    .成员 bCylLowReg, 字节型
    .成员 bCylHighReg, 字节型
    .成员 bDriveHeadReg, 字节型
    .成员 bCommandReg, 字节型
    .成员 bReserved1, 字节型, , , IDEREGS_End
    .成员 bDriveNumber, 字节型
    .成员 bReserved, 字节型, , "3"
    .成员 dwReserved, 整数型, , "4"
    .成员 bBuffer, 字节型

.数据类型 取硬盘特征号1, , 24
    .成员 bVersion, 字节型
    .成员 bRevision, 字节型
    .成员 bReserved, 字节型
    .成员 bIDEDeviceMap, 字节型
    .成员 fCapabilities, 整数型
    .成员 dwReserved, 整数型, , "4"

.数据类型 取硬盘特征号2, , 28+33-1
    .成员 HeaderLength, 整数型
    .成员 Signature, 字节型, , "8"
    .成员 Timeout, 整数型
    .成员 ControlCode, 整数型
    .成员 ReturnCode, 整数型
    .成员 Length, 整数型
    .成员 cBufferSize, 整数型, , , SENDCMDINPARAMS_Begin
    .成员 bFeaturesReg, 字节型, , , IDEREGS_Begin
    .成员 bSectorCountReg, 字节型
    .成员 bSectorNumberReg, 字节型
    .成员 bCylLowReg, 字节型
    .成员 bCylHighReg, 字节型
    .成员 bDriveHeadReg, 字节型
    .成员 bCommandReg, 字节型
    .成员 bReserved1, 字节型, , , IDEREGS_End
    .成员 bDriveNumber, 字节型
    .成员 bReserved, 字节型, , "3"
    .成员 dwReserved, 整数型, , "4"
    .成员 bBuffer, 字节型, , , SENDCMDINPARAMS_End

.数据类型 取硬盘特征号3, , 256
    .成员 wGenConfig, 短整数型
    .成员 wNumCyls, 短整数型
    .成员 wReserved, 短整数型
    .成员 wNumHeads, 短整数型
    .成员 wBytesPerTrack, 短整数型
    .成员 wBytesPerSector, 短整数型
    .成员 wSectorsPerTrack, 短整数型
    .成员 wVendorUnique, 短整数型, , "3"
    .成员 sSerialNumber, 字节型, , "20"
    .成员 wBufferType, 短整数型
    .成员 wBufferSize, 短整数型
    .成员 wECCSize, 短整数型
    .成员 sFirmwareRev, 字节型, , "8"
    .成员 sModelNumber, 字节型, , "40"
    .成员 wMoreVendorUnique, 短整数型
    .成员 wDoubleWordIO, 短整数型
    .成员 wCapabilities, 短整数型
    .成员 wReserved1, 短整数型
    .成员 wPIOTiming, 短整数型
    .成员 wDMATiming, 短整数型
    .成员 wBS, 短整数型
    .成员 wNumCurrentCyls, 短整数型
    .成员 wNumCurrentHeads, 短整数型
    .成员 wNumCurrentSectorsPerTrack, 短整数型
    .成员 ulCurrentSectorCapacity, 整数型
    .成员 wMultSectorStuff, 短整数型
    .成员 ulTotalAddressableSectors, 整数型
    .成员 wSingleWordDMA, 短整数型
    .成员 wMultiWordDMA, 短整数型
    .成员 bReserved, 字节型, , "128"

.数据类型 GdiplusStartupInput
    .成员 GdiplusVersion, 整数型
    .成员 DebugEventCallback, 整数型
    .成员 SuppressBackgroundThread, 整数型
    .成员 SuppressExternalCodecs, 整数型

.数据类型 BLENDFUNCTION
    .成员 BlendOp, 字节型
    .成员 BlendFlags, 字节型
    .成员 SourceConstantAlpha, 字节型
    .成员 AlphaFormat, 字节型

.数据类型 Size, , 尺寸;
    .成员 cx, 整数型
    .成员 cy, 整数型

.数据类型 BITMAPINFO
    .成员 BITMAPINFOHEADER, BITMAPINFOHEADER
    .成员 bmiColors, 整数型, , , RGBQUAD          bmiColors[1]; 

.数据类型 BITMAPINFOHEADER
    .成员 biSize, 整数型
    .成员 biWidth, 整数型
    .成员 biHeight, 整数型
    .成员 biPlanes, 短整数型
    .成员 biBitCount, 短整数型
    .成员 biCompression, 整数型
    .成员 biSizeImage, 整数型
    .成员 biXPelsPerMeter, 整数型
    .成员 biYPelsPerMeter, 整数型
    .成员 biClrUsed, 整数型
    .成员 biClrImportant, 整数型

.数据类型 BITMAPFILEHEADER
    .成员 bfType, 短整数型
    .成员 bfSize, 整数型
    .成员 bfReserved1, 短整数型
    .成员 bfReserved2, 短整数型
    .成员 bfOffBits, 整数型

.数据类型 BITMAP
    .成员 bmType, 整数型
    .成员 bmWidth, 整数型
    .成员 bmHeight, 整数型
    .成员 bmWidthBytes, 整数型
    .成员 bmPlanes, 短整数型
    .成员 bmBitsPixel, 短整数型
    .成员 bmBits, 整数型, 传址

.数据类型 位图信息_, , 位图信息_
    .成员 结果大小, 整数型, , , biSize
    .成员 位图宽度, 整数型, , , biWidth
    .成员 位图高度, 整数型, , , biHeight
    .成员 位图位面数, 短整数型, , , biPlanes
    .成员 位深度, 短整数型, , , biBitCount
    .成员 压缩率, 整数型, , , biCompression
    .成员 位图大小, 整数型, , , biSizeImage
    .成员 水平折像度, 整数型, , , biXPelsPerMeter
    .成员 垂直折像度, 整数型, , , biYPelsPerMeter
    .成员 位图颜色表索引, 整数型, , , biClrUsed
    .成员 位图显示索引, 整数型, , , biClrImportant
    .成员 蓝色值, 字节型, , , rgbBlue
    .成员 绿色值, 字节型, , , rgbGreen
    .成员 红色值, 字节型, , , rgbRed
    .成员 保留参数, 字节型, , , rgbReserved

.数据类型 _验证码取图, , 设备无关位图;
    .成员 biSize, 整数型, , , 40
    .成员 biWidth, 整数型, , , btm.bmWidth
    .成员 biHeight, 整数型, , , btm.bmHeight
    .成员 biPlanes, 短整数型, , , 1
    .成员 biBitCount, 短整数型, , , btm.bmBitsPixel
    .成员 biCompression, 整数型, , , 0
    .成员 biSizeImage, 整数型, , , (btm.bmWidth*24+31)/8*btm.bmHeight
    .成员 biXPelsPerMeter, 整数型, , , 0
    .成员 biYPelsPerMeter, 整数型, , , 0
    .成员 biClrUsed, 整数型, , , 0 24色取0
    .成员 biClrImportant, 整数型, , , 0

.数据类型 超级列表框0
    .成员 掩码, 整数型
    .成员 项目, 整数型
    .成员 子项目, 整数型
    .成员 状态, 整数型
    .成员 状态掩码, 整数型
    .成员 项目文本, 文本型, 传址
    .成员 项目文本长度, 整数型
    .成员 图片索引, 整数型
    .成员 项目数值, 整数型
    .成员 缩进, 整数型

.数据类型 超级列表框1
    .成员 掩码, 整数型
    .成员 表项索引, 整数型
    .成员 子项目, 整数型
    .成员 状态, 整数型
    .成员 状态掩码, 整数型
    .成员 项目文本, 整数型
    .成员 项目文本长度, 整数型
    .成员 图片索引, 整数型
    .成员 项目数值, 整数型
    .成员 缩进, 整数型

.数据类型 列表框信息, 公开
    .成员 标题, 文本型, 传址, , 本参数指定表项的标题文本(也即是第0列的标题)。
    .成员 图片索引, 整数型, , , 图片索引用于指定“图片组”属性中的某张图片。索引值从 0 开始，-1 表示无图片。
    .成员 状态图片索引, 整数型, , , 状态图片索引用于指定“状态图片组”属性中的某张图片。索引值从 0 开始，-1 表示无图片。
    .成员 表项数值, 整数型, , , 该数值与指定表项相关联。
    .成员 缩进数目, 整数型, , , “缩进数目”仅在报表型列表框才有效，用作指定显示时在表项首部增加的空白数。
    .成员 列标题, 文本型, , "1", 从第1列开始计起的列标题，多列请按列索引次序依次写到相应的数组成员中
    .成员 列图片索引, 整数型, , "1", 从第1列开始计起，可以被省略。图片索引用于指定“图片组”属性中的某张图片。索引值从 0 开始，-1 表示无图片。如果本参数被省略，默认值为 -1 。

.数据类型 超级列表框3
    .成员 flags, 整数型, , , 查找类型常量
    .成员 LPCTSTR, 文本型, 传址, , LVFI_STRING or LVFI_PARTIAL 才能有效
    .成员 lParam, 整数型, , , LVFI_PARAM 才能有效
    .成员 pt, 精易_坐标, 传址, , LVFI_NEARESTXY 才能有效
    .成员 vkDirection, 整数型, , , 查找热键常量，LVFI_NEARESTXY 才能有效

.数据类型 超级列表框4
    .成员 flags, 整数型, , , 查找类型常量
    .成员 LPCTSTR, 整数型, , , LVFI_STRING or LVFI_PARTIAL 才能有效
    .成员 lParam, 整数型, , , LVFI_PARAM 才能有效
    .成员 pt, 整数型, , , LVFI_NEARESTXY 才能有效
    .成员 vkDirection, 整数型, , , 查找热键常量，LVFI_NEARESTXY 才能有效

.数据类型 超级列表框5
    .成员 ulFlags, 整数型
    .成员 hbm, 整数型, , , 没有使用,置0
    .成员 图片路径, 文本型, 传址
    .成员 最大长度, 整数型
    .成员 xOffsetPercent, 整数型, , , X补偿百分比
    .成员 yOffsetPercent, 整数型, , , Y补偿百分比

.数据类型 超级列表框6
    .成员 ulFlags, 整数型
    .成员 hbm, 整数型, , , 没有使用,置0
    .成员 pszImage, 整数型, , , 图片路径
    .成员 cchImageMax, 整数型, , , 最大长度
    .成员 xOffsetPercent, 整数型, , , X补偿百分比
    .成员 yOffsetPercent, 整数型, , , Y补偿百分比

.数据类型 超级列表框7
    .成员 mask, 整数型
    .成员 对齐方式, 整数型
    .成员 列宽度, 整数型
    .成员 列标题, 文本型, 传址
    .成员 缓冲区长度, 整数型
    .成员 列索引, 整数型
    .成员 列图标, 整数型
    .成员 iOrder, 整数型

.数据类型 超级列表框8
    .成员 mask, 整数型
    .成员 对齐方式, 整数型
    .成员 列宽度, 整数型
    .成员 列标题, 整数型
    .成员 缓冲区长度, 整数型
    .成员 列索引, 整数型
    .成员 列图标, 整数型
    .成员 iOrder, 整数型

.数据类型 精易_颜色对话框, 公开
    .成员 长度, 整数型
    .成员 窗口句柄, 整数型
    .成员 hInstance, 整数型
    .成员 rgbResult, 整数型
    .成员 颜色数长度, 文本型
    .成员 lCustData, 整数型
    .成员 lpfnHook, 整数型
    .成员 lpTemplateName, 文本型

.数据类型 查找的文件信息
    .成员 dwFileAttributes, 整数型
    .成员 ftCreationTime, FILETIME
    .成员 ftLastAccessTime, FILETIME
    .成员 ftLastWriteTime, FILETIME
    .成员 nFileSizeHigh, 整数型
    .成员 nFileSizeLow, 整数型
    .成员 dwReserved0, 整数型
    .成员 dwReserved1, 整数型
    .成员 cFileName, 字节型, , "260"
    .成员 cAlternate, 字节型, , "14"

.数据类型 FILETIME, 公开
    .成员 dwLowDateTime, 整数型
    .成员 dwHighDateTime, 整数型

.数据类型 精易_任务相关
    .成员 cbSize, 整数型
    .成员 hwnd, 整数型
    .成员 uCallbackMessage, 整数型
    .成员 uEdge, 整数型
    .成员 rc, 精易_矩形
    .成员 lParam, 整数型

.数据类型 TOKEN_PRIVILEGES
    .成员 PrivilegeCount, 整数型
    .成员 LowPart, 整数型
    .成员 HighPart, 整数型
    .成员 Attributes, 整数型

.数据类型 LUID
    .成员 LowPart, 整数型
    .成员 HighPart, 整数型

.数据类型 精易_模块信息, 公开, 进程模块信息
    .成员 size, 整数型, , , 1
    .成员 mid, 整数型, , , 模块ID
    .成员 pid, 整数型, , , 进程ID
    .成员 gusage, 整数型, , , 全局引用数
    .成员 pusage, 整数型, , , 引用数
    .成员 base, 整数型, , , 模块基址
    .成员 大小, 整数型, , , 模块大小
    .成员 模块句柄, 整数型, , , 模块句柄
    .成员 模块文件名, 字节型, , "256", 模块名
    .成员 模块完整路径, 字节型, , "256", 模块路径

.数据类型 精易_热键信息
    .成员 窗口句柄, 整数型
    .成员 热键ID
    .成员 回调函数, 整数型

.数据类型 光驱相关1
    .成员 dwCallback, 整数型
    .成员 wDeviceID, 整数型
    .成员 lpstrDeviceType, 文本型
    .成员 lpstrElementName, 文本型
    .成员 lpstrAlias, 整数型

.数据类型 光驱相关2
    .成员 dwCallback, 整数型
    .成员 dwTimeFormat, 整数型
    .成员 dwAudio, 整数型

.数据类型 精易_进程信息, 公开
    .成员 进程ID, 整数型
    .成员 进程名, 文本型
    .成员 进程全路径名, 文本型

.数据类型 精易_进程结构, 公开
    .成员 进程句柄, 整数型, , , hProcess
    .成员 线程句柄, 整数型, , , hThread
    .成员 进程标识符, 整数型, , , dwProcessId
    .成员 线程标识符, 整数型, , , dwThreadId

.数据类型 精易_窗口信息, 公开
    .成员 窗口句柄, 整数型
    .成员 进程ID, 整数型
    .成员 线程ID, 整数型
    .成员 窗口标题, 文本型
    .成员 窗口类名, 文本型

.数据类型 精易_进程信息数组, 公开
    .成员 进程标识符, 整数型, , , 初始值为 0 。
    .成员 进程名称, 文本型, , , 初始值为“”。
    .成员 进程模块标识符, 整数型, , , 初始值为 0 。
    .成员 父进程标识符, 整数型, , , 初始值为 0 。
    .成员 线程优先权, 整数型, , , 初始值为 0 。
    .成员 线程数, 整数型, , , 初始值为 0 。

.数据类型 精易_进程信息列表, 公开, PROCESSENTRY32
    .成员 dwSize, 整数型, , , 1
    .成员 cntUsage, 整数型, , , 2
    .成员 进程ID, 整数型, , , 3
    .成员 th32DefaultHeapID, 整数型, , , 4
    .成员 th32ModuleID, 整数型, , , 5
    .成员 cntThreads, 整数型, , , 6
    .成员 th32ParentProcessID, 整数型, , , 7
    .成员 pcPriClassBase, 整数型, , , 8
    .成员 dwFlags, 整数型, , , 9
    .成员 进程名称, 字节型, , "260", 10

.数据类型 PGUITHREADINFO
    .成员 cbSize, 整数型
    .成员 flags, 整数型
    .成员 hwndActive, 整数型
    .成员 hwndFocus, 整数型
    .成员 hwndCapture, 整数型
    .成员 hwndMenuOwner, 整数型
    .成员 hwndMoveSize, 整数型
    .成员 hwndCaret, 整数型
    .成员 rcCaret, 精易_矩形

.数据类型 线程入口结构
    .成员 结构大小, 整数型, , , 注意！请先初始化！
    .成员 引用线程数, 整数型, , , 请传0
    .成员 线程ID, 整数型
    .成员 父进程ID, 整数型
    .成员 优先级, 整数型
    .成员 更改的优先级, 整数型
    .成员 保留, 整数型

.数据类型 MSG
    .成员 hwnd, 整数型
    .成员 message, 整数型
    .成员 wParam, 整数型
    .成员 lParam, 整数型
    .成员 time, 整数型
    .成员 pt, 精易_坐标

.数据类型 点阵型
    .成员 x, 整数型
    .成员 y, 整数型
    .成员 z, 整数型

.数据类型 精易_坐标, 公开
    .成员 横, 整数型, , , 横X
    .成员 纵, 整数型, , , 纵Y

.数据类型 点阵, 公开
    .成员 点, 整数型, , "1", 低16位X,高16位Y

.数据类型 精易_位置和大小, 公开
    .成员 左边, 整数型, , , 左边，相当于左上角的x
    .成员 顶边, 整数型, , , 顶边，相当于左上角的y
    .成员 宽度, 整数型, , , 窗口的宽度
    .成员 高度, 整数型, , , 窗口的高度

.数据类型 精易_矩形, 公开
    .成员 左边, 整数型, , , 左边，相当于左上角的x
    .成员 顶边, 整数型, , , 顶边，相当于左上角的y
    .成员 右边, 整数型, , , 右边，相当于右下角的x
    .成员 底边, 整数型, , , 底边，相当于右下角的y

.数据类型 表项结构信息, 公开
    .成员 横向, 整数型
    .成员 纵向, 整数型
    .成员 flags, 整数型
    .成员 行, 整数型
    .成员 列, 整数型

.数据类型 精易_内存属性, 公开, MEMORY_BASIC_INFORMATION
    .成员 区域地址, 整数型, , , BaseAddress
    .成员 分配地址, 整数型, , , AllocationBase
    .成员 初始属性, 整数型, , , AllocationProtect
    .成员 区域长度, 整数型, , , RegionSize
    .成员 保留值, 整数型, , , 已提交值,保留值,自由值State
    .成员 当前属性, 整数型, , , Protect
    .成员 页类型, 整数型, , , lType

.数据类型 程序延时
    .成员 成员_时间, 长整数型, , , 占用8个字节

.数据类型 ADSL拨号0
    .成员 结构的大小, 整数型, , , 该结构的大小（以字节为单位）
    .成员 访问的入口名, 字节型, , "257", 表示一个远程访问的入口名,拨号网络中的连接图标小的文字,空表示仅与第一个有效的MODEM建立远程连接
    .成员 呼叫的号码, 字节型, , "129", 表示呼叫的号码,szEntryName为空时,该元素不能为空
    .成员 回叫号码, 字节型, , "129", 表示回叫号码,一般都设为空
    .成员 指定用户名称, 字节型, , "257", 指定用户名称
    .成员 指定用户密码, 字节型, , "257", 指定用户密码
    .成员 指定域, 字节型, , "16", 指定域

.数据类型 取连接信息用结构, , ADSL拨号1
    .成员 内存大小, 整数型, , , 该结构占内存大小
    .成员 拨号连接名称, 字节型, , "255", 拨号连接名称
    .成员 缓冲区的大小, 字节型, , , 缓冲区的大小
    .成员 连接的个数, 文本型, , , 实际的连接的个数

.数据类型 ADSL拨号2
    .成员 data1, 整数型
    .成员 data2, 短整数型
    .成员 data3, 短整数型
    .成员 data4, 字节型, , "8"

.数据类型 ADSL拨号3
    .成员 a, 字节型
    .成员 b, 字节型
    .成员 c, 字节型
    .成员 d, 字节型

.数据类型 LSA_UNICODE_STRING
    .成员 长度, 短整数型
    .成员 最大长度, 短整数型
    .成员 缓冲区, 字节集

.数据类型 创建连接所用结构, , ADSL拨号4
    .成员 dwSize, 整数型
    .成员 dwfOptions, 整数型
    .成员 dwCountryID, 整数型
    .成员 dwCountryCode, 整数型
    .成员 szAreaCode, 字节型, , "8"
    .成员 szLocalPhoneNumber, 字节型, , "132"
    .成员 dwAlternateOffset, 整数型
    .成员 ipaddr, ADSL拨号3
    .成员 ipaddrDns, ADSL拨号3
    .成员 dbury, ADSL拨号3
    .成员 ipaddrWins, ADSL拨号3
    .成员 ipaddrWinsAlt, ADSL拨号3
    .成员 dwFrameSize, 整数型
    .成员 hr57hfb, 整数型
    .成员 dwFramingProtocol, 整数型
    .成员 szScript, 字节型, , "260"
    .成员 szAutodialDll, 字节型, , "260"
    .成员 d75hdrb, 字节型, , "260"
    .成员 szDeviceType, 字节型, , "16"
    .成员 szDeviceName, 字节型, , "132"
    .成员 szX25PadType, 字节型, , "32"
    .成员 sd5h7rd, 字节型, , "200"
    .成员 szX25Facilities, 字节型, , "200"
    .成员 szX25UserData, 字节型, , "204"
    .成员 dwChannels, 整数型
    .成员 sd5rybh, 整数型
    .成员 dwReserved2, 整数型
    .成员 dwSubEntries, 整数型
    .成员 dwDialMode, 整数型
    .成员 dwDialExtraPercent, 整数型
    .成员 dbh5uy, 整数型
    .成员 dwHangUpExtraPercent, 整数型
    .成员 dwHangUpExtraSampleSeconds, 整数型
    .成员 dburgy, 整数型
    .成员 dwType, 整数型
    .成员 sdr5uyhbd, 整数型
    .成员 dwCustomAuthKey, 整数型
    .成员 guidId, ADSL拨号2
    .成员 szCustomDialDll, 字节型, , "260"
    .成员 sbyhrs, 整数型
    .成员 dwfOptions2, 整数型
    .成员 dwfOptions3, 整数型
    .成员 szDnsSuffix, 字节型, , "256"
    .成员 dwTcpWindowSize, 整数型
    .成员 szPrerequisitePbk, 字节型, , "260"
    .成员 szPrerequisiteEntry, 字节型, , "260"
    .成员 dwRedialCount, 整数型
    .成员 dwRedialPause, 整数型

.数据类型 设置拨号所以结构, , ADSL拨号5
    .成员 dsubr, 整数型, , , 该结构的大小（以字节为单位）
    .成员 dwMask, 整数型
    .成员 szUserName, 字节型, , "257"
    .成员 szPassword, 字节型, , "257"
    .成员 szDomain, 字节型, , "16"

.数据类型 IP_ADAPTER_INFO
    .成员 Next, 整数型
    .成员 ComboIndex, 整数型
    .成员 AdapterName, 字节型, , "260", 名称
    .成员 Description, 字节型, , "132", 描述
    .成员 AddressLength, 整数型
    .成员 Address, 字节型, , "8"
    .成员 Index, 整数型
    .成员 Type, 整数型, , , 类型
    .成员 DhcpEnabled, 整数型
    .成员 CurrentIpAddress, 整数型
    .成员 IpAddressList, IP_ADDR_STRING
    .成员 GatewayList, IP_ADDR_STRING
    .成员 DhcpServer, IP_ADDR_STRING
    .成员 HaveWins, 逻辑型
    .成员 PrimaryWinsServer, IP_ADDR_STRING
    .成员 SecondaryWinsServer, IP_ADDR_STRING
    .成员 LeaseObtained, 整数型
    .成员 LeaseExpires, 整数型

.数据类型 IP_PER_ADAPTER_INFO_彗星
    .成员 AutoconfigEnabled, 整数型, , , UINT。AutoconfigEnabled
    .成员 AutoconfigActive, 整数型, , , UINT。AutoconfigActive
    .成员 CurrentDnsServer, 整数型, , , PIP_ADDR_STRING。CurrentDnsServer
    .成员 DnsServerList, IP_ADDR_STRING, , , IP_ADDR_STRING。DnsServerList

.数据类型 IP_PER_ADAPTER_INFO
    .成员 tmp, 整数型, , "3"
    .成员 CurrentDnsServer, IP_ADDR_STRING
    .成员 DnsServerList, IP_ADDR_STRING

.数据类型 OPENFILENAME, 公开, 打开文件名结构
    .成员 结构大小, 整数型, , , win2k以上为88，以下为76  1
    .成员 窗口句柄, 整数型, , , 2
    .成员 实例句柄, 整数型, , , 3
    .成员 过滤器, 字节集, , , 4
    .成员 自定义过滤器, 文本型, , , 5
    .成员 自定义过滤器最大长度, 整数型, , , 6
    .成员 过滤器索引, 整数型, , , 7
    .成员 文件名, 字节集, , , 8
    .成员 文件名最大长度, 整数型, , , 9
    .成员 文件标题, 文本型, , , 10
    .成员 文件标题最大长度, 整数型, , , 11
    .成员 初始目录, 文本型, , , 12
    .成员 标题, 文本型, , , 13
    .成员 标志, 整数型, , , 14
    .成员 文件偏移量, 短整数型, , , 15
    .成员 文件扩展名, 短整数型, , , 16
    .成员 默认扩展名, 文本型, , , 17
    .成员 自定义数据, 整数型, , , 18
    .成员 回调函数地址, 整数型, , , 19
    .成员 模板名, 整数型, , , 20

.数据类型 PLASTINPUTINFO, , 取系统空闲时间
    .成员 cbSize, 整数型
    .成员 dwTime, 整数型

.数据类型 数据_APIHOOK类
    .成员 区域地址, 整数型
    .成员 API命令名, 文本型
    .成员 继续暂停, 文本型
    .成员 原函数地址, 整数型
    .成员 新函数地址, 字节集
    .成员 原保护值, 整数型
    .成员 原字节, 字节集
    .成员 命令标识, 文本型, , , 动态链接库名+API命令名

.数据类型 精易_时间, 公开, , SYSTEMTIME
    .成员 年, 短整数型, , , wYear
    .成员 月, 短整数型, , , wMonth
    .成员 星期, 短整数型
    .成员 日, 短整数型, , , wDay
    .成员 时, 短整数型, , , wHour
    .成员 分, 短整数型, , , wMinute
    .成员 秒, 短整数型, , , wSecond
    .成员 毫, 短整数型, , , wMilliseconds

.数据类型 LSA_OBJECT_ATTRIBUTES
    .成员 Length, 整数型
    .成员 RootDirectory, 整数型
    .成员 ObjectName, LSA_UNICODE_STRING, , , 未知类型：PLSA_UNICODE_STRING。
    .成员 Attributes, 整数型
    .成员 SecurityDescriptor, 整数型, 传址, , 此参数需传址。
    .成员 SecurityQualityOfService, 整数型, 传址, , 此参数需传址。

.数据类型 OSVERSIONINFOEX, 公开, 系统_取操作系统类别
    .成员 dwOSVersionInfoSize, , , , 结构的大小
    .成员 dwMajorVersion, , , , 主版本号
    .成员 dwMinorVersion, , , , 次版本号
    .成员 dwBuildNumber, , , , 构建号
    .成员 dwPlatformId, , , , 支持的平台
    .成员 szCSDVersion, 字节型, , "128", 补丁包的名称
    .成员 wServicePackMajor, 短整数型, , , 补丁包的主版本
    .成员 wServicePackMinor, 短整数型, , , 补丁包的次版本
    .成员 wSuiteMask, 短整数型, , , 系统上的程序组
    .成员 wProductType, 字节型, , , 系统类型
    .成员 wReserved, 字节型, , , 保留

.数据类型 OSVersionInfo
    .成员 版本信息大小, 整数型
    .成员 主版本, 整数型
    .成员 次版本, 整数型
    .成员 构造版本, 整数型
    .成员 平台标识符, 整数型
    .成员 CSD版本, 文本型

.数据类型 RasEntry
    .成员 dwSize, 整数型
    .成员 dwfOptions, 整数型
    .成员 dwCountryID, 整数型
    .成员 dwCountryCode, 整数型
    .成员 szAreaCode, 字节型, , "8"
    .成员 szLocalPhoneNumber, 字节型, , "132"
    .成员 dwAlternatesOffset, 整数型
    .成员 ipaddr, ADSL拨号3, , , 未知类型：TRasIPAddr。
    .成员 ipaddrDns, ADSL拨号3, , , 未知类型：TRasIPAddr。
    .成员 ipaddrDnsAlt, ADSL拨号3, , , 未知类型：TRasIPAddr。
    .成员 ipaddrWins, ADSL拨号3, , , 未知类型：TRasIPAddr。
    .成员 ipaddrWinsAlt, ADSL拨号3, , , 未知类型：TRasIPAddr。
    .成员 dwFrameSize, 整数型
    .成员 dwfNetProtocols, 整数型
    .成员 dwFramingProtocol, 整数型
    .成员 szScript, 字节型, , "260", 数组：MAX_PATH - 1+1。
    .成员 szAutodialDll, 字节型, , "260", 数组：MAX_PATH - 1+1。
    .成员 szAutodialFunc, 字节型, , "260", 数组：MAX_PATH - 1+1。
    .成员 szDeviceType, 字节型, , "16"
    .成员 szDeviceName, 字节型, , "132"
    .成员 szX25PadType, 字节型, , "32"
    .成员 szX25Address, 字节型, , "200"
    .成员 szX25Facilities, 字节型, , "200"
    .成员 szX25UserData, 字节型, , "204"
    .成员 dwChannels, 整数型
    .成员 dwReserved1, 整数型
    .成员 dwReserved2, 整数型
    .成员 dwSubEntries, 整数型
    .成员 dwDialMode, 整数型
    .成员 dwDialExtraPercent, 整数型
    .成员 dwDialExtraSampleSeconds, 整数型
    .成员 dwHangUpExtraPercent, 整数型
    .成员 dwHangUpExtraSampleSeconds, 整数型
    .成员 dwIdleDisconnectSeconds, 整数型

.数据类型 Stroks
    .成员 名字, 文本型
    .成员 条目名字, 文本型
    .成员 用户, 文本型
    .成员 值, 文本型

.数据类型 RARHeaderData, , RAR 档案文件头数据结构
    .成员 ArcName, 字节型, , "260", 输出，返回当前档案文件名，可用于检测是否为正确的分卷名。
    .成员 FileName, 字节型, , "260", 输出，返回 OEM (DOS) 编码的文件名
    .成员 Flags, 整数型, , , 输出，文件标志（&H1-文件继承自前卷; &H2-文件延续至后卷; &H4-文件使用密码加密; &H8-文件包含注释文本; &H10-先前文件使用了压缩[固实标志]）
    .成员 PackSize, 整数型, , , 输出，返回打包文件或分卷大小（如果使用了分卷压缩）
    .成员 UnpSize, 整数型, , , 输出，返回解包后的文件大小
    .成员 HostOS, 整数型, , , 输出，返回执行的操作系统（(0-MS DOS; 1-0S/2; 2-Win32; 3-Unix)）
    .成员 FileCRC, 整数型, , , 输出，返回解包文件的 CRC 校验信息. 如果文件被分卷,只有最后分卷部分包含了正确的 CRC 信息并且只有使用了 RAR_OM_LIST_INCSPLIT 模式才可正常读取.
    .成员 FileTime, 整数型, , , 输出，返回标准 MS DOS 格式的日期和时间
    .成员 UnpVer, 整数型, , , 输出，返回提取文件所需的 RAR 版本，返回格式为： 10*主版本号+副版本号
    .成员 Method, 整数型, , , 输出，返回打包方法。
    .成员 FileAttr, 整数型, , , 输出，返回文件属性。
    .成员 CmtBuf, 整数型, , , 输入/输出，本应为档案注释文本，文本型数据，但新版本的 DLL 将不再执行该功能，CmtState 一直为 0。
    .成员 CmtBufSize, 整数型, , , 输入，返回缓冲大小,新版本中不必再设置(见上)
    .成员 CmtSize, 整数型, , , 输出，返回实际缓冲大小,新版本中无效(见上)
    .成员 CmtState, 整数型, , , 输出，返回注释获取状态,新版本中无效(将始终返回无注释状态, 见上)

.数据类型 SHELLEXECUTEINFOA
    .成员 cbSize, 整数型
    .成员 fMask, 整数型
    .成员 hwnd, 整数型
    .成员 lpVerb, 文本型
    .成员 lpFile, 文本型
    .成员 lpParameters, 文本型
    .成员 lpDirectory, 文本型
    .成员 nShow, 整数型
    .成员 hInstApp, 整数型
    .成员 lpIDList, 整数型
    .成员 lpClass, 文本型
    .成员 hkeyClass, 整数型
    .成员 dwHotKey, 整数型
    .成员 hIcon, 整数型
    .成员 hProcess, 整数型

.数据类型 SHELLEXECUTEINFOW
    .成员 cbSize, 整数型
    .成员 fMask, 整数型
    .成员 hwnd, 整数型
    .成员 lpVerb, 字节集
    .成员 lpFile, 字节集
    .成员 lpParameters, 字节集
    .成员 lpDirectory, 字节集
    .成员 nShow, 整数型
    .成员 hInstApp, 整数型
    .成员 lpIDList, 整数型
    .成员 lpClass, 字节集
    .成员 hkeyClass, 整数型
    .成员 dwHotKey, 整数型
    .成员 hIcon, 整数型
    .成员 hProcess, 整数型

.数据类型 RAROpenArchiveDataEx, , RAR 档案打开数据结构
    .成员 ArcName, 文本型, , , 输入，指定档案文件名。
    .成员 ArcNameW, 字节集, , , 输入，指定档案文件名的 Unicode 字符串，未指定 Unicode 名称时设为空。
    .成员 OpenMode, 整数型, , , 输入，指定打开方式，为 RAR_OM_* 常数之一。
    .成员 OpenResult, 整数型, , , 输出，返回 0 表示执行成功，其他值参见 ERAR_* 常数[仅 11-15 部分]。
    .成员 CmtBuf, 文本型, , , 输入/输出，可选。档案注释文本缓冲区，最大缓冲长度为 64 Kb；缓冲过小时超出部分被截断，本成员为空时表示不获取注释文本。
    .成员 CmtBufSize, 整数型, , , 输入，指定 CmtBuf 成员的缓冲区大小。
    .成员 CmtSize, 整数型, , , 输出，返回实际读取到档案注释文本的缓冲大小， 该值不会超过 CmtBufSize 成员。
    .成员 CmtState, 整数型, , , 输出，返回档案注释文本读取结果(0 表示未设置注释;1 表示注释读取完成, 其他返回值见 ERAR_* 常数[仅 11,12,14,20])
    .成员 Flags, 整数型, , , 输出，位标记组合。(&H1-分卷属性; &H2-包含档案注释; &H4-档案锁定属性; &H8-固实档案属性; &H10-新式分卷命名方案[volname.partN.rar]; &H20-包含校验信息; &H40-包含恢复记录; &H80-区块头被加密; &H100-首个分卷[需 RAR 3.0 以上版本])

.数据类型 SECURITY_ATTRIBUTES, , 系统_取DOS执行结果
    .成员 nLength, 整数型
    .成员 lpSecurityDescriptor, 整数型
    .成员 bInheritHandle, 逻辑型

.数据类型 注册表_键, 公开
    .成员 键名称, 文本型
    .成员 键值, 字节集
    .成员 类型, 整数型, , , 类型对照请看"REG_"开头的常量

.数据类型 PROCESS_INFORMATION
    .成员 hProcess, 整数型
    .成员 hThread, 整数型
    .成员 dwProcessId, 整数型
    .成员 dwThreadId, 整数型

.数据类型 STARTUPINFO, 公开
    .成员 cb, 整数型
    .成员 lpReserved, 整数型
    .成员 lpDesktop, 整数型
    .成员 lpTitle, 整数型
    .成员 dwX, 整数型
    .成员 dwY, 整数型
    .成员 dwXSize, 整数型
    .成员 dwYSize, 整数型
    .成员 dwXCountChars, 整数型
    .成员 dwYCountChars, 整数型
    .成员 dwFillAttribute, 整数型
    .成员 dwFlags, 整数型
    .成员 wShowWindow, 短整数型
    .成员 cbReserved2, 短整数型
    .成员 lpReserved2, 整数型
    .成员 hStdInput, 整数型
    .成员 hStdOutput, 整数型
    .成员 hStdError, 整数型
    .成员 lpAttributeList, 整数型, , , STARTUPINFOEX

.数据类型 RESTOREPTINFO, , 系统还原_创建还原点
    .成员 dwEventType
    .成员 dwRestorePtType
    .成员 llSequenceNumber, 长整数型
    .成员 szDescription, 字节型, , "64"

.数据类型 SMGRSTATUS, , 系统还原_创建还原点
    .成员 nStatus
    .成员 llSequenceNumber, 长整数型

.数据类型 FONT_RESOURCE, , 系统_取字体名
    .成员 dwDup, 整数型, , "7"
    .成员 wszFontName, 短整数型, , "1024"

.数据类型 SYSTEM_INFO, , 系统_取CPU占用率
    .成员 wProcessorArchitecture, 整数型
    .成员 dwPageSize, 整数型
    .成员 lpMinimumApplicationAddress, 整数型
    .成员 lpMaximumApplicationAddress, 整数型
    .成员 dwActiveProcessorMask, 整数型
    .成员 dwNumberOrfProcessors, 整数型
    .成员 dwProcessorType, 整数型
    .成员 dwAllocationGranularity, 整数型
    .成员 dwReserved, 整数型

.数据类型 PFLASHWINFO, , 窗口_闪动Ex
    .成员 cbSize, 整数型
    .成员 hwnd, 整数型
    .成员 dwFlags, 整数型
    .成员 uCount, 整数型
    .成员 dwTimeout, 整数型

.数据类型 GUID, 公开
    .成员 Data1, 整数型
    .成员 Data2, 短整数型
    .成员 Data3, 短整数型
    .成员 Data4, 字节型, , "8"

.数据类型 时区信息_, , 系统_取系统时区
    .成员 Bias, 整数型
    .成员 StandardName, 字节型, , "63"
    .成员 系统时间年, 短整数型
    .成员 系统时间月, 短整数型
    .成员 系统时间星期, 短整数型
    .成员 系统时间天, 短整数型
    .成员 系统时间时, 短整数型
    .成员 系统时间分, 短整数型
    .成员 系统时间秒, 短整数型
    .成员 系统时间毫秒, 短整数型
    .成员 StandardBias, 整数型
    .成员 DaylightName, 短整数型, , "32"
    .成员 时区时间年, 短整数型
    .成员 时区时间月, 短整数型
    .成员 时区时间星期, 短整数型
    .成员 时区时间天, 短整数型
    .成员 时区时间时, 短整数型
    .成员 时区时间分, 短整数型
    .成员 时区时间秒, 短整数型
    .成员 时区时间毫秒, 短整数型
    .成员 DaylightBias, 整数型

.数据类型 WINDOWINFO, , 窗口_是否激活
    .成员 cbSize, 整数型
    .成员 rcWindow, 精易_矩形
    .成员 rcClient, 精易_矩形
    .成员 dwStyle, 整数型
    .成员 dwExStyle, 整数型
    .成员 dwWindowStatus, 整数型
    .成员 cxWindowBorders, 整数型
    .成员 cyWindowBorders, 整数型
    .成员 atomWindowType, 短整数型
    .成员 wCreatorVersion, 短整数型

.数据类型 IO_STATUS_BLOCK, , 文件_句柄取路径
    .成员 Status
    .成员 Information

.数据类型 FILE_NAME_INFORMATION, , 文件_句柄取路径
    .成员 FileNameLength
    .成员 FileName

.数据类型 BY_HANDLE_FILE_INFORMATION, , 文件_句柄取路径
    .成员 dwFileAttributes, 整数型
    .成员 ftCreationTime, FILETIME
    .成员 ftLastAccessTime, FILETIME
    .成员 ftLastWriteTime, FILETIME
    .成员 dwVolumeSerialNumber, 整数型
    .成员 nFileSizeHigh, 整数型
    .成员 nFileSizeLow, 整数型
    .成员 nNumberOfLinks, 整数型
    .成员 nFileIndexHigh, 整数型
    .成员 nFileIndexLow, 整数型

.数据类型 IO_COUNTERS, , 进程_取IO读取字节 进程_取IO其它计数
    .成员 读取操作数量, 长整数型, , , ReadOperationCount
    .成员 写入操作数量, 长整数型, , , WriteOperationCount
    .成员 其它读写操作数量, 长整数型, , , OtherOperationCount
    .成员 读取字节数, 长整数型, , , ReadTransferCount
    .成员 写入字节数, 长整数型, , , WriteTransferCount
    .成员 其它读写操作字节, 长整数型, , , OtherTransferCount

.数据类型 MINMAXINFO, , 窗口_限定尺寸
    .成员 ptReserved, 精易_坐标
    .成员 ptMaxSize, 精易_坐标
    .成员 ptMaxPosition, 精易_坐标
    .成员 ptMinTrackSize, 精易_坐标
    .成员 ptMaxTrackSize, 精易_坐标

.数据类型 MD5_CTX
    .成员 i, 整数型, , "2"
    .成员 buf, 整数型, , "4"
    .成员 in, 字节型, , "64"
    .成员 digest, 字节型, , "16"

.数据类型 URL_COMPONENTS, 公开
    .成员 dwStructSize, , , , 本结构长度，注：60
    .成员 lpszScheme, , , , 协议类型
    .成员 dwSchemeLength, , , , 协议类型缓冲区长度
    .成员 nScheme, , , , 链接类型，1=http，2=https。（INTERNET_SCHEME_HTTP=1，INTERNET_SCHEME_HTTPS=2）
    .成员 lpszHostName, , , , 主机域名(Host)
    .成员 dwHostNameLength, , , , 主机域名缓冲区长度
    .成员 nPort, , , , 端口
    .成员 lpszUserName, , , , 帐号
    .成员 dwUserNameLength, , , , 帐号缓冲区长度
    .成员 lpszPassword, , , , 密码
    .成员 dwPasswordLength, , , , 密码缓冲区长度
    .成员 lpszUrlPath, , , , 路径(页面地址)
    .成员 dwUrlPathLength, , , , 路径缓冲区长度
    .成员 lpszExtraInfo, , , , 额外信息，比如“?”或“#”之后的参数字符串。
    .成员 dwExtraInfoLength, , , , 额外信息长度

.数据类型 LOGFONT, 公开, 定义字体的属性
    .成员 lfHeight, 整数型, , , 字体单元格或字符的高度（以逻辑单位表示）。字符高度值（也称为em高度）是字符单元格高度值减去内部前导值。
    .成员 lfWidth, 整数型, , , 字体中字符的平均宽度（以逻辑单位表示）。如果lfWidth为零，则设备的宽高比与可用字体的数字化宽高比相匹配，以找到最接近的匹配，由差值的绝对值确定。
    .成员 lfEscapement, 整数型, , , 设备x轴之间的角度，以十分之一度为单位
    .成员 lfOrientation, 整数型, , , 每个字符的基线和设备的x轴之间的角度，以十分之一度为单位。
    .成员 lfWeight, 整数型, , , 字体的权重范围为0到1000.例如，400表示正常，700表示粗体。如果此值为零，则使用默认权重。
    .成员 lfItalic, 字节型, , , 斜体
    .成员 lfUnderline, 字节型, , , 下划线
    .成员 lfStrikeOut, 字节型, , , 删除线
    .成员 lfCharSet, 字节型, , , 字符集
    .成员 lfOutPrecision, 字节型, , , 输出精度。输出精度定义输出必须与请求的字体的高度，宽度，字符方向，擒纵，音高和字体类型匹配的程度。
    .成员 lfClipPrecision, 字节型, , , 剪裁精度。裁剪精度定义了如何剪辑部分位于裁剪区域之外的字符。
    .成员 lfQuality, 字节型, , , 输出质量。输出质量定义了图形设备接口（GDI）必须如何仔细地将逻辑字体属性与实际物理字体的属性相匹配。
    .成员 lfPitchAndFamily, 字节型, , , 字体族
    .成员 lfFaceName, 字节型, , "32", W版为64个成员的字节数组或者32个成员的短整数数组,以null结尾的字符串，用于指定字体的字体名称。此字符串的长度不得超过32个TCHAR值，包括终止NULL。该EnumFontFamiliesEx函数可用于枚举所有当前可用字体的字体名称。如果lfFaceName是空字符串，则GDI使用与其他指定属性匹配的第一个字体。

.数据类型 CHOOSEFONT, , 对话框_选择字体
    .成员 结构大小, 整数型
    .成员 窗口句柄, 整数型
    .成员 设备场景句柄, 整数型
    .成员 字体结构指针, 整数型
    .成员 点大小, 整数型
    .成员 标志, 整数型
    .成员 颜色值, 整数型
    .成员 自定义数据, 整数型
    .成员 回调函数地址, 整数型
    .成员 模板名称, 文本型
    .成员 实例句柄, 整数型
    .成员 字体风格, 文本型
    .成员 字体类型, 短整数型
    .成员 空白队列, 短整数型
    .成员 最小尺寸, 整数型
    .成员 最大尺寸, 整数型

.数据类型 NOTIFYICONDATA
    .成员 cbSize, 整数型, , , 结构大小
    .成员 hWnd, 整数型, , , 窗口句柄
    .成员 uID, 整数型, , , 标识符
    .成员 uFlags, 整数型, , , 标志
    .成员 uCallbackMessage, 整数型, , , 返回信息
    .成员 hIcon, 整数型, , , 图标句柄
    .成员 szTip, 字节型, , "128", 提示文本
    .成员 dwState, 整数型
    .成员 dwStateMask, 整数型
    .成员 szInfo, 字节型, , "256", 提示信息
    .成员 uTimeoutAndVersion, 整数型
    .成员 szInfoTitle, 字节型, , "64", 标题
    .成员 dwInfoFlags, 整数型, , , 提示图标

.数据类型 IconDirEntry, , 16
    .成员 bWidth, 字节型, , , 图标图片的显示宽度
    .成员 bHeight, 字节型, , , 图标图片的显示高度
    .成员 bColorCount, 字节型, , , 图标图片的颜色数
    .成员 bReserved, 字节型, , , 保留域总是 0
    .成员 wPlanes, 短整数型, , , 图标图片的位面数
    .成员 wBitCount, 短整数型, , , 图标图片的颜色深度
    .成员 dwBytesInRes, 整数型, , , 图标图片占用的数据量
    .成员 dwImageOffset, 整数型, , , 图标图片的开始位置

.数据类型 hostent
    .成员 h_name
    .成员 h_aliases
    .成员 h_addrtype, 短整数型
    .成员 h_length, 短整数型
    .成员 h_addr_list

.数据类型 ICMP_ECHO_REPLY
    .成员 address, 整数型, , ,  ‘包含正回复的IP地址
    .成员 Status, 整数型, , ,   ‘包含回复的状态（参看后面的常量部分）
    .成员 RoundTripTime, 整数型, , , ‘往返时间RTT(毫秒)
    .成员 DataSize, 整数型, , , ‘回复数据大小(字节)
    .成员 Reserved, 短整数型, , ,  ‘保留
    .成员 ptrData, 短整数型, , , ‘指向回复数据的指针
    .成员 Options, IP_OPTION_INFORMATION, , , 回复选项
    .成员 Data, 字节型, , "250"

.数据类型 IP_OPTION_INFORMATION
    .成员 Ttl, 字节型, , ,  ‘生存时间
    .成员 Tos, 字节型, , , ‘服务类型
    .成员 Flags, 字节型, , ,  ‘IP头标志
    .成员 OptionsSize, 字节型, , ,  ‘选项数据的大小，字节
    .成员 OptionsData, 整数型, , , ‘指向选项数据的指针

.数据类型 WAVEOUTCAPS
    .成员 wMid, 短整数型
    .成员 wPid, 短整数型
    .成员 vDriverVersion, 整数型
    .成员 szPname, 字节型, , "32"
    .成员 dwFormats, 整数型
    .成员 wChannels, 短整数型
    .成员 dwSupport, 整数型

.数据类型 配置节数据, 公开
    .成员 节名称, 文本型
    .成员 项, 配置项数据, , "1"

.数据类型 配置项数据, 公开
    .成员 配置项名称, 文本型
    .成员 值, 文本型

.数据类型 ULARGE_INTEGER, , 进程_取父ID
    .成员 LowPart
    .成员 HighPart

.数据类型 UNICODE_STRING, , 进程_取父ID
    .成员 长度, 短整数型, , , Length
    .成员 最大长度, 短整数型, , , MaximumLength
    .成员 缓冲区, 整数型, , , Buffer

.数据类型 SYSTEM_PROCESS_INFORMATION, 公开, 进程_取父ID
    .成员 NextEntryDelta, 整数型
    .成员 ThreadCount, 整数型
    .成员 Reserved1, LARGE_INTEGER, , "3"
    .成员 CreateTime, LARGE_INTEGER
    .成员 UserTime, LARGE_INTEGER
    .成员 KernelTime, LARGE_INTEGER
    .成员 ImageName, UNICODE_STRING
    .成员 BasePriority, 整数型, , , KPRIORITY               
    .成员 ProcessId, 整数型
    .成员 InheritedFromProcessId, 整数型
    .成员 HandleCount, 整数型
    .成员 Reserved2, 整数型, , "2"
    .成员 VirtualMemoryCounters, VM_COUNTERS, , , VM_COUNTERS             
    .成员 IoCounters, IO_COUNTERS, , , IO_COUNTERS             

.数据类型 OVERLAPPED
    .成员 Internal, 整数型
    .成员 InternalHigh, 整数型
    .成员 offset, 整数型
    .成员 OffsetHigh, 整数型
    .成员 hEvent, 整数型

.数据类型 精易_系统服务列表, 公开, 系统服务_枚举系统服务
    .成员 服务名称, 文本型
    .成员 显示名称, 文本型
    .成员 描述, 文本型
    .成员 文件路径, 文本型
    .成员 启动类型, 文本型
    .成员 服务状态, 文本型
    .成员 登陆为, 文本型

.数据类型 精易_系统服务列表Ex, 公开, 系统服务_枚举系统服务
    .成员 服务名称, 文本型
    .成员 显示名称, 文本型
    .成员 描述, 文本型
    .成员 进程ID
    .成员 文件路径, 文本型
    .成员 启动类型, 文本型
    .成员 服务状态, 文本型
    .成员 登陆为, 文本型

.数据类型 ENUM_SERVICE_STATUS_PROCESS
    .成员 lpServiceName
    .成员 lpDisplayName
    .成员 ServiceStatusProcess, SERVICE_STATUS_PROCESS

.数据类型 SERVICE_STATUS_PROCESS
    .成员 dwServiceType
    .成员 dwCurrentState
    .成员 dwControlsAccepted
    .成员 dwWin32ExitCode
    .成员 dwServiceSpecificExitCode
    .成员 dwCheckPoint
    .成员 dwWaitHint
    .成员 dwProcessId
    .成员 dwServiceFlags

.数据类型 ENUM_SERVICE_STATUS, , 枚举服务
    .成员 lpServiceName
    .成员 lpDisplayName
    .成员 ServiceStatus, SERVICE_STATUS

.数据类型 SYSTEMTIME
    .成员 wYear, 短整数型
    .成员 wMonth, 短整数型
    .成员 wDayOfWeek, 短整数型
    .成员 wDay, 短整数型
    .成员 wHour, 短整数型
    .成员 wMinute, 短整数型
    .成员 wSecond, 短整数型
    .成员 wMilliseconds, 短整数型

.数据类型 Cookie, 公开, cookie类型
    .成员 健, 文本型
    .成员 值, 文本型

.数据类型 NetworkCardMapName
    .成员 Index, 整数型
    .成员 strMapName, 文本型
    .成员 strFriendName, 文本型
    .成员 strGUID, 文本型

.数据类型 IP_ADAPTER_INFO_彗星
    .成员 Next, 整数型, , , _IP_ADAPTER_INFO* Next
    .成员 ComboIndex, 整数型, , , DWORD。ComboIndex
    .成员 AdapterName, 字节型, , "260", Char AdapterName[MAX_ADAPTER_NAME_LENGTH + 4];MAX_ADAPTER_NAME_LENGTH = 256
    .成员 Description, 字节型, , "132", char Description[MAX_ADAPTER_DESCRIPTION_LENGTH + 4];MAX_ADAPTER_DESCRIPTION_LENGTH = 128
    .成员 AddressLength, 整数型, , , UINT。AddressLength
    .成员 Address, 字节型, , "8", BYTE Address[MAX_ADAPTER_ADDRESS_LENGTH];MAX_ADAPTER_ADDRESS_LENGTH=8
    .成员 Index, 整数型, , , DWORD。Index
    .成员 Type, 整数型, , , UINT。Type
    .成员 DhcpEnabled, 整数型, , , UINT。DhcpEnabled
    .成员 CurrentIpAddress, 整数型, , , PIP_ADDR_STRING。CurrentIpAddress
    .成员 IpAddressList, IP_ADDR_STRING, , , IP_ADDR_STRING。IpAddressList
    .成员 GatewayList, IP_ADDR_STRING, , , IP_ADDR_STRING。GatewayList
    .成员 DhcpServer, IP_ADDR_STRING, , , IP_ADDR_STRING。DhcpServer
    .成员 HaveWins, 整数型, , , BOOL。HaveWins
    .成员 PrimaryWinsServer, IP_ADDR_STRING, , , IP_ADDR_STRING。PrimaryWinsServer
    .成员 SecondaryWinsServer, IP_ADDR_STRING, , , IP_ADDR_STRING。SecondaryWinsServer
    .成员 LeaseObtained, 长整数型, , , time_t。LeaseObtained
    .成员 LeaseExpires, 长整数型, , , time_t。LeaseExpires

.数据类型 IP_INTERFACE_INFO
    .成员 NumAdapters, 整数型, , , LONG。NumAdapters
    .成员 Adapter, IP_ADAPTER_INDEX_MAP, , , IP_ADAPTER_INDEX_MAP。Adapter[1]

.数据类型 精易_网卡信息_彗星, 公开, 网卡信息
    .成员 网卡名称, 文本型, , , 网卡名称
    .成员 网卡描述, 文本型, , , 网卡描述
    .成员 连接名称, 文本型, , , 友好名称，本地连接
    .成员 网卡类型n, 整数型
    .成员 网卡类型, 文本型, , , 网卡类型
    .成员 MAC地址, 文本型, , , MAC地址
    .成员 IP地址, 文本型, , , IP地址
    .成员 子网掩码, 文本型, , , 子网掩码
    .成员 网关地址, 文本型, , , 网关地址
    .成员 首选DNS服务器, 文本型, , , 首选DNS服务器
    .成员 备用DNS服务器, 文本型, , , 备用DNS服务器
    .成员 是否启用DHCP, 逻辑型

.数据类型 IP_ADAPTER_INDEX_MAP
    .成员 Index, 整数型, , , ULONG。Index
    .成员 Name, 字节型, , "256", WCHAR。Name。[MAX_ADAPTER_NAME];MAX_ADAPTER_NAME=128

.数据类型 精易_IP归属地, 公开
    .成员 IP, 文本型
    .成员 国家, 文本型
    .成员 省份, 文本型
    .成员 城市, 文本型
    .成员 运营商, 文本型

.数据类型 模糊属性, 公开, _DWM_BLURBEHIND
    .成员 dwFlags, 整数型, , , DWM Blur Behind常量值的按位组合，指示已设置此结构的哪些成员。
    .成员 fEnable, 逻辑型, , , TRUE将窗口句柄注册到DWM模糊后面; FALSE从DWM注销的窗口句柄模糊后面。
    .成员 hRgnBlur, 整数型, , , 客户区内将应用模糊的区域。一个NULL值将应用于整个客户区域的模糊。
    .成员 fTransitionOnMaximized, 整数型, , , 如果窗口的着色应转换为与最大化窗口匹配，则为TRUE ; 否则，FALSE。

.数据类型 EncoderParameter
    .成员 Guid, 字节型, , "16", 为了方便使用了字节型数组，本来应该是GUID类型。
    .成员 NumberOfValues, 整数型
    .成员 Type, 整数型
    .成员 Value, 整数型, , , Value *

.数据类型 缩略图属性, 公开, _DWM_THUMBNAIL_PROPERTIES
    .成员 dwFlags, 整数型, , , 按位组合DWM略缩图常数值，该值指示设置了此结构的哪些成员。1=源矩形，2=显示矩形，4=透明度，8=可视，16=仅工作区
    .成员 目标矩形, 精易_矩形, , , rcDestination         1.略缩图将显示到目标窗口中的矩形区域。
    .成员 源矩形, 精易_矩形, , , rcSource              2.要用作略缩图的源窗口的区域。默认情况下，整个窗口用作略缩图。
    .成员 透明度, 字节型, , , opacity               4.渲染略缩图的不透明度。取值0-255。0是完全透明的，而255是完全不透明的。默认值为255。
    .成员 可视, 逻辑型, , , fVisible              8.可视
    .成员 仅工作区, 逻辑型, , , fSourceClientAreaOnly 16.仅使用略缩图源的工作区

.数据类型 EncoderParameters
    .成员 Count, 整数型
    .成员 Parameter, EncoderParameter, , "1"

.数据类型 SCROLLINFO
    .成员 cbSize, 整数型
    .成员 fMask, 整数型
    .成员 nMin, 整数型
    .成员 nMax, 整数型
    .成员 nPage, 整数型
    .成员 nPos, 整数型
    .成员 nTrackPos, 整数型

.数据类型 SCROLLBARINFO
    .成员 cbSize, 整数型
    .成员 rcScrollBar, RECT
    .成员 dxyLineButton, 整数型
    .成员 xyThumbTop, 整数型
    .成员 xyThumbBottom, 整数型
    .成员 reserved, 整数型
    .成员 rgstate, 整数型, , "6"

.数据类型 COMBOBOXINFO, 公开
    .成员 cbSize, 整数型, , , 结构大小
    .成员 rcItem, RECT, , , 条目矩形
    .成员 rcButton, RECT, , , 按钮矩形
    .成员 stateButton, 整数型, , , 按钮状态
    .成员 hwndCombo, 整数型, , , 超级组合框句柄
    .成员 hwndItem, 整数型, , , 编辑框句柄
    .成员 hwndList, 整数型, , , 列表框句柄

.数据类型 MIB_TCPTABLE_OWNER_PID, , https://msdn.microsoft.com/en-us/library/aa366921.aspx
    .成员 dwNumEntries, 整数型, , , 表中MIB_TCPROW_OWNER_PID元素的数量。
    .成员 TCP_TABLE_CLASS, MIB_TCPROW_OWNER_PID, , "255", MIB_TCPROW_OWNER_PID数组。

.数据类型 MIB_TCPROW_OWNER_PID, , https://msdn.microsoft.com/en-us/library/aa366913.aspx
    .成员 dwState, 整数型, , , //连接状态
    .成员 dwLocalAddr, 整数型, , , //本地 IP地址,值为零表示TCP侦听器愿意接受与本地计算机相关联的任何IP接口的数据报。
    .成员 dwLocalPort, 整数型, , , //本地端口,本地计算机上TCP端点的端口号。该成员以网络字节顺序存储。
    .成员 dwRemoteAddr, 整数型, , , //远程 IP 地址
    .成员 dwRemotePort, 整数型, , , //远程端口
    .成员 dwOwningPid, 整数型, , , //关联的进程ID,发出UDP端点绑定功能的进程的PID 。当PID不可用时，该成员设置为0。

.数据类型 MIB_UDPTABLE_OWNER_PID, , https://msdn.microsoft.com/en-us/library/aa366932.aspx
    .成员 dwNumEntries, 整数型, , , 表中MIB_UDPROW_OWNER_PID元素的数量。
    .成员 UDP_TABLE_CLASS, MIB_UDPROW_OWNER_PID, , "255", MIB_UDPTABLE_OWNER_PID数组。

.数据类型 MIB_UDPROW_OWNER_PID, , https://msdn.microsoft.com/en-us/library/aa366928.aspx
    .成员 dwLocalAddr, 整数型, , , //本地 IP地址,值为零表示UDP侦听器愿意接受与本地计算机相关联的任何IP接口的数据报。
    .成员 dwLocalPort, 整数型, , , //本地端口,本地计算机上UDP端点的端口号。该成员以网络字节顺序存储。
    .成员 dwOwningPid, 整数型, , , //关联的进程ID,发出UDP端点绑定功能的进程的PID 。当PID不可用时，该成员设置为0。

.数据类型 HotKeyData
    .成员 hWnd, 整数型
    .成员 nModifiers, 整数型, , , #MOD_CONTROL #MOD_SHIFT #MOD_ALT
    .成员 nVirtKey, 整数型
    .成员 hProc, 整数型
    .成员 nType, 整数型
    .成员 bChar, 逻辑型

.数据类型 WINDOWCOMPOSITIONATTRIBDATA
    .成员 Attrib, 整数型
    .成员 pvData, ACCENT_POLICY, 传址
    .成员 cbData, 整数型

.数据类型 ACCENT_POLICY
    .成员 AccentState, 整数型
    .成员 AccentFlags, 整数型
    .成员 GradientColor, 整数型
    .成员 AnimationId, 整数型

.数据类型 STORAGE_DEVICE_DESCRIPTOR, , 输出参数
    .成员 Version, 整数型
    .成员 Size, 整数型
    .成员 DeviceType, 字节型
    .成员 DeviceTypeModifier, 字节型
    .成员 RemovableMedia, 字节型
    .成员 CommandQueueing, 字节型
    .成员 VendorIdOffset, 整数型
    .成员 ProductIdOffset, 整数型
    .成员 ProductRevisionOffset, 整数型
    .成员 SerialNumberOffset, 整数型
    .成员 BusType, 整数型, , , STORAGE_BUS_TYPE
    .成员 RawPropertiesLength, 整数型
    .成员 RawDeviceProperties, 字节型, , "1"

.数据类型 STORAGE_PROPERTY_QUERY, , 输入参数
    .成员 PropertyId, 长整数型
    .成员 QueryType, 长整数型
    .成员 AdditionalParameters, 字节型, , "1"

.数据类型 WINDOWPLACEMENT, 公开
    .成员 Length, 整数型, , , 结构的长度
    .成员 flags, 整数型, , , 控制最小化窗口的位置和恢复窗口的方法(#WPF_xxx)
    .成员 showCmd, 整数型, , , 窗口的当前显示状态(#SW_xxx)
    .成员 ptMinPosition, POINT, , , 窗口最小化时窗口左上角的坐标
    .成员 ptMaxPosition, POINT, , , 窗口最大化时窗口左上角的坐标
    .成员 rcNormalPosition, RECT, , , 当窗口处于恢复位置时窗口的坐标

.数据类型 PROCESSENTRY32W
    .成员 dwSize, 整数型
    .成员 cntUsage, 整数型
    .成员 th32ProcessID, 整数型
    .成员 th32DefaultHeapID, 整数型
    .成员 th32ModuleID, 整数型
    .成员 cntThreads, 整数型
    .成员 th32ParentProcessID, 整数型
    .成员 pcPriClassBase, 整数型
    .成员 dwFlags, 整数型
    .成员 szExeFile, 字节型, , "520"

.数据类型 WIN32_FIND_DATAW, 公开
    .成员 dwFileAttributes, 整数型
    .成员 ftCreationTime, FILETIME
    .成员 ftLastAccessTime, FILETIME
    .成员 ftLastWriteTime, FILETIME
    .成员 nFileSizeHigh, 整数型
    .成员 nFileSizeLow, 整数型
    .成员 dwReserved0, 整数型
    .成员 dwReserved1, 整数型
    .成员 cFileName, 字节型, , "520"
    .成员 cAlternateFileName, 字节型, , "28"

.数据类型 KBDLLHOOKSTRUCT
    .成员 vkCode, 整数型
    .成员 scanCode, 整数型
    .成员 flags, 整数型
    .成员 time, 整数型
    .成员 dwExtraInfo, 整数型

.数据类型 精易_时区信息, 公开
    .成员 时区, 文本型
    .成员 时区名, 文本型
    .成员 时区代码, 文本型

.数据类型 精易_显卡信息, 公开
    .成员 显卡名称, 文本型, , , Name
    .成员 驱动程序版本号, 文本型, , , DriverVersion
    .成员 内存大小, 长整数型, , , AdapterRAM
    .成员 描述, 文本型, , , Caption
    .成员 详细描述, 文本型, , , Description

.数据类型 精易_回收站中的文件信息, 公开
    .成员 当前的路径, 文本型
    .成员 原路径, 文本型
    .成员 删除时间, 日期时间型

.数据类型 BROWSEINFOW
    .成员 hwndOwner, 整数型
    .成员 pidlRoot, 整数型
    .成员 pszDisplayName, 整数型
    .成员 lpszTitle, 整数型
    .成员 ulFlags, 整数型
    .成员 lpfn, 整数型
    .成员 lParam, 整数型
    .成员 iImage, 整数型

.数据类型 精易_网络适配器配置, 公开
    .成员 状态, 整数型, , , #IfOperStatus**
    .成员 描述, 文本型
    .成员 适配器名称, 文本型
    .成员 物理地址, 文本型
    .成员 启用DHCP, 逻辑型
    .成员 IPv4地址, 文本型
    .成员 IPv4子网掩码, 文本型
    .成员 IPv4默认网关, 文本型
    .成员 DHCP服务器, 文本型
    .成员 IPv4DNS服务器, 文本型
    .成员 本地IPv6地址, 文本型
    .成员 IPv6索引, 整数型
    .成员 IPv6默认网关, 文本型
    .成员 IPv6DNS服务器, 文本型

.数据类型 JsonError, 公开
    .成员 Number, 整数型, , , 错误号
    .成员 Source, 文本型, , , 错误的来源
    .成员 Description, 文本型, , , 错误的描述
    .成员 HelpFile, 文本型, , , 可以在其中找到错误帮助的文件
    .成员 HelpContext, 整数型, , , 包含错误信息主题的上下文ID
    .成员 Text, 文本型, , , 发生错误的源代码行
    .成员 Line, 整数型, , , 发生错误的源代码行号
    .成员 Column, 整数型, , , 发生错误的源代码列位置

.数据类型 进程_模块信息, 公开
    .成员 模块句柄, 长整数型
    .成员 模块文件名, 文本型
    .成员 模块完整路径, 文本型

.数据类型 HOOKPROC
    .成员 lpfn, 子程序指针
    .成员 HHOOK, 整数型
    .成员 lpAddress, 整数型

.数据类型 MSLLHOOKSTRUCT
    .成员 pt, POINT
    .成员 mouseData, 整数型
    .成员 flags, 整数型
    .成员 time, 整数型
    .成员 dwExtraInfo, 整数型

.数据类型 NUMBERFMTA
    .成员 NumDigits, 整数型
    .成员 LeadingZero, 整数型
    .成员 Grouping, 整数型
    .成员 lpDecimalSep, 文本型
    .成员 lpThousandSep, 文本型
    .成员 NegativeOrder, 整数型

.数据类型 INPUT, 公开
    .成员 type, 整数型
    .成员 wVk, 短整数型
    .成员 wScan, 短整数型
    .成员 dwFlags, 整数型
    .成员 time, 整数型
    .成员 dwExtraInfo, 整数型
    .成员 uMsg, 整数型
    .成员 wParamL, 短整数型
    .成员 wParamH, 短整数型

.数据类型 精易_任务列表项目, 公开
    .成员 目标, 字节集
    .成员 命令行, 字节集
    .成员 图标路径, 字节集, , , icon
    .成员 起始位置, 字节集
    .成员 标题, 字节集
    .成员 描述, 字节集

.数据类型 SYSTEM_POWER_STATUS, 公开, 包含有关系统电源状态的信息。
    .成员 ACLineStatus, 字节型, , , 交流电源状态。
    .成员 BatteryFlag, 字节型, , , 电池充电状态。
    .成员 BatteryLifePercent, 字节型, , , 剩余电量的百分比。
    .成员 SystemStatusFlag, 字节型, , , 省电模式的状态。
    .成员 BatteryLifeTime, 整数型, , , 剩余的电池寿命秒数。
    .成员 BatteryFullLifeTime, 整数型, , , 完全充电时的电池寿命秒数。

.数据类型 OPENASINFO
    .成员 pcszFile, 字节集
    .成员 pcszClass, 整数型
    .成员 oaifInFlags, 整数型

.数据类型 PERFORMANCE_INFORMATION
    .成员 cb, 整数型
    .成员 CommitTotal, 整数型
    .成员 CommitLimit, 整数型
    .成员 CommitPeak, 整数型
    .成员 PhysicalTotal, 整数型
    .成员 PhysicalAvailable, 整数型
    .成员 SystemCache, 整数型
    .成员 KernelTotal, 整数型
    .成员 KernelPaged, 整数型
    .成员 KernelNonpaged, 整数型
    .成员 PageSize, 整数型
    .成员 HandleCount, 整数型
    .成员 ProcessCount, 整数型
    .成员 ThreadCount, 整数型

.数据类型 精易_线程信息, 公开
    .成员 线程ID, 整数型
    .成员 进程ID, 整数型
    .成员 模块路径, 文本型
    .成员 线程入口, 整数型

.数据类型 CREDUI_INFOW
    .成员 cbSize, 整数型
    .成员 hwndParent, 整数型
    .成员 pszMessageText, 字节集
    .成员 pszCaptionText, 字节集
    .成员 hbmBanner, 整数型

.数据类型 自定义排序数组, , 用于自定义数组排序  文本_分割文本排序（）
    .成员 整数, 整数型, , , 整数型排序字段
    .成员 小数, 双精度小数型, , , 小数型排序字段
    .成员 日期时间, 日期时间型, , , 日期时间型排序字段
    .成员 文本, 文本型, , , 文本型排序字段
    .成员 原数据, 文本型, , , 单行文本内容

.数据类型 WIN32_FILE_SIZE, 公开
    .成员 dwSizeLow, 整数型
    .成员 dwSizeHigh, 整数型

.数据类型 INTERNET_BUFFERSA
    .成员 dwStructSize, 整数型
    .成员 Next, 整数型
    .成员 lpcszHeader, 整数型
    .成员 dwHeadersLength, 整数型
    .成员 dwHeadersTotal, 整数型
    .成员 lpvBuffer, 整数型
    .成员 dwBufferLength, 整数型
    .成员 dwBufferTotal, 整数型
    .成员 dwOffsetLow, 整数型
    .成员 dwOffsetHigh, 整数型

.版本 2

.程序集 调试
.子程序 _启动子程序, 整数型, , 请在本子程序中放置易模块初始化代码
    ' ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
    ' ┃模块开发：广大易友    版本：V11.1.5                               ┃
    ' ┣━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
    ' ┃模块说明：使用易语言核心支持库 + API完成      授权：开源&永久免费 ┃◆精易论坛       〓 http://bbs.125.la/
    ' ┣━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
    ' ┃使用注意：精易模块纯绿色,为了确保安全,请务必到〖精易论坛〗下载    ┃◆易语言助手     〓 http://e.125.la/
    ' ┣━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
    ' ┃特别声明：部分代码是取自前辈们的，集合在一起只是方便大家使用！    ┃◆精易编程助手   〓 http://soft.125.la/
    ' ┣━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
    ' ┃使用声明：请勿使用本模块编写有损他人利益的软件,造成的后果全部自负 ┃◆精易模块官网   〓 http://ec.125.la/
    ' ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛
    .如果真 (是否为调试版 ())
        输出调试文本 (#精易论坛模块注释) ' 请保留此信息，勿删除或修改。
        窗口_写字 (, “精易论坛 bbs.125.la 模块版本:11.1.5”, “黑体”, 23, , 680, 36) ' 请保留此信息，勿删除或修改。
    .如果真结束
    
    m_CodePage ＝ #CP_gb2312 ' => 简体中文 GBK
    m_stageSize ＝ 1048576 ' => 1M
    GetWinver () ' => _WIN32_WINNT
    
    _临时子程序 () ' 在初始化代码执行完毕后调用测试代码
    返回 (0) ' 可以根据您的需要返回任意数值

.子程序 _临时子程序
    

.版本 2

.程序集 类_位图处理, , 公开, 作: 为你芯冻
.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
    

.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
    

.子程序 取位图颜色, 整数型, 公开
    .参数 位图, 字节集
    .参数 横坐标, 整数型, 可空, 范围为 0~图像宽度 - 1；留空为0。表示图像最左侧。
    .参数 纵坐标, 整数型, 可空, 范围为 0~图像高度 - 1；留空为0。表示图像最顶边。
    .局部变量 信息大小, 整数型, , , BITMAPINFOHEADER -> biSize        一般为 40，但从实际数据获取较保险
    .局部变量 图像宽度, 整数型, , , BITMAPINFOHEADER -> biWidth
    .局部变量 图像高度, 整数型, , , BITMAPINFOHEADER -> biHeight       > 0 从下至上逆向存储； < 0 从上至下正向存储
    .局部变量 图像位数, 短整数型, , , BITMAPINFOHEADER -> biBitCount
    .局部变量 图像压缩, 整数型, , , BITMAPINFOHEADER -> biCompression  1/2-压缩图像; 4/5-JPG/PNG  0-未压缩; 3-未压缩且调色板为3色掩码(位域方式)
    .局部变量 扫描行, 整数型, , , 固定公式计算
    .局部变量 坐标偏移, 整数型, , , 固定公式计算，返回相对于图像数据阵列起始位置的偏移量
    .局部变量 数据偏移, 整数型, , , 文件头 + 信息头 + 调色板(如果有) + 坐标偏移，即指定坐标颜色数据(或其调色板索引)相对于图形数据的偏移量
    .局部变量 色板大小, 整数型, , , 调色板大小，如果有。
    .局部变量 RGB, 字节集
    .局部变量 字节位移, 整数型, , , 用于 图像位数 = 1 或 4 时取指定位
    .局部变量 定点数据, 整数型, , , 颜色数据所在位置、颜色(或调色板)索引等

    .如果真 (取字节集左边 (位图, 2) ≠ { 66, 77 }) ' { 66, 77 } BM 标志
        返回 (-1)
    .如果真结束
    信息大小 ＝ 取字节集数据 (取字节集中间 (位图, 15, 4), #整数型, )
    图像宽度 ＝ 取字节集数据 (取字节集中间 (位图, 19, 4), #整数型, )
    图像高度 ＝ 取字节集数据 (取字节集中间 (位图, 23, 4), #整数型, )
    图像位数 ＝ 取字节集数据 (取字节集中间 (位图, 29, 2), #短整数型, )
    图像压缩 ＝ 取字节集数据 (取字节集中间 (位图, 31, 4), #整数型, )
    .如果真 (图像压缩 ≠ 0 且 图像压缩 ≠ 3)
        返回 (-1)
    .如果真结束
    .如果真 (横坐标 ＜ 0 或 纵坐标 ＜ 0 或 横坐标 ＞ 图像宽度 － 1 或 纵坐标 ＞ 图像高度 － 1)
        返回 (-1)
    .如果真结束
    .判断开始 (图像位数 ＝ 16 或 图像位数 ＝ 32)
        色板大小 ＝ 选择 (图像压缩 ＝ 0, 0, 12)
    .判断 (图像位数 ＝ 24)
        色板大小 ＝ 0
    .判断 (图像位数 ＝ 1 或 图像位数 ＝ 4 或 图像位数 ＝ 8) ' 有调色板
        色板大小 ＝ 左移 (取字节集数据 (取字节集中间 (位图, 47, 4), #整数型, ), 2) ' 实际使用色彩数 * 4
        .如果真 (色板大小 ＝ 0)
            色板大小 ＝ 左移 (4, 图像位数)
        .如果真结束
        
    .默认
        返回 (-1)
    .判断结束
    扫描行 ＝ 左移 (右移 (图像宽度 × 图像位数 ＋ 31, 5), 2) ' 备用写法：右移 (位与 (图像宽度 × 图像位数 ＋ 31, 位取反 (31)), 3)
    坐标偏移 ＝ (右移 (图像高度, 31) × (图像高度 ＋ 1) ＋ 图像高度 － 位或 (右移 (图像高度, 31), 1) × (纵坐标 ＋ 1)) × 扫描行 ＋ 右移 (横坐标 × 图像位数, 3) ＋ 1
    数据偏移 ＝ 14 ＋ 信息大小 ＋ 色板大小 ＋ 坐标偏移
    RGB ＝ { 0, 0, 0, 0 }
    .判断开始 (图像位数 ＝ 32) ' 3 字节表示 1个像素颜色
        RGB ＝ 取字节集中间 (位图, 数据偏移, 4)
    .判断 (图像位数 ＝ 24)
        RGB [1] ＝ 位图 [数据偏移 ＋ 2]
        RGB [2] ＝ 位图 [数据偏移 ＋ 1]
        RGB [3] ＝ 位图 [数据偏移]
    .判断 (图像位数 ＝ 1 或 图像位数 ＝ 4 或 图像位数 ＝ 8) ' 有调色板，1 字节表示 8/2/1 个像素颜色的调色板索引
        定点数据 ＝ 位图 [数据偏移] ' 色彩索引字节
        字节位移 ＝ 位与 (横坐标 ＋ 1, 8 ÷ 图像位数 － 1)
        .如果真 (字节位移 ＞ 0)
            定点数据 ＝ 右移 (定点数据, 8 － 图像位数 × 字节位移)
        .如果真结束
        定点数据 ＝ 位与 (定点数据, 左移 (1, 图像位数) － 1)
        定点数据 ＝ 14 ＋ 信息大小 ＋ 左移 (定点数据, 2) ＋ 1 ' 指定色调色板偏移基址
        RGB [1] ＝ 位图 [定点数据 ＋ 2]
        RGB [2] ＝ 位图 [定点数据 ＋ 1]
        RGB [3] ＝ 位图 [定点数据]
    .默认
        
    .判断结束
    返回 (取字节集数据 (RGB, #整数型, ))

.子程序 置位图颜色, 字节集, 公开
    .参数 位图, 字节集
    .参数 横坐标, 整数型, 可空, 范围为 0~图像宽度 - 1；留空为0。表示图像最左侧。
    .参数 纵坐标, 整数型, 可空, 范围为 0~图像高度 - 1；留空为0。表示图像最顶边。
    .参数 颜色值, 整数型
    .局部变量 信息大小, 整数型, , , BITMAPINFOHEADER -> biSize        一般为 40，但从实际数据获取较保险
    .局部变量 图像宽度, 整数型, , , BITMAPINFOHEADER -> biWidth
    .局部变量 图像高度, 整数型, , , BITMAPINFOHEADER -> biHeight       > 0 从下至上逆向存储； < 0 从上至下正向存储
    .局部变量 图像位数, 短整数型, , , BITMAPINFOHEADER -> biBitCount
    .局部变量 图像压缩, 整数型, , , BITMAPINFOHEADER -> biCompression  1/2-压缩图像; 4/5-JPG/PNG  0-未压缩; 3-未压缩且调色板为3色掩码(位域方式)
    .局部变量 扫描行, 整数型, , , 固定公式计算
    .局部变量 坐标偏移, 整数型, , , 固定公式计算，返回相对于图像数据阵列起始位置的偏移量
    .局部变量 数据偏移, 整数型, , , 文件头 + 信息头 + 调色板(如果有) + 坐标偏移，即指定坐标颜色数据(或其调色板索引)相对于图形数据的偏移量
    .局部变量 色板大小, 整数型, , , 调色板大小，如果有。
    .局部变量 RGB, 字节集

    .如果真 (取字节集左边 (位图, 2) ≠ { 66, 77 }) ' { 66, 77 } BM 标志
        返回 ({ })
    .如果真结束
    信息大小 ＝ 取字节集数据 (取字节集中间 (位图, 15, 4), #整数型, )
    图像宽度 ＝ 取字节集数据 (取字节集中间 (位图, 19, 4), #整数型, )
    图像高度 ＝ 取字节集数据 (取字节集中间 (位图, 23, 4), #整数型, )
    图像位数 ＝ 取字节集数据 (取字节集中间 (位图, 29, 2), #短整数型, )
    图像压缩 ＝ 取字节集数据 (取字节集中间 (位图, 31, 4), #整数型, )
    .如果真 (图像压缩 ≠ 0 且 图像压缩 ≠ 3)
        返回 (位图)
    .如果真结束
    .如果真 (横坐标 ＜ 0 或 纵坐标 ＜ 0 或 横坐标 ＞ 图像宽度 － 1 或 纵坐标 ＞ 图像高度 － 1)
        返回 (位图)
    .如果真结束
    .判断开始 (图像位数 ＝ 16 或 图像位数 ＝ 32)
        色板大小 ＝ 选择 (图像压缩 ＝ 0, 0, 12)
    .判断 (图像位数 ＝ 24)
        色板大小 ＝ 0
    .默认
        返回 (位图)
    .判断结束
    扫描行 ＝ 左移 (右移 (图像宽度 × 图像位数 ＋ 31, 5), 2) ' 备用写法：右移 (位与 (图像宽度 × 图像位数 ＋ 31, 位取反 (31)), 3)
    坐标偏移 ＝ (右移 (图像高度, 31) × (图像高度 ＋ 1) ＋ 图像高度 － 位或 (右移 (图像高度, 31), 1) × (纵坐标 ＋ 1)) × 扫描行 ＋ 右移 (横坐标 × 图像位数, 3) ＋ 1
    数据偏移 ＝ 14 ＋ 信息大小 ＋ 色板大小 ＋ 坐标偏移
    RGB ＝ 到字节集 (颜色值)
    .判断开始 (图像位数 ＝ 32) ' 3 字节表示 1个像素颜色
        位图 ＝ 字节集替换 (位图, 数据偏移, 4, RGB)
    .判断 (图像位数 ＝ 24)
        位图 [数据偏移 ＋ 2] ＝ RGB [1]
        位图 [数据偏移 ＋ 1] ＝ RGB [2]
        位图 [数据偏移] ＝ RGB [3]
    .默认
        
    .判断结束
    返回 (位图)

.子程序 取位图颜色表, 整数型, 公开
    .参数 位图, 字节集
    .参数 颜色表, 整数型, 参考 数组
    .局部变量 信息大小, 整数型, , , BITMAPINFOHEADER -> biSize        一般为 40，但从实际数据获取较保险
    .局部变量 图像宽度, 整数型, , , BITMAPINFOHEADER -> biWidth
    .局部变量 图像高度, 整数型, , , BITMAPINFOHEADER -> biHeight       > 0 从下至上逆向存储； < 0 从上至下正向存储
    .局部变量 图像位数, 短整数型, , , BITMAPINFOHEADER -> biBitCount
    .局部变量 图像压缩, 整数型, , , BITMAPINFOHEADER -> biCompression  1/2-压缩图像; 4/5-JPG/PNG  0-未压缩; 3-未压缩且调色板为3色掩码(位域方式)
    .局部变量 扫描行, 整数型, , , 固定公式计算
    .局部变量 坐标偏移, 整数型, , , 固定公式计算，返回相对于图像数据阵列起始位置的偏移量
    .局部变量 数据偏移, 整数型, , , 文件头 + 信息头 + 调色板(如果有) + 坐标偏移，即指定坐标颜色数据(或其调色板索引)相对于图形数据的偏移量
    .局部变量 色板大小, 整数型, , , 调色板大小，如果有。
    .局部变量 RGB, 字节集
    .局部变量 x, 整数型
    .局部变量 y, 整数型
    .局部变量 定点数据, 整数型
    .局部变量 字节位移, 整数型

    .如果真 (取字节集左边 (位图, 2) ≠ { 66, 77 }) ' { 66, 77 } BM 标志
        返回 (0)
    .如果真结束
    信息大小 ＝ 取字节集数据 (取字节集中间 (位图, 15, 4), #整数型, )
    图像宽度 ＝ 取字节集数据 (取字节集中间 (位图, 19, 4), #整数型, )
    图像高度 ＝ 取字节集数据 (取字节集中间 (位图, 23, 4), #整数型, )
    图像位数 ＝ 取字节集数据 (取字节集中间 (位图, 29, 2), #短整数型, )
    图像压缩 ＝ 取字节集数据 (取字节集中间 (位图, 31, 4), #整数型, )
    .如果真 (图像压缩 ≠ 0 且 图像压缩 ≠ 3)
        返回 (0)
    .如果真结束
    .判断开始 (图像位数 ＝ 16 或 图像位数 ＝ 32)
        色板大小 ＝ 选择 (图像压缩 ＝ 0, 0, 12)
    .判断 (图像位数 ＝ 24)
        色板大小 ＝ 0
    .判断 (图像位数 ＝ 1 或 图像位数 ＝ 4 或 图像位数 ＝ 8) ' 有调色板
        色板大小 ＝ 左移 (取字节集数据 (取字节集中间 (位图, 47, 4), #整数型, ), 2) ' 实际使用色彩数 * 4
        .如果真 (色板大小 ＝ 0)
            色板大小 ＝ 左移 (4, 图像位数)
        .如果真结束
        
    .默认
        返回 (0)
    .判断结束
    扫描行 ＝ 左移 (右移 (图像宽度 × 图像位数 ＋ 31, 5), 2) ' 备用写法：右移 (位与 (图像宽度 × 图像位数 ＋ 31, 位取反 (31)), 3)
    重定义数组 (颜色表, 假, 图像宽度, 图像高度)
    .计次循环首 (图像宽度, x)
        .计次循环首 (图像高度, y)
            坐标偏移 ＝ (右移 (图像高度, 31) × (图像高度 ＋ 1) ＋ 图像高度 － 位或 (右移 (图像高度, 31), 1) × y) × 扫描行 ＋ 右移 ((x － 1) × 图像位数, 3) ＋ 1
            数据偏移 ＝ 14 ＋ 信息大小 ＋ 色板大小 ＋ 坐标偏移
            RGB ＝ { 0, 0, 0, 0 }
            .判断开始 (图像位数 ＝ 32) ' 3 字节表示 1个像素颜色
                RGB ＝ 取字节集中间 (位图, 数据偏移, 4)
            .判断 (图像位数 ＝ 24)
                RGB [1] ＝ 位图 [数据偏移 ＋ 2]
                RGB [2] ＝ 位图 [数据偏移 ＋ 1]
                RGB [3] ＝ 位图 [数据偏移]
            .判断 (图像位数 ＝ 1 或 图像位数 ＝ 4 或 图像位数 ＝ 8) ' 有调色板，1 字节表示 8/2/1 个像素颜色的调色板索引
                定点数据 ＝ 位图 [数据偏移] ' 色彩索引字节
                字节位移 ＝ 位与 (x, 8 ÷ 图像位数 － 1)
                .如果真 (字节位移 ＞ 0)
                    定点数据 ＝ 右移 (定点数据, 8 － 图像位数 × 字节位移)
                .如果真结束
                定点数据 ＝ 位与 (定点数据, 左移 (1, 图像位数) － 1)
                定点数据 ＝ 14 ＋ 信息大小 ＋ 左移 (定点数据, 2) ＋ 1 ' 指定色调色板偏移基址
                RGB [1] ＝ 位图 [定点数据 ＋ 2]
                RGB [2] ＝ 位图 [定点数据 ＋ 1]
                RGB [3] ＝ 位图 [定点数据]
            .默认
                
            .判断结束
            颜色表 [x] [y] ＝ 取字节集数据 (RGB, 3, )
        .计次循环尾 ()
        处理事件 ()
    .计次循环尾 ()
    返回 (图像位数)

.子程序 颜色表构建位图, 字节集, 公开, 如果颜色表是24位颜色表的话要构建8位位图 必须先把24位颜色表改成8位颜色表
    .参数 颜色表, 整数型, 数组, 输进一个二维数组,分别表示宽和高,数组值为颜色值
    .参数 位数, 整数型, 可空, 默认为24
    .局部变量 w, 整数型
    .局部变量 w1, 整数型
    .局部变量 h, 整数型
    .局部变量 x, 整数型
    .局部变量 y, 整数型
    .局部变量 i, 整数型
    .局部变量 n, 整数型
    .局部变量 位图, 字节集
    .局部变量 调色板, 整数型, , "0"

    .如果真 (取数组成员数 (颜色表) ＝ 0)
        返回 ({ })
    .如果真结束
    位数 ＝ 选择 (是否为空 (位数), 24, 位数)
    w ＝ 取字节集数据 (指针到字节集 (lstrcpynA_整数数组 (颜色表, 颜色表, 0) － 8, 4), 3, )
    h ＝ 取字节集数据 (指针到字节集 (lstrcpynA_整数数组 (颜色表, 颜色表, 0) － 4, 4), 3, )
    .判断开始 (位数 ＝ 24)
        .计次循环首 (h, y)
            .计次循环首 (w, x)
                位图 ＝ 位图 ＋ 字节集_反转 (取字节集左边 (到字节集 (颜色表 [x] [h ＋ 1 － y]), 3))
            .计次循环尾 ()
            .如果真 (取字节集长度 (位图) ÷ 4 ≠ 到整数 (取字节集长度 (位图) ÷ 4))
                位图 ＝ 位图 ＋ 取空白字节集 ((1 － 取字节集长度 (位图) ÷ 4 ＋ 到整数 (取字节集长度 (位图) ÷ 4)) × 4)
            .如果真结束
            处理事件 ()
        .计次循环尾 ()
        位图 ＝ { 66, 77 } ＋ 到字节集 (到整数 (58 ＋ 取字节集长度 (位图))) ＋ { 0, 0, 0, 0, 54, 0, 0, 0, 40, 0, 0, 0 } ＋ 到字节集 (w) ＋ 到字节集 (h) ＋ { 1, 0, 24, 0, 0, 0, 0, 0 } ＋ 到字节集 (取字节集长度 (位图)) ＋ { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } ＋ 位图
    .判断 (位数 ＝ 1)
        调色板 ＝ { #黑色, #白色 }
        w1 ＝ 到整数 (w ÷ 8)
        .如果真 (w1 ≠ w ÷ 8)
            w1 ＝ w1 ＋ 1
        .如果真结束
        .计次循环首 (h, y)
            .计次循环首 (w1, x)
                位图 ＝ 位图 ＋ { 0 }
                .计次循环首 (8, i)
                    .如果真 ((x － 1) × 8 ＋ i ≤ w)
                        .如果真 (颜色表 [(x － 1) × 8 ＋ i] [h ＋ 1 － y] ＝ #白色)
                            位图 [取字节集长度 (位图)] ＝ 位图 [取字节集长度 (位图)] ＋ 求次方 (2, 8 － i)
                        .如果真结束
                        
                    .如果真结束
                    
                .计次循环尾 ()
            .计次循环尾 ()
            .如果真 (取字节集长度 (位图) ÷ 4 ≠ 到整数 (取字节集长度 (位图) ÷ 4))
                位图 ＝ 位图 ＋ 取空白字节集 ((1 － 取字节集长度 (位图) ÷ 4 ＋ 到整数 (取字节集长度 (位图) ÷ 4)) × 4)
            .如果真结束
            处理事件 ()
        .计次循环尾 ()
        位图 ＝ { 66, 77 } ＋ 到字节集 (到整数 (66 ＋ 取字节集长度 (位图))) ＋ { 0, 0, 0, 0, 62, 0, 0, 0, 40, 0, 0, 0 } ＋ 到字节集 (w) ＋ 到字节集 (h) ＋ { 1, 0, 1, 0, 0, 0, 0, 0 } ＋ 到字节集 (取字节集长度 (位图)) ＋ { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } ＋ 指针到字节集 (lstrcpynA_整数数组 (调色板, 调色板, 0), 取数组成员数 (调色板) × 4) ＋ 位图
    .判断 (位数 ＝ 4)
        调色板 ＝ { 0, 8388608, 32768, 8421376, 128, 8388736, 32896, 8421504, 12632256, 16711680, 65280, 16776960, 255, 16711935, 65535, 16777215 }
        w1 ＝ 到整数 (w ÷ 2)
        .如果真 (w1 ≠ w ÷ 2)
            w1 ＝ w1 ＋ 1
        .如果真结束
        .计次循环首 (h, y)
            .计次循环首 (w1, x)
                位图 ＝ 位图 ＋ { 0 }
                .计次循环首 (2, i)
                    .如果真 ((x － 1) × 2 ＋ i ≤ w)
                        .计次循环首 (取数组成员数 (调色板), n)
                            .如果真 (调色板 [n] ＝ 颜色表 [(x － 1) × 2 ＋ i] [h ＋ 1 － y])
                                跳出循环 ()
                            .如果真结束
                            
                        .计次循环尾 ()
                        n ＝ 选择 (n ＝ 取数组成员数 (调色板) ＋ 1, n － 2, n － 1)
                        位图 [取字节集长度 (位图)] ＝ 位图 [取字节集长度 (位图)] ＋ n × 求次方 (16, 2 － i)
                        
                    .如果真结束
                    
                .计次循环尾 ()
            .计次循环尾 ()
            .如果真 (取字节集长度 (位图) ÷ 4 ≠ 到整数 (取字节集长度 (位图) ÷ 4))
                位图 ＝ 位图 ＋ 取空白字节集 ((1 － 取字节集长度 (位图) ÷ 4 ＋ 到整数 (取字节集长度 (位图) ÷ 4)) × 4)
            .如果真结束
            处理事件 ()
        .计次循环尾 ()
        位图 ＝ { 66, 77 } ＋ 到字节集 (到整数 (122 ＋ 取字节集长度 (位图))) ＋ { 0, 0, 0, 0, 118, 0, 0, 0, 40, 0, 0, 0 } ＋ 到字节集 (w) ＋ 到字节集 (h) ＋ { 1, 0, 4, 0, 0, 0, 0, 0 } ＋ 到字节集 (取字节集长度 (位图)) ＋ { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } ＋ 指针到字节集 (lstrcpynA_整数数组 (调色板, 调色板, 0), 取数组成员数 (调色板) × 4) ＋ 位图
    .判断 (位数 ＝ 8)
        调色板 ＝ { 0, 65793, 131586, 197379, 263172, 328965, 394758, 460551, 526344, 592137, 657930, 723723, 789516, 855309, 921102, 986895, 1052688, 1118481, 1184274, 1250067, 1315860, 1381653, 1447446, 1513239, 1579032, 1644825, 1710618, 1776411, 1842204, 1907997, 1973790, 2039583, 2105376, 2171169, 2236962, 2302755, 2368548, 2434341, 2500134, 2565927, 2631720, 2697513, 2763306, 2829099, 2894892, 2960685, 3026478, 3092271, 3158064, 3223857, 3289650, 3355443, 3421236, 3487029, 3552822, 3618615, 3684408, 3750201, 3815994, 3881787, 3947580, 4013373, 4079166, 4144959, 4210752, 4276545, 4342338, 4408131, 4473924, 4539717, 4605510, 4671303, 4737096, 4802889, 4868682, 4934475, 5000268, 5066061, 5131854, 5197647, 5263440, 5329233, 5395026, 5460819, 5526612, 5592405, 5658198, 5723991, 5789784, 5855577, 5921370, 5987163, 6052956, 6118749, 6184542, 6250335, 6316128, 6381921, 6447714, 6513507, 6579300, 6645093, 6710886, 6776679, 6842472, 6908265, 6974058, 7039851, 7105644, 7171437, 7237230, 7303023, 7368816, 7434609, 7500402, 7566195, 7631988, 7697781, 7763574, 7829367, 7895160, 7960953, 8026746, 8092539, 8158332, 8224125, 8289918, 8355711, 8421504, 8487297, 8553090, 8618883, 8684676, 8750469, 8816262, 8882055, 8947848, 9013641, 9079434, 9145227, 9211020, 9276813, 9342606, 9408399, 9474192, 9539985, 9605778, 9671571, 9737364, 9803157, 9868950, 9934743, 10000536, 10066329, 10132122, 10197915, 10263708, 10329501, 10395294, 10461087, 10526880, 10592673, 10658466, 10724259, 10790052, 10855845, 10921638, 10987431, 11053224, 11119017, 11184810, 11250603, 11316396, 11382189, 11447982, 11513775, 11579568, 11645361, 11711154, 11776947, 11842740, 11908533, 11974326, 12040119, 12105912, 12171705, 12237498, 12303291, 12369084, 12434877, 12500670, 12566463, 12632256, 12698049, 12763842, 12829635, 12895428, 12961221, 13027014, 13092807, 13158600, 13224393, 13290186, 13355979, 13421772, 13487565, 13553358, 13619151, 13684944, 13750737, 13816530, 13882323, 13948116, 14013909, 14079702, 14145495, 14211288, 14277081, 14342874, 14408667, 14474460, 14540253, 14606046, 14671839, 14737632, 14803425, 14869218, 14935011, 15000804, 15066597, 15132390, 15198183, 15263976, 15329769, 15395562, 15461355, 15527148, 15592941, 15658734, 15724527, 15790320, 15856113, 15921906, 15987699, 16053492, 16119285, 16185078, 16250871, 16316664, 16382457, 16448250, 16514043, 16579836, 16645629, 16711422, 16777215 }
        .计次循环首 (h, y)
            .计次循环首 (w, x)
                位图 ＝ 位图 ＋ { 0 }
                .计次循环首 (取数组成员数 (调色板), n)
                    .如果真 (调色板 [n] ＝ 颜色表 [x] [h ＋ 1 － y])
                        跳出循环 ()
                    .如果真结束
                    
                .计次循环尾 ()
                n ＝ 选择 (n ＝ 取数组成员数 (调色板) ＋ 1, n － 2, n － 1)
                位图 [取字节集长度 (位图)] ＝ n
            .计次循环尾 ()
            .如果真 (取字节集长度 (位图) ÷ 4 ≠ 到整数 (取字节集长度 (位图) ÷ 4))
                位图 ＝ 位图 ＋ 取空白字节集 ((1 － 取字节集长度 (位图) ÷ 4 ＋ 到整数 (取字节集长度 (位图) ÷ 4)) × 4)
            .如果真结束
            处理事件 ()
        .计次循环尾 ()
        位图 ＝ { 66, 77 } ＋ 到字节集 (到整数 (2102 ＋ 取字节集长度 (位图))) ＋ { 0, 0, 0, 0, 54, 4, 0, 0, 40, 0, 0, 0 } ＋ 到字节集 (w) ＋ 到字节集 (h) ＋ { 1, 0, 8, 0, 0, 0, 0, 0 } ＋ 到字节集 (取字节集长度 (位图)) ＋ { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } ＋ 指针到字节集 (lstrcpynA_整数数组 (调色板, 调色板, 0), 取数组成员数 (调色板) × 4) ＋ 位图
    .判断 (位数 ＝ 32)
        .计次循环首 (h, y)
            .计次循环首 (w, x)
                位图 ＝ 位图 ＋ 字节集_反转 (取字节集左边 (到字节集 (颜色表 [x] [h ＋ 1 － y]), 3)) ＋ { 0 }
            .计次循环尾 ()
            处理事件 ()
        .计次循环尾 ()
        位图 ＝ { 66, 77 } ＋ 到字节集 (到整数 (58 ＋ 取字节集长度 (位图))) ＋ { 0, 0, 0, 0, 54, 0, 0, 0, 40, 0, 0, 0 } ＋ 到字节集 (w) ＋ 到字节集 (h) ＋ { 1, 0, 32, 0, 0, 0, 0, 0 } ＋ 到字节集 (取字节集长度 (位图)) ＋ { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } ＋ 位图
    .默认
        
    .判断结束
    返回 (位图)

.子程序 位图去杂点, 字节集, 公开
    .参数 位图, 字节集
    .局部变量 颜色表, 整数型, , "0"
    .局部变量 w, 整数型
    .局部变量 h, 整数型
    .局部变量 x, 整数型
    .局部变量 y, 整数型
    .局部变量 i, 整数型
    .局部变量 孤立值, 整数型
    .局部变量 点x, 整数型
    .局部变量 点y, 整数型
    .局部变量 点阵, 整数型, , "8,3"

    w ＝ 取字节集数据 (取字节集中间 (位图, 19, 4), 3, )
    h ＝ 取字节集数据 (取字节集中间 (位图, 23, 4), 3, )
    写到内存 ({ 1, 0, 0, 0, 255, 255, 255, 255, 0, 0, 0, 0, 2, 0, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 4, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255, 8, 0, 0, 0, 1, 0, 0, 0, 255, 255, 255, 255, 16, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 32, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 128, 0, 0, 0, 255, 255, 255, 255, 1, 0, 0, 0 }, lstrcpynA_整数数组 (点阵, 点阵, 0), 96)
    取位图颜色表 (位图, 颜色表)
    .计次循环首 (h, y)
        .计次循环首 (w, x)
            点x ＝ -1
            点y ＝ -1
            孤立值 ＝ 点是否孤立 (位图, x － 1, y － 1)
            .如果真 (孤立值 ＝ -1)
                到循环尾 ()
            .如果真结束
            .如果真 (孤立值 ＝ 0)
                颜色表 [x] [y] ＝ #白色
                到循环尾 ()
            .如果真结束
            .计次循环首 (8, i)
                .如果真 (位与 (孤立值, 点阵 [i] [1]) ＝ 点阵 [i] [1])
                    .如果 (点x ＝ -1 且 点y ＝ -1)
                        点x ＝ x ＋ 点阵 [i] [2]
                        点y ＝ y ＋ 点阵 [i] [3]
                    .否则
                        跳出循环 ()
                    .如果结束
                    
                .如果真结束
                
            .计次循环尾 ()
            .如果真 (i ＝ 9)
                i ＝ 点是否孤立 (位图, 点x, 点y)
                .如果真 (i ＝ 孤立值)
                    颜色表 [x] [y] ＝ #白色
                    颜色表 [点x] [点y] ＝ #白色
                .如果真结束
                
            .如果真结束
            
        .计次循环尾 ()
        处理事件 ()
    .计次循环尾 ()
    位图 ＝ 颜色表构建位图 (颜色表)
    返回 (位图)

.子程序 位图缩放, 字节集, 公开
    .参数 位图, 字节集
    .参数 缩放后宽, 整数型
    .参数 缩放后高, 整数型
    .局部变量 w, 整数型
    .局部变量 h, 整数型
    .局部变量 x, 整数型
    .局部变量 y, 整数型
    .局部变量 x0, 双精度小数型
    .局部变量 y0, 双精度小数型
    .局部变量 x1, 整数型
    .局部变量 x2, 整数型
    .局部变量 y1, 整数型
    .局部变量 y2, 整数型
    .局部变量 颜色1, 字节集
    .局部变量 颜色2, 字节集
    .局部变量 缩放颜色r1, 双精度小数型
    .局部变量 缩放颜色g1, 双精度小数型
    .局部变量 缩放颜色b1, 双精度小数型
    .局部变量 缩放颜色r2, 双精度小数型
    .局部变量 缩放颜色g2, 双精度小数型
    .局部变量 缩放颜色b2, 双精度小数型
    .局部变量 dt颜色r, 双精度小数型
    .局部变量 dt颜色g, 双精度小数型
    .局部变量 dt颜色b, 双精度小数型
    .局部变量 缩放宽比, 双精度小数型
    .局部变量 缩放高比, 双精度小数型
    .局部变量 颜色表, 整数型, , "0"
    .局部变量 缩放颜色表, 整数型, , "0"

    w ＝ 取字节集数据 (取字节集中间 (位图, 19, 4), 3, )
    h ＝ 取字节集数据 (取字节集中间 (位图, 23, 4), 3, )
    取位图颜色表 (位图, 颜色表)
    重定义数组 (缩放颜色表, 假, 缩放后宽, 缩放后高)
    缩放宽比 ＝ w ÷ 缩放后宽
    缩放高比 ＝ h ÷ 缩放后高
    .计次循环首 (缩放后宽, x)
        .计次循环首 (缩放后高, y)
            x0 ＝ x × 缩放宽比
            y0 ＝ y × 缩放高比
            .如果 (到整数 (x0) ≠ x0)
                x1 ＝ 选择 (到整数 (x0) ＜ 1, 1, 到整数 (x0))
                x2 ＝ 到整数 (x0) ＋ 1
            .否则
                x1 ＝ x0
                x2 ＝ x0
            .如果结束
            .如果 (到整数 (y0) ≠ y0)
                y1 ＝ 选择 (到整数 (y0) ＜ 1, 1, 到整数 (y0))
                y2 ＝ 到整数 (y0) ＋ 1
            .否则
                y1 ＝ y0
                y2 ＝ y0
            .如果结束
            颜色1 ＝ 到字节集 (颜色表 [x1] [y1])
            颜色2 ＝ 到字节集 (颜色表 [x1] [y2])
            缩放颜色r1 ＝ 颜色2 [1] － (颜色2 [1] － 颜色1 [1]) × (y2 － y0)
            缩放颜色g1 ＝ 颜色2 [2] － (颜色2 [2] － 颜色1 [2]) × (y2 － y0)
            缩放颜色b1 ＝ 颜色2 [3] － (颜色2 [3] － 颜色1 [3]) × (y2 － y0)
            颜色1 ＝ 到字节集 (颜色表 [x2] [y1])
            颜色2 ＝ 到字节集 (颜色表 [x2] [y2])
            缩放颜色r2 ＝ 颜色2 [1] － (颜色2 [1] － 颜色1 [1]) × (y2 － y0)
            缩放颜色g2 ＝ 颜色2 [2] － (颜色2 [2] － 颜色1 [2]) × (y2 － y0)
            缩放颜色b2 ＝ 颜色2 [3] － (颜色2 [3] － 颜色1 [3]) × (y2 － y0)
            dt颜色r ＝ 缩放颜色r2 － (缩放颜色r2 － 缩放颜色r1) × (x2 － x0)
            dt颜色g ＝ 缩放颜色g2 － (缩放颜色g2 － 缩放颜色g1) × (x2 － x0)
            dt颜色b ＝ 缩放颜色b2 － (缩放颜色b2 － 缩放颜色b1) × (x2 － x0)
            颜色1 [1] ＝ 四舍五入 (dt颜色r, )
            颜色1 [2] ＝ 四舍五入 (dt颜色g, )
            颜色1 [3] ＝ 四舍五入 (dt颜色b, )
            缩放颜色表 [x] [y] ＝ 取字节集数据 (颜色1, 3, )
        .计次循环尾 ()
        处理事件 ()
    .计次循环尾 ()
    返回 (颜色表构建位图 (缩放颜色表))

.子程序 位图转换位数, 字节集, 公开
    .参数 位图, 字节集
    .参数 位数, 整数型
    .局部变量 w, 整数型
    .局部变量 h, 整数型
    .局部变量 x, 整数型
    .局部变量 y, 整数型
    .局部变量 i, 整数型
    .局部变量 rgb1, 字节集
    .局部变量 rgb2, 字节集
    .局部变量 亮度值, 双精度小数型
    .局部变量 颜色值, 整数型
    .局部变量 颜色表, 整数型, , "0"
    .局部变量 调色板, 整数型, , "0"

    w ＝ 取字节集数据 (取字节集中间 (位图, 19, 4), 3, )
    h ＝ 取字节集数据 (取字节集中间 (位图, 23, 4), 3, )
    取位图颜色表 (位图, 颜色表)
    .如果真 (位数 ＝ 8 或 位数 ＝ 4 或 位数 ＝ 1)
        .计次循环首 (w, x)
            .计次循环首 (h, y)
                rgb1 ＝ 到字节集 (颜色表 [x] [y])
                亮度值 ＝ rgb1 [1] × 0.299 ＋ rgb1 [2] × 0.588 ＋ rgb1 [3] × 0.113
                连续赋值 (四舍五入 (亮度值, ), rgb1 [1], rgb1 [2], rgb1 [3])
                颜色表 [x] [y] ＝ 取字节集数据 (rgb1, 3, )
            .计次循环尾 ()
            处理事件 ()
        .计次循环尾 ()
        .如果真 (位数 ＝ 4 或 位数 ＝ 1)
            .如果 (位数 ＝ 4)
                调色板 ＝ { 0, 8388608, 32768, 8421376, 128, 8388736, 32896, 8421504, 12632256, 16711680, 65280, 16776960, 255, 16711935, 65535, 16777215 }
            .否则
                调色板 ＝ { #黑色, #白色 }
            .如果结束
            .计次循环首 (w, x)
                .计次循环首 (h, y)
                    rgb1 ＝ 到字节集 (颜色表 [x] [y])
                    亮度值 ＝ rgb1 [1]
                    颜色值 ＝ -1
                    .计次循环首 (取数组成员数 (调色板), i)
                        .如果 (颜色值 ＝ -1)
                            颜色值 ＝ 调色板 [i]
                        .否则
                            rgb1 ＝ 到字节集 (颜色值)
                            rgb2 ＝ 到字节集 (调色板 [i])
                            颜色值 ＝ 选择 (取绝对值 (rgb2 [1] × 0.113 ＋ rgb2 [2] × 0.588 ＋ rgb2 [3] × 0.299 － 亮度值) ＜ 取绝对值 (rgb1 [1] × 0.113 ＋ rgb1 [2] × 0.588 ＋ rgb1 [3] × 0.299 － 亮度值), 调色板 [i], 颜色值)
                        .如果结束
                        
                    .计次循环尾 ()
                    颜色表 [x] [y] ＝ 颜色值
                .计次循环尾 ()
                处理事件 ()
            .计次循环尾 ()
        .如果真结束
        
    .如果真结束
    位图 ＝ 颜色表构建位图 (颜色表, 位数)
    返回 (位图)

.子程序 位图二值化, 字节集, 公开
    .参数 位图, 字节集
    .参数 阀值, 整数型
    .局部变量 w, 整数型
    .局部变量 h, 整数型
    .局部变量 x, 整数型
    .局部变量 y, 整数型
    .局部变量 rgb, 字节集
    .局部变量 颜色表, 整数型, , "0"

    w ＝ 取字节集数据 (取字节集中间 (位图, 19, 4), 3, )
    h ＝ 取字节集数据 (取字节集中间 (位图, 23, 4), 3, )
    .如果真 (取位图颜色表 (位图, 颜色表) ＝ 0)
        返回 ({ })
    .如果真结束
    .计次循环首 (w, x)
        .计次循环首 (h, y)
            rgb ＝ 到字节集 (颜色表 [x] [y])
            .如果 (rgb [1] ＜ 阀值 且 rgb [2] ＜ 阀值 且 rgb [3] ＜ 阀值)
                颜色表 [x] [y] ＝ #黑色
            .否则
                颜色表 [x] [y] ＝ #白色
            .如果结束
            
        .计次循环尾 ()
        处理事件 ()
    .计次循环尾 ()
    位图 ＝ 颜色表构建位图 (颜色表)
    返回 (位图)

.子程序 位图反色, 字节集, 公开
    .参数 位图, 字节集
    .局部变量 颜色表, 整数型, , "0"
    .局部变量 w, 整数型
    .局部变量 h, 整数型
    .局部变量 x, 整数型
    .局部变量 y, 整数型
    .局部变量 rgb, 整数型
    .局部变量 bin, 字节集

    w ＝ 取字节集数据 (取字节集中间 (位图, 19, 4), 3, )
    h ＝ 取字节集数据 (取字节集中间 (位图, 23, 4), 3, )
    取位图颜色表 (位图, 颜色表)
    .计次循环首 (w, x)
        .计次循环首 (h, y)
            rgb ＝ 颜色表 [x] [y]
            bin ＝ 到字节集 (rgb)
            bin [1] ＝ 255 － bin [1]
            bin [2] ＝ 255 － bin [2]
            bin [3] ＝ 255 － bin [3]
            rgb ＝ 取字节集数据 (bin, 3, )
            颜色表 [x] [y] ＝ rgb
        .计次循环尾 ()
        处理事件 ()
    .计次循环尾 ()
    位图 ＝ 颜色表构建位图 (颜色表)
    返回 (位图)

.子程序 取位图轮廓图, 字节集, 公开
    .参数 位图, 字节集
    .局部变量 w, 整数型
    .局部变量 h, 整数型
    .局部变量 x, 整数型
    .局部变量 y, 整数型
    .局部变量 i, 整数型
    .局部变量 rgb, 整数型
    .局部变量 颜色表, 整数型, , "0"

    w ＝ 取字节集数据 (取字节集中间 (位图, 19, 4), 3, )
    h ＝ 取字节集数据 (取字节集中间 (位图, 23, 4), 3, )
    取位图颜色表 (位图, 颜色表)
    .计次循环首 (w, x)
        .计次循环首 (h, y)
            rgb ＝ 取位图颜色 (位图, x － 1, y － 1)
            .如果真 (rgb ≠ #白色)
                rgb ＝ 取位图颜色 (位图, x － 2, y － 1)
                .如果真 (rgb ＝ -1 或 rgb ＝ #白色)
                    到循环尾 ()
                .如果真结束
                rgb ＝ 取位图颜色 (位图, x － 1, y － 2)
                .如果真 (rgb ＝ -1 或 rgb ＝ #白色)
                    到循环尾 ()
                .如果真结束
                rgb ＝ 取位图颜色 (位图, x, y － 1)
                .如果真 (rgb ＝ -1 或 rgb ＝ #白色)
                    到循环尾 ()
                .如果真结束
                rgb ＝ 取位图颜色 (位图, x － 1, y)
                .如果真 (rgb ＝ -1 或 rgb ＝ #白色)
                    到循环尾 ()
                .如果真结束
                rgb ＝ 取位图颜色 (位图, x － 2, y － 2)
                .如果真 (rgb ＝ -1 或 rgb ＝ #白色)
                    到循环尾 ()
                .如果真结束
                rgb ＝ 取位图颜色 (位图, x, y － 2)
                .如果真 (rgb ＝ -1 或 rgb ＝ #白色)
                    到循环尾 ()
                .如果真结束
                rgb ＝ 取位图颜色 (位图, x － 2, y)
                .如果真 (rgb ＝ -1 或 rgb ＝ #白色)
                    到循环尾 ()
                .如果真结束
                rgb ＝ 取位图颜色 (位图, x, y)
                .如果真 (rgb ＝ -1 或 rgb ＝ #白色)
                    到循环尾 ()
                .如果真结束
                颜色表 [x － 1] [y － 1] ＝ #白色
            .如果真结束
            
        .计次循环尾 ()
        处理事件 ()
    .计次循环尾 ()
    返回 (颜色表构建位图 (颜色表))

.子程序 位图细化, 字节集, 公开
    .参数 位图, 字节集
    .局部变量 表, 字节集
    .局部变量 位图宽度, 整数型
    .局部变量 位图高度, 整数型
    .局部变量 Finished, 逻辑型
    .局部变量 X, 整数型
    .局部变量 Y, 整数型
    .局部变量 w, 整数型
    .局部变量 e, 整数型
    .局部变量 nw, 整数型
    .局部变量 n, 整数型
    .局部变量 ne, 整数型
    .局部变量 sw, 整数型
    .局部变量 s, 整数型
    .局部变量 se, 整数型
    .局部变量 num, 整数型

    表 ＝ { 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0 }
    位图宽度 ＝ 取字节集数据 (取字节集中间 (位图, 19, 4), 3, )
    位图高度 ＝ 取字节集数据 (取字节集中间 (位图, 23, 4), 3, )
    Finished ＝ 假
    .判断循环首 (Finished ＝ 假)
        Finished ＝ 真
        .计次循环首 (位图高度 － 2, Y)
            X ＝ 1
            .判断循环首 (X ＜ 位图宽度 － 2)
                .如果真 (取位图颜色 (位图, X, Y) ≠ #白色)
                    w ＝ 选择 (取位图颜色 (位图, X － 1, Y) ＝ #白色, 1, 0)
                    e ＝ 选择 (取位图颜色 (位图, X ＋ 1, Y) ＝ #白色, 1, 0)
                    .如果真 (w ＝ 1 或 e ＝ 1)
                        nw ＝ 选择 (取位图颜色 (位图, X － 1, Y － 1) ＝ #白色, 1, 0)
                        n ＝ 选择 (取位图颜色 (位图, X, Y － 1) ＝ #白色, 1, 0)
                        ne ＝ 选择 (取位图颜色 (位图, X ＋ 1, Y － 1) ＝ #白色, 1, 0)
                        sw ＝ 选择 (取位图颜色 (位图, X － 1, Y ＋ 1) ＝ #白色, 1, 0)
                        s ＝ 选择 (取位图颜色 (位图, X, Y ＋ 1) ＝ #白色, 1, 0)
                        se ＝ 选择 (取位图颜色 (位图, X ＋ 1, Y ＋ 1) ＝ #白色, 1, 0)
                        num ＝ nw ＋ n × 2 ＋ ne × 4 ＋ w × 8 ＋ e × 16 ＋ sw × 32 ＋ s × 64 ＋ se × 128
                        .如果真 (表 [num ＋ 1] ＝ 1)
                            位图 ＝ 置位图颜色 (位图, X, Y, #白色)
                            Finished ＝ 假
                            X ＝ X ＋ 1
                        .如果真结束
                        
                    .如果真结束
                    
                .如果真结束
                X ＝ X ＋ 1
            .判断循环尾 ()
            处理事件 ()
        .计次循环尾 ()
        .计次循环首 (位图宽度 － 2, X)
            Y ＝ 1
            .判断循环首 (Y ＜ 位图高度 － 2)
                .如果真 (取位图颜色 (位图, X, Y) ≠ #白色)
                    n ＝ 选择 (取位图颜色 (位图, X, Y － 1) ＝ #白色, 1, 0)
                    s ＝ 选择 (取位图颜色 (位图, X, Y ＋ 1) ＝ #白色, 1, 0)
                    .如果真 (n ＝ 1 或 s ＝ 1)
                        nw ＝ 选择 (取位图颜色 (位图, X － 1, Y － 1) ＝ #白色, 1, 0)
                        ne ＝ 选择 (取位图颜色 (位图, X ＋ 1, Y － 1) ＝ #白色, 1, 0)
                        w ＝ 选择 (取位图颜色 (位图, X － 1, Y) ＝ #白色, 1, 0)
                        e ＝ 选择 (取位图颜色 (位图, X ＋ 1, Y) ＝ #白色, 1, 0)
                        sw ＝ 选择 (取位图颜色 (位图, X － 1, Y ＋ 1) ＝ #白色, 1, 0)
                        se ＝ 选择 (取位图颜色 (位图, X ＋ 1, Y ＋ 1) ＝ #白色, 1, 0)
                        num ＝ nw ＋ n × 2 ＋ ne × 4 ＋ w × 8 ＋ e × 16 ＋ sw × 32 ＋ s × 64 ＋ se × 128
                        .如果真 (表 [num ＋ 1] ＝ 1)
                            位图 ＝ 置位图颜色 (位图, X, Y, #白色)
                            Finished ＝ 假
                            Y ＝ Y ＋ 1
                        .如果真结束
                        
                    .如果真结束
                    
                .如果真结束
                Y ＝ Y ＋ 1
            .判断循环尾 ()
            处理事件 ()
        .计次循环尾 ()
    .判断循环尾 ()
    返回 (位图)

.子程序 位图分割1, 整数型, 公开
    .参数 位图, 字节集
    .参数 范围数组, 精易_矩形, 参考 可空 数组
    .局部变量 w, 整数型
    .局部变量 h, 整数型
    .局部变量 x, 整数型
    .局部变量 y, 整数型
    .局部变量 i, 整数型
    .局部变量 rgb, 整数型
    .局部变量 范围, 精易_矩形
    .局部变量 有效, 逻辑型, , "2"

    w ＝ 取字节集数据 (取字节集中间 (位图, 19, 4), 3, )
    h ＝ 取字节集数据 (取字节集中间 (位图, 23, 4), 3, )
    清除数组 (范围数组)
    .计次循环首 (w, x)
        有效 [2] ＝ 假
        .计次循环首 (h, y)
            rgb ＝ 取位图颜色 (位图, x － 1, y － 1)
            .如果真 (rgb ≠ #白色)
                .如果 (有效 [1])
                    有效 [2] ＝ 真
                    范围.顶边 ＝ 选择 (y ＜ 范围.顶边 ＋ 1, y － 1, 范围.顶边)
                .否则
                    有效 [1] ＝ 真
                    有效 [2] ＝ 真
                    范围.左边 ＝ x － 1
                    范围.顶边 ＝ y － 1
                .如果结束
                跳出循环 ()
            .如果真结束
            
        .计次循环尾 ()
        .如果真 (有效 [1])
            .如果真 (有效 [2] ＝ 假)
                有效 [1] ＝ 假
                范围.右边 ＝ x － 范围.左边
                范围.底边 ＝ h － 范围.顶边
                .计次循环首 (范围.底边, y)
                    .计次循环首 (范围.右边, i)
                        rgb ＝ 取位图颜色 (位图, 范围.左边 ＋ i － 2, h － y)
                        .如果真 (rgb ≠ #白色)
                            跳出循环 ()
                        .如果真结束
                        
                    .计次循环尾 ()
                    .如果真 (范围.右边 ＋ 1 ≠ i)
                        跳出循环 ()
                    .如果真结束
                    
                .计次循环尾 ()
                范围.底边 ＝ 范围.底边 ＋ 1 － y
                加入成员 (范围数组, 范围)
            .如果真结束
            
        .如果真结束
        处理事件 ()
    .计次循环尾 ()
    返回 (取数组成员数 (范围数组))

.子程序 位图分割2, 整数型, 公开
    .参数 位图, 字节集
    .参数 点阵数组, 点阵, 参考 可空 数组
    .局部变量 w, 整数型
    .局部变量 h, 整数型
    .局部变量 x, 整数型
    .局部变量 y, 整数型
    .局部变量 i, 整数型
    .局部变量 rgb, 整数型
    .局部变量 颜色表, 整数型, , "0"

    w ＝ 取字节集数据 (取字节集中间 (位图, 19, 4), 3, )
    h ＝ 取字节集数据 (取字节集中间 (位图, 23, 4), 3, )
    清除数组 (点阵数组)
    取位图颜色表 (位图, 颜色表)
    .计次循环首 (w, x)
        .计次循环首 (h, y)
            rgb ＝ 颜色表 [x] [y]
            .如果真 (rgb ≠ #白色)
                加入成员 (点阵数组, 枚举连续点 (颜色表, x, y))
            .如果真结束
            
        .计次循环尾 ()
        处理事件 ()
    .计次循环尾 ()
    返回 (取数组成员数 (点阵数组))

.子程序 取位图有效范围, 精易_矩形, 公开
    .参数 位图, 字节集
    .局部变量 w, 整数型
    .局部变量 h, 整数型
    .局部变量 x, 整数型
    .局部变量 y, 整数型
    .局部变量 有效范围, 精易_矩形
    .局部变量 是否有效, 整数型, , "2,3"

    w ＝ 取字节集数据 (取字节集中间 (位图, 19, 4), 3, )
    h ＝ 取字节集数据 (取字节集中间 (位图, 23, 4), 3, )
    .计次循环首 (w, x)
        是否有效 [1] [2] ＝ 0
        是否有效 [2] [2] ＝ 0
        是否有效 [1] [3] ＝ 是否有效 [1] [1]
        是否有效 [2] [3] ＝ 是否有效 [2] [1]
        .计次循环首 (h, y)
            .如果真 (是否有效 [1] [2] ＝ 0 且 有效范围.左边 ＝ 0)
                .如果真 (取位图颜色 (位图, x － 1, y － 1) ＝ #黑色)
                    是否有效 [1] [1] ＝ 是否有效 [1] [1] ＋ 1
                    是否有效 [1] [2] ＝ 1
                .如果真结束
                
            .如果真结束
            .如果真 (是否有效 [2] [2] ＝ 0 且 有效范围.右边 ＝ 0)
                .如果真 (取位图颜色 (位图, w － x, h － y) ＝ #黑色)
                    是否有效 [2] [1] ＝ 是否有效 [2] [1] ＋ 1
                    是否有效 [2] [2] ＝ 1
                .如果真结束
                
            .如果真结束
            
        .计次循环尾 ()
        是否有效 [1] [1] ＝ 选择 (是否有效 [1] [3] ＝ 是否有效 [1] [1], 0, 是否有效 [1] [1])
        是否有效 [2] [1] ＝ 选择 (是否有效 [2] [3] ＝ 是否有效 [2] [1], 0, 是否有效 [2] [1])
        .如果真 (是否有效 [1] [1] ＝ 2 且 有效范围.左边 ＝ 0)
            有效范围.左边 ＝ x － 2
        .如果真结束
        .如果真 (是否有效 [2] [1] ＝ 2 且 有效范围.右边 ＝ 0)
            有效范围.右边 ＝ x － 2
        .如果真结束
        处理事件 ()
    .计次循环尾 ()
    w ＝ w － 有效范围.左边 － 有效范围.右边
    数组清零 (是否有效)
    .计次循环首 (h, y)
        是否有效 [1] [2] ＝ 0
        是否有效 [2] [2] ＝ 0
        是否有效 [1] [3] ＝ 是否有效 [1] [1]
        是否有效 [2] [3] ＝ 是否有效 [2] [1]
        .计次循环首 (w, x)
            .如果真 (是否有效 [1] [2] ＝ 0 且 有效范围.顶边 ＝ 0)
                .如果真 (取位图颜色 (位图, 有效范围.左边 ＋ x － 1, y － 1) ＝ #黑色)
                    是否有效 [1] [1] ＝ 是否有效 [1] [1] ＋ 1
                    是否有效 [1] [2] ＝ 1
                .如果真结束
                
            .如果真结束
            .如果真 (是否有效 [2] [2] ＝ 0 且 有效范围.底边 ＝ 0)
                .如果真 (取位图颜色 (位图, 有效范围.左边 ＋ w － x, h － y) ＝ #黑色)
                    是否有效 [2] [1] ＝ 是否有效 [2] [1] ＋ 1
                    是否有效 [2] [2] ＝ 1
                .如果真结束
                
            .如果真结束
            
            
        .计次循环尾 ()
        是否有效 [1] [1] ＝ 选择 (是否有效 [1] [3] ＝ 是否有效 [1] [1], 0, 是否有效 [1] [1])
        是否有效 [2] [1] ＝ 选择 (是否有效 [2] [3] ＝ 是否有效 [2] [1], 0, 是否有效 [2] [1])
        .如果真 (是否有效 [1] [1] ＝ 2 且 有效范围.顶边 ＝ 0)
            有效范围.顶边 ＝ y － 2
        .如果真结束
        .如果真 (是否有效 [2] [1] ＝ 2 且 有效范围.底边 ＝ 0)
            有效范围.底边 ＝ y － 2
        .如果真结束
        处理事件 ()
    .计次循环尾 ()
    有效范围.右边 ＝ w
    有效范围.底边 ＝ h － 有效范围.顶边 － 有效范围.底边
    返回 (有效范围)

.子程序 点是否孤立, 整数型, , 0表示孤立,1表示左边,2表示左上,4表示上,8表示右上,16表示右,32表示右下,64表示下,128表示左下
    .参数 位图, 字节集
    .参数 x, 整数型
    .参数 y, 整数型
    .局部变量 相关点, 整数型
    .局部变量 rgb, 整数型

    rgb ＝ 取位图颜色 (位图, x, y)
    .如果 (rgb ≠ #白色)
        rgb ＝ 取位图颜色 (位图, x － 1, y)
        .如果真 (rgb ≠ -1 且 rgb ≠ #白色)
            相关点 ＝ 相关点 ＋ 1
        .如果真结束
        rgb ＝ 取位图颜色 (位图, x － 1, y － 1)
        .如果真 (rgb ≠ -1 且 rgb ≠ #白色)
            相关点 ＝ 相关点 ＋ 2
        .如果真结束
        rgb ＝ 取位图颜色 (位图, x, y － 1)
        .如果真 (rgb ≠ -1 且 rgb ≠ #白色)
            相关点 ＝ 相关点 ＋ 4
        .如果真结束
        rgb ＝ 取位图颜色 (位图, x ＋ 1, y － 1)
        .如果真 (rgb ≠ -1 且 rgb ≠ #白色)
            相关点 ＝ 相关点 ＋ 8
        .如果真结束
        rgb ＝ 取位图颜色 (位图, x ＋ 1, y)
        .如果真 (rgb ≠ -1 且 rgb ≠ #白色)
            相关点 ＝ 相关点 ＋ 16
        .如果真结束
        rgb ＝ 取位图颜色 (位图, x ＋ 1, y ＋ 1)
        .如果真 (rgb ≠ -1 且 rgb ≠ #白色)
            相关点 ＝ 相关点 ＋ 32
        .如果真结束
        rgb ＝ 取位图颜色 (位图, x, y ＋ 1)
        .如果真 (rgb ≠ -1 且 rgb ≠ #白色)
            相关点 ＝ 相关点 ＋ 64
        .如果真结束
        rgb ＝ 取位图颜色 (位图, x － 1, y ＋ 1)
        .如果真 (rgb ≠ -1 且 rgb ≠ #白色)
            相关点 ＝ 相关点 ＋ 128
        .如果真结束
        
    .否则
        相关点 ＝ -1
    .如果结束
    返回 (相关点)

.子程序 枚举连续点, 点阵
    .参数 颜色表, 整数型, 参考 数组
    .参数 x, 整数型
    .参数 y, 整数型
    .局部变量 点阵, 点阵
    .局部变量 点组, 整数型, , "0"
    .局部变量 颜色组, 整数型, , "0"
    .局部变量 data, 字节集
    .局部变量 i, 整数型
    .局部变量 x0, 字节集
    .局部变量 y0, 字节集
    .局部变量 minx, 字节集
    .局部变量 maxx, 字节集
    .局部变量 miny, 字节集
    .局部变量 maxy, 字节集

    不重复加入点 (点组, 合并整数 (x, y))
    加入成员 (颜色组, 颜色表 [x] [y])
    子枚举 (颜色表, x, y, 点组, 颜色组)
    data ＝ 指针到字节集 (lstrcpynA_整数数组 (点组, 点组, 0), 取数组成员数 (点组) × 4)
    minx ＝ 取字节集左边 (data, 2)
    maxx ＝ minx
    miny ＝ 取字节集中间 (data, 3, 2)
    maxy ＝ miny
    .计次循环首 (取数组成员数 (点组), i)
        x0 ＝ 取字节集中间 (data, (i － 1) × 4 ＋ 1, 2)
        y0 ＝ 取字节集中间 (data, (i － 1) × 4 ＋ 3, 2)
        minx ＝ 比较字节数小 (minx, x0)
        maxx ＝ 比较字节数大 (maxx, x0)
        miny ＝ 比较字节数小 (miny, y0)
        maxy ＝ 比较字节数大 (maxy, y0)
    .计次循环尾 ()
    重定义数组 (点阵.点, 假, 取字节集数据 (maxx, 3, ) ＋ 1 － 取字节集数据 (minx, 3, ), 取字节集数据 (maxy, 3, ) ＋ 1 － 取字节集数据 (miny, 3, ))
    写到内存 (取重复字节集 (取数组成员数 (点阵.点) × 4, { 255, 255, 255, 0 }), lstrcpynA_整数数组 (点阵.点, 点阵.点, 0), 取数组成员数 (点阵.点) × 4)
    .计次循环首 (取数组成员数 (点组), i)
        x0 ＝ 取字节集中间 (data, (i － 1) × 4 ＋ 1, 2)
        y0 ＝ 取字节集中间 (data, (i － 1) × 4 ＋ 3, 2)
        x ＝ 取字节集数据 (x0, 3, ) ＋ 1 － 取字节集数据 (minx, 3, )
        y ＝ 取字节集数据 (y0, 3, ) ＋ 1 － 取字节集数据 (miny, 3, )
        点阵.点 [x] [y] ＝ 颜色组 [i]
    .计次循环尾 ()
    返回 (点阵)

.子程序 子枚举
    .参数 颜色表, 整数型, 参考 数组
    .参数 x, 整数型
    .参数 y, 整数型
    .参数 点组, 整数型, 参考 数组
    .参数 颜色组, 整数型, 参考 数组
    .局部变量 w, 整数型
    .局部变量 h, 整数型
    .局部变量 位图, 字节集
    .局部变量 孤立值, 整数型
    .局部变量 方位, 整数型, , "8,3"
    .局部变量 i, 整数型
    .局部变量 点x, 整数型
    .局部变量 点y, 整数型

    位图 ＝ 颜色表构建位图 (颜色表)
    孤立值 ＝ 点是否孤立 (位图, x － 1, y － 1)
    位图 ＝ { }
    颜色表 [x] [y] ＝ #白色
    写到内存 ({ 1, 0, 0, 0, 255, 255, 255, 255, 0, 0, 0, 0, 2, 0, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 4, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255, 8, 0, 0, 0, 1, 0, 0, 0, 255, 255, 255, 255, 16, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 32, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 128, 0, 0, 0, 255, 255, 255, 255, 1, 0, 0, 0 }, lstrcpynA_整数数组 (方位, 方位, 0), 96)
    w ＝ 取字节集数据 (指针到字节集 (lstrcpynA_整数数组 (颜色表, 颜色表, 0) － 8, 4), 3, )
    h ＝ 取字节集数据 (指针到字节集 (lstrcpynA_整数数组 (颜色表, 颜色表, 0) － 4, 4), 3, )
    .计次循环首 (8, i)
        .如果真 (位与 (孤立值, 方位 [i] [1]) ＝ 方位 [i] [1])
            点x ＝ x ＋ 方位 [i] [2]
            点y ＝ y ＋ 方位 [i] [3]
            .如果真 (点x ＜ 1 或 点y ＜ 1 或 点x ＞ w 或 点y ＞ h)
                到循环尾 ()
            .如果真结束
            .如果真 (不重复加入点 (点组, 合并整数 (点x, 点y)))
                加入成员 (颜色组, 颜色表 [点x] [点y])
                子枚举 (颜色表, 点x, 点y, 点组, 颜色组)
            .如果真结束
            
        .如果真结束
        处理事件 ()
    .计次循环尾 ()

.子程序 比较字节数大, 字节集, , 返回大数的字节
    .参数 数1, 字节集
    .参数 数2, 字节集
    .局部变量 i1, 整数型
    .局部变量 i2, 整数型
    .局部变量 n, 整数型

    i1 ＝ 取字节集长度 (数1)
    i2 ＝ 取字节集长度 (数2)
    .如果真 (i1 ≠ 4)
        数1 ＝ 数1 ＋ 取空白字节集 (4 － i1)
    .如果真结束
    .如果真 (i2 ≠ 4)
        数2 ＝ 数2 ＋ 取空白字节集 (4 － i2)
    .如果真结束
    .计次循环首 (4, n)
        .如果真 (数1 [5 － n] ≠ 数2 [5 － n])
            返回 (选择 (数1 [5 － n] ＞ 数2 [5 － n], 取字节集左边 (数1, i1), 取字节集左边 (数2, i2)))
        .如果真结束
        
    .计次循环尾 ()
    返回 (取字节集左边 (数1, i1))

.子程序 比较字节数小, 字节集, , 返回小数的字节
    .参数 数1, 字节集
    .参数 数2, 字节集
    .局部变量 i1, 整数型
    .局部变量 i2, 整数型
    .局部变量 n, 整数型

    i1 ＝ 取字节集长度 (数1)
    i2 ＝ 取字节集长度 (数2)
    .如果真 (i1 ≠ 4)
        数1 ＝ 数1 ＋ 取空白字节集 (4 － i1)
    .如果真结束
    .如果真 (i2 ≠ 4)
        数2 ＝ 数2 ＋ 取空白字节集 (4 － i2)
    .如果真结束
    .计次循环首 (4, n)
        .如果真 (数1 [5 － n] ≠ 数2 [5 － n])
            返回 (选择 (数1 [5 － n] ＜ 数2 [5 － n], 取字节集左边 (数1, i1), 取字节集左边 (数2, i2)))
        .如果真结束
        
    .计次循环尾 ()
    返回 (取字节集左边 (数1, i1))

.子程序 不重复加入点, 逻辑型
    .参数 点组, 整数型, 参考 数组
    .参数 点, 整数型, , 低16位X,高16位Y
    .局部变量 data, 字节集
    .局部变量 i, 整数型

    data ＝ 指针到字节集 (lstrcpynA_整数数组 (点组, 点组, 0), 取数组成员数 (点组) × 4)
    .循环判断首 ()
        i ＝ i ＋ 1
        i ＝ 寻找字节集 (data, 到字节集 (点), i)
        .如果真 (i ＝ -1)
            加入成员 (点组, 点)
            返回 (真)
        .如果真结束
        处理事件 ()
    .循环判断尾 (到整数 ((i － 1) ÷ 4) ≠ (i － 1) ÷ 4)
    返回 (假)

.版本 2

.程序集 类_位图操作, , 公开, 此类由坛友提供
.程序集变量 颜色表_1位深, 字节集, , , 2色biBitCount=1
.程序集变量 颜色表_4位深, 字节集, , , 16色biBitCount=4
.程序集变量 颜色表_8位深, 字节集, , , 256色biBitCount=8
.程序集变量 屏幕设备句柄, 整数型
.程序集变量 场景句柄, 整数型
.程序集变量 位图句柄, 整数型
.程序集变量 旧位图句柄, 整数型
.程序集变量 位图数据, 字节集, , , 位图数据
.程序集变量 位图指针, 整数型
.程序集变量 场景被更新, 逻辑型

.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
    初始化颜色表 ()
    屏幕设备句柄 ＝ GetDC (0)

.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
    SelectObject (场景句柄, 旧位图句柄)
    DeleteObject (位图句柄)
    DeleteDC (场景句柄)
    ReleaseDC (0, 屏幕设备句柄)

.子程序 释放旧位图
    .如果真 (位图数据 ＝ { } 且 位图句柄 ＝ 0)
        返回 ()
    .如果真结束
    SelectObject (场景句柄, 旧位图句柄)
    DeleteObject (位图句柄)
    DeleteDC (场景句柄)
    ReleaseDC (0, 屏幕设备句柄)
    连续赋值 (0, 位图句柄, 位图指针, 场景句柄, 旧位图句柄)
    位图数据 ＝ { }
    屏幕设备句柄 ＝ GetDC (0)
    场景被更新 ＝ 假

.子程序 初始化颜色表
    颜色表_1位深 ＝ { }
    颜色表_1位深 ＝ 颜色表_1位深 ＋ { 0, 0, 0, 0 }
    颜色表_1位深 ＝ 颜色表_1位深 ＋ { 255, 255, 255, 0 }
    颜色表_4位深 ＝ { }
    颜色表_4位深 ＝ 颜色表_4位深 ＋ { 0, 0, 0, 0 }
    颜色表_4位深 ＝ 颜色表_4位深 ＋ { 0, 0, 128, 0 }
    颜色表_4位深 ＝ 颜色表_4位深 ＋ { 0, 128, 0, 0 }
    颜色表_4位深 ＝ 颜色表_4位深 ＋ { 0, 128, 128, 0 }
    颜色表_4位深 ＝ 颜色表_4位深 ＋ { 128, 0, 0, 0 }
    颜色表_4位深 ＝ 颜色表_4位深 ＋ { 128, 0, 128, 0 }
    颜色表_4位深 ＝ 颜色表_4位深 ＋ { 128, 128, 0, 0 }
    颜色表_4位深 ＝ 颜色表_4位深 ＋ { 128, 128, 128, 0 }
    颜色表_4位深 ＝ 颜色表_4位深 ＋ { 192, 192, 192, 0 }
    颜色表_4位深 ＝ 颜色表_4位深 ＋ { 0, 0, 255, 0 }
    颜色表_4位深 ＝ 颜色表_4位深 ＋ { 0, 255, 0, 0 }
    颜色表_4位深 ＝ 颜色表_4位深 ＋ { 0, 255, 255, 0 }
    颜色表_4位深 ＝ 颜色表_4位深 ＋ { 255, 0, 0, 0 }
    颜色表_4位深 ＝ 颜色表_4位深 ＋ { 255, 0, 255, 0 }
    颜色表_4位深 ＝ 颜色表_4位深 ＋ { 255, 255, 0, 0 }
    颜色表_4位深 ＝ 颜色表_4位深 ＋ { 255, 255, 255, 0 }
    颜色表_8位深 ＝ { }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 0, 0, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 0, 128, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 128, 0, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 128, 128, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 0, 0, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 0, 128, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 128, 0, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 192, 192, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 220, 192, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 240, 202, 166, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 32, 64, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 32, 96, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 32, 128, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 32, 160, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 32, 192, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 32, 224, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 64, 0, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 64, 32, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 64, 64, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 64, 96, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 64, 128, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 64, 160, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 64, 192, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 64, 224, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 96, 0, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 96, 32, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 96, 64, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 96, 96, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 96, 128, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 96, 160, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 96, 192, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 96, 224, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 128, 0, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 128, 32, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 128, 64, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 128, 96, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 128, 128, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 128, 160, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 128, 192, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 128, 224, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 160, 0, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 160, 32, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 160, 64, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 160, 96, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 160, 128, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 160, 160, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 160, 192, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 160, 224, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 192, 0, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 192, 32, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 192, 64, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 192, 96, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 192, 128, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 192, 160, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 192, 192, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 192, 224, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 224, 0, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 224, 32, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 224, 64, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 224, 96, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 224, 128, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 224, 160, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 224, 192, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 224, 224, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 0, 0, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 0, 32, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 0, 64, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 0, 96, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 0, 128, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 0, 160, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 0, 192, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 0, 224, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 32, 0, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 32, 32, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 32, 64, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 32, 96, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 32, 128, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 32, 160, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 32, 192, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 32, 224, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 64, 0, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 64, 32, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 64, 64, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 64, 96, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 64, 128, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 64, 160, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 64, 192, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 64, 224, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 96, 0, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 96, 32, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 96, 64, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 96, 96, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 96, 128, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 96, 160, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 96, 192, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 96, 224, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 128, 0, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 128, 32, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 128, 64, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 128, 96, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 128, 128, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 128, 160, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 128, 192, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 128, 224, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 160, 0, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 160, 32, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 160, 64, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 160, 96, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 160, 128, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 160, 160, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 160, 192, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 160, 224, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 192, 0, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 192, 32, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 192, 64, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 192, 96, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 192, 128, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 192, 160, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 192, 192, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 192, 224, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 224, 0, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 224, 32, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 224, 64, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 224, 96, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 224, 128, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 224, 160, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 224, 192, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 64, 224, 224, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 0, 0, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 0, 32, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 0, 64, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 0, 96, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 0, 128, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 0, 160, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 0, 192, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 0, 224, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 32, 0, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 32, 32, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 32, 64, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 32, 96, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 32, 128, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 32, 160, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 32, 192, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 32, 224, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 64, 0, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 64, 32, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 64, 64, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 64, 96, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 64, 128, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 64, 160, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 64, 192, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 64, 224, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 96, 0, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 96, 32, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 96, 64, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 96, 96, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 96, 128, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 96, 160, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 96, 192, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 96, 224, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 128, 0, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 128, 32, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 128, 64, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 128, 96, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 128, 128, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 128, 160, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 128, 192, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 128, 224, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 160, 0, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 160, 32, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 160, 64, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 160, 96, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 160, 128, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 160, 160, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 160, 192, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 160, 224, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 192, 0, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 192, 32, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 192, 64, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 192, 96, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 192, 128, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 192, 160, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 192, 192, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 192, 224, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 224, 0, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 224, 32, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 224, 64, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 224, 96, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 224, 128, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 224, 160, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 224, 192, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 224, 224, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 0, 0, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 0, 32, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 0, 64, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 0, 96, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 0, 128, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 0, 160, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 0, 192, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 0, 224, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 32, 0, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 32, 32, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 32, 64, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 32, 96, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 32, 128, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 32, 160, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 32, 192, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 32, 224, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 64, 0, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 64, 32, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 64, 64, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 64, 96, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 64, 128, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 64, 160, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 64, 192, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 64, 224, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 96, 0, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 96, 32, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 96, 64, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 96, 96, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 96, 128, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 96, 160, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 96, 192, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 96, 224, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 128, 0, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 128, 32, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 128, 64, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 128, 96, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 128, 128, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 128, 160, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 128, 192, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 128, 224, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 160, 0, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 160, 32, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 160, 64, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 160, 96, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 160, 128, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 160, 160, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 160, 192, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 160, 224, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 192, 0, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 192, 32, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 192, 64, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 192, 96, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 192, 128, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 192, 192, 160, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 240, 251, 255, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 164, 160, 160, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 128, 128, 128, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 0, 255, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 255, 0, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 0, 255, 255, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 255, 0, 0, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 255, 0, 255, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 255, 255, 0, 0 }
    颜色表_8位深 ＝ 颜色表_8位深 ＋ { 255, 255, 255, 0 }

.子程序 从数据创建, 逻辑型, 公开, 从位图字节集载入位图数据创建位图(成功返回真,失败返回假,本类原有位图将自动被释放)
    .参数 位图文件数据, 字节集
    .局部变量 a, 逻辑型

    写到文件 (目录_取特定目录 (11) ＋ “新位图操作类_载入位图.bmp”, 位图文件数据)
    a ＝ 从文件创建 (目录_取特定目录 (11) ＋ “新位图操作类_载入位图.bmp”)
    删除文件 (目录_取特定目录 (11) ＋ “新位图操作类_载入位图.bmp”)
    返回 (a)

.子程序 从数据创建2, 逻辑型, 公开
    .参数 位图文件数据, 字节集
    .局部变量 宽, 整数型
    .局部变量 高, 整数型
    .局部变量 位深度, 整数型

    释放旧位图 ()
    .如果真 (取字节集长度 (位图文件数据) ＜ 55)
        返回 (假)
    .如果真结束
    宽 ＝ 取字节集数据 (位图文件数据, 3, 19)
    高 ＝ 取字节集数据 (位图文件数据, 3, 23)
    位深度 ＝ 取字节集数据 (位图文件数据, 2, 29)
    .如果真 (宽 ＜ 1 或 高 ＜ 1)
        返回 (假)
    .如果真结束
    场景句柄 ＝ CreateCompatibleDC (屏幕设备句柄)
    位图数据 ＝ 取字节集右边 (位图文件数据, 取字节集长度 (位图文件数据) － 14)
    位图句柄 ＝ CreateDIBSection1 (屏幕设备句柄, 位图数据, 0, 位图指针, 0, 0)
    RtlMoveMemory (位图指针, 取颜色点阵地址 (), 取颜色点阵大小 ())
    旧位图句柄 ＝ SelectObject (场景句柄, 位图句柄)
    返回 (真)

.子程序 从文件创建, 逻辑型, 公开, 从bmp文件载入位图数据创建位图(成功返回真,失败返回假,本类原有位图将自动被释放)
    .参数 文件名, 文本型, , 位图文件路径
    .局部变量 位图句柄1, 整数型
    .局部变量 a, 逻辑型

    位图句柄1 ＝ LoadImage (0, 文件名, 0, 0, 0, 16)
    a ＝ 从位图句柄创建 (位图句柄1)
    DeleteObject (位图句柄1)
    返回 (a)

.子程序 从位图句柄创建, 逻辑型, 公开, 通过已有的位图句柄创建新的位图存于本类中(成功返回真,失败返回假,本类原有位图将自动被释放)
    .参数 已知的位图句柄, 整数型, , 已经获得的位图句柄,该句柄需另外删除!
    .参数 位深度, 整数型, 可空, 位深度:  1, 4, 8, 16, 24, 32  默认为原来的位深度
    .局部变量 位图, BITMAP
    .局部变量 场景句柄1, 整数型
    .局部变量 旧位图句柄1, 整数型

    释放旧位图 ()
    .如果真 (GetObjectA (已知的位图句柄, 5 × 4 ＋ 2 ＋ 2, 位图) ＝ 0)
        返回 (假)
    .如果真结束
    场景句柄1 ＝ CreateCompatibleDC (屏幕设备句柄)
    旧位图句柄1 ＝ SelectObject (场景句柄1, 已知的位图句柄)
    创建空位图 (位图.bmWidth, 位图.bmHeight, 选择 (位深度 ＝ 0, 位图.bmBitsPixel, 位深度), )
    场景句柄 ＝ CreateCompatibleDC (屏幕设备句柄)
    位图句柄 ＝ CreateDIBSection1 (屏幕设备句柄, 位图数据, 0, 位图指针, 0, 0)
    旧位图句柄 ＝ SelectObject (场景句柄, 位图句柄)
    BitBlt (场景句柄, 0, 0, 位图.bmWidth, 位图.bmHeight, 场景句柄1, 0, 0, #SRCCOPY)
    GdiFlush ()
    RtlMoveMemory (取颜色点阵地址 (), 位图指针, 取颜色点阵大小 ())
    SelectObject (场景句柄1, 旧位图句柄1)
    ' 删除对象_ (已知位图句柄)
    DeleteDC (场景句柄1)
    返回 (真)
    

.子程序 从图标句柄创建, 逻辑型, 公开, 通过文件图标句柄创建图标位图(成功返回真,失败返回假,本类原有位图将自动被释放)
    .参数 图标句柄, 整数型, , 文件图标句柄
    .参数 图标宽度, 整数型, 可空, 默认为32
    .参数 图标高度, 整数型, 可空, 默认为32
    .参数 位深度, 整数型, 可空, 位深度:  1, 4, 8, 16, 24, 32  默认为32位
    .局部变量 矩形, 精易_矩形
    .局部变量 场景句柄1, 整数型
    .局部变量 位图句柄1, 整数型
    .局部变量 旧位图句柄1, 整数型
    .局部变量 mBrush, 整数型

    .如果真 (是否为空 (图标宽度))
        图标宽度 ＝ 32
    .如果真结束
    .如果真 (是否为空 (图标高度))
        图标高度 ＝ 32
    .如果真结束
    .如果真 (是否为空 (位深度))
        位深度 ＝ 32
    .如果真结束
    矩形.右边 ＝ 图标宽度
    矩形.底边 ＝ 图标高度
    场景句柄1 ＝ CreateCompatibleDC (屏幕设备句柄)
    位图句柄1 ＝ CreateCompatibleBitmap (屏幕设备句柄, 图标宽度, 图标高度)
    旧位图句柄1 ＝ SelectObject (场景句柄1, 位图句柄1)
    mBrush ＝ CreateSolidBrush (#白色)
    FillRect (场景句柄1, 矩形, mBrush)
    DrawIconEx (场景句柄1, 0, 0, 图标句柄, 图标宽度, 图标高度, 0, 0, 3)
    从场景创建 (场景句柄1, 矩形, 位深度)
    DeleteDC (场景句柄1)
    DeleteObject (旧位图句柄1)
    DeleteObject (位图句柄1)
    DeleteObject (mBrush)
    返回 (位图句柄 ≠ 0)

.子程序 从屏幕创建, 逻辑型, 公开, 从屏幕创建位图,抓取屏幕画面(成功返回真,失败返回假,本类原有位图将自动被释放)
    .参数 左边, 整数型, 可空, 抓取的屏幕区域左边  默认为0
    .参数 顶边, 整数型, 可空, 抓取的屏幕区域顶边  默认为0
    .参数 宽度, 整数型, 可空, 创建位图的宽度  默认为屏幕宽度-左边
    .参数 高度, 整数型, 可空, 创建位图的高度  默认为屏幕高度-顶边
    .参数 位深度, 整数型, 可空, 位深度:  1, 4, 8, 16, 24, 32  默认为当前屏幕色深
    .局部变量 场景句柄1, 整数型
    .局部变量 位图句柄1, 整数型
    .局部变量 旧位图句柄1, 整数型
    .局部变量 局部_位图信息, 位图信息_
    .局部变量 DEVMODE, 短整数型, , "61"

    释放旧位图 ()
    EnumDisplaySettingsA (0, -1, DEVMODE [1])
    .如果真 (位深度 ＝ 0)
        位深度 ＝ DEVMODE [53]
    .如果真结束
    .如果真 (位深度 ≠ 1 且 位深度 ≠ 4 且 位深度 ≠ 8 且 位深度 ≠ 16 且 位深度 ≠ 24 且 位深度 ≠ 32)
        返回 (假)
    .如果真结束
    .如果真 (宽度 ＝ 0)
        宽度 ＝ DEVMODE [55] － 左边
    .如果真结束
    .如果真 (高度 ＝ 0)
        高度 ＝ DEVMODE [57] － 顶边
    .如果真结束
    局部_位图信息.位深度 ＝ 位深度
    局部_位图信息.压缩率 ＝ 0
    局部_位图信息.位图位面数 ＝ 1
    局部_位图信息.结果大小 ＝ 40
    局部_位图信息.位图宽度 ＝ 宽度
    局部_位图信息.位图高度 ＝ 高度
    场景句柄1 ＝ CreateCompatibleDC (屏幕设备句柄)
    位图句柄1 ＝ CreateDIBSection (场景句柄1, 局部_位图信息, 0, 0, 0, 0)
    旧位图句柄1 ＝ SelectObject (场景句柄1, 位图句柄1)
    创建空位图 (局部_位图信息.位图宽度, 局部_位图信息.位图高度, 局部_位图信息.位深度, )
    场景句柄 ＝ CreateCompatibleDC (屏幕设备句柄)
    位图句柄 ＝ CreateDIBSection1 (屏幕设备句柄, 位图数据, 0, 位图指针, 0, 0)
    旧位图句柄 ＝ SelectObject (场景句柄, 位图句柄)
    BitBlt (场景句柄, 0, 0, 局部_位图信息.位图宽度, 局部_位图信息.位图高度, 屏幕设备句柄, 左边, 顶边, #SRCCOPY)
    GdiFlush ()
    RtlMoveMemory (取颜色点阵地址 (), 位图指针, 取颜色点阵大小 ())
    SelectObject (场景句柄1, 旧位图句柄1)
    DeleteObject (位图句柄1)
    DeleteDC (场景句柄1)
    返回 (真)

.子程序 从窗口创建, 逻辑型, 公开, 从窗口创建位图,获取窗口客户区画面(成功返回真,失败返回假,本类原有位图将自动被释放)
    .参数 窗口句柄, 整数型, , 欲获取窗口位图的窗口句柄,必须保证窗口可视性,且不能是最小化窗口
    .参数 左边, 整数型, 可空, 抓取的窗口客户区域左边  默认为0
    .参数 顶边, 整数型, 可空, 抓取的窗口客户区域顶边  默认为0
    .参数 宽度, 整数型, 可空, 创建位图的宽度  默认为窗口客户区域的宽度-左边
    .参数 高度, 整数型, 可空, 创建位图的高度  默认为窗口客户区域的高度-顶边
    .参数 位深度, 整数型, 可空, 位深度:  1, 4, 8, 16, 24, 32  默认为24位
    .局部变量 矩形区域, 精易_矩形
    .局部变量 窗口大小, 精易_矩形
    .局部变量 窗口位置, 精易_坐标
    .局部变量 场景句柄1, 整数型
    .局部变量 位图句柄1, 整数型
    .局部变量 旧位图句柄1, 整数型

    释放旧位图 ()
    .如果真 (IsIconic (窗口句柄))
        返回 (假)
    .如果真结束
    .如果真 (IsWindowVisible (窗口句柄) ＝ 假)
        返回 (假)
    .如果真结束
    .如果真 (位深度 ＝ 0)
        位深度 ＝ 24
    .如果真结束
    .如果真 (位深度 ≠ 1 且 位深度 ≠ 4 且 位深度 ≠ 8 且 位深度 ≠ 16 且 位深度 ≠ 24 且 位深度 ≠ 32)
        返回 (假)
    .如果真结束
    GetWindowRect (窗口句柄, 矩形区域)
    场景句柄1 ＝ CreateCompatibleDC (屏幕设备句柄)
    位图句柄1 ＝ CreateCompatibleBitmap (屏幕设备句柄, 矩形区域.右边 － 矩形区域.左边, 矩形区域.底边 － 矩形区域.顶边)
    旧位图句柄1 ＝ SelectObject (场景句柄1, 位图句柄1)
    .如果真 (取反 (PrintWindow (窗口句柄, 场景句柄1, 0)))
        SelectObject (场景句柄1, 旧位图句柄1)
        DeleteObject (位图句柄1)
        DeleteDC (场景句柄1)
        返回 (假)
    .如果真结束
    GetClientRect (窗口句柄, 窗口大小)
    .如果真 (宽度 ＝ 0)
        宽度 ＝ 窗口大小.右边 － 左边
    .如果真结束
    .如果真 (高度 ＝ 0)
        高度 ＝ 窗口大小.底边 － 顶边
    .如果真结束
    ClientToScreen (窗口句柄, 窗口位置)
    场景句柄 ＝ CreateCompatibleDC (屏幕设备句柄)
    创建空位图 (宽度, 高度, 位深度, )
    位图句柄 ＝ CreateDIBSection1 (屏幕设备句柄, 位图数据, 0, 位图指针, 0, 0)
    旧位图句柄 ＝ SelectObject (场景句柄, 位图句柄)
    BitBlt (场景句柄, 0, 0, 宽度, 高度, 场景句柄1, 窗口位置.横 － 矩形区域.左边 ＋ 左边, 窗口位置.纵 － 矩形区域.顶边 ＋ 顶边, 13369376)
    SelectObject (场景句柄1, 旧位图句柄1)
    DeleteObject (位图句柄1)
    DeleteDC (场景句柄1)
    GdiFlush ()
    RtlMoveMemory (取颜色点阵地址 (), 位图指针, 取颜色点阵大小 ())
    返回 (真)

.子程序 从场景创建, 逻辑型, 公开, 从DC场景创建位图,复制DC上的内容到DIB获取场景中画面(成功返回真,失败返回假,本类原有位图将自动被释放)
    .参数 DC场景句柄, 整数型, , 已经的DC场景
    .参数 区域, 精易_矩形, , 欲获取场景的区域范围
    .参数 位深度, 整数型, , 位深度:  1, 4, 8, 16, 24, 32
    .局部变量 位图宽度, 整数型
    .局部变量 位图高度, 整数型

    释放旧位图 ()
    .如果真 (位深度 ≠ 1 且 位深度 ≠ 4 且 位深度 ≠ 8 且 位深度 ≠ 16 且 位深度 ≠ 24 且 位深度 ≠ 32)
        返回 (假)
    .如果真结束
    位图宽度 ＝ 区域.右边 － 区域.左边
    位图高度 ＝ 区域.底边 － 区域.顶边
    创建空位图 (位图宽度, 位图高度, 位深度, )
    场景句柄 ＝ CreateCompatibleDC (DC场景句柄)
    位图句柄 ＝ CreateDIBSection1 (DC场景句柄, 位图数据, 0, 位图指针, 0, 0)
    旧位图句柄 ＝ SelectObject (场景句柄, 位图句柄)
    BitBlt (场景句柄, 0, 0, 位图宽度, 位图高度, DC场景句柄, 区域.左边, 区域.顶边, #SRCCOPY)
    GdiFlush ()
    RtlMoveMemory (取颜色点阵地址 (), 位图指针, 取颜色点阵大小 ())
    返回 (真)

.子程序 从资料创建, , , 通过现有内存创建的位图信息资料移植到本类,必须保证资料的准确性(本命令为高级成员命令,本类原有位图将自动被释放)
    .参数 资料_位图句柄, 整数型
    .参数 资料_场景句柄, 整数型
    .参数 资料_位图数据, 字节集, , 位图颜色数据

    释放旧位图 ()
    位图句柄 ＝ 资料_位图句柄
    场景句柄 ＝ 资料_场景句柄
    位图数据 ＝ 资料_位图数据
    场景句柄 ＝ CreateCompatibleDC (屏幕设备句柄)
    旧位图句柄 ＝ SelectObject (场景句柄, 位图句柄)

.子程序 从剪辑板创建, 逻辑型, 公开, 取得剪辑板中位图(成功返回真,剪辑板中没有位图或失败返回假,本类原有位图将自动被释放)
    .参数 位深度, 整数型, 可空, 位深度:  1, 4, 8, 16, 24, 32  默认为系统色深
    .局部变量 位图句柄1, 整数型
    .局部变量 a, 逻辑型

    释放旧位图 ()
    OpenClipboard (0)
    位图句柄1 ＝ GetClipboardData (2)
    CloseClipboard ()
    a ＝ 从位图句柄创建 (位图句柄1, 位深度)
    DeleteObject (位图句柄1)
    返回 (a)

.子程序 创建空白位图, 逻辑型, 公开, 创建一幅指定大小与位深度的空白位图(成功返回真,失败返回假,本类原有位图将自动被释放)
    .参数 宽度, 整数型
    .参数 高度, 整数型
    .参数 位深度, 整数型, , 位深度:  1, 4, 8, 16, 24, 32

    释放旧位图 ()
    创建空位图 (宽度, 高度, 位深度)
    场景句柄 ＝ CreateCompatibleDC (屏幕设备句柄)
    位图句柄 ＝ CreateDIBSection1 (屏幕设备句柄, 位图数据, 0, 位图指针, 0, 0)
    旧位图句柄 ＝ SelectObject (场景句柄, 位图句柄)
    GdiFlush ()
    RtlMoveMemory (取颜色点阵地址 (), 位图指针, 取颜色点阵大小 ())
    返回 (真)

.子程序 更新位图, , 公开, 强制立即更新位图中所作的操作(通常不使用)
    .如果真 (位图数据 ＝ { })
        返回 ()
    .如果真结束
    RtlMoveMemory (取颜色点阵地址 (), 位图指针, 取颜色点阵大小 ())

.子程序 创建空位图, 逻辑型
    .参数 宽度, 整数型
    .参数 高度, 整数型
    .参数 位深度, 整数型
    .参数 填充的颜色, 长整数型, 可空, 默认填充的颜色,4294967295
    .局部变量 iColors, 整数型
    .局部变量 iSize, 整数型
    .局部变量 pBI, BITMAPINFOHEADER

    ' .如果真 (是否为空 (填充的颜色))
        ' 填充的颜色 ＝ 4294967295
    ' .如果真结束
    .如果 (位深度 ＝ 1)
        iColors ＝ 2
    .否则
        .如果 (位深度 ＝ 4)
            iColors ＝ 16
        .否则
            .如果 (位深度 ＝ 8)
                iColors ＝ 256
            .否则
                .如果 (位深度 ＝ 16 或 位深度 ＝ 24 或 位深度 ＝ 32)
                    iColors ＝ 0
                .否则
                    返回 (假)
                .如果结束
                
            .如果结束
            
        .如果结束
        
    .如果结束
    iSize ＝ iColors × 4 ＋ 扫描行对齐 (宽度 × 位深度) × 高度
    位图数据 ＝ 取空白字节集 (iSize) ' 分配空间
    ' 填写BMP文件头
    pBI.biSize ＝ 40
    pBI.biWidth ＝ 宽度
    pBI.biHeight ＝ 高度
    pBI.biPlanes ＝ 1
    pBI.biBitCount ＝ 位深度
    位图数据 ＝ 位图信息头转字节集 (pBI) ＋ 位图数据
    ' 初始化颜色表
    .判断开始 (位深度 ＝ 1)
        RtlMoveMemory (取颜色表指针 (), lstrcpyn_字节集 (颜色表_1位深, 颜色表_1位深, 0), 取颜色表大小 ())
    .判断 (位深度 ＝ 4)
        RtlMoveMemory (取颜色表指针 (), lstrcpyn_字节集 (颜色表_4位深, 颜色表_4位深, 0), 取颜色表大小 ())
    .默认
        .如果真 (位深度 ＝ 8)
            RtlMoveMemory (取颜色表指针 (), lstrcpyn_字节集 (颜色表_8位深, 颜色表_8位深, 0), 取颜色表大小 ())
        .如果真结束
        
    .判断结束
    返回 (真)

.子程序 转换位深度, 逻辑型, 公开, 转换当前类中位图的位深度(成功返回真,失败返回假)
    .参数 新的位深度, 整数型, , 位深度:  1, 4, 8, 16, 24, 32
    .局部变量 位图, BITMAP
    .局部变量 场景句柄1, 整数型
    .局部变量 位图句柄1, 整数型
    .局部变量 旧位图句柄1, 整数型

    .如果真 (GetObjectA (位图句柄, 5 × 4 ＋ 2 ＋ 2, 位图) ＝ 0)
        返回 (假)
    .如果真结束
    场景句柄1 ＝ 场景句柄
    位图句柄1 ＝ 位图句柄
    旧位图句柄1 ＝ 旧位图句柄
    位图数据 ＝ { }
    创建空位图 (位图.bmWidth, 位图.bmHeight, 新的位深度, )
    场景句柄 ＝ CreateCompatibleDC (屏幕设备句柄)
    位图句柄 ＝ CreateDIBSection1 (屏幕设备句柄, 位图数据, 0, 位图指针, 0, 0)
    旧位图句柄 ＝ SelectObject (场景句柄, 位图句柄)
    BitBlt (场景句柄, 0, 0, 位图.bmWidth, 位图.bmHeight, 场景句柄1, 0, 0, #SRCCOPY)
    GdiFlush ()
    RtlMoveMemory (取颜色点阵地址 (), 位图指针, 取颜色点阵大小 ())
    SelectObject (场景句柄1, 旧位图句柄1)
    DeleteObject (位图句柄1)
    DeleteDC (场景句柄1)
    返回 (真)

.子程序 复制到, 逻辑型, 公开, 将当前类中位图复制到目标位图类中(成功返回真,失败返回假)
    .参数 目标位图, 类_位图操作, 参考, 复制到的目标位图
    .参数 左边, 整数型, 可空, 复制源位图区域的左边 默认为0
    .参数 顶边, 整数型, 可空, 复制源位图区域的顶边 默认为0
    .参数 宽度, 整数型, 可空, 复制源位图的宽度 默认为源位图最大有效宽度
    .参数 高度, 整数型, 可空, 复制源位图的高度 默认为源位图最大有效高度
    .参数 目标左边, 整数型, 可空, 复制到目标位图的横坐标 默认为0
    .参数 目标顶边, 整数型, 可空, 复制到目标位图的纵坐标 默认为0
    .局部变量 位图, BITMAP

    .如果真 (GetObjectA (位图句柄, 5 × 4 ＋ 2 ＋ 2, 位图) ＝ 0)
        返回 (假)
    .如果真结束
    .如果真 (是否为空 (宽度))
        宽度 ＝ 位图.bmWidth
    .如果真结束
    .如果真 (是否为空 (高度))
        高度 ＝ 位图.bmHeight
    .如果真结束
    ' 目标位图.创建空白位图 (宽度 ＋ 目标左边, 高度 ＋ 目标顶边, 位图.bmBitsPixel)
    BitBlt (目标位图.取场景句柄 (), 目标左边, 目标顶边, 宽度 ＋ 目标左边, 高度 ＋ 目标顶边, 场景句柄, 左边, 顶边, #SRCCOPY)
    目标位图.更新位图 ()
    返回 (真)

.子程序 取位图句柄, 整数型, 公开, 取得当前类中位图的位图句柄(返回位图句柄,本类中没有位图返回0)
    返回 (位图句柄)

.子程序 取场景句柄, 整数型, 公开, 取得当前类中位图所在DC场景句柄(返回场景句柄,本类中没有位图返回0)
    返回 (场景句柄)

.子程序 取宽度, 整数型, 公开, (数据方式)取位图宽度,失败返回0
    .如果真 (位图数据 ＝ { })
        返回 (0)
    .如果真结束
    返回 (取字节集数据 (取字节集中间 (位图数据, 5, 4), #整数型, ))

.子程序 取高度, 整数型, 公开, (数据方式)取位图高度,失败返回0
    .如果真 (位图数据 ＝ { })
        返回 (0)
    .如果真结束
    返回 (取字节集数据 (位图数据, #整数型, 9))

.子程序 取位深度, 整数型, 公开, (数据方式)取位图颜色位数,失败返回0
    .如果真 (位图数据 ＝ { })
        返回 (0)
    .如果真结束
    返回 (到整数 (到短整数 (取字节集中间 (位图数据, 15, 2))))

.子程序 取宽度2, 整数型, 公开, (函数方式)取位图宽度,失败返回0
    .局部变量 位图, BITMAP

    GetObjectA (位图句柄, 5 × 4 ＋ 2 ＋ 2, 位图)
    返回 (位图.bmWidth)

.子程序 取高度2, 整数型, 公开, (函数方式)取位图高度,失败返回0
    .局部变量 位图, BITMAP

    GetObjectA (位图句柄, 5 × 4 ＋ 2 ＋ 2, 位图)
    返回 (位图.bmHeight)

.子程序 取位深度2, 整数型, 公开, (函数方式)取位图颜色位数,失败返回0
    .局部变量 位图, BITMAP

    GetObjectA (位图句柄, 5 × 4 ＋ 2 ＋ 2, 位图)
    返回 (位图.bmBitsPixel)

.子程序 取指针, 整数型, 公开, 取位图数据BITMAPINFO指针,失败返回0
    返回 (lstrcpyn_字节集 (位图数据, 位图数据, 0))

.子程序 取颜色点阵地址, 整数型, 公开, 取颜色点阵地址,失败返回0
    .如果真 (位图数据 ＝ { })
        返回 (0)
    .如果真结束
    返回 (lstrcpyn_字节集 (位图数据, 位图数据, 0) ＋ 40 ＋ 取颜色表大小 ())

.子程序 取颜色点阵大小, 整数型, 公开, 取颜色点阵大小,失败返回0
    .局部变量 r

    .如果真 (位图数据 ＝ { })
        返回 (0)
    .如果真结束
    r ＝ 取行字节数 ()
    返回 (取高度 () × 取行字节数 ())

.子程序 取颜色表指针, 整数型, 公开, 取颜色表指针,失败返回0,大于256色的位图不使用颜色表
    .如果真 (位图数据 ＝ { })
        返回 (0)
    .如果真结束
    .如果真 (取位深度 () ≥ 16)
        返回 (0)
    .如果真结束
    返回 (lstrcpyn_字节集 (位图数据, 位图数据, 0) ＋ 40)

.子程序 取颜色表大小, 整数型, 公开, 取颜色表大小,失败返回0
    .如果真 (位图数据 ＝ { })
        返回 (0)
    .如果真结束
    返回 (取颜色表颜色个数 (取字节集左边 (位图数据, 40)) × 4)

.子程序 取颜色表颜色个数, 整数型, , 取颜色表数组颜色个数
    .参数 pBmpInfo, 字节集
    .局部变量 iBitCount, 短整数型

    iBitCount ＝ 取字节集数据 (取字节集中间 (pBmpInfo, 15, 2), #短整数型, )
    .判断开始 (iBitCount ＝ 1)
        返回 (2)
    .判断 (iBitCount ＝ 4)
        返回 (16)
    .判断 (iBitCount ＝ 8)
        返回 (256)
    .默认
        .如果真 (iBitCount ＝ 16 或 iBitCount ＝ 24 或 iBitCount ＝ 32)
            返回 (0)
        .如果真结束
        
    .判断结束
    返回 (0)

.子程序 取行字节数, 整数型, 公开, 取得位图颜色数据一行的字节数
    .如果真 (位图数据 ＝ { })
        返回 (0)
    .如果真结束
    返回 (扫描行对齐 (取字节集数据 (取字节集中间 (位图数据, 5, 4), #整数型, ) × 取字节集数据 (取字节集中间 (位图数据, 13, 2), #整数型, ) × 取字节集数据 (取字节集中间 (位图数据, 15, 2), #整数型, )))
    

.子程序 扫描行对齐, 整数型, , 保图像的扫描行DWORD对齐
    .参数 bits, 整数型

    bits ＝ bits ＋ 31
    返回 (左移 (右移 (bits, 5), 2))

.子程序 位图信息头转字节集, 字节集
    .参数 欲转成字节集的信息, BITMAPINFOHEADER
    .局部变量 返回值, 字节集

    返回值 ＝ 到字节集 (欲转成字节集的信息.biSize)
    返回值 ＝ 返回值 ＋ 到字节集 (欲转成字节集的信息.biWidth)
    返回值 ＝ 返回值 ＋ 到字节集 (欲转成字节集的信息.biHeight)
    返回值 ＝ 返回值 ＋ 到字节集 (欲转成字节集的信息.biPlanes)
    返回值 ＝ 返回值 ＋ 到字节集 (欲转成字节集的信息.biBitCount)
    返回值 ＝ 返回值 ＋ 到字节集 (欲转成字节集的信息.biCompression)
    返回值 ＝ 返回值 ＋ 到字节集 (欲转成字节集的信息.biSizeImage)
    返回值 ＝ 返回值 ＋ 到字节集 (欲转成字节集的信息.biXPelsPerMeter)
    返回值 ＝ 返回值 ＋ 到字节集 (欲转成字节集的信息.biYPelsPerMeter)
    返回值 ＝ 返回值 ＋ 到字节集 (欲转成字节集的信息.biClrUsed)
    返回值 ＝ 返回值 ＋ 到字节集 (欲转成字节集的信息.biClrImportant)
    
    返回 (返回值)

.子程序 位图文件头转字节集, 字节集
    .参数 欲转成字节集的信息, BITMAPFILEHEADER
    .局部变量 返回值, 字节集

    返回值 ＝ 到字节集 (欲转成字节集的信息.bfType)
    
    返回值 ＝ 返回值 ＋ 到字节集 (欲转成字节集的信息.bfSize)
    
    返回值 ＝ 返回值 ＋ 到字节集 (欲转成字节集的信息.bfReserved1)
    
    返回值 ＝ 返回值 ＋ 到字节集 (欲转成字节集的信息.bfReserved2)
    返回值 ＝ 返回值 ＋ 到字节集 (欲转成字节集的信息.bfOffBits)
    返回 (返回值)

.子程序 取出位图数据, 字节集, 公开, 返回位图文件数据(写到文件后就是.BMP图片)
    .如果真 (场景被更新)
        RtlMoveMemory (取颜色点阵地址 (), 位图指针, 取颜色点阵大小 ())
        场景被更新 ＝ 假
    .如果真结束
    返回 (到字节集 (到短整数 (19778)) ＋ 到字节集 (到整数 (取字节集长度 (位图数据) ＋ 14)) ＋ { 0, 0 } ＋ { 0, 0 } ＋ 到字节集 (到整数 (54 ＋ 取颜色表大小 ())) ＋ 位图数据)
    ' 给位图数据加上位图文件头

.子程序 取出颜色数据, 字节集, 公开, 不含文件头的颜色部分的数据
    .如果真 (场景被更新)
        RtlMoveMemory (取颜色点阵地址 (), 位图指针, 取颜色点阵大小 ())
        场景被更新 ＝ 假
    .如果真结束
    返回 (取字节集右边 (位图数据, 取颜色点阵大小 ()))

.子程序 取某点颜色, 整数型, 公开, 取得位图中某点颜色值(成功返回十进制颜色值,失败返回-1)
    .参数 横坐标, 整数型
    .参数 纵坐标, 整数型

    .如果真 (场景被更新)
        RtlMoveMemory (取颜色点阵地址 (), 位图指针, 取颜色点阵大小 ())
        场景被更新 ＝ 假
    .如果真结束
    返回 (GetPixel (场景句柄, 横坐标, 纵坐标))

.子程序 置某点颜色, 逻辑型, 公开, 设置位图中某点颜色值(成功返回真,失败返回假)
    .参数 横坐标, 整数型
    .参数 纵坐标, 整数型
    .参数 颜色值, 整数型, , 十进制RGB颜色值

    场景被更新 ＝ SetPixelV (场景句柄, 横坐标, 纵坐标, 颜色值) ≠ 0
    返回 (场景被更新)

.子程序 置剪辑板位图, 逻辑型, 公开, 将指定位图存放到当前Windows系统剪辑板中,剪辑板中的原有内容被覆盖(成功返回真,失败返回假)
    .局部变量 a, 整数型
    .局部变量 场景句柄1, 整数型
    .局部变量 位图句柄1, 整数型
    .局部变量 旧位图句柄1, 整数型
    .局部变量 位图, BITMAP

    GetObjectA (位图句柄, 5 × 4 ＋ 2 ＋ 2, 位图)
    场景句柄1 ＝ CreateCompatibleDC (0)
    位图句柄1 ＝ CreateCompatibleBitmap (屏幕设备句柄, 位图.bmWidth, 位图.bmHeight)
    旧位图句柄1 ＝ SelectObject (场景句柄1, 位图句柄1)
    BitBlt (场景句柄1, 0, 0, 位图.bmWidth, 位图.bmHeight, 场景句柄, 0, 0, #SRCCOPY)
    SelectObject (场景句柄1, 旧位图句柄1)
    DeleteDC (场景句柄1)
    OpenClipboard (0)
    EmptyClipboard ()
    a ＝ SetClipboardData (#CF_BITMAP, 位图句柄1)
    CloseClipboard ()
    返回 (a ≠ 0)

.子程序 置窗口位图, 逻辑型, 公开, 将位图画入指定窗口中(成功返回真,失败返回假)
    .参数 窗口句柄, 整数型
    .局部变量 局部_位图信息, 位图信息_
    .局部变量 局部_空白字节集, 字节集
    .局部变量 位图, BITMAP
    .局部变量 窗口设备句柄, 整数型

    .如果真 (GetObjectA (位图句柄, 5 × 4 ＋ 2 ＋ 2, 位图) ＝ 0)
        返回 (假)
    .如果真结束
    局部_位图信息.位深度 ＝ 位图.bmBitsPixel
    局部_位图信息.压缩率 ＝ 0
    局部_位图信息.位图位面数 ＝ 1
    局部_位图信息.结果大小 ＝ 40
    局部_位图信息.位图宽度 ＝ 位图.bmWidth
    局部_位图信息.位图高度 ＝ 位图.bmHeight
    局部_空白字节集 ＝ 取空白字节集 (局部_位图信息.位图宽度 × 局部_位图信息.位图高度 × 4)
    GetDIBits3 (场景句柄, 位图句柄, 0, 局部_位图信息.位图高度, 局部_空白字节集 [1], 局部_位图信息, 0)
    窗口设备句柄 ＝ GetDC (窗口句柄)
    SetDIBitsToDevice (窗口设备句柄, 0, 0, 局部_位图信息.位图宽度, 局部_位图信息.位图高度, 0, 0, 0, 局部_位图信息.位图高度, 局部_空白字节集 [1], 局部_位图信息, 0)
    DeleteDC (窗口设备句柄)
    返回 (真)
    

.版本 2

.程序集 类_像素组, , 公开
.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
    ' 命令收集地址：https://bbs.125.la/forum.php?mod=viewthread&tid=14182970

.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
    

.子程序 位图_转_像素组, 逻辑型, 公开, 图片宽高小于1才会返回假
    .参数 wt_, 类_位图操作
    .参数 shuj_, 整数型, 数组
    .局部变量 k_, 整数型
    .局部变量 g_, 整数型
    .局部变量 q1, 整数型
    .局部变量 g_s1, 整数型
    .局部变量 y_, 整数型
    .局部变量 k_s1, 整数型
    .局部变量 s1, 整数型

    k_ ＝ wt_.取宽度 ()
    g_ ＝ wt_.取高度 ()
    .如果真 (k_ ＜ 1)
        返回 (假)
    .如果真结束
    
    .如果真 (g_ ＜ 1)
        返回 (假)
    .如果真结束
    
    q1 ＝ k_ × g_
    重定义数组 (shuj_, 假, q1)
    .计次循环首 (g_, g_s1)
        y_ ＝ g_s1 － 1
        .计次循环首 (k_, k_s1)
            s1 ＝ s1 ＋ 1 ' 优化
            shuj_ [s1] ＝ wt_.取某点颜色 (k_s1 － 1, y_)
        .计次循环尾 ()
    .计次循环尾 ()
    返回 (真)

.子程序 像素组_转_位图, 逻辑型, 公开
    .参数 位图_, 类_位图操作, 参考
    .参数 shuj_, 整数型, 数组
    .参数 k_, 整数型
    .参数 g_, 整数型
    .局部变量 q1, 整数型
    .局部变量 k_s1, 整数型
    .局部变量 g_s1, 整数型
    .局部变量 y_, 整数型
    .局部变量 s1, 整数型

    q1 ＝ k_ × g_
    .如果真 (q1 ＜ 1)
        返回 (假)
    .如果真结束
    
    .如果真 (取数组成员数 (shuj_) ＜ q1)
        返回 (假)
    .如果真结束
    位图_.创建空白位图 (k_, g_, 24)
    .计次循环首 (g_, g_s1)
        y_ ＝ g_s1 － 1
        .计次循环首 (k_, k_s1)
            s1 ＝ s1 ＋ 1 ' 优化
            位图_.置某点颜色 (k_s1 － 1, y_, shuj_ [s1])
        .计次循环尾 ()
    .计次循环尾 ()
    返回 (真)

.子程序 像素组_取_某点颜色, 整数型, 公开
    .参数 shuj_, 整数型, 数组
    .参数 k, 整数型
    .参数 x, 整数型
    .参数 y, 整数型
    .局部变量 ls_d, 整数型
    .局部变量 q1, 整数型

    q1 ＝ 取数组成员数 (shuj_)
    .如果真 (q1 ＜ 1)
        返回 (0)
    .如果真结束
    ls_d ＝ (y － 1) × k ＋ x
    
    .如果真 (q1 ≥ ls_d)
        返回 (shuj_ [ls_d])
    .如果真结束
    返回 (0)
    

.子程序 像素组_置_某点颜色, , 公开
    .参数 shuj_, 整数型, 数组
    .参数 k, 整数型
    .参数 x, 整数型
    .参数 y, 整数型
    .参数 置入颜色, 整数型
    .局部变量 ls_d, 整数型
    .局部变量 q1, 整数型

    q1 ＝ 取数组成员数 (shuj_)
    .如果真 (q1 ＜ 1)
        返回 ()
    .如果真结束
    
    ls_d ＝ (y － 1) × k ＋ x
    .如果真 (q1 ≥ ls_d)
        shuj_ [ls_d] ＝ 置入颜色
    .如果真结束
    
    

.子程序 像素组_缩放图片_快速, 逻辑型, 公开, 图片宽高小于1才会返回假
    .参数 shuj_, 整数型, 数组
    .参数 k_, 整数型
    .参数 g_, 整数型
    .参数 缩放后_k, 整数型
    .参数 缩放后_g, 整数型
    .参数 缩放后数据, 整数型, 数组
    .局部变量 q1, 整数型
    .局部变量 q2, 整数型
    .局部变量 x_int, 整数型
    .局部变量 y_int, 整数型
    .局部变量 g_s1, 整数型
    .局部变量 k_s1, 整数型
    .局部变量 shu_1, 整数型
    .局部变量 shu_2, 整数型
    .局部变量 yt_d, 整数型
    .局部变量 sf_d, 整数型

    q1 ＝ k_ × g_
    .如果真 (q1 ＜ 1)
        返回 (假)
    .如果真结束
    
    .如果真 (取数组成员数 (shuj_) ＜ q1)
        返回 (假)
    .如果真结束
    
    q2 ＝ 缩放后_k × 缩放后_g
    .如果真 (q2 ＜ 1)
        返回 (假)
    .如果真结束
    
    重定义数组 (缩放后数据, 假, q2)
    ' ------------------------
    x_int ＝ k_ × 1000 ÷ 缩放后_k
    y_int ＝ g_ × 1000 ÷ 缩放后_g
    
    .计次循环首 (缩放后_g, g_s1)
        .计次循环首 (缩放后_k, k_s1)
            shu_1 ＝ k_s1 × x_int ÷ 1000
            shu_2 ＝ g_s1 × y_int ÷ 1000
            .如果真 (shu_1 ＜ 1)
                shu_1 ＝ 1
            .如果真结束
            
            .如果真 (shu_2 ＜ 1)
                shu_2 ＝ 1
            .如果真结束
            
            yt_d ＝ (shu_2 － 1) × k_ ＋ shu_1
            sf_d ＝ (g_s1 － 1) × 缩放后_k ＋ k_s1
            缩放后数据 [sf_d] ＝ shuj_ [yt_d]
        .计次循环尾 ()
    .计次循环尾 ()
    返回 (真)

.子程序 像素组_缩放图片_无损, 逻辑型, 公开
    .参数 shuj_, 整数型, 数组
    .参数 k_, 整数型
    .参数 g_, 整数型
    .参数 缩放后_k, 整数型
    .参数 缩放后_g, 整数型
    .参数 缩放后数据, 整数型, 数组
    .局部变量 q1, 整数型
    .局部变量 q2, 整数型
    .局部变量 x_int, 整数型
    .局部变量 y_int, 整数型
    .局部变量 xh_x, 整数型
    .局部变量 xh_y, 整数型
    .局部变量 g_s1, 整数型
    .局部变量 k_s1, 整数型
    .局部变量 shu_1, 整数型
    .局部变量 shu_2, 整数型
    .局部变量 N, 整数型
    .局部变量 R, 整数型
    .局部变量 G, 整数型
    .局部变量 B, 整数型
    .局部变量 临时_x, 整数型
    .局部变量 临时_y, 整数型
    .局部变量 临时_颜色, 整数型
    .局部变量 临时_点, 整数型

    q1 ＝ k_ × g_
    .如果真 (q1 ＜ 1)
        返回 (假)
    .如果真结束
    
    .如果真 (取数组成员数 (shuj_) ＜ q1)
        返回 (假)
    .如果真结束
    
    q2 ＝ 缩放后_k × 缩放后_g
    .如果真 (q2 ＜ 1)
        返回 (假)
    .如果真结束
    
    重定义数组 (缩放后数据, 假, q2)
    x_int ＝ k_ × 1000 ÷ 缩放后_k
    y_int ＝ g_ × 1000 ÷ 缩放后_g
    ' ---------------------------
    xh_x ＝ x_int ÷ 1000
    xh_y ＝ y_int ÷ 1000
    ' ----------------------------
    .计次循环首 (缩放后_g, g_s1)
        .计次循环首 (缩放后_k, k_s1)
            shu_1 ＝ x_int × (k_s1 － 1)
            .如果真 (shu_1 ＞ 0)
                shu_1 ＝ shu_1 ÷ 1000
            .如果真结束
            
            .如果真 (shu_1 ＜ 1)
                shu_1 ＝ 0
            .如果真结束
            N ＝ 0
            R ＝ 0
            G ＝ 0
            B ＝ 0
            临时_颜色 ＝ 0
            .计次循环首 (xh_x, )
                shu_1 ＝ shu_1 ＋ 1
                .判断开始 (shu_1 ＜ 1)
                    临时_x ＝ 1
                .默认
                    
                    临时_x ＝ shu_1
                .判断结束
                shu_2 ＝ y_int × (g_s1 － 1)
                .如果真 (shu_2 ＞ 0)
                    shu_2 ＝ shu_2 ÷ 1000
                .如果真结束
                
                .如果真 (shu_2 ＜ 1)
                    shu_2 ＝ 0
                .如果真结束
                
                .计次循环首 (xh_y, )
                    shu_2 ＝ shu_2 ＋ 1
                    .判断开始 (shu_2 ＜ 1)
                        临时_y ＝ 1
                    .默认
                        
                        临时_y ＝ shu_2
                    .判断结束
                    
                    临时_点 ＝ (临时_y － 1) × k_ ＋ 临时_x
                    临时_颜色 ＝ shuj_ [临时_点]
                    加入_RGB (临时_颜色, R, G, B, N)
                .计次循环尾 ()
                临时_y ＝ y_int × g_s1
                .如果真 (临时_y ＞ 0)
                    临时_y ＝ 临时_y ÷ 1000
                .如果真结束
                
                .如果真 (临时_y ＜ 1)
                    临时_y ＝ 1
                .如果真结束
                
                临时_点 ＝ (临时_y － 1) × k_ ＋ 临时_x
                临时_颜色 ＝ shuj_ [临时_点]
                加入_RGB (临时_颜色, R, G, B, N)
            .计次循环尾 ()
            临时_x ＝ x_int × k_s1
            .如果真 (临时_x ＞ 0)
                临时_x ＝ 临时_x ÷ 1000
            .如果真结束
            
            .如果真 (临时_x ＜ 1)
                临时_x ＝ 1
            .如果真结束
            
            shu_2 ＝ y_int × (g_s1 － 1)
            .如果真 (shu_2 ＞ 0)
                shu_2 ＝ shu_2 ÷ 1000
            .如果真结束
            
            .如果真 (shu_2 ＜ 1)
                shu_2 ＝ 0
            .如果真结束
            
            .计次循环首 (xh_y, )
                shu_2 ＝ shu_2 ＋ 1
                .判断开始 (shu_2 ＜ 1)
                    临时_y ＝ 1
                .默认
                    
                    临时_y ＝ shu_2
                .判断结束
                
                临时_点 ＝ (临时_y － 1) × k_ ＋ 临时_x
                临时_颜色 ＝ shuj_ [临时_点]
                加入_RGB (临时_颜色, R, G, B, N)
            .计次循环尾 ()
            临时_y ＝ y_int × g_s1
            .如果真 (临时_y ＞ 0)
                临时_y ＝ 临时_y ÷ 1000
            .如果真结束
            
            .如果真 (临时_y ＜ 1)
                临时_y ＝ 1
            .如果真结束
            
            临时_点 ＝ (临时_y － 1) × k_ ＋ 临时_x
            临时_颜色 ＝ shuj_ [临时_点]
            加入_RGB (临时_颜色, R, G, B, N)
            R ＝ R ÷ N
            G ＝ G ÷ N
            B ＝ B ÷ N
            临时_颜色 ＝ RGB_整数 (R, G, B)
            临时_点 ＝ (g_s1 － 1) × 缩放后_k ＋ k_s1
            缩放后数据 [临时_点] ＝ 临时_颜色
        .计次循环尾 ()
    .计次循环尾 ()
    返回 (真)

.版本 2

.程序集 类_图像格式转换类, , 公开, 作者：凌晨孤星；修改：邓学彬(泪闯天涯)
.程序集变量 m_hMem, 整数型
.程序集变量 m_Stream, 对象
.程序集变量 m_pBitmap, 整数型
.程序集变量 m_nWidth, 整数型, , , 图片宽度
.程序集变量 m_nHeight, 整数型, , , 图片高度
.程序集变量 m_pBrush, 整数型, , , 背景画刷

.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
    .局部变量 GpInput, GdiplusStartupInput

    GpInput.GdiplusVersion ＝ 1
    GdiplusStartup (全_Token, GpInput, 0) ' 启动 GDI+
    
    ' 模块命令收录自：http://bbs.eyuyan.com/read.php?tid=405365

.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
    销毁 ()
    .如果真 (m_pBrush ≠ 0)
        GdipDeleteBrush (m_pBrush)
        m_pBrush ＝ 0
    .如果真结束
    

.子程序 销毁, , 公开, 销毁载入的图像,释放内存
    .如果真 (m_pBitmap ≠ 0)
        GdipDisposeImage (m_pBitmap)
        m_pBitmap ＝ 0
    .如果真结束
    .如果真 (m_Stream.是否为空 () ＝ 假)
        m_Stream.清除 ()
    .如果真结束
    .如果真 (m_hMem ≠ 0)
        GlobalFree (m_hMem)
        m_hMem ＝ 0
    .如果真结束
    m_nWidth ＝ 0
    m_nHeight ＝ 0

.子程序 载入图像, 逻辑型, 公开
    .参数 图像数据, 字节集
    .局部变量 nLength, 整数型
    .局部变量 lpvoid, 整数型
    .局部变量 pStream1, 整数型
    .局部变量 pStream2, 整数型

    销毁 ()
    nLength ＝ 取字节集长度 (图像数据)
    .如果真 (nLength ＜ 5)
        返回 (假)
    .如果真结束
    m_hMem ＝ GlobalAlloc (#GMEM_MOVEABLE, nLength)
    .如果真 (m_hMem ＝ 0)
        返回 (假)
    .如果真结束
    
    CreateStreamOnHGlobal_Object (m_hMem, 假, m_Stream) ' 创建流对象。注意第2个参数！！！！！！！！！如果后面调用了 GlobalFree 进行释放的话，这里第2个参数设置为“假”
    .如果真 (m_Stream.是否为空 ())
        返回 (假)
    .如果真结束
    lpvoid ＝ GlobalLock (m_hMem) ' 锁定该区域，获得存放数据的地址
    .如果真 (lpvoid ＝ 0)
        返回 (假)
    .如果真结束
    RtlMoveMemory_字节集 (lpvoid, 图像数据, nLength) ' 把数据写到流里面
    GlobalUnlock (m_hMem) ' 取消锁定
    pStream1 ＝ GetObjectPtr (m_Stream, m_Stream, 0) ' 获得流对象指针
    .如果真 (pStream1 ＝ 0)
        返回 (假)
    .如果真结束
    RtlMoveMemory_整数传址1 (pStream2, pStream1, 4)
    .如果真 (pStream2 ＝ 0)
        返回 (假)
    .如果真结束
    GDIpCreateBitmapFromStream (pStream2, m_pBitmap) ' 创建位图对象
    .如果真 (m_pBitmap ＝ 0)
        返回 (假)
    .如果真结束
    
    返回 (m_pBitmap ≠ 0)

.子程序 载入文件, 逻辑型, 公开
    .参数 文件名, 文本型, , 完整文件路径。
    .局部变量 FileName, 字节集

    销毁 ()
    .如果真 (文件名 ＝ “”)
        返回 (假)
    .如果真结束
    FileName ＝ 编码_Ansi到Unicode (文件名, )
    GdipLoadImageFromFile (FileName, m_pBitmap)
    返回 (m_pBitmap ≠ 0)

.子程序 转换到字节集, 字节集, 公开, 转换图片为新格式,操作成功返回新图片的字节集,失败返回空字节集.参数1为转换格式(1、bmp；2、jpg；3、gif；4、tiff；5、png),参数2为JPG图片质量(0-100)
    .参数 转换格式, 整数型, , 转换后的图片格式。1、bmp；2、jpg；3、gif；4、tiff；5、png
    .参数 JPG图片质量, 整数型, 可空, 只对JPG格式有效,0最差效果,100最好效果,留空默认为100
    .局部变量 Clsid, 字节集
    .局部变量 DataStream, 对象
    .局部变量 hMemDataStream, 整数型
    .局部变量 pDataStream, 整数型
    .局部变量 nStreamSize, 整数型
    .局部变量 bRet, 逻辑型
    .局部变量 eps, EncoderParameters
    .局部变量 quality, 整数型
    .局部变量 新图像, 字节集
    .局部变量 pStream2, 整数型
    .局部变量 pStream1, 整数型

    .如果真 (m_pBitmap ＝ 0)
        返回 (新图像)
    .如果真结束
    填充背景 ()
    ' //-----------------------------------------
    .如果真 (是否为空 (JPG图片质量))
        JPG图片质量 ＝ 100
    .如果真结束
    .如果真 (JPG图片质量 ＜ 0)
        JPG图片质量 ＝ 0
    .如果真结束
    .如果真 (JPG图片质量 ＞ 100)
        JPG图片质量 ＝ 100
    .如果真结束
    ' //-----------------------------------------
    GetCLSID (转换格式, Clsid)
    eps.Count ＝ 1
    eps.Parameter [1].Type ＝ 4
    eps.Parameter [1].NumberOfValues ＝ 1
    .如果真 (转换格式 ＝ 2) ' jpg
        quality ＝ JPG图片质量 ' 图片质量，0最差效果，100最好效果
        eps.Parameter [1].Value ＝ lstrcpynA_整数传址 (quality, quality, 0)
        CLSIDFromString_字节 (编码_Ansi到Unicode (“{1d5be4b5-fa4a-452d-9cdd-5db35105e7eb}”, ), eps.Parameter [1].Guid)
    .如果真结束
    ' //-----------------------------------------
    hMemDataStream ＝ GlobalAlloc (#GMEM_MOVEABLE, 0)
    CreateStreamOnHGlobal_Object (hMemDataStream, 假, DataStream)
    pStream1 ＝ GetObjectPtr (DataStream, DataStream, 0) ' 获得流对象指针
    .如果真 (pStream1 ≠ 0)
        RtlMoveMemory_整数传址1 (pStream2, pStream1, 4)
        .如果真 (pStream2 ≠ 0)
            GdipSaveImageToStream (m_pBitmap, pStream2, Clsid, eps)
            pDataStream ＝ GlobalLock (hMemDataStream)
            nStreamSize ＝ GlobalSize (hMemDataStream)
            .如果真 (pDataStream ≠ 0)
                新图像 ＝ 取空白字节集 (nStreamSize)
                RtlMoveMemory_int2Bytes (新图像, pDataStream, nStreamSize)
                bRet ＝ 真
            .如果真结束
            GlobalUnlock (hMemDataStream)
        .如果真结束
        
    .如果真结束
    GlobalFree (hMemDataStream)
    返回 (新图像)

.子程序 转换到文件, 逻辑型, 公开, 转换图片为新格式,操作成功返回真,失败返回假.参数1为转换格式(1、bmp；2、jpg；3、gif；4、tiff；5、png),参数2为JPG图片质量(0-100)
    .参数 文件名, 文本型, , 完整文件路径,存放转换后的图片。
    .参数 转换格式, 整数型, , 转换后的图片格式。1、bmp；2、jpg；3、gif；4、tiff；5、png
    .参数 JPG图片质量, 整数型, 可空, 只对JPG格式有效,0最差效果,100最好效果,留空默认为100
    .局部变量 Clsid, 字节集
    .局部变量 FileName, 字节集
    .局部变量 eps, EncoderParameters
    .局部变量 quality, 整数型
    .局部变量 r, 整数型

    .如果真 (m_pBitmap ＝ 0)
        返回 (假)
    .如果真结束
    .如果真 (文件名 ＝ “”)
        返回 (假)
    .如果真结束
    填充背景 ()
    ' //-----------------------------------------
    .如果真 (是否为空 (JPG图片质量))
        JPG图片质量 ＝ 100
    .如果真结束
    .如果真 (JPG图片质量 ＜ 0)
        JPG图片质量 ＝ 0
    .如果真结束
    .如果真 (JPG图片质量 ＞ 100)
        JPG图片质量 ＝ 100
    .如果真结束
    ' //-----------------------------------------
    GetCLSID (转换格式, Clsid)
    eps.Count ＝ 1
    eps.Parameter [1].Type ＝ 4
    eps.Parameter [1].NumberOfValues ＝ 1
    .如果真 (转换格式 ＝ 2) ' jpg
        quality ＝ JPG图片质量 ' 图片质量，0最差效果，100最好效果
        eps.Parameter [1].Value ＝ lstrcpynA_整数传址 (quality, quality, 0)
        CLSIDFromString_字节 (编码_Ansi到Unicode (“{1d5be4b5-fa4a-452d-9cdd-5db35105e7eb}”, ), eps.Parameter [1].Guid)
    .如果真结束
    ' //-----------------------------------------
    FileName ＝ 编码_Ansi到Unicode (文件名, )
    r ＝ GdipSaveImageToFile_EncoderParameters (m_pBitmap, FileName, Clsid, eps)
    返回 (r ＝ 0)

.子程序 填充背景, , 公开
    .局部变量 pNewBitmap, 整数型
    .局部变量 pGraphics, 整数型

    .如果真 (m_pBitmap ＝ 0)
        返回 ()
    .如果真结束
    .如果真 (m_pBrush ＝ 0)
        返回 ()
    .如果真结束
    ' //-----------------------------------------------
    .如果真 (m_nWidth ＝ 0 或 m_nHeight ＝ 0)
        GdipGetImageWidth (m_pBitmap, m_nWidth)
        GdipGetImageHeight (m_pBitmap, m_nHeight)
    .如果真结束
    GdipCreateBitmapFromScan0 (m_nWidth, m_nHeight, 0, #像素格式_32bppARGB, 0, pNewBitmap)
    .如果真 (pNewBitmap ＝ 0)
        返回 ()
    .如果真结束
    GdipGetImageGraphicsContext (pNewBitmap, pGraphics)
    GdipFillRectangle (pGraphics, m_pBrush, 0, 0, m_nWidth, m_nHeight)
    GdipDrawImageRectRect_NULL (pGraphics, m_pBitmap, 0, 0, m_nWidth, m_nHeight, 0, 0, m_nWidth, m_nHeight, #单位_像素, 0, 0, 0)
    GdipDeleteGraphics (pGraphics)
    ' //-----------------------------------------------
    销毁 ()
    m_pBitmap ＝ pNewBitmap

.子程序 取图片宽度, 整数型, 公开
    .如果真 (m_pBitmap ≠ 0 且 m_nWidth ＝ 0)
        取图片尺寸 (0, 0)
    .如果真结束
    返回 (m_nWidth)

.子程序 取图片高度, 整数型, 公开
    .如果真 (m_pBitmap ≠ 0 且 m_nHeight ＝ 0)
        取图片尺寸 (0, 0)
    .如果真结束
    返回 (m_nHeight)

.子程序 取图片尺寸, , 公开
    .参数 图片宽度, 整数型, 参考
    .参数 图片高度, 整数型, 参考

    .如果真 (m_pBitmap ≠ 0)
        .如果真 (m_nWidth ＝ 0)
            GdipGetImageWidth (m_pBitmap, m_nWidth)
        .如果真结束
        .如果真 (m_nHeight ＝ 0)
            GdipGetImageHeight (m_pBitmap, m_nHeight)
        .如果真结束
        .如果真 (m_nWidth ＝ 0 或 m_nHeight ＝ 0)
            销毁 ()
        .如果真结束
        
    .如果真结束
    图片宽度 ＝ m_nWidth
    图片高度 ＝ m_nHeight

.子程序 取图片句柄, 整数型, 公开
    返回 (m_pBitmap)

.子程序 置背景颜色, , 公开, 设置转换后图片的背景颜色
    .参数 背景颜色, 整数型, , RGB颜色值，-1为透明(不填充背景)

    .如果真 (m_pBrush ≠ 0)
        GdipDeleteBrush (m_pBrush)
        m_pBrush ＝ 0
    .如果真结束
    .如果真 (背景颜色 ≥ 0)
        GdipCreateSolidFill (RGB2ARGB (背景颜色), m_pBrush)
    .如果真结束
    

.子程序 GetCLSID
    .参数 转换格式, 整数型, , 转换后的图片格式。1、bmp；2、jpg；3、gif；4、tiff；5、png
    .参数 Clsid, 字节集, 参考
    .局部变量 pStr, 文本型

    .判断开始 (转换格式 ＝ 1) ' bmp
        pStr ＝ “{557CF400-1A04-11D3-9A73-0000F81EF32E}”
    .判断 (转换格式 ＝ 2) ' jpg
        pStr ＝ “{557CF401-1A04-11D3-9A73-0000F81EF32E}”
    .判断 (转换格式 ＝ 3) ' gif
        pStr ＝ “{557CF402-1A04-11D3-9A73-0000F81EF32E}”
    .判断 (转换格式 ＝ 4) ' tiff
        pStr ＝ “{557CF405-1A04-11D3-9A73-0000F81EF32E}”
    .判断 (转换格式 ＝ 5) ' png
        pStr ＝ “{557CF406-1A04-11D3-9A73-0000F81EF32E}”
    .默认
        pStr ＝ “{557CF400-1A04-11D3-9A73-0000F81EF32E}”
    .判断结束
    Clsid ＝ 取空白字节集 (16)
    CLSIDFromString_字节集传址2 (编码_Ansi到Unicode (pStr, ), Clsid) ' 获取图像格式对应的Clsid
    

.版本 2

.程序集 类_图片组操作类, , 公开
.程序集变量 集_图片组句柄, 整数型

.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
    

.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
    

.子程序 销毁图片组, 整数型, 公开, 成功返回非零,失败返回0
    返回 (ImageList_Destroy (集_图片组句柄))

.子程序 创建图片组, 字节集, 公开, 创建一个空的图片组，成功返回所创建图片组的数据，失败返回空字节集
    .参数 参_宽度, 整数型, 可空, 欲创建图片组的宽度,默认为32
    .参数 参_高度, 整数型, 可空, 欲创建图片组的高度,默认为32
    .参数 参_位深, 整数型, 可空, 默认为32
    .参数 图片组背景颜色, 整数型, 可空, 默认为白色

    .如果真 (是否为空 (参_宽度))
        参_宽度 ＝ 32
    .如果真结束
    .如果真 (是否为空 (参_高度))
        参_高度 ＝ 32
    .如果真结束
    .如果真 (是否为空 (参_位深))
        参_位深 ＝ 32
    .如果真结束
    集_图片组句柄 ＝ ImageList_Create (参_宽度, 参_高度, 参_位深, 0, 0)
    .如果 (是否为空 (图片组背景颜色))
        置图片组背景颜色 (#白色)
    .否则
        置图片组背景颜色 (图片组背景颜色)
    .如果结束
    返回 (导出图片组 ())

.子程序 删除图标, 逻辑型, 公开, 删除图片组中指定位置的图标,成功返回真,否则返回假
    .参数 参_索引位置, 整数型, , 要删除的图标位置,索引从0开始

    返回 (ImageList_Remove (集_图片组句柄, 参_索引位置))

.子程序 清空, 逻辑型, 公开, 成功返回真,否则返回假
    返回 (ImageList_Remove (集_图片组句柄, -1))

.子程序 取图片组尺寸, 逻辑型, 公开, 取得图片组的图标尺寸,成功返回真,否则返回假
    .参数 参_宽度, 整数型, 参考, 此变量用于存放图片组图标宽度
    .参数 参_高度, 整数型, 参考, 此变量用于存放图片组图标高度

    返回 (ImageList_GetIconSize (集_图片组句柄, 参_宽度, 参_高度))

.子程序 取图片组图标数, 整数型, 公开, 取出图片组的图标数
    返回 (ImageList_GetImageCount (集_图片组句柄))

.子程序 置图片组图标尺寸, 逻辑型, 公开, 设置图片组的图标大小,成功返回真,否则返回假
    .参数 参_宽度, 整数型, , 要设置的图标组图标宽度
    .参数 参_高度, 整数型, , 要设置的图标组图标高度

    返回 (ImageList_SetIconSize (集_图片组句柄, 参_宽度, 参_高度))

.子程序 置图片组图标数, 逻辑型, 公开, 成功返回真,否则返回假
    .参数 图标数量, 整数型, , 要设置的图片组图标数量

    返回 (ImageList_SetImageCount (集_图片组句柄, 图标数量))

.子程序 取图片组背景颜色, 整数型, 公开, 返回图片组的背景颜色
    返回 (ImageList_GetBkColor (集_图片组句柄))

.子程序 置图片组背景颜色, 逻辑型, 公开, 成功返回真,否则返回假
    .参数 背景颜色值, 整数型, , 要设置的图片组背景颜色值

    返回 (ImageList_SetBkColor (集_图片组句柄, 背景颜色值))

.子程序 取图片组句柄, 整数型, 公开, 返回创建成功后的图片组句柄
    返回 (集_图片组句柄)

.子程序 置图片组句柄, , 公开, 设置要操作的图片组句柄
    .参数 句柄, 整数型, , 要设置要操作的图片组句柄

    集_图片组句柄 ＝ 句柄

.子程序 替换图标, 逻辑型, 公开, 根据图标句柄替换指定索引的图标,成功返回真,失败返回假
    .参数 图标句柄, 整数型, , 欲替换成的ico图标的句柄,可用命令 载入图标_ 返回的句柄
    .参数 替换位置索引, 整数型, , 欲替换图片组的索引位置,0为第一位置,如果为空表示插入到尾部

    返回 (ImageList_ReplaceIcon (集_图片组句柄, 替换位置索引, 图标句柄) ≠ -1)

.子程序 替换位图, 整数型, 公开, 成功返回非0失败返回0
    .参数 位图句柄, 整数型, , 欲替换成的位图的句柄,可用命令 载入位图_ 返回的句柄
    .参数 替换位置索引, 整数型, , 欲替换图片组的索引位置,0为第一位置

    返回 (ImageList_Replace (集_图片组句柄, 替换位置索引, 位图句柄, 0))

.子程序 导出图片组_其它语言, 字节集, , 取回图片组的数据
    .局部变量 字节流, 字节流
    .局部变量 返回值, 逻辑型
    .局部变量 图片组字节集, 字节集

    字节流.创建字节流 ()
    返回值 ＝ ImageList_Write (集_图片组句柄, 字节流.取字节流指针 ())
    .如果真 (返回值)
        图片组字节集 ＝ 字节流.取出字节集 ()
    .如果真结束
    字节流.释放字节流 ()
    返回 (图片组字节集)

.子程序 导出图片组, 字节集, 公开, 取出为易使用的图片组字节集 
    .局部变量 字节流, 字节流
    .局部变量 返回值, 逻辑型
    .局部变量 图片组字节集, 字节集

    字节流.创建字节流 ()
    返回值 ＝ ImageList_Write (集_图片组句柄, 字节流.取字节流指针 ())
    .如果 (返回值)
        图片组字节集 ＝ { 77, 73, 84, 76, 0, 0, 0, 255 } ＋ 字节流.取出字节集 ()
    .否则
        信息框 (“取出失败”, 0, )
    .如果结束
    字节流.释放字节流 ()
    返回 (图片组字节集)

.子程序 导入图片组_其它语言, 逻辑型, , 将图片组字节集数据读入到本类中操作使用,成功返回真,失败返回假
    .参数 图片组字节集, 字节集, , 要读入的图片组数据
    .局部变量 字节流, 字节流

    字节流.创建字节流 (图片组字节集)
    集_图片组句柄 ＝ ImageList_Read (字节流.取字节流指针 ()) ' 将图片组句柄赋值
    字节流.释放字节流 ()
    返回 (集_图片组句柄 ≠ 0) ' 成功返回图片组句柄

.子程序 导入图片组, 逻辑型, 公开, 将易图片组读入为类图片组
    .参数 图片组字节集, 字节集, , 要读入的图片组数据
    .局部变量 字节流, 字节流

    图片组字节集 ＝ 取字节集中间 (图片组字节集, 9, 取字节集长度 (图片组字节集) － 8) ' 前面的八个字节为易图片组标志头  MITL.... 的字节集数据
    字节流.创建字节流 (图片组字节集)
    集_图片组句柄 ＝ ImageList_Read (字节流.取字节流指针 ()) ' 将图片组句柄赋值
    字节流.释放字节流 ()
    返回 (集_图片组句柄 ≠ 0) ' 成功返回图片组句柄

.子程序 取图标句柄_从文件, 整数型, 公开, 载入指定图标,成功返回图标句柄,失败返回0
    .参数 图标文件路径, 文本型, , 欲载入的图标文件全路径

    返回 (LoadImage (0, 图标文件路径, 1, 0, 0, 16))

.子程序 取图片句柄_从文件, 整数型, 公开, 载入指定位图,成功返回位图句柄,失败返回0
    .参数 位图文件路径, 文本型, , 欲载入的位图文件全路径,只能为BMP格式位图文件路径

    返回 (LoadImage (0, 位图文件路径, 0, 0, 0, 16))

.子程序 取图片句柄_从字节集, 整数型, 公开, 载入指定图片,或者图标.成功返回位图句柄,失败返回0
    .参数 图片字节集, 字节集, , 欲载入的bmp,jpg等图片资源或者ico图标字节集
    .局部变量 图片对象, 对象, 静态
    .局部变量 图片句柄, 整数型

    CoInitialize (0)
    图片对象.创建图片对象 (图片字节集)
    图片句柄 ＝ 图片对象.读数值属性 (“Handle”, )
    CoUninitialize ()
    返回 (图片句柄)

.子程序 加入图标_从字节集, 逻辑型, 公开
    .参数 图片字节集, 字节集, , 要加入的bmp,jpg等图片资源或者ico图标字节集

    返回 (加入图标_从句柄 (取图片句柄_从字节集 (图片字节集)) ≠ -1)

.子程序 加入位图_从文件, 整数型, 公开, 成功返回添加位图后的图片索引,失败返回 -1
    .参数 位图文件路径, 文本型, , 要添加的bmp位图文件路径,只能为bmp格式图片,如果这个位图尺寸大于了创建图片组的尺寸,将自动被分割成多个图片,自动添加到图片组中
    .局部变量 位图句柄, 整数型

    位图句柄 ＝ 取图片句柄_从文件 (位图文件路径)
    返回 (ImageList_Add (集_图片组句柄, 位图句柄, 0))

.子程序 加入位图_从句柄, 整数型, 公开, 成功返回添加位图后的图片索引,失败返回 -1
    .参数 位图句柄, 整数型, , 可用命令 载入位图_从字节集_ ,载入位图_从文件_ 返回的句柄,欲添加的bmp位图图片句柄,只能为bmp格式图片,如果这个位图尺寸大于了创建图片组的尺寸,将自动被分割成多个图片,自动添加到图片组中

    返回 (ImageList_Add (集_图片组句柄, 位图句柄, 0))

.子程序 加入图标_从文件, 整数型, 公开, 成功返回添加图标后的图片索引,失败返回 -1
    .参数 图标文件路径, 文本型, , 欲添加的ico图标文件路径
    .局部变量 图标句柄, 整数型

    图标句柄 ＝ 取图标句柄_从文件 (图标文件路径)
    返回 (ImageList_AddIcon (集_图片组句柄, 图标句柄))

.子程序 加入图标_从句柄, 整数型, 公开, 成功返回添加图标后的图片索引,失败返回 -1
    .参数 图标句柄, 整数型, , 欲添加的ico图标的句柄,可用命令 取图标句柄_从文件 返回的句柄

    返回 (ImageList_AddIcon (集_图片组句柄, 图标句柄))

.版本 2

.程序集 类_识图, , 公开
.程序集变量 LF内容, 文本型
.程序集变量 LF颜色, 整数型
.程序集变量 LF大小, 整数型
.程序集变量 LF加粗, 整数型
.程序集变量 LF斜体, 逻辑型
.程序集变量 LF下划线, 逻辑型
.程序集变量 LF删除线, 逻辑型
.程序集变量 LF字体名称, 文本型

.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
    

.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
    

.子程序 制作范围, 精易_矩形, 公开, 生成一个矩形的范围,并返回
    .参数 左边, 整数型, 可空, 查找范围的左边
    .参数 顶边, 整数型, 可空, 查找范围的顶边
    .参数 宽度, 整数型, 可空, 查找范围的宽度
    .参数 高度, 整数型, 可空, 查找范围的高度
    .局部变量 矩形, 精易_矩形

    矩形.左边 ＝ 左边
    矩形.顶边 ＝ 顶边
    矩形.右边 ＝ 矩形.左边 ＋ 宽度
    矩形.底边 ＝ 矩形.顶边 ＋ 高度
    返回 (矩形)

.子程序 找图_从句柄, 精易_坐标, 公开, 在屏幕或指定窗口上找图，成功返回找到的位置坐标，失败坐标返回-1。，BUG命令谨慎使用
    .参数 窗口句柄, 整数型, 可空, 可空。默认在屏幕中查找。
    .参数 目标图片, 字节集, , 要查找的图片数据   bmp图片
    .参数 寻找范围, 精易_矩形, 可空, 可空。可用 制作范围() 制作返回。留空为查找整个屏幕或窗口。
    .参数 是否在后台, 逻辑型, 可空, 可空。默认为假，在当前屏幕中查找，真为后台窗口中查找。
    .局部变量 找到坐标, 精易_坐标
    .局部变量 位图, 类_位图操作
    .局部变量 保存位图1, 字节集
    .局部变量 宽1, 整数型
    .局部变量 高1, 整数型
    .局部变量 保存位图2, 字节集
    .局部变量 保存位图集, 字节集, , "0"
    .局部变量 宽2, 整数型
    .局部变量 高2, 整数型
    .局部变量 补零2, 整数型
    .局部变量 i, 整数型
    .局部变量 找到位置, 整数型
    .局部变量 i2, 整数型
    .局部变量 窗口坐标, 精易_坐标
    .局部变量 矩形范围, 精易_矩形

    找到坐标.横 ＝ -1
    找到坐标.纵 ＝ -1
    .判断开始 (是否在后台)
        位图.从窗口创建 (窗口句柄, 寻找范围.左边, 寻找范围.顶边, 寻找范围.右边, 寻找范围.底边, 8)
    .默认
        .如果真 (窗口句柄 ≠ 0)
            ClientToScreen (窗口句柄, 窗口坐标)
            GetClientRect (窗口句柄, 矩形范围)
            .如果真 (寻找范围.右边 ＝ 0 或 寻找范围.右边 ＞ 矩形范围.右边 － 寻找范围.左边)
                寻找范围.右边 ＝ 矩形范围.右边 － 寻找范围.左边
            .如果真结束
            .如果真 (寻找范围.底边 ＝ 0 或 寻找范围.底边 ＞ 矩形范围.底边 － 寻找范围.顶边)
                寻找范围.底边 ＝ 矩形范围.底边 － 寻找范围.顶边
            .如果真结束
            
        .如果真结束
        位图.从屏幕创建 (窗口坐标.横 ＋ 寻找范围.左边, 窗口坐标.纵 ＋ 寻找范围.顶边, 寻找范围.右边, 寻找范围.底边, 8)
    .判断结束
    保存位图1 ＝ 位图.取出颜色数据 ()
    宽1 ＝ 位图.取宽度2 ()
    高1 ＝ 位图.取高度2 ()
    宽1 ＝ 宽1 ＋ (4 － 宽1 ％ 4) ％ 4 ' 将宽补足4位
    
    .如果真 (位图.从数据创建 (目标图片) ＝ 假) ' 创建失败,直接返回
        返回 (找到坐标)
    .如果真结束
    位图.转换位深度 (8)
    保存位图2 ＝ 位图.取出颜色数据 ()
    宽2 ＝ 位图.取宽度2 ()
    高2 ＝ 位图.取高度2 ()
    补零2 ＝ (4 － 宽2 ％ 4) ％ 4
    清除数组 (保存位图集)
    .计次循环首 (高2, i)
        加入成员 (保存位图集, 取字节集中间 (保存位图2, (宽2 ＋ 补零2) × (i － 1) ＋ 1, 宽2))
    .计次循环尾 ()
    
    .循环判断首 ()
        找到位置 ＝ 寻找字节集 (保存位图1, 保存位图集 [1], 找到位置 ＋ 1)
        ' 输出调试文本 (找到位置)
        .如果真 (找到位置 ＝ -1)
            返回 (找到坐标)
        .如果真结束
        .计次循环首 (高2 － 1, i2)
            .如果 (取字节集中间 (保存位图1, 找到位置 ＋ 宽1 × i2, 宽2) ＝ 保存位图集 [i2 ＋ 1])
                .如果真 (i2 ＝ 高2 － 1)
                    找到坐标.横 ＝ (找到位置 － 1) ％ 宽1 ' 得到初始点坐标
                    找到坐标.纵 ＝ 高1 － (找到位置 － 1) ＼ 宽1 － 1
                    找到坐标.横 ＝ 找到坐标.横 ＋ 宽2 ＼ 2 ＋ 寻找范围.左边 ＋ 窗口坐标.横 ' 得到中心坐标
                    找到坐标.纵 ＝ 找到坐标.纵 － 高2 ＼ 2 ＋ 寻找范围.顶边 ＋ 窗口坐标.纵
                    返回 (找到坐标)
                .如果真结束
                
            .否则
                跳出循环 ()
            .如果结束
            
        .计次循环尾 ()
    .循环判断尾 (找到位置 ＞ 0)
    返回 (找到坐标)

.子程序 找图_从字节集, 精易_坐标, 公开, 在位图数据中找图片(返回找到的图片中心坐标,找不到返回-1坐标)，BUG命令谨慎使用
    .参数 范围图片, 字节集, , 默认为上次范围图片
    .参数 目标图片, 字节集, , 默认为上次目标图片
    .局部变量 找到坐标, 精易_坐标
    .局部变量 位图, 类_位图操作
    .局部变量 保存位图1, 字节集
    .局部变量 宽1, 整数型
    .局部变量 高1, 整数型
    .局部变量 保存位图2, 字节集
    .局部变量 保存位图集, 字节集, , "0"
    .局部变量 宽2, 整数型
    .局部变量 高2, 整数型
    .局部变量 补零2, 整数型
    .局部变量 i, 整数型
    .局部变量 找到位置, 整数型
    .局部变量 i2, 整数型

    找到坐标.横 ＝ -1
    找到坐标.纵 ＝ -1
    .如果真 (位图.从数据创建 (范围图片) ＝ 假)
        返回 (找到坐标)
    .如果真结束
    位图.转换位深度 (8)
    保存位图1 ＝ 位图.取出颜色数据 ()
    宽1 ＝ 位图.取宽度2 ()
    高1 ＝ 位图.取高度2 ()
    宽1 ＝ 宽1 ＋ (4 － 宽1 ％ 4) ％ 4 ' 将宽补足4位
    
    .如果真 (位图.从数据创建 (目标图片) ＝ 假)
        返回 (找到坐标)
    .如果真结束
    位图.转换位深度 (8)
    保存位图2 ＝ 位图.取出颜色数据 ()
    宽2 ＝ 位图.取宽度2 ()
    高2 ＝ 位图.取高度2 ()
    补零2 ＝ (4 － 宽2 ％ 4) ％ 4
    .计次循环首 (高2, i)
        加入成员 (保存位图集, 取字节集中间 (保存位图2, (宽2 ＋ 补零2) × (i － 1) ＋ 1, 宽2))
    .计次循环尾 ()
    .循环判断首 ()
        找到位置 ＝ 寻找字节集 (保存位图1, 保存位图集 [1], 找到位置 ＋ 1)
        .如果真 (找到位置 ＝ -1)
            返回 (找到坐标)
        .如果真结束
        .计次循环首 (高2 － 1, i2)
            .如果 (取字节集中间 (保存位图1, 找到位置 ＋ 宽1 × i2, 宽2) ＝ 保存位图集 [i2 ＋ 1])
                .如果真 (i2 ＝ 高2 － 1)
                    找到坐标.横 ＝ (找到位置 － 1) ％ 宽1 ' 得到初始点坐标
                    找到坐标.纵 ＝ 高1 － (找到位置 － 1) ＼ 宽1 － 1
                    找到坐标.横 ＝ 找到坐标.横 ＋ 宽2 ＼ 2 ' 得到中心坐标
                    找到坐标.纵 ＝ 找到坐标.纵 － 高2 ＼ 2
                    返回 (找到坐标)
                .如果真结束
                
            .否则
                跳出循环 ()
            .如果结束
            
        .计次循环尾 ()
    .循环判断尾 (找到位置 ＞ 0)
    返回 (找到坐标)

.子程序 找字_初始化, , 公开, 在使用 找字() 命令前,必须先初始化本命令
    .参数 要查找的文字, 文本型
    .参数 文字的颜色, 整数型
    .参数 文字的字体, 字体, 可空, 可空。默认：9号宋体

    LF内容 ＝ 要查找的文字
    LF颜色 ＝ 文字的颜色
    LF大小 ＝ 文字的字体.字体大小
    .如果 (文字的字体.加粗)
        LF加粗 ＝ 700
    .否则
        LF加粗 ＝ 400
    .如果结束
    LF斜体 ＝ 文字的字体.倾斜
    LF下划线 ＝ 文字的字体.下划线
    LF删除线 ＝ 文字的字体.删除线
    LF字体名称 ＝ 文字的字体.字体名称

.子程序 找字, 精易_坐标, 公开, 在屏幕或指定窗口上找字。使用此命令前，必须先使用 找字_初始化() 命令。成功返回找到的位置坐标，失败坐标返回-1。
    .参数 窗口句柄, 整数型, 可空, 可空。默认在屏幕中查找。
    .参数 寻找范围, 精易_矩形, 可空, 可空。可用 制作范围() 制作返回。留空为查找整个屏幕或窗口。
    .参数 误差值, 整数型, 可空, 可空。默认为0， 值：0-255。值越大，速度越慢。
    .参数 吻合值, 整数型, 可空, 可空。默认为完全吻合，值：0-100。建议设置在90以上。
    .参数 是否在后台, 逻辑型, 可空, 可空。默认为假，在当前屏幕中查找，真为后台窗口中查找。
    .局部变量 找到坐标, 精易_坐标
    .局部变量 位图, 类_位图操作
    .局部变量 相同点阵, 精易_坐标, , "0"
    .局部变量 不同点阵, 精易_坐标, , "0"
    .局部变量 窗口坐标, 精易_坐标
    .局部变量 矩形范围, 精易_矩形

    .如果 (是否在后台)
        位图.从窗口创建 (窗口句柄, 寻找范围.左边, 寻找范围.顶边, 寻找范围.右边, 寻找范围.底边, 8)
    .否则
        .如果真 (窗口句柄 ≠ 0)
            ClientToScreen (窗口句柄, 窗口坐标)
            GetClientRect (窗口句柄, 矩形范围)
            .如果真 (寻找范围.右边 ＝ 0 或 寻找范围.右边 ＞ 矩形范围.右边 － 寻找范围.左边)
                寻找范围.右边 ＝ 矩形范围.右边 － 寻找范围.左边
            .如果真结束
            .如果真 (寻找范围.底边 ＝ 0 或 寻找范围.底边 ＞ 矩形范围.底边 － 寻找范围.顶边)
                寻找范围.底边 ＝ 矩形范围.底边 － 寻找范围.顶边
            .如果真结束
            
        .如果真结束
        位图.从屏幕创建 (窗口坐标.横 ＋ 寻找范围.左边, 窗口坐标.纵 ＋ 寻找范围.顶边, 寻找范围.右边, 寻找范围.底边, 8)
    .如果结束
    取文字点阵 (相同点阵, 不同点阵)
    找到坐标 ＝ 找点阵 (位图.取出颜色数据 (), 位图.取宽度2 (), 位图.取高度2 (), 相同点阵, 不同点阵, 误差值, 吻合值)
    .如果真 (找到坐标.横 ＝ -1)
        返回 (找到坐标)
    .如果真结束
    找到坐标.横 ＝ 找到坐标.横 ＋ 寻找范围.左边 ＋ 窗口坐标.横
    找到坐标.纵 ＝ 找到坐标.纵 ＋ 寻找范围.顶边 ＋ 窗口坐标.纵
    返回 (找到坐标)

.子程序 找字_从字节集, 精易_坐标, 公开, 在指定的图片位图上寻找指定的文字。使用此命令前，必须先使用 找字_初始化() 命令。成功返回找到的位置坐标，失败坐标返回-1。
    .参数 位图数据, 字节集, , 欲被查找的图片
    .参数 误差值, 整数型, 可空, 可空。默认为0， 值：0-255。值越大，速度越慢。
    .参数 吻合值, 整数型, 可空, 可空。默认为完全吻合，值：0-100。建议设置在90以上。
    .局部变量 位图, 类_位图操作
    .局部变量 相同点阵, 精易_坐标, , "0"
    .局部变量 不同点阵, 精易_坐标, , "0"

    位图.从数据创建 (位图数据)
    .如果真 (位图.取位深度 () ≠ 8)
        位图.转换位深度 (8)
    .如果真结束
    取文字点阵 (相同点阵, 不同点阵)
    返回 (找点阵 (位图.取出颜色数据 (), 位图.取宽度2 (), 位图.取高度2 (), 相同点阵, 不同点阵, 误差值, 吻合值))

.子程序 找字_批量, 整数型, 公开, 在指定的图片位图上找出所有指定文字的坐标。使用此命令前，必须先使用 找字_初始化() 命令。成功返回坐标数组。
    .参数 坐标数组, 精易_坐标, 可空 数组, 请提供一个"精易_坐标"类型的变量数组，用于接收找到的坐标数组。
    .参数 位图数据, 字节集, , 欲被查找的图片
    .参数 误差值, 整数型, 可空, 可空。默认为0， 值：0-255。值越大，速度越慢。
    .参数 前景吻合度, 整数型, 可空, 可空。默认为完全吻合，值：0-100。建议设置在90以上。
    .参数 背景吻合度, 整数型, 可空, 可空。默认为完全吻合，值：0-100。建议设置在90以上。
    .局部变量 位图, 类_位图操作
    .局部变量 相同点阵, 精易_坐标, , "0"
    .局部变量 不同点阵, 精易_坐标, , "0"

    位图.从数据创建 (位图数据)
    .如果真 (位图.取位深度 () ≠ 8)
        位图.转换位深度 (8)
    .如果真结束
    取文字点阵 (相同点阵, 不同点阵)
    返回 (找点阵2 (坐标数组, 位图.取出颜色数据 (), 位图.取宽度2 (), 位图.取高度2 (), 相同点阵, 不同点阵, 误差值, 前景吻合度, 背景吻合度))

.子程序 取色, 整数型, 公开, 在屏幕或指定窗口上取出某点的颜色值，成功返回10进制颜色值。
    .参数 窗口句柄, 整数型, 可空, 可空。默认在屏幕中查找。
    .参数 水平位置, 整数型, , 目标横坐标
    .参数 垂直位置, 整数型, , 目标纵坐标
    .参数 是否在后台, 逻辑型, 可空, 可空。默认为假，在当前屏幕中查找，真为后台窗口中查找。
    .局部变量 位图, 类_位图操作
    .局部变量 坐标, 精易_坐标

    .如果 (是否在后台)
        位图.从窗口创建 (窗口句柄, 水平位置, 垂直位置, 1, 1, 24)
    .否则
        .如果真 (窗口句柄 ≠ 0)
            ClientToScreen (窗口句柄, 坐标)
        .如果真结束
        位图.从屏幕创建 (坐标.横 ＋ 水平位置, 坐标.纵 ＋ 垂直位置, 1, 1, 24)
    .如果结束
    返回 (位图.取某点颜色 (0, 0))

.子程序 找色, 精易_坐标, 公开, 在屏幕或指定窗口上找指定的颜色，成功返回此颜色的坐标，失败坐标返回为-1
    .参数 窗口句柄, 整数型, 可空, 可空。默认在屏幕中查找。
    .参数 要查找的颜色值, 整数型, , 要查找的颜色值
    .参数 寻找范围, 精易_矩形, 可空, 可空。可用 制作范围() 制作返回。留空为查找整个屏幕或窗口。
    .参数 误差值, 整数型, 可空, 可空。默认为0， 值：0-255。值越大，速度越慢。
    .参数 是否在后台, 逻辑型, 可空, 可空。默认为假，在当前屏幕中查找，真为后台窗口中查找。
    .局部变量 保存颜色值, 字节集
    .局部变量 找到位置, 整数型
    .局部变量 位图, 类_位图操作
    .局部变量 坐标, 精易_坐标
    .局部变量 实际宽, 整数型
    .局部变量 矩形范围, 精易_矩形

    保存颜色值 ＝ 到可用颜色2 (要查找的颜色值)
    .如果 (是否在后台)
        位图.从窗口创建 (窗口句柄, 寻找范围.左边, 寻找范围.顶边, 寻找范围.右边, 寻找范围.底边, 8)
    .否则
        .如果真 (窗口句柄 ≠ 0)
            ClientToScreen (窗口句柄, 坐标)
            GetClientRect (窗口句柄, 矩形范围)
            .如果真 (寻找范围.右边 ＝ 0 或 寻找范围.右边 ＞ 矩形范围.右边 － 寻找范围.左边)
                寻找范围.右边 ＝ 矩形范围.右边 － 寻找范围.左边
            .如果真结束
            .如果真 (寻找范围.底边 ＝ 0 或 寻找范围.底边 ＞ 矩形范围.底边 － 寻找范围.顶边)
                寻找范围.底边 ＝ 矩形范围.底边 － 寻找范围.顶边
            .如果真结束
            
        .如果真结束
        位图.从屏幕创建 (坐标.横 ＋ 寻找范围.左边, 坐标.纵 ＋ 寻找范围.顶边, 寻找范围.右边, 寻找范围.底边, 8)
    .如果结束
    坐标.横 ＝ -1
    坐标.纵 ＝ -1
    实际宽 ＝ 位图.取宽度2 ()
    实际宽 ＝ 实际宽 ＋ (4 － 实际宽 ％ 4) ％ 4 ' 将宽补足4位
    .如果 (误差值 ＝ 0)
        找到位置 ＝ 寻找字节集 (位图.取出颜色数据 (), 保存颜色值, 找到位置 ＋ 1)
    .否则
        找到位置 ＝ 寻找字节集_字节 (位图.取出颜色数据 (), 取字节集数据 (保存颜色值, #字节型, ), 误差值, 找到位置 ＋ 1)
    .如果结束
    .如果真 (找到位置 ≠ -1)
        坐标.横 ＝ (找到位置 － 1) ％ 实际宽
        坐标.纵 ＝ 位图.取高度2 () － (找到位置 － 1) ＼ 实际宽 － 1
    .如果真结束
    返回 (坐标)

.子程序 取出数值, 整数型, , 从标准数值的截图中取出它的数值(成功返回数值,失败返回-1)
    .参数 位图数据, 字节集, , 标准数值的截图(建议小图,不宜掺杂多余数字)
    .参数 颜色, 整数型, 可空, 默认为 #白色
    .参数 字体, 字体, 可空, 默认为9号宋体字
    .局部变量 位图, 类_位图操作
    .局部变量 字符表, 文本型, , "0"
    .局部变量 相同点阵, 精易_坐标, , "0"
    .局部变量 不同点阵, 精易_坐标, , "0"
    .局部变量 找到坐标, 精易_坐标, , "0"
    .局部变量 i, 整数型
    .局部变量 i2, 整数型
    .局部变量 位置, 整数型
    .局部变量 结果, 文本型, , "0"
    .局部变量 返回内容, 文本型

    位图.从数据创建 (位图数据)
    .如果真 (位图.取位深度 () ≠ 8)
        位图.转换位深度 (8)
    .如果真结束
    找字_初始化 (“”, 颜色, 字体)
    重定义数组 (结果, 假, 位图.取宽度2 ())
    字符表 ＝ { “0”, “1”, “2”, “3”, “4”, “5”, “6”, “7”, “8”, “9” }
    .计次循环首 (取数组成员数 (字符表), i)
        LF内容 ＝ 字符表 [i]
        取文字点阵 (相同点阵, 不同点阵)
        .计次循环首 (找点阵5 (找到坐标, 位图.取出颜色数据 (), 位图.取宽度2 (), 位图.取高度2 (), 相同点阵, 不同点阵), i2)
            位置 ＝ 找到坐标 [i2].横
            结果 [位置] ＝ 字符表 [i]
        .计次循环尾 ()
    .计次循环尾 ()
    .计次循环首 (取数组成员数 (结果), i)
        .如果真 (结果 [i] ≠ “”)
            返回内容 ＝ 返回内容 ＋ 结果 [i]
        .如果真结束
        
    .计次循环尾 ()
    .如果真 (返回内容 ＝ “”)
        返回 (-1)
    .如果真结束
    返回 (到数值 (返回内容))

.子程序 高级找色, 精易_坐标, , 在位图数据中找颜色(返回找到的颜色所在位图中的坐标,找不到返回-1坐标)
    .参数 位图数据, 字节集, 可空, 非首次查找可将本参数留空,表示采用上次的位图数据
    .参数 颜色值, 整数型, 可空, 非首次查找可将本参数留空,可接着上次找到的点往下找
    .参数 误差, 整数型, 可空, 默认为0 表示最低误差值 最大值为255,建议0-10之间
    .局部变量 保存位图, 字节集, 静态
    .局部变量 保存颜色值, 字节集, 静态
    .局部变量 找到位置, 整数型, 静态
    .局部变量 宽, 整数型, 静态
    .局部变量 高, 整数型, 静态
    .局部变量 位图, 类_位图操作
    .局部变量 坐标, 精易_坐标

    .如果真 (是否为空 (颜色值) ＝ 假)
        保存颜色值 ＝ 到可用颜色2 (颜色值)
        找到位置 ＝ 0
    .如果真结束
    .如果真 (位图数据 ≠ { })
        位图.从数据创建 (位图数据)
        位图.转换位深度 (8)
        保存位图 ＝ 位图.取出颜色数据 ()
        宽 ＝ 位图.取宽度2 ()
        高 ＝ 位图.取高度2 ()
        宽 ＝ 宽 ＋ (4 － 宽 ％ 4) ％ 4 ' 将宽补足4位
    .如果真结束
    坐标.横 ＝ -1
    坐标.纵 ＝ -1
    .如果 (误差 ＝ 0)
        找到位置 ＝ 寻找字节集 (保存位图, 保存颜色值, 找到位置 ＋ 1)
    .否则
        找到位置 ＝ 寻找字节集_字节 (保存位图, 取字节集数据 (保存颜色值, #字节型, ), 误差, 找到位置 ＋ 1)
    .如果结束
    .如果真 (找到位置 ≠ -1)
        坐标.横 ＝ (找到位置 － 1) ％ 宽
        坐标.纵 ＝ 高 － (找到位置 － 1) ＼ 宽 － 1
    .如果真结束
    返回 (坐标)

.子程序 高级找图, 精易_坐标, , 在位图数据中找图片(返回找到的图片左下角第一个有效点的坐标,找不到返回-1坐标)
    .参数 范围图片, 字节集, 可空, 默认为上次范围图片
    .参数 目标图片, 字节集, 可空, 默认为上次目标图片 (建议使用10*10以内位图)
    .参数 透明色, 整数型, 可空, 目标图片中欲被忽略的颜色值  默认为-1 如果目标图片为空,为上次透明色
    .参数 吻合度, 整数型, 可空, 默认为100完全吻合 相吻合的百分比(0-100之间)建议90以上
    .参数 误差值, 整数型, 可空, 默认为0 表示最低误差值 最大值为255,建议0-10之间
    .局部变量 找到坐标, 精易_坐标
    .局部变量 位图, 类_位图操作
    .局部变量 保存位图1, 字节集, 静态
    .局部变量 宽1, 整数型, 静态
    .局部变量 高1, 整数型, 静态
    .局部变量 基色, 整数型, 静态
    .局部变量 颜色点阵, 点阵型, 静态, "0"

    找到坐标.横 ＝ -1
    找到坐标.纵 ＝ -1
    .如果 (范围图片 ≠ { })
        保存位图1 ＝ { }
        .如果真 (位图.从数据创建 (范围图片) ＝ 假)
            返回 (找到坐标)
        .如果真结束
        位图.转换位深度 (8)
        保存位图1 ＝ 位图.取出颜色数据 ()
        宽1 ＝ 位图.取宽度2 ()
        高1 ＝ 位图.取高度2 ()
    .否则
        .如果真 (保存位图1 ＝ { })
            返回 (找到坐标)
        .如果真结束
        
    .如果结束
    .如果真 (是否为空 (透明色))
        透明色 ＝ -1
    .如果真结束
    .如果真 (是否为空 (目标图片) ＝ 假)
        基色 ＝ 取图片点阵 (目标图片, 透明色, 颜色点阵)
    .如果真结束
    .如果真 (基色 ＝ -1)
        返回 (找到坐标)
    .如果真结束
    返回 (找点阵3 (保存位图1, 宽1, 高1, 颜色点阵, 基色, 误差值, 吻合度))

.子程序 高级找图2, 整数型, , 在位图数据中找出图片所有坐标点(返回找到的图片数目,找不到返回0)
    .参数 找到坐标, 精易_坐标, 可空 数组, 返回所有找到的(图片左下角第一个有效点的坐标)坐标数组
    .参数 范围图片, 字节集, 可空, 默认为上次范围图片
    .参数 目标图片, 字节集, 可空, 默认为上次目标图片 (建议使用10*10以内位图)
    .参数 透明色, 整数型, 可空, 目标图片中欲被忽略的颜色值  默认为-1 如果目标图片为空,为上次透明色
    .参数 吻合度, 整数型, 可空, 默认为100完全吻合 相吻合的百分比(0-100之间)建议90以上
    .参数 误差值, 整数型, 可空, 默认为0 表示最低误差值 最大值为255,建议0-10之间
    .局部变量 位图, 类_位图操作
    .局部变量 保存位图1, 字节集, 静态
    .局部变量 宽1, 整数型, 静态
    .局部变量 高1, 整数型, 静态
    .局部变量 基色, 整数型, 静态
    .局部变量 颜色点阵, 点阵型, 静态, "0"

    .如果 (范围图片 ≠ { })
        保存位图1 ＝ { }
        .如果真 (位图.从数据创建 (范围图片) ＝ 假)
            返回 (0)
        .如果真结束
        位图.转换位深度 (8)
        保存位图1 ＝ 位图.取出颜色数据 ()
        宽1 ＝ 位图.取宽度2 ()
        高1 ＝ 位图.取高度2 ()
    .否则
        .如果真 (保存位图1 ＝ { })
            返回 (0)
        .如果真结束
        
    .如果结束
    .如果真 (是否为空 (透明色))
        透明色 ＝ -1
    .如果真结束
    .如果真 (是否为空 (目标图片) ＝ 假)
        基色 ＝ 取图片点阵 (目标图片, 透明色, 颜色点阵)
    .如果真结束
    .如果真 (基色 ＝ -1)
        返回 (0)
    .如果真结束
    返回 (找点阵4 (找到坐标, 保存位图1, 宽1, 高1, 颜色点阵, 基色, 误差值, 吻合度))

.子程序 高级精确找图2, 整数型, , 在位图数据中找出图片所有坐标点(返回找到的图片数目,找不到返回0)
    .参数 找到坐标, 精易_坐标, 可空 数组, 返回所有找到的(图片中心)坐标数组
    .参数 范围图片, 字节集, 可空, 默认为上次范围图片
    .参数 目标图片, 字节集, 可空, 默认为上次目标图片
    .局部变量 临时坐标, 精易_坐标
    .局部变量 位图, 类_位图操作
    .局部变量 保存位图1, 字节集, 静态
    .局部变量 宽1, 整数型, 静态
    .局部变量 高1, 整数型, 静态
    .局部变量 保存位图2, 字节集, 静态
    .局部变量 保存位图集, 字节集, 静态, "0"
    .局部变量 宽2, 整数型, 静态
    .局部变量 高2, 整数型, 静态
    .局部变量 补零2, 整数型, 静态
    .局部变量 保存忽略色, 整数型, 静态
    .局部变量 i, 整数型
    .局部变量 找到位置, 整数型
    .局部变量 i2, 整数型

    .如果 (范围图片 ≠ { })
        保存位图1 ＝ { }
        .如果真 (位图.从数据创建 (范围图片) ＝ 假)
            返回 (0)
        .如果真结束
        位图.转换位深度 (8)
        保存位图1 ＝ 位图.取出颜色数据 ()
        宽1 ＝ 位图.取宽度2 ()
        高1 ＝ 位图.取高度2 ()
        宽1 ＝ 宽1 ＋ (4 － 宽1 ％ 4) ％ 4 ' 将宽补足4位
    .否则
        .如果真 (保存位图1 ＝ { })
            返回 (0)
        .如果真结束
        
    .如果结束
    .如果 (目标图片 ≠ { })
        保存位图2 ＝ { }
        .如果真 (位图.从数据创建 (目标图片) ＝ 假)
            返回 (0)
        .如果真结束
        位图.转换位深度 (8)
        保存位图2 ＝ 位图.取出颜色数据 ()
        宽2 ＝ 位图.取宽度2 ()
        高2 ＝ 位图.取高度2 ()
        补零2 ＝ (4 － 宽2 ％ 4) ％ 4
        清除数组 (保存位图集)
        .计次循环首 (高2, i)
            加入成员 (保存位图集, 取字节集中间 (保存位图2, (宽2 ＋ 补零2) × (i － 1) ＋ 1, 宽2))
        .计次循环尾 ()
    .否则
        .如果真 (保存位图2 ＝ { })
            返回 (0)
        .如果真结束
        
    .如果结束
    
    .循环判断首 ()
        找到位置 ＝ 寻找字节集 (保存位图1, 保存位图集 [1], 找到位置 ＋ 1)
        ' 输出调试文本 (找到位置)
        .如果真 (找到位置 ＝ -1)
            跳出循环 ()
        .如果真结束
        .计次循环首 (高2 － 1, i2)
            .如果 (取字节集中间 (保存位图1, 找到位置 ＋ 宽1 × i2, 宽2) ＝ 保存位图集 [i2 ＋ 1])
                .如果真 (i2 ＝ 高2 － 1)
                    临时坐标.横 ＝ (找到位置 － 1) ％ 宽1 ' 得到初始点坐标
                    临时坐标.纵 ＝ 高1 － (找到位置 － 1) ＼ 宽1 － 1
                    临时坐标.横 ＝ 临时坐标.横 ＋ 宽2 ＼ 2 ' 得到中心坐标
                    临时坐标.纵 ＝ 临时坐标.纵 － 高2 ＼ 2
                    加入成员 (找到坐标, 临时坐标)
                .如果真结束
                
            .否则
                跳出循环 ()
            .如果结束
            
        .计次循环尾 ()
    .循环判断尾 (找到位置 ＞ 0)
    返回 (取数组成员数 (找到坐标))

.子程序 到可用颜色, 整数型
    .参数 颜色值, 整数型
    .局部变量 位图, 类_位图操作

    ' 0.299R 0.587G 0.114B
    位图.创建空白位图 (1, 1, 32)
    位图.置某点颜色 (0, 0, 颜色值)
    位图.转换位深度 (8)
    返回 (取字节集数据 (位图.取出颜色数据 (), #字节型, 1))

.子程序 到可用颜色2, 字节集
    .参数 颜色值, 整数型
    .局部变量 位图, 类_位图操作

    位图.创建空白位图 (1, 1, 32)
    位图.置某点颜色 (0, 0, 颜色值)
    位图.转换位深度 (8)
    返回 (取字节集左边 (位图.取出颜色数据 (), 1))

.子程序 到可用图片, 字节集, , <用不到,仅作参考>
    .参数 图片数据, 字节集
    .局部变量 位图, 类_位图操作

    位图.从数据创建 (图片数据)
    位图.转换位深度 (8)
    返回 (位图.取出颜色数据 ())

.子程序 寻找字节集_字节, 整数型
    .参数 字节集, 字节集
    .参数 字节, 整数型
    .参数 误差, 整数型
    .参数 起始位置, 整数型, 可空
    .局部变量 i, 整数型

    .计次循环首 (取字节集长度 (字节集), i)
        .如果真 (取绝对值 (字节集 [i] － 字节) ≤ 误差 且 i ≥ 起始位置)
            返回 (i)
        .如果真结束
        
    .计次循环尾 ()
    返回 (-1)

.子程序 寻找字节集3, 整数型, , 返回一字节集在另一字节集中最先出现的位置，位置值从 1 开始。如果未找到，返回 -1
    .参数 被搜寻的字节集, 字节集
    .参数 欲寻找的字节集, 字节集
    .参数 起始寻找位置, 整数型, 可空, 可空为1
    .参数 忽略值, 整数型, 可空, 欲寻找的字节集中,被忽略的字节值
    .参数 误差值, 整数型, 可空, 寻找字节集的误差值 每个字节(0-255)所允许的最大差值
    .局部变量 计次1, 整数型
    .局部变量 长度, 整数型
    .局部变量 计次2, 整数型
    .局部变量 总长度, 整数型

    .如果真 (起始寻找位置 ＜ 1)
        起始寻找位置 ＝ 1
    .如果真结束
    长度 ＝ 取字节集长度 (欲寻找的字节集)
    总长度 ＝ 取字节集长度 (被搜寻的字节集)
    .如果 (忽略值 ＝ -1)
        .如果 (误差值 ＝ 0)
            返回 (寻找字节集 (被搜寻的字节集, 欲寻找的字节集, 起始寻找位置))
        .否则
            .计次循环首 (总长度 － 长度 ＋ 1, 计次1)
                .如果真 (计次1 ≥ 起始寻找位置 且 取绝对值 (欲寻找的字节集 [1] － 被搜寻的字节集 [计次1]) ≤ 误差值)
                    计次2 ＝ 1
                    .循环判断首 () ' 循环判断比计次循环效率要高得多
                        .如果真 (计次2 ＝ 长度)
                            返回 (计次1)
                        .如果真结束
                        计次2 ＝ 计次2 ＋ 1
                    .循环判断尾 (取绝对值 (欲寻找的字节集 [计次2] － 被搜寻的字节集 [计次1 ＋ 计次2 － 1]) ≤ 误差值)
                .如果真结束
                
            .计次循环尾 ()
        .如果结束
        
    .否则
        .如果 (误差值 ＝ 0)
            .计次循环首 (总长度 － 长度 ＋ 1, 计次1)
                .如果真 (计次1 ≥ 起始寻找位置 且 欲寻找的字节集 [1] ＝ 被搜寻的字节集 [计次1])
                    计次2 ＝ 1
                    .循环判断首 () ' 循环判断比计次循环效率要高得多
                        .如果真 (计次2 ＝ 长度)
                            返回 (计次1)
                        .如果真结束
                        计次2 ＝ 计次2 ＋ 1
                    .循环判断尾 (忽略值 ＝ 欲寻找的字节集 [计次2] 或 欲寻找的字节集 [计次2] ＝ 被搜寻的字节集 [计次1 ＋ 计次2 － 1])
                .如果真结束
                
            .计次循环尾 ()
        .否则
            .计次循环首 (总长度 － 长度 ＋ 1, 计次1)
                .如果真 (计次1 ≥ 起始寻找位置)
                    计次2 ＝ 1
                    .判断循环首 (忽略值 ＝ 欲寻找的字节集 [计次2] 或 取绝对值 (欲寻找的字节集 [计次2] － 被搜寻的字节集 [计次1 ＋ 计次2 － 1]) ≤ 误差值)
                        .如果真 (计次2 ＝ 长度)
                            返回 (计次1)
                        .如果真结束
                        计次2 ＝ 计次2 ＋ 1
                    .判断循环尾 ()
                .如果真结束
                
            .计次循环尾 ()
        .如果结束
        
    .如果结束
    返回 (-1)

.子程序 是否吻合, 逻辑型, , 判断两段同长度字节集是否相似
    .参数 字节集1, 字节集
    .参数 字节集2, 字节集, , 忽略值
    .参数 忽略值, 整数型, , -1
    .参数 误差值, 整数型, , 0-255之间,0为必须完全吻合
    .局部变量 长, 整数型
    .局部变量 I, 整数型

    长 ＝ 取字节集长度 (字节集1)
    .如果真 (取字节集长度 (字节集2) ≠ 长)
        返回 (假)
    .如果真结束
    
    .如果 (忽略值 ＝ -1)
        .如果 (误差值 ＝ 0)
            .计次循环首 (长, I)
                .如果真 (字节集1 [I] ≠ 字节集2 [I])
                    返回 (假)
                .如果真结束
                
            .计次循环尾 ()
        .否则
            .计次循环首 (长, I)
                .如果真 (取绝对值 (字节集1 [I] － 字节集2 [I]) ＞ 误差值)
                    返回 (假)
                .如果真结束
                
            .计次循环尾 ()
        .如果结束
        
    .否则
        .如果 (误差值 ＝ 0)
            .计次循环首 (长, I)
                .如果真 (忽略值 ≠ 字节集2 [I] 且 字节集1 [I] ≠ 字节集2 [I])
                    返回 (假)
                .如果真结束
                
            .计次循环尾 ()
        .否则
            .计次循环首 (长, I)
                .如果真 (忽略值 ≠ 字节集2 [I] 且 取绝对值 (字节集1 [I] － 字节集2 [I]) ＞ 误差值)
                    返回 (假)
                .如果真结束
                
            .计次循环尾 ()
        .如果结束
        
    .如果结束
    返回 (真)

.子程序 取文字点阵
    .参数 前景偏移点, 精易_坐标, 参考 可空 数组
    .参数 背景偏移点, 精易_坐标, 参考 可空 数组
    .局部变量 点, 精易_坐标
    .局部变量 基点, 精易_坐标
    .局部变量 hdc, 整数型
    .局部变量 场景句柄, 整数型
    .局部变量 高, 整数型
    .局部变量 hf, 整数型
    .局部变量 h, 整数型
    .局部变量 hbk, 整数型
    .局部变量 htext, 整数型
    .局部变量 x, 整数型
    .局部变量 y, 整数型
    .局部变量 位图句柄, 整数型

    清除数组 (前景偏移点)
    清除数组 (背景偏移点)
    hdc ＝ GetDC (0)
    高 ＝ LF大小 × GetDeviceCaps (hdc, 90) ÷ 72
    场景句柄 ＝ CreateCompatibleDC (hdc)
    位图句柄 ＝ CreateCompatibleBitmap (hdc, 高 × 取文本长度 (LF内容) ＼ 2, 高)
    SelectObject (场景句柄, 位图句柄)
    hf ＝ CreateFontA (高, 0, 0, 0, LF加粗, LF斜体, LF下划线, LF删除线, 134, 0, 0, 0, 0, LF字体名称)
    h ＝ SelectObject (场景句柄, hf)
    hbk ＝ SetBkMode (场景句柄, 1)
    htext ＝ SetTextColor (场景句柄, 255)
    TextOutA (场景句柄, 0, 0, LF内容, 取文本长度 (LF内容))
    SetBkMode (场景句柄, hbk)
    SetTextColor (场景句柄, htext)
    SelectObject (场景句柄, h)
    DeleteObject (hf)
    基点.横 ＝ -1
    .计次循环首 (高, y)
        .计次循环首 (高 × 取文本长度 (LF内容) ＼ 2, x)
            .如果 (基点.横 ＝ -1)
                .如果真 (GetPixel (场景句柄, x － 1, 高 － y) ＞ 0)
                    基点.横 ＝ x － 1
                    基点.纵 ＝ 高 － y
                .如果真结束
                
            .否则
                点.横 ＝ x － 1 － 基点.横
                点.纵 ＝ 基点.纵 － (高 － y)
                .如果 (GetPixel (场景句柄, x － 1, 高 － y) ＞ 0)
                    加入成员 (前景偏移点, 点)
                .否则
                    加入成员 (背景偏移点, 点)
                .如果结束
                
            .如果结束
            
        .计次循环尾 ()
    .计次循环尾 ()
    .计次循环首 (高, y)
        .计次循环首 (高 × 取文本长度 (LF内容) ＼ 2, x)
            .如果真 (GetPixel (场景句柄, x － 1, 高 － y) ＞ 0)
                跳出循环 ()
            .如果真结束
            点.横 ＝ x － 1 － 基点.横
            点.纵 ＝ 基点.纵 － (高 － y)
            加入成员 (背景偏移点, 点)
        .计次循环尾 ()
        .如果真 (基点.纵 ＝ 高 － y)
            .如果真 (基点.横 ＝ x － 1)
                跳出循环 ()
            .如果真结束
            
        .如果真结束
        
    .计次循环尾 ()
    DeleteDC (场景句柄)
    ReleaseDC (0, hdc)

.子程序 取图片点阵, 整数型, , 成功返回255基点颜色,失败返回-1
    .参数 目标图片, 字节集
    .参数 透明色, 整数型, 参考, 返回255颜色值,无透明色-1
    .参数 前景偏移点, 点阵型, 参考 数组
    .局部变量 位图, 类_位图操作
    .局部变量 颜色数据, 字节集
    .局部变量 宽, 整数型
    .局部变量 高, 整数型
    .局部变量 补零, 整数型
    .局部变量 临时字节集, 字节集
    .局部变量 y, 整数型
    .局部变量 x, 整数型
    .局部变量 临时偏移点, 点阵型
    .局部变量 基点, 点阵型

    .如果真 (位图.从数据创建 (目标图片) ＝ 假)
        返回 (-1)
    .如果真结束
    位图.转换位深度 (8)
    颜色数据 ＝ 位图.取出颜色数据 ()
    宽 ＝ 位图.取宽度2 ()
    高 ＝ 位图.取高度2 ()
    补零 ＝ (4 － 宽 ％ 4) ％ 4
    .如果真 (透明色 ≠ -1)
        透明色 ＝ 到可用颜色 (透明色)
    .如果真结束
    基点.z ＝ -1
    .计次循环首 (高, y)
        临时字节集 ＝ 取字节集中间 (颜色数据, (宽 ＋ 补零) × (y － 1) ＋ 1, 宽)
        .计次循环首 (宽, x)
            .如果真 (临时字节集 [x] ≠ 透明色)
                .如果 (基点.z ＝ -1)
                    基点.x ＝ x － 1
                    基点.y ＝ 高 － y
                    基点.z ＝ 临时字节集 [x]
                .否则
                    临时偏移点.x ＝ x － 1 － 基点.x
                    临时偏移点.y ＝ 基点.y － (高 － y)
                    临时偏移点.z ＝ 临时字节集 [x]
                    加入成员 (前景偏移点, 临时偏移点)
                    ' 输出调试文本 (临时偏移点.z)
                .如果结束
                
            .如果真结束
            处理事件 ()
        .计次循环尾 ()
    .计次循环尾 ()
    返回 (基点.z)

.子程序 找点阵, 精易_坐标, , 找字
    .参数 数据, 字节集
    .参数 宽, 整数型
    .参数 高, 整数型
    .参数 点阵, 精易_坐标, 数组
    .参数 不同点阵, 精易_坐标, 数组
    .参数 误差值, 整数型, , 默认为精确找色,可指定误差0-255,建议在20点误差以内
    .参数 符合程度, 整数型, , 默认为90  100 完全相吻合  80 百分之80像素点相吻合 
    .局部变量 颜色值, 整数型
    .局部变量 找到坐标, 精易_坐标
    .局部变量 总长, 整数型
    .局部变量 i, 整数型
    .局部变量 i2, 整数型
    .局部变量 i3, 整数型
    .局部变量 i4, 整数型
    .局部变量 行字节集, 字节集
    .局部变量 位置, 整数型
    .局部变量 吻合值, 整数型
    .局部变量 已吻合值, 整数型
    .局部变量 不吻合值, 整数型
    .局部变量 临时颜色值, 整数型
    .局部变量 补零, 字节型

    找到坐标.横 ＝ -1
    找到坐标.纵 ＝ -1
    总长 ＝ 取字节集长度 (数据)
    颜色值 ＝ 到可用颜色 (LF颜色)
    .如果 (符合程度 ＝ 0)
        吻合值 ＝ 取数组成员数 (点阵) × 100 ＼ 100
        不吻合值 ＝ 取数组成员数 (不同点阵) × 100 ＼ 100
    .否则
        吻合值 ＝ 取数组成员数 (点阵) × 符合程度 ＼ 100
        不吻合值 ＝ 取数组成员数 (不同点阵) × 符合程度 ＼ 100
    .如果结束
    补零 ＝ (4 － 宽 ％ 4) ％ 4
    .计次循环首 (高, i)
        行字节集 ＝ 取字节集中间 (数据, 1 ＋ (宽 ＋ 补零) × (i － 1), 宽)
        .计次循环首 (宽, i2)
            .如果真 (取绝对值 (行字节集 [i2] － 颜色值) ≤ 误差值)
                已吻合值 ＝ 0
                .计次循环首 (取数组成员数 (点阵), i3)
                    位置 ＝ i2 ＋ 点阵 [i3].横 － 1 ' 这是X位置
                    .如果真 (位置 ＞ 宽) ' 偏移点超出范围
                        ' 输出调试文本 (“超出”)
                        跳出循环 ()
                    .如果真结束
                    位置 ＝ (宽 ＋ 补零) × (点阵 [i3].纵 ＋ i － 1) ＋ 位置 ＋ 1
                    .如果真 (总长 ＜ 位置)
                        ' 输出调试文本 (“超出2”)
                        跳出循环 ()
                    .如果真结束
                    .如果真 (取绝对值 (数据 [位置] － 行字节集 [i2]) ≤ 误差值)
                        已吻合值 ＝ 已吻合值 ＋ 1
                        临时颜色值 ＝ 行字节集 [i2]
                        .如果真 (已吻合值 ≥ 吻合值)
                            .如果真 (取数组成员数 (不同点阵) ＝ 0)
                                ' 输出调试文本 (当前吻合值)
                                找到坐标.横 ＝ i2 － 1
                                找到坐标.纵 ＝ 高 － i
                                返回 (找到坐标)
                            .如果真结束
                            已吻合值 ＝ 0
                            .计次循环首 (取数组成员数 (不同点阵), i4) ' 判断文字以外点与文字颜色不同,防止找到的是色块不是文字!!
                                位置 ＝ i2 ＋ 不同点阵 [i4].横 － 1
                                .如果真 (位置 ＞ 宽)
                                    跳出循环 ()
                                .如果真结束
                                位置 ＝ 1 ＋ (宽 ＋ 补零) × (不同点阵 [i4].纵 ＋ i － 1) ＋ 位置
                                .如果真 (总长 ＜ 位置 ＋ 2)
                                    跳出循环 ()
                                .如果真结束
                                .如果真 (数据 [位置] ＝ 临时颜色值)
                                    到循环尾 ()
                                .如果真结束
                                已吻合值 ＝ 已吻合值 ＋ 1
                                .如果真 (已吻合值 ≥ 不吻合值)
                                    找到坐标.横 ＝ i2 － 1
                                    找到坐标.纵 ＝ 高 － i
                                    返回 (找到坐标)
                                .如果真结束
                                
                            .计次循环尾 ()
                            跳出循环 ()
                        .如果真结束
                        
                    .如果真结束
                    
                .计次循环尾 ()
            .如果真结束
            处理事件 ()
        .计次循环尾 ()
    .计次循环尾 ()
    返回 (找到坐标)

.子程序 找点阵2, 整数型, , 找所有字
    .参数 坐标组, 精易_坐标, 可空 数组
    .参数 数据, 字节集
    .参数 宽, 整数型
    .参数 高, 整数型
    .参数 点阵, 精易_坐标, 数组
    .参数 不同点阵, 精易_坐标, 数组
    .参数 误差值, 整数型, , 默认为精确找色,可指定误差0-255,建议在20点误差以内
    .参数 符合程度, 整数型, , 默认为90  100 完全相吻合  80 百分之80像素点相吻合 
    .参数 符合程度2, 整数型
    .局部变量 颜色值, 整数型
    .局部变量 找到坐标, 精易_坐标
    .局部变量 总长, 整数型
    .局部变量 i, 整数型
    .局部变量 i2, 整数型
    .局部变量 i3, 整数型
    .局部变量 i4, 整数型
    .局部变量 行字节集, 字节集
    .局部变量 位置, 整数型
    .局部变量 吻合值, 整数型
    .局部变量 已吻合值, 整数型
    .局部变量 不吻合值, 整数型
    .局部变量 临时颜色值, 整数型
    .局部变量 补零, 字节型

    清除数组 (坐标组)
    找到坐标.横 ＝ -1
    找到坐标.纵 ＝ -1
    总长 ＝ 取字节集长度 (数据)
    颜色值 ＝ 到可用颜色 (LF颜色)
    .如果 (符合程度 ＝ 0)
        吻合值 ＝ 取数组成员数 (点阵) × 100 ＼ 100
    .否则
        吻合值 ＝ 取数组成员数 (点阵) × 符合程度 ＼ 100
    .如果结束
    .如果 (符合程度2 ＝ 0)
        不吻合值 ＝ 取数组成员数 (不同点阵) × 100 ＼ 100
    .否则
        不吻合值 ＝ 取数组成员数 (不同点阵) × 符合程度2 ＼ 100
    .如果结束
    补零 ＝ (4 － 宽 ％ 4) ％ 4
    .计次循环首 (高, i)
        行字节集 ＝ 取字节集中间 (数据, 1 ＋ (宽 ＋ 补零) × (i － 1), 宽)
        .计次循环首 (宽, i2)
            .如果真 (取绝对值 (行字节集 [i2] － 颜色值) ≤ 误差值)
                已吻合值 ＝ 0
                .计次循环首 (取数组成员数 (点阵), i3)
                    位置 ＝ i2 ＋ 点阵 [i3].横 － 1 ' 这是X位置
                    .如果真 (位置 ＞ 宽) ' 偏移点超出范围
                        跳出循环 ()
                    .如果真结束
                    位置 ＝ (宽 ＋ 补零) × (点阵 [i3].纵 ＋ i － 1) ＋ 位置 ＋ 1
                    .如果真 (总长 ＜ 位置)
                        跳出循环 ()
                    .如果真结束
                    .如果真 (取绝对值 (数据 [位置] － 行字节集 [i2]) ≤ 误差值)
                        已吻合值 ＝ 已吻合值 ＋ 1
                        临时颜色值 ＝ 行字节集 [i2]
                        .如果真 (已吻合值 ≥ 吻合值)
                            .如果真 (取数组成员数 (不同点阵) ＝ 0)
                                找到坐标.横 ＝ i2 － 1
                                找到坐标.纵 ＝ 高 － i
                                加入成员 (坐标组, 找到坐标)
                                跳出循环 ()
                            .如果真结束
                            已吻合值 ＝ 0
                            .计次循环首 (取数组成员数 (不同点阵), i4) ' 判断文字以外点与文字颜色不同,防止找到的是色块不是文字!!
                                位置 ＝ i2 ＋ 不同点阵 [i4].横 － 1
                                .如果真 (位置 ＞ 宽)
                                    跳出循环 ()
                                .如果真结束
                                位置 ＝ 1 ＋ (宽 ＋ 补零) × (不同点阵 [i4].纵 ＋ i － 1) ＋ 位置
                                .如果真 (总长 ＜ 位置 ＋ 2)
                                    跳出循环 ()
                                .如果真结束
                                .如果真 (数据 [位置] ＝ 临时颜色值)
                                    到循环尾 ()
                                .如果真结束
                                已吻合值 ＝ 已吻合值 ＋ 1
                                .如果真 (已吻合值 ≥ 不吻合值)
                                    找到坐标.横 ＝ i2 － 1
                                    找到坐标.纵 ＝ 高 － i
                                    加入成员 (坐标组, 找到坐标)
                                    跳出循环 ()
                                .如果真结束
                                
                            .计次循环尾 ()
                            跳出循环 ()
                        .如果真结束
                        
                    .如果真结束
                    
                .计次循环尾 ()
            .如果真结束
            处理事件 ()
        .计次循环尾 ()
    .计次循环尾 ()
    返回 (取数组成员数 (坐标组))

.子程序 找点阵3, 精易_坐标, , 找图
    .参数 数据, 字节集
    .参数 宽, 整数型
    .参数 高, 整数型
    .参数 点阵, 点阵型, 数组
    .参数 基色, 整数型
    .参数 误差值, 整数型, , 默认为精确找色,可指定误差0-255,建议在20点误差以内
    .参数 符合程度, 整数型, , 默认为90  100 完全相吻合  80 百分之80像素点相吻合 
    .局部变量 找到坐标, 精易_坐标
    .局部变量 总长, 整数型
    .局部变量 i, 整数型
    .局部变量 i2, 整数型
    .局部变量 i3, 整数型
    .局部变量 i4, 整数型
    .局部变量 行字节集, 字节集
    .局部变量 位置, 整数型
    .局部变量 吻合值, 整数型
    .局部变量 已吻合值, 整数型
    .局部变量 临时颜色值, 整数型
    .局部变量 补零, 字节型

    找到坐标.横 ＝ -1
    找到坐标.纵 ＝ -1
    总长 ＝ 取字节集长度 (数据)
    .如果 (符合程度 ＝ 0)
        吻合值 ＝ 取数组成员数 (点阵) × 100 ＼ 100
    .否则
        吻合值 ＝ 取数组成员数 (点阵) × 符合程度 ＼ 100
    .如果结束
    补零 ＝ (4 － 宽 ％ 4) ％ 4
    .计次循环首 (高, i)
        行字节集 ＝ 取字节集中间 (数据, 1 ＋ (宽 ＋ 补零) × (i － 1), 宽)
        .计次循环首 (宽, i2)
            .如果真 (取绝对值 (行字节集 [i2] － 基色) ≤ 误差值)
                已吻合值 ＝ 0
                .计次循环首 (取数组成员数 (点阵), i3)
                    位置 ＝ i2 ＋ 点阵 [i3].x － 1 ' 这是X位置
                    .如果真 (位置 ＞ 宽) ' 偏移点超出范围
                        跳出循环 ()
                    .如果真结束
                    位置 ＝ (宽 ＋ 补零) × (点阵 [i3].y ＋ i － 1) ＋ 位置 ＋ 1
                    .如果真 (总长 ＜ 位置)
                        跳出循环 ()
                    .如果真结束
                    .如果真 (取绝对值 (数据 [位置] － 点阵 [i3].z) ≤ 误差值)
                        已吻合值 ＝ 已吻合值 ＋ 1
                        临时颜色值 ＝ 行字节集 [i2]
                        .如果真 (已吻合值 ≥ 吻合值)
                            找到坐标.横 ＝ i2 － 1
                            找到坐标.纵 ＝ 高 － i
                            返回 (找到坐标)
                        .如果真结束
                        
                    .如果真结束
                    处理事件 ()
                .计次循环尾 ()
            .如果真结束
            处理事件 ()
        .计次循环尾 ()
    .计次循环尾 ()
    返回 (找到坐标)

.子程序 找点阵4, 整数型, , 找所有图
    .参数 所有坐标, 精易_坐标, 参考 数组
    .参数 数据, 字节集
    .参数 宽, 整数型
    .参数 高, 整数型
    .参数 点阵, 点阵型, 数组
    .参数 基色, 整数型
    .参数 误差值, 整数型, , 默认为精确找色,可指定误差0-255,建议在20点误差以内
    .参数 符合程度, 整数型, , 默认为90  100 完全相吻合  80 百分之80像素点相吻合 
    .局部变量 找到坐标, 精易_坐标
    .局部变量 总长, 整数型
    .局部变量 i, 整数型
    .局部变量 i2, 整数型
    .局部变量 i3, 整数型
    .局部变量 i4, 整数型
    .局部变量 行字节集, 字节集
    .局部变量 位置, 整数型
    .局部变量 吻合值, 整数型
    .局部变量 已吻合值, 整数型
    .局部变量 临时颜色值, 整数型
    .局部变量 补零, 字节型

    清除数组 (所有坐标)
    总长 ＝ 取字节集长度 (数据)
    .如果 (符合程度 ＝ 0)
        吻合值 ＝ 取数组成员数 (点阵) × 100 ＼ 100
    .否则
        吻合值 ＝ 取数组成员数 (点阵) × 符合程度 ＼ 100
    .如果结束
    补零 ＝ (4 － 宽 ％ 4) ％ 4
    .计次循环首 (高, i)
        行字节集 ＝ 取字节集中间 (数据, 1 ＋ (宽 ＋ 补零) × (i － 1), 宽)
        .计次循环首 (宽, i2)
            .如果真 (取绝对值 (行字节集 [i2] － 基色) ≤ 误差值)
                已吻合值 ＝ 0
                .计次循环首 (取数组成员数 (点阵), i3)
                    位置 ＝ i2 ＋ 点阵 [i3].x － 1 ' 这是X位置
                    .如果真 (位置 ＞ 宽) ' 偏移点超出范围
                        跳出循环 ()
                    .如果真结束
                    位置 ＝ (宽 ＋ 补零) × (点阵 [i3].y ＋ i － 1) ＋ 位置 ＋ 1
                    .如果真 (总长 ＜ 位置)
                        跳出循环 ()
                    .如果真结束
                    .如果真 (取绝对值 (数据 [位置] － 点阵 [i3].z) ≤ 误差值)
                        已吻合值 ＝ 已吻合值 ＋ 1
                        临时颜色值 ＝ 行字节集 [i2]
                        .如果真 (已吻合值 ≥ 吻合值)
                            ' 输出调试文本 (当前吻合值)
                            找到坐标.横 ＝ i2 － 1
                            找到坐标.纵 ＝ 高 － i
                            加入成员 (所有坐标, 找到坐标)
                            跳出循环 ()
                        .如果真结束
                        
                    .如果真结束
                    处理事件 ()
                .计次循环尾 ()
            .如果真结束
            处理事件 ()
        .计次循环尾 ()
    .计次循环尾 ()
    返回 (取数组成员数 (所有坐标))

.子程序 找点阵5, 整数型, , 快速找所有字
    .参数 坐标组, 精易_坐标, 可空 数组
    .参数 数据, 字节集
    .参数 宽, 整数型
    .参数 高, 整数型
    .参数 点阵, 精易_坐标, 数组
    .参数 不同点阵, 精易_坐标, 数组
    .局部变量 颜色值, 整数型
    .局部变量 找到坐标, 精易_坐标
    .局部变量 总长, 整数型
    .局部变量 i, 整数型
    .局部变量 i2, 整数型
    .局部变量 i3, 整数型
    .局部变量 i4, 整数型
    .局部变量 行字节集, 字节集
    .局部变量 位置, 整数型
    .局部变量 吻合值, 整数型
    .局部变量 已吻合值, 整数型
    .局部变量 不吻合值, 整数型
    .局部变量 临时颜色值, 整数型
    .局部变量 补零, 字节型

    清除数组 (坐标组)
    总长 ＝ 取字节集长度 (数据)
    颜色值 ＝ 到可用颜色 (LF颜色)
    吻合值 ＝ 取数组成员数 (点阵)
    不吻合值 ＝ 取数组成员数 (不同点阵)
    补零 ＝ (4 － 宽 ％ 4) ％ 4
    .计次循环首 (高, i)
        行字节集 ＝ 取字节集中间 (数据, 1 ＋ (宽 ＋ 补零) × (i － 1), 宽)
        .计次循环首 (宽, i2)
            .如果真 (行字节集 [i2] ＝ 颜色值)
                已吻合值 ＝ 0
                .计次循环首 (取数组成员数 (点阵), i3)
                    位置 ＝ i2 ＋ 点阵 [i3].横 － 1 ' 这是X位置
                    .如果真 (位置 ＞ 宽) ' 偏移点超出范围
                        跳出循环 ()
                    .如果真结束
                    位置 ＝ (宽 ＋ 补零) × (点阵 [i3].纵 ＋ i － 1) ＋ 位置 ＋ 1
                    .如果真 (总长 ＜ 位置)
                        跳出循环 ()
                    .如果真结束
                    .如果真 (数据 [位置] ＝ 行字节集 [i2])
                        已吻合值 ＝ 已吻合值 ＋ 1
                        临时颜色值 ＝ 行字节集 [i2]
                        .如果真 (已吻合值 ≥ 吻合值)
                            已吻合值 ＝ 0
                            .计次循环首 (取数组成员数 (不同点阵), i4) ' 判断文字以外点与文字颜色不同,防止找到的是色块不是文字!!
                                位置 ＝ i2 ＋ 不同点阵 [i4].横 － 1
                                .如果真 (位置 ＞ 宽)
                                    跳出循环 ()
                                .如果真结束
                                位置 ＝ 1 ＋ (宽 ＋ 补零) × (不同点阵 [i4].纵 ＋ i － 1) ＋ 位置
                                .如果真 (总长 ＜ 位置 ＋ 2)
                                    跳出循环 ()
                                .如果真结束
                                .如果真 (数据 [位置] ＝ 临时颜色值)
                                    到循环尾 ()
                                .如果真结束
                                已吻合值 ＝ 已吻合值 ＋ 1
                                .如果真 (已吻合值 ≥ 不吻合值)
                                    找到坐标.横 ＝ i2 － 1
                                    找到坐标.纵 ＝ 高 － i
                                    加入成员 (坐标组, 找到坐标)
                                    跳出循环 ()
                                .如果真结束
                                
                            .计次循环尾 ()
                            跳出循环 ()
                        .如果真结束
                        
                    .如果真结束
                    
                .计次循环尾 ()
            .如果真结束
            处理事件 ()
        .计次循环尾 ()
    .计次循环尾 ()
    返回 (取数组成员数 (坐标组))

.版本 2

.程序集 集_图片
.程序集变量 集_转换错误, 文本型

.子程序 图片_平铺拉伸, 字节集, 公开, 按指定宽高  平铺/拉伸  成功返回图片字节集  失败返回空字节集
    .参数 参_原图片, 字节集
    .参数 参_设定宽度, 整数型, 可空, 默认：1920
    .参数 参_设定高度, 整数型, 可空, 默认：1080
    .参数 参_处理类型, 整数型, 可空, 可空，默认0=平铺  1=拉伸
    .局部变量 底位图, 类_位图操作
    .局部变量 层位图, 类_位图操作
    .局部变量 局_原宽度, 整数型
    .局部变量 局_原高度, 整数型
    .局部变量 局_相差宽度, 整数型
    .局部变量 局_相差高度, 整数型
    .局部变量 局_原图, 字节集
    .局部变量 a, 整数型
    .局部变量 b, 整数型
    .局部变量 局_左边, 整数型
    .局部变量 局_剩余宽度, 整数型
    .局部变量 局_剩余高度, 整数型
    .局部变量 局_顶边, 整数型
    .局部变量 局_循环_横向, 整数型
    .局部变量 局_循环_纵向, 整数型
    .局部变量 局_新图片, 字节集
    .局部变量 i, 整数型

    .如果真 (图片_转换 (参_原图片, 1, , 局_原图, ) ＝ 假)
        输出调试文本 (“转换图片失败”)
        返回 ({ })
    .如果真结束
    
    
    .如果真 (参_设定宽度 ＝ 0)
        参_设定宽度 ＝ 1920
    .如果真结束
    
    .如果真 (参_设定高度 ＝ 0)
        参_设定高度 ＝ 1080
    .如果真结束
    
    
    
    .如果真 (层位图.从数据创建 (局_原图) ＝ 假)
        输出调试文本 (“创建创建层位图失败”)
        返回 ({ })
    .如果真结束
    
    局_原宽度 ＝ 层位图.取宽度 ()
    局_原高度 ＝ 层位图.取高度 ()
    
    .如果真 (参_处理类型 ＝ 0)
        .如果真 (参_设定宽度 ≤ 局_原宽度 或 参_设定高度 ≤ 局_原高度)
            输出调试文本 (“平铺模式下，设定的宽高需要大于原图片的宽高”)
            返回 ({ })
        .如果真结束
        
    .如果真结束
    
    
    .如果真 (底位图.创建空白位图 (参_设定宽度, 参_设定高度, 24) ＝ 假)
        输出调试文本 (“创建空白底位图失败”)
        返回 ({ })
    .如果真结束
    
    .判断开始 (参_处理类型 ＝ 0)
        局_相差宽度 ＝ 参_设定宽度 － 局_原宽度
        局_相差高度 ＝ 参_设定高度 － 局_原高度
        
        局_剩余宽度 ＝ 参_设定宽度 ％ 局_原宽度
        局_循环_横向 ＝ (参_设定宽度 － 局_剩余宽度) ÷ 局_原宽度
        
        局_剩余高度 ＝ 参_设定高度 ％ 局_原高度
        局_循环_纵向 ＝ (参_设定高度 － 局_剩余高度) ÷ 局_原高度
        
        
        局_左边 ＝ －局_原宽度
        .计次循环首 (局_循环_横向, a)
            局_左边 ＝ 局_左边 ＋ 局_原宽度
            层位图.复制到 (底位图, 0, 0, 局_原宽度, 局_原高度, 局_左边, 0) ' 横向平铺一张
            局_顶边 ＝ －局_原高度
            .计次循环首 (局_循环_纵向, a)
                局_顶边 ＝ 局_顶边 ＋ 局_原高度
                层位图.复制到 (底位图, 0, 0, 局_原宽度, 局_原高度, 局_左边, 局_顶边) ' 纵向平铺一张
                系统_处理事件 ()
            .计次循环尾 ()
            .如果真 (局_剩余高度 ≠ 0)
                层位图.复制到 (底位图, 0, 0, 局_原宽度, 局_剩余高度, 局_左边, 局_顶边 ＋ 局_原高度) ' 纵向剩余高度 再平铺一张
            .如果真结束
            
            系统_处理事件 ()
        .计次循环尾 ()
        
        .如果真 (局_剩余宽度 ≠ 0)
            局_顶边 ＝ －局_原高度
            .计次循环首 (局_循环_纵向, i)
                局_顶边 ＝ 局_顶边 ＋ 局_原高度
                层位图.复制到 (底位图, 0, 0, 局_剩余宽度, 局_原高度, 局_左边 ＋ 局_原宽度, 局_顶边) ' 补全剩余宽度的纵向一列
                系统_处理事件 ()
            .计次循环尾 ()
            .如果真 (局_剩余高度 ≠ 0)
                层位图.复制到 (底位图, 0, 0, 局_原宽度, 局_剩余高度, 局_左边 ＋ 局_原宽度, 局_顶边 ＋ 局_原高度) ' 纵向剩余高度 再平铺一张
            .如果真结束
            
        .如果真结束
        
        局_新图片 ＝ 底位图.取出位图数据 ()
    .默认
        局_新图片 ＝ 图片_缩放 (局_原图, 参_设定宽度, 参_设定高度, 真)
    .判断结束
    返回 (局_新图片)

.子程序 图片_到24位图, 字节集, 公开, 把非24位BMP、JPG、GIF的图片转化为24位图
    .参数 参_原图片, 字节集
    .参数 参_执行结果, 逻辑型, 参考 可空, 可以被省略，提供参数数据时只能提供变量。如果提供本参数，其中将被写入本命令的执行结果——执行成功时为真，执行失败时为假。
    .局部变量 局_图片对象, 对象
    .局部变量 局_图片, 字节集

    ' 例程收录自：https://bbs.125.la/forum.php?mod=redirect&goto=findpost&ptid=13978978&pid=10764012
    .如果真 (取字节集左边 (参_原图片, 2) ≠ { 66, 77 } 或 取字节集数据 (参_原图片, #短整数型, 29) ≠ 24)
        .如果真 (局_图片对象.创建图片对象 (参_原图片))
            局_图片 ＝ 局_图片对象.取回图片 ()
            局_图片对象.清除 ()
            参_执行结果 ＝ 真
            返回 (局_图片)
        .如果真结束
        
    .如果真结束
    参_执行结果 ＝ 假
    返回 (参_原图片)

.子程序 图片_分割, 逻辑型, 公开
    .参数 参_原图片, 字节集
    .参数 参_横向分割数量, 整数型, 可空, 默认：2
    .参数 参_纵向分割数量, 整数型, 可空, 默认：2
    .参数 参_图片数组, 字节集, 数组
    .局部变量 局_总位图, 类_位图操作
    .局部变量 局_单位图, 类_位图操作
    .局部变量 局_宽度, 整数型
    .局部变量 局_高度, 整数型
    .局部变量 局_单宽度, 整数型
    .局部变量 局_单高度, 整数型
    .局部变量 局_纵向计次, 整数型
    .局部变量 局_横向计次, 整数型
    .局部变量 局_左边, 整数型
    .局部变量 局_顶边, 整数型
    .局部变量 局_单图片, 字节集
    .局部变量 局_原图, 字节集

    图片_转换 (参_原图片, 1, , 局_原图, )
    .如果真 (局_总位图.从数据创建 (局_原图) ＝ 假)
        返回 (假)
    .如果真结束
    
    .如果真 (是否为空 (参_横向分割数量))
        参_横向分割数量 ＝ 2
    .如果真结束
    
    .如果真 (是否为空 (参_纵向分割数量))
        参_纵向分割数量 ＝ 2
    .如果真结束
    
    
    局_宽度 ＝ 局_总位图.取宽度 ()
    局_高度 ＝ 局_总位图.取高度 ()
    
    局_单宽度 ＝ 局_宽度 ÷ 参_横向分割数量
    局_单高度 ＝ 局_高度 ÷ 参_纵向分割数量
    
    局_单位图.创建空白位图 (局_单宽度, 局_单高度, 32)
    局_顶边 ＝ 0 － 局_单高度
    .计次循环首 (参_纵向分割数量, 局_纵向计次)
        局_顶边 ＝ 局_顶边 ＋ 局_单高度
        局_左边 ＝ 0 － 局_单宽度
        .计次循环首 (参_横向分割数量, 局_横向计次)
            局_左边 ＝ 局_左边 ＋ 局_单宽度
            局_总位图.复制到 (局_单位图, 局_左边, 局_顶边, 局_单宽度, 局_单高度, 0, 0)
            局_单图片 ＝ 局_单位图.取出位图数据 ()
            加入成员 (参_图片数组, 局_单图片)
        .计次循环尾 ()
        局_左边 ＝ 0 － 局_单宽度
    .计次循环尾 ()
    返回 (真)
    

.子程序 图片_取照片拍摄日期, 逻辑型, 公开
    .参数 文件名, 文本型
    .参数 拍摄时间, 文本型, 参考
    .局部变量 gdiplusStartupInput, GdiplusStartupInput
    .局部变量 gdiplusToken, 整数型
    .局部变量 nSize, 整数型
    .局部变量 buffer, 字节集
    .局部变量 pImage, 整数型
    .局部变量 hStatus, 整数型

    gdiplusStartupInput.GdiplusVersion ＝ 1
    hStatus ＝ GdiplusStartup (gdiplusToken, gdiplusStartupInput, 0)
    .如果真 (hStatus ≠ 0)
        返回 (假)
    .如果真结束
    hStatus ＝ GdipLoadImageFromFile (编码_Ansi到Unicode (文件名, ), pImage)
    .如果真 (hStatus ＝ 0)
        hStatus ＝ GdipGetPropertyItemSize (pImage, #PropertyTagExifDTOrig, nSize)
        .如果真 (hStatus ＝ 0)
            buffer ＝ 取空白字节集 (nSize)
            GdipGetPropertyItem (pImage, #PropertyTagExifDTOrig, nSize, buffer)
            拍摄时间 ＝ 取字节集数据 (buffer, #文本型, 17)
        .如果真结束
        GdipDisposeImage (pImage)
    .如果真结束
    GdiplusShutdown (gdiplusToken)
    返回 (nSize ≠ 0)

.子程序 图片_缩放, 字节集, 公开
    .参数 图片, 字节集
    .参数 宽度, 整数型
    .参数 高度, 整数型
    .参数 无损, 逻辑型, 可空, 假为快速 真为无损，默认为假
    .局部变量 对象, 对象
    .局部变量 数据1, 整数型, , "0"
    .局部变量 数据2, 整数型, , "0"
    .局部变量 a, 整数型
    .局部变量 b, 整数型
    .局部变量 位图, 类_位图操作
    .局部变量 c, 整数型
    .局部变量 d, 整数型
    .局部变量 图片缩放, 类_像素组

    ' 命令收集地址：https://bbs.125.la/forum.php?mod=viewthread&tid=14182970
    CoInitialize (0)
    对象.创建图片对象 (图片)
    位图.从数据创建 (对象.取回图片 ())
    CoUninitialize ()
    图片缩放.位图_转_像素组 (位图, 数据1)
    a ＝ 位图.取宽度 ()
    b ＝ 位图.取高度 ()
    c ＝ 宽度
    d ＝ 高度
    .判断开始 (无损 ＝ 假)
        图片缩放.像素组_缩放图片_快速 (数据1, a, b, c, d, 数据2)
    .默认
        图片缩放.像素组_缩放图片_无损 (数据1, a, b, c, d, 数据2)
    .判断结束
    位图.创建空白位图 (1, 1, 24)
    图片缩放.像素组_转_位图 (位图, 数据2, c, d)
    返回 (位图.取出位图数据 ())

.子程序 图片_缩放_透明, 字节集, 公开, @大司命
    .参数 参_图片, 字节集
    .参数 参_宽度, 整数型, 可空, 留空或小于1默认取原来宽度
    .参数 参_高度, 整数型, 可空, 留空或小于1默认取原来高度
    .局部变量 Startup, GdiplusStartupInput
    .局部变量 hMem, 整数型
    .局部变量 nSize, 整数型
    .局部变量 lpStr, 整数型
    .局部变量 ipStr, 整数型
    .局部变量 bitmap, 整数型
    .局部变量 token, 整数型
    .局部变量 bpStr, 整数型
    .局部变量 xpStr, 字节集

    ' 该命令来自：https://bbs.125.la/thread-14322627-1-1.html
    Startup.GdiplusVersion ＝ 1
    GdiplusStartup (token, Startup, 0)
    nSize ＝ 取字节集长度 (参_图片)
    hMem ＝ GlobalAlloc (#GMEM_MOVEABLE, nSize)
    lpStr ＝ GlobalLock (hMem)
    CreateStreamOnHGlobal (hMem, 假, ipStr)
    RtlMoveMemory_字节集 (lpStr, 参_图片, nSize)
    GlobalUnlock (hMem)
    GdipLoadImageFromStream (ipStr, bitmap)
    .如果真 (参_宽度 ＜ 1)
        GdipGetImageWidth (bitmap, 参_宽度)
    .如果真结束
    .如果真 (参_高度 ＜ 1)
        GdipGetImageHeight (bitmap, 参_高度)
    .如果真结束
    GdipGetImageThumbnail (bitmap, 参_宽度, 参_高度, bpStr, 0, 0)
    GdipDisposeImage (bitmap)
    GlobalFree (hMem)
    hMem ＝ GlobalAlloc (位或 (#GMEM_ZEROINIT, #GMEM_MOVEABLE), 0)
    CreateStreamOnHGlobal (hMem, 假, ipStr)
    xpStr ＝ 取空白字节集 (16)
    CLSIDFromString_字节集传址2 ({ 123, 0, 53, 0, 53, 0, 55, 0, 67, 0, 70, 0, 52, 0, 48, 0, 54, 0, 45, 0, 49, 0, 65, 0, 48, 0, 52, 0, 45, 0, 49, 0, 49, 0, 68, 0, 51, 0, 45, 0, 57, 0, 65, 0, 55, 0, 51, 0, 45, 0, 48, 0, 48, 0, 48, 0, 48, 0, 70, 0, 56, 0, 49, 0, 69, 0, 70, 0, 51, 0, 50, 0, 69, 0, 125, 0, 0, 0 }, xpStr)
    GdipSaveImageToStream_字节集 (bpStr, ipStr, xpStr, 0)
    lpStr ＝ GlobalLock (hMem)
    nSize ＝ GlobalSize (hMem)
    xpStr ＝ 指针到字节集 (lpStr, nSize)
    GlobalUnlock (hMem)
    GlobalFree (hMem)
    GdipDisposeImage (bpStr)
    GdiplusShutdown (token)
    返回 (xpStr)

.子程序 加入_RGB
    .参数 颜色, 整数型
    .参数 R, 整数型, 参考
    .参数 G, 整数型, 参考
    .参数 B, 整数型, 参考
    .参数 N, 整数型, 参考
    .局部变量 ls_zjj, 字节集

    ls_zjj ＝ 到字节集 (颜色)
    R ＝ R ＋ ls_zjj [1]
    G ＝ G ＋ ls_zjj [2]
    B ＝ B ＋ ls_zjj [3]
    N ＝ N ＋ 1

.子程序 RGB_整数, 整数型
    .参数 r, 整数型
    .参数 g, 整数型
    .参数 b, 整数型
    .局部变量 shu_, 整数型
    .局部变量 ls_zjj, 字节集

    ls_zjj ＝ 取空白字节集 (4)
    ls_zjj [1] ＝ r
    ls_zjj [2] ＝ g
    ls_zjj [3] ＝ b
    写到内存 (ls_zjj, 取变量地址_字节 (shu_), 4)
    返回 (shu_)

.子程序 图片_拼接, 字节集, 公开, 仅支持bmp格式的图片拼接，如需其他格式的图片请先转换
    .参数 参_图片数组, 文本型, 数组, 图片文件的路径数组
    .参数 参_列总数, 整数型
    .参数 参_行总数, 整数型
    .参数 参_图片宽度, 整数型
    .参数 参_图片高度, 整数型
    .局部变量 a, 整数型
    .局部变量 b, 整数型
    .局部变量 局_单图片, 字节集
    .局部变量 局_总位图, 类_位图操作
    .局部变量 局_单位图, 类_位图操作
    .局部变量 局_宽度, 整数型
    .局部变量 局_高度, 整数型
    .局部变量 局_位深, 短整数型
    .局部变量 局_目标左, 整数型
    .局部变量 局_目标顶, 整数型
    .局部变量 局_拼接结果, 字节集
    .局部变量 局_数组, 文本型, , "0"
    .局部变量 局_索引, 整数型

    局_宽度 ＝ 参_图片宽度 × 参_列总数
    局_高度 ＝ 参_图片高度 × 参_行总数
    局_总位图.创建空白位图 (局_宽度, 局_高度, 32)
    .计次循环首 (参_列总数, a)
        局_目标左 ＝ (a － 1) × 参_图片宽度
        .计次循环首 (参_行总数, b)
            局_目标顶 ＝ (b － 1) × 参_图片高度
            局_索引 ＝ 局_索引 ＋ 1
            .如果真 (局_索引 ＞ 取数组成员数 (参_图片数组))
                返回 ({ })
            .如果真结束
            局_单图片 ＝ 读入文件 (参_图片数组 [局_索引])
            局_单图片 ＝ 图片_缩放 (局_单图片, 参_图片宽度, 参_图片高度, 真)
            局_单位图.从数据创建 (局_单图片)
            局_单位图.复制到 (局_总位图, 0, 0, 参_图片宽度, 参_图片高度, 局_目标左, 局_目标顶)
            处理事件 ()
        .计次循环尾 ()
    .计次循环尾 ()
    局_拼接结果 ＝ 局_总位图.取出位图数据 ()
    返回 (局_拼接结果)

.子程序 图片_拼接1, 字节集, 公开, 两张图片拼接为一张，支持上下拼接和左右拼接，图片自动居中
    .参数 图片1, 字节集
    .参数 图片2, 字节集
    .参数 拼接方式, 逻辑型, , 上下拼接传入：真 左右拼接传入：假
    .参数 合成底色, 整数型, 可空, 默认白底
    .局部变量 _图片1, 字节集
    .局部变量 _图片2, 字节集
    .局部变量 局_总位图, 类_位图操作
    .局部变量 局_单位图, 类_位图操作
    .局部变量 局_宽度, 整数型
    .局部变量 局_高度, 整数型
    .局部变量 局_拼接结果, 字节集
    .局部变量 y, 整数型
    .局部变量 x, 整数型
    .局部变量 局_左边, 整数型
    .局部变量 局_顶边, 整数型

    ' 源码收录自：https://bbs.125.la/forum.php?mod=viewthread&tid=14339636
    图片_转换 (图片1, 1, , _图片1, )
    图片_转换 (图片2, 1, , _图片2, )
    .如果真 (合成底色 ＝ 0)
        合成底色 ＝ #白色
    .如果真结束
    .如果 (拼接方式)
        ' 上下拼接取最宽宽度
        局_宽度 ＝ 图片_取宽度 (_图片1)
        .如果真 (局_宽度 ＜ 图片_取宽度 (_图片2))
            局_宽度 ＝ 图片_取宽度 (_图片2)
        .如果真结束
        ' 上下拼接取两张图片高度和
        局_高度 ＝ 图片_取高度 (_图片1) ＋ 图片_取高度 (_图片2)
        
        局_总位图.创建空白位图 (局_宽度, 局_高度, 32)
        
        .计次循环首 (局_宽度, x)
            .计次循环首 (局_高度, y)
                局_总位图.置某点颜色 (x － 1, y － 1, 合成底色)
            .计次循环尾 ()
        .计次循环尾 ()
        
        局_左边 ＝ 0
        .如果真 (图片_取宽度 (_图片1) ≠ 局_宽度)
            局_左边 ＝ 到整数 ((局_宽度 － 图片_取宽度 (_图片1)) ÷ 2)
        .如果真结束
        局_单位图.从数据创建 (_图片1)
        局_单位图.复制到 (局_总位图, 0, 0, 图片_取宽度 (_图片1), 图片_取高度 (_图片1), 局_左边, 0)
        处理事件 ()
        局_左边 ＝ 0
        .如果真 (图片_取宽度 (_图片2) ≠ 局_宽度)
            局_左边 ＝ 到整数 ((局_宽度 － 图片_取宽度 (_图片2)) ÷ 2)
        .如果真结束
        局_单位图.从数据创建 (_图片2)
        局_单位图.复制到 (局_总位图, 0, 0, 图片_取宽度 (_图片2), 图片_取高度 (_图片2), 局_左边, 图片_取高度 (_图片1))
        处理事件 ()
        
    .否则
        
        ' 左右拼接取最高高度
        局_高度 ＝ 图片_取高度 (_图片1)
        .如果真 (局_高度 ＜ 图片_取高度 (_图片2))
            局_高度 ＝ 图片_取高度 (_图片2)
        .如果真结束
        ' 左右拼接取两张图片宽度和
        局_宽度 ＝ 图片_取宽度 (_图片1) ＋ 图片_取宽度 (_图片2)
        
        局_总位图.创建空白位图 (局_宽度, 局_高度, 32)
        
        .计次循环首 (局_宽度, x)
            .计次循环首 (局_高度, y)
                局_总位图.置某点颜色 (x － 1, y － 1, 合成底色)
            .计次循环尾 ()
        .计次循环尾 ()
        
        局_顶边 ＝ 0
        .如果真 (图片_取高度 (_图片1) ≠ 局_高度)
            局_顶边 ＝ 到整数 ((局_高度 － 图片_取高度 (_图片1)) ÷ 2)
        .如果真结束
        局_单位图.从数据创建 (_图片1)
        局_单位图.复制到 (局_总位图, 0, 0, 图片_取宽度 (_图片1), 图片_取高度 (_图片1), 0, 局_顶边)
        处理事件 ()
        局_顶边 ＝ 0
        .如果真 (图片_取高度 (_图片2) ≠ 局_高度)
            局_顶边 ＝ 到整数 ((局_高度 － 图片_取高度 (_图片2)) ÷ 2)
        .如果真结束
        局_单位图.从数据创建 (_图片2)
        局_单位图.复制到 (局_总位图, 0, 0, 图片_取宽度 (_图片2), 图片_取高度 (_图片2), 图片_取宽度 (_图片1), 局_顶边)
        处理事件 ()
    .如果结束
    局_拼接结果 ＝ 局_总位图.取出位图数据 ()
    返回 (局_拼接结果)

.子程序 RGB2ARGB, 整数型
    .参数 RGB颜色, 整数型
    .参数 透明度, 整数型, 可空, 0-255
    .局部变量 Color, 字节集

    .如果真 (是否为空 (透明度))
        透明度 ＝ 255
    .如果真结束
    Color ＝ 到字节集 (RGB颜色)
    RGB颜色 ＝ 位或 (Color [3] ＋ Color [2] × 256 ＋ Color [1] × 65536, 左移 (透明度, 24)) ' 转换成GDI+的颜色值
    返回 (RGB颜色)

.子程序 图片_高斯模糊, 字节集, 公开, BMP
    .参数 参_BMP图片, 字节集
    .参数 参_衰减, 整数型, 可空
    .局部变量 BMP图片宽度, 整数型
    .局部变量 BMP图片高度, 整数型
    .局部变量 BMP起始位置, 整数型
    .局部变量 i, 整数型
    .局部变量 BMPY, 整数型
    .局部变量 BMPX, 整数型
    .局部变量 当前x, 整数型
    .局部变量 当前y, 整数型
    .局部变量 平均R, 整数型
    .局部变量 平均B, 整数型
    .局部变量 平均G, 整数型
    .局部变量 当前R, 整数型
    .局部变量 当前G, 整数型
    .局部变量 当前B, 整数型
    .局部变量 当前N, 整数型
    .局部变量 Y, 整数型
    .局部变量 输出BMP, 字节集
    .局部变量 衰减_整数, 整数型
    .局部变量 BMP占用字节, 整数型

    输出BMP ＝ 参_BMP图片
    BMP起始位置 ＝ 参_BMP图片 [3]
    BMP图片宽度 ＝ 参_BMP图片 [19] ＋ 参_BMP图片 [20] × 256
    BMP图片高度 ＝ 参_BMP图片 [23] ＋ 参_BMP图片 [24] × 256
    衰减_整数 ＝ 0
    .如果真 (是否为空 (参_衰减) ＝ 假)
        衰减_整数 ＝ 参_衰减
    .如果真结束
    .变量循环首 (0, BMP图片高度 － 1, 1, BMPY)
        .变量循环首 (0, BMP图片宽度 － 1, 1, BMPX)
            平均R ＝ 0
            平均G ＝ 0
            平均B ＝ 0
            当前N ＝ 0
            .如果真 (图片_取像素RGB (参_BMP图片, BMPX － 1, BMPY, 当前R, 当前G, 当前B))
                平均R ＝ 平均R ＋ 当前R
                平均G ＝ 平均G ＋ 当前G
                平均B ＝ 平均B ＋ 当前B
                当前N ＝ 当前N ＋ 1
            .如果真结束
            .如果真 (图片_取像素RGB (参_BMP图片, BMPX ＋ 1, BMPY, 当前R, 当前G, 当前B))
                平均R ＝ 平均R ＋ 当前R
                平均G ＝ 平均G ＋ 当前G
                平均B ＝ 平均B ＋ 当前B
                当前N ＝ 当前N ＋ 1
            .如果真结束
            .如果真 (图片_取像素RGB (参_BMP图片, BMPX, BMPY ＋ 1, 当前R, 当前G, 当前B))
                平均R ＝ 平均R ＋ 当前R
                平均G ＝ 平均G ＋ 当前G
                平均B ＝ 平均B ＋ 当前B
                当前N ＝ 当前N ＋ 1
            .如果真结束
            .如果真 (图片_取像素RGB (参_BMP图片, BMPX, BMPY － 1, 当前R, 当前G, 当前B))
                平均R ＝ 平均R ＋ 当前R
                平均G ＝ 平均G ＋ 当前G
                平均B ＝ 平均B ＋ 当前B
                当前N ＝ 当前N ＋ 1
            .如果真结束
            平均B ＝ 取整 (平均B ÷ 当前N) － 衰减_整数
            平均G ＝ 取整 (平均G ÷ 当前N) － 衰减_整数
            平均R ＝ 取整 (平均R ÷ 当前N) － 衰减_整数
            .如果真 (平均B ＜ 0)
                平均B ＝ 0
            .如果真结束
            .如果真 (平均G ＜ 0)
                平均G ＝ 0
            .如果真结束
            .如果真 (平均R ＜ 0)
                平均R ＝ 0
            .如果真结束
            ' 输出BMP [BMP起始位置 ＋ (BMPY × BMP图片宽度 ＋ BMPX) × 3 ＋ 1] ＝ 平均B
            ' 输出BMP [BMP起始位置 ＋ (BMPY × BMP图片宽度 ＋ BMPX) × 3 ＋ 2] ＝ 平均G
            ' 输出BMP [BMP起始位置 ＋ (BMPY × BMP图片宽度 ＋ BMPX) × 3 ＋ 3] ＝ 平均R
            BMP占用字节 ＝ 取整 ((BMP图片宽度 × 24 ＋ 31) ÷ 32) × 4 ' 取一行像素占用字节数
            BMP起始位置 ＝ 55 ＋ (BMP图片高度 － BMPY － 1) × BMP占用字节 ＋ BMPX × 3
            输出BMP [BMP起始位置] ＝ 平均B
            输出BMP [BMP起始位置 ＋ 1] ＝ 平均G
            输出BMP [BMP起始位置 ＋ 2] ＝ 平均R
        .变量循环尾 ()
    .变量循环尾 ()
    返回 (输出BMP)

.子程序 图片_取像素RGB, 逻辑型, 公开
    .参数 BMP图片, 字节集
    .参数 图片X, 整数型
    .参数 图片Y, 整数型
    .参数 图片R, 整数型, 参考
    .参数 图片G, 整数型, 参考
    .参数 图片B, 整数型, 参考
    .局部变量 BMP图片宽度, 整数型
    .局部变量 BMP图片高度, 整数型
    .局部变量 BMP起始位置, 整数型
    .局部变量 BMP占用字节, 整数型
    .局部变量 dwLen, 整数型

    dwLen ＝ 取字节集长度 (BMP图片)
    .如果真 (dwLen ＜ 24)
        返回 (假)
    .如果真结束
    .如果真 (BMP图片 [3] ＜ 58 或 BMP图片 [29] ≠ 24) ' 判断文件长度 和  图片深度
        返回 (假)
    .如果真结束
    BMP图片宽度 ＝ BMP图片 [19] ＋ BMP图片 [20] × 256
    BMP图片高度 ＝ BMP图片 [23] ＋ BMP图片 [24] × 256
    BMP占用字节 ＝ 取整 ((BMP图片宽度 × 24 ＋ 31) ÷ 32) × 4 ' 取一行像素占用字节数
    .如果真 (图片X ＜ 0 或 图片X ≥ BMP图片宽度)
        返回 (假)
    .如果真结束
    .如果真 (图片Y ＜ 0 或 图片Y ≥ BMP图片高度)
        返回 (假)
    .如果真结束
    BMP起始位置 ＝ 55 ＋ (BMP图片高度 － 图片Y － 1) × BMP占用字节 ＋ 图片X × 3
    图片R ＝ BMP图片 [BMP起始位置 ＋ 2]
    图片G ＝ BMP图片 [BMP起始位置 ＋ 1]
    图片B ＝ BMP图片 [BMP起始位置]
    返回 (真)

.子程序 图片_置像素RGB, 逻辑型, 公开
    .参数 BMP图片, 字节集
    .参数 图片X, 整数型
    .参数 图片Y, 整数型
    .参数 图片R, 整数型
    .参数 图片G, 整数型
    .参数 图片B, 整数型
    .局部变量 BMP图片宽度, 整数型
    .局部变量 BMP图片高度, 整数型
    .局部变量 BMP起始位置, 整数型

    BMP起始位置 ＝ BMP图片 [3]
    BMP图片宽度 ＝ BMP图片 [19] ＋ BMP图片 [20] × 256
    BMP图片高度 ＝ BMP图片 [23] ＋ BMP图片 [24] × 256
    .如果真 (图片X ＜ 0 或 图片X ≥ BMP图片宽度)
        返回 (假)
    .如果真结束
    .如果真 (图片Y ＜ 0 或 图片Y ≥ BMP图片高度)
        返回 (假)
    .如果真结束
    BMP图片 [BMP起始位置 ＋ (图片Y × BMP图片宽度 ＋ 图片X) × 3 ＋ 1] ＝ 图片B
    BMP图片 [BMP起始位置 ＋ (图片Y × BMP图片宽度 ＋ 图片X) × 3 ＋ 2] ＝ 图片G
    BMP图片 [BMP起始位置 ＋ (图片Y × BMP图片宽度 ＋ 图片X) × 3 ＋ 3] ＝ 图片R
    返回 (真)

.子程序 图片_加水印, 字节集, 公开, 给24位图加水印,如不是24位图请先转换
    .参数 源图_图数据, 字节集
    .参数 水印_图数据, 字节集
    .参数 水印图_左边, 整数型, 可空, 默认：水印右边空白留20，水印左边程序自动计算
    .参数 水印图_顶边, 整数型, 可空, 默认：水印底边空白留20，水印顶边程序自动计算
    .参数 透明颜色, 整数型, 可空, 默认：白色
    .局部变量 图数据, 字节集
    .局部变量 原图_头长
    .局部变量 原图_宽
    .局部变量 原图_高
    .局部变量 原图_纠正位
    .局部变量 原图_图数宽
    .局部变量 原图_图数长
    .局部变量 原图_大小
    .局部变量 水印_图头长
    .局部变量 水印_宽
    .局部变量 水印_高
    .局部变量 水印_纠正位
    .局部变量 水印_图数宽
    .局部变量 水印_图数长
    .局部变量 水印_大小
    .局部变量 加左边
    .局部变量 加顶边
    .局部变量 首点1
    .局部变量 首点2
    .局部变量 计次1
    .局部变量 局_偏移

    .如果真 (取字节集数据 (源图_图数据, #短整数型, 29) ≠ 24 或 取字节集数据 (水印_图数据, #短整数型, 29) ≠ 24)
        返回 ({ })
    .如果真结束
    透明颜色 ＝ 选择 (是否为空 (透明颜色), 16777215, 透明颜色)
    原图_头长 ＝ 取字节集数据 (源图_图数据, #短整数型, 11)
    原图_宽 ＝ 取字节集数据 (源图_图数据, #整数型, 19)
    原图_高 ＝ 取字节集数据 (源图_图数据, #整数型, 23)
    原图_纠正位 ＝ 位与 (原图_宽, 3)
    原图_图数宽 ＝ 原图_宽 × 3 ＋ 原图_纠正位
    原图_图数长 ＝ 原图_图数宽 × 原图_高
    原图_大小 ＝ 原图_图数长 ＋ 原图_头长
    水印_图头长 ＝ 取字节集数据 (水印_图数据, #短整数型, 11)
    水印_宽 ＝ 取字节集数据 (水印_图数据, #整数型, 19)
    水印_高 ＝ 取字节集数据 (水印_图数据, #整数型, 23)
    水印_纠正位 ＝ 位与 (水印_宽, 3)
    水印_图数宽 ＝ 水印_宽 × 3 ＋ 水印_纠正位
    水印_图数长 ＝ 水印_图数宽 × 水印_高
    水印_大小 ＝ 水印_图数长 ＋ 水印_图头长
    .如果真 (是否为空 (水印图_左边))
        水印图_左边 ＝ 原图_宽 － 水印_宽 － 20
    .如果真结束
    .如果真 (是否为空 (水印图_顶边))
        水印图_顶边 ＝ 原图_高 － 水印_高 － 20
    .如果真结束
    .如果真 (水印图_左边 ＜ 0)
        水印图_左边 ＝ 0
    .如果真结束
    .如果真 (水印图_顶边 ＜ 0)
        水印图_顶边 ＝ 0
    .如果真结束
    .如果真 (原图_高 ＜ 水印_高)
        水印_高 ＝ 原图_高
    .如果真结束
    .如果真 (原图_宽 ＜ 水印_宽)
        水印_宽 ＝ 原图_宽
    .如果真结束
    .如果真 (原图_宽 － 水印图_左边 － 水印_宽 ＜ 0)
        水印_宽 ＝ 原图_宽 － 水印图_左边
    .如果真结束
    .如果真 (原图_高 － 水印图_顶边 － 水印_高 ＜ 0)
        水印_高 ＝ 原图_高 － 水印图_顶边
    .如果真结束
    图数据 ＝ 源图_图数据
    .计次循环首 (水印_高, 计次1)
        首点1 ＝ 原图_大小 － (水印图_顶边 ＋ 计次1) × 原图_图数宽 ＋ 水印图_左边 × 3
        首点2 ＝ 水印_大小 － 计次1 × 水印_图数宽
        .计次循环首 (水印_宽, )
            .如果真 (取颜色值 (水印_图数据 [首点2 ＋ 3], 水印_图数据 [首点2 ＋ 2], 水印_图数据 [首点2 ＋ 1]) ≠ 透明颜色)
                图数据 [首点1 ＋ 1] ＝ 水印_图数据 [首点2 ＋ 1]
                图数据 [首点1 ＋ 2] ＝ 水印_图数据 [首点2 ＋ 2]
                图数据 [首点1 ＋ 3] ＝ 水印_图数据 [首点2 ＋ 3]
            .如果真结束
            首点1 ＝ 首点1 ＋ 3
            首点2 ＝ 首点2 ＋ 3
        .计次循环尾 ()
    .计次循环尾 ()
    返回 (图数据)

.子程序 图片_转换, 逻辑型, 公开, 支持bmp、jpg、gif、tiff、png互转；成功返回转换好的图片数据，失败返回空字节集；
    .参数 图像数据, 字节集, , 被转换的图像数据；
    .参数 转换格式, 整数型, , 要转换成的图像格式：1=bmp；2=jpg；3=gif；4=tiff；5=png；
    .参数 保存路径, 文本型, 可空, 把转换后的图像保存到指定位置；
    .参数 返回数据, 字节集, 参考 可空, 变量储存返回数据.
    .参数 含透明色, 逻辑型, 可空, 转换PNG图片时是否需要处理透明色，可为空，默认不处理。
    .局部变量 新图像, 字节集, , , 用于保存新图像的变量
    .局部变量 Clsid, GUID
    .局部变量 pStr, 文本型
    .局部变量 hMem, 整数型
    .局部变量 Stream
    .局部变量 lpvoid, 整数型
    .局部变量 pStream, 整数型
    .局部变量 bitmap, 整数型
    .局部变量 DataStream
    .局部变量 hMemDataStream, 整数型
    .局部变量 pDataStream, 整数型
    .局部变量 nStreamSize, 整数型
    .局部变量 bRet, 逻辑型
    .局部变量 GpInput, GdiplusStartupInput
    .局部变量 局_Token, 整数型
    .局部变量 局_hBitMap, 整数型
    .局部变量 局_后缀名, 文本型

    .如果真 (取字节集长度 (图像数据) ＜ 3)
        返回 (假)
    .如果真结束
    GpInput.GdiplusVersion ＝ 1
    GdiplusStartup (局_Token, GpInput, 0) ' 启动GDI+
    .判断开始 (转换格式 ＝ 1) ' bmp
        pStr ＝ “{557CF400-1A04-11D3-9A73-0000F81EF32E}”
        局_后缀名 ＝ “.bmp”
    .判断 (转换格式 ＝ 2) ' jpg
        pStr ＝ “{557CF401-1A04-11D3-9A73-0000F81EF32E}”
        局_后缀名 ＝ “.jpg”
    .判断 (转换格式 ＝ 3) ' gif
        pStr ＝ “{557CF402-1A04-11D3-9A73-0000F81EF32E}”
        局_后缀名 ＝ “.gif”
    .判断 (转换格式 ＝ 4) ' tiff
        pStr ＝ “{557CF405-1A04-11D3-9A73-0000F81EF32E}”
        局_后缀名 ＝ “.tiff”
    .判断 (转换格式 ＝ 5) ' png
        pStr ＝ “{557CF406-1A04-11D3-9A73-0000F81EF32E}”
        局_后缀名 ＝ “.png”
    .默认
        
    .判断结束
    
    
    Clsid ＝ COM_StringToCLSID (pStr)
    hMem ＝ GlobalAlloc (2, 取字节集长度 (图像数据)) ' 分配内存
    CreateStreamOnHGlobal (hMem, 假, Stream)
    
    lpvoid ＝ GlobalLock (hMem)
    写到内存 (图像数据, lpvoid, 取字节集长度 (图像数据))
    GlobalUnlock (hMem)
    
    pStream ＝ lstrcpyn_整数型 (Stream, Stream, 0)
    GDIpCreateBitmapFromStream (取字节集数据 (指针到字节集 (pStream, 4), #整数型, ), bitmap)
    .如果真 (含透明色)
        GdipCreateHBITMAPFromBitmap (bitmap, 局_hBitMap, #白色)
        GdipCreateBitmapFromHBITMAP (局_hBitMap, 0, bitmap)
        DeleteObject (局_hBitMap)
    .如果真结束
    
    CreateStreamOnHGlobal (0, 真, DataStream)
    pStream ＝ lstrcpyn_整数型 (DataStream, DataStream, 0)
    pStream ＝ 取字节集数据 (指针到字节集 (pStream, 4), #整数型, )
    
    GDIpSaveImageToStream_GUID (bitmap, pStream, Clsid, 0)
    GetHGlobalFromStream (pStream, hMemDataStream)
    pDataStream ＝ GlobalLock (hMemDataStream)
    nStreamSize ＝ GlobalSize (hMemDataStream)
    .如果真 (pDataStream ≠ 0)
        新图像 ＝ 取空白字节集 (nStreamSize)
        RtlMoveMemory_int2Bytes (新图像, pDataStream, nStreamSize)
        .如果真 (删首尾空 (保存路径) ≠ “”)
            写到文件 (选择 (到小写 (取文本右边 (保存路径, 取文本长度 (局_后缀名))) ≠ 到小写 (局_后缀名), 保存路径 ＋ 局_后缀名, 保存路径), 新图像)
        .如果真结束
        返回数据 ＝ 新图像
        bRet ＝ 真
    .如果真结束
    COM_Release (Stream)
    COM_Release (DataStream)
    GlobalUnlock (hMemDataStream)
    GlobalFree (hMemDataStream)
    GdipDisposeImage (bitmap)
    GlobalFree (hMem)
    GdiplusShutdown (局_Token) ' GDI关闭 +
    返回 (bRet)

.子程序 图片_转换1, 字节集, 公开
    .参数 参_原始图片, 字节集
    .参数 参_转换格式, 整数型, , 要转换成的图像格式：1=bmp；2=jpg；3=gif；4=tiff；5=png；
    .参数 参_输出质量, 整数型, , 0-100
    .局部变量 局_图像转换, 类_图像格式转换类
    .局部变量 局_转换结果, 字节集

    .如果真 (局_图像转换.载入图像 (参_原始图片) ＝ 假)
        返回 ({ })
    .如果真结束
    局_转换结果 ＝ 局_图像转换.转换到字节集 (参_转换格式, 参_输出质量)
    返回 (局_转换结果)

.子程序 图片_转换Ex, 字节集, 公开, 支持bmp、jpg、gif、tiff、png互转；成功返回转换好的图片数据，失败返回空字节集；
    .参数 图像数据, 字节集, , 被转换的图像数据；
    .参数 转换格式, 整数型, 可空, 要转换成的图像格式：1=bmp；2=jpg；3=gif；4=tiff；其他=png；
    .参数 保存路径, 文本型, 可空, 把转换后的图像保存到指定位置；
    .参数 含透明色, 逻辑型, 可空, 转换PNG图片时是否需要处理透明色，可为空，默认不处理。
    .局部变量 Clsid, 字节集, , , 转换标志
    .局部变量 szText, 文本型, , , gdi+图片转换标志
    .局部变量 hMem, 整数型, , , 原图片存放的内存句柄
    .局部变量 hMemData, 整数型, , , 转换后的图片内存句柄
    .局部变量 hBmp, 整数型, , , 从流指针里创建的位图句柄
    .局部变量 hBmp1, 整数型, , , 位图
    .局部变量 pStream, 整数型, , , 原图片流对象指针
    .局部变量 pAddrStream, 整数型, , , 原图片内存地址,图片数据写入这里
    .局部变量 pDataStream, 整数型, , , 转换后图片流对象指针
    .局部变量 pAddrDataStream, 整数型, , , 图片转换后的内存地址
    .局部变量 dwLen, 整数型, , , 转换后图片的大小
    .局部变量 Ret, 字节集, , , 返回值
    .局部变量 Token, 整数型, , , gdi+token
    .局部变量 扩展名, 文本型
    .局部变量 Error, 整数型, , , gdi+错误代码
    .局部变量 input, GdiplusStartupInput
    .局部变量 wzText, 字节集

    .如果真 (取字节集长度 (图像数据) ＜ 3)
        返回 ({ })
    .如果真结束
    ' Clsid ＝ 取空白字节集 (16)  ' 临时借用一下这个变量做缓冲区,相当于 GdiplusStartupInput 这个数据结构,4个成员
    ' __set (取指针_字节集型 (Clsid), 0, 1)  ' 设置 第一个成员 GdiplusVersion 为1
    ' Error ＝ GdiplusStartupA (Token, 取指针_字节集型 (Clsid), 0)  ' 启动GDI+
    input.GdiplusVersion ＝ 1
    Error ＝ GdiplusStartup (Token, input, 0) ' 启动GDI+
    .如果真 (Error ≠ 0)
        返回 ({ })
    .如果真结束
    .判断开始 (转换格式 ＝ 1) ' bmp
        szText ＝ “{557CF400-1A04-11D3-9A73-0000F81EF32E}”
        扩展名 ＝ “.bmp”
    .判断 (转换格式 ＝ 2) ' jpg
        szText ＝ “{557CF401-1A04-11D3-9A73-0000F81EF32E}”
        扩展名 ＝ “.jpg”
    .判断 (转换格式 ＝ 3) ' gif
        szText ＝ “{557CF402-1A04-11D3-9A73-0000F81EF32E}”
        扩展名 ＝ “.gif”
    .判断 (转换格式 ＝ 4) ' tiff
        szText ＝ “{557CF405-1A04-11D3-9A73-0000F81EF32E}”
        扩展名 ＝ “.tiff”
    .默认
        szText ＝ “{557CF406-1A04-11D3-9A73-0000F81EF32E}”
        扩展名 ＝ “.png”
    .判断结束
    
    
    Clsid ＝ 取空白字节集 (16)
    wzText ＝ 编码_Ansi到Unicode (szText, )
    CLSIDFromString (取指针_字节集型 (wzText), Clsid)
    
    
    hMem ＝ GlobalAlloc (66, 取字节集长度 (图像数据)) ' 申请内存
    pAddrStream ＝ GlobalLock (hMem) ' 锁定内存,返回这个内存句柄的内存首地址
    RtlMoveMemory (pAddrStream, 取指针_字节集型 (图像数据), 取字节集长度 (图像数据)) ' 把图片数据写入这个内存
    .如果真 (GlobalUnlock (hMem) ≠ 0) ' 解锁内存
        集_转换错误 ＝ “解锁原图片内存失败”
    .如果真结束
    
    CreateStreamOnHGlobal_整数型 (hMem, 0, pStream) ' 创建流对象
    Error ＝ GDIpCreateBitmapFromStream (pStream, hBmp) ' 从流里创建位图
    .如果真 (Error ≠ 0)
        SafeRelease (pStream) ' 释放流对象
        .如果真 (GlobalFree (hMem) ≠ 0) ' 释放内存
            集_转换错误 ＝ “从流里创建位图失败,并且释放内存失败”
        .如果真结束
        返回 ({ })
    .如果真结束
    
    .如果真 (含透明色)
        GdipCreateHBITMAPFromBitmap (hBmp, hBmp1, #白色) ' 返回位图句柄。需要调用 DeleteObject 释放
        GdipDisposeImage (hBmp)
        GdipCreateBitmapFromHBITMAP (hBmp1, 0, hBmp)
    .如果真结束
    
    CreateStreamOnHGlobal_整数型 (0, 0, pDataStream) ' 创建流,从这个流里取转换后的数据
    GdipSaveImageToStream_字节集 (hBmp, pDataStream, Clsid, 0) ' 转换图片
    GetHGlobalFromStream (pDataStream, hMemData) ' 从流里获取内存句柄
    
    pAddrDataStream ＝ GlobalLock (hMemData) ' 锁定内存句柄
    dwLen ＝ GlobalSize (hMemData) ' 取转换后内存大小
    .如果真 (pAddrDataStream ≠ 0)
        Ret ＝ 取空白字节集 (dwLen) ' 缓冲区
        RtlMoveMemory (取指针_字节集型 (Ret), pAddrDataStream, dwLen) ' 把转换后的图片数据写入到缓冲区
        .如果真 (删首尾空 (保存路径) ≠ “”)
            写到文件 (选择 (到小写 (取文本右边 (保存路径, 取文本长度 (扩展名))) ≠ 到小写 (扩展名), 保存路径 ＋ 扩展名, 保存路径), Ret)
        .如果真结束
        
    .如果真结束
    SafeRelease (pStream) ' 释放原图片流对象
    SafeRelease (pDataStream) ' 释放转换后流对象
    .如果真 (GlobalUnlock (hMemData) ≠ 0) ' 解锁转换后的内存
        集_转换错误 ＝ “解锁转换后的内存失败”
    .如果真结束
    
    .如果真 (GlobalFree (hMemData) ≠ 0) ' 释放转换后的内存
        集_转换错误 ＝ “释放转换后的内存失败”
    .如果真结束
    
    .如果真 (hBmp1 ≠ 0)
        .如果真 (DeleteObject (hBmp1) ＝ 0) ' 删除位图
            集_转换错误 ＝ “删除位图失败”
        .如果真结束
        
    .如果真结束
    Error ＝ GdipDisposeImage (hBmp) ' 释放gdi+位图
    .如果真 (Error ≠ 0)
        集_转换错误 ＝ “释放gdi+位图失败”
    .如果真结束
    .如果真 (GlobalFree (hMem) ≠ 0) ' 释放第一个申请的内存
        集_转换错误 ＝ “释放原图片内存失败”
    .如果真结束
    GdiplusShutdown (Token) ' 关闭 gdi+
    返回 (Ret)

.子程序 图片_转换Ex_取最后错误, 文本型, 公开
    返回 (集_转换错误)

.子程序 图标_取数量, 整数型, 公开, 取出文件的图标数量
    .参数 文件路径, 文本型

    返回 (ExtractIconA (0, 文件路径, -1))

.子程序 图片_取句柄, 整数型, 公开, 取图片句柄,成功返回图片句柄,失败返回0
    .参数 参_图片, 字节集, , 欲添加为菜单图片的资源
    .局部变量 局_对象, 对象, 静态, "0"
    .局部变量 局_句柄, 整数型
    .局部变量 局_成员数, 整数型

    局_成员数 ＝ 取数组成员数 (局_对象) ＋ 1
    重定义数组 (局_对象, 真, 局_成员数)
    CoInitialize (0)
    .如果真 (局_对象 [局_成员数].创建图片对象 (参_图片))
        CoUninitialize ()
        返回 (局_对象 [局_成员数].读数值属性 (“handle”, ))
    .如果真结束
    CoUninitialize ()
    返回 (0)

.子程序 图标_取句柄, 整数型, 公开, 取“位图 鼠标图片 图标“句柄,成功返回句柄,失败返回0
    .参数 图片路径, 文本型
    .参数 图像类型, 整数型, 可空, IMAGE_ 开头的常量  默认为 #IMAGE_ICON 图标
    .局部变量 局_图片高度, 整数型
    .局部变量 局_图片宽度, 整数型

    局_图片宽度 ＝ GetSystemMetrics (71)
    局_图片高度 ＝ GetSystemMetrics (72) ' SM_CYMENUCHECK 获取菜单复选号位图的大小
    .如果真 (是否为空 (图像类型))
        图像类型 ＝ #IMAGE_ICON
    .如果真结束
    返回 (LoadImage (0, 图片路径, 图像类型, 局_图片宽度, 局_图片高度, 16))

.子程序 颜色_取反色, 整数型, 公开, 取一个颜色的反色
    .参数 要取反色的10进制颜色, 整数型
    .局部变量 bin, 字节集

    bin ＝ 到字节集 (要取反色的10进制颜色)
    bin [1] ＝ 255 － bin [1]
    bin [2] ＝ 255 － bin [2]
    bin [3] ＝ 255 － bin [3]
    返回 (取字节集数据 (bin, #整数型, ))

.子程序 图片_后台截图, 字节集, 公开, 后台截图
    .参数 窗口句柄, 整数型, , 要截取的图片的窗口句柄
    .局部变量 矩形区域, 精易_矩形
    .局部变量 屏幕设备上下文句柄, 整数型
    .局部变量 内存设备上下文句柄, 整数型
    .局部变量 位图句柄, 整数型
    .局部变量 旧位图句柄, 整数型
    .局部变量 位图, BITMAP
    .局部变量 位图像素点阵, 字节集
    .局部变量 位图文件头, BITMAPFILEHEADER
    .局部变量 位图文件头字节集, 字节集
    .局部变量 位图信息, BITMAPINFO
    .局部变量 位图信息字节集, 字节集

    .如果真 (取反 (窗口_句柄是否有效 (窗口句柄)))
        返回 ({ })
    .如果真结束
    GetWindowRect (窗口句柄, 矩形区域)
    屏幕设备上下文句柄 ＝ GetDC (0)
    内存设备上下文句柄 ＝ CreateCompatibleDC (屏幕设备上下文句柄)
    位图句柄 ＝ CreateCompatibleBitmap (屏幕设备上下文句柄, 矩形区域.右边 － 矩形区域.左边, 矩形区域.底边 － 矩形区域.顶边)
    旧位图句柄 ＝ SelectObject (内存设备上下文句柄, 位图句柄)
    .如果真 (取反 (PrintWindow (窗口句柄, 内存设备上下文句柄, 0)))
        SelectObject (内存设备上下文句柄, 旧位图句柄)
        DeleteObject (位图句柄)
        DeleteDC (内存设备上下文句柄)
        ReleaseDC (0, 屏幕设备上下文句柄)
        返回 ({ })
    .如果真结束
    GetObjectA (位图句柄, 5 × 4 ＋ 2 ＋ 2, 位图)
    位图信息.BITMAPINFOHEADER.biSize ＝ 4 × 11
    GetDIBits1 (内存设备上下文句柄, 位图句柄, 0, 0, 0, 位图信息, 0)
    位图像素点阵 ＝ 取空白字节集 (位图信息.BITMAPINFOHEADER.biSizeImage)
    位图信息.BITMAPINFOHEADER.biCompression ＝ 0
    GetDIBits (内存设备上下文句柄, 位图句柄, 0, 位图.bmHeight, 位图像素点阵, 位图信息, 0)
    ' 构造位图信息
    位图信息字节集 ＝ 取空白字节集 (位图信息.BITMAPINFOHEADER.biSize)
    RtlMoveMemory_BITMAPINFO (位图信息字节集, 位图信息, 位图信息.BITMAPINFOHEADER.biSize)
    ' 构造位图文件头
    位图文件头.bfType ＝ 19778
    位图文件头.bfOffBits ＝ 2 × 4 ＋ 3 × 2 ＋ 位图信息.BITMAPINFOHEADER.biSize
    位图文件头.bfSize ＝ 位图文件头.bfOffBits ＋ 位图信息.BITMAPINFOHEADER.biSizeImage
    位图文件头.bfReserved1 ＝ 0
    位图文件头.bfReserved2 ＝ 0
    位图文件头字节集 ＝ 取空白字节集 (14)
    RtlMoveMemory_BITMAPFILEHEADER (位图文件头字节集, 位图文件头, 14)
    SelectObject (内存设备上下文句柄, 旧位图句柄)
    DeleteObject (位图句柄)
    DeleteDC (内存设备上下文句柄)
    ReleaseDC (0, 屏幕设备上下文句柄)
    返回 (位图文件头字节集 ＋ 位图信息字节集 ＋ 位图像素点阵)

.子程序 图片_后台区域截图, 字节集, 公开, 可后台截取指定位置大小的图片。窗口不能最小化，否则会导致截取失败。
    .参数 窗口句柄, 整数型, , 要截取的图片的窗口句柄
    .参数 欲截取的左边, 整数型
    .参数 欲截取的顶边, 整数型
    .参数 欲截取的宽度, 整数型
    .参数 欲截取的高度, 整数型

    返回 (图片_取图片区域 (图片_后台截图 (窗口句柄), 欲截取的左边, 欲截取的顶边, 欲截取的宽度, 欲截取的高度))

.子程序 图片_取图片区域, 字节集, 公开, 提供一张图片，取出指定位置大小的图片。
    .参数 原位图, 字节集, , 24位BMP位图
    .参数 图片左边, 整数型, , 欲取出的图片左边
    .参数 图片顶边, 整数型, , 欲取出的图片顶边
    .参数 图片宽度, 整数型, , 欲取出的图片宽度
    .参数 图片高度, 整数型, , 欲取出的图片高度
    .局部变量 图像宽度, 整数型
    .局部变量 图像高度, 整数型
    .局部变量 图像位数, 整数型
    .局部变量 图像压缩, 整数型
    .局部变量 新位图, 字节集
    .局部变量 新位图信息头, BITMAPINFOHEADER
    .局部变量 新位图文件头, BITMAPFILEHEADER
    .局部变量 文件长度, 整数型
    .局部变量 i, 整数型
    .局部变量 颜色点阵偏移量, 整数型
    .局部变量 点的大小, 整数型
    .局部变量 颜色表, 字节集
    .局部变量 总数据偏移, 整数型
    .局部变量 新行宽, 整数型
    .局部变量 原行宽, 整数型
    .局部变量 时间, 整数型

    图像宽度 ＝ 取字节集数据 (取字节集中间 (原位图, 19, 4), #整数型, )
    图像高度 ＝ 取字节集数据 (取字节集中间 (原位图, 23, 4), #整数型, )
    图像位数 ＝ 取字节集数据 (取字节集中间 (原位图, 29, 2), #短整数型, )
    图像压缩 ＝ 取字节集数据 (取字节集中间 (原位图, 31, 4), #整数型, )
    .如果真 (图像压缩 ≠ 0)
        返回 ({ })
    .如果真结束
    .如果真 (图像位数 ＝ 32)
        颜色点阵偏移量 ＝ 54
        点的大小 ＝ 4
    .如果真结束
    .如果真 (图像位数 ＝ 24)
        颜色点阵偏移量 ＝ 54
        点的大小 ＝ 3
    .如果真结束
    .如果真 (图像位数 ＝ 16)
        颜色点阵偏移量 ＝ 54
        点的大小 ＝ 2
    .如果真结束
    .如果真 (图像位数 ＝ 8)
        颜色点阵偏移量 ＝ 1078
        点的大小 ＝ 1
        颜色表 ＝ 取字节集中间 (原位图, 55, 1024)
    .如果真结束
    .如果真 (图像位数 ＜ 8)
        输出调试文本 (“错误！ 图像位深小于8！”)
        返回 ({ })
    .如果真结束
    ' 输出调试文本 (“参数错误！请检查输入的参数！”)
    ' 返回 ({  })
    
    .如果真 (图片左边 ＜ 0)
        图片左边 ＝ 0
    .如果真结束
    .如果真 (图片顶边 ＜ 0)
        图片顶边 ＝ 0
    .如果真结束
    .如果真 (图片左边 ＞ 图像宽度 或 图片顶边 ＞ 图像高度)
        输出调试文本 (“参数错误，错误原因：图片左边或图片顶边小于截取出来图片的宽度或高度”)
        返回 ({ })
    .如果真结束
    .如果真 (图片宽度 ≤ 0 或 图片高度 ≤ 0)
        输出调试文本 (“参数错误，错误原因：图片宽度或图片高度小于等于0”)
        返回 ({ })
    .如果真结束
    .如果真 (图片左边 ＋ 图片宽度 ＞ 图像宽度)
        图片宽度 ＝ 图像宽度 － 图片左边
    .如果真结束
    .如果真 (图片顶边 ＋ 图片高度 ＞ 图像高度)
        图片高度 ＝ 图像高度 － 图片顶边
    .如果真结束
    
    原行宽 ＝ 左移 (右移 (图像宽度 × 图像位数 ＋ 31, 5), 2)
    新行宽 ＝ 左移 (右移 (图片宽度 × 图像位数 ＋ 31, 5), 2)
    文件长度 ＝ 新行宽 × 图片高度
    新位图 ＝ 取空白字节集 (文件长度 ＋ 54 ＋ 取字节集长度 (颜色表))
    新位图文件头.bfType ＝ 19778
    新位图文件头.bfOffBits ＝ 颜色点阵偏移量
    新位图文件头.bfSize ＝ 颜色点阵偏移量 ＋ 文件长度
    RtlMoveMemory_BITMAPFILEHEADER_字节型 (新位图 [1], 新位图文件头, 14)
    新位图信息头.biSize ＝ 40
    新位图信息头.biWidth ＝ 图片宽度
    新位图信息头.biHeight ＝ 图片高度
    新位图信息头.biPlanes ＝ 1
    新位图信息头.biBitCount ＝ 图像位数
    RtlMoveMemory_BITMAPINFOHEADER (新位图 [15], 新位图信息头, 40)
    .如果真 (图像位数 ＝ 8)
        RtlMoveMemory_字节型 (新位图 [55], 颜色表 [1], 1024)
    .如果真结束
    总数据偏移 ＝ 原行宽 × (图像高度 － 图片高度 － 图片顶边) ＋ 图片左边 × 点的大小 ' 总偏移=高偏移+宽偏移
    .计次循环首 (图片高度, i)
        RtlMoveMemory_字节型 (新位图 [(i － 1) × 新行宽 ＋ 颜色点阵偏移量 ＋ 1], 原位图 [颜色点阵偏移量 ＋ 总数据偏移 ＋ (i － 1) × 原行宽 ＋ 1], 新行宽)
    .计次循环尾 ()
    返回 (新位图)

.子程序 图片_屏幕截图, 字节集, 公开, 截取桌面指定大小的图片
    .参数 屏幕宽度, 整数型
    .参数 屏幕高度, 整数型
    .参数 图片位数, 整数型, 可空, 这里支持 4 8 24 32 默认是24位图!
    .局部变量 桌面句柄, 整数型
    .局部变量 源场景, 整数型
    .局部变量 位图句柄, 整数型
    .局部变量 位图像素点阵, 字节集
    .局部变量 位图文件头, BITMAPFILEHEADER
    .局部变量 位图文件头字节集, 字节集
    .局部变量 位图信息, 位图信息_
    .局部变量 位图信息字节集, 字节集
    .局部变量 颜色表, 字节集
    .局部变量 颜色表大小, 整数型

    .判断开始 (图片位数 ＝ 0)
        位图信息.位深度 ＝ 24
    .默认
        位图信息.位深度 ＝ 图片位数
    .判断结束
    位图信息.位图位面数 ＝ 1
    位图信息.位图宽度 ＝ 屏幕宽度
    位图信息.位图高度 ＝ 屏幕高度
    位图信息.位图大小 ＝ 位图信息.位图宽度 × 位图信息.位图高度 × 位图信息.位深度 ÷ 8
    位图信息.结果大小 ＝ 40
    位图信息.压缩率 ＝ 0
    
    颜色表大小 ＝ 取位图深度 (位图信息.位深度)
    位图像素点阵 ＝ 取空白字节集 (位图信息.位图大小)
    颜色表 ＝ 取空白字节集 (颜色表大小)
    桌面句柄 ＝ GetDC (0)
    源场景 ＝ CreateCompatibleDC (桌面句柄)
    位图句柄 ＝ CreateDIBSection (源场景, 位图信息, 1, 0, 0, 0) ' 不知是不是这里后面的三个参数导致的这些原因,但不知要如何弄这里的参数
    SelectObject (源场景, 位图句柄)
    GetDIBColorTable (源场景, 0, 颜色表大小, 颜色表) ' 是不是不能这样取颜色表?虽然能出图了,但颜色好象还是不正常,是这里取出的颜色表有问题?
    
    StretchBlt (源场景, 0, 0, 位图信息.位图宽度, 位图信息.位图高度, 桌面句柄, 0, 位图信息.位图高度, 位图信息.位图宽度, －位图信息.位图高度, 13369376)
    GetBitmapBits (位图句柄, 位图信息.位图大小, 位图像素点阵)
    
    ' 取位图二进制位_ (源场景, 位图句柄, 0, 位图信息.位图高度, 位图像素点阵 [1], 位图信息, #DIB_PAL_COLORS)
    
    ' 不知道为什么不能用这个(取位图二进制位_)API,而用(复制位图_)API却不会出错
    
    位图信息字节集 ＝ 取空白字节集 (位图信息.结果大小)
    RtlMoveMemory_位图信息 (位图信息字节集, 位图信息, 位图信息.结果大小)
    位图文件头.bfType ＝ 19778
    位图文件头.bfOffBits ＝ 颜色表大小 ＋ 54
    位图文件头.bfSize ＝ 54 ＋ 位图信息.位图大小
    位图文件头字节集 ＝ 取空白字节集 (14)
    RtlMoveMemory_BITMAPFILEHEADER (位图文件头字节集, 位图文件头, 14)
    DeleteObject (位图句柄)
    DeleteDC (源场景)
    ReleaseDC (0, 桌面句柄)
    返回 (位图文件头字节集 ＋ 位图信息字节集 ＋ 颜色表 ＋ 位图像素点阵)

.子程序 图片_屏幕区域截图, 字节集, 公开, 截取桌面指定位置和大小的图片
    .参数 欲截取的左边, 整数型
    .参数 欲截取的顶边, 整数型
    .参数 欲截取的宽度, 整数型
    .参数 欲截取的高度, 整数型
    .局部变量 行宽, 整数型
    .局部变量 文件长度, 整数型
    .局部变量 Head, 字节集
    .局部变量 Data, 字节集
    .局部变量 BitmapHead, BITMAPINFOHEADER
    .局部变量 源场景, 整数型
    .局部变量 色深, 整数型
    .局部变量 目标场景, 整数型
    .局部变量 位图句柄, 整数型
    .局部变量 原位图句柄, 整数型

    源场景 ＝ GetDC (0)
    色深 ＝ GetDeviceCaps (源场景, 12)
    目标场景 ＝ CreateCompatibleDC (源场景)
    位图句柄 ＝ CreateCompatibleBitmap (源场景, 欲截取的宽度, 欲截取的高度)
    原位图句柄 ＝ SelectObject (目标场景, 位图句柄)
    BitBlt (目标场景, 0, 0, 欲截取的宽度, 欲截取的高度, 源场景, 欲截取的左边, 欲截取的顶边, 13369376) ' #SRCCOPY＝13369376
    ReleaseDC (0, 源场景)
    SelectObject (目标场景, 原位图句柄)
    BitmapHead.biSize ＝ 40
    BitmapHead.biWidth ＝ 欲截取的宽度
    BitmapHead.biHeight ＝ 欲截取的高度
    BitmapHead.biPlanes ＝ 1
    BitmapHead.biBitCount ＝ 到短整数 (色深)
    行宽 ＝ 左移 (右移 (欲截取的宽度 × 色深 ＋ 31, 5), 2)
    Data ＝ 取空白字节集 (BitmapHead.biSize ＋ 行宽 × 欲截取的高度)
    .如果真 (Data ＝ { })
        返回 ({ })
    .如果真结束
    RtlMoveMemory_BITMAPINFOHEADER (Data [1], BitmapHead, BitmapHead.biSize)
    .如果 (GetDIBits2 (目标场景, 位图句柄, 0, 欲截取的高度, Data [BitmapHead.biSize ＋ 1], Data [1], 0) ≠ 0)
        文件长度 ＝ 14 ＋ 行宽 × 欲截取的高度
        Data ＝ 到字节集 (“BM”) ＋ 到字节集 (文件长度) ＋ { 0, 0, 0, 0, 54, 0, 0, 0 } ＋ Data
    .否则
        Data ＝ { }
    .如果结束
    DeleteObject (位图句柄)
    DeleteDC (目标场景)
    返回 (Data)

.子程序 取位图深度, 整数型
    .参数 位深, 整数型

    .判断开始 (位深 ＝ 1)
        返回 (8)
    .判断 (位深 ＝ 4)
        返回 (64)
    .判断 (位深 ＝ 8)
        返回 (1024)
    .默认
        返回 (0)
    .判断结束
    

.子程序 图片_通过句柄取图标, 字节集, 公开
    .参数 窗口句柄, 整数型, , 当前窗口句柄
    .参数 图标句柄, 整数型
    .参数 图标宽度, 整数型, 可空
    .参数 图标高度, 整数型, 可空
    .参数 背景颜色, 整数型, 可空
    .局部变量 sRect, 精易_矩形
    .局部变量 sIco, 字节集
    .局部变量 位图操作, 类_位图操作
    .局部变量 SrchDC, 整数型
    .局部变量 newDC, 整数型
    .局部变量 hwnd, 整数型
    .局部变量 hBmp, 整数型
    .局部变量 hBmpPrev, 整数型
    .局部变量 mBrush, 整数型

    .如果真 (是否为空 (图标宽度))
        图标宽度 ＝ 32
    .如果真结束
    .如果真 (是否为空 (图标高度))
        图标高度 ＝ 32
    .如果真结束
    .如果真 (是否为空 (背景颜色))
        背景颜色 ＝ #白色
    .如果真结束
    sRect.顶边 ＝ 0
    sRect.左边 ＝ 0
    sRect.右边 ＝ 图标宽度
    sRect.底边 ＝ 图标高度
    SrchDC ＝ GetDC (窗口句柄)
    newDC ＝ CreateCompatibleDC (SrchDC)
    ' 验证 (newDC)
    hBmp ＝ CreateCompatibleBitmap (SrchDC, 图标宽度, 图标高度)
    ' 验证 (hBmp)
    hBmpPrev ＝ SelectObject (newDC, hBmp)
    ' 验证 (hBmpPrev)
    mBrush ＝ CreateSolidBrush (背景颜色)
    FillRect (newDC, sRect, mBrush)
    DrawIconEx (newDC, 0, 0, 图标句柄, 图标宽度, 图标高度, 0, 0, 3)
    位图操作.从场景创建 (newDC, sRect, 32)
    sIco ＝ 位图操作.取出位图数据 ()
    ReleaseDC (hwnd, SrchDC)
    DeleteDC (newDC)
    DeleteObject (hBmpPrev)
    DeleteObject (hBmp)
    DeleteObject (mBrush)
    返回 (sIco)

.子程序 图片_取宽度, 整数型, 公开, 快速读取图片宽度，失败返回零。
    .参数 参_图片数据, 字节集, , 支持文件路径与图片内容，路径非unicode编码，可用 到字节集()转换
    .局部变量 gdip_Image
    .局部变量 Wid, 整数型
    .局部变量 Hgt, 整数型
    .局部变量 hresult
    .局部变量 GpInput, GdiplusStartupInput
    .局部变量 gdip_Token, 整数型
    .局部变量 FileName, 文本型
    .局部变量 FileExists, 逻辑型
    .局部变量 dwFileSize, 整数型
    .局部变量 hImageMemory, 整数型
    .局部变量 pImageMemory, 整数型
    .局部变量 pIStream, 整数型

    FileName ＝ 到文本 (参_图片数据)
    FileExists ＝ 文件_是否存在 (FileName)
    GpInput.GdiplusVersion ＝ 1
    hresult ＝ GdiplusStartup (gdip_Token, GpInput, 0) ' 启动GDI+
    .如果真 (hresult ＝ 0)
        .如果 (FileExists)
            hresult ＝ GdipLoadImageFromFile (编码_Ansi到Unicode (FileName, ), gdip_Image)
        .否则
            dwFileSize ＝ 取字节集长度 (参_图片数据)
            hImageMemory ＝ GlobalAlloc (#GMEM_MOVEABLE, dwFileSize) ' ; //给图片分配全局内存
            pImageMemory ＝ GlobalLock (hImageMemory) ' ; //锁定内存
            CopyMemory_Bytes2int (pImageMemory, 参_图片数据, dwFileSize)
            hresult ＝ CreateStreamOnHGlobal (hImageMemory, 假, pIStream) ' //用全局内存初使化IStream接口指针
            GdipLoadImageFromStream (pIStream, gdip_Image)
            .如果真 (hresult ＝ 0)
                COM_Release (pIStream)
            .如果真结束
            GlobalUnlock (pImageMemory) ' ; //解锁内存
            GlobalFree (hImageMemory)
        .如果结束
        GdipGetImageWidth (gdip_Image, Wid)
        GdipDisposeImage (gdip_Image)
        GdiplusShutdown (gdip_Token) ' GDI关闭 +
    .如果真结束
    返回 (Wid)

.子程序 图片_取高度, 整数型, 公开, 快速读取图片高度，失败返回零。
    .参数 参_图片数据, 字节集, , 支持文件路径与图片内容，路径非unicode编码，可用 到字节集()转换
    .局部变量 gdip_Image
    .局部变量 Wid, 整数型
    .局部变量 Hgt, 整数型
    .局部变量 hresult
    .局部变量 GpInput, GdiplusStartupInput
    .局部变量 gdip_Token, 整数型
    .局部变量 FileName, 文本型
    .局部变量 FileExists, 逻辑型
    .局部变量 dwFileSize, 整数型
    .局部变量 hImageMemory, 整数型
    .局部变量 pImageMemory, 整数型
    .局部变量 pIStream, 整数型

    FileName ＝ 到文本 (参_图片数据)
    FileExists ＝ 文件_是否存在 (FileName)
    GpInput.GdiplusVersion ＝ 1
    hresult ＝ GdiplusStartup (gdip_Token, GpInput, 0) ' 启动GDI+
    .如果真 (hresult ＝ 0)
        .如果 (FileExists)
            hresult ＝ GdipLoadImageFromFile (编码_Ansi到Unicode (FileName, ), gdip_Image)
        .否则
            dwFileSize ＝ 取字节集长度 (参_图片数据)
            hImageMemory ＝ GlobalAlloc (#GMEM_MOVEABLE, dwFileSize) ' ; //给图片分配全局内存
            pImageMemory ＝ GlobalLock (hImageMemory) ' ; //锁定内存
            CopyMemory_Bytes2int (pImageMemory, 参_图片数据, dwFileSize)
            CreateStreamOnHGlobal (hImageMemory, 假, pIStream) ' //用全局内存初使化IStream接口指针
            GdipLoadImageFromStream (pIStream, gdip_Image)
            .如果真 (hresult ＝ 0)
                COM_Release (pIStream)
            .如果真结束
            GlobalUnlock (pImageMemory) ' ; //解锁内存
            GlobalFree (hImageMemory)
        .如果结束
        GdipGetImageHeight (gdip_Image, Hgt)
        GdipDisposeImage (gdip_Image)
        GdiplusShutdown (gdip_Token) ' GDI关闭 +
    .如果真结束
    返回 (Hgt)

.子程序 图片_取格式, 文本型, 公开, 根据文件头部判断文件格式，成功返回格式名称，失败返回空。
    .参数 绝对路径, 文本型, , 绝对路径

    返回 (图片_取格式W (编码_Ansi到Unicode (绝对路径)))

.子程序 图片_取格式W, 文本型, 公开, 根据文件头部判断文件格式，成功返回格式名称，失败返回空。
    .参数 绝对路径, 字节集, , 绝对路径->Unicode
    .局部变量 hFile, 整数型
    .局部变量 data, 字节集
    .局部变量 Hex, 文本型
    .局部变量 readSize, 整数型

    hFile ＝ CreateFileW (绝对路径, #FILE_GENERIC_READ, 位或 (#FILE_SHARE_READ, #FILE_SHARE_WRITE, #FILE_SHARE_DELETE), #NULL, #OPEN_EXISTING, #FILE_ATTRIBUTE_NORMAL, #NULL)
    .如果真 (hFile ＝ #INVALID_HANDLE_VALUE)
        返回 (“”)
    .如果真结束
    data ＝ 取空白字节集 (16)
    ReadFile_字节集 (hFile, data, 16, readSize, #NULL)
    CloseHandle (hFile)
    .如果真 (readSize ＝ 16)
        Hex ＝ 字节集_字节集到十六进制 (data)
        .判断开始 (Hex ≈ “FFD8FF”) ' JPEG
            返回 (“JPEG”)
        .判断 (Hex ≈ “89504E470D0A1A0A0000000D49484452”) ' PNG
            返回 (“PNG”)
        .判断 (Hex ≈ “47494638” 或 Hex ≈ “474946383761” 或 Hex ≈ “474946383961”) ' GIF
            返回 (“GIF”)
        .判断 (Hex ≈ “49492A00” 或 Hex ≈ “4D4D002A” 或 Hex ≈ “49492A00”) ' TIFF
            返回 (“TIFF”)
        .判断 (Hex ≈ “424D”) ' BMP
            返回 (“BMP”)
        .判断 (Hex ≈ “0A”) ' PCX
            返回 (“PCX”)
        .判断 (Hex ≈ “3C”) ' SVG
            返回 (“SVG”)
        .判断 (Hex ≈ “38425053000100000000000000”) ' PSD
            返回 (“PSD”)
        .判断 (Hex ≈ “465753”) ' SWF
            返回 (“SWF”)
        .判断 (Hex ≈ “D7CDC69A0000”) ' WMF
            返回 (“WMF”)
        .判断 (Hex ≈ “01000000”) ' EMF
            返回 (“EMF”)
        .判断 (Hex ≈ “C5D0D3C6”) ' EPS
            返回 (“EPS”)
        .判断 (Hex ≈ “0000020000” 或 Hex ≈ “0000100000”) ' TGA
            返回 (“TGA”)
        .判断 (Hex ≈ “00000100”) ' ICO
            返回 (“ICO”)
        .判断 (Hex ≈ “00000200”) ' CUR
            返回 (“CUR”)
        .判断 (Hex ≈ “52494646”) ' ANI or WEBP
            .如果真 (取文本中间 (Hex, 17, 8) ＝ “57454250”)
                返回 (“WEBP”)
            .如果真结束
            返回 (“ANI”)
        .判断 (Hex ≈ “464F524D”) ' IFF
            返回 (“IFF”)
        .默认
            
        .判断结束
        
    .如果真结束
    返回 (“”)

.子程序 SaveBitmapToImage, 字节集, 公开, Save => BMP
    .参数 hBitmap, 整数型
    .局部变量 hDC, 整数型
    .局部变量 iBits, 整数型
    .局部变量 wBitCount, 短整数型
    .局部变量 Bitmap, 整数型
    .局部变量 lpbi, 整数型
    .局部变量 dwBmBitsSize, 整数型
    .局部变量 hDib, 整数型
    .局部变量 dwPaletteSize, 整数型
    .局部变量 hPal, 整数型
    .局部变量 hOldPal, 整数型
    .局部变量 bmfHdr, 整数型
    .局部变量 dwDIBSize, 整数型
    .局部变量 szBinary, 字节集

    hDC ＝ CreateDCW (编码_Ansi到Unicode (“DISPLAY”, ), #NULL, #NULL, #NULL)
    iBits ＝ GetDeviceCaps (hDC, #BITSPIXEL) × GetDeviceCaps (hDC, #PLANES)
    DeleteDC (hDC)
    .判断开始 (iBits ≤ 1)
        wBitCount ＝ 1
    .判断 (iBits ≤ 4)
        wBitCount ＝ 4
    .判断 (iBits ≤ 8)
        wBitCount ＝ 8
    .默认
        wBitCount ＝ 24
    .判断结束
    Bitmap ＝ LocalAlloc (#LMEM_ZEROINIT, 24) ' sizeof(BITMAP)
    GetObjectW (hBitmap, 24, Bitmap)
    dwBmBitsSize ＝ (__get (Bitmap, 4) × wBitCount ＋ 31) ÷ 32 × 4 × __get (Bitmap, 8)
    hDib ＝ GlobalAlloc (位或 (#GMEM_MOVEABLE, #GMEM_ZEROINIT), dwBmBitsSize ＋ dwPaletteSize ＋ 40) ' dwBmBitsSize + dwPaletteSize + sizeof(BITMAPINFOHEADER)
    lpbi ＝ GlobalLock (hDib)
    __set (lpbi, 0, 40) ' biSize => sizeof(BITMAPINFOHEADER)
    __set (lpbi, 4, __get (Bitmap, 4)) ' biWidth => bmWidth
    __set (lpbi, 8, __get (Bitmap, 8)) ' biHeight => bmHeight
    __set_short (lpbi, 12, 1) ' biPlanes
    __set_short (lpbi, 14, wBitCount) ' biBitCount
    __set (lpbi, 16, 0) ' biCompression => BI_RGB
    hPal ＝ GetStockObject (#DEFAULT_PALETTE)
    .如果真 (hPal ≠ #NULL)
        hDC ＝ GetDC (#NULL)
        hOldPal ＝ SelectPalette (hDC, hPal, 假)
        RealizePalette (hDC)
    .如果真结束
    GetDIBits4 (hDC, hBitmap, 0, __get (Bitmap, 8), lpbi ＋ 40 ＋ dwPaletteSize, lpbi, #DIB_RGB_COLORS) ' lpbi + sizeof(BITMAPINFOHEADER) + dwPaletteSize
    .如果真 (hOldPal ≠ #NULL)
        SelectPalette (hDC, hOldPal, 真)
        RealizePalette (hDC)
        ReleaseDC (#NULL, hDC)
    .如果真结束
    bmfHdr ＝ LocalAlloc (#LMEM_ZEROINIT, 14) ' sizeof(BITMAPFILEHEADER)
    __set_short (bmfHdr, 0, 19778) ' bfType => "BM"
    dwDIBSize ＝ 14 ＋ 40 ＋ dwPaletteSize ＋ dwBmBitsSize ' sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER) + dwPaletteSize + dwBmBitsSize
    __set (bmfHdr, 2, dwDIBSize) ' bfSize
    __set (bmfHdr, 10, 14 ＋ 40 ＋ dwPaletteSize) ' sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER) + dwPaletteSize
    szBinary ＝ 指针到字节集 (bmfHdr, 14) ＋ 指针到字节集 (lpbi, dwDIBSize) ' sizeof(BITMAPFILEHEADER)
    LocalFree (bmfHdr)
    GlobalUnlock (hDib)
    GlobalFree (hDib)
    LocalFree (lpbi)
    LocalFree (Bitmap)
    返回 (szBinary)

.子程序 CopyBitmap, 整数型, 公开, Copy => hBitmap
    .参数 hBitmap, 整数型
    .参数 x, 整数型, 可空
    .参数 y, 整数型, 可空
    .参数 cx, 整数型, 可空
    .参数 cy, 整数型, 可空
    .局部变量 hDC, 整数型
    .局部变量 hdcMem, 整数型
    .局部变量 hdcSrc, 整数型
    .局部变量 pv, 整数型
    .局部变量 bufDC, 整数型
    .局部变量 hOldBm, 整数型
    .局部变量 hgdiobj, 整数型

    hDC ＝ GetDC (#NULL)
    hdcMem ＝ CreateCompatibleDC (hDC)
    hdcSrc ＝ SelectObject (hdcMem, hBitmap)
    pv ＝ LocalAlloc (#LMEM_ZEROINIT, 24) ' sizeof(BITMAP)
    GetObjectW (hBitmap, 24, pv) ' sizeof(BITMAP)
    .如果真 (是否为空 (cx))
        cx ＝ __get (pv, 4) ' BITMAP => bmWidth
    .如果真结束
    .如果真 (是否为空 (cy))
        cy ＝ __get (pv, 8) ' BITMAP => bmHeight
    .如果真结束
    LocalFree (pv)
    bufDC ＝ CreateCompatibleDC (hDC)
    hOldBm ＝ CreateCompatibleBitmap (hDC, cx, cy)
    hgdiobj ＝ SelectObject (bufDC, hOldBm)
    BitBlt (bufDC, 0, 0, cx, cy, hdcMem, x, y, #SRCCOPY)
    SelectObject (bufDC, hgdiobj)
    DeleteDC (bufDC)
    SelectObject (hdcMem, hdcSrc)
    DeleteDC (hdcMem)
    ReleaseDC (#NULL, hDC)
    返回 (hOldBm)

.子程序 图片_WIA缩放, 字节集, 公开, 返回修改大小后的图片
    .参数 文件名, 文本型
    .参数 设置宽度, 整数型
    .参数 设置高度, 整数型
    .参数 按比例缩放, 逻辑型, 可空, 默认假
    .参数 输出路径, 文本型, 可空, 保存修改大小的图片文件
    .局部变量 img, 对象
    .局部变量 ip, 对象

    img.创建 (“WIA.ImageFile”, )
    ip.创建 (“WIA.ImageProcess”, )
    img.方法 (“LoadFile”, 文件名)
    ip.读对象型属性 (“Filters”, ).方法 (“Add”, ip.读对象型属性 (“FilterInfos”, ).读对象型属性 (“Item”, “Scale”).读文本属性 (“FilterID”, ), 0)
    ip.读对象型属性 (“Filters”, ).读对象型属性 (“Item”, 1).读对象型属性 (“Properties”, ).读对象型属性 (“Item”, “MaximumHeight”).写属性 (“Value”, 设置高度)
    ip.读对象型属性 (“Filters”, ).读对象型属性 (“Item”, 1).读对象型属性 (“Properties”, ).读对象型属性 (“Item”, “MaximumWidth”).写属性 (“Value”, 设置宽度)
    ip.读对象型属性 (“Filters”, ).读对象型属性 (“Item”, 1).读对象型属性 (“Properties”, ).读对象型属性 (“Item”, “PreserveAspectRatio”).写属性 (“Value”, 按比例缩放)
    img ＝ ip.对象型方法 (“Apply”, img)
    .如果真 (是否为空 (输出路径) ＝ 假)
        img.方法 (“SaveFile”, 输出路径)
    .如果真结束
    返回 (img.读对象型属性 (“FileData”, ).读属性 (“BinaryData”, ).取字节集 ())

.子程序 GetImageFileToBitmap, 整数型, 公开, ImageFile => hBitmap
    .参数 wszFileName, 字节集, , jpg; gif
    .局部变量 hFile, 整数型
    .局部变量 dwFileSize, 整数型
    .局部变量 hImageMemory, 整数型
    .局部变量 pImageMemory, 整数型
    .局部变量 dwReadSize, 整数型
    .局部变量 pIStream, 整数型
    .局部变量 pIPicture, 整数型
    .局部变量 pHandle, 整数型
    .局部变量 hBitmap, 整数型
    .局部变量 hr, 整数型

    hFile ＝ CreateFileW (wszFileName, #GENERIC_READ, #FILE_SHARE_READ, #NULL, #OPEN_EXISTING, #FILE_ATTRIBUTE_NORMAL, #NULL)
    .如果真 (hFile ≠ #INVALID_HANDLE_VALUE)
        dwFileSize ＝ GetFileSize (hFile, #NULL)
        hImageMemory ＝ GlobalAlloc (#GMEM_MOVEABLE, dwFileSize)
        .如果真 (hImageMemory ≠ #NULL)
            pImageMemory ＝ GlobalLock (hImageMemory)
            ReadFile_整数型 (hFile, pImageMemory, dwFileSize, dwReadSize, #NULL)
            GlobalUnlock (hImageMemory)
            hr ＝ CreateStreamOnHGlobal (hImageMemory, 假, pIStream)
            .如果真 (hr ＝ #S_OK 且 pIStream ≠ #NULL)
                hr ＝ OleLoadPicture (pIStream, 0, 假, 取指针_字节集型 (#IID_IPicture), pIPicture)
                .如果真 (hr ＝ #S_OK 且 pIPicture ≠ #NULL)
                    hr ＝ CallObject (pIPicture, #IPicture_get_Handle, 取指针整数_ (pHandle), , , , , , , , )
                    .如果真 (hr ＝ #S_OK 且 pHandle ≠ #NULL)
                        hBitmap ＝ CopyImage (pHandle, #IMAGE_BITMAP, 0, 0, #LR_COPYRETURNORG)
                    .如果真结束
                    SafeRelease (pIPicture)
                .如果真结束
                SafeRelease (pIStream)
            .如果真结束
            GlobalFree (hImageMemory)
        .如果真结束
        CloseHandle (hFile)
    .如果真结束
    返回 (hBitmap)

.子程序 GetImageToBitmap, 整数型, 公开, Image => hBitmap
    .参数 imageData, 字节集, , image
    .局部变量 dwSize, 整数型
    .局部变量 hImageMemory, 整数型
    .局部变量 pImageMemory, 整数型
    .局部变量 pIStream, 整数型
    .局部变量 pIPicture, 整数型
    .局部变量 pHandle, 整数型
    .局部变量 hBitmap, 整数型
    .局部变量 hr, 整数型

    dwSize ＝ 取字节集长度 (imageData)
    .如果真 (dwSize ＞ 0)
        hImageMemory ＝ GlobalAlloc (#GMEM_MOVEABLE, dwSize)
        .如果真 (hImageMemory ≠ #NULL)
            pImageMemory ＝ GlobalLock (hImageMemory)
            memcpy (pImageMemory, 取指针字节集_ (imageData), dwSize)
            GlobalUnlock (hImageMemory)
            hr ＝ CreateStreamOnHGlobal (hImageMemory, 假, pIStream)
            .如果真 (hr ＝ #S_OK 且 pIStream ≠ #NULL)
                hr ＝ OleLoadPicture (pIStream, 0, 假, 取指针_字节集型 (#IID_IPicture), pIPicture)
                .如果真 (hr ＝ #S_OK 且 pIPicture ≠ #NULL)
                    hr ＝ CallObject (pIPicture, #IPicture_get_Handle, 取指针整数_ (pHandle), , , , , , , , )
                    .如果真 (hr ＝ #S_OK 且 pHandle ≠ #NULL)
                        hBitmap ＝ CopyImage (pHandle, #IMAGE_BITMAP, 0, 0, #LR_COPYRETURNORG)
                    .如果真结束
                    SafeRelease (pIPicture)
                .如果真结束
                SafeRelease (pIStream)
            .如果真结束
            GlobalFree (hImageMemory)
        .如果真结束
        
    .如果真结束
    返回 (hBitmap)

.版本 2

.程序集 文件拖放, , 公开, 文件拖放
.程序集变量 hWndControl, 整数型
.程序集变量 WndProc, 整数型
.程序集变量 oldWndProc, 整数型
.程序集变量 lpPrevWndFunc, 整数型
.程序集变量 iswchar, 逻辑型

.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
    

.子程序 _销毁
    拖放对象_撤销 ()

.子程序 拖放对象_注册, , 公开, 将类命令声明到程序集，局部变量会失败
    .参数 窗口句柄, 整数型
    .参数 挂接拖放事件, 子程序指针, , 创建一个取回文件名子程序.需要带参数;   参数1:文本型
    .参数 使用Unicode字符集, 逻辑型, 可空, 为真时挂接拖放事件接收宽字符

    hWndControl ＝ 窗口句柄
    lpPrevWndFunc ＝ 到整数 (挂接拖放事件)
    iswchar ＝ 使用Unicode字符集
    .如果真 (_WIN32_WINNT ≥ #_WIN32_WINNT_VISTA)
        ChangeWindowMessageFilter (#WM_DROPFILES, #MSGFLT_ADD)
        ChangeWindowMessageFilter (#WM_COPYDATA, #MSGFLT_ADD)
        ChangeWindowMessageFilter (#WM_COPYGLOBALDATA, #MSGFLT_ADD)
    .如果真结束
    DragAcceptFiles (hWndControl, 1)
    WndProc ＝ 类_取内部方法地址 (5) ' 拖放对象回调
    oldWndProc ＝ SetWindowLongW (hWndControl, #GWL_WNDPROC, WndProc)

.子程序 拖放对象_撤销, , 公开
    DragAcceptFiles (hWndControl, 0)
    .如果真 (oldWndProc ≠ #NULL)
        SetWindowLongW (hWndControl, #GWL_WNDPROC, oldWndProc)
        oldWndProc ＝ #NULL
    .如果真结束
    .如果真 (WndProc ≠ #NULL)
        类_释放内部方法地址 (WndProc)
        WndProc ＝ #NULL
    .如果真结束
    lpPrevWndFunc ＝ #NULL
    iswchar ＝ 假

.子程序 拖放对象回调, 整数型
    .参数 hWnd, 整数型
    .参数 uMsg, 整数型
    .参数 hDrop, 整数型
    .参数 lParam, 整数型
    .局部变量 pwzFilePath, 整数型
    .局部变量 szFilePath, 文本型
    .局部变量 nNumOfFiles, 整数型
    .局部变量 i, 整数型

    .如果真 (uMsg ＝ #WM_DROPFILES)
        nNumOfFiles ＝ DragQueryFileW (hDrop, -1, #NULL, 0)
        .如果真 (nNumOfFiles ＞ 0)
            pwzFilePath ＝ LocalAlloc (#LMEM_ZEROINIT, 1025 × 2)
            .如果真 (pwzFilePath ≠ #NULL)
                .变量循环首 (0, nNumOfFiles － 1, 1, i)
                    memset (pwzFilePath, 0, 1025 × 2)
                    .如果 (iswchar) ' 使用Unicode字符集
                        DragQueryFileW (hDrop, i, pwzFilePath, 1024)
                    .否则
                        DragQueryFileA (hDrop, i, pwzFilePath, 1024)
                    .如果结束
                    调用子程序_ (lpPrevWndFunc, pwzFilePath, , , , , , , , , , , , , , )
                .变量循环尾 ()
                LocalFree (pwzFilePath)
            .如果真结束
            
        .如果真结束
        DragFinish (hDrop)
        返回 (0)
    .如果真结束
    返回 (CallWindowProcW (oldWndProc, hWnd, uMsg, hDrop, lParam))

.版本 2

.程序集 集_文件目录
.程序集变量 程序集_文件数组, 文本型, , "0"

.子程序 文件_是否被占用, 逻辑型, 公开
    .参数 文件路径, 文本型
    .局部变量 hFile, 整数型

    .如果真 (文件是否存在 (文件路径))
        hFile ＝ CreateFileA (文件路径, #GENERIC_WRITE, 0, 0, #OPEN_EXISTING, #FILE_ATTRIBUTE_NORMAL, 0)
        .如果真 (hFile ≠ #INVALID_HANDLE_VALUE)
            CloseHandle (hFile)
            返回 (假)
        .如果真结束
        返回 (真)
    .如果真结束
    返回 (假)

.子程序 文件_创建稀疏文件, 整数型, 公开, 成功返回文件句柄
    .参数 参_文件名, 文本型
    .局部变量 局_文件句柄, 整数型

    .如果真 (系统_磁盘是否支持稀疏文件 (参_文件名) ＝ 假)
        返回 (0)
    .如果真结束
    .如果真 (文件是否存在 (参_文件名) ＝ 假)
        局_文件句柄 ＝ 打开文件 (参_文件名, #改写, )
        写出数据 (局_文件句柄, { 0 })
        关闭文件 (局_文件句柄)
    .如果真结束
    局_文件句柄 ＝ CreateFileA (参_文件名, 位或 (#GENERIC_READ, #GENERIC_WRITE), 位或 (#FILE_SHARE_READ, #FILE_SHARE_WRITE), 0, #OPEN_EXISTING, 0, 0)
    DeviceIoControl1 (局_文件句柄, #FSCTL_SET_SPARSE, 0, 0, 0, 0, 0, 0)
    返回 (局_文件句柄)

.子程序 文件_是否是稀疏文件, 逻辑型, 公开
    .参数 参_文件名, 文本型
    .局部变量 局_文件属性, 整数型

    局_文件属性 ＝ GetFileAttributesA (参_文件名)
    .如果真 (局_文件属性 ＝ -1)
        返回 (假)
    .如果真结束
    .如果 (位与 (局_文件属性, #FILE_ATTRIBUTE_SPARSE_FILE) ＝ 512)
        返回 (真)
    .否则
        返回 (假)
    .如果结束
    

.子程序 文件_取图标, 字节集, 公开, 返回指定文件路径文件的图标
    .参数 窗口句柄, 整数型, , 当前程序的窗口句柄
    .参数 文件路径, 文本型, , 文件的完整路径
    .参数 宽度, 整数型
    .参数 高度, 整数型
    .参数 背景色, 整数型, 可空
    .局部变量 ImgHandle, 整数型
    .局部变量 Bin, 字节集

    .如果真 (是否为空 (背景色))
        背景色 ＝ #品红
    .如果真结束
    ImgHandle ＝ 文件_取图标句柄 (文件路径)
    Bin ＝ 图片_通过句柄取图标 (窗口句柄, ImgHandle, 宽度, 高度, 背景色)
    DestroyIcon (ImgHandle)
    返回 (Bin)

.子程序 文件_文件名是否可用, 逻辑型, 公开
    .参数 文件名, 文本型
    .局部变量 dwLen, 整数型
    .局部变量 aryChar, 文本型, , "0"
    .局部变量 i, 整数型

    dwLen ＝ 取文本长度 (文件名)
    .如果真 (dwLen ＞ 255)
        输出调试文本 (“除非使用UNICODE路径，否则名称不能超过 255 个字符！”)
        返回 (假)
    .如果真结束
    dwLen ＝ 文本_逐字分割 (#常量_过滤字符, aryChar)
    .计次循环首 (dwLen, i)
        .如果真 (寻找文本 (文件名, aryChar [i], , 假) ≠ -1)
            返回 (假)
        .如果真结束
        
    .计次循环尾 ()
    .如果真 (文件_是否存在 (文件名))
        返回 (假)
    .如果真结束
    返回 (真)

.子程序 文件_取文件信息, 文本型, 公开, 取指定文件相关信息，默认取备注
    .参数 文件路径, 文本型
    .参数 类型, 整数型, 可空, “1备注”, “2公司名”, “3描述”, “4文件版本”, “5内部名称”, “6版权”, “7合法商标”, “8原文件名”, “9个人用编译版说明”, “10产品名称”, “11产品版本”, “12特殊编译版说明”
    .局部变量 dwType, 整数型

    .如果 (类型 ＜ 1 或 类型 ＞ 12)
        dwType ＝ 8
    .否则
        dwType ＝ 多项选择 (类型, 8, 1, 2, 0, 3, 4, 5, 6, 9, 7, 0, 10)
    .如果结束
    返回 (编码_Unicode到Ansi (文件_取文件版本信息W (编码_Ansi到Unicode (文件路径, ), dwType)))

.子程序 文件_取文件版本信息W, 字节集, 公开, 成功返回文件指定类型的信息
    .参数 文件名, 字节集
    .参数 类型, 整数型, 可空, 0、文件版本；1、公司名称；2、文件描述；3、内部名称；4、合法版权；5、合法商标；6、源文件名；7、产品名称；8、备注；9、个人编译版说明；10、特殊编译版说明；11、语言
    .局部变量 dwInfoSize, 整数型
    .局部变量 dwHandle, 整数型
    .局部变量 pData, 整数型
    .局部变量 aryType, 文本型, , "0"
    .局部变量 wzSubBlock, 字节集
    .局部变量 pwzBuf, 整数型
    .局部变量 nBufLen, 整数型
    .局部变量 wzBuf, 字节集
    .局部变量 dwFileVersionMS, 整数型
    .局部变量 dwFileVersionLS, 整数型
    .局部变量 aryLanguage, 短整数型, , "0"
    .局部变量 wCodePage, 短整数型
    .局部变量 dwLangCodePage, 整数型
    .局部变量 szLangCodePage, 文本型
    .局部变量 dwLen, 整数型
    .局部变量 i, 整数型

    dwInfoSize ＝ GetFileVersionInfoSizeW (文件名, dwHandle)
    .如果真 (dwInfoSize ＞ 0)
        pData ＝ LocalAlloc (#LMEM_ZEROINIT, dwInfoSize)
        .如果真 (GetFileVersionInfoW (文件名, #NULL, dwInfoSize, pData))
            aryType ＝ { “\”, “CompanyName”, “FileDescription”, “InternalName”, “LegalCopyright”, “LegalTrademarks”, “OriginalFilename”, “ProductName”, “Comments”, “PrivateBuild”, “SpecialBuild”, “” } ' 留空是用来取语言的
            .如果 (类型 ≤ 0 或 类型 ＋ 1 ＞ 取数组成员数 (aryType))
                wzSubBlock ＝ 编码_Ansi到Unicode (aryType [1], )
                .如果真 (VerQueryValueW (pData, wzSubBlock, pwzBuf, nBufLen))
                    dwFileVersionMS ＝ __get (pwzBuf, 8)
                    dwFileVersionLS ＝ __get (pwzBuf, 12)
                    wzBuf ＝ 编码_Ansi到Unicode (到文本 (HIWORD (dwFileVersionMS)) ＋ “.” ＋ 到文本 (LOWORD (dwFileVersionMS)) ＋ “.” ＋ 到文本 (HIWORD (dwFileVersionLS)) ＋ “.” ＋ 到文本 (LOWORD (dwFileVersionLS)), )
                .如果真结束
                
            .否则
                wzSubBlock ＝ 编码_Ansi到Unicode (“\VarFileInfo\Translation”, )
                .如果真 (VerQueryValueW (pData, wzSubBlock, pwzBuf, nBufLen))
                    dwLangCodePage ＝ __get_short (pwzBuf, 0)
                    .如果 (aryType [类型 ＋ 1] ＝ “”) ' 是否为取语言
                        pwzBuf ＝ LocalAlloc (#LMEM_ZEROINIT, 128 × 2)
                        nBufLen ＝ VerLanguageNameW (dwLangCodePage, pwzBuf, 127)
                        .如果真 (nBufLen ＞ 0)
                            wzBuf ＝ 指针到字节集 (pwzBuf, nBufLen × 2)
                        .如果真结束
                        LocalFree (pwzBuf)
                    .否则
                        wCodePage ＝ __get_short (pwzBuf, 2)
                        ' 2052 中文
                        ' 1033 英文
                        aryLanguage ＝ { 2052, 1033 }
                        .如果真 (dwLangCodePage ≠ 2052 且 dwLangCodePage ≠ 1033)
                            加入成员 (aryLanguage, dwLangCodePage)
                        .如果真结束
                        dwLen ＝ 取数组成员数 (aryLanguage)
                        .计次循环首 (dwLen, i)
                            szLangCodePage ＝ 进制_十到十六 (MAKELONG (wCodePage, aryLanguage [i]), 真)
                            wzSubBlock ＝ 编码_Ansi到Unicode (“\StringFileInfo\” ＋ szLangCodePage ＋ “\” ＋ aryType [类型 ＋ 1], )
                            .如果真 (VerQueryValueW (pData, wzSubBlock, pwzBuf, nBufLen))
                                wzBuf ＝ 指针到字节集 (pwzBuf, nBufLen × 2)
                                跳出循环 ()
                            .如果真结束
                            
                        .计次循环尾 ()
                    .如果结束
                    
                .如果真结束
                
            .如果结束
            
        .如果真结束
        LocalFree (pData)
    .如果真结束
    返回 (wzBuf)

.子程序 文件_取文件版本号, 文本型, 公开, 返回指定文件的版本号
    .参数 FullFileName, 文本型
    .参数 错误信息, 文本型, 参考 可空
    .局部变量 size, 整数型
    .局部变量 文件版本字节集, 字节集
    .局部变量 lVerPointer, 整数型
    .局部变量 返回长度, 整数型

    .局部变量 bytebuffer, 字节型, , "261"
    .局部变量 HexNumber, 整数型
    .局部变量 Lang_Charset_String, 文本型
    .局部变量 临时_文本, 文本型
    .局部变量 rc, 整数型
    .局部变量 文件版本, 文本型

    size ＝ GetFileVersionInfoSize (FullFileName, 0)
    .如果真 (size ≤ 0)
        错误信息 ＝ “GetFileVersionInfoSize（获取信息长度）失败”
        返回 (“”)
    .如果真结束
    文件版本字节集 ＝ 取空白字节集 (size)
    
    .如果真 (GetFileVersionInfo (FullFileName, 0, size, 文件版本字节集) ＝ 假)
        错误信息 ＝ “GetFileVersionInfo（获取信息）失败”
        返回 (“”)
    .如果真结束
    
    .如果真 (VerQueryValue (文件版本字节集, “\VarFileInfo\Translation”, lVerPointer, 返回长度) ＝ 假)
        错误信息 ＝ “VerQueryValue（查询Version）失败”
        返回 (“”)
    .如果真结束
    RtlMoveMemory (取数据_通用型_数组 (bytebuffer), lVerPointer, 返回长度)
    HexNumber ＝ bytebuffer [3] ＋ bytebuffer [4] × 256 ＋ bytebuffer [1] × 65536 ＋ bytebuffer [2] × 16777216
    rc ＝ 到长整数 (bytebuffer [1] ＋ bytebuffer [2] × 256)
    Lang_Charset_String ＝ 取十六进制文本 (HexNumber)
    
    .判断循环首 (取文本长度 (Lang_Charset_String) ＜ 8)
        Lang_Charset_String ＝ “0” ＋ Lang_Charset_String
    .判断循环尾 ()
    
    临时_文本 ＝ 取空白文本 (261)
    临时_文本 ＝ “\StringFileInfo\” ＋ Lang_Charset_String ＋ “\FileVersion”
    .如果 (VerQueryValue (文件版本字节集, 临时_文本, lVerPointer, 返回长度))
        文件版本 ＝ 取空白文本 (返回长度)
        lstrcpy (文件版本, lVerPointer)
    .否则
        文件版本 ＝ “”
    .如果结束
    
    返回 (文件版本)
    

.子程序 目录_处理, 文本型, 公开, 检测最后一个字符是否为“\”如果不是则加上，某些支持库或组件要求必须结尾有\等符号才能识别为目录。源码由雪山凌狐提供
    .参数 要处理的目录, 文本型, , 传入要检测和处理的目录路径
    .局部变量 返回值, 文本型

    返回值 ＝ 要处理的目录
    .如果真 (取文本右边 (要处理的目录, 1) ≠ “\”)
        返回值 ＝ 返回值 ＋ “\”
    .如果真结束
    返回 (返回值)

.子程序 文件_枚举EX, , 公开, 遍历特定目录特定后缀名的所有文件，结果在回调函数中输出，源码由雪山凌狐提供
    .参数 查找的目录, 文本型, , 程序内部会自动给目录结尾加上“\”
    .参数 后缀名, 文本型, 可空, 默认为“*”，即查找所有后缀名文件，如果传入空文本参数，则同样视为遍历所有后缀名文件
    .参数 是否遍历子目录, 逻辑型, 可空, 默认为假，即仅遍历根目录的文件
    .参数 回调函数, 子程序指针, 可空, 指定一个外部的子程序可以在每次找出一个文件的时候运行，该函数的第一个参数为查找到的文件名，第二个参数为文件的完整路径
    .局部变量 文件名, 文本型
    .局部变量 文件目录, 文本型
    .局部变量 完整路径, 文本型
    .局部变量 前缀, 文本型

    ' 初始化可空参数
    .如果真 (是否为空 (后缀名) 或 后缀名 ＝ “”)
        后缀名 ＝ “*”
    .如果真结束
    .如果真 (是否为空 (是否遍历子目录))
        是否遍历子目录 ＝ 假
    .如果真结束
    
    .如果 (寻找文本 (后缀名, “*.”, , 假) ≠ -1)
        前缀 ＝ “”
    .否则
        前缀 ＝ “*.”
    .如果结束
    
    
    
    ' 规范化传入的目录名
    .如果真 (取文本右边 (查找的目录, 1) ≠ “\”)
        查找的目录 ＝ 查找的目录 ＋ “\”
    .如果真结束
    
    ' 初始化查找
    文件名 ＝ 寻找文件 (查找的目录 ＋ 前缀 ＋ 后缀名, )
    ' 循环查找内容
    .判断循环首 (文件名 ≠ “”)
        
        ' 回调运行
        ' 调用子程序 (回调函数, , , 文件名, 查找的目录 ＋ 文件名)
        完整路径 ＝ 查找的目录 ＋ 文件名
        
        .如果真 (后缀名 ≠ “*”)
            ' .如果真 (文件_取扩展名 (完整路径) ≠ “.” ＋ 后缀名)
                ' 到循环尾 ()
            ' .如果真结束
            
        .如果真结束
        
        程序_Call (到整数 (回调函数), lstrcpyn_文本型 (文件名, 文件名, 0), lstrcpyn_文本型 (完整路径, 完整路径, 0))
        
        ' 再次查找
        文件名 ＝ 寻找文件 (, )
    .判断循环尾 ()
    
    ' 子目录文件查找
    .如果真 (是否遍历子目录)
        文件目录 ＝ 寻找文件 (查找的目录 ＋ “*.*”, #子目录)
        
        .判断循环首 (文件目录 ≠ “”)
            .如果真 (文件目录 ≠ “.” 且 文件目录 ≠ “..”)
                ' 递归调用，精髓所在
                文件_枚举EX (查找的目录 ＋ 文件目录, 后缀名, 真, 回调函数)
                处理事件 ()
            .如果真结束
            
            文件目录 ＝ 寻找文件 (, #子目录)
            
        .判断循环尾 ()
        
    .如果真结束
    

.子程序 文件_打开, 整数型, 公开, 文件必须存在，成功返回文件句柄，失败返回-1
    .参数 文件路径, 文本型
    .参数 执行模式, 整数型, 可空, 可空。0=API方式，1=核心支持库方式。默认为0，用API方式。
    .局部变量 hFile, 整数型

    .如果 (执行模式 ＝ 0)
        hFile ＝ CreateFileA (文件路径, 位或 (#GENERIC_READ, #GENERIC_WRITE), #FILE_SHARE_READ, 0, #OPEN_EXISTING, #FILE_FLAG_SEQUENTIAL_SCAN, 0)
    .否则
        hFile ＝ 打开文件 (文件路径, #读写, #无限制)
    .如果结束
    返回 (hFile)

.子程序 文件_关闭, , 公开, 关闭后,将文件号设置为0
    .参数 文件号, 整数型, 参考
    .参数 执行模式, 整数型, 可空, 可空。0=API方式，1=核心支持库方式。默认为0，用API方式。

    .如果真 (文件号 ＞ 0)
        .如果 (执行模式 ＝ 0)
            CloseHandle (文件号)
        .否则
            关闭文件 (文件号)
        .如果结束
        
    .如果真结束
    

.子程序 文件_重启电脑后替换, , 公开, 感谢【微凉清风】提供此函数
    .参数 用于替换的文件路径, 文本型
    .参数 被替换目标文件路径, 文本型
    .参数 是否删除源文件, 逻辑型, 可空, 可空，默认为假。是否删除“用于替换的文件路径”

    .如果真 (是否删除源文件 ＝ 真)
        MoveFileExA (用于替换的文件路径, 字符 (0), 4) ' #MOVEFILE_DELAY_UNTIL_REBOOT
    .如果真结束
    MoveFileExA (用于替换的文件路径, 被替换目标文件路径, 4) ' #MOVEFILE_DELAY_UNTIL_REBOOT

.子程序 文件_写出字节集, 逻辑型, 公开, 成功返回真，失败返回假。
    .参数 文件号, 整数型, , 由  文件_打开 函数返回文件句柄，不支持 易自带 打开文件(）命令。
    .参数 要写入的数据, 字节集
    .参数 执行模式, 整数型, 可空, 可空。0=API方式，1=核心支持库方式。默认为0，用API方式。
    .局部变量 t, 字节集

    .如果真 (文件号 ＞ 0)
        t ＝ 取空白字节集 (取字节集长度 (要写入的数据))
        RtlMoveMemory_字节集2 (t, 要写入的数据, 取字节集长度 (要写入的数据))
        .如果真 (执行模式 ＝ 0)
            返回 (WriteFile (文件号, t, 取字节集长度 (要写入的数据), 0, 0))
        .如果真结束
        返回 (写出字节集 (文件号, 要写入的数据))
    .如果真结束
    返回 (假)

.子程序 文件_读入字节集, 整数型, 公开, 成功 = 非0    失败 = 0
    .参数 参_文件号, 整数型
    .参数 参_读入的字节集, 字节集
    .参数 参_读入长度, 长整数型, 可空, 调用 文件_取实际大小 获取
    .参数 参_读入字符数, 整数型, 可空, 默认1024

    .如果真 (是否为空 (参_读入长度))
        GetFileSizeEx (参_文件号, 取指针长整数_ (参_读入长度))
    .如果真结束
    
    .如果真 (是否为空 (参_读入字符数))
        参_读入字符数 ＝ 1024
    .如果真结束
    参_读入的字节集 ＝ 取空白字节集 (参_读入长度)
    返回 (ReadFile (参_文件号, 参_读入的字节集, 参_读入长度, 参_读入字符数, 0))

.子程序 文件_移动读写位置, 逻辑型, 公开, 成功返回真，失败返回假。
    .参数 文件号, 整数型
    .参数 移动距离, 整数型
    .参数 执行模式, 整数型, 可空, 可空。0=API方式，1=核心支持库方式。默认为0，用API方式。

    .如果真 (执行模式 ＝ 0)
        .如果 (SetFilePointer (文件号, 移动距离, 0, 0) ＝ -1)
            输出调试文本 (“设置文件指针失败-API：” ＋ 到文本 (移动距离))
            返回 (假)
        .否则
            返回 (真)
        .如果结束
        
    .如果真结束
    返回 (移动读写位置 (文件号, #文件首, 移动距离))

.子程序 文件_下载, , 公开, 用windows自带的下载方式来下载文件；
    .参数 网络文件地址, 文本型
    .局部变量 wszUrl, 字节集
    .局部变量 dwSize, 整数型

    wszUrl ＝ 编码_Ansi到Unicode (网络文件地址, )
    dwSize ＝ 文本_取长度W (wszUrl)
    .如果真 (dwSize ＞ 0)
        DoFileDownload (wszUrl)
    .如果真结束
    
    ' 当前的安全设置不允许从该位置下载文件--解决方法
    ' https://blog.csdn.net/XiaoXiao_RenHe/article/details/123086783
    
    ' 系统_写文本注册项W (#HKEY_CURRENT_USER, 编码_Ansi到Unicode (“Software\Microsoft\Windows\CurrentVersion\Internet Settings\ZoneMap\Domains\125.la”, ), #REG_DWORD, 编码_Ansi到Unicode (“https”, ), 到字节集 (2), 真)

.子程序 文件_下载1, 逻辑型, 公开, 支持HTTP,HTTPS协议.成功返回真,失败返回假.(Mr.Yang提供)
    .参数 下载地址, 文本型, , 需下载的URL地址.
    .参数 保存路径, 文本型, , 保存到本地的完整文件路径.
    .参数 任务类型, 整数型, 可空, 0=覆盖 1=改名 2=跳过.当文件覆盖失败时返回假.跳过时返回真.
    .局部变量 新地址, 文本型
    .局部变量 新路径, 文本型
    .局部变量 计次, 整数型
    .局部变量 aryHotFixID, 文本型, , "0"
    .局部变量 len, 整数型

    .如果真 (_WIN32_WINNT ＜ #_WIN32_WINNT_WIN7 且 IsDebuggerPresent ())
        len ＝ 系统_遍历修复补丁ID (aryHotFixID, “KB2813430”)
        .如果真 (len ＝ 0)
            输出调试文本 (“缺少修复补丁(KB2813430) 可能导致该功能无效”)
            输出调试文本 (“https://bbs.125.la/thread-14731053-1-1.html”)
        .如果真结束
        
    .如果真结束
    
    .如果 (寻找文本 (下载地址, “://”, , 假) ＝ -1) ' 缺少协yi
        新地址 ＝ “http://” ＋ 下载地址
    .否则
        新地址 ＝ 下载地址
    .如果结束
    .如果 (文件是否存在 (保存路径))
        .判断开始 (任务类型 ＝ 0) ' 覆盖
            .如果 (删除文件 (保存路径))
                新路径 ＝ 保存路径
            .否则
                返回 (假)
            .如果结束
            
        .判断 (任务类型 ＝ 1) ' 改名
            .计次循环首 (99, 计次)
                新路径 ＝ 保存路径
                新路径 ＝ 文本_删右边 (新路径, 取文本长度 (文件_取扩展名 (新路径))) ＋ “(” ＋ 到文本 (计次) ＋ “)” ＋ 文件_取扩展名 (新路径)
                .如果真 (文件是否存在 (新路径) ＝ 假)
                    跳出循环 ()
                .如果真结束
                
            .计次循环尾 ()
        .默认
            返回 (真) ' 跳过
        .判断结束
        
    .否则
        新路径 ＝ 保存路径
    .如果结束
    ' //
    DeleteUrlCacheEntry (新地址)
    返回 (URLDownloadToFileA (0, 新地址, 新路径, 0, 0) ＝ 0)

.子程序 文件_执行, 逻辑型, 公开, 执行文件夹或文件或命令(成功返回真,失败返回假)
    .参数 文件名, 文本型, , 欲操作(文件)或(文件夹的名称)或(网址)
    .参数 命令行, 文本型, 可空, 执行文件的命令行，没有则设为空
    .参数 窗口方式, 整数型, 可空, 0、普通激活方式；1、隐藏窗口；2、最小化窗口、3、最大化窗口

    返回 (文件_执行W (编码_Ansi到Unicode (文件名, ), 编码_Ansi到Unicode (命令行, ), 窗口方式))

.子程序 文件_执行W, 逻辑型, 公开, 执行文件夹或文件或命令
    .参数 文件名, 字节集, , 欲操作(文件)或(文件夹的名称)或(网址)
    .参数 命令行, 字节集, 可空, 执行文件的命令行，没有则设为空
    .参数 窗口方式, 整数型, 可空, 0、普通激活方式；1、隐藏窗口；2、最小化窗口、3、最大化窗口
    .局部变量 nShowCmd, 整数型

    .如果 (窗口方式 ＜ 0 或 窗口方式 ＞ 3)
        nShowCmd ＝ #SW_SHOWNORMAL
    .否则
        nShowCmd ＝ 多项选择 (窗口方式 ＋ 1, #SW_SHOWNORMAL, #SW_HIDE, #SW_SHOWMINNOACTIVE, #SW_SHOWMAXIMIZED)
    .如果结束
    返回 (ShellExecuteW (#NULL, 编码_Ansi到Unicode (“Open”, ), 文件名, 命令行 ＋ { 0, 0 }, { 0, 0 }, nShowCmd) ≠ #ERROR_FILE_NOT_FOUND)

.子程序 文件_定位, 逻辑型, 公开, 成功则打开文件所在目录并选中文件
    .参数 欲定位的文件, 文本型, , 需提供文件的绝对路径
    .参数 编辑模式, 逻辑型, 可空, 重命名模式

    返回 (文件_定位W (编码_Ansi到Unicode (欲定位的文件, ), 编辑模式))

.子程序 文件_定位W, 逻辑型, 公开, 成功则打开文件所在目录并选中文件
    .参数 欲定位的文件, 字节集, , 需提供文件的绝对路径
    .参数 编辑模式, 逻辑型, 可空, 重命名模式
    .局部变量 pidl, 整数型
    .局部变量 hr, 整数型

    .如果真 (PathFileExistsW (欲定位的文件) ＝ 假)
        返回 (假)
    .如果真结束
    pidl ＝ ILCreateFromPathW (欲定位的文件)
    .如果真 (pidl ＝ 0)
        返回 (假)
    .如果真结束
    CoInitialize (#NULL)
    hr ＝ SHOpenFolderAndSelectItems (pidl, 0, 0, 选择 (编辑模式, #OFASI_EDIT, 0))
    CoUninitialize ()
    ILFree (pidl)
    返回 (hr ＝ #S_OK)

.子程序 文件_定位多个, 逻辑型, 公开, 成功则打开文件或文件夹所在目录并选中
    .参数 所在文件夹, 文本型
    .参数 欲定位的文件或文件夹, 文本型, 数组, 需提供文件或文件夹的绝对路径
    .局部变量 len, 整数型
    .局部变量 arr, 字节集, , "0"
    .局部变量 i, 整数型

    len ＝ 取数组成员数 (欲定位的文件或文件夹)
    .计次循环首 (len, i)
        加入成员 (arr, 编码_Ansi到Unicode (欲定位的文件或文件夹 [i], ))
    .计次循环尾 ()
    返回 (文件_定位多个W (编码_Ansi到Unicode (所在文件夹, ), arr))

.子程序 文件_定位多个W, 逻辑型, 公开, 成功则打开文件或文件夹所在目录并选中
    .参数 所在文件夹, 字节集
    .参数 欲定位的文件或文件夹, 字节集, 数组, 需提供文件或文件夹的绝对路径
    .局部变量 pidl, 整数型
    .局部变量 cidl, 整数型
    .局部变量 tidl, 整数型
    .局部变量 apidl, 整数型, , "0"
    .局部变量 hr, 整数型
    .局部变量 i, 整数型

    .如果真 (PathIsDirectoryW (所在文件夹) ＝ 0)
        返回 (假)
    .如果真结束
    pidl ＝ ILCreateFromPathW (所在文件夹)
    .如果真 (pidl ＝ 0)
        返回 (假)
    .如果真结束
    cidl ＝ 取数组成员数 (欲定位的文件或文件夹)
    .计次循环首 (cidl, i)
        tidl ＝ ILCreateFromPathW (欲定位的文件或文件夹 [i])
        .如果真 (tidl ＝ 0)
            到循环尾 ()
        .如果真结束
        加入成员 (apidl, tidl)
    .计次循环尾 ()
    cidl ＝ 取数组成员数 (apidl)
    CoInitialize (#NULL)
    hr ＝ SHOpenFolderAndSelectItems (pidl, cidl, 取数据_通用型_数组 (apidl), 0)
    CoUninitialize ()
    .计次循环首 (cidl, i)
        ILFree (apidl [i])
    .计次循环尾 ()
    ILFree (pidl)
    返回 (hr ＝ #S_OK)

.子程序 文件_取尺寸, 文本型, 公开, 直接大于2G以上超大文件
    .参数 参_文件名, 文本型, , 文件的完整路径
    .参数 参_格式化, 逻辑型, 可空, 格式化以B、KB、GB返回
    .局部变量 m_hfile
    .局部变量 m_fileSize, 长整数型
    .局部变量 m_objsfo, 对象
    .局部变量 m_objFile, 对象
    .局部变量 m_return, 文本型
    .局部变量 m_sbuffer, 文本型

    m_hfile ＝ _lopen (参_文件名, 0)
    GetFileSizeEx (m_hfile, 取指针长整数_ (m_fileSize))
    _lclose (m_hfile)
    .如果真 (m_fileSize ＝ 0)
        CoInitialize (0)
        m_objsfo.创建 (“scripting.FileSystemObject”, )
        m_objFile ＝ m_objsfo.对象型方法 (“GetFile”, 参_文件名)
        m_fileSize ＝ m_objFile.读属性 (“Size”, ).取数值 ()
        m_objFile.清除 ()
        m_objFile.清除 ()
        CoUninitialize ()
    .如果真结束
    .如果真 (参_格式化)
        m_sbuffer ＝ 取空白文本 (20)
        StrFormatByteSize64A (m_fileSize, m_sbuffer, 20)
        .如果真 (m_sbuffer ＝ “0 字节”)
            m_sbuffer ＝ “0”
        .如果真结束
        .如果真 (寻找文本 (m_sbuffer, “字节”, , 假) ≠ 0)
            m_sbuffer ＝ 子文本替换 (m_sbuffer, “字节”, “B”, , , 真)
        .如果真结束
        m_return ＝ m_sbuffer
    .如果真结束
    返回 (选择 (参_格式化, m_return, 到文本 (m_fileSize)))

.子程序 文件_取实际大小, 长整数型, 公开, 获取一个文件在磁盘上实际占据的字节数，如文件右键属性中的大小，显示就是实际压缩过的尺寸
    .参数 文件路径, 文本型
    .局部变量 dwFileSizeLow, 整数型
    .局部变量 dwFileSizeHigh, 整数型
    .局部变量 FileSize, 长整数型

    ' https://bbs.125.la/thread-14484380-1-1.html
    dwFileSizeLow ＝ GetCompressedFileSize (文件路径, dwFileSizeHigh)
    .如果真 (dwFileSizeLow ＝ #INVALID_FILE_SIZE 且 dwFileSizeHigh ＝ 0)
        返回 (0)
    .如果真结束
    .如果 (dwFileSizeLow ＜ 0) ' 文件大小在2-4G之间时低位是负值
        dwFileSizeLow ＝ 位与 (dwFileSizeLow, 2147483647) ' 将低位和（01111111111111111111111111111111）位与，去掉负号
        FileSize ＝ dwFileSizeHigh × 4294967296 ＋ 2147483648 ＋ dwFileSizeLow ' 再加上2G和高位得到文件实际大小
    .否则
        FileSize ＝ dwFileSizeHigh × 4294967296 ＋ dwFileSizeLow
    .如果结束
    返回 (FileSize)

.子程序 文件_关联, , 公开, 关联指定后缀名到指定文件 (打开该后缀名文件,该后缀名文件路径将作为参数传递给指定文件)
    .参数 程序路径, 文本型, , 可空，关联到程序的路径，如果留空将取消关联。
    .参数 后缀, 文本型, , 欲关联的后缀名,多个后缀用|分开 (如: asp|htm|html)
    .参数 ICO图标路径, 文本型, 可空, 被关联文件的图标 可空为执行文件(程序)图标，也可以直接指向一个其它一个可执行的文件。
    .参数 文件类型, 文本型, 可空, 关联文件的说明 被关联文件属性中的文件类型
    .参数 关联名, 文本型, 可空, 可空为后缀
    .局部变量 所有后缀, 文本型, , "0"
    .局部变量 a, 整数型
    .局部变量 局_关联名, 文本型

    所有后缀 ＝ 分割文本 (后缀, “|”, )
    .如果 (删首尾空 (程序路径) ＝ “”) ' 取消关联
        .计次循环首 (取数组成员数 (所有后缀), a)
            局_关联名 ＝ 取文本注册项 (#根类, “.” ＋ 所有后缀 [a] ＋ “\”, )
            删除注册项 (#根类, “\” ＋ 局_关联名 ＋ “\DefaultIcon”)
            删除注册项 (#根类, “\” ＋ 局_关联名 ＋ “\Shell\Open\Command”)
            删除注册项 (#根类, “\” ＋ 局_关联名 ＋ “\Shell\Open”)
            删除注册项 (#根类, “\” ＋ 局_关联名 ＋ “\Shell”)
            删除注册项 (#根类, “\” ＋ 局_关联名 ＋ “”)
            写注册项 (1, “.” ＋ 所有后缀 [a] ＋ “\”, “”)
        .计次循环尾 ()
        
    .否则
        .如果真 (ICO图标路径 ＝ “”)
            ICO图标路径 ＝ 程序路径
        .如果真结束
        .如果真 (关联名 ＝ “”)
            关联名 ＝ 后缀
        .如果真结束
        写注册项 (1, 关联名 ＋ “\”, 文件类型) ' 关联文件说明
        写注册项 (1, 关联名 ＋ “\EditFlags”, 2) ' 别的关联文件也有,估计不能少.
        写注册项 (1, 关联名 ＋ “\Shell\Open\Command\”, #引号 ＋ 程序路径 ＋ #引号 ＋ “ ” ＋ #引号 ＋ “%1” ＋ #引号) ' 以关联后缀文件的路径作为执行文件(程序)的命令行
        写注册项 (1, 关联名 ＋ “\DefaultIcon\”, ICO图标路径 ＋ “,0”)
        .计次循环首 (取数组成员数 (所有后缀), a)
            写注册项 (1, “.” ＋ 所有后缀 [a] ＋ “\”, 关联名) ' 关联后缀到htxt中
        .计次循环尾 ()
    .如果结束
    系统_刷新 ()

.子程序 文件_取关联, 文本型, 公开, 写入一个后缀，取得此后缀文档打开方式，失败则返回空文本
    .参数 后缀, 文本型, , 文件后缀，如"txt","*.txt",".txt"三者都可以
    .局部变量 程序名, 文本型
    .局部变量 打开方式, 文本型

    后缀 ＝ 子文本替换 (后缀, “*”, , , , 真)
    后缀 ＝ 子文本替换 (后缀, “.”, , , , 真)
    程序名 ＝ 取文本注册项 (#根类, “.” ＋ 后缀 ＋ “\”, )
    .如果真 (取文本长度 (程序名) ＝ 0)
        返回 (“”)
    .如果真结束
    打开方式 ＝ 取文本注册项 (#根类, 程序名 ＋ “\shell\”, “open”)
    程序名 ＝ 取文本注册项 (#根类, 程序名 ＋ “\shell\” ＋ 打开方式 ＋ “\command\”, )
    返回 (程序名)

.子程序 文件_取关联W, 字节集, 公开, 获取文件关联
    .参数 文件扩展名, 字节集, , .txt
    .参数 hKey, 整数型, 参考 可空, RegCloseKey (hKey)
    .局部变量 hr, 整数型
    .局部变量 iQueryAssoc, 整数型
    .局部变量 dwBufLen, 整数型
    .局部变量 pwzBuf, 整数型
    .局部变量 wzBuf, 字节集

    CoInitialize (#NULL)
    hr ＝ CoCreateInstance1 (取指针_字节集型 (#CLSID_QueryAssociations), #NULL, #CLSCTX_INPROC_SERVER, 取指针_字节集型 (#IID_IQueryAssociations), iQueryAssoc)
    .如果真 (hr ＝ #S_OK 且 iQueryAssoc ≠ #NULL)
        hr ＝ CallObject (iQueryAssoc, #IQueryAssociations_Init, #NULL, 取指针_字节集型 (文件扩展名), #NULL, #NULL, , , , , )
        .如果真 (hr ＝ #S_OK)
            hr ＝ CallObject (iQueryAssoc, #IQueryAssociations_GetString, 位或 (#ASSOCF_NOFIXUPS, #ASSOCF_VERIFY), #ASSOCSTR_EXECUTABLE, #NULL, #NULL, 取指针整数_ (dwBufLen), , , , )
            .如果真 (hr ＝ #S_FALSE 且 dwBufLen ＞ 0)
                pwzBuf ＝ LocalAlloc (#LMEM_ZEROINIT, dwBufLen × 2)
                hr ＝ CallObject (iQueryAssoc, #IQueryAssociations_GetString, 位或 (#ASSOCF_NOFIXUPS, #ASSOCF_VERIFY), #ASSOCSTR_EXECUTABLE, #NULL, pwzBuf, 取指针整数_ (dwBufLen), , , , )
                .如果真 (hr ＝ #S_OK 且 指针_到字节集W (PathFindFileNameW (pwzBuf)) ≠ 编码_Ansi到Unicode (“OpenWith.exe”, ))
                    wzBuf ＝ 指针_到字节集W (pwzBuf)
                .如果真结束
                LocalFree (pwzBuf)
            .如果真结束
            .如果真 (是否为空 (hKey) ＝ 假)
                hr ＝ CallObject (iQueryAssoc, #IQueryAssociations_GetKey, #ASSOCF_NOFIXUPS, #ASSOCKEY_CLASS, #NULL, 取指针整数_ (hKey), , , , , )
                ' RegCloseKey (hKey)
            .如果真结束
            
        .如果真结束
        SafeRelease (iQueryAssoc)
    .如果真结束
    CoUninitialize ()
    返回 (wzBuf)

.子程序 文件_取目录, 文本型, 公开, 取得文件所在目录的路径,如：局_项数组:\012\3600.exe 成功将返回 局_项数组:\012\
    .参数 路径文件名, 文本型, , 文件的完整地址

    .如果真 (文件_是否为目录 (路径文件名))
        返回 (路径文件名)
    .如果真结束
    返回 (取文本左边 (路径文件名, 倒找文本 (路径文件名, “\”, , 假)))

.子程序 文件_取目录W, 字节集, 公开, 取得文件所在目录的路径
    .参数 文件的绝对路径, 字节集
    .局部变量 rfind, 整数型

    .如果真 (文件_是否为目录W (文件的绝对路径))
        返回 (文件的绝对路径)
    .如果真结束
    rfind ＝ 倒找字节集 (文件的绝对路径, { 92, 0 }, )
    .如果真 (rfind ＝ -1)
        返回 ({ })
    .如果真结束
    返回 (取字节集左边 (文件的绝对路径, rfind ＋ 1) ＋ { 0, 0 })

.子程序 文件_取大小, 长整数型, 公开, 返回一个文件的长度，单位是字节
    .参数 文件的绝对路径, 文本型

    返回 (文件_取大小W (编码_Ansi到Unicode (文件的绝对路径, )))

.子程序 文件_取大小W, 长整数型, 公开, 返回一个文件的长度，单位是字节
    .参数 文件的绝对路径, 字节集
    .局部变量 FindData, WIN32_FIND_DATAW
    .局部变量 hFind, 整数型

    hFind ＝ FindFirstFileW (文件的绝对路径, FindData)
    .判断开始 (hFind ≠ #INVALID_HANDLE_VALUE)
        FindClose (hFind)
        返回 (合并长整数 (FindData.nFileSizeLow, FindData.nFileSizeHigh))
    .判断 (hFind ＝ #INVALID_HANDLE_VALUE)
        输出调试文本 (“错误：找不到文件”)
    .默认
        输出调试文本 (取错误信息文本_API (hFind))
    .判断结束
    返回 (0)

.子程序 文件_相差数, 整数型, , 返回两个目录中相差的文件数
    .参数 服务器目录, 文本型, , 目录不以\结尾会自动添加
    .参数 本地目录, 文本型, , 目录不以\结尾会自动添加
    .局部变量 文件名, 文本型
    .局部变量 子目录, 文本型
    .局部变量 返回数, 整数型

    服务器目录 ＝ 服务器目录 ＋ “\”
    本地目录 ＝ 本地目录 ＋ “\”
    创建目录 (本地目录)
    处理事件 ()
    文件名 ＝ 寻找文件 (服务器目录 ＋ “*.*”, 39)
    .判断循环首 (文件名 ≠ “”)
        .如果真 (文件是否存在 (本地目录 ＋ 文件名) ＝ 假)
            返回数 ＝ 返回数 ＋ 1
        .如果真结束
        文件名 ＝ 寻找文件 (, )
    .判断循环尾 ()
    子目录 ＝ 寻找文件 (服务器目录 ＋ “*.*”, 16)
    .判断循环首 (子目录 ≠ “”)
        .如果真 (子目录 ≠ “.” 且 子目录 ≠ “..”)
            返回数 ＝ 返回数 ＋ 文件_相差数 (服务器目录 ＋ 子目录, 本地目录 ＋ 子目录)
        .如果真结束
        子目录 ＝ 寻找文件 (, #子目录)
    .判断循环尾 ()
    返回 (返回数)
    

.子程序 文件_循环删除, , 公开, 删除指定的文件
    .参数 文件名, 文本型
    .参数 超时, 整数型, 可空, 毫秒，默认3秒
    .局部变量 用时, 整数型

    .如果真 (超时 ＝ 0)
        超时 ＝ 3000
    .如果真结束
    用时 ＝ 取启动时间 ()
    .判断循环首 (文件是否存在 (文件名))
        置文件属性 (文件名, 0)
        删除文件 (文件名)
        .如果真 (取启动时间 () － 用时 ≥ 超时)
            跳出循环 ()
        .如果真结束
        
    .判断循环尾 ()

.子程序 文件_创建, 整数型, 公开, 瞬间创建一个指定大小的文件，最大能创建 2,147,483,647 字节大小的文件。成功返回1，失败返回错误代码;
    .参数 文件路径, 文本型
    .参数 要创建的大小, 整数型, , 单位为字节,最大能创建 2,147,483,647 字节大小的文件
    .局部变量 hFile, 整数型
    .局部变量 iRet, 整数型

    目录_创建 (文件_取目录 (文件路径))
    hFile ＝ CreateFileA (文件路径, #GENERIC_WRITE, 0, 0, #OPEN_ALWAYS, #FILE_ATTRIBUTE_ARCHIVE, 0)
    .如果真 (hFile ＝ #INVALID_HANDLE_VALUE) ' 创建文件失败返回值是-1
        返回 (_GetLastError ()) ' 失败返回错误代码
    .如果真结束
    
    要创建的大小 ＝ SetFilePointer (hFile, 要创建的大小, 0, 0)
    .如果 (要创建的大小 ＞ -1) ' 表示创建成功
        .判断开始 (SetEndOfFile (hFile) ＝ 0) ' 设置文件结尾失败;
            iRet ＝ _GetLastError ()
        .默认
            iRet ＝ 1
        .判断结束
        
    .否则
        iRet ＝ _GetLastError ()
    .如果结束
    
    CloseHandle (hFile)
    ' 最后无论如何要关闭文件;
    .如果真 (iRet ≠ 1) ' 如果不等于1,证明步骤失败;要删除对应的文件.不然会剩下一个空文件;
        删除文件 (文件路径)
    .如果真结束
    返回 (iRet)

.子程序 文件_取格式, 整数型, 公开, 0=exe/dll；1=e/ec；3=rar；4=zip；5=7z；6=jpg；7=gif；8=swf；失败返回-1
    .参数 文件字节集, 字节集, , 可以用读入文件获取文件字节集
    .参数 返回文本格式, 文本型, 参考 可空, 可留空；装载文本格式的变量；如是exe格式的直接返回exe,失败返回空文本
    .局部变量 局_文件字节集, 字节集

    局_文件字节集 ＝ 取字节集左边 (文件字节集, 30)
    .判断开始 (取字节集左边 (局_文件字节集, 2) ＝ 到字节集 (“MZ”))
        返回文本格式 ＝ “exe/dll”
        返回 (0)
    .判断 (取字节集左边 (局_文件字节集, 8) ＝ 到字节集 (“CNWTEPRG”))
        返回文本格式 ＝ “e/ec”
        返回 (1)
    .判断 (取字节集左边 (局_文件字节集, 3) ＝ 到字节集 (“Rar”))
        返回文本格式 ＝ “rar”
        返回 (3)
    .判断 (取字节集左边 (局_文件字节集, 2) ＝ 到字节集 (“PK”))
        返回文本格式 ＝ “zip”
        返回 (4)
    .判断 (取字节集左边 (局_文件字节集, 2) ＝ 到字节集 (“7z”))
        返回文本格式 ＝ “7z”
        返回 (5)
    .判断 (取字节集左边 (局_文件字节集, 24) ＝ 到字节集 (“Content-Type: image/jpeg”) 或 取字节集左边 (局_文件字节集, 3) ＝ { 255, 216, 255 })
        返回文本格式 ＝ “jpg”
        返回 (6)
    .判断 (取字节集左边 (局_文件字节集, 6) ＝ 到字节集 (“GIF89a”))
        返回文本格式 ＝ “gif”
        返回 (7)
    .判断 (取字节集左边 (局_文件字节集, 3) ＝ 到字节集 (“FWS”))
        返回文本格式 ＝ “swf”
        返回 (8)
    .默认
        
    .判断结束
    返回 (-1)

.子程序 文件_复制, 逻辑型, 公开, 成功返回真，失败返回假。本命令为初级命令
    .参数 被复制文件名, 文本型, , 被复制文件名
    .参数 复制到文件名, 文本型, , 复制到文件名
    .参数 是否覆盖, 整数型, 可空, 可空。默认为直接覆盖。0=覆盖，非0不覆盖

    返回 (CopyFileA (被复制文件名, 复制到文件名, 是否覆盖))

.子程序 文件_复制W, 逻辑型, 公开, 成功返回真
    .参数 被复制的文件名, 字节集
    .参数 复制到的文件名, 字节集
    .参数 是否覆盖, 逻辑型

    返回 (CopyFileW (被复制的文件名, 复制到的文件名, 取反 (是否覆盖)))

.子程序 文件_取时间, 逻辑型, 公开, 返回文件的创建时间、修改时间、访问时间
    .参数 文件名, 文本型
    .参数 创建时间, 文本型, 参考 可空, 存放创建时间的变量
    .参数 最后修改时间, 文本型, 参考 可空, 存放修改时间的变量
    .参数 最后访问时间, 文本型, 参考 可空, 存放访问时间的变量

    返回 (文件_取时间W (编码_Ansi到Unicode (文件名, ), 创建时间, 最后修改时间, 最后访问时间))

.子程序 文件_取时间W, 逻辑型, 公开, 返回文件的创建时间、修改时间、访问时间
    .参数 文件名, 字节集
    .参数 创建时间, 文本型, 参考 可空, 存放创建时间的变量
    .参数 最后修改时间, 文本型, 参考 可空, 存放修改时间的变量
    .参数 最后访问时间, 文本型, 参考 可空, 存放访问时间的变量
    .局部变量 dwFlags, 整数型
    .局部变量 hFile, 整数型
    .局部变量 CreateTime, FILETIME
    .局部变量 AccessTime, FILETIME
    .局部变量 WriteTime, FILETIME
    .局部变量 vTime, 日期时间型
    .局部变量 lRes, 逻辑型

    .如果真 (文件_是否为目录W (文件名))
        dwFlags ＝ #FILE_FLAG_BACKUP_SEMANTICS
    .如果真结束
    hFile ＝ CreateFileW (文件名, 位或 (#GENERIC_READ, #GENERIC_WRITE), 位或 (#FILE_SHARE_READ, #FILE_SHARE_WRITE), 0, #OPEN_EXISTING, dwFlags, 0)
    .如果真 (hFile ＝ #INVALID_HANDLE_VALUE)
        返回 (假)
    .如果真结束
    lRes ＝ GetFileTime (hFile, CreateTime, AccessTime, WriteTime)
    CloseHandle (hFile)
    .如果真 (lRes)
        vTime ＝ FileTimeToVariantTime (CreateTime)
        创建时间 ＝ 时间_到文本 (vTime, 1, , )
        vTime ＝ FileTimeToVariantTime (AccessTime)
        最后访问时间 ＝ 时间_到文本 (vTime, 1, , )
        vTime ＝ FileTimeToVariantTime (WriteTime)
        最后修改时间 ＝ 时间_到文本 (vTime, 1, , )
    .如果真结束
    返回 (lRes)

.子程序 文件_置时间, 逻辑型, 公开, 修改文件的创建时间、修改时间、访问时间
    .参数 文件名, 文本型
    .参数 创建时间, 文本型, 可空, 时间格式为：2009-11-15 15:15:15
    .参数 最后修改时间, 文本型, 可空, 时间格式为：2009-11-15 15:15:15
    .参数 最后访问时间, 文本型, 可空, 时间格式为：2009-11-15 15:15:15

    返回 (文件_置时间W (编码_Ansi到Unicode (文件名, ), 创建时间, 最后修改时间, 最后访问时间))

.子程序 文件_置时间W, 逻辑型, 公开, 修改文件的创建时间、修改时间、访问时间
    .参数 文件名, 字节集
    .参数 创建时间, 文本型, 可空, 时间格式为：2009-11-15 15:15:15
    .参数 最后修改时间, 文本型, 可空, 时间格式为：2009-11-15 15:15:15
    .参数 最后访问时间, 文本型, 可空, 时间格式为：2009-11-15 15:15:15
    .局部变量 CreateTime, FILETIME
    .局部变量 AccessTime, FILETIME
    .局部变量 WriteTime, FILETIME
    .局部变量 vTime, 日期时间型
    .局部变量 dwFlags, 整数型
    .局部变量 hFile, 整数型
    .局部变量 isRes, 逻辑型

    vTime ＝ 到时间 (创建时间)
    .如果真 (vTime ≠ [1899年12月30日])
        CreateTime ＝ VariantTimeToFileTime (vTime)
    .如果真结束
    vTime ＝ 到时间 (最后访问时间)
    .如果真 (vTime ≠ [1899年12月30日])
        AccessTime ＝ VariantTimeToFileTime (vTime)
    .如果真结束
    vTime ＝ 到时间 (最后修改时间)
    .如果真 (vTime ≠ [1899年12月30日])
        WriteTime ＝ VariantTimeToFileTime (vTime)
    .如果真结束
    .如果真 (文件_是否为目录W (文件名))
        dwFlags ＝ #FILE_FLAG_BACKUP_SEMANTICS
    .如果真结束
    hFile ＝ CreateFileW (文件名, #GENERIC_WRITE, #FILE_SHARE_WRITE, 0, #OPEN_EXISTING, dwFlags, 0)
    .如果真 (hFile ＝ #INVALID_HANDLE_VALUE)
        返回 (假)
    .如果真结束
    isRes ＝ SetFileTime (hFile, CreateTime, AccessTime, WriteTime)
    CloseHandle (hFile)
    返回 (isRes)

.子程序 文件_取扩展名, 文本型, 公开, 返回一个文件的后缀名,如：.jpg  如果没有后缀,返回空
    .参数 文件名, 文本型, , 需要处理的原始文件名

    返回 (PathFindExtensionA (文件名))

.子程序 文件_去扩展名, 逻辑型, 公开, 去掉指定文件路径的后缀
    .参数 原始文件名, 文本型, , 需要处理的原始文件名
    .局部变量 局_后缀, 文本型
    .局部变量 是否成功, 逻辑型

    局_后缀 ＝ 文件_取扩展名 (原始文件名)
    .如果真 (局_后缀 ＝ “”)
        返回 (假)
    .如果真结束
    返回 (文件更名 (原始文件名, 取文本左边 (原始文件名, 取文本长度 (原始文件名) － 取文本长度 (局_后缀))))

.子程序 文件_改扩展名, 逻辑型, 公开, 改变一个文件的后缀名,成功返回真，失败返回假。
    .参数 原始文件名, 文本型, , 需要处理的原始文件名
    .参数 新扩展名, 文本型, , 后缀必须包含"."，如“.rar”,否则失败。
    .局部变量 NewPath, 文本型
    .局部变量 suffix, 文本型

    NewPath ＝ 原始文件名
    suffix ＝ PathFindExtensionA (新扩展名)
    .如果真 (取文本长度 (suffix) ＞ 1)
        PathRenameExtensionA (NewPath, suffix)
        返回 (文件_改名 (原始文件名, NewPath))
    .如果真结束
    返回 (假)

.子程序 文件_合并文件, 逻辑型, 公开, 将两个文件进行合并,生成一个新的文件
    .参数 合并文件名, 文本型, , 前一个文件名,最后生成的文件名也是它.
    .参数 被合并文件名, 文本型, , 要追加的文件名.
    .参数 生成文件名, 文本型, 可空, 如果空,以第一个文件名为准
    .局部变量 局_文件句柄, 整数型
    .局部变量 局_标志, 逻辑型

    ' http://bbs.125.la/forum.php?mod=redirect&goto=findpost&ptid=14647170&pid=20040177
    .如果 (是否为空 (生成文件名))
        局_文件句柄 ＝ 打开文件 (合并文件名, #读写, )
        .如果真 (局_文件句柄 ＝ 0)
            返回 (假)
        .如果真结束
        移到文件尾 (局_文件句柄)
        写出字节集 (局_文件句柄, 读入文件 (被合并文件名))
    .否则
        局_文件句柄 ＝ 打开文件 (生成文件名, #改写, )
        .如果真 (局_文件句柄 ＝ 0)
            返回 (假)
        .如果真结束
        移到文件尾 (局_文件句柄)
        写出字节集 (局_文件句柄, 读入文件 (合并文件名))
        写出字节集 (局_文件句柄, 读入文件 (被合并文件名))
    .如果结束
    关闭文件 (局_文件句柄)
    返回 (真)

.子程序 文件_是否存在, 逻辑型, 公开, 判断指定的文件是否存在
    .参数 文件名, 文本型, , 文件全路径

    返回 (文件_是否存在W (编码_Ansi到Unicode (文件名)))

.子程序 文件_是否存在W, 逻辑型, 公开, 判断指定的文件是否存在
    .参数 文件的绝对路径, 字节集
    .局部变量 hFind, 整数型
    .局部变量 FindData, WIN32_FIND_DATAW

    .如果真 (文件的绝对路径 ＝ { } 或 文件的绝对路径 ＝ { 0, 0 })
        返回 (假)
    .如果真结束
    hFind ＝ FindFirstFileW (文件的绝对路径, FindData)
    .如果真 (hFind ＝ #INVALID_HANDLE_VALUE)
        返回 (假)
    .如果真结束
    FindClose (hFind)
    返回 (位与 (FindData.dwFileAttributes, #FILE_ATTRIBUTE_DIRECTORY) ＝ 0)

.子程序 文件_取文件名, 文本型, 公开, 如：局_项数组:\123.exe 成功返回123
    .参数 路径文件名, 文本型, , 文件完整地址
    .参数 是否带后缀, 逻辑型, 可空, 默认为假，不带后缀；真为带后缀
    .局部变量 局_文件名, 文本型

    局_文件名 ＝ PathFindFileName (路径文件名)
    .如果真 (取文本右边 (局_文件名, 1) ＝ “\”)
        ' 取出来了一个\,这表示不正确，返回空
        返回 (“”)
    .如果真结束
    
    返回 (选择 (是否带后缀, 局_文件名, 取文本左边 (局_文件名, 取文本长度 (局_文件名) － 取文本长度 (文件_取扩展名 (局_文件名)))))

.子程序 文件_移动, 逻辑型, 公开, 移动指定文件到指定的文件位置
    .参数 欲移动的文件名, 文本型, , 欲移动的文件名
    .参数 移动到的文件名, 文本型, , 移动到的文件名

    返回 (MoveFileA (欲移动的文件名, 移动到的文件名))

.子程序 文件_移动W, 逻辑型, 公开, 将文件从一个位置移动到另外一个位置
    .参数 被移动的文件, 字节集
    .参数 移动到的位置, 字节集

    返回 (MoveFileW (被移动的文件, 移动到的位置))

.子程序 文件_搜索, , 公开, 可以设置显示标签和自动加入到列表框,可以当成枚举文件命令
    .参数 欲寻找的目录, 文本型, , 如：C:,表示C盘,记得C字后面两点一定要写，目录不以\结尾会自动添加
    .参数 加入的列表框, 列表框
    .参数 文件类型, 文本型, 可空, 可空：默认为*.*,也就是全部类型。 如填 *.txt只找txt类型的文件
    .参数 文件名包含的关键字, 文本型, 可空, 搜索文件名中 包含的关键字。如： 精易论坛.exe 只需要 精易就可以了
    .参数 显示标签, 标签, 可空, 用来显示搜索路径的标签
    .参数 是否带路径, 逻辑型, 可空, 默认为假； 真=带目录路径，如C:\012.txt； 假=不带，如 012.txt；
    .局部变量 局_子目录, 文本型
    .局部变量 局_文件名, 文本型
    .局部变量 LabelDisplay, 逻辑型, , ,  
    .局部变量 Keyword, 逻辑型
    .局部变量 ListBoxDisplay, 逻辑型

    欲寻找的目录 ＝ 选择 (取文本右边 (欲寻找的目录, 1) ≠ “\”, 欲寻找的目录 ＋ “\”, 欲寻找的目录)
    文件类型 ＝ 选择 (是否为空 (文件类型), “*.*”, 文件类型)
    Keyword ＝ 选择 (是否为空 (文件名包含的关键字), 假, 真)
    LabelDisplay ＝ 选择 (是否为空 (显示标签), 假, 真)
    
    局_文件名 ＝ 寻找文件 (欲寻找的目录 ＋ 文件类型, )
    
    .判断循环首 (局_文件名 ≠ “”)
        .如果真 (LabelDisplay)
            显示标签.标题 ＝ 欲寻找的目录 ＋ 局_文件名
            显示标签.刷新显示 ()
        .如果真结束
        .判断开始 (Keyword ＝ 假)
            .判断开始 (是否带路径)
                加入的列表框.加入项目 (欲寻找的目录 ＋ 局_文件名, )
            .默认
                加入的列表框.加入项目 (局_文件名, )
            .判断结束
            
        .判断 (寻找文本 (到小写 (局_文件名), 到小写 (文件名包含的关键字), , 假) ≠ -1)
            .判断开始 (是否带路径)
                加入的列表框.加入项目 (欲寻找的目录 ＋ 局_文件名, )
            .默认
                加入的列表框.加入项目 (局_文件名, )
            .判断结束
            
        .默认
            
        .判断结束
        
        处理事件 ()
        局_文件名 ＝ 寻找文件 (, )
    .判断循环尾 ()
    
    局_子目录 ＝ 寻找文件 (欲寻找的目录 ＋ “*.*”, #子目录)
    .判断循环首 (局_子目录 ≠ “”)
        .如果真 (取文本左边 (局_子目录, 1) ≠ “.”)
            .判断开始 (LabelDisplay)
                文件_搜索 (欲寻找的目录 ＋ 局_子目录 ＋ “\”, 加入的列表框, 文件类型, 文件名包含的关键字, 显示标签, 是否带路径)
            .默认
                文件_搜索 (欲寻找的目录 ＋ 局_子目录 ＋ “\”, 加入的列表框, 文件类型, 文件名包含的关键字, , 是否带路径)
            .判断结束
            处理事件 ()
        .如果真结束
        局_子目录 ＝ 寻找文件 (, #子目录)
        处理事件 ()
    .判断循环尾 ()

.子程序 文件_搜索1, , 公开, 搜索指定的文件路径中的指定后缀的文件并加入到列表框中  在一个子程序中多次调用此命令需清除文件数组后再调用
    .参数 欲寻找的目录, 文本型, , 如：C:,表示C盘,记得C字后面两点一定要写
    .参数 欲寻找的文件名, 文本型, , 如果寻找全部文件可以填入*.*或*.txt只找txt文件
    .参数 加入的列表框, 列表框, 可空, 把搜到的加到列表框中
    .参数 是否带路径, 逻辑型, 可空, 默认为假； 真=带目录路径，如C:\012.txt； 假=不带，如 012.txt；
    .参数 文件数组, 文本型, 可空 数组
    .局部变量 局_子目录, 文本型
    .局部变量 局_文件名, 文本型

    .如果真 (取文本右边 (欲寻找的目录, 1) ≠ “\”)
        欲寻找的目录 ＝ 欲寻找的目录 ＋ “\”
    .如果真结束
    局_文件名 ＝ 寻找文件 (欲寻找的目录 ＋ 欲寻找的文件名, )
    .判断循环首 (局_文件名 ≠ “”)
        .如果 (是否为空 (加入的列表框) ＝ 假)
            .判断开始 (是否带路径 ＝ 真)
                加入的列表框.加入项目 (欲寻找的目录 ＋ 局_文件名, )
                加入成员 (文件数组, 欲寻找的目录 ＋ 局_文件名)
            .默认
                加入的列表框.加入项目 (局_文件名, )
                加入成员 (文件数组, 局_文件名)
            .判断结束
            
        .否则
            .判断开始 (是否带路径 ＝ 真)
                加入成员 (文件数组, 欲寻找的目录 ＋ 局_文件名)
            .默认
                加入成员 (文件数组, 局_文件名)
            .判断结束
            
        .如果结束
        处理事件 ()
        局_文件名 ＝ 寻找文件 (, )
    .判断循环尾 ()
    局_子目录 ＝ 寻找文件 (欲寻找的目录 ＋ “*.*”, #子目录)
    .判断循环首 (局_子目录 ≠ “”)
        .如果真 (取文本左边 (局_子目录, 1) ≠ “.”)
            处理事件 ()
            .如果 (是否为空 (加入的列表框) ＝ 假)
                文件_搜索1 (欲寻找的目录 ＋ 局_子目录 ＋ “\”, 欲寻找的文件名, 加入的列表框, 是否带路径, 文件数组)
            .否则
                文件_搜索1 (欲寻找的目录 ＋ 局_子目录 ＋ “\”, 欲寻找的文件名, , 是否带路径, 文件数组)
            .如果结束
            
        .如果真结束
        局_子目录 ＝ 寻找文件 (, #子目录)
    .判断循环尾 ()
    

.子程序 文件_搜索_深度, , 公开, 无返回值，可以根据目录深度进行回调搜索，从而提高运行效率。
    .参数 欲寻找的目录, 文本型, , 如：C:,表示C盘,记得C字后面两点一定要写，目录不以\结尾会自动添加
    .参数 装载函数, 子程序指针, , 需要一个参数接收回调，名称为;文件路径[文本型].
    .参数 文件类型, 文本型, 可空, 可空：默认为*.*,也就是全部类型。 如填 *.txt只找txt类型的文件
    .参数 目录深度, , 可空, 可空：默认为-1，即不限制目录深度。
    .局部变量 局_文件, 文本型
    .局部变量 局_数组, 文本型, , "0"
    .局部变量 局_路径, 文本型

    处理事件 ()
    欲寻找的目录 ＝ 选择 (取文本右边 (欲寻找的目录, 1) ≠ “\”, 欲寻找的目录 ＋ “\”, 欲寻找的目录)
    .如果真 (是否为空 (文件类型))
        文件类型 ＝ “*.*”
    .如果真结束
    .如果真 (是否为空 (目录深度))
        目录深度 ＝ -1
    .如果真结束
    局_文件 ＝ 寻找文件 (欲寻找的目录 ＋ 文件类型, )
    .判断循环首 (局_文件 ≠ “”)
        局_路径 ＝ 欲寻找的目录 ＋ 局_文件
        程序_Call (到整数 (装载函数), lstrcpyn_文本型 (局_路径, 局_路径, 0))
        局_文件 ＝ 寻找文件 (, )
    .判断循环尾 ()
    局_文件 ＝ 寻找文件 (欲寻找的目录 ＋ “*.*”, 16) ' #子目录
    .判断循环首 (局_文件 ≠ “”)
        .如果真 (局_文件 ≠ “.” 且 局_文件 ≠ “..”)
            局_数组 ＝ 分割文本 (欲寻找的目录 ＋ 局_文件, “\”, )
            .如果 (目录深度 ＝ -1)
                文件_搜索_深度 (欲寻找的目录 ＋ 局_文件, 装载函数, 文件类型, 目录深度)
            .否则
                .如果真 (取数组成员数 (局_数组) ＜ 目录深度 ＋ 1)
                    文件_搜索_深度 (欲寻找的目录 ＋ 局_文件, 装载函数, 文件类型, 目录深度)
                .如果真结束
                
            .如果结束
            
        .如果真结束
        局_文件 ＝ 寻找文件 (, 16) ' #子目录
    .判断循环尾 ()

.子程序 文件_枚举, 整数型, 公开, 枚举某个目录下的指定类型文件；成功返回文件数量；
    .参数 欲寻找的目录, 文本型, , 文件目录
    .参数 欲寻找的文件名, 文本型, , 如果寻找全部文件可以填入*.*，或*.txt只找txt文件, 多个后缀中间用“|”隔开
    .参数 文件数组, 文本型, 参考 可空 数组, 用于装载文件数组的变量；把寻找到的文件都放在这个数组里，并返回；
    .参数 是否带路径, 逻辑型, 可空, 默认为假； 真=带目录路径，如C:\012.txt； 假=不带，如 012.txt；
    .参数 是否按字母排序, 逻辑型, 可空, 默认为假；真=按字母a-z排序  假=不排序
    .参数 是否遍历子目录, 逻辑型, 可空, 留空默认为假；为真时文件数组不主动清空
    .局部变量 局_文件名, 文本型
    .局部变量 局_目录, 文本型
    .局部变量 局_后缀数组, 文本型, , "0"
    .局部变量 局_后缀总数, 整数型
    .局部变量 局_计次, 整数型

    .如果真 (是否遍历子目录 ＝ 假)
        清除数组 (文件数组)
    .如果真结束
    局_目录 ＝ 欲寻找的目录
    .如果真 (取文本右边 (局_目录, 1) ≠ “\”)
        局_目录 ＝ 局_目录 ＋ “\”
    .如果真结束
    局_后缀数组 ＝ 分割文本 (欲寻找的文件名, “|”, )
    局_后缀总数 ＝ 取数组成员数 (局_后缀数组)
    .计次循环首 (局_后缀总数, 局_计次)
        局_文件名 ＝ 寻找文件 (局_目录 ＋ 局_后缀数组 [局_计次], )
        .判断循环首 (局_文件名 ≠ “”)
            .如果真 (是否带路径)
                局_文件名 ＝ 局_目录 ＋ 局_文件名
            .如果真结束
            加入成员 (文件数组, 局_文件名)
            系统_处理事件1 ()
            局_文件名 ＝ 寻找文件 (, )
        .判断循环尾 ()
    .计次循环尾 ()
    .如果真 (是否按字母排序)
        数组_排序 (文件数组, 0, )
    .如果真结束
    .如果真 (是否遍历子目录)
        局_文件名 ＝ 寻找文件 (局_目录 ＋ “*.*”, #子目录)
        .判断循环首 (局_文件名 ≠ “”)
            .如果真 (局_文件名 ≠ “.” 且 局_文件名 ≠ “..”)
                文件_枚举 (局_目录 ＋ 局_文件名, 欲寻找的文件名, 文件数组, 是否带路径, 是否按字母排序, 是否遍历子目录)
                系统_处理事件1 ()
            .如果真结束
            局_文件名 ＝ 寻找文件 (, #子目录)
        .判断循环尾 ()
    .如果真结束
    返回 (取数组成员数 (文件数组))

.子程序 文件_枚举1, , 公开, 如提供搜索目录路径，将会搜索此目录所有在内的文件。
    .参数 目录, 文本型, , 目录，如“D:\”盘，目录不以\结尾会自动添加
    .参数 拓展名, 文本型, , “*.exe”
    .参数 装载函数, 子程序指针, , 二个参数，1=目录【文本型】；2=文件名【文本型】
    .局部变量 文本, 文本型
    .局部变量 文件夹, 文本型
    .局部变量 局_目录, 文本型

    局_目录 ＝ 目录
    .如果真 (取文本右边 (目录, 1) ≠ “\”)
        局_目录 ＝ 目录 ＋ “\”
    .如果真结束
    文本 ＝ 寻找文件 (局_目录 ＋ 拓展名, )
    .判断循环首 (文本 ≠ “”)
        程序_Call (到整数 (装载函数), lstrcpyn_文本型 (局_目录, 局_目录, 0), lstrcpyn_文本型 (文本, 文本, 0))
        文本 ＝ 寻找文件 (, )
    .判断循环尾 ()
    文本 ＝ 寻找文件 (局_目录 ＋ “*.*”, #子目录)
    .判断循环首 (文本 ≠ “”)
        .如果真 (取文本左边 (文本, 1) ≠ “.”)
            文本 ＝ 局_目录 ＋ 文本
            文件_枚举1 (文本, 拓展名, 装载函数)
        .如果真结束
        文本 ＝ 寻找文件 (, #子目录)
        系统_处理事件1 ()
    .判断循环尾 ()

.子程序 文件_枚举W, 整数型, 公开, 枚举某个目录下的指定类型文件，成功返回文件数组。
    .参数 欲寻找的目录, 字节集
    .参数 欲寻找的文件名, 字节集, 可空, *为寻找全部文件
    .参数 文件数组, 字节集, 参考 可空 数组
    .参数 是否带路径, 逻辑型, 可空, 为真时返回文件为绝对路径
    .参数 是否遍历子目录, 逻辑型, 可空, 为真时文件数组不主动清空
    .参数 是否枚举文件夹, 逻辑型, 可空, 为真时只枚举文件夹
    .局部变量 FileDir, 字节集
    .局部变量 FindData, WIN32_FIND_DATAW
    .局部变量 hFind, 整数型
    .局部变量 pFile, 整数型
    .局部变量 dwSize, 整数型
    .局部变量 FileName, 字节集
    .局部变量 dwLen, 整数型

    FileDir ＝ 删除Unicode结尾空白字节 (欲寻找的目录, )
    .如果真 (取字节集右边 (FileDir, 2) ≠ { 92, 0 })
        FileDir ＝ FileDir ＋ { 92, 0 }
    .如果真结束
    .如果真 (是否遍历子目录 ＝ 假)
        清除数组 (文件数组)
    .如果真结束
    .如果 (欲寻找的文件名 ＝ { } 或 欲寻找的文件名 ＝ { 0, 0 })
        hFind ＝ FindFirstFileW (FileDir ＋ { 42, 0, 0, 0 }, FindData) ' *
    .否则
        hFind ＝ FindFirstFileW (FileDir ＋ 欲寻找的文件名, FindData)
    .如果结束
    .如果真 (hFind ≠ #INVALID_HANDLE_VALUE)
        .循环判断首 ()
            .如果真 (是否枚举文件夹 ＝ 假 且 位与 (FindData.dwFileAttributes, #FILE_ATTRIBUTE_DIRECTORY) ≠ 0 或 (是否枚举文件夹 且 位与 (FindData.dwFileAttributes, #FILE_ATTRIBUTE_DIRECTORY) ＝ 0))
                到循环尾 ()
            .如果真结束
            pFile ＝ 取数据_通用型_数组 (FindData.cFileName)
            .如果真 (pFile ＝ 0)
                到循环尾 ()
            .如果真结束
            dwSize ＝ lstrlenW (pFile)
            .如果真 (dwSize ＝ 0)
                到循环尾 ()
            .如果真结束
            FileName ＝ 指针到字节集 (pFile, dwSize × 2 ＋ 2)
            .如果真 (FileName ＝ { 46, 0, 0, 0 } 或 FileName ＝ { 46, 0, 46, 0, 0, 0 })
                到循环尾 ()
            .如果真结束
            .如果 (是否带路径)
                加入成员 (文件数组, FileDir ＋ FileName)
            .否则
                加入成员 (文件数组, FileName)
            .如果结束
            
        .循环判断尾 (FindNextFileW (hFind, FindData))
        FindClose (hFind)
    .如果真结束
    .如果真 (是否遍历子目录)
        hFind ＝ FindFirstFileW (FileDir ＋ { 42, 0, 0, 0 }, FindData)
        .如果真 (hFind ≠ #INVALID_HANDLE_VALUE)
            .循环判断首 ()
                pFile ＝ 取数据_通用型_数组 (FindData.cFileName)
                .如果真 (pFile ＝ 0)
                    到循环尾 ()
                .如果真结束
                dwSize ＝ lstrlenW (pFile)
                .如果真 (dwSize ＝ 0)
                    到循环尾 ()
                .如果真结束
                FileName ＝ 指针到字节集 (pFile, dwSize × 2 ＋ 2)
                .如果真 (FileName ＝ { 46, 0, 0, 0 } 或 FileName ＝ { 46, 0, 46, 0, 0, 0 })
                    到循环尾 ()
                .如果真结束
                .如果真 (位与 (FindData.dwFileAttributes, #FILE_ATTRIBUTE_DIRECTORY) ≠ 0)
                    文件_枚举W (FileDir ＋ FileName, 欲寻找的文件名, 文件数组, 是否带路径, 是否遍历子目录, 是否枚举文件夹)
                .如果真结束
                
            .循环判断尾 (FindNextFileW (hFind, FindData))
            FindClose (hFind)
        .如果真结束
        
    .如果真结束
    dwLen ＝ 取数组成员数 (文件数组)
    返回 (dwLen)

.子程序 删除Unicode结尾空白字节, 字节集, 公开
    .参数 欲被处理的字节集, 字节集
    .参数 标准Unicode编码, 逻辑型, 可空, 默认为假，非标准Unicode编码
    .局部变量 dwSize, 整数型
    .局部变量 ptr, 整数型
    .局部变量 s, 短整数型
    .局部变量 i, 整数型

    dwSize ＝ 取字节集长度 (欲被处理的字节集)
    .如果真 (dwSize ＜ 2)
        返回 ({ })
    .如果真结束
    ptr ＝ 取指针_字节集型 (欲被处理的字节集)
    .变量循环首 (0, dwSize － 2, 2, i)
        s ＝ 指针_到短整数型_汇编 (ptr ＋ i)
        .如果真 (s ＝ 0)
            跳出循环 ()
        .如果真结束
        
    .变量循环尾 ()
    .判断开始 (i ＝ 0 或 i ＞ dwSize)
        返回 ({ })
    .判断 (标准Unicode编码)
        返回 (指针到字节集 (ptr, i) ＋ { 0, 0 })
    .默认
        返回 (指针到字节集 (ptr, i))
    .判断结束
    

.子程序 文件_枚举_队列, , 公开
    .参数 参_目录, 文本型
    .参数 参_文件名, 文本型
    .参数 参_是否遍历子目录, 逻辑型, 可空
    .参数 参_回调函数, 子程序指针, , 参数1:文本型:目录 参数2:文本型:文件名
    .局部变量 局_队列, 类_队列
    .局部变量 局_目录, 文本型
    .局部变量 局_文件名, 文本型
    .局部变量 局_文本, 文本型

    局_目录 ＝ 参_目录
    .如果真 (取文本右边 (局_目录, 1) ≠ “\”)
        局_目录 ＝ 局_目录 ＋ “\”
    .如果真结束
    局_队列.压入文本 (局_目录)
    .判断循环首 (局_队列.弹出文本 (局_文本))
        局_文件名 ＝ 寻找文件 (局_文本 ＋ 参_文件名, )
        .判断循环首 (局_文件名 ≠ “”)
            程序_Call (到整数 (参_回调函数), 取指针_文本型 (局_文本), 取指针_文本型 (局_文件名), , , )
            局_文件名 ＝ 寻找文件 (, )
        .判断循环尾 ()
        .如果真 (取反 (参_是否遍历子目录))
            到循环尾 ()
        .如果真结束
        局_文件名 ＝ 寻找文件 (局_文本 ＋ “*.*”, #子目录)
        .判断循环首 (局_文件名 ≠ “”)
            .如果真 (局_文件名 ≠ “.” 且 局_文件名 ≠ “..”)
                局_队列.压入文本 (局_文本 ＋ 局_文件名 ＋ “\”)
            .如果真结束
            局_文件名 ＝ 寻找文件 (, #子目录)
        .判断循环尾 ()
    .判断循环尾 ()

.子程序 文件_删除, 逻辑型, 公开, 删除指定路径的文件
    .参数 欲删除的文件名, 文本型, , 欲删除的文件名

    返回 (DeleteFileA (欲删除的文件名))

.子程序 文件_删除W, 逻辑型, 公开, 删除指定路径的文件
    .参数 欲删除的文件名, 字节集

    返回 (DeleteFileW (欲删除的文件名))

.子程序 文件_删除到回收站, 逻辑型, 公开, 将指定文件删除到回收站,成功返回真,失败返回假[V雪落有声V]
    .参数 欲删除的文件名, 文本型, , 欲删除的全路径文件名
    .参数 删除方式选项, 整数型, 可空, 1: 不询问删除;  2: 不提示错误;  4: 不显示进度。如果被省略，默认值为 0 。

    返回 (文件_文件操作W (#FO_DELETE, 编码_Ansi到Unicode (欲删除的文件名, ), , 删除方式选项))

.子程序 文件_删除配置节, , 公开, 删除指定配置文件中的节
    .参数 配置文件名, 文本型
    .参数 节名称, 文本型
    .局部变量 a, 文本型, , "2"
    .局部变量 b, 整数型, , "2"

    .如果真 (文件是否存在 (配置文件名))
        a [1] ＝ 到文本 (读入文件 (配置文件名))
        b [1] ＝ 寻找文本 (a [1], “[” ＋ 节名称 ＋ “]”, , 假)
        .如果真 (b [1] ＞ -1)
            b [2] ＝ 寻找文本 (a [1], “[”, b [1] ＋ 取文本长度 (节名称) ＋ 1, 假)
            .如果 (b [2] ＝ -1)
                b [2] ＝ 取文本长度 (a [1])
            .否则
                b [2] ＝ b [2] － 1 ' 减去[的长度
            .如果结束
            a [2] ＝ 取文本左边 (a [1], b [1] － 1) ＋ 取文本右边 (a [1], 取文本长度 (a [1]) － b [2])
            写到文件 (配置文件名, 到字节集 (a [2]))
        .如果真结束
        
    .如果真结束
    

.子程序 文件_删除配置项, , 公开, 删除指定配置文件中的项
    .参数 配置文件名, 文本型
    .参数 节名称, 文本型
    .参数 配置项名称, 文本型
    .局部变量 a, 文本型, , "2"
    .局部变量 b, 整数型, , "3"

    .如果真 (文件是否存在 (配置文件名))
        写配置项 (配置文件名, 节名称, 配置项名称, “Mark2928198601074334”)
        a [1] ＝ 到文本 (读入文件 (配置文件名))
        b [2] ＝ 寻找文本 (a [1], “Mark2928198601074334”, 1, 假)
        b [1] ＝ 倒找文本 (a [1], #换行符, b [2], 假)
        b [3] ＝ 寻找文本 (a [1], #换行符, b [2], 假)
        .如果真 (b [3] ＝ -1)
            b [3] ＝ 取文本长度 (a [1])
        .如果真结束
        a [2] ＝ 取文本左边 (a [1], b [1]) ＋ 取文本右边 (a [1], 取文本长度 (a [1]) － b [3])
        写到文件 (配置文件名, 到字节集 (a [2]))
    .如果真结束
    

.子程序 文件_取路径盘符, 文本型, 公开, 如 局_项数组:001\002\01\0104.txt返回 局_项数组:
    .参数 文件或目录名, 文本型
    .局部变量 SFO, 对象

    CoInitialize (0)
    .如果真 (SFO.创建 (“scripting.FileSystemObject”, ))
        返回 (SFO.读文本属性 (“GetDriveName”, 文件或目录名))
    .如果真结束
    CoUninitialize ()
    返回 (“”)

.子程序 文件_到短文件名, 文本型, 公开, 返回短文件名
    .参数 文件名, 文本型
    .局部变量 szPath, 字节集

    szPath ＝ 文件_到短文件名W (编码_Ansi到Unicode (文件名, ))
    返回 (编码_Unicode到Ansi (szPath))

.子程序 文件_到短文件名W, 字节集, 公开, 返回短文件名
    .参数 完整路径, 字节集
    .局部变量 dwSize, 整数型
    .局部变量 szPath, 字节集

    dwSize ＝ GetShortPathNameW (完整路径, { 0, 0 }, 0)
    .如果真 (dwSize ＞ 0)
        szPath ＝ 取空白字节集 (dwSize × 2)
        GetShortPathNameW (完整路径, szPath, dwSize)
    .如果真结束
    返回 (szPath)

.子程序 文件_到长文件名, 文本型, 公开, 返回长文件名
    .参数 文件名, 文本型
    .局部变量 局_长路径, 文本型
    .局部变量 局_长度, 整数型

    局_长度 ＝ GetLongPathNameA (文件名, 局_长路径, 0)
    局_长路径 ＝ 取空白文本 (局_长度)
    GetLongPathNameA (文件名, 局_长路径, 局_长度)
    .如果真 (删首尾空 (局_长路径) ≠ “”)
        返回 (局_长路径)
    .如果真结束
    返回 (文件名)

.子程序 文件_改名, 逻辑型, 公开, 重新命名一个文件。成功返回真，失败返回假。本命令为初级命令。
    .参数 文件名, 文本型, , 文件名
    .参数 新文件名, 文本型, , 新文件名
    .局部变量 lRes, 逻辑型

    .如果真 (文件_路径是否规范 (新文件名) ＝ 假)
        输出调试文本 (“文件_改名 - 新文件名不规范，使用不规范的文件名会导致文件被删除。请更改参数[新文件名]”)
        返回 (假)
    .如果真结束
    lRes ＝ MoveFileA (文件名, 新文件名)
    .如果真 (lRes ＝ 假)
        输出调试文本 (取错误信息文本_API (, ))
    .如果真结束
    返回 (lRes)

.子程序 文件_删除某类文件, 整数型, 公开, 支持通配符删除，写法如：删除文件("局_项数组:\","*.*")返回删除文件总数(有些文件由于某种原因可能未被删除)
    .参数 目录名, 文本型, , 最后不带"\",但可自动加上.
    .参数 扩展名, 文本型, , 如"*.BAT"或“ABC*.INI"，可以使用多字符 (*) 和单字符 (?) 通配符
    .参数 是否包含子目录, 逻辑型, 可空, 默认为假，不包含；真，包含。
    .参数 参_删除数量, 整数型, 可空, 此参数没用的,无需填写参数,否则返回的成功删除数量将不准确
    .局部变量 文件名, 文本型
    .局部变量 删除数量, 整数型

    删除数量 ＝ 参_删除数量
    .如果真 (寻找文本 (扩展名, “.”, , 假) ＝ -1)
        提示框 (“扩展名有错,请返回检查,格式请看参数说明”)
        返回 (0)
    .如果真结束
    .如果真 (取文本右边 (目录名, 1) ≠ “\”)
        目录名 ＝ 目录名 ＋ “\”
    .如果真结束
    文件名 ＝ 寻找文件 (目录名 ＋ 扩展名, )
    .判断循环首 (文件名 ≠ “”)
        .如果真 (删除文件 (目录名 ＋ 文件名))
            删除数量 ＝ 删除数量 ＋ 1
        .如果真结束
        文件名 ＝ 寻找文件 (, )
    .判断循环尾 ()
    .如果真 (是否包含子目录)
        文件名 ＝ 寻找文件 (目录名 ＋ “*.*”, #子目录)
        .判断循环首 (文件名 ≠ “”)
            .如果真 (取文本左边 (文件名, 1) ≠ “.”)
                删除数量 ＝ 文件_删除某类文件 (目录名 ＋ 文件名, 扩展名, 是否包含子目录, 删除数量)
            .如果真结束
            文件名 ＝ 寻找文件 (, #子目录)
        .判断循环尾 ()
    .如果真结束
    返回 (删除数量)

.子程序 文件_后缀是否关联, 整数型, 公开, 判断指定后缀名是否被关联(未关联返回-1 关联文件不存在返回0 已经关联返回1)
    .参数 后缀, 文本型, , 欲判断是否已经关联的后缀 ( 如 html )
    .局部变量 路径, 文本型
    .局部变量 a, 整数型
    .局部变量 b, 整数型

    .如果真 (注册项是否存在 (1, “.” ＋ 后缀 ＋ “\”) ＝ 假)
        返回 (-1)
    .如果真结束
    路径 ＝ 取文本注册项 (1, 取文本注册项 (1, “.” ＋ 后缀 ＋ “\”, ) ＋ “\Shell\Open\Command\”, )
    a ＝ 寻找文本 (路径, #引号, , 假)
    .如果 (a ＝ -1)
        a ＝ 寻找文本 (路径, “ ”, , 假)
        .如果真 (a ≠ -1)
            路径 ＝ 取文本左边 (路径, a － 1)
        .如果真结束
        
    .否则
        b ＝ 寻找文本 (路径, #引号, a ＋ 1, 假)
        路径 ＝ 取文本中间 (路径, a ＋ 1, b － a － 1)
    .如果结束
    .如果真 (文件是否存在 (路径) ＝ 假)
        返回 (0)
    .如果真结束
    返回 (1)

.子程序 文件_创建文件目录, 逻辑型, 公开, 根据一个文件名创建出该文件名所包含的所有目录
    .参数 文件名, 文本型, , 完整路径的文件名
    .局部变量 文本, 文本型
    .局部变量 次数, 整数型

    .如果真 (取文本中间 (文件名, 2, 1) ≠ “:”)
        返回 (假)
    .如果真结束
    .判断循环首 (寻找文本 (文件名, “\”, 次数 ＋ 1, 假) ≠ -1)
        次数 ＝ 寻找文本 (文件名, “\”, 次数 ＋ 1, 假)
        文本 ＝ 取文本左边 (文件名, 次数)
        创建目录 (文本)
    .判断循环尾 ()
    返回 (真)

.子程序 文件_取配置节名数组, , 公开, 返回节名数组
    .参数 配置文件名, 文本型
    .参数 节名数组, 文本型, 参考 数组
    .局部变量 a, 文本型, , "2"
    .局部变量 b, 整数型

    .如果 (取反 (文件是否存在 (配置文件名)))
        
    .否则
        b ＝ 打开文件 (配置文件名, #读入, #无限制)
        .判断循环首 (取反 (是否在文件尾 (b, 真)))
            a [1] ＝ 读入一行 (b)
            .如果真 (取文本左边 (a [1], 1) ＝ “[” 且 文本比较 (取文本左边 (a [1], 寻找文本 (a [1], “]”, 1, 真)), “[”, 假) ＞ 0)
                .如果 (a [2] ≠ “”)
                    a [2] ＝ a [2] ＋ “|” ＋ 取文本中间 (a [1], 2, 寻找文本 (a [1], “]”, 1, 真) － 2)
                .否则
                    a [2] ＝ 取文本中间 (a [1], 2, 寻找文本 (a [1], “]”, 1, 真) － 2)
                .如果结束
                
            .如果真结束
            
        .判断循环尾 ()
        关闭文件 (b)
        节名数组 ＝ 分割文本 (a [2], “|”, )
    .如果结束
    

.子程序 文件_取MP3播放时间, 文本型, 公开, Mp3文件的全曲时间,仅支持MP3文件,如果文件不存在，将返回空
    .参数 文件名, 文本型
    .参数 类型, 整数型, 可空, 0；总长度  1；分+秒  2；秒
    .局部变量 局部_缓冲文本, 文本型
    .局部变量 局部_整理路径, 文本型
    .局部变量 局部_长度_秒, 整数型
    .局部变量 局部_长度_分, 整数型
    .局部变量 局部_时长, 文本型

    局部_缓冲文本 ＝ 取空白文本 (128)
    局部_整理路径 ＝ 取空白文本 (256)
    GetShortPathNameA (文件名, 局部_整理路径, 取文本长度 (局部_整理路径))
    mciSendStringA (“open ” ＋ #引号 ＋ 局部_整理路径 ＋ #引号 ＋ “ Alias movie notify”, 局部_缓冲文本, 取文本长度 (局部_缓冲文本), 0) ' Alias movie parent %u Style %u notify
    局部_缓冲文本 ＝ 取空白文本 (128)
    mciSendStringA (“status movie length”, 局部_缓冲文本, 取文本长度 (局部_缓冲文本), 0)
    局部_长度_秒 ＝ 到数值 (局部_缓冲文本) ÷ 1000
    局部_长度_分 ＝ 到整数 (局部_长度_秒 ÷ 60)
    局部_时长 ＝ 文本_自动补零 (到文本 (局部_长度_分), 2) ＋ “:” ＋ 文本_自动补零 (到文本 (局部_长度_秒 － 到数值 (局部_长度_分 × 60)), 2)
    mciSendStringA (“close all”, 字符 (0), 0, #NULL)
    .判断开始 (类型 ＝ 1)
        返回 (局部_时长)
    .判断 (类型 ＝ 2)
        返回 (到文本 (到整数 (局部_长度_秒)))
    .默认
        返回 (局部_缓冲文本)
    .判断结束
    

.子程序 文件_取配置项名数组, 整数型, 公开, 返回指定配置文件中指定的节中所有的配置名称，以“|”为分界，如果配置文件不存在或配置文件中指定节为空将返回空文本
    .参数 配置文件名, 文本型
    .参数 节名名称, 文本型
    .参数 项名数组, 文本型, 参考 数组
    .局部变量 局_源数据, 文本型
    .局部变量 局_节名位置, 整数型
    .局部变量 局_位置, 整数型
    .局部变量 局_项数据, 文本型
    .局部变量 局_项名数据, 文本型
    .局部变量 局_项数组, 文本型, , "0"
    .局部变量 i, 整数型
    .局部变量 局_终止数, 双精度小数型

    .如果 (取反 (文件是否存在 (配置文件名)))
        返回 (0)
    .否则
        局_源数据 ＝ 到文本 (读入文件 (配置文件名))
        局_节名位置 ＝ 寻找文本 (局_源数据, “[” ＋ 节名名称 ＋ “]”, , 假)
        .如果真 (局_节名位置 ＞ -1)
            局_位置 ＝ 寻找文本 (局_源数据, “[”, 局_节名位置 ＋ 取文本长度 (节名名称) ＋ 1, 假)
            .如果真 (局_位置 ＝ -1)
                局_位置 ＝ 取文本长度 (局_源数据)
            .如果真结束
            局_项数据 ＝ 取文本中间 (局_源数据, 局_节名位置 ＋ 取文本长度 (节名名称) ＋ 4, 局_位置 － 局_节名位置 － 取文本长度 (节名名称) － 4)
            .如果真 (寻找文本 (局_项数据, “=”, , 假) ＞ -1)
                局_项数组 ＝ 分割文本 (局_项数据, “=”, )
                .如果 (倒找文本 (局_项数组 [1], #换行符, , 真) ＞ -1)
                    局_项名数据 ＝ 取文本右边 (局_项数组 [1], 取文本长度 (局_项数组 [1]) － 倒找文本 (局_项数组 [1], #换行符, , 真) － 1)
                .否则
                    局_项名数据 ＝ 局_项数组 [1]
                .如果结束
                
                .如果 (取文本右边 (局_源数据, 2) ＝ #换行符)
                    局_终止数 ＝ 取数组成员数 (局_项数组) － 1
                .否则
                    局_终止数 ＝ 取数组成员数 (局_项数组)
                .如果结束
                
                
                .变量循环首 (2, 局_终止数, 1, i)
                    局_项名数据 ＝ 局_项名数据 ＋ “|” ＋ 取文本右边 (局_项数组 [i], 取文本长度 (局_项数组 [i]) － 倒找文本 (局_项数组 [i], #换行符, , 真) － 1)
                .变量循环尾 ()
            .如果真结束
            
        .如果真结束
        项名数组 ＝ 分割文本 (局_项名数据, “|”, )
    .如果结束
    返回 (取数组成员数 (项名数组))

.子程序 文件_取配置项名数组1, 整数型, 公开, 返回指定配置文件中所有已有节名的文本数组。本命令为初级命令。
    .参数 配置文件名, 文本型
    .参数 节名称, 文本型
    .参数 返回的配置项名数组, 文本型, 数组
    .局部变量 sbuffer, 字节集
    .局部变量 Array, 字节集, , "0"
    .局部变量 Lenth
    .局部变量 count
    .局部变量 i
    .局部变量 text, 文本型
    .局部变量 len

    清除数组 (返回的配置项名数组)
    sbuffer ＝ 字节集_取空白字节集 (32767)
    Lenth ＝ GetPrivateProfileSection (节名称, sbuffer, 32767, 配置文件名)
    sbuffer ＝ 取字节集左边 (sbuffer, Lenth)
    Array ＝ 分割字节集 (sbuffer, { 0 }, )
    .计次循环首 (取数组成员数 (Array), i)
        text ＝ 到文本 (Array [i])
        len ＝ 寻找文本 (text, “=”, , 假)
        .如果真 (len ≠ -1)
            text ＝ 取文本左边 (text, len － 1)
        .如果真结束
        加入成员 (返回的配置项名数组, text)
    .计次循环尾 ()
    返回 (取数组成员数 (Array))

.子程序 文件_取文本编码, 整数型, 公开, 获取指定路径的txt文档的编码格式。成功返回（1：UTF-8，2：Unicode；3：Unicode big endian；4：ANSI），默认返回 4。注：请确保文件能被正常读入。
    .参数 参_文件路径, 文本型
    .局部变量 局_文件内容, 字节集
    .局部变量 局_文件长度, 整数型
    .局部变量 局_lpiResult, 整数型

    ' https://bbs.125.la/thread-14471247-1-1.html
    局_文件内容 ＝ 读入文件 (参_文件路径)
    局_文件长度 ＝ 取字节集长度 (局_文件内容)
    .判断开始 (局_文件长度 ＞ 2 且 取字节集中间 (局_文件内容, 1, 2) ＝ { 239, 187 }) ' UTF-8
        .如果真 (取字节集中间 (局_文件内容, 3, 1) ＝ { 191 })
            返回 (1)
        .如果真结束
        
    .判断 (取字节集中间 (局_文件内容, 1, 2) ＝ { 255, 254 }) ' Unicode
        返回 (2)
    .判断 (取字节集中间 (局_文件内容, 1, 2) ＝ { 254, 255 }) ' Unicode big endian
        返回 (3)
    .默认
        
    .判断结束
    局_lpiResult ＝ -1
    .判断开始 (IsTextUnicode (局_文件内容, 局_文件长度, 局_lpiResult)) ' Unicode
        返回 (2)
    .判断 (文本_是否UTF8_汇编 (局_文件内容)) ' UTF-8
        返回 (1)
    .默认
        返回 (4) ' ANSI
    .判断结束
    

.子程序 文件_是否为目录, 逻辑型, 公开, 判断一个指定的文件路径是否为目录, 是目录返回真, 不是目录或文件路径不存在返回假
    .参数 文件路径, 文本型

    返回 (文件_是否为目录W (编码_Ansi到Unicode (文件路径, )))

.子程序 文件_是否为目录W, 逻辑型, 公开, 判断一个指定的文件路径是否为目录, 是目录返回真, 不是目录或文件路径不存在返回假
    .参数 文件路径, 字节集
    .局部变量 dwFileAttributes, 整数型

    dwFileAttributes ＝ GetFileAttributesW (文件路径)
    .如果真 (dwFileAttributes ＝ #INVALID_FILE_ATTRIBUTES)
        返回 (假)
    .如果真结束
    返回 (位与 (dwFileAttributes, #FILE_ATTRIBUTE_DIRECTORY) ≠ 0)

.子程序 文件_寻找文件W, 字节集, 公开, 返回一个文本，用以表示所找到的文件名或目录名，它必须与所要求的名称格式或文件属性相匹配。
    .参数 欲寻找的文件或目录名称, 字节集, 可空, 可以被省略。可以使用多字符(*)和单字符(?)通配符来指定多重文件。在非首次寻找文件时，参数值必须为空或被省略。
    .参数 欲寻找文件的属性, 整数型, 可空, 可以被省略。参数值可以为以下常量值或其和：1、#只读文件；2、#隐藏文件；4、#系统文件；16、#子目录；32、#存档文件。通过将这些常量值加起来可以一次设置多个文件属性。如果省略本参数，默认为搜寻除子目录外的所有文件。
    .局部变量 aryhFind, 整数型, 静态, "0"
    .局部变量 dwFindLen, 整数型
    .局部变量 hFind, 整数型
    .局部变量 FindData, WIN32_FIND_DATAW
    .局部变量 lpFile, 整数型
    .局部变量 FileName, 字节集
    .局部变量 iLen, 整数型

    .如果真 (欲寻找文件的属性 ≤ 0)
        欲寻找文件的属性 ＝ 位或 (#FILE_ATTRIBUTE_READONLY, #FILE_ATTRIBUTE_HIDDEN, #FILE_ATTRIBUTE_SYSTEM, #FILE_ATTRIBUTE_ARCHIVE)
    .如果真结束
    .如果真 (是否为空 (欲寻找的文件或目录名称))
        dwFindLen ＝ 取数组成员数 (aryhFind)
        .如果真 (dwFindLen ＞ 0)
            hFind ＝ aryhFind [dwFindLen]
        .如果真结束
        .如果真 (hFind ＝ 0)
            返回 ({ })
        .如果真结束
        .判断循环首 (FindNextFileW (hFind, FindData))
            .如果真 (位与 (FindData.dwFileAttributes, 欲寻找文件的属性) ≠ 0)
                lpFile ＝ 取数据_通用型_数组 (FindData.cFileName)
                iLen ＝ lstrlenW (lpFile)
                .如果真 (iLen ＞ 0)
                    FileName ＝ 指针到字节集 (lpFile, iLen × 2 ＋ 2)
                    返回 (FileName)
                .如果真结束
                
            .如果真结束
            
        .判断循环尾 ()
        FindClose (hFind)
        .如果真 (dwFindLen ＞ 0)
            删除成员 (aryhFind, dwFindLen, )
        .如果真结束
        返回 ({ })
    .如果真结束
    hFind ＝ FindFirstFileW (欲寻找的文件或目录名称, FindData)
    .如果真 (hFind ＝ #INVALID_HANDLE_VALUE)
        返回 ({ })
    .如果真结束
    加入成员 (aryhFind, hFind)
    .如果真 (位与 (FindData.dwFileAttributes, 欲寻找文件的属性) ≠ 0)
        lpFile ＝ 取数据_通用型_数组 (FindData.cFileName)
        iLen ＝ lstrlenW (lpFile)
        .如果真 (iLen ＞ 0)
            FileName ＝ 指针到字节集 (lpFile, iLen × 2 ＋ 2)
            返回 (FileName)
        .如果真结束
        
    .如果真结束
    返回 (文件_寻找文件W (, 欲寻找文件的属性))

.子程序 文件_是否为64位, 逻辑型, 公开, 判断一个可执行映像是否为64位。
    .参数 文件路径, 文本型

    返回 (文件_是否为64位W (编码_Ansi到Unicode (文件路径, )))

.子程序 文件_是否为64位W, 逻辑型, 公开, 判断一个可执行映像是否为64位。
    .参数 文件路径, 字节集
    .局部变量 hFile, 整数型
    .局部变量 hMapping, 整数型
    .局部变量 ImageBase, 整数型
    .局部变量 wMagic, 短整数型
    .局部变量 lfanew, 整数型
    .局部变量 pNtAddr, 整数型
    .局部变量 dwSignature, 整数型
    .局部变量 isNotWow64, 逻辑型

    hFile ＝ CreateFileW (文件路径, #GENERIC_READ, #FILE_SHARE_READ, #NULL, #OPEN_EXISTING, #FILE_ATTRIBUTE_NORMAL, #NULL)
    .如果真 (hFile ＝ #INVALID_HANDLE_VALUE)
        返回 (假)
    .如果真结束
    hMapping ＝ CreateFileMappingW (hFile, #NULL, #PAGE_READONLY, 0, 0, #NULL)
    .如果真 (hMapping ≠ #NULL)
        ImageBase ＝ MapViewOfFile (hMapping, #FILE_MAP_READ, 0, 0, 0)
        .如果真 (ImageBase ≠ #NULL)
            wMagic ＝ 指针_到短整数型_汇编 (ImageBase) ' IMAGE_DOS_HEADER => e_magic
            .如果真 (wMagic ＝ #IMAGE_DOS_SIGNATURE)
                lfanew ＝ __get (ImageBase, 60) ' IMAGE_DOS_HEADER => e_lfanew
                pNtAddr ＝ ImageBase ＋ lfanew
                dwSignature ＝ __get (pNtAddr, 0) ' IMAGE_NT_HEADERS => Signature
                .如果真 (dwSignature ＝ #IMAGE_NT_SIGNATURE)
                    wMagic ＝ 指针_到短整数型_汇编 (pNtAddr ＋ 24) ' IMAGE_NT_HEADERS => OptionalHeader.Magic
                    .判断开始 (wMagic ＝ #IMAGE_NT_OPTIONAL_HDR32_MAGIC)
                        isNotWow64 ＝ 假 ' x86
                    .判断 (wMagic ＝ #IMAGE_NT_OPTIONAL_HDR64_MAGIC)
                        isNotWow64 ＝ 真 ' x64
                    .默认
                        输出调试文本 (“该文件不是一个可执行映像。”)
                    .判断结束
                    
                .如果真结束
                
            .如果真结束
            UnmapViewOfFile (ImageBase)
        .如果真结束
        CloseHandle (hMapping)
    .如果真结束
    CloseHandle (hFile)
    返回 (isNotWow64)

.子程序 文件_修改访问权限, 逻辑型, 公开, 利用DACL访问控制列表修改文件或文件夹访问权限
    .参数 文件路径, 文本型, , 文件或目录
    .参数 用户名, 文本型, , Administrators
    .参数 权限, 整数型, , #GENERIC_
    .参数 类型, 整数型, , #SET_ 或 #DENY_

    返回 (文件_修改访问权限W (编码_Ansi到Unicode (文件路径, ), 编码_Ansi到Unicode (用户名, ), 权限, 类型))

.子程序 文件_修改访问权限W, 逻辑型, 公开, 利用DACL访问控制列表修改文件或文件夹访问权限
    .参数 文件路径, 字节集, , 文件或目录
    .参数 用户名, 字节集, , Administrators
    .参数 权限, 整数型, , #GENERIC_
    .参数 类型, 整数型, , #SET_ 或 #DENY_
    .局部变量 pOldDacl, 整数型
    .局部变量 pExpAccess, 整数型
    .局部变量 pNewDacl, 整数型
    .局部变量 isRes, 逻辑型

    .如果真 (GetNamedSecurityInfoW (取指针_字节集型 (文件路径), #SE_FILE_OBJECT, #DACL_SECURITY_INFORMATION, #NULL, #NULL, 取指针整数_ (pOldDacl), #NULL, #NULL) ＝ #ERROR_SUCCESS)
        pExpAccess ＝ LocalAlloc (#LMEM_ZEROINIT, 32) ' sizeof(EXPLICIT_ACCESS)
        BuildExplicitAccessWithNameW (pExpAccess, 取指针_字节集型 (用户名), 权限, 类型, #SUB_CONTAINERS_AND_OBJECTS_INHERIT)
        .如果真 (SetEntriesInAclW (1, pExpAccess, #NULL, 取指针整数_ (pNewDacl)) ＝ #ERROR_SUCCESS)
            isRes ＝ SetNamedSecurityInfoW (取指针_字节集型 (文件路径), #SE_FILE_OBJECT, #DACL_SECURITY_INFORMATION, #NULL, #NULL, pNewDacl, #NULL) ＝ #ERROR_SUCCESS
            LocalFree (pNewDacl)
        .如果真结束
        LocalFree (pExpAccess)
    .如果真结束
    返回 (isRes)

.子程序 文件_遍历PE导入表, 整数型, 公开, 遍历可执行映像的PE导入表获取导入DLL文件的名称
    .参数 文件路径, 文本型
    .参数 导入DLL文件的名称, 文本型, 参考 数组, 接收
    .局部变量 hFile, 整数型
    .局部变量 hMapping, 整数型
    .局部变量 ImageBase, 整数型
    .局部变量 wMagic, 短整数型
    .局部变量 lfanew, 整数型
    .局部变量 dwSignature, 整数型
    .局部变量 pNtAddr, 整数型
    .局部变量 Offset, 整数型
    .局部变量 ImportData, 整数型
    .局部变量 szName, 文本型

    清除数组 (导入DLL文件的名称)
    
    hFile ＝ CreateFileW (编码_Ansi到Unicode (文件路径, ), #GENERIC_READ, #FILE_SHARE_READ, #NULL, #OPEN_EXISTING, #FILE_ATTRIBUTE_NORMAL, #NULL)
    .如果真 (hFile ≠ #INVALID_HANDLE_VALUE)
        hMapping ＝ CreateFileMappingW (hFile, #NULL, #PAGE_READONLY, 0, 0, #NULL)
        .如果真 (hMapping ≠ #NULL)
            ImageBase ＝ MapViewOfFile (hMapping, #FILE_MAP_READ, 0, 0, 0)
            .如果真 (ImageBase ≠ #NULL)
                wMagic ＝ 指针_到短整数型_汇编 (ImageBase) ' IMAGE_DOS_HEADER => e_magic
                .如果真 (wMagic ＝ #IMAGE_DOS_SIGNATURE)
                    lfanew ＝ __get (ImageBase, 60) ' IMAGE_DOS_HEADER => e_lfanew
                    pNtAddr ＝ ImageBase ＋ lfanew
                    dwSignature ＝ __get (pNtAddr, 0) ' IMAGE_NT_HEADERS => Signature
                    .如果真 (dwSignature ＝ #IMAGE_NT_SIGNATURE)
                        wMagic ＝ 指针_到短整数型_汇编 (pNtAddr ＋ 24) ' IMAGE_NT_HEADERS => OptionalHeader.Magic
                        .判断开始 (wMagic ＝ #IMAGE_NT_OPTIONAL_HDR32_MAGIC)
                            Offset ＝ 128 ' x86
                        .判断 (wMagic ＝ #IMAGE_NT_OPTIONAL_HDR64_MAGIC)
                            Offset ＝ 144 ' x64
                        .默认
                            输出调试文本 (“该文件不是一个可执行映像。”)
                        .判断结束
                        
                        .如果真 (Offset ≠ 0) ' 偏移
                            ImportData ＝ ImageRvaToVa (pNtAddr, ImageBase, __get (pNtAddr, Offset), #NULL) ' PIMAGE_NT_HEADERS => OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress
                            .判断循环首 (ImportData ≠ #NULL 且 __get (ImportData, 0) ≠ #NULL) ' IMAGE_IMPORT_DESCRIPTOR => Characteristics
                                szName ＝ 指针到文本 (ImageRvaToVa (pNtAddr, ImageBase, __get (ImportData, 12), #NULL)) ' IMAGE_IMPORT_DESCRIPTOR => Name
                                加入成员 (导入DLL文件的名称, szName)
                                ImportData ＝ ImportData ＋ 20
                            .判断循环尾 ()
                        .如果真结束
                        
                    .如果真结束
                    
                .如果真结束
                UnmapViewOfFile (ImageBase)
            .如果真结束
            CloseHandle (hMapping)
        .如果真结束
        CloseHandle (hFile)
    .如果真结束
    返回 (取数组成员数 (导入DLL文件的名称))

.子程序 文件_遍历PE导出表, 整数型, 公开, 遍历可执行映像的PE导出表获取函数名称
    .参数 文件路径, 文本型
    .参数 导出函数名称, 文本型, 参考 数组, 接收
    .局部变量 hFile, 整数型
    .局部变量 hMapping, 整数型
    .局部变量 ImageBase, 整数型
    .局部变量 wMagic, 短整数型
    .局部变量 lfanew, 整数型
    .局部变量 dwSignature, 整数型
    .局部变量 pNtAddr, 整数型
    .局部变量 Offset, 整数型
    .局部变量 ImportData, 整数型
    .局部变量 dwNumberOfNames, 整数型
    .局部变量 pAddressOfNames, 整数型
    .局部变量 szName, 文本型
    .局部变量 i, 整数型

    清除数组 (导出函数名称)
    
    hFile ＝ CreateFileW (编码_Ansi到Unicode (文件路径, ), #GENERIC_READ, #FILE_SHARE_READ, #NULL, #OPEN_EXISTING, #FILE_ATTRIBUTE_NORMAL, #NULL)
    .如果真 (hFile ≠ #INVALID_HANDLE_VALUE)
        hMapping ＝ CreateFileMappingW (hFile, #NULL, #PAGE_READONLY, 0, 0, #NULL)
        .如果真 (hMapping ≠ #NULL)
            ImageBase ＝ MapViewOfFile (hMapping, #FILE_MAP_READ, 0, 0, 0)
            .如果真 (ImageBase ≠ #NULL)
                wMagic ＝ 指针_到短整数型_汇编 (ImageBase) ' IMAGE_DOS_HEADER => e_magic
                .如果真 (wMagic ＝ #IMAGE_DOS_SIGNATURE)
                    lfanew ＝ __get (ImageBase, 60) ' IMAGE_DOS_HEADER => e_lfanew
                    pNtAddr ＝ ImageBase ＋ lfanew
                    dwSignature ＝ __get (pNtAddr, 0) ' IMAGE_NT_HEADERS => Signature
                    .如果真 (dwSignature ＝ #IMAGE_NT_SIGNATURE)
                        wMagic ＝ 指针_到短整数型_汇编 (pNtAddr ＋ 24) ' IMAGE_NT_HEADERS => OptionalHeader.Magic
                        .判断开始 (wMagic ＝ #IMAGE_NT_OPTIONAL_HDR32_MAGIC)
                            Offset ＝ 120 ' x86
                        .判断 (wMagic ＝ #IMAGE_NT_OPTIONAL_HDR64_MAGIC)
                            Offset ＝ 136 ' x64
                        .默认
                            输出调试文本 (“该文件不是一个可执行映像。”)
                        .判断结束
                        
                        .如果真 (Offset ≠ 0) ' 偏移
                            ImportData ＝ ImageRvaToVa (pNtAddr, ImageBase, __get (pNtAddr, Offset), #NULL) ' PIMAGE_NT_HEADERS => OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress
                            .如果真 (ImportData ≠ #NULL)
                                dwNumberOfNames ＝ __get (ImportData, 24)
                            .如果真结束
                            .如果真 (dwNumberOfNames ＞ 0)
                                pAddressOfNames ＝ ImageRvaToVa (pNtAddr, ImageBase, __get (ImportData, 32), #NULL) ' IMAGE_EXPORT_DIRECTORY => AddressOfNames
                                .变量循环首 (0, dwNumberOfNames － 1, 1, i) ' IMAGE_EXPORT_DIRECTORY => NumberOfNames
                                    szName ＝ 指针到文本 (ImageRvaToVa (pNtAddr, ImageBase, __get (pAddressOfNames, i × 4), #NULL)) ' IMAGE_IMPORT_DESCRIPTOR => Name
                                    加入成员 (导出函数名称, szName)
                                .变量循环尾 ()
                            .如果真结束
                            
                        .如果真结束
                        
                    .如果真结束
                    
                .如果真结束
                UnmapViewOfFile (ImageBase)
            .如果真结束
            CloseHandle (hMapping)
        .如果真结束
        CloseHandle (hFile)
    .如果真结束
    返回 (取数组成员数 (导出函数名称))

.子程序 分割符, , , '————————————————————————————————————————————————————————————
    

.子程序 目录_取文件数, 整数型, 公开, 使用FileSystemObject取目录文件数, 适合有大量文件的目录
    .参数 参_目录名, 文本型
    .局部变量 FSO, 对象
    .局部变量 GetFolder, 对象
    .局部变量 getfile, 对象
    .局部变量 SubFolders, 对象
    .局部变量 局_返回, 整数型

    CoInitialize (0)
    FSO.创建 (“Scripting.FileSystemObject”, )
    GetFolder ＝ FSO.对象型方法 (“GetFolder”, 参_目录名)
    getfile ＝ GetFolder.读对象型属性 (“Files”, )
    局_返回 ＝ getfile.读数值属性 (“count”, )
    CoUninitialize ()
    返回 (局_返回)

.子程序 目录_删除自身_cmd, , 公开, 利用CMD命令删除自身
    置文件属性 (取运行目录 () ＋ “\” ＋ 取执行文件名 (), 0)
    运行 (“cmd.exe /c del ” ＋ #引号 ＋ 取运行目录 () ＋ “\” ＋ 取执行文件名 () ＋ #引号, 假, #隐藏窗口)
    结束 ()

.子程序 目录_复制文件_cmd, , 公开, 利用CMD命令复制文件
    .参数 要复制的文件名, 文本型
    .参数 复制到的目录名, 文本型

    要复制的文件名 ＝ #引号 ＋ 要复制的文件名 ＋ #引号
    复制到的目录名 ＝ #引号 ＋ 复制到的目录名 ＋ #引号
    运行 (“cmd.exe /c copy /y ” ＋ 要复制的文件名 ＋ “ ” ＋ 复制到的目录名, 假, #隐藏窗口)

.子程序 目录_移动文件_cmd, , 公开, 利用CMD命令移动文件
    .参数 要移动的文件名, 文本型
    .参数 移动到的目录名, 文本型

    运行 (“cmd.exe /c move /y ” ＋ #引号 ＋ 要移动的文件名 ＋ #引号 ＋ “ ” ＋ #引号 ＋ 移动到的目录名 ＋ #引号, 假, #隐藏窗口)

.子程序 目录_移动并运行_cmd, , 公开
    .参数 要移动的文件名, 文本型
    .参数 移动到的目录名, 文本型
    .局部变量 临时文本, 文本型
    .局部变量 临时文件名, 文本型

    临时文件名 ＝ 文件_取文件名 (要移动的文件名)
    临时文本 ＝ #移动并运行bat
    临时文本 ＝ 子文本替换 (临时文本, “被移动文件”, 要移动的文件名, , , 真)
    临时文本 ＝ 子文本替换 (临时文本, “目录”, 移动到的目录名, , , 真)
    临时文本 ＝ 子文本替换 (临时文本, “要运行的文件”, 临时文件名, , , 真)
    写到文件 (取运行目录 () ＋ “\123.bat”, 到字节集 (到文本 (临时文本)))
    运行 (取运行目录 () ＋ “\123.bat”, 假, 1)

.子程序 目录_定位, 逻辑型, 公开, 成功则打开文件所在目录并选中文件，失败返回假,本命令为初级命令！
    .参数 文件路径, 文本型, , 需提供文件绝对路径
    .参数 编辑模式, 逻辑型, 可空, 重命名模式。

    返回 (文件_定位 (文件路径, 编辑模式))

.子程序 目录_改名, 逻辑型, 公开, 重新命名一个目录名称。成功返回真，失败返回假。本命令为初级命令。
    .参数 目录名, 文本型, , 目录名
    .参数 新目录名, 文本型, , 新目录名

    返回 (文件更名 (目录名, 新目录名))

.子程序 目录_复制, , 公开, 复制目录到指定的路径
    .参数 源目录, 文本型, , 如：C:\001\002
    .参数 目标目录, 文本型, , 复制至：d:\2543\545
    .局部变量 SFO, 对象

    CoInitialize (0)
    .如果真 (SFO.创建 (“scripting.FileSystemObject”, ))
        SFO.方法 (“CopyFolder”, 源目录, 目标目录)
    .如果真结束
    CoUninitialize ()

.子程序 目录_浏览, 文本型, 公开, 浏览文件夹内支持创建文件夹 支持显示文件 编辑框 (返回被选择文件或文件夹路径)
    .参数 标题, 文本型, 可空, 设置标题
    .参数 显示文件, 逻辑型, 可空, 默认为假。
    .参数 初始目录, 文本型, 可空, 设置一个初始目录,默认为我的电脑
    .参数 地址栏, 逻辑型, 可空, 是否包含编辑框,可编辑,默认为假
    .参数 新样式, 逻辑型, 可空, 有新建按钮及右键菜单,默认为真
    .参数 父窗口句柄, 整数型, 可空
    .局部变量 szPath, 字节集

    szPath ＝ 目录_浏览W (编码_Ansi到Unicode (标题, ), 显示文件, 编码_Ansi到Unicode (初始目录, ), 地址栏, 新样式, 父窗口句柄)
    返回 (编码_Unicode到Ansi (szPath))

.子程序 目录_浏览W, 字节集, 公开, 浏览文件夹
    .参数 标题, 字节集, 可空
    .参数 显示文件, 逻辑型, 可空
    .参数 初始目录, 字节集, 可空, 设置一个初始目录
    .参数 地址栏, 逻辑型, 可空, 是否包含编辑框
    .参数 新样式, 逻辑型, 可空, 有新建按钮及右键菜单
    .参数 父窗口句柄, 整数型, 可空
    .局部变量 bi, BROWSEINFOW
    .局部变量 szDir, 字节集
    .局部变量 szTitle, 字节集
    .局部变量 dwFlags, 整数型
    .局部变量 szFolder, 字节集
    .局部变量 pidl, 整数型
    .局部变量 pszPath, 整数型
    .局部变量 szPath, 字节集
    .局部变量 bRet, 逻辑型
    .局部变量 dwSize, 整数型

    bi.hwndOwner ＝ 父窗口句柄
    szDir ＝ 取空白字节集 (#MAX_PATH × 2)
    bi.pszDisplayName ＝ 取指针_字节集型 (szDir)
    .如果 (标题 ＝ { })
        szTitle ＝ 编码_Ansi到Unicode (“请选择一个文件夹”, )
        bi.lpszTitle ＝ 取指针_字节集型 (szTitle)
    .否则
        bi.lpszTitle ＝ 取指针_字节集型 (标题)
    .如果结束
    .如果真 (显示文件)
        dwFlags ＝ 位或 (dwFlags, #BIF_BROWSEINCLUDEFILES)
    .如果真结束
    .如果真 (地址栏)
        dwFlags ＝ 位或 (dwFlags, #BIF_EDITBOX)
    .如果真结束
    .如果真 (新样式)
        dwFlags ＝ 位或 (dwFlags, #BIF_NEWDIALOGSTYLE)
    .如果真结束
    bi.ulFlags ＝ dwFlags
    bi.lpfn ＝ 到整数 (&BrowseCallbackProc)
    .如果 (初始目录 ＝ { })
        szFolder ＝ 取空白字节集 (#MAX_PATH × 2)
        bi.lParam ＝ 取指针_字节集型 (szFolder)
    .否则
        bi.lParam ＝ 取指针_字节集型 (初始目录)
    .如果结束
    pidl ＝ SHBrowseForFolderW (bi)
    .如果真 (pidl ≠ #NULL)
        pszPath ＝ LocalAlloc (#LMEM_ZEROINIT, #MAX_PATH × 2)
        bRet ＝ SHGetPathFromIDListW (pidl, pszPath)
        dwSize ＝ lstrlenW (pszPath)
        .如果真 (dwSize ＞ 0)
            szPath ＝ 指针到字节集 (pszPath, dwSize × 2 ＋ 2)
        .如果真结束
        LocalFree (pszPath)
        CoTaskMemFree (pidl)
        返回 (szPath)
    .如果真结束
    返回 ({ })

.子程序 BrowseCallbackProc, 整数型, , 浏览文件夹
    .参数 hwnd, 整数型
    .参数 uMsg, 整数型
    .参数 lParam, 整数型
    .参数 lpData, 整数型

    .如果真 (uMsg ＝ #BFFM_INITIALIZED)
        SendMessageW (hwnd, #BFFM_SETSELECTIONW, 1, lpData)
    .如果真结束
    返回 (1)

.子程序 目录_取父路径, 文本型, 公开, 返回指定文件或目录的上一级目录路径；路径后面包含\
    .参数 文件或目录名, 文本型, , 如：C:\001\002\0.txt则返回C:\001\002\；
    .局部变量 局_位置, 整数型
    .局部变量 局_文本, 文本型

    局_文本 ＝ 文件或目录名
    .如果真 (取文本右边 (局_文本, 1) ＝ “\”)
        局_文本 ＝ 取文本左边 (局_文本, 取文本长度 (局_文本) － 1)
    .如果真结束
    局_位置 ＝ 倒找文本 (局_文本, “\”, , 假)
    返回 (取文本左边 (局_文本, 局_位置))

.子程序 目录_取大小, 长整数型, 公开, 取一个文件夹的大小；单位为字节型, 失败返回-1。
    .参数 目录名路径, 文本型, , 如：D:\Program Files
    .局部变量 SFO, 对象
    .局部变量 长度, 变体型
    .局部变量 对象1, 对象
    .局部变量 Length, 长整数型

    CoInitialize (0)
    .如果真 (SFO.创建 (“scripting.FileSystemObject”, ))
        对象1 ＝ SFO.对象型方法 (“GetFolder”, 目录名路径)
        长度 ＝ 对象1.读属性 (“Size”, )
        Length ＝ 到长整数 (长度.取数值 ())
        CoUninitialize ()
        返回 (Length)
    .如果真结束
    返回 (-1)

.子程序 目录_更新, , 公开, 把某个目录下的所有文件复制到另一个目录里
    .参数 源目录, 文本型, , 源目录，目录不以\结尾会自动添加
    .参数 目标目录, 文本型, 可空, 目标目录，目录不以\结尾会自动添加
    .参数 是否覆盖文件, 整数型, 可空, 可空。默认为直接覆盖。0=覆盖，非0不覆盖
    .局部变量 局_子目录, 文本型
    .局部变量 局_文件名, 文本型
    .局部变量 局_旧目录, 文本型
    .局部变量 局_新目录, 文本型

    局_旧目录 ＝ 源目录
    局_新目录 ＝ 目标目录
    .如果真 (取文本右边 (局_旧目录, 1) ≠ “\”)
        局_旧目录 ＝ 局_旧目录 ＋ “\”
    .如果真结束
    .如果真 (取文本右边 (局_新目录, 1) ≠ “\”)
        局_新目录 ＝ 局_新目录 ＋ “\”
    .如果真结束
    .如果真 (目录_是否存在 (局_新目录) ＝ 假)
        目录_创建 (局_新目录)
    .如果真结束
    
    局_文件名 ＝ 寻找文件 (局_旧目录 ＋ “*.*”, )
    .判断循环首 (局_文件名 ≠ “”)
        文件_复制 (局_旧目录 ＋ 局_文件名, 局_新目录 ＋ 局_文件名, 是否覆盖文件)
        处理事件 ()
        局_文件名 ＝ 寻找文件 (, )
    .判断循环尾 ()
    局_子目录 ＝ 寻找文件 (局_旧目录 ＋ “*.*”, #子目录)
    .判断循环首 (局_子目录 ≠ “”)
        .如果真 (取文本左边 (局_子目录, 1) ≠ “.”)
            处理事件 ()
            目录_更新 (局_旧目录 ＋ 局_子目录, 局_新目录 ＋ 局_子目录)
        .如果真结束
        局_子目录 ＝ 寻找文件 (, #子目录)
    .判断循环尾 ()

.子程序 目录_同步更新, , 公开, 将目标目录的文件和源目录中的文件进行对比，将不同的文件同步到目标目录里。
    .参数 源目录, 文本型, , 源目录，目录不以\结尾会自动添加
    .参数 目标目录, 文本型, , 欲更新目标的目录，目录不以\结尾会自动添加
    .局部变量 文件名, 文本型
    .局部变量 子目录, 文本型
    .局部变量 局_旧目录, 文本型
    .局部变量 局_新目录, 文本型

    局_旧目录 ＝ 源目录
    局_新目录 ＝ 目标目录
    .如果真 (取文本右边 (局_旧目录, 1) ≠ “\”)
        局_旧目录 ＝ 局_旧目录 ＋ “\”
    .如果真结束
    .如果真 (取文本右边 (局_新目录, 1) ≠ “\”)
        局_新目录 ＝ 局_新目录 ＋ “\”
    .如果真结束
    创建目录 (局_新目录)
    处理事件 ()
    文件名 ＝ 寻找文件 (局_旧目录 ＋ “*.*”, 39)
    .判断循环首 (文件名 ≠ “”)
        .判断开始 (文件_是否存在 (局_新目录 ＋ 文件名) ＝ 假) ' 不存在
            文件_复制 (局_旧目录 ＋ 文件名, 局_新目录 ＋ 文件名)
        .判断 (校验_取md5_进度 (局_新目录 ＋ 文件名, ) ≠ 校验_取md5_进度 (局_旧目录 ＋ 文件名, ))
            文件_复制 (局_旧目录 ＋ 文件名, 局_新目录 ＋ 文件名, 0)
        .默认
            
        .判断结束
        文件名 ＝ 寻找文件 (, )
    .判断循环尾 ()
    子目录 ＝ 寻找文件 (局_旧目录 ＋ “*.*”, 16)
    .判断循环首 (子目录 ≠ “”)
        .如果真 (子目录 ≠ “.” 且 子目录 ≠ “..”)
            .如果 (目录_是否存在 (局_新目录 ＋ 子目录))
                目录_同步更新 (局_旧目录 ＋ 子目录, 局_新目录 ＋ 子目录)
            .否则
                目录_删除目录 (局_新目录 ＋ 子目录)
            .如果结束
            
        .如果真结束
        子目录 ＝ 寻找文件 (, #子目录)
    .判断循环尾 ()

.子程序 目录_创建, 逻辑型, 公开, 创建多级目录，成功返回真，失败返回假。如果指定目录存在也会返回真，不覆盖目录内容。
    .参数 目录路径, 文本型
    .局部变量 szPath, 字节集

    szPath ＝ 编码_Ansi到Unicode (目录路径, )
    目录_创建W (szPath)
    返回 (目录_是否存在W (szPath))

.子程序 目录_创建W, , 公开, 创建多级目录
    .参数 目录名, 字节集, , 待创建的目录的全路径
    .局部变量 pszPath, 整数型
    .局部变量 dwSize, 整数型
    .局部变量 ptr, 整数型
    .局部变量 sBuf, 短整数型
    .局部变量 iNum, 整数型
    .局部变量 i, 整数型

    dwSize ＝ 取字节集长度 (目录名)
    .如果真 (dwSize ＜ 8) ' 不可能少于8个字节的长度，如 G:\1
        返回 ()
    .如果真结束
    pszPath ＝ 取指针_字节集型 (目录名)
    ptr ＝ LocalAlloc (#LMEM_ZEROINIT, dwSize ＋ 2) ' 多申请2个字节，避免传递进来的不规范
    .变量循环首 (0, dwSize － 2, 2, i)
        sBuf ＝ __get_short (pszPath, i)
        .如果真 (sBuf ＝ 47) ' /
            sBuf ＝ 92 ' \
        .如果真结束
        .判断开始 (sBuf ＝ 0)
            CreateDirectoryW (ptr, #NULL)
            跳出循环 ()
        .判断 (sBuf ＝ 92) ' \
            .如果真 (iNum ＞ 0)
                CreateDirectoryW (ptr, #NULL)
            .如果真结束
            iNum ＝ iNum ＋ 1
        .默认
            
        .判断结束
        __set_short (ptr, i, sBuf)
    .变量循环尾 ()
    LocalFree (ptr)

.子程序 目录_清空, , 公开, 删除指定目录下所有文件，子目录或子目录下的文件不会被删除；
    .参数 要删除文件的目录, 文本型, , 如：删除D:\Program Files(也就是Program Files)目录下的全部文件，目录不以\结尾会自动添加
    .参数 文件类型, 文本型, 可空, 默认为清空所有文件；或者清空指定格式(*.txt或*.exe)等等；
    .局部变量 局_目录, 文本型
    .局部变量 局_文件类型, 文本型
    .局部变量 临时_文件名数组, 文本型, , "0"
    .局部变量 i, 整数型

    局_目录 ＝ 要删除文件的目录
    局_文件类型 ＝ 文件类型
    .如果真 (取文本右边 (局_目录, 1) ≠ “\”)
        局_目录 ＝ 局_目录 ＋ “\”
    .如果真结束
    .如果真 (局_文件类型 ＝ “”)
        局_文件类型 ＝ “*.*”
    .如果真结束
    
    .如果真 (目录_是否符合规范 (局_目录, 真) ＝ 假)
        输出调试文本 (“目录_清空 - 传入的目录不合规范，这样会导致不可预料的情况甚至格盘！请重新提供符合规范的目录路径！注意：不可以直接使用磁盘根目录！”)
        返回 ()
    .如果真结束
    .如果真 (目录_是否存在 (局_目录) ＝ 假)
        输出调试文本 (“该目录不存在，请检查路径后重试”)
        返回 ()
    .如果真结束
    
    .计次循环首 (文件_枚举 (局_目录, 局_文件类型, 临时_文件名数组, 真), i)
        ' 默认不包含子目录，所以不会删除子目录及其中的文件。
        文件_删除到回收站 (临时_文件名数组 [i], 1)
    .计次循环尾 ()

.子程序 目录_强力清空, , 公开, 删除指定目录下所有文件，包括文件夹
    .参数 要删除文件的目录, 文本型, , 如：删除D:\Program Files(也就是Program Files)目录下的全部文件；，目录不以\结尾会自动添加
    .局部变量 局_目录, 文本型

    局_目录 ＝ 要删除文件的目录
    .如果真 (取文本右边 (局_目录, 1) ≠ “\”)
        局_目录 ＝ 局_目录 ＋ “\”
    .如果真结束
    
    .如果真 (目录_是否符合规范 (局_目录, 真) ＝ 假)
        输出调试文本 (“目录_强力清空 - 传入的目录不合规范，这样会导致不可预料的情况甚至格盘！请重新提供符合规范的目录路径！注意：不可以直接使用磁盘根目录！”)
        返回 ()
    .如果真结束
    .如果真 (目录_是否存在 (局_目录) ＝ 假)
        输出调试文本 (“该目录不存在，请检查路径后重试”)
        返回 ()
    .如果真结束
    目录_删除目录 (局_目录)
    目录_创建 (局_目录)

.子程序 目录_是否存在, 逻辑型, 公开, 输入一个目录名,判断此目录是否存在
    .参数 欲判断的目录名称, 文本型, , 传入的目录名不会被改变

    返回 (目录_是否存在W (编码_Ansi到Unicode (欲判断的目录名称, )))

.子程序 目录_是否存在W, 逻辑型, 公开, 判断路径是否存在
    .参数 欲判断的目录名称, 字节集, , 要判断的路径

    返回 (PathIsDirectoryW (欲判断的目录名称) ＝ #FILE_ATTRIBUTE_DIRECTORY)

.子程序 目录_取特定目录, 文本型, 公开, 本命令返回指定的Windows系统特定目录，所返回目录名以“\”符号结束，如失败返回空文本。
    .参数 欲获取目录类型, 整数型, 可空, 留空为桌面！1、我的文档；2、我的收藏夹；3、系统桌面；4、系统字体；5、开始菜单组；6、程序菜单组；7、启动菜单组；8、程序数据目录；9、Windows安装目录；10、Windows系统目录；11、临时文件目录；12、系统缓存目录；13、文件系统目录
    .参数 csidl, 整数型, 可空, #CSIDL_*！不为空时 欲获取目录类型 视为无效
    .局部变量 szPath, 字节集

    .如果 (是否为空 (csidl) ＝ 假)
        szPath ＝ 目录_取特定目录W (, csidl)
    .否则
        szPath ＝ 目录_取特定目录W (欲获取目录类型, )
    .如果结束
    返回 (编码_Unicode到Ansi (szPath))

.子程序 目录_取特定目录W, 字节集, 公开, 本命令返回指定的Windows系统特定目录，所返回目录名以“\”符号结束，如失败返回空文本。
    .参数 欲获取目录类型, 整数型, 可空, 留空为桌面！1、我的文档；2、我的收藏夹；3、系统桌面；4、系统字体；5、开始菜单组；6、程序菜单组；7、启动菜单组；8、程序数据目录；9、Windows安装目录；10、Windows系统目录；11、临时文件目录；12、系统缓存目录；13、文件系统目录
    .参数 csidl, 整数型, 可空, #CSIDL_*！不为空时 欲获取目录类型 视为无效
    .局部变量 szPath, 字节集
    .局部变量 pszPath, 整数型
    .局部变量 dwSize, 整数型
    .局部变量 szEnd, 字节集
    .局部变量 iCsidl, 整数型

    szPath ＝ 取空白字节集 (#MAX_PATH × 2)
    pszPath ＝ 取指针_字节集型 (szPath)
    .如果真 (是否为空 (csidl) ＝ 假)
        .如果真 (SHGetSpecialFolderPathW (#NULL, pszPath, csidl, 假) ＝ 假)
            返回 ({ })
        .如果真结束
        dwSize ＝ lstrlenW (pszPath)
        .如果真 (dwSize ＝ 0)
            返回 ({ })
        .如果真结束
        szEnd ＝ 指针到字节集 (pszPath ＋ dwSize × 2 － 2, 2) ' 取出结尾2个字节
        .如果真 (szEnd ≠ { 92, 0 }) ' 是否以反斜杠结尾
            __set_byte (pszPath, dwSize × 2, 92)
            dwSize ＝ dwSize ＋ 1
        .如果真结束
        szPath ＝ 指针到字节集 (pszPath, dwSize × 2 ＋ 2)
        返回 (szPath)
    .如果真结束
    .如果真 (欲获取目录类型 ≤ 0 或 欲获取目录类型 ＞ 13)
        欲获取目录类型 ＝ 3
    .如果真结束
    .判断开始 (欲获取目录类型 ≥ 1 且 欲获取目录类型 ≤ 10)
        iCsidl ＝ 多项选择 (欲获取目录类型, #CSIDL_PERSONAL, #CSIDL_FAVORITES, #CSIDL_DESKTOPDIRECTORY, #CSIDL_FONTS, #CSIDL_STARTMENU, #CSIDL_PROGRAMS, #CSIDL_STARTUP, #CSIDL_APPDATA, #CSIDL_WINDOWS, #CSIDL_SYSTEM)
        返回 (目录_取特定目录W (, iCsidl))
    .判断 (欲获取目录类型 ＝ 11)
        dwSize ＝ GetTempPathW (#MAX_PATH, pszPath)
        .如果真 (dwSize ＝ 0)
            返回 ({ })
        .如果真结束
        szPath ＝ 指针到字节集 (pszPath, dwSize × 2 ＋ 2)
        返回 (szPath)
    .判断 (欲获取目录类型 ＝ 12)
        返回 (目录_取特定目录W (, #CSIDL_INTERNET_CACHE))
    .判断 (欲获取目录类型 ＝ 13)
        返回 (目录_取特定目录W (, #CSIDL_COMMON_APPDATA))
    .默认
        
    .判断结束
    返回 ({ })

.子程序 目录_检索文件的显示名称, 文本型, 公开, 通过csidl值标识检索文件的显示名称
    .参数 csidl, 整数型, , #CSIDL_*
    .局部变量 szDisplayName, 字节集

    szDisplayName ＝ 目录_检索文件的显示名称W (csidl)
    返回 (编码_Unicode到Ansi (szDisplayName))

.子程序 目录_检索文件的显示名称W, 字节集, 公开, 通过csidl值标识检索文件的显示名称
    .参数 csidl, 整数型, , #CSIDL_*
    .局部变量 hr, 整数型
    .局部变量 pidl, 整数型
    .局部变量 dwSize, 整数型
    .局部变量 psfi, 整数型
    .局部变量 szDisplayName, 字节集

    hr ＝ SHGetFolderLocation (#NULL, csidl, #NULL, 0, pidl)
    .如果真 (hr ＝ #S_OK 且 pidl ≠ #NULL)
        dwSize ＝ 692
        psfi ＝ LocalAlloc (#LMEM_ZEROINIT, dwSize)
        CoInitialize (#NULL)
        hr ＝ SHGetFileInfoW (pidl, 0, psfi, dwSize, 位或 (#SHGFI_DISPLAYNAME, #SHGFI_PIDL))
        CoUninitialize ()
        .如果真 (hr ≠ 0)
            ' psfi ＋ 12 => szDisplayName[MAX_PATH]
            szDisplayName ＝ 指针_到字节集W (psfi ＋ 12)
        .如果真结束
        LocalFree (psfi)
        ILFree (pidl)
    .如果真结束
    返回 (szDisplayName)

.子程序 目录_取特定目录EX, 文本型, 公开, 1 AppDat局_项名数据 2 IE临时目录  3 局_项数组DBurning  4 局_项数组ookies  5 桌面  6 收藏夹  7 字体  8 历史记录  9 Lo局_项数组alAppDat局_项名数据 10 Lo局_项数组alSettings  11 我的音乐  12 我的图片  13 我的视频  14 NetHood  15 我的文档  16 PrintHood  17 开始_程序  18 我最近的文档  19 发送到  20 开始菜单  21 启动文件夹  22 Templates  23 所有用户_管理工具  24 所有用户_AppDat局_项名数据 25 所有用户_桌面  26 所有用户_文档  27 所有用户_收藏夹  28 所有用户_开始_程序  29 所有用户_开始菜单  30 所有用户_启动文件夹  31 所有用户_Templates  32 所有用户_音乐  33 所有用户_图片  34 所有用户_视频  35 临时目录  36 安装目录  37 系统目录  38 用户目录  39 所有用户  40 程序文件  41 所有用户_程序文件  42 系统盘  43 软件安装目录
    .参数 选择类型, 整数型, 可空, [beineimao]
    .局部变量 文本1, 文本型
    .局部变量 类型, 文本型, , "0"
    .局部变量 i, 整数型

    加入成员 (类型, “AppData”)
    加入成员 (类型, “Cache”)
    加入成员 (类型, “CD Burning”)
    加入成员 (类型, “Cookies”)
    加入成员 (类型, “Desktop”)
    加入成员 (类型, “Favorites”)
    加入成员 (类型, “Fonts”)
    加入成员 (类型, “History”)
    加入成员 (类型, “Local AppData”)
    加入成员 (类型, “Local Settings”)
    加入成员 (类型, “My Music”)
    加入成员 (类型, “My Pictures”)
    加入成员 (类型, “My Video”)
    加入成员 (类型, “NetHood”)
    加入成员 (类型, “Personal”)
    加入成员 (类型, “PrintHood”)
    加入成员 (类型, “Programs”)
    加入成员 (类型, “Recent”)
    加入成员 (类型, “SendTo”)
    加入成员 (类型, “Start Menu”)
    加入成员 (类型, “Startup”)
    加入成员 (类型, “Templates”)
    加入成员 (类型, “Common Administrative Tools”)
    加入成员 (类型, “Common AppData”)
    加入成员 (类型, “Common Desktop”)
    加入成员 (类型, “Common Documents”)
    加入成员 (类型, “Common Favorites”)
    加入成员 (类型, “Common Programs”)
    加入成员 (类型, “Common Start Menu”)
    加入成员 (类型, “Common Startup”)
    加入成员 (类型, “Common Templates”)
    加入成员 (类型, “CommonMusic”)
    加入成员 (类型, “CommonPictures”)
    加入成员 (类型, “CommonVideo”)
    加入成员 (类型, “Temp”)
    加入成员 (类型, “WinDir”)
    加入成员 (类型, “System32”)
    加入成员 (类型, “USERPROFILE”)
    加入成员 (类型, “ALLUSERSPROFILE”)
    加入成员 (类型, “ProgramFiles”)
    加入成员 (类型, “CommonProgramFiles”)
    加入成员 (类型, “SystemDrive”)
    加入成员 (类型, “软件安装目录”)
    .如果真 (选择类型 ＜ 1 或 选择类型 ＞ 取数组成员数 (类型))
        选择类型 ＝ 1
    .如果真结束
    .如果真 (到小写 (类型 [选择类型]) ＝ “软件安装目录”)
        返回 (取运行目录 ())
    .如果真结束
    .如果真 (读环境变量 (到小写 (类型 [选择类型])) ≠ “”)
        返回 (读环境变量 (到小写 (类型 [选择类型])))
    .如果真结束
    .如果真 (到小写 (类型 [选择类型]) ＝ 到小写 (“System32”))
        返回 (取文本左边 (读环境变量 (“ComSpec”), 倒找文本 (读环境变量 (“ComSpec”), “\”, , 假) － 1))
    .如果真结束
    返回 (取文本注册项 (选择 (到小写 (取文本左边 (到小写 (类型 [选择类型]), 6)) ＝ “common”, #本地机器, #现行用户), “Software\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders\” ＋ 到小写 (类型 [选择类型]), ))

.子程序 目录_取子目录数, 整数型, 公开, 取一个文件夹下面的子目录数量；失败返回-1
    .参数 父文件夹路径, 文本型
    .局部变量 SFO, 对象
    .局部变量 Folder, 对象
    .局部变量 对象, 对象
    .局部变量 局_数量, 整数型

    CoInitialize (0)
    .如果真 (SFO.创建 (“scripting.FileSystemObject”, ))
        Folder ＝ SFO.对象型方法 (“GetFolder”, 父文件夹路径)
        对象 ＝ Folder.读对象型属性 (“SubFolders”, )
        局_数量 ＝ 对象.读数值属性 (“Count”, )
        SFO.清除 ()
        CoUninitialize ()
        返回 (局_数量)
    .如果真结束
    返回 (-1)

.子程序 目录_枚举子目录, 整数型, 公开, 取一个文件夹下级子目录；成功返回子目录数量，失败返回0；
    .参数 父文件夹路径, 文本型, , 如：D:\Program Files；目录分割符请用\，路径不以\结尾会自动添加
    .参数 子目录数组, 文本型, 参考 可空 数组, 用来装载返回的子目录路径；
    .参数 是否带路径, 逻辑型, 可空, 假=不带，真=带;
    .参数 是否按字母排序, 逻辑型, 可空, 默认为假；真=按字母a-z排序  假=不排序
    .局部变量 子目录名, 文本型
    .局部变量 局_目录, 文本型

    局_目录 ＝ 父文件夹路径
    .如果真 (取文本右边 (局_目录, 1) ≠ “\”)
        局_目录 ＝ 局_目录 ＋ “\”
    .如果真结束
    清除数组 (子目录数组)
    子目录名 ＝ 寻找文件 (局_目录 ＋ “*.*”, #子目录)
    .判断循环首 (子目录名 ≠ “”)
        .如果真 (子目录名 ≠ “.” 且 子目录名 ≠ “..”)
            .如果 (是否带路径 ＝ 假)
                加入成员 (子目录数组, 子目录名)
            .否则
                加入成员 (子目录数组, 局_目录 ＋ 子目录名)
            .如果结束
            
        .如果真结束
        
        子目录名 ＝ 寻找文件 (, #子目录)
    .判断循环尾 ()
    .如果真 (是否按字母排序)
        数组_排序 (子目录数组, 0, )
    .如果真结束
    
    返回 (取数组成员数 (子目录数组))

.子程序 目录_枚举子目录1, 整数型, 公开, 取一个文件夹下级子目录；成功返回子目录数量，失败返回0；通过是否枚举子目录参数，可以枚举所有的子目录
    .参数 父文件夹路径, 文本型, , 如：D:\Program Files；目录分割符请用\，路径不以\结尾会自动添加
    .参数 子目录数组, 文本型, 参考 可空 数组, 用来装载返回的子目录路径；
    .参数 是否带路径, 逻辑型, 可空, 可为空默认为真,假=不带，真=带;
    .参数 是否继续向下枚举, 逻辑型, 可空, 为空，默认不枚举。
    .局部变量 子目录名, 文本型
    .局部变量 本级子目录列表, 文本型, , "0"
    .局部变量 目录计数器, 整数型
    .局部变量 目录总数, 整数型
    .局部变量 局_目录, 文本型

    局_目录 ＝ 父文件夹路径
    .如果真 (取文本右边 (局_目录, 1) ≠ “\”)
        局_目录 ＝ 局_目录 ＋ “\”
    .如果真结束
    子目录名 ＝ 寻找文件 (局_目录 ＋ “*.*”, #子目录)
    是否带路径 ＝ 选择 (是否为空 (是否带路径), 真, 是否带路径)
    .判断循环首 (子目录名 ≠ “”)
        .如果真 (子目录名 ≠ “.” 且 子目录名 ≠ “..”)
            加入成员 (本级子目录列表, 子目录名)
            .如果 (是否带路径)
                加入成员 (子目录数组, 局_目录 ＋ 子目录名)
            .否则
                加入成员 (子目录数组, 子目录名)
            .如果结束
            
        .如果真结束
        处理事件 ()
        子目录名 ＝ 寻找文件 (, #子目录)
    .判断循环尾 ()
    目录总数 ＝ 取数组成员数 (本级子目录列表)
    .如果真 (是否继续向下枚举)
        .计次循环首 (取数组成员数 (本级子目录列表), 目录计数器)
            .如果真 (目录_是否有子目录 (局_目录 ＋ 本级子目录列表 [目录计数器]))
                目录总数 ＝ 目录总数 ＋ 目录_枚举子目录1 (局_目录 ＋ 本级子目录列表 [目录计数器], 子目录数组, 是否带路径, 是否继续向下枚举)
            .如果真结束
            
        .计次循环尾 ()
    .如果真结束
    返回 (目录总数)

.子程序 目录_取创建时间, 日期时间型, 公开, 返回创建的时间
    .参数 目录名, 文本型, 可空
    .局部变量 SFO, 对象
    .局部变量 对象1, 对象
    .局部变量 日期, 日期时间型

    CoInitialize (0)
    .如果真 (SFO.创建 (“scripting.FileSystemObject”, ))
        对象1 ＝ SFO.对象型方法 (“GetFolder”, 目录名)
        日期 ＝ 对象1.读日期属性 (“DateCreated”, )
    .如果真结束
    CoUninitialize ()
    返回 (日期)

.子程序 目录_是否为空, 逻辑型, 公开, 如果为空返回真，否则返回假
    .参数 欲判断的目录路径, 文本型

    返回 (PathIsDirectoryEmptyA (欲判断的目录路径))

.子程序 目录_是否为空W, 逻辑型, 公开, 如果为空返回真，否则返回假
    .参数 欲判断的目录路径, 字节集

    返回 (PathIsDirectoryEmptyW (欲判断的目录路径))

.子程序 目录_是否有子目录, 逻辑型, 公开, 判断一个目录下有无下级子目录
    .参数 当前目录, 文本型, , 目录不以\结尾会自动添加
    .局部变量 文件名, 文本型
    .局部变量 局_目录, 文本型

    局_目录 ＝ 当前目录
    .如果真 (取文本右边 (局_目录, 1) ≠ “\”)
        局_目录 ＝ 局_目录 ＋ “\”
    .如果真结束
    文件名 ＝ 寻找文件 (局_目录 ＋ “*.*”, #子目录)
    .判断循环首 (文件名 ≠ “”)
        .如果真 (文件名 ≠ “” 且 文件名 ≠ “.” 且 文件名 ≠ “..”)
            返回 (真)
        .如果真结束
        文件名 ＝ 寻找文件 (, #子目录)
    .判断循环尾 ()
    返回 (假)

.子程序 目录_是否有子目录W, 逻辑型, 公开, 判断一个目录下有无下级子目录
    .参数 当前目录, 字节集, , 目录不以\结尾会自动添加
    .局部变量 szDir, 字节集
    .局部变量 hFind, 整数型
    .局部变量 FindData, WIN32_FIND_DATAW
    .局部变量 pFile, 整数型

    szDir ＝ 删除Unicode结尾空白字节 (当前目录, )
    .如果真 (取字节集右边 (szDir, 2) ≠ { 92, 0 })
        szDir ＝ szDir ＋ { 92, 0 }
    .如果真结束
    hFind ＝ FindFirstFileW (szDir ＋ { 42, 0, 0, 0 }, FindData)
    .如果真 (hFind ≠ #INVALID_HANDLE_VALUE)
        .循环判断首 ()
            pFile ＝ 取数据_通用型_数组 (FindData.cFileName)
            .如果真 (lstrcmpiW (pFile, { 46, 0, 0, 0 }) ＝ 0 或 lstrcmpiW (pFile, { 46, 0, 46, 0, 0, 0 }) ＝ 0)
                到循环尾 ()
            .如果真结束
            .如果真 (位与 (FindData.dwFileAttributes, #FILE_ATTRIBUTE_DIRECTORY) ≠ 0)
                FindClose (hFind)
                返回 (真)
            .如果真结束
            
        .循环判断尾 (FindNextFileW (hFind, FindData))
        FindClose (hFind)
    .如果真结束
    返回 (假)

.子程序 目录_设置系统属性, 逻辑型, 公开, 成功返回真，失败返回假； 给一个文件夹正确的属性，成为一个系统文件夹
    .参数 目录名, 文本型

    .判断开始 (目录名 ≠ “”)
        .判断开始 (PathMakeSystemFolderA (目录名) ≠ 0)
            返回 (真)
        .默认
            返回 (假)
        .判断结束
        
    .默认
        返回 (假)
    .判断结束
    

.子程序 目录_取消系统属性, 逻辑型, 公开, 成功返回真，失败返回假；
    .参数 目录名, 文本型

    .判断开始 (目录名 ≠ “”)
        .判断开始 (PathUnmakeSystemFolderA (目录名) ≠ 0)
            返回 (真)
        .默认
            返回 (假)
        .判断结束
        
    .默认
        返回 (假)
    .判断结束
    

.子程序 目录_检查系统属性, 逻辑型, 公开, 有系统属性返回真，没有返回假；
    .参数 目录名, 文本型

    .判断开始 (目录名 ≠ “”)
        .判断开始 (PathIsSystemFolderA (目录名, 0) ≠ 0)
            返回 (真)
        .默认
            返回 (假)
        .判断结束
        
    .默认
        返回 (假)
    .判断结束
    

.子程序 目录_取Windows目录, 文本型, 公开, 如：局_项数组:\WINDOWS\
    返回 (目录_取特定目录 (, #CSIDL_WINDOWS))

.子程序 目录_取system32目录, 文本型, 公开, 如：局_项数组:\WINDOWS\system32\
    返回 (目录_取特定目录 (, #CSIDL_SYSTEM))

.子程序 目录_取临时目录, 文本型, 公开, 取出Temp目录,如:局_项数组:\DO局_项数组UME~1\ADMINI~1\LO局_项数组ALS~1\Temp\
    返回 (目录_取特定目录 (11, ))

.子程序 目录_取尾部目录名或文件名, 文本型, 公开, 如果是目录:局_项数组:\001\002则返回 002；  如果是文件:局_项数组:\001\002\0.txt则返回 0.txt
    .参数 文件或目录名, 文本型, , 如果参数尾部包含\,将会被去掉

    返回 (编码_Unicode到Ansi (目录_取尾部目录名或文件名W (编码_Ansi到Unicode (文件或目录名, ))))

.子程序 目录_取尾部目录名或文件名W, 字节集, 公开, 检索指定文件的名称
    .参数 文件路径, 字节集
    .局部变量 pszBuf, 字节集
    .局部变量 suffix, 字节集
    .局部变量 lRes, 整数型

    pszBuf ＝ 取空白字节集 (#MAXWORD ＋ 1)
    lRes ＝ GetFileTitleW (文件路径, pszBuf, #MAXSHORT)
    .如果真 (lRes ＝ #S_OK)
        .如果真 (位与 (GetFileAttributesW (文件路径), #FILE_ATTRIBUTE_DIRECTORY) ＝ 0)
            .如果真 (系统_取数值注册项 (#HKEY_CURRENT_USER, “SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Advanced”, “HideFileExt”, 系统_是否64位操作系统 ()) ＝ 1) ' 隐藏文件扩展名
                suffix ＝ 指针_到字节集W (PathFindExtensionW (文件路径))
                .如果真 (suffix ≠ { })
                    wcscat (pszBuf, suffix)
                .如果真结束
                
            .如果真结束
            
        .如果真结束
        返回 (删除Unicode结尾空白字节 (pszBuf, 真))
    .如果真结束
    返回 ({ })

.子程序 目录_取运行目录, 文本型, 公开, 取当前被执行的易程序文件所处的目录
    返回 (编码_Unicode到Ansi (目录_取运行目录W ()))

.子程序 目录_取运行目录W, 字节集, 公开, 取当前被执行的易程序文件所处的目录
    .局部变量 hProcess, 整数型
    .局部变量 szFileName, 字节集
    .局部变量 dwSize, 整数型

    hProcess ＝ GetCurrentProcess ()
    szFileName ＝ 取空白字节集 (#MAX_PATH × 2)
    dwSize ＝ GetModuleFileNameExW (hProcess, #NULL, 取指针_字节集型 (szFileName), #MAX_PATH)
    CloseHandle (hProcess)
    .如果真 (dwSize ＝ 0)
        返回 ({ })
    .如果真结束
    szFileName ＝ 字节集_寻找取左 (szFileName, { 92, 0 }, -1) ＋ { 0, 0 }
    返回 (szFileName)

.子程序 目录_取当前目录, 文本型, 公开, 返回一个文本，用来代表当前的目录。如果失败，返回空文本。
    返回 (编码_Unicode到Ansi (目录_取当前目录W ()))

.子程序 目录_取当前目录W, 字节集, 公开, 成功返回当前目录
    .局部变量 dwSize, 整数型
    .局部变量 szDiry, 字节集

    dwSize ＝ GetCurrentDirectoryW (0, #NULL)
    .如果真 (dwSize ＞ 0)
        szDiry ＝ 取空白字节集 (dwSize × 2)
        GetCurrentDirectoryW (dwSize, 取指针_字节集型 (szDiry))
    .如果真结束
    返回 (szDiry)

.子程序 目录_取桌面目录, 文本型, 公开, 获取系统桌面的路径
    返回 (目录_取特定目录 (, #CSIDL_DESKTOPDIRECTORY))

.子程序 目录_是否符合规范, 逻辑型, 公开, 【严格】检查目录是否合规范，不和规范的目录返回假。判断标准:盘符:\目录
    .参数 要检查的目录, 文本型, , 需要检查的完整的目录路径，不接受相对路径
    .参数 是否禁止为根目录, 逻辑型, 可空, 如果设置为真，如果是盘符根目录返回假。默认为真。
    .局部变量 临时_要检查的目录, 文本型
    .局部变量 盘符, 文本型
    .局部变量 盘符代码, 整数型
    .局部变量 返回逻辑, 逻辑型

    .局部变量 文件名, 文本型

    临时_要检查的目录 ＝ 要检查的目录
    .判断循环首 (寻找文本 (临时_要检查的目录, “\\”, , 假) ＞ 0)
        临时_要检查的目录 ＝ 子文本替换 (临时_要检查的目录, “\\”, “\”, , , 真)
    .判断循环尾 ()
    
    .判断循环首 (寻找文本 (临时_要检查的目录, “//”, , 假) ＞ 0)
        临时_要检查的目录 ＝ 子文本替换 (要检查的目录, “//”, “/”, , , 真)
    .判断循环尾 ()
    
    盘符 ＝ 到大写 (取文本左边 (临时_要检查的目录, 1))
    盘符代码 ＝ 取代码 (盘符, 1)
    .如果真 (盘符代码 ＜ 65 或 盘符代码 ＞ 90)
        ' 不是A-Z之间的，标识这不是一个正常的盘符。
        返回 (假)
    .如果真结束
    
    返回逻辑 ＝ 寻找文本 (临时_要检查的目录, “:\”, , 假) ≠ -1
    ' 表示没有":\",盘符后面的分隔符
    .如果真 (返回逻辑 ＝ 假)
        返回逻辑 ＝ 寻找文本 (临时_要检查的目录, “:/”, , 假) ≠ -1
        ' 同时要检查反斜杠。如果也没有，则返回不合法
        .如果真 (返回逻辑 ＝ 假)
            返回 (假)
        .如果真结束
        
    .如果真结束
    
    .如果真 (是否禁止为根目录)
        临时_要检查的目录 ＝ 子文本替换 (临时_要检查的目录, “\\”, “\”, , , 真)
        临时_要检查的目录 ＝ 子文本替换 (临时_要检查的目录, “//”, “/”, , , 真)
        .如果真 (取文本长度 (临时_要检查的目录) ＝ 3)
            ' D:\   只有根目录会等于3.
            返回 (假)
        .如果真结束
        
    .如果真结束
    
    返回 (真)

.子程序 目录_取x86系统目录, 文本型, 公开, 取x86的system文件夹
    返回 (目录_取特定目录 (, #CSIDL_SYSTEMX86))

.子程序 目录_打开虚拟文件夹, 逻辑型, 公开, 打开我的电脑、控制面板之类的虚拟文件夹
    .参数 csidl, 整数型, , #CSIDL_*
    .局部变量 pidl, 整数型
    .局部变量 sei, SHELLEXECUTEINFOW
    .局部变量 bRet, 逻辑型

    .如果真 (SHGetSpecialFolderLocation (#NULL, csidl, pidl) ≠ #S_OK)
        返回 (假)
    .如果真结束
    sei.cbSize ＝ 60
    sei.fMask ＝ #SEE_MASK_IDLIST
    sei.lpIDList ＝ pidl
    sei.lpVerb ＝ 编码_Ansi到Unicode (“open”, )
    sei.nShow ＝ #SW_SHOWNORMAL
    bRet ＝ ShellExecuteExW (sei)
    CoTaskMemFree (pidl)
    返回 (bRet)

.子程序 目录_删除目录, 逻辑型, 公开, 删除一个存在的目录及其中的所有子目录和下属文件
    .参数 欲删除的目录, 文本型

    返回 (目录_删除目录W (编码_Ansi到Unicode (欲删除的目录, )))

.子程序 目录_删除目录W, 逻辑型, 公开, 删除一个存在的目录及其中的所有子目录和下属文件
    .参数 欲删除的目录, 字节集
    .局部变量 FileDir, 字节集
    .局部变量 FindData, WIN32_FIND_DATAW
    .局部变量 hFind, 整数型
    .局部变量 pFile, 整数型
    .局部变量 dwLen, 整数型
    .局部变量 FileName, 字节集
    .局部变量 dwFileAttributes, 整数型
    .局部变量 bRet, 逻辑型

    FileDir ＝ 删除Unicode结尾空白字节 (欲删除的目录, )
    .如果真 (取字节集右边 (FileDir, 2) ≠ { 92, 0 })
        FileDir ＝ FileDir ＋ { 92, 0 }
    .如果真结束
    .如果真 (寻找字节集 (FileDir, { 92, 0 }, ) ＝ 1)
        返回 (假)
    .如果真结束
    hFind ＝ FindFirstFileW (FileDir ＋ { 42, 0, 0, 0 }, FindData)
    .如果真 (hFind ≠ #INVALID_HANDLE_VALUE)
        .循环判断首 ()
            pFile ＝ 取数据_通用型_数组 (FindData.cFileName)
            .如果真 (pFile ＝ 0)
                到循环尾 ()
            .如果真结束
            dwLen ＝ lstrlenW (pFile)
            .如果真 (dwLen ＝ 0)
                到循环尾 ()
            .如果真结束
            FileName ＝ 指针到字节集 (pFile, dwLen × 2 ＋ 2)
            .如果真 (FileName ＝ { 46, 0, 0, 0 } 或 FileName ＝ { 46, 0, 46, 0, 0, 0 })
                到循环尾 ()
            .如果真结束
            .如果真 (位与 (FindData.dwFileAttributes, #FILE_ATTRIBUTE_DIRECTORY) ≠ 0)
                目录_删除目录W (FileDir ＋ FileName)
                到循环尾 ()
            .如果真结束
            .如果真 (位与 (FindData.dwFileAttributes, #FILE_ATTRIBUTE_READONLY) ≠ 0)
                dwFileAttributes ＝ 位与 (FindData.dwFileAttributes, 位取反 (#FILE_ATTRIBUTE_READONLY))
                SetFileAttributesW (FileDir ＋ FileName, dwFileAttributes)
            .如果真结束
            DeleteFileW (FileDir ＋ FileName)
        .循环判断尾 (FindNextFileW (hFind, FindData))
        FindClose (hFind)
        bRet ＝ RemoveDirectoryW (FileDir ＋ { 0, 0 })
    .如果真结束
    返回 (bRet)

.子程序 目录_监控文件修改, , 公开, 阻塞并等待被监视的目录发生改变
    .参数 要监视的目录完整路径, 文本型
    .参数 监视在指定的目录中的目录树, 逻辑型, 可空, 为假只监视指定的目录

    目录_监控文件修改W (编码_Ansi到Unicode (要监视的目录完整路径, ), 监视在指定的目录中的目录树)

.子程序 目录_监控文件修改W, , 公开, 阻塞并等待被监视的目录发生改变
    .参数 要监视的目录完整路径, 字节集
    .参数 监视在指定的目录中的目录树, 逻辑型, 可空, 为假只监视指定的目录
    .局部变量 hChangeHandle, 整数型
    .局部变量 dwResult, 整数型

    hChangeHandle ＝ FindFirstChangeNotificationW (要监视的目录完整路径, 监视在指定的目录中的目录树, 位或 (#FILE_NOTIFY_CHANGE_FILE_NAME, #FILE_NOTIFY_CHANGE_SIZE, #FILE_NOTIFY_CHANGE_LAST_WRITE))
    .如果真 (hChangeHandle ＝ #INVALID_HANDLE_VALUE)
        返回 ()
    .如果真结束
    dwResult ＝ WaitForMultipleObjects (1, 取指针整数_ (hChangeHandle), 假, #INFINITE)
    FindCloseChangeNotification (hChangeHandle)

.子程序 目录_监控文件修改W1, 逻辑型, 公开, 监控目标目录下某一文件发生改变，并且可以知道发生变化的是哪一个文件。
    .参数 欲监控的目标目录, 字节集
    .参数 发生更改时回调, 整数型, , void ActionProc(DWORD Action, WCHAR* FileName, DWORD FileNameLength);
    .参数 lParam, 整数型, 参考, 调用目录_停止监控目录以释放lParam。
    .局部变量 hDirectory, 整数型
    .局部变量 hCompletionPort, 整数型
    .局部变量 dwSize, 整数型
    .局部变量 hThread, 整数型
    .局部变量 lRes, 逻辑型

    .如果真 (lParam ≠ #NULL)
        目录_停止监控目录 (lParam)
    .如果真结束
    hDirectory ＝ CreateFileW (欲监控的目标目录, 位或 (#GENERIC_READ, #GENERIC_WRITE, #FILE_LIST_DIRECTORY), 位或 (#FILE_SHARE_READ, #FILE_SHARE_WRITE, #FILE_SHARE_DELETE), #NULL, #OPEN_EXISTING, 位或 (#FILE_FLAG_BACKUP_SEMANTICS, #FILE_FLAG_OVERLAPPED), #NULL)
    .如果真 (hDirectory ≠ #INVALID_HANDLE_VALUE)
        hCompletionPort ＝ CreateIoCompletionPort (hDirectory, #NULL, 0, 0)
        .如果真 (hCompletionPort ≠ #NULL)
            dwSize ＝ 2084
            ' hDirectory + hCompletionPort + lpAddress + hThread + lpOverlapped + TCHAR * 1024
            lParam ＝ GlobalAlloc (#GMEM_ZEROINIT, dwSize)
            .如果真 (lParam ≠ #NULL)
                __set (lParam, 0, hDirectory)
                __set (lParam, 4, hCompletionPort)
                __set (lParam, 8, 发生更改时回调)
                hThread ＝ CreateThread (#NULL, 0, 到整数 (&CompletionThreadProc), lParam, 0, #NULL)
                .如果真 (hThread ≠ #NULL)
                    __set (lParam, 12, hThread)
                    lRes ＝ ReadDirectoryChangesW (hDirectory, lParam ＋ 36, 1024, 真, 位或 (#FILE_NOTIFY_CHANGE_FILE_NAME, #FILE_NOTIFY_CHANGE_DIR_NAME, #FILE_NOTIFY_CHANGE_ATTRIBUTES, #FILE_NOTIFY_CHANGE_SIZE, #FILE_NOTIFY_CHANGE_LAST_WRITE, #FILE_NOTIFY_CHANGE_LAST_ACCESS, #FILE_NOTIFY_CHANGE_CREATION, #FILE_NOTIFY_CHANGE_SECURITY), #NULL, lParam ＋ 16, #NULL)
                    .如果真 (lRes)
                        返回 (真)
                    .如果真结束
                    CloseHandle (hThread)
                .如果真结束
                GlobalFree (lParam)
                lParam ＝ #NULL
            .如果真结束
            PostQueuedCompletionStatus (hCompletionPort, 0, 1, 0)
            CloseHandle (hCompletionPort)
        .如果真结束
        CloseHandle (hDirectory)
    .如果真结束
    返回 (假)

.子程序 CompletionThreadProc
    .参数 lParam, 整数型
    .局部变量 hCompletionPort, 整数型
    .局部变量 dwTransferred, 整数型
    .局部变量 pCompletionKey, 整数型
    .局部变量 pOverlapped, 整数型
    .局部变量 Offset, 整数型
    .局部变量 NextEntryOffset, 整数型
    .局部变量 Action, 整数型
    .局部变量 FileNameLength, 整数型
    .局部变量 FileName, 字节集
    .局部变量 lpAddress, 整数型
    .局部变量 hDirectory, 整数型
    .局部变量 lRes, 逻辑型

    .如果真 (lParam ＝ #NULL)
        返回 ()
    .如果真结束
    hDirectory ＝ __get (lParam, 0)
    hCompletionPort ＝ __get (lParam, 4)
    lpAddress ＝ __get (lParam, 8)
    lRes ＝ 真
    .判断循环首 (GetQueuedCompletionStatus (hCompletionPort, dwTransferred, pCompletionKey, pOverlapped, #INFINITE) ≠ 0 且 lRes)
        .如果真 (pCompletionKey ＝ 1)
            跳出循环 ()
        .如果真结束
        .如果真 (dwTransferred ＞ 0)
            Offset ＝ 0
            .判断循环首 (真)
                NextEntryOffset ＝ __get (lParam ＋ Offset, 36)
                Action ＝ __get (lParam ＋ Offset, 40)
                FileNameLength ＝ __get (lParam ＋ Offset, 44)
                ' FileName ＝ 指针到字节集 (lParam ＋ Offset ＋ 48, FileNameLength) ＋ { 0, 0 }
                .如果真 (lpAddress ≠ #NULL 且 Action ≥ #FILE_ACTION_ADDED 且 Action ≤ #FILE_ACTION_RENAMED_NEW_NAME)
                    调用子程序_ (lpAddress, Action, lParam ＋ Offset ＋ 48, FileNameLength, , , , , , , , , , , , )
                .如果真结束
                .如果真 (NextEntryOffset ＝ 0)
                    跳出循环 ()
                .如果真结束
                Offset ＝ Offset ＋ NextEntryOffset
            .判断循环尾 ()
        .如果真结束
        memset (lParam ＋ 36, 0, 1024)
        lRes ＝ ReadDirectoryChangesW (hDirectory, lParam ＋ 36, 1024, 真, 位或 (#FILE_NOTIFY_CHANGE_FILE_NAME, #FILE_NOTIFY_CHANGE_DIR_NAME, #FILE_NOTIFY_CHANGE_ATTRIBUTES, #FILE_NOTIFY_CHANGE_SIZE, #FILE_NOTIFY_CHANGE_LAST_WRITE, #FILE_NOTIFY_CHANGE_LAST_ACCESS, #FILE_NOTIFY_CHANGE_CREATION, #FILE_NOTIFY_CHANGE_SECURITY), #NULL, lParam ＋ 16, #NULL)
    .判断循环尾 ()

.子程序 目录_停止监控目录, 逻辑型, 公开, 调用以释放目录_监控文件修改W1的lParam。
    .参数 lParam, 整数型, 参考
    .局部变量 hDirectory, 整数型
    .局部变量 hCompletionPort, 整数型
    .局部变量 hThread, 整数型

    .如果真 (lParam ≠ #NULL)
        hCompletionPort ＝ __get (lParam, 4)
        .如果真 (hCompletionPort ≠ #NULL)
            PostQueuedCompletionStatus (hCompletionPort, 0, 1, 0)
            CloseHandle (hCompletionPort)
        .如果真结束
        hThread ＝ __get (lParam, 12)
        .如果真 (hThread ≠ #NULL)
            CloseHandle (hThread)
        .如果真结束
        hDirectory ＝ __get (lParam, 0)
        .如果真 (hDirectory ≠ #NULL)
            CloseHandle (hDirectory)
        .如果真结束
        .如果真 (hDirectory ≠ #NULL 且 hCompletionPort ≠ #NULL 且 hThread ≠ #NULL)
            GlobalFree (lParam)
            lParam ＝ #NULL
            返回 (真)
        .如果真结束
        
    .如果真结束
    返回 (假)

.子程序 目录_获取完整路径名称, 文本型, 公开, 检索指定文件的完整路径和文件名。
    .参数 文件名, 文本型

    返回 (编码_Unicode到Ansi (目录_获取完整路径名称W (编码_Ansi到Unicode (文件名, ))))

.子程序 目录_获取完整路径名称W, 字节集, 公开, 检索指定文件的完整路径和文件名。
    .参数 文件名, 字节集
    .局部变量 nMaxCount, 整数型
    .局部变量 pszPath, 字节集

    nMaxCount ＝ GetFullPathNameW (文件名, 0, #NULL, #NULL)
    .如果真 (nMaxCount ＞ 0)
        pszPath ＝ 取空白字节集 (incShl (nMaxCount, 真))
        nMaxCount ＝ GetFullPathNameW (文件名, nMaxCount, 取指针字节集_ (pszPath), #NULL)
        assignZero (pszPath, incShl (nMaxCount, ), 真)
    .如果真结束
    返回 (pszPath)

.子程序 目录_附加, 文本型, 公开, 将一条路径附加到另一条路径的末尾。
    .参数 欲附加的路径, 文本型
    .参数 要附加的路径, 文本型, , ..\pszMore

    返回 (编码_Unicode到Ansi (目录_附加W (编码_Ansi到Unicode (欲附加的路径, ), 编码_Ansi到Unicode (要附加的路径, ))))

.子程序 目录_附加W, 字节集, 公开, 将一条路径附加到另一条路径的末尾。
    .参数 欲附加的路径, 字节集
    .参数 要附加的路径, 字节集, , ..\pszMore
    .局部变量 dwSize, 整数型
    .局部变量 pszPath, 字节集

    dwSize ＝ 取字节集长度 (欲附加的路径)
    .如果真 (dwSize ＞ 2 且 dwSize ≤ incShl (#MAX_PATH, 真))
        pszPath ＝ 取空白字节集 (incShl (#MAX_PATH, 真))
        memcpy (取指针字节集_ (pszPath), 取指针字节集_ (欲附加的路径), dwSize)
        .如果真 (PathAppendW (pszPath, 要附加的路径))
            返回 (删除Unicode结尾空白字节 (pszPath, 真))
        .如果真结束
        
    .如果真结束
    返回 ({ })

.子程序 文件_创建映射对象, 整数型, 公开, 成功返回映射对象句柄,失败返回0
    .参数 映射对象名, 文本型, , 映射对象名,可随意填写
    .参数 映射对象的值, 整数型, , 映射对象的值,为整数型
    .局部变量 局_映射句柄, 整数型
    .局部变量 局_视图地址, 整数型

    局_映射句柄 ＝ CreateFileMappingA (-1, 0, 4, 0, 4, 映射对象名) ' 4的整数倍-对齐
    局_视图地址 ＝ MapViewOfFile (局_映射句柄, 6, 0, 0, 0)
    RtlMoveMemory_Eint_int (局_视图地址, 映射对象的值, 4)
    ' _取消文件映射对象 (局_视图地址)
    返回 (局_视图地址)

.子程序 文件_读取映射对象, 整数型, 公开, 读取映射对象的值
    .参数 映射对象名, 文本型, , 用【文件_创建映射对象】命令分创建时的映射对象名
    .局部变量 局_映射句柄, 整数型
    .局部变量 局_视图地址, 整数型
    .局部变量 局_值, 整数型

    .如果真 (局_视图地址 ＝ 0)
        局_映射句柄 ＝ OpenFileMappingA (6, 0, 映射对象名)
        局_视图地址 ＝ MapViewOfFile (局_映射句柄, 6, 0, 0, 0)
    .如果真结束
    .如果真 (局_视图地址 ≠ 0)
        RtlMoveMemory_整数传址1 (局_值, 局_视图地址, 4)
    .如果真结束
    返回 (局_值)

.子程序 文件_句柄取路径, 文本型, 公开, 根据文件句柄获取文件所在路径，失败返回空文本。
    .参数 文件句柄
    .局部变量 Status
    .局部变量 isb, IO_STATUS_BLOCK
    .局部变量 fni, FILE_NAME_INFORMATION
    .局部变量 stFileInfo, BY_HANDLE_FILE_INFORMATION
    .局部变量 hMem
    .局部变量 NameLength
    .局部变量 Name, 文本型
    .局部变量 diskCount
    .局部变量 temp, 字节集
    .局部变量 i, 整数型
    .局部变量 disk, 文本型
    .局部变量 tmp, 字节集
    .局部变量 diskData, 字节集
    .局部变量 dwVolumeSerialNumber, 整数型

    .如果 (GetFileInformationByHandle (文件句柄, stFileInfo)) ' 根据句柄取文件信息，主要是取磁盘序列号
        diskData ＝ 取空白字节集 (256)
        diskCount ＝ GetLogicalDriveStringsA (256, diskData) ' 枚举逻辑磁盘
        .变量循环首 (0, diskCount ÷ 4 － 1, 1, i)
            disk ＝ 到文本 (取字节集中间 (diskData, 4 × i ＋ 1, 4))
            .如果真 (GetVolumeInformation (disk, 字符 (0), 0, dwVolumeSerialNumber, 0, 0, 字符 (0), 0)) ' 判断磁盘序列号是否与取出来的序列号相等。
                .如果真 (dwVolumeSerialNumber ＝ stFileInfo.dwVolumeSerialNumber)
                    跳出循环 ()
                .如果真结束
                
            .如果真结束
            处理事件 ()
        .变量循环尾 ()
        disk ＝ 取文本左边 (disk, 2)
    .否则
        返回 (“”)
    .如果结束
    hMem ＝ GlobalAlloc (64, 528)
    Status ＝ ZwQueryInformationFile (文件句柄, isb, hMem, 528, 9) ' #FileNameInformation取文件名称信息
    .如果真 (Status ＝ 0)
        NameLength ＝ 取字节集数据 (指针到字节集 (hMem, 4), #整数型, )
        Name ＝ 编码_Unicode到Ansi (指针到字节集 (hMem ＋ 4, NameLength))
    .如果真结束
    GlobalFree (hMem)
    返回 (disk ＋ Name)

.子程序 文件_句柄取路径W, 字节集, 公开, 通过文件句柄获取文件所在路径
    .参数 文件句柄, 整数型
    .局部变量 szPath, 字节集

    szPath ＝ 取空白字节集 (#MAXWORD ＋ 1)
    GetFinalPathNameByHandleW (文件句柄, szPath, #MAXSHORT, #VOLUME_NAME_NT)
    返回 (删除Unicode结尾空白字节 (DosToLogicalDrive (szPath), 真))

.子程序 文件_取属性, 整数型, 公开, 返回一个文件或目录的属性。此属性值由以下常量或其和构成： 1、#只读文件； 2、#隐藏文件；  4、#系统文件； 16、#子目录；32、#存档文件 。要判断是否设置了某个属性，在返回值与想要得知的属性值之间使用“位与”命令进行比较。如果所得的结果不为零，则表示设置了这个属性值。如果取文件属性失败，将返回 -1。
    .参数 文件名, 文本型

    返回 (GetFileAttributes (文件名))

.子程序 文件_移除属性, 逻辑型, 公开, 移除指定文件的属性信息
    .参数 文件的绝对路径, 文本型
    .参数 欲设置的属性值, 整数型, , 参数值可以为以下常量值或其和： 1、#只读文件； 2、#隐藏文件； 4、#系统文件； 32、#存档文件 。通过将这些常量值加起来可以一次设置多个文件属性

    返回 (文件_移除属性W (编码_Ansi到Unicode (文件的绝对路径, ), 欲设置的属性值))

.子程序 文件_移除属性W, 逻辑型, 公开, 移除指定文件的属性信息
    .参数 文件的绝对路径, 字节集
    .参数 欲设置的属性值, 整数型, , 参数值可以为以下常量值或其和： 1、#只读文件； 2、#隐藏文件； 4、#系统文件； 32、#存档文件 。通过将这些常量值加起来可以一次设置多个文件属性
    .局部变量 dwFileAttributes, 整数型

    dwFileAttributes ＝ GetFileAttributesW (文件的绝对路径)
    dwFileAttributes ＝ 位与 (dwFileAttributes, 位取反 (欲设置的属性值))
    返回 (SetFileAttributesW (文件的绝对路径, dwFileAttributes))

.子程序 文件_取类型, 文本型, 公开, 获取文件类型，如.exe文件，则返回“应用程序”，失败则返回空。
    .参数 文件路径, 文本型
    .局部变量 Fileinfo, SHFILEINFO

    线程_初始化COM库 ()
    SHGetFileInfo (文件路径, 0, Fileinfo, 348, 1024) ' #SHGFI_TYPENAME)
    线程_取消COM库 ()
    返回 (到文本 (Fileinfo.szTypeName))

.子程序 文件_取图标句柄, 整数型, 公开, 获取文件的图标句柄
    .参数 路径, 文本型
    .局部变量 sInfo, SHFILEINFO

    线程_初始化COM库 ()
    SHGetFileInfo (路径, 128, sInfo, 348, 256)
    线程_取消COM库 ()
    返回 (sInfo.hIcon)

.子程序 文件_路径是否规范, 逻辑型, 公开, 用于【严格】检查完整路径是否规范。检查规则：盘符:\目录名\二级目录名\文件名.文件后缀
    .参数 要检查的完整路径, 文本型
    .参数 是否不检查后缀, 逻辑型, 可空, 用于指定是否检查文件的后缀，如果为假，则忽略文件后缀。默认为真
    .局部变量 盘符, 文本型
    .局部变量 盘符代码, 整数型
    .局部变量 返回逻辑, 逻辑型

    .局部变量 文件名, 文本型

    .如果真 (是否为空 (是否不检查后缀))
        是否不检查后缀 ＝ 真
    .如果真结束
    盘符 ＝ 到大写 (取文本左边 (要检查的完整路径, 1))
    盘符代码 ＝ 取代码 (盘符, 1)
    .如果真 (盘符代码 ＜ 65 或 盘符代码 ＞ 90)
        ' 不是A-Z之间的，标识这不是一个正常的盘符。
        返回 (假)
    .如果真结束
    
    返回逻辑 ＝ 寻找文本 (要检查的完整路径, “:\”, , 假) ≠ -1
    ' 表示没有":\",盘符后面的分隔符
    .如果真 (返回逻辑 ＝ 假)
        返回逻辑 ＝ 寻找文本 (要检查的完整路径, “:/”, , 假) ≠ -1
        ' 同时要检查反斜杠。如果也没有，则返回不合法
        .如果真 (返回逻辑 ＝ 假)
            返回 (假)
        .如果真结束
        
    .如果真结束
    
    文件名 ＝ 文件_取文件名 (要检查的完整路径, 真)
    .如果真 (文件名 ＝ “”)
        返回 (假)
    .如果真结束
    
    .如果真 (内部_命名规则过滤 (文件名))
        返回 (假)
    .如果真结束
    
    .如果真 (是否不检查后缀 ＝ 假)
        盘符代码 ＝ 倒找文本 (文件名, “.”, , 假)
        返回 (盘符代码 ＞ 1 且 盘符代码 ＜ 取文本长度 (文件名))
        ' 还有一个情况，以.开头的文件名，所以要判断>1才可以
    .如果真结束
    
    返回 (文件名 ≠ “”)
    

.子程序 内部_命名规则过滤, 逻辑型
    .参数 文件名, 文本型
    .局部变量 局_数组, 文本型, , "0"
    .局部变量 局_计次, 整数型

    局_数组 ＝ { “?”, “/”, “\”, “<”, “>”, “*”, “|”, “:” }
    加入成员 (局_数组, #引号)
    .计次循环首 (9, 局_计次)
        .如果真 (寻找文本 (文件名, 局_数组 [局_计次], , 假) ≠ -1)
            返回 (真)
        .如果真结束
        
    .计次循环尾 ()
    返回 (假)

.子程序 文件_文件操作W, 逻辑型, 公开, 复制、移动、重命名或删除文件系统对象。
    .参数 命令类型, 整数型, , 1、移动；2、复制；3、删除；4、重命名
    .参数 一个或多个源文件名, 字节集, , 多个文件名之间用字符0隔开！
    .参数 目标文件或目录名称, 字节集, 可空, 多个文件名之间用字符0隔开
    .参数 文件操作选项, 整数型, 可空, 1、不询问；2、不提示；4、不显示进度；8、不保留
    .局部变量 FileOp, SHFILEOPSTRUCT
    .局部变量 lRet, 整数型

    .如果真 (命令类型 ＜ 1 或 命令类型 ＞ 4)
        输出调试文本 (“请严格传递命令类型！”)
        返回 (假)
    .如果真结束
    FileOp.wFunc ＝ 多项选择 (命令类型, #FO_MOVE, #FO_COPY, #FO_DELETE, #FO_RENAME)
    FileOp.pFrom ＝ 一个或多个源文件名 ＋ { 0, 0 } ' 必须以双空结尾
    .如果真 (FileOp.wFunc ≠ #FO_DELETE)
        .如果真 (目标文件或目录名称 ＝ { })
            输出调试文本 (“目标文件或目录名称不能传递空值！”)
            返回 (假)
        .如果真结束
        FileOp.pTo ＝ 目标文件或目录名称 ＋ { 0, 0 } ' 必须以双空结尾
    .如果真结束
    .如果真 (位与 (文件操作选项, 1) ≠ 0)
        FileOp.fFlags ＝ 位或 (FileOp.fFlags, #FOF_NOCONFIRMATION, #FOF_NOCONFIRMMKDIR)
    .如果真结束
    .如果真 (位与 (文件操作选项, 2) ≠ 0)
        FileOp.fFlags ＝ 位或 (FileOp.fFlags, #FOF_NOERRORUI)
    .如果真结束
    .如果真 (位与 (文件操作选项, 4) ≠ 0)
        FileOp.fFlags ＝ 位或 (FileOp.fFlags, #FOF_SILENT)
    .如果真结束
    .如果真 (位与 (文件操作选项, 8) ＝ 0)
        FileOp.fFlags ＝ 位或 (FileOp.fFlags, #FOF_ALLOWUNDO)
    .如果真结束
    lRet ＝ SHFileOperationW (FileOp)
    .如果真 (lRet ≠ #ERROR_SUCCESS)
        输出调试文本 (取错误信息文本_API (lRet, “Shell32.dll”))
    .如果真结束
    .如果真 (FileOp.hNameMappings ≠ 0)
        SHFreeNameMappings (FileOp.hNameMappings)
    .如果真结束
    返回 (lRet ＝ 0 且 FileOp.fAnyOperationsAborted ＝ 0)

.子程序 GetIPropertyStore, 字节集, 公开, VARIANT
    .参数 szPath, 字节集
    .参数 key, 字节集
    .局部变量 hr, 整数型
    .局部变量 pIPropertyStore, 整数型
    .局部变量 pv, 整数型
    .局部变量 dwCount, 整数型
    .局部变量 pkey, 整数型
    .局部变量 vt, 短整数型
    .局部变量 lVal, 长整数型
    .局部变量 szBuf, 字节集
    .局部变量 i, 整数型

    ' https://docs.microsoft.com/en-us/windows/win32/medfound/metadata-properties-for-media-files?redirectedfrom=MSDN
    
    CoInitialize (#NULL)
    hr ＝ SHGetPropertyStoreFromParsingName (取指针_字节集型 (szPath), #NULL, #GPS_READWRITE, 取指针_字节集型 (#IID_IPropertyStore), pIPropertyStore)
    .如果真 (hr ＝ #S_OK 且 pIPropertyStore ≠ #NULL)
        pv ＝ LocalAlloc (#LMEM_ZEROINIT, 16) ' sizeof(VARIANT)
        
        ' 遍历取文件的属性
        ' hr ＝ CallObject (pIPropertyStore, #IPropertyStore_GetCount, 取指针整数_ (dwCount), , , , , , , , )
        ' .如果真 (hr ＝ #S_OK 且 dwCount ＞ 0)
            ' pkey ＝ LocalAlloc (#LMEM_ZEROINIT, 20)  ' sizeof(PROPERTYKEY)
            ' .变量循环首 (0, dwCount － 1, 1, i)
                ' memset (pkey, 0, 20)
                ' hr ＝ CallObject (pIPropertyStore, #IPropertyStore_GetAt, i, pkey, , , , , , , )
                ' .如果真 (hr ＝ #S_OK)
                    ' memset (pv, 0, 16)
                    ' hr ＝ CallObject (pIPropertyStore, #IPropertyStore_GetValue, pkey, pv, , , , , , , )
                    ' .如果真 (hr ＝ #S_OK)
                        ' vt ＝ 指针_到短整数型_汇编 (pv)
                        ' lVal ＝ 指针_到长整数型_汇编 (pv ＋ 8)
                    ' .如果真结束
                    
                ' .如果真结束
                
            ' .变量循环尾 ()
            ' LocalFree (pkey)
        ' .如果真结束
        
        hr ＝ CallObject (pIPropertyStore, #IPropertyStore_GetValue, 取指针_字节集型 (key), pv, , , , , , , )
        szBuf ＝ 指针到字节集 (pv, 16)
        
        LocalFree (pv)
        SafeRelease (pIPropertyStore)
    .如果真结束
    CoUninitialize ()
    返回 (szBuf)

.子程序 SetIPropertyStore, 逻辑型, 公开
    .参数 szPath, 字节集
    .参数 key, 字节集
    .参数 pv, 字节集, , VARIANT
    .局部变量 hr, 整数型
    .局部变量 pIPropertyStore, 整数型
    .局部变量 isSucc, 逻辑型

    CoInitialize (#NULL)
    hr ＝ SHGetPropertyStoreFromParsingName (取指针_字节集型 (szPath), #NULL, #GPS_READWRITE, 取指针_字节集型 (#IID_IPropertyStore), pIPropertyStore)
    .如果真 (hr ＝ #S_OK 且 pIPropertyStore ≠ #NULL)
        hr ＝ CallObject (pIPropertyStore, #IPropertyStore_SetValue, 取指针_字节集型 (key), 取指针_字节集型 (pv), , , , , , , )
        .如果真 (hr ＝ #S_OK)
            hr ＝ CallObject (pIPropertyStore, #IPropertyStore_Commit, , , , , , , , , )
            isSucc ＝ hr ＝ #S_OK
        .如果真结束
        SafeRelease (pIPropertyStore)
    .如果真结束
    CoUninitialize ()
    返回 (isSucc)

.子程序 文件_取MIME类型, 文本型, 公开, 成功返回MIME类型
    .参数 文件路径, 文本型

    返回 (编码_Unicode到Ansi (文件_取MIME类型W (编码_Ansi到Unicode (文件路径, ))))

.子程序 文件_取MIME类型W, 字节集, 公开, 成功返回MIME类型
    .参数 文件路径, 字节集
    .局部变量 pwzMimeOut, 整数型
    .局部变量 szMime, 字节集
    .局部变量 hr, 整数型

    hr ＝ FindMimeFromData (#NULL, 取指针_字节集型 (文件路径), #NULL, 0, #NULL, #FMFD_URLASFILENAME, pwzMimeOut, 0)
    .如果 (hr ＝ #S_OK 且 pwzMimeOut ≠ #NULL)
        szMime ＝ 指针_到字节集W (pwzMimeOut)
        CoTaskMemFree (pwzMimeOut)
    .否则
        输出调试文本 (取错误信息文本_API (hr, “urlmon.dll”))
    .如果结束
    返回 (szMime)

.版本 2

.程序集 集_文件读写W
.子程序 文件_打开文件W, 整数型, 公开, 成功返回被打开文件的文件号
    .参数 文件路径, 字节集
    .参数 打开方式, 整数型, 可空, 1、#读入 2、#写出 3、#读写 4、#重写 5、#改写
    .参数 共享方式, 整数型, 可空, 1、#无限制 2、#禁止读 3、#禁止写 4、#禁止读写
    .局部变量 dwDesiredAccess, 整数型
    .局部变量 dwShareMode, 整数型
    .局部变量 dwCreationDisposition, 整数型
    .局部变量 dwFlagsAndAttributes, 整数型
    .局部变量 hFile, 整数型

    .判断开始 (打开方式 ＝ #读入)
        dwDesiredAccess ＝ #GENERIC_READ
        dwCreationDisposition ＝ #OPEN_EXISTING
    .判断 (打开方式 ＝ #写出)
        dwDesiredAccess ＝ #GENERIC_WRITE
        dwCreationDisposition ＝ #OPEN_EXISTING
    .判断 (打开方式 ＝ #重写)
        dwDesiredAccess ＝ #GENERIC_WRITE
        dwCreationDisposition ＝ #CREATE_ALWAYS
    .判断 (打开方式 ＝ #改写)
        dwDesiredAccess ＝ #GENERIC_WRITE
        dwCreationDisposition ＝ #OPEN_ALWAYS
    .判断 (打开方式 ＝ #改读)
        dwDesiredAccess ＝ 位或 (#GENERIC_READ, #GENERIC_WRITE)
        dwCreationDisposition ＝ #OPEN_ALWAYS
    .默认
        dwDesiredAccess ＝ 位或 (#GENERIC_READ, #GENERIC_WRITE)
        dwCreationDisposition ＝ #OPEN_EXISTING
    .判断结束
    
    .判断开始 (共享方式 ＝ #禁止读)
        dwShareMode ＝ 位或 (#FILE_SHARE_WRITE, #FILE_SHARE_DELETE)
    .判断 (共享方式 ＝ #禁止写)
        dwShareMode ＝ 位或 (#FILE_SHARE_READ, #FILE_SHARE_DELETE)
    .判断 (共享方式 ＝ #禁止读写)
        dwShareMode ＝ 0
    .默认
        dwShareMode ＝ 位或 (#FILE_SHARE_READ, #FILE_SHARE_WRITE, #FILE_SHARE_DELETE)
    .判断结束
    
    dwFlagsAndAttributes ＝ 选择 (文件_是否为目录W (文件路径), #FILE_FLAG_BACKUP_SEMANTICS, #FILE_ATTRIBUTE_NORMAL)
    hFile ＝ CreateFileW (文件路径, dwDesiredAccess, dwShareMode, #NULL, dwCreationDisposition, dwFlagsAndAttributes, #NULL)
    返回 (选择 (hFile ＝ #INVALID_HANDLE_VALUE, 0, hFile))

.子程序 文件_关闭文件W, 逻辑型, 公开, 关闭被打开的各种类型文件
    .参数 文件句柄, 整数型, 参考
    .局部变量 lRet, 逻辑型

    .如果真 (文件句柄 ＞ 0)
        lRet ＝ CloseHandle (文件句柄)
        文件句柄 ＝ 0
    .如果真结束
    返回 (lRet)

.子程序 文件_移动读写位置W, 逻辑型, 公开, 置下一个读或写操作的位置
    .参数 文件句柄, 整数型
    .参数 起始移动位置, 整数型, 可空, 1、#文件首 2、#文件尾 3、#现行位置
    .参数 移动距离, 长整数型
    .局部变量 dwMoveMethod, 整数型

    .如果真 (文件句柄 ≤ 0)
        返回 (假)
    .如果真结束
    .判断开始 (起始移动位置 ＝ #文件尾)
        dwMoveMethod ＝ #FILE_END
    .判断 (起始移动位置 ＝ #现行位置)
        dwMoveMethod ＝ #FILE_CURRENT
    .默认
        dwMoveMethod ＝ #FILE_BEGIN
    .判断结束
    返回 (SetFilePointer (文件句柄, LOWPART (移动距离), HIGHPART (移动距离), dwMoveMethod) ≠ #INVALID_SET_FILE_POINTER)

.子程序 文件_取读写位置W, 长整数型, 公开, 返回指定被打开文件的当前读/写位置
    .参数 文件句柄, 整数型
    .局部变量 dwLowPart, 整数型
    .局部变量 dwHighPart, 整数型

    dwLowPart ＝ SetFilePointer (文件句柄, #NULL, dwHighPart, #FILE_CURRENT)
    .如果真 (dwLowPart ＝ #INVALID_SET_FILE_POINTER)
        返回 (0)
    .如果真结束
    返回 (合并长整数 (dwLowPart, dwHighPart))

.子程序 文件_取文件长度W, 长整数型, 公开, 返回指定被打开文件的尺寸
    .参数 文件句柄, 整数型
    .局部变量 dwFileSize, 长整数型

    .如果真 (文件句柄 ≤ 0)
        返回 (0)
    .如果真结束
    .如果真 (GetFileSizeEx (文件句柄, 取指针长整数_ (dwFileSize)) ＝ 假)
        输出调试文本 (取错误信息文本_API (, ))
    .如果真结束
    返回 (dwFileSize)

.子程序 文件_读入字节集W, 字节集, 公开, 从当前读写位置读取并返回一段字节集数据
    .参数 文件句柄, 整数型
    .参数 读入长度, 整数型
    .局部变量 pMem, 整数型
    .局部变量 ulSize, 整数型
    .局部变量 aryBit, 字节集

    .如果真 (文件句柄 ≤ 0)
        返回 ({ })
    .如果真结束
    pMem ＝ HeapAlloc (GetProcessHeap (), #HEAP_ZERO_MEMORY, 读入长度)
    .如果真 (pMem ≠ #NULL)
        .如果真 (ReadFile_整数型 (文件句柄, pMem, 读入长度, ulSize, #NULL) ＝ 假)
            文件_移动读写位置W (文件句柄, #文件尾, 0)
        .如果真结束
        aryBit ＝ 指针到字节集 (pMem, ulSize)
        HeapFree (GetProcessHeap (), 0, pMem)
    .如果真结束
    返回 (aryBit)

.子程序 文件_写出字节集W, 逻辑型, 公开, 写出字节集数据到文件中当前读写位置处
    .参数 文件句柄, 整数型
    .参数 要写出的数据, 字节集
    .局部变量 nMaxCount, 整数型

    .如果真 (文件句柄 ≤ 0)
        返回 (假)
    .如果真结束
    nMaxCount ＝ 取字节集长度 (要写出的数据)
    返回 (WriteFile (文件句柄, 要写出的数据, nMaxCount, #NULL, #NULL))

.子程序 文件_是否在文件尾W, 逻辑型, 公开, 判断读写位置是否已经处于该文件数据的尾部
    .参数 文件句柄, 整数型

    .如果真 (文件句柄 ≤ 0)
        返回 (假)
    .如果真结束
    返回 (文件_取读写位置W (文件句柄) ＝ 文件_取文件长度W (文件句柄))

.版本 2

.程序集 类_快速文本, , 公开, 文本的快速累加
.程序集变量 _文件句柄, 整数型
.程序集变量 集_缓冲区, 字节集

.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
    _文件句柄 ＝ 打开内存文件 ()

.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
    关闭文件 (_文件句柄)

.子程序 添加, , 公开
    .参数 文本内容, 文本型

    写出文本 (_文件句柄, 文本内容)

.子程序 取文本, 文本型, 公开
    .如果真 (取读写位置 (_文件句柄) ≠ 0)
        移到文件首 (_文件句柄)
    .如果真结束
    返回 (读入文本 (_文件句柄, 取文件长度 (_文件句柄)))
    

.子程序 取文件号, 整数型, 公开
    返回 (_文件句柄)
    

.子程序 插入, 逻辑型, 公开, 在指定字符后(含中文)插入文本内容
    .参数 参_插入位置, 整数型, 可空, 字符数,中文也算一个字符,可空,默认最前
    .参数 参_文本内容, 文本型, , 要插入的文本内容
    .局部变量 局_缓冲区长度, 整数型
    .局部变量 局_偏移, 整数型

    写缓存区 ()
    局_缓冲区长度 ＝ 取字节集长度 (集_缓冲区)
    局_偏移 ＝ 1
    .如果真 (是否为空 (参_插入位置))
        参_插入位置 ＝ 0
    .如果真结束
    局_偏移 ＝ 字数到位置 (参_插入位置)
    局_偏移 ＝ 局_偏移 － 1
    移动读写位置 (_文件句柄, #文件首, 局_偏移)
    返回 (插入文本 (_文件句柄, 参_文本内容))

.子程序 取文本内容, 文本型, 公开, 取出文本内容
    .参数 参_起始位置, 整数型, 可空, 可空.默认从第一个字符开始
    .参数 参_字符数, 整数型, 可空, 可空,默认取全部
    .局部变量 局_偏移, 整数型
    .局部变量 局_缓冲区长度, 整数型
    .局部变量 局_偏移2, 整数型

    .如果真 (取读写位置 (_文件句柄) ≠ 0)
        移到文件首 (_文件句柄)
    .如果真结束
    .如果真 (是否为空 (参_字符数) 且 是否为空 (参_起始位置))
        返回 (读入文本 (_文件句柄, ))
    .如果真结束
    集_缓冲区 ＝ 读入字节集 (_文件句柄, 取文件长度 (_文件句柄))
    .如果真 (是否为空 (参_起始位置))
        参_起始位置 ＝ 1
    .如果真结束
    .如果真 (是否为空 (参_字符数))
        参_字符数 ＝ 取字节集长度 (集_缓冲区)
    .如果真结束
    参_起始位置 ＝ 参_起始位置 － 1
    局_偏移 ＝ 1
    局_缓冲区长度 ＝ 取字节集长度 (集_缓冲区)
    局_偏移 ＝ 字数到位置 (参_起始位置)
    局_偏移2 ＝ 字数到位置 (参_起始位置 ＋ 参_字符数)
    返回 (到文本 (取字节集中间 (集_缓冲区, 局_偏移, 局_偏移2 － 局_偏移)))

.子程序 清空内容, , 公开, 清空文本内容
    关闭文件 (_文件句柄)
    _文件句柄 ＝ 打开内存文件 ()

.子程序 删除文本, 逻辑型, 公开, 删除指定位置内容
    .参数 参_起始位置, 整数型, , 起始位置
    .参数 参_字符数, 整数型, , 删除个数,汉字算一个
    .局部变量 局_偏移, 整数型
    .局部变量 局_缓冲区长度, 整数型
    .局部变量 局_偏移2, 整数型

    .如果真 (取读写位置 (_文件句柄) ≠ 0)
        移到文件首 (_文件句柄)
    .如果真结束
    集_缓冲区 ＝ 读入字节集 (_文件句柄, 取文件长度 (_文件句柄))
    局_缓冲区长度 ＝ 取字节集长度 (集_缓冲区)
    局_偏移 ＝ 字数到位置 (参_起始位置)
    局_偏移2 ＝ 字数到位置 (参_起始位置 ＋ 参_字符数)
    移动读写位置 (_文件句柄, #文件首, 局_偏移 － 1)
    返回 (删除数据 (_文件句柄, 局_偏移2 － 局_偏移))

.子程序 替换文本内容, 逻辑型, 公开, 替换指定位置文本
    .参数 参_替换位置, 整数型, , 起始位置
    .参数 参_替换长度, 整数型, , 替换长度
    .参数 参_替换文本, 文本型, 可空, 替换文本,可空
    .局部变量 局_偏移1, 整数型
    .局部变量 局_偏移2, 整数型
    .局部变量 局_缓冲区长度, 整数型

    写缓存区 ()
    局_偏移1 ＝ 1
    局_缓冲区长度 ＝ 取字节集长度 (集_缓冲区)
    局_偏移1 ＝ 字数到位置 (参_替换位置)
    局_偏移2 ＝ 字数到位置 (参_替换位置 ＋ 参_替换长度)
    清空内容 ()
    返回 (写出字节集 (_文件句柄, 字节集替换 (集_缓冲区, 局_偏移1, 局_偏移2 － 局_偏移1, 到字节集 (参_替换文本))))

.子程序 取长度, 整数型, 公开, 取字符数,汉字算一个
    .如果真 (取读写位置 (_文件句柄) ≠ 0)
        移到文件首 (_文件句柄)
    .如果真结束
    返回 (汇编_取字数 (到字节集 (取文本内容 (, ))))

.子程序 寻找文本内容, 整数型, 公开, 寻找文本
    .参数 参_寻找文本内容, 文本型, , 欲寻找文本
    .参数 参_起始寻找位置, 整数型, 可空, 起始位置,可空,默认从最头开始
    .局部变量 局_偏移, 整数型
    .局部变量 局_文本, 字节集
    .局部变量 i, 整数型

    写缓存区 ()
    局_偏移 ＝ 1
    .如果真 (是否为空 (参_起始寻找位置))
        参_起始寻找位置 ＝ 1
    .如果真结束
    局_偏移 ＝ 字数到位置 (参_起始寻找位置)
    i ＝ 寻找字节集 (集_缓冲区, 到字节集 (参_寻找文本内容), 局_偏移)
    .如果真 (i ＝ 1)
        返回 (1)
    .如果真结束
    局_文本 ＝ 取字节集左边 (集_缓冲区, i － 1)
    .如果 (局_文本 ＝ { })
        返回 (0)
    .否则
        返回 (汇编_取字数 (局_文本) ＋ 1)
    .如果结束
    

.子程序 替换子文本内容, 逻辑型, 公开, 子文本替换
    .参数 参_被替换文本, 文本型, , 被替换内容
    .参数 参_替换为文本, 文本型, 可空, 替换为内容,可空.默认删除
    .参数 参_起始替换位置, 整数型, 可空, 起始位置,可空,默认从最前开始
    .参数 参_最大替换次数, 整数型, 可空, 最大替换次数.可空.默认替换所有
    .局部变量 局_偏移, 整数型
    .局部变量 局_缓冲区长度, 整数型

    写缓存区 ()
    局_偏移 ＝ 1
    局_缓冲区长度 ＝ 取字节集长度 (集_缓冲区)
    .如果真 (是否为空 (参_起始替换位置))
        参_起始替换位置 ＝ 1
    .如果真结束
    局_偏移 ＝ 字数到位置 (参_起始替换位置)
    清空内容 ()
    .如果 (是否为空 (参_最大替换次数))
        返回 (写出字节集 (_文件句柄, 子字节集替换 (集_缓冲区, 到字节集 (参_被替换文本), 到字节集 (参_替换为文本), 局_偏移, )))
    .否则
        返回 (写出字节集 (_文件句柄, 子字节集替换 (集_缓冲区, 到字节集 (参_被替换文本), 到字节集 (参_替换为文本), 局_偏移, 参_最大替换次数)))
    .如果结束
    

.子程序 汇编_取字数, 整数型, 公开, 取文本中英文字数
    .参数 参_内容, 字节集

    参_内容 ＝ 参_内容 ＋ { 0 }
    取变量堆栈地址_字节集 (参_内容)
    置入代码 ({ 139, 24, 139, 75, 4, 141, 115, 8, 172, 132, 192, 116, 7, 168, 128, 116, 1, 70, 226, 244, 139, 67, 4, 41, 200, 201, 194, 4, 0 })
    返回 (0)

.子程序 置文本, 逻辑型, 公开, 置文本
    .参数 参_文本, 文本型, , 文本内容

    关闭文件 (_文件句柄)
    _文件句柄 ＝ 打开内存文件 ()
    返回 (写出文本 (_文件句柄, 参_文本))

.子程序 从文件读入, 逻辑型, 公开, 读文件内容到内存
    .参数 参_文件名, 文本型, , 要读入的文件名

    关闭文件 (_文件句柄)
    _文件句柄 ＝ 打开内存文件 ()
    返回 (写出字节集 (_文件句柄, 读入文件 (参_文件名)))

.子程序 写出到文件, 逻辑型, 公开, 写内存内容到文件
    .参数 参_文件名, 文本型, , 要写出的文件名

    .如果真 (取读写位置 (_文件句柄) ≠ 0)
        移到文件首 (_文件句柄)
    .如果真结束
    返回 (写到文件 (参_文件名, 读入字节集 (_文件句柄, 取文件长度 (_文件句柄))))

.子程序 删全部空格, 逻辑型, 公开, 删除所有中英文空格
    .局部变量 局_计数器, 整数型
    .局部变量 局_缓冲区长度, 整数型

    写缓存区 ()
    局_缓冲区长度 ＝ 取字节集长度 (集_缓冲区)
    清空内容 ()
    局_计数器 ＝ 1
    .判断循环首 (局_缓冲区长度 ＞ 局_计数器)
        .判断开始 (集_缓冲区 [局_计数器] ＝ 32)
            局_计数器 ＝ 局_计数器 ＋ 1
            到循环尾 ()
        .判断 (集_缓冲区 [局_计数器] ＝ 161 且 集_缓冲区 [局_计数器 ＋ 1] ＝ 161)
            局_计数器 ＝ 局_计数器 ＋ 2
            到循环尾 ()
        .默认
            写出字节集 (_文件句柄, 到字节集 (集_缓冲区 [局_计数器]))
            局_计数器 ＝ 局_计数器 ＋ 1
        .判断结束
        
    .判断循环尾 ()
    .如果 (取长度 () ＝ 0)
        返回 (假)
    .否则
        返回 (真)
    .如果结束
    

.子程序 写缓存区
    .如果真 (取读写位置 (_文件句柄) ≠ 0)
        移到文件首 (_文件句柄)
    .如果真结束
    集_缓冲区 ＝ 读入字节集 (_文件句柄, 取文件长度 (_文件句柄))

.子程序 删首尾空格, 逻辑型, 公开
    .局部变量 局_计数器, 整数型
    .局部变量 局_缓冲区长度, 整数型
    .局部变量 局_偏移1, 整数型

    写缓存区 ()
    局_缓冲区长度 ＝ 取字节集长度 (集_缓冲区)
    清空内容 ()
    局_计数器 ＝ 1
    .判断循环首 (局_缓冲区长度 ＞ 局_计数器)
        .判断开始 (集_缓冲区 [局_计数器] ＝ 32)
            局_计数器 ＝ 局_计数器 ＋ 1
            到循环尾 ()
        .判断 (集_缓冲区 [局_计数器] ＝ 161 且 集_缓冲区 [局_计数器 ＋ 1] ＝ 161)
            局_计数器 ＝ 局_计数器 ＋ 2
            到循环尾 ()
        .默认
            跳出循环 ()
        .判断结束
        
    .判断循环尾 ()
    局_偏移1 ＝ 局_计数器
    局_计数器 ＝ 局_缓冲区长度
    .判断循环首 (局_计数器 ＞ 1)
        .判断开始 (集_缓冲区 [局_计数器] ＝ 32)
            局_计数器 ＝ 局_计数器 － 1
            到循环尾 ()
        .判断 (集_缓冲区 [局_计数器] ＝ 161 且 集_缓冲区 [局_计数器 － 1] ＝ 161)
            局_计数器 ＝ 局_计数器 － 2
            到循环尾 ()
        .默认
            跳出循环 ()
        .判断结束
        
    .判断循环尾 ()
    返回 (写出字节集 (_文件句柄, 取字节集中间 (集_缓冲区, 局_偏移1, 局_计数器 － 局_偏移1 ＋ 1)))

.子程序 删首空格, 逻辑型, 公开
    .局部变量 局_计数器, 整数型
    .局部变量 局_缓冲区长度, 整数型

    写缓存区 ()
    局_缓冲区长度 ＝ 取字节集长度 (集_缓冲区)
    清空内容 ()
    局_计数器 ＝ 1
    .判断循环首 (局_缓冲区长度 ＞ 局_计数器)
        .判断开始 (集_缓冲区 [局_计数器] ＝ 32)
            局_计数器 ＝ 局_计数器 ＋ 1
            到循环尾 ()
        .判断 (集_缓冲区 [局_计数器] ＝ 161 且 集_缓冲区 [局_计数器 ＋ 1] ＝ 161)
            局_计数器 ＝ 局_计数器 ＋ 2
            到循环尾 ()
        .默认
            跳出循环 ()
        .判断结束
        
    .判断循环尾 ()
    返回 (写出字节集 (_文件句柄, 取字节集右边 (集_缓冲区, 局_缓冲区长度 － 局_计数器 ＋ 1)))

.子程序 删尾空格, 逻辑型, 公开
    .局部变量 局_计数器, 整数型
    .局部变量 局_缓冲区长度, 整数型

    写缓存区 ()
    局_缓冲区长度 ＝ 取字节集长度 (集_缓冲区)
    清空内容 ()
    局_计数器 ＝ 局_缓冲区长度
    .判断循环首 (局_计数器 ＞ 1)
        .判断开始 (集_缓冲区 [局_计数器] ＝ 32)
            局_计数器 ＝ 局_计数器 － 1
            到循环尾 ()
        .判断 (集_缓冲区 [局_计数器] ＝ 161 且 集_缓冲区 [局_计数器 － 1] ＝ 161)
            局_计数器 ＝ 局_计数器 － 2
            到循环尾 ()
        .默认
            跳出循环 ()
        .判断结束
        
    .判断循环尾 ()
    返回 (写出字节集 (_文件句柄, 取字节集左边 (集_缓冲区, 局_计数器)))

.子程序 到小写字母, 逻辑型, 公开
    .参数 参_起始位置, 整数型, 可空
    .参数 参_转换字母数, 整数型, 可空
    .局部变量 局_缓冲区长度, 整数型
    .局部变量 局_偏移, 整数型

    写缓存区 ()
    局_缓冲区长度 ＝ 取字节集长度 (集_缓冲区)
    清空内容 ()
    局_偏移 ＝ 1
    .如果真 (是否为空 (参_起始位置))
        参_起始位置 ＝ 1
    .如果真结束
    .如果真 (是否为空 (参_转换字母数))
        参_转换字母数 ＝ 汇编_取字数 (集_缓冲区) － 字数到位置 (参_起始位置)
    .如果真结束
    局_偏移 ＝ 字数到位置 (参_起始位置)
    .计次循环首 (参_转换字母数, )
        .如果真 (局_偏移 ＞ 局_缓冲区长度)
            跳出循环 ()
        .如果真结束
        .如果 (集_缓冲区 [局_偏移] ＞ 128)
            局_偏移 ＝ 局_偏移 ＋ 2
        .否则
            .如果真 (集_缓冲区 [局_偏移] ＞ 64 且 集_缓冲区 [局_偏移] ＜ 91)
                集_缓冲区 [局_偏移] ＝ 位或 (集_缓冲区 [局_偏移], 32)
            .如果真结束
            局_偏移 ＝ 局_偏移 ＋ 1
        .如果结束
        
    .计次循环尾 ()
    返回 (写出字节集 (_文件句柄, 集_缓冲区))

.子程序 到大写字母, 逻辑型, 公开
    .参数 参_起始位置, 整数型, 可空
    .参数 参_转换字母数, 整数型, 可空
    .局部变量 局_缓冲区长度, 整数型
    .局部变量 局_偏移, 整数型

    写缓存区 ()
    局_缓冲区长度 ＝ 取字节集长度 (集_缓冲区)
    清空内容 ()
    局_偏移 ＝ 1
    .如果真 (是否为空 (参_起始位置))
        参_起始位置 ＝ 1
    .如果真结束
    .如果真 (是否为空 (参_转换字母数))
        参_转换字母数 ＝ 汇编_取字数 (集_缓冲区) － 字数到位置 (参_起始位置)
    .如果真结束
    局_偏移 ＝ 字数到位置 (参_起始位置)
    .计次循环首 (参_转换字母数, )
        .如果真 (局_偏移 ＞ 局_缓冲区长度)
            跳出循环 ()
        .如果真结束
        .如果 (集_缓冲区 [局_偏移] ＞ 128)
            局_偏移 ＝ 局_偏移 ＋ 2
        .否则
            .如果真 (集_缓冲区 [局_偏移] ＞ 96 且 集_缓冲区 [局_偏移] ＜ 123)
                集_缓冲区 [局_偏移] ＝ 位与 (集_缓冲区 [局_偏移], 95)
            .如果真结束
            局_偏移 ＝ 局_偏移 ＋ 1
        .如果结束
        
    .计次循环尾 ()
    返回 (写出字节集 (_文件句柄, 集_缓冲区))

.子程序 字数到位置, 整数型
    .参数 参_字数, 整数型
    .局部变量 局_偏移, 整数型
    .局部变量 局_缓冲区长度, 整数型

    局_缓冲区长度 ＝ 取字节集长度 (集_缓冲区)
    局_偏移 ＝ 1
    .计次循环首 (参_字数 － 1, )
        .如果真 (局_偏移 ＞ 局_缓冲区长度)
            跳出循环 ()
        .如果真结束
        .如果 (集_缓冲区 [局_偏移] ＞ 128)
            局_偏移 ＝ 局_偏移 ＋ 2
        .否则
            局_偏移 ＝ 局_偏移 ＋ 1
        .如果结束
        
    .计次循环尾 ()
    返回 (局_偏移)
    

.版本 2

.程序集 集_字节集
.子程序 字节集_字节集转文本, 文本型, 公开, 以文本表示字节集，适合于字节集的调试用,查看字节集可以将一串字节集用文本形式表示出来，极大地方便了调试字节集变量。感谢易友[缘诚]提供优化查看速度方案
    .参数 原始字节集, 字节集, , 要查看的字节集
    .局部变量 局_文件句柄, 整数型
    .局部变量 局_字节集长度, 整数型
    .局部变量 局_i, 整数型
    .局部变量 局_文本, 文本型

    局_文件句柄 ＝ 打开内存文件 ()
    局_字节集长度 ＝ 取字节集长度 (原始字节集)
    .计次循环首 (局_字节集长度, 局_i)
        插入文本 (局_文件句柄, 到文本 (原始字节集 [局_i]) ＋ “,”)
        处理事件 ()
    .计次循环尾 ()
    移到文件首 (局_文件句柄)
    局_文本 ＝ “{” ＋ 读入文本 (局_文件句柄, )
    关闭文件 (局_文件句柄)
    .如果 (取文本右边 (局_文本, 1) ＝ “,”)
        局_文本 ＝ 取文本左边 (局_文本, 取文本长度 (局_文本) － 1) ＋ “}”
    .否则
        局_文本 ＝ 局_文本 ＋ “}”
    .如果结束
    
    返回 (局_文本)
    
    

.子程序 字节集_字节集转文本ex, 文本型, 公开, 感谢【@贫民窟 】提供源码
    .参数 字节集, 字节集
    .局部变量 长度, 整数型
    .局部变量 缓冲区, 字节集
    .局部变量 缓冲区索引, 整数型
    .局部变量 i, 整数型
    .局部变量 字节, 字节型
    .局部变量 字节1, 字节型
    .局部变量 字节2, 字节型
    .局部变量 字节3, 字节型

    长度 ＝ 取字节集长度 (字节集)
    .如果真 (长度 ＝ 0)
        返回 (“”)
    .如果真结束
    
    缓冲区 ＝ 取空白字节集 (长度 × 4 ＋ 2)
    缓冲区 [1] ＝ 123
    缓冲区索引 ＝ 1
    
    .计次循环首 (长度, i)
        字节 ＝ 字节集 [i]
        缓冲区索引 ＝ 缓冲区索引 ＋ 1
        
        字节1 ＝ 字节 ＼ 100
        字节 ＝ 字节 － 字节1 × 100
        
        字节2 ＝ 字节 ＼ 10
        
        字节 ＝ 字节 － 字节2 × 10
        
        .判断开始 (字节1 ＞ 0)
            缓冲区 [缓冲区索引] ＝ 字节1 ＋ 48
            缓冲区索引 ＝ 缓冲区索引 ＋ 1
            缓冲区 [缓冲区索引] ＝ 字节2 ＋ 48
            缓冲区索引 ＝ 缓冲区索引 ＋ 1
        .默认
            .如果真 (字节2 ＞ 0)
                缓冲区 [缓冲区索引] ＝ 字节2 ＋ 48
                缓冲区索引 ＝ 缓冲区索引 ＋ 1
            .如果真结束
            
        .判断结束
        
        缓冲区 [缓冲区索引] ＝ 字节 ＋ 48
        .判断开始 (长度 ＝ i)
            缓冲区 [缓冲区索引 ＋ 1] ＝ 125
            
        .默认
            缓冲区索引 ＝ 缓冲区索引 ＋ 1
            缓冲区 [缓冲区索引] ＝ 44
        .判断结束
        
    .计次循环尾 ()
    返回 (到文本 (缓冲区))

.子程序 字节集_文本转字节集ex, 字节集, 公开, 感谢【@贫民窟 】提供源码
    .参数 参_文本, 文本型
    .局部变量 局_缓冲区, 字节集
    .局部变量 局_缓冲区索引, 整数型
    .局部变量 局_数字缓冲区, 字节集
    .局部变量 局_数字缓冲索引, 整数型
    .局部变量 局_字节集, 字节集
    .局部变量 局_长度, 整数型
    .局部变量 i, 整数型
    .局部变量 局_字节, 字节型
    .局部变量 局_插入逻辑, 逻辑型
    .局部变量 局_位数, 整数型
    .局部变量 局_文本, 文本型

    局_文本 ＝ 参_文本
    
    .如果真 (取文本左边 (局_文本, 1) ≠ “{”)
        局_文本 ＝ “{” ＋ 局_文本
    .如果真结束
    
    .如果真 (取文本右边 (局_文本, 1) ≠ “}”)
        局_文本 ＝ 局_文本 ＋ “}”
    .如果真结束
    
    局_字节集 ＝ 到字节集 (删全部空 (局_文本))
    局_长度 ＝ 取字节集长度 (局_字节集)
    .如果真 (局_长度 ＜ 1)
        返回 ({ })
    .如果真结束
    
    局_缓冲区 ＝ 取空白字节集 (局_长度)
    局_缓冲区索引 ＝ 1
    局_数字缓冲区 ＝ { 0, 0, 0 }
    局_数字缓冲索引 ＝ 1
    .计次循环首 (局_长度, i)
        局_字节 ＝ 局_字节集 [i]
        .判断开始 (局_字节 ＞ 47 且 局_字节 ＜ 58) ' 数字。
            .如果真 (局_数字缓冲索引 ＞ 3)
                信息框 (“error”, 0, )
                返回 ({ })
            .如果真结束
            局_数字缓冲区 [局_数字缓冲索引] ＝ 局_字节 － 48
            局_数字缓冲索引 ＝ 局_数字缓冲索引 ＋ 1
            局_插入逻辑 ＝ 真
            局_位数 ＝ 局_位数 ＋ 1
            
        .默认
            
            .如果真 (局_插入逻辑)
                局_插入逻辑 ＝ 假
                .判断开始 (局_位数 ＝ 1)
                    局_字节 ＝ 局_数字缓冲区 [1]
                .判断 (局_位数 ＝ 2)
                    局_字节 ＝ 局_数字缓冲区 [1] × 10 ＋ 局_数字缓冲区 [2]
                .默认
                    局_字节 ＝ 局_数字缓冲区 [1] × 100 ＋ 局_数字缓冲区 [2] × 10 ＋ 局_数字缓冲区 [3]
                .判断结束
                局_缓冲区 [局_缓冲区索引] ＝ 局_字节
                局_缓冲区索引 ＝ 局_缓冲区索引 ＋ 1
                局_数字缓冲区 [1] ＝ 0
                局_数字缓冲区 [2] ＝ 0
                局_数字缓冲区 [3] ＝ 0
                局_数字缓冲索引 ＝ 1
                局_位数 ＝ 0
            .如果真结束
            
        .判断结束
        
    .计次循环尾 ()
    返回 (取字节集左边 (局_缓冲区, 局_缓冲区索引 － 1))

.子程序 字节集_文本转字节集, 字节集, 公开, 将“字节集_字节集转文本”得到的文本字节集重新转换为字节集。感谢【御风软件】提供代码
    .参数 文本字节集, 文本型
    .局部变量 N, 整数型
    .局部变量 文本数组, 文本型, , "0"
    .局部变量 字节长度, 整数型
    .局部变量 新字节集, 字节集

    文本数组 ＝ 分割文本 (取文本中间 (文本字节集, 2, 取文本长度 (文本字节集) － 1), “,”, )
    字节长度 ＝ 取数组成员数 (文本数组)
    新字节集 ＝ 取空白字节集 (字节长度)
    .计次循环首 (字节长度, N)
        新字节集 [N] ＝ 到字节 (文本数组 [N])
    .计次循环尾 ()
    返回 (新字节集)

.子程序 字节集_十六进制到字节集, 字节集, 公开, 将一串十六进制文本还原为字节集。还原为字节集可以将默认的16进制文本转换成字节集。如“00BFAD00”可还原为{0,191,173,0}
    .参数 原始16进制文本, 文本型, , 如“00BFAD00AFD4FD4F9E054F9FF91FC5FF2076FBAFDB071044”
    .局部变量 ptr, 整数型
    .局部变量 dwLen, 整数型
    .局部变量 pszBuf, 整数型
    .局部变量 szBuf, 字节集
    .局部变量 wBit, 短整数型
    .局部变量 cBuf, 字节型
    .局部变量 i, 整数型
    .局部变量 n, 整数型

    ptr ＝ 取指针_文本型 (原始16进制文本)
    dwLen ＝ 取文本长度 (原始16进制文本)
    pszBuf ＝ LocalAlloc (#LMEM_ZEROINIT, dwLen ＋ 1)
    .变量循环首 (0, dwLen － 2, 2, i)
        wBit ＝ 指针_到短整数型_汇编 (ptr ＋ i)
        .如果 (sscanf (取指针地址_短整数型 (wBit), “%x”, cBuf) ＞ 0)
            __set_byte (pszBuf, n, cBuf)
            n ＝ n ＋ 1
        .否则
            ' 一般不可能执行到这里！如果执行到这里，说明用户传入的十六进制文本有问题！
            ' __set_short (pszBuf, n, wBit)
            ' n ＝ n ＋ 2
        .如果结束
        
    .变量循环尾 ()
    szBuf ＝ 指针到字节集 (pszBuf, n)
    LocalFree (pszBuf)
    返回 (szBuf)

.子程序 字节集_字节集到十六进制, 文本型, 公开, 将字节集用16进制表示.可以将字节集用系统标准16进制表示
    .参数 原始字节集, 字节集, , 用于转换的字节集
    .局部变量 pszBuf, 整数型
    .局部变量 szBuf, 文本型
    .局部变量 dwBufLen, 整数型
    .局部变量 i, 整数型
    .局部变量 n, 整数型

    dwBufLen ＝ 取字节集长度 (原始字节集)
    pszBuf ＝ LocalAlloc (#LMEM_ZEROINIT, dwBufLen × 2 ＋ 1)
    .计次循环首 (dwBufLen, i)
        n ＝ n ＋ sprintf (pszBuf ＋ n, “%02X”, 原始字节集 [i])
    .计次循环尾 ()
    szBuf ＝ 指针到文本 (pszBuf)
    LocalFree (pszBuf)
    返回 (szBuf)

.子程序 字节集_十六进制到字节集2, 字节集, 公开, 将一串十六进制文本还原为字节集。还原为字节集可以将默认的16进制文本转换成字节集。如“00BFAD00”可还原为{0,191,173,0}
    .参数 原始16进制文本, 文本型, , 如“00BFAD00AFD4FD4F9E054F9FF91FC5FF2076FBAFDB071044”
    .局部变量 bytes, 字节集
    .局部变量 bytes_ret, 字节集
    .局部变量 len, 整数型
    .局部变量 p1, 整数型
    .局部变量 i, 整数型
    .局部变量 byte1, 整数型
    .局部变量 byte2, 整数型

    ' https://bbs.125.la/forum.php?mod=viewthread&tid=14653144
    bytes ＝ 到字节集 (原始16进制文本)
    len ＝ 取字节集长度 (bytes)
    .如果真 (位与 (len, 1) ＝ 1)
        bytes ＝ bytes ＋ 取空白字节集 (1)
        len ＝ len ＋ 1
        bytes [len] ＝ bytes [len － 1]
        bytes [len － 1] ＝ 48
    .如果真结束
    bytes_ret ＝ 取空白字节集 (右移 (len, 1))
    .变量循环首 (1, len, 2, p1)
        i ＝ i ＋ 1
        byte1 ＝ bytes [p1]
        byte2 ＝ bytes [p1 ＋ 1]
        .判断开始 (byte1 ＞ 96)
            byte1 ＝ byte1 － 87
        .判断 (byte1 ＞ 64)
            byte1 ＝ byte1 － 55
        .默认
            byte1 ＝ byte1 － 48
        .判断结束
        .判断开始 (byte2 ＞ 96)
            byte2 ＝ byte2 － 87
        .判断 (byte2 ＞ 64)
            byte2 ＝ byte2 － 55
        .默认
            byte2 ＝ byte2 － 48
        .判断结束
        bytes_ret [i] ＝ 左移 (byte1, 4) ＋ byte2
    .变量循环尾 ()
    返回 (bytes_ret)

.子程序 字节集_字节集到十六进制2, 文本型, 公开, 将字节集用16进制表示.可以将字节集用系统标准16进制表示
    .参数 原始字节集, 字节集, , 用于转换的字节集
    .局部变量 len, 整数型
    .局部变量 byte, 整数型
    .局部变量 high, 整数型
    .局部变量 low, 整数型
    .局部变量 ret, 字节集
    .局部变量 len_ret, 整数型
    .局部变量 i, 整数型
    .局部变量 j, 整数型

    len ＝ 取字节集长度 (原始字节集)
    len_ret ＝ len × 2
    ' ret ＝ 取重复字节集 (len_ret, { 48 })
    ret ＝ 取空白字节集 (len_ret ＋ 1)
    .变量循环首 (1, len_ret, 2, j)
        i ＝ i ＋ 1
        byte ＝ 原始字节集 [i]
        .如果 (byte ＞ 15)
            high ＝ 位与 (右移 (byte, 4), 15)
            .如果 (high ＞ 9)
                ret [j] ＝ high ＋ 55
            .否则
                ret [j] ＝ high ＋ 48
            .如果结束
            
        .否则
            ret [j] ＝ 48
        .如果结束
        low ＝ 位与 (byte, 15)
        .如果 (low ＞ 9)
            ret [j ＋ 1] ＝ low ＋ 55
        .否则
            ret [j ＋ 1] ＝ low ＋ 48
        .如果结束
        
    .变量循环尾 ()
    返回 (到文本 (ret))

.子程序 到十六进制, 文本型, , 返回转换后的十六进制文本
    .参数 十进制数据, 整数型, , 传入十进制整型数据
    .局部变量 局部_结果, 文本型

    局部_结果 ＝ 取十六进制文本 (十进制数据)
    .如果真 (取文本长度 (局部_结果) ％ 2 ＝ 1)
        返回 (“0” ＋ 局部_结果)
    .如果真结束
    返回 (局部_结果)

.子程序 字节集_寻找取左, 字节集, 公开, 从字节集的左边按 欲寻找的字节集 开始寻找 如 字节集_取左边({105,108,121,13,10,83,101},{13,10}) 将返回 {105,108,121}
    .参数 被查找的字节集, 字节集, , 被查找的字节集
    .参数 欲寻找的字节集, 字节集, , 欲寻找的字节集
    .参数 起始寻找位置, 整数型, 可空, 可为空，默认为1，从左往右寻找，如果为负数，则从右往左寻找。
    .局部变量 局_长度, 整数型
    .局部变量 局_起始搜寻位置, 整数型
    .局部变量 局_方向, 整数型
    .局部变量 局_找到的位置, 整数型
    .局部变量 局_返回结果, 字节集

    局_长度 ＝ 取字节集长度 (被查找的字节集)
    
    局_起始搜寻位置 ＝ 起始寻找位置
    .如果真 (局_起始搜寻位置 ＜ 0)
        局_起始搜寻位置 ＝ 局_起始搜寻位置 × -1
        .如果真 (局_起始搜寻位置 ＝ 1)
            局_起始搜寻位置 ＝ 0
        .如果真结束
        局_方向 ＝ 1
    .如果真结束
    
    .如果 (局_方向 ＝ 1)
        局_找到的位置 ＝ 倒找字节集 (被查找的字节集, 欲寻找的字节集, 局_长度 － 局_起始搜寻位置)
    .否则
        .如果真 (局_起始搜寻位置 ＝ 0)
            局_起始搜寻位置 ＝ 1
        .如果真结束
        局_找到的位置 ＝ 寻找字节集 (被查找的字节集, 欲寻找的字节集, 局_起始搜寻位置)
    .如果结束
    
    .如果真 (局_找到的位置 ＝ -1)
        返回 ({ })
    .如果真结束
    
    局_返回结果 ＝ 取字节集左边 (被查找的字节集, 局_找到的位置 － 1)
    返回 (局_返回结果)

.子程序 字节集_寻找取右, 字节集, 公开, 从字节集的右边按 欲寻找的字节集 开始寻找  如 字节集_取右边({105,108,121,13,10,83,101},{13,10}) 将返回 {83,101}
    .参数 被查找的字节集, 字节集, , 被查找的字节集
    .参数 欲寻找的字节集, 字节集, , 欲寻找的字节集
    .参数 起始寻找位置, 整数型, 可空, 可为空，默认为1，从左往右寻找，如果为负数，则从右往左寻找。
    .局部变量 局_长度, 整数型
    .局部变量 局_起始搜寻位置, 整数型
    .局部变量 局_方向, 整数型
    .局部变量 局_找到的位置, 整数型
    .局部变量 局_返回结果, 字节集

    局_长度 ＝ 取字节集长度 (被查找的字节集)
    
    局_起始搜寻位置 ＝ 起始寻找位置
    .如果真 (局_起始搜寻位置 ＜ 0)
        局_起始搜寻位置 ＝ 局_起始搜寻位置 × -1
        .如果真 (局_起始搜寻位置 ＝ 1)
            局_起始搜寻位置 ＝ 0
        .如果真结束
        局_方向 ＝ 1
    .如果真结束
    
    .如果 (局_方向 ＝ 1)
        局_找到的位置 ＝ 倒找字节集 (被查找的字节集, 欲寻找的字节集, 局_长度 － 局_起始搜寻位置)
    .否则
        .如果真 (局_起始搜寻位置 ＝ 0)
            局_起始搜寻位置 ＝ 1
        .如果真结束
        局_找到的位置 ＝ 寻找字节集 (被查找的字节集, 欲寻找的字节集, 局_起始搜寻位置)
    .如果结束
    
    .如果真 (局_找到的位置 ＝ -1)
        返回 ({ })
    .如果真结束
    
    局_返回结果 ＝ 取字节集右边 (被查找的字节集, 局_长度 － 取字节集长度 (欲寻找的字节集) － 局_找到的位置 ＋ 1)
    返回 (局_返回结果)

.子程序 字节集_寻找取中, 字节集, 公开
    .参数 要操作的字节集, 字节集
    .参数 前面字节集, 字节集
    .参数 后面字节集, 字节集
    .参数 起始搜寻位置, 整数型, 可空, 可空。1为首位置，2为第2个位置，如此类推，如果被省略，则“寻找字节集”命令默认从首部开始，“倒找字节集”命令默认从尾部开始。
    .局部变量 局_字节集, 字节集
    .局部变量 局_位置, 整数型

    局_位置 ＝ 寻找字节集 (要操作的字节集, 前面字节集, 起始搜寻位置)
    .如果真 (局_位置 ＝ -1)
        返回 ({ })
    .如果真结束
    局_字节集 ＝ 取字节集右边 (要操作的字节集, 取字节集长度 (要操作的字节集) － 局_位置 － 取字节集长度 (前面字节集) ＋ 1)
    局_位置 ＝ 寻找字节集 (局_字节集, 后面字节集, )
    .如果真 (局_位置 ＝ -1)
        返回 ({ })
    .如果真结束
    局_字节集 ＝ 取字节集左边 (局_字节集, 局_位置 － 1)
    返回 (局_字节集)

.子程序 字节集_到文本, 文本型, 公开
    .参数 字节集, 字节集
    .局部变量 返回值, 文本型
    .局部变量 Temp, 字节集

    Temp ＝ 字节集 ＋ { 0 }
    返回 (指针到文本 (字节集_取指针 (Temp)))

.子程序 字节集_到整数, 整数型, 公开
    .参数 字节集, 字节集
    .参数 位置, 整数型, 可空, 默认为1
    .局部变量 返回值, 整数型
    .局部变量 Address, 整数型
    .局部变量 Len, 整数型

    Address ＝ 字节集_取指针 (字节集)
    Len ＝ 字节集_取长度 (字节集)
    .如果真 (是否为空 (位置) ＝ 真)
        位置 ＝ 1
    .如果真结束
    .如果真 (位置 ＞ Len 或 位置 ＜ 1)
        返回 (0)
    .如果真结束
    .如果 (Len － 位置 ＜ 4)
        RtlMoveMemory_整数传址1 (返回值, Address ＋ 位置 － 1, Len － 位置 ＋ 1)
    .否则
        RtlMoveMemory_整数传址1 (返回值, Address ＋ 位置 － 1, 4)
    .如果结束
    返回 (返回值)

.子程序 整数型_到文本, 文本型
    .参数 整数, 整数型
    .局部变量 返回值, 文本型
    .局部变量 参数, 整数型, , "1"

    返回值 ＝ 文本型_取空白 (4)
    参数 [1] ＝ 整数
    wsprintfA (返回值, “%d”, 参数)
    返回 (返回值)

.子程序 字节集_取左边, 字节集, 公开
    .参数 字节集, 字节集
    .参数 欲取出字节的数目, 整数型
    .局部变量 Len, 整数型
    .局部变量 Address, 整数型

    Len ＝ 字节集_取长度 (字节集)
    .如果真 (Len ＜ 1)
        返回 ({ })
    .如果真结束
    .判断开始 (欲取出字节的数目 ＜ 1)
        返回 ({ })
    .判断 (欲取出字节的数目 ＞ Len)
        欲取出字节的数目 ＝ Len
    .默认
        
    .判断结束
    Address ＝ 字节集_取指针 (字节集)
    返回 (指针到字节集 (Address, 欲取出字节的数目))

.子程序 字节集_取右边, 字节集, 公开
    .参数 字节集, 字节集
    .参数 欲取出字节的数目, 整数型
    .局部变量 Len, 整数型
    .局部变量 Address, 整数型

    Len ＝ 字节集_取长度 (字节集)
    .如果真 (Len ＜ 1)
        返回 ({ })
    .如果真结束
    .判断开始 (欲取出字节的数目 ＜ 1)
        返回 ({ })
    .判断 (欲取出字节的数目 ＞ Len)
        欲取出字节的数目 ＝ Len
    .默认
        
    .判断结束
    Address ＝ 字节集_取指针 (字节集) ＋ Len － 欲取出字节的数目
    返回 (指针到字节集 (Address, 欲取出字节的数目))

.子程序 字节集_取空白, 字节集, 公开
    .参数 零字节数目, 整数型
    .局部变量 Address, 整数型
    .局部变量 返回值, 字节集

    .如果真 (零字节数目 ＜ 1)
        返回 ({ })
    .如果真结束
    Address ＝ LocalAlloc (64, 零字节数目)
    .如果真 (Address ＝ 0)
        返回 ({ })
    .如果真结束
    返回值 ＝ 指针到字节集 (Address, 零字节数目)
    LocalFree (Address)
    返回 (返回值)

.子程序 字节集_取长度, 整数型, 公开
    .参数 字节集, 字节集
    .局部变量 返回值, 整数型
    .局部变量 Address, 整数型

    .如果真 (字节集 ＝ { })
        返回 (0)
    .如果真结束
    
    置入代码 ({ 139, 93, 8, 139, 27, 139, 91, 4, 137, 93, 252 }) ' 取字节集长度
    ' Address ＝ 字节集_取指针 (字节集)
    ' RtlMoveMemory_Int (返回值, Address － 4, 4)
    返回 (返回值)

.子程序 字节集_取指定位置字节集, 字节集, 公开
    .参数 字节集, 字节集
    .参数 起始取出位置, 整数型
    .参数 欲取出字节的数目, 整数型
    .局部变量 Len, 整数型
    .局部变量 Address, 整数型

    Len ＝ 字节集_取长度 (字节集)
    .如果真 (Len ＜ 1)
        返回 ({ })
    .如果真结束
    .判断开始 (起始取出位置 ＜ 1)
        起始取出位置 ＝ 1
    .判断 (起始取出位置 ＞ Len)
        返回 ({ })
    .默认
        
    .判断结束
    .如果真 (欲取出字节的数目 ＜ 1)
        返回 ({ })
    .如果真结束
    .如果真 (欲取出字节的数目 ＋ 起始取出位置 － 1 ＞ Len)
        欲取出字节的数目 ＝ Len － 起始取出位置 ＋ 1
    .如果真结束
    Address ＝ 字节集_取指针 (字节集) ＋ 起始取出位置 － 1
    返回 (指针到字节集 (Address, 欲取出字节的数目))

.子程序 字节集_取中间, 字节集, 公开, 取指定字节集中 指定前后字节集中间的数据，用法与”文本_取出中间文本“类似
    .参数 要操作的字节集, 字节集
    .参数 前面字节集, 字节集
    .参数 后面字节集, 字节集
    .参数 起始搜寻位置, 整数型, 可空, 可空。1为首位置，2为第2个位置，如此类推，如果被省略，则“寻找字节集”命令默认从首部开始，“倒找字节集”命令默认从尾部开始。
    .局部变量 局_字节集, 字节集
    .局部变量 局_位置, 整数型

    局_位置 ＝ 寻找字节集 (要操作的字节集, 前面字节集, 起始搜寻位置)
    .如果真 (局_位置 ＝ -1)
        返回 ({ })
    .如果真结束
    局_字节集 ＝ 取字节集右边 (要操作的字节集, 取字节集长度 (要操作的字节集) － 局_位置 － 取字节集长度 (前面字节集) ＋ 1)
    局_位置 ＝ 寻找字节集 (局_字节集, 后面字节集, 起始搜寻位置)
    .如果真 (局_位置 ＝ -1)
        返回 ({ })
    .如果真结束
    局_字节集 ＝ 取字节集左边 (局_字节集, 局_位置 － 1)
    返回 (局_字节集)
    
    ' 文本_取出中间文本 ()
    ' 子程序名：文本_取出中间文本
    ' 比如：欲取全文本为“12345”,现在要取出“3”，<3>的前面为“2”，<3>的后面为“4”，
    ' 返回值类型：文本型
    ' 参数<1>的名称为“欲取全文本”，类型为“文本型”。注明：比如：欲取全文本为 12345。
    ' 参数<2>的名称为“前面文本”，类型为“文本型”。注明：3的前面为“2”，引号直接用 #引号，如："<font color=#引号red#引号>"。
    ' 参数<3>的名称为“后面文本”，类型为“文本型”。注明：3的后面为“4”，引号直接用 #引号，如："<font color=#引号red#引号>"。
    

.子程序 字节集_替换, 字节集, 公开, 将指定字节集的某一部分用其它的字节集替换,然后返回替换后的结果.
    .参数 欲替换其部分的字节集, 字节集
    .参数 起始替换位置, 整数型, , 替换的起始位置,1为首位置,2为第2个位置,如此类推.
    .参数 替换长度, 整数型
    .参数 用作替换的字节集, 字节集, 可空, 可以被省略.如果本参数被省略,则删除字节集中的指定部分.
    .局部变量 Len_X, 整数型
    .局部变量 Temp1, 字节集
    .局部变量 Temp2, 字节集

    .如果真 (欲替换其部分的字节集 ＝ { })
        返回 ({ })
    .如果真结束
    .如果真 (替换长度 ＜ 1)
        返回 (欲替换其部分的字节集)
    .如果真结束
    Len_X ＝ 字节集_取长度 (欲替换其部分的字节集)
    .如果真 (起始替换位置 ＜ 1)
        起始替换位置 ＝ 1
    .如果真结束
    .如果真 (起始替换位置 ＞ Len_X)
        返回 (欲替换其部分的字节集)
    .如果真结束
    Temp1 ＝ 字节集_取左边 (欲替换其部分的字节集, 起始替换位置 － 1)
    Temp2 ＝ 字节集_取右边 (欲替换其部分的字节集, Len_X － (起始替换位置 ＋ 替换长度) ＋ 1)
    返回 (Temp1 ＋ 用作替换的字节集 ＋ Temp2)

.子程序 字节集_寻找, 整数型, 公开, 返回一字节集在另一字节集中最先出现的位置,位置值从 1 开始.如果未找到,返回 -1.
    .参数 被搜寻的字节集, 字节集
    .参数 欲寻找的字节集, 字节集
    .参数 起始搜寻位置, 整数型, 可空, 1为首位置,2为第2个位置,如此类推,如果被省略,则“寻找字节集”命令默认从首部开始,“倒找字节集”命令默认从尾部开始.

    置入代码 ({ 83, 82, 86, 87, 139, 125, 8, 139, 63, 133, 255, 116, 119, 139, 95, 4, 131, 251, 0, 126, 111, 141, 87, 8, 139, 117, 12, 139, 54, 133, 246, 116, 99, 139, 78, 4, 131, 249, 0, 126, 91, 141, 70, 8, 137, 69, 244, 139, 69, 16, 72, 131, 248, 0, 125, 2, 49, 192, 137, 69, 16, 41, 195, 57, 217, 127, 65, 73, 137, 77, 248, 41, 203, 137, 93, 252, 1, 194, 139, 117, 244, 137, 215, 137, 217, 138, 38, 70, 227, 42, 138, 7, 71, 73, 48, 224, 117, 246, 137, 250, 137, 203, 139, 77, 248, 227, 15, 138, 38, 138, 7, 70, 71, 48, 224, 117, 217, 73, 227, 2, 235, 241, 139, 69, 16, 3, 69, 252, 41, 216, 235, 3, 131, 200, 255, 95, 94, 90, 91, 131, 196, 12, 137, 236, 93, 194, 16, 0 })
    返回 (0)

.子程序 字节集_取指针, 整数型, 公开
    .参数 字节集, 字节集

    返回 (lstrcpyn_字节集 (字节集, 字节集, 0))

.子程序 字节集_子替换, 字节集, 公开, 将所有的预被替换的字节集用 用作替换的子字节集 替换
    .参数 欲被替换的字节集, 字节集
    .参数 欲被替换的子字节集, 字节集
    .参数 用作替换的子字节集, 字节集, 可空, 可以被省略。如果省略本参数，则默认为空字节集。
    .参数 进行替换的起始位置, 整数型, 可空, 可以被省略。被替换子字节集的起始搜索位置。如果省略，默认从1开始。
    .参数 替换进行的次数, 整数型, 可空, 可以被省略。对子字节集进行替换的次数。如果省略，默认进行所有可能的替换。
    .局部变量 offset, 整数型, , "0"
    .局部变量 count, 整数型
    .局部变量 i, 整数型
    .局部变量 ret, 字节集
    .局部变量 len, 整数型
    .局部变量 偏移, 整数型

    .如果真 (欲被替换的字节集 ＝ { } 或 欲被替换的子字节集 ＝ { })
        返回 ({ })
    .如果真结束
    .如果真 (是否为空 (进行替换的起始位置))
        进行替换的起始位置 ＝ 1
    .如果真结束
    count ＝ 字节集_寻找子 (欲被替换的字节集, 欲被替换的子字节集, offset, 进行替换的起始位置)
    .如果真 (count ＝ 0)
        返回 (欲被替换的字节集)
    .如果真结束
    .如果真 (是否为空 (替换进行的次数) 或 替换进行的次数 ＞ count)
        替换进行的次数 ＝ count
    .如果真结束
    ret ＝ 欲被替换的字节集
    len ＝ 字节集_取长度 (欲被替换的子字节集)
    
    偏移 ＝ 字节集_取长度 (用作替换的子字节集) － len
    
    .计次循环首 (替换进行的次数, i)
        .如果 (i ＝ 1)
            ret ＝ 字节集_替换 (ret, offset [i], len, 用作替换的子字节集)
        .否则
            ret ＝ 字节集_替换 (ret, offset [i] ＋ 偏移 × (i － 1), len, 用作替换的子字节集)
        .如果结束
        
    .计次循环尾 ()
    返回 (ret)

.子程序 字节集_寻找子, 整数型, 公开, 查找所有欲寻找的字节集 ，将每个位置放入 结果数组
    .参数 被搜寻的字节集, 字节集
    .参数 欲寻找的字节集, 字节集
    .参数 结果数组, 整数型, 数组
    .参数 开始偏移, 整数型, 可空
    .局部变量 i
    .局部变量 j
    .局部变量 len_y

    清除数组 (结果数组)
    i ＝ 1
    .如果 (是否为空 (开始偏移))
        j ＝ 1
    .否则
        j ＝ 开始偏移
    .如果结束
    len_y ＝ 字节集_取长度 (欲寻找的字节集)
    .判断循环首 (i ≠ -1)
        i ＝ 字节集_寻找 (被搜寻的字节集, 欲寻找的字节集, j)
        .如果真 (i ≠ -1)
            加入成员 (结果数组, i)
            j ＝ i ＋ len_y
        .如果真结束
        
    .判断循环尾 ()
    返回 (取数组成员数 (结果数组))

.子程序 AdjustString, 字节集, 公开, 字节序大小端转换
    .参数 pBuf, 整数型
    .参数 dwSize, 整数型
    .局部变量 ptr, 整数型
    .局部变量 szBuf, 字节集
    .局部变量 i, 整数型

    ptr ＝ LocalAlloc (#LMEM_ZEROINIT, dwSize)
    .变量循环首 (0, dwSize － 2, 2, i)
        memcpy (ptr ＋ i ＋ 1, pBuf ＋ i, 1)
        memcpy (ptr ＋ i, pBuf ＋ i ＋ 1, 1)
    .变量循环尾 ()
    szBuf ＝ 指针到字节集 (ptr, dwSize)
    LocalFree (ptr)
    返回 (szBuf)

.子程序 字节集_反转, 字节集, 公开, 字节序反转
    .参数 字节集, 字节集
    .局部变量 i, 整数型
    .局部变量 反转后字节集, 字节集
    .局部变量 len, 整数型

    len ＝ 取字节集长度 (字节集)
    反转后字节集 ＝ 取空白字节集 (len)
    .计次循环首 (len, i)
        反转后字节集 [len － i ＋ 1] ＝ 字节集 [i]
    .计次循环尾 ()
    返回 (反转后字节集)

.子程序 字节集_反转Asm, 字节集, 公开, 字节序反转
    .参数 数据的字节集, 字节集
    .局部变量 nMaxCount, 整数型
    .局部变量 aryBin, 字节集

    nMaxCount ＝ 取字节集长度 (数据的字节集)
    aryBin ＝ 取空白字节集 (nMaxCount)
    置入代码 ({ 139, 93, 8, 139, 3, 141, 88, 8, 139, 69, 248, 139, 77, 252, 133, 201, 116, 9, 138, 19, 136, 84, 8, 7, 67, 226, 247, 201, 194, 4, 0 })
    ' mov ebx, dword [ebp+08h]
    ' mov eax, dword [ebx]
    ' lea ebx, dword [eax+08h]
    ' mov eax, dword [ebp-08h]
    ' mov ecx, dword [ebp-04h]
    ' test ecx, ecx
    ' je label2
    ' label1:
    ' mov dl, byte [ebx]
    ' mov byte [eax+ecx+07h], dl
    ' inc ebx
    ' loop label1
    ' label2:
    ' leave
    ' retn 04h
    返回 ({ })

.子程序 字节集_取中间_批量, 整数型, 公开, 与 文本_取中间_批量 用法基本一致
    .参数 欲取其部分的字节集, 字节集
    .参数 欲取出字节的左边, 字节集
    .参数 欲取出字节的右边, 字节集
    .参数 存放取出的字节数组, 字节集, 可空 数组
    .参数 起始取出位置, 整数型, 可空, 1为首位置，2为第2个位置，如此类推。
    .局部变量 dwBegin, 整数型
    .局部变量 dwEnd, 整数型
    .局部变量 dwSize, 整数型
    .局部变量 aryBin, 字节集

    清除数组 (存放取出的字节数组)
    .如果真 (起始取出位置 ≤ 0)
        起始取出位置 ＝ 1
    .如果真结束
    dwBegin ＝ 起始取出位置
    .循环判断首 ()
        dwBegin ＝ 寻找字节集 (欲取其部分的字节集, 欲取出字节的左边, dwBegin)
        .如果真 (dwBegin ＝ -1)
            跳出循环 ()
        .如果真结束
        dwBegin ＝ dwBegin ＋ 取字节集长度 (欲取出字节的左边)
        dwEnd ＝ 寻找字节集 (欲取其部分的字节集, 欲取出字节的右边, dwBegin)
        .如果真 (dwEnd ＝ -1)
            跳出循环 ()
        .如果真结束
        dwSize ＝ dwEnd － dwBegin
        aryBin ＝ 取字节集中间 (欲取其部分的字节集, dwBegin, dwSize)
        加入成员 (存放取出的字节数组, aryBin)
        dwBegin ＝ dwEnd ＋ 取字节集长度 (欲取出字节的右边)
    .循环判断尾 (dwBegin ≠ -1)
    返回 (取数组成员数 (存放取出的字节数组))

.版本 2

.程序集 集_文本
.程序集变量 集_计次, 整数型

.子程序 数组_去重复_整数型, 整数型, 公开, 返回剩余不重复数组的成员数量
    .参数 整数数组, 整数型, 数组, 要去重复的 整数数组
    .局部变量 成员数, 整数型
    .局部变量 i, 长整数型
    .局部变量 a, 整数型

    ' 该历程收录自：https://bbs.125.la/thread-14402954-1-1.html
    数组排序 (整数数组, 真)
    成员数 ＝ 取数组成员数 (整数数组)
    i ＝ 0
    a ＝ 1
    .判断循环首 (a ≤ 成员数)
        i ＝ i ＋ 1
        整数数组 [i] ＝ 整数数组 [a]
        .循环判断首 ()
            a ＝ a ＋ 1
            .如果真 (a ＞ 成员数)
                跳出循环 ()
            .如果真结束
            
        .循环判断尾 (整数数组 [i] ＝ 整数数组 [a])
    .判断循环尾 ()
    重定义数组 (整数数组, 真, i)
    返回 (i)

.子程序 数组_去重复_整数型1, 整数型, 公开, 去重复并返回剩余不重复数组的成员数量
    .参数 整数数组, 整数型, 数组, 要去重复的 整数数组
    .局部变量 i, 整数型
    .局部变量 局_参考空间, 整数型, , "0", 空间
    .局部变量 局_最大值, 整数型
    .局部变量 局_最小值, 整数型
    .局部变量 数组长度, 整数型
    .局部变量 a, 整数型
    .局部变量 参数1, 双精度小数型

    ' 该历程收录自: https://bbs.125.la/thread-14762146-1-1.html
    ' 不需要用长整数，易语言数组容量应该超不过整数型极限2147483648
    .如果真 (取数组成员数 (整数数组) ＝ 0)
        返回 (0)
    .如果真结束
    
    连续赋值 (整数数组 [1], 局_最大值, 局_最小值)
    .变量循环首 (2, 取数组成员数 (整数数组), 1, i)
        .如果 (整数数组 [i] ＞ 局_最大值)
            局_最大值 ＝ 整数数组 [i]
        .否则
            .如果真 (整数数组 [i] ＜ 局_最小值)
                局_最小值 ＝ 整数数组 [i]
            .如果真结束
            
        .如果结束
        
    .变量循环尾 ()
    数组长度 ＝ 局_最大值 － 局_最小值 ＋ 1
    参数1 ＝ 局_最小值 － 1
    ' 开辟空间
    重定义数组 (局_参考空间, 假, 数组长度)
    .计次循环首 (取数组成员数 (整数数组), i)
        .如果真 (局_参考空间 [整数数组 [i] － 参数1] ＝ 0)
            局_参考空间 [整数数组 [i] － 参数1] ＝ 1
        .如果真结束
        
    .计次循环尾 ()
    
    .计次循环首 (取数组成员数 (局_参考空间), i)
        .如果真 (局_参考空间 [i] ＝ 1)
            a ＝ a ＋ 1
            整数数组 [a] ＝ i ＋ 参数1
        .如果真结束
        
    .计次循环尾 ()
    重定义数组 (整数数组, 真, a)
    返回 (取数组成员数 (整数数组))

.子程序 文本_取长度ex, 整数型, 公开, 全角汉字字符算一个长度
    .参数 参数_被计算文本, 文本型
    .局部变量 szChar, 字节集

    szChar ＝ 编码_Ansi到Unicode (参数_被计算文本, )
    返回 (文本_取长度W (szChar))

.子程序 文本_分割文本, 整数型, 公开, 能够将连续的分隔符视为一个分隔符 返回成员数
    .参数 待分割文本, 文本型
    .参数 分隔符, 文本型, 可空
    .参数 返回子文本数目, 整数型, 可空
    .参数 返回数组, 文本型, 参考 数组
    .局部变量 i, 整数型
    .局部变量 临时数组, 文本型, , "0"

    重定义数组 (返回数组, 假, 0)
    .如果真 (分隔符 ＝ “”)
        分隔符 ＝ “,”
    .如果真结束
    .如果 (返回子文本数目 ＝ 0)
        临时数组 ＝ 分割文本 (待分割文本, 分隔符, )
    .否则
        临时数组 ＝ 分割文本 (待分割文本, 分隔符, 返回子文本数目)
    .如果结束
    
    .计次循环首 (取数组成员数 (临时数组), i)
        .如果真 (临时数组 [i] ≠ “”)
            加入成员 (返回数组, 临时数组 [i])
        .如果真结束
        
    .计次循环尾 ()
    返回 (取数组成员数 (返回数组))
    

.子程序 文本_寻找文本, 整数型, 公开, 成功找到返回位置索引，未找到返回-1。调用Ntdll命令，比核心库快三倍以上，注意！此命令不是严格按易语言文本型来查找。
    .参数 参_原始文本, 文本型
    .参数 参_查找文本, 文本型
    .参数 参_搜寻位置, 整数型, 可空, 可以被省略。位置值从 1 开始。如果本参数被省略，默认为 1
    .参数 参_不分大写, 逻辑型, 可空, 初始值为“假”。为真不区分大小写，为假区分。
    .局部变量 局_原始文本, 文本型
    .局部变量 局_查找文本, 文本型

    .如果真 (参_搜寻位置 ＝ 0)
        参_搜寻位置 ＝ 1
    .如果真结束
    
    .如果真 (取文本长度 (参_原始文本) ＝ 0 或 取文本长度 (参_查找文本) ＝ 0)
        返回 (-1)
    .如果真结束
    
    
    .判断开始 (参_不分大写)
        局_原始文本 ＝ 参_原始文本
        局_查找文本 ＝ 参_查找文本
        返回 (_寻找文本 (API_文本小写 (局_原始文本), API_文本小写 (局_查找文本), 参_搜寻位置))
    .默认
        返回 (_寻找文本 (参_原始文本, 参_查找文本, 参_搜寻位置))
    .判断结束
    

.子程序 _寻找文本, 整数型
    .参数 原始文本, 文本型
    .参数 查找文本, 文本型
    .参数 搜寻位置, 整数型
    .局部变量 查找索引, 整数型
    .局部变量 文本地址, 整数型

    .如果真 (原始文本 ＝ “”)
        返回 (-1)
    .如果真结束
    文本地址 ＝ 取指针文本_ (原始文本)
    搜寻位置 ＝ 搜寻位置 － 1
    查找索引 ＝ API_查找文本 (文本地址 ＋ 搜寻位置, 查找文本)
    .如果真 (查找索引 ＝ 0)
        返回 (-1)
    .如果真结束
    返回 (查找索引 － 文本地址 ＋ 1)

.子程序 文本_是否UTF8_汇编, 逻辑型, 公开, utf8编码返回真, 其他编码返回假, 支持多线程; 感谢【@jr21066 】
    .参数 参_内容, 字节集

    .如果真 (参_内容 ＝ { })
        返回 (假)
    .如果真结束
    置入代码 ({ 86, 87, 83, 139, 69, 8, 139, 24, 139, 75, 4, 139, 48, 131, 198, 8, 139, 67, 8, 37, 255, 255, 255, 0, 61, 191, 187, 239, 0, 116, 101, 172, 138, 224, 60, 127, 118, 88, 192, 232, 6, 60, 6, 117, 19, 172, 80, 192, 232, 6, 60, 2, 117, 74, 88, 192, 232, 7, 60, 0, 116, 70, 235, 62, 138, 196, 192, 232, 4, 60, 14, 117, 18, 172, 192, 232, 6, 60, 2, 117, 47, 172, 192, 232, 6, 60, 2, 117, 39, 235, 41, 138, 196, 192, 232, 3, 60, 30, 117, 28, 172, 192, 232, 6, 60, 2, 117, 20, 172, 192, 232, 6, 60, 2, 117, 12, 172, 192, 232, 6, 60, 2, 117, 4, 235, 6, 226, 159, 51, 192, 235, 3, 51, 192, 64, 91, 95, 94, 201, 194, 4, 0 })
    返回 (假)
    ' *** 缩略程序块 ***
    ' push esi  正确的保护寄存器就是这样的,因为偷懒才用pushad这样的.唯一的好处就是编译后的字节少,这次因为要用eax带回结果,所以不能保护eax值
    ' push edi
    ' push ebx
    ' mov eax,[ebp+08h]
    ' mov ebx,[eax]
    ' mov ecx,[ebx+04h]
    ' mov esi,[eax]
    ' add esi,08h
    ' mov eax,[ebx+08h]
    ' and eax,00FFFFFFh
    ' cmp eax,00EFBBBFh  有的UTF-8文件是带文件头的,如果有文件头就不判断了.
    ' je Label1
    ' Label6:
    ' lodsb
    ' mov ah,al
    ' cmp al,7Fh  单字节小于127的都是ASCII码,是不用判断的
    ' jbe Label2
    ' shr al,06h
    ' cmp al,06h  判断位数及判定逻辑都在最后.感兴趣的同学可以参阅,是在网上搜索的.不是原创.只能解释这么多了.
    ' jne Label3
    ' lodsb
    ' push eax
    ' shr al,06h
    ' cmp al,02h
    ' jne Label4
    ' pop eax
    ' shr al,07h
    ' cmp al,00h
    ' je Label1
    ' jmp Label2
    ' Label3:
    ' mov al,ah
    ' shr al,04h
    ' cmp al,0Eh
    ' jne Label5
    ' lodsb
    ' shr al,06h
    ' cmp al,02h
    ' jne Label4
    ' lodsb
    ' shr al,06h
    ' cmp al,02h
    ' jne Label4
    ' jmp Label1
    ' Label5:
    ' mov al,ah
    ' shr al,03h
    ' cmp al,1Eh
    ' jne Label4
    ' lodsb
    ' shr al,06h
    ' cmp al,02h
    ' jne Label4
    ' lodsb
    ' shr al,06h
    ' cmp al,02h
    ' jne Label4
    ' lodsb
    ' shr al,06h
    ' cmp al,02h
    ' jne Label4
    ' jmp Label1
    ' Label2:
    ' loop Label6
    ' Label4:
    ' xor eax,eax  返回假
    ' jmp Label7
    ' Label1:
    ' xor eax,eax
    ' inc eax  返回真,据说清零加一也比直接给eax1要快很多....
    ' Label7:
    ' pop ebx
    ' pop edi
    ' pop esi
    ' leave
    ' retn 0004h  自己返回的要恢复堆栈,一个参数就是一个整数.占四个字节.
    
    ' 附编码说明及判定方法,来源于网络.非自创.
    ' 如果不符合utf-8的规范，认为是gb18030编码
    ' 如果有符合utf-8规范中的3字节或4字节编码的，认为是utf-8编码
    ' 如果有符合utf-8规范中的2字节编码的，但是不符合gb18030编码的，认为是utf-8编码
    ' 如果全部都是符合2字节的utf-8编码，同时也符合gb18030编码的，认为是gb18030编码
    ' Unicode符号范围        |   UTF-8编码方式
    ' (十六进制)                 |   （二进制）
    ' ------------------------------+--------------------------------------------------------------
    ' 0000 0000-0000 007F | 0xxxxxxx
    ' 0000 0080-0000 07FF | 110xxxxx 10xxxxxx
    ' 0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx
    ' 0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
    ' ---------------------------------------------------------------------------------------------

.子程序 文本_均分文本, , 公开, 根据换行符将大文件内容均分为几段来处理
    .参数 参_内容, 字节集, , 要处理的文本内容
    .参数 参_文本数组, 文本型, 数组, 用于存放返回文本的数组
    .参数 参_分割数, 整数型, , 分割的段数
    .局部变量 局_区间值, 整数型
    .局部变量 局_偏移, 整数型
    .局部变量 局_内容, 字节集
    .局部变量 局_计数器, 整数型

    ' 复制源内容,保护原文本
    局_内容 ＝ 参_内容
    ' 求区段长度
    局_区间值 ＝ 四舍五入 (取字节集长度 (局_内容) ÷ 参_分割数, )
    清除数组 (参_文本数组)
    .计次循环首 (参_分割数 － 1, 局_计数器)
        ' 寻找上一换行符位置,分割完整的文本行
        局_偏移 ＝ 倒找字节集 (局_内容, { 13, 10 }, 局_区间值)
        加入成员 (参_文本数组, 到文本 (取字节集中间 (局_内容, 1, 局_偏移)))
        局_内容 ＝ 取字节集右边 (局_内容, 取字节集长度 (局_内容) － 局_偏移)
    .计次循环尾 ()
    ' 最后一段文本
    加入成员 (参_文本数组, 到文本 (局_内容))

.子程序 文本_均分文本1, 文本型, 公开, 按长度给文本加入换行符
    .参数 欲均分的文本, 文本型
    .参数 每行文本长度, 整数型
    .局部变量 局_判断, 逻辑型
    .局部变量 局_分割, 文本型, , "0"
    .局部变量 局_编码, 文本型
    .局部变量 局_返回, 文本型
    .局部变量 i, 整数型

    ' https://bbs.125.la/forum.php?mod=viewthread&tid=14622764
    局_编码 ＝ 编码_Ansi到Unicode_文本型 (欲均分的文本)
    局_分割 ＝ 分割文本 (局_编码, “&#”, )
    局_判断 ＝ 真
    .计次循环首 (取数组成员数 (局_分割), i)
        局_返回 ＝ 局_返回 ＋ 编码_Unicode到Ansi_文本型 (“&#” ＋ 局_分割 [i])
        .如果真 (取文本长度 (局_返回) ≥ 每行文本长度 且 局_判断 ＝ 真)
            局_返回 ＝ 局_返回 ＋ #换行符
            局_判断 ＝ 假
        .如果真结束
        .如果真 (局_判断 ＝ 假)
            .如果真 (取文本长度 (文本_取右边 (局_返回, #换行符, , )) ≥ 每行文本长度)
                局_返回 ＝ 局_返回 ＋ #换行符
            .如果真结束
            
        .如果真结束
        
    .计次循环尾 ()
    返回 (局_返回)

.子程序 文本_删除空行_汇编, 文本型, 公开, 一次完成搜索替换
    .参数 参_内容, 文本型
    .局部变量 局_缓存区, 文本型

    .如果真 (参_内容 ＝ “”)
        返回 (“”)
    .如果真结束
    局_缓存区 ＝ 取空白文本 (取文本长度 (参_内容))
    取指针文本_ (参_内容)
    ' https://bbs.125.la/forum.php?mod=viewthread&tid=14749043
    置入代码 ({ 96, 139, 240, 139, 125, 252, 51, 192, 51, 219, 51, 201, 172, 60, 0, 116, 82, 60, 13, 116, 68, 60, 10, 116, 68, 138, 224, 131, 249, 1, 117, 45, 102, 131, 251, 1, 117, 3, 176, 13, 170, 102, 129, 251, 0, 1, 117, 3, 176, 10, 170, 102, 129, 251, 1, 1, 117, 6, 176, 10, 170, 176, 13, 170, 102, 129, 251, 1, 2, 117, 6, 176, 13, 170, 176, 10, 170, 138, 196, 170, 185, 1, 0, 0, 0, 51, 219, 235, 179, 179, 1, 235, 175, 138, 251, 254, 199, 235, 169, 170, 97 })
    返回 (局_缓存区)

.子程序 文本_取全部汉字拼音, 文本型, 公开, 支持取出文本中所有国标汉字的拼音，默认不保留非国标汉字字符。
    .参数 文本, 文本型, , 欲取拼音的文本
    .参数 保留非汉字, 逻辑型, 可空, 默认假，不保留原文本里的符号和数字等非国标汉字字符；真则保留。
    .局部变量 b, 字节集
    .局部变量 c, 整数型
    .局部变量 n, 整数型
    .局部变量 z, 整数型
    .局部变量 ret, 文本型
    .局部变量 p0, 文本型
    .局部变量 p1, 文本型

    .如果真 (是否为空 (保留非汉字))
        保留非汉字 ＝ 假
    .如果真结束
    b ＝ 到字节集 (文本)
    c ＝ 取字节集长度 (b)
    n ＝ 1
    .判断循环首 (n ≤ c)
        .如果 (n ＞ c)
            z ＝ 1
        .否则
            .如果 (b [n] ＞ 128)
                z ＝ 2
                p0 ＝ 到文本 (取字节集中间 (b, n, 2))
                p1 ＝ 取拼音 (p0, 1)
                .判断开始 (取文本长度 (删全部空 (p1)) ≠ 0)
                    ret ＝ ret ＋ p1 ＋ “空”
                .默认
                    .如果真 (保留非汉字)
                        ret ＝ ret ＋ p0
                    .如果真结束
                    
                .判断结束
                
            .否则
                .如果 (b [n] ≠ 13)
                    z ＝ 1
                .否则
                    .如果 (b [n ＋ 1] ＝ 10)
                        z ＝ 2
                    .否则
                        z ＝ 1
                        
                    .如果结束
                    
                .如果结束
                
                .如果真 (保留非汉字)
                    .如果 (取文本长度 (删全部空 (取拼音 (到文本 (取字节集中间 (b, n ＋ 1, 2)), 1))) ≠ 0) ' ‘判断单字节字符后面是否是双字节字符
                        ret ＝ ret ＋ 到文本 (取字节集中间 (b, n, z)) ＋ “空”
                    .否则
                        ret ＝ ret ＋ 到文本 (取字节集中间 (b, n, z))
                    .如果结束
                    
                .如果真结束
                
            .如果结束
            
        .如果结束
        n ＝ n ＋ z
    .判断循环尾 ()
    ret ＝ 子文本替换 (ret, “ ”, “”, , , 真) ' ’删除中间多余的空格
    ret ＝ 子文本替换 (ret, “空”, “ ”, , , 真) ' ’把用作隔开的“空”替换为“ ”
    
    .如果真 (取文本右边 (ret, 1) ＝ “ ”) ' ’删除尾部多余空格
        ret ＝ 取文本左边 (ret, 取文本长度 (ret) － 1)
    .如果真结束
    返回 (ret)

.子程序 文本_插入文本到关键字所在行后, 文本型, 公开, 插入文本到关键字所在行后，返回处理后的文本  [Harry· 提供]
    .参数 原文本, 文本型
    .参数 关键字, 文本型
    .参数 插入内容, 文本型
    .参数 是否换行, 逻辑型, 可空, 是否换行插入文本，默认为真
    .局部变量 i, 整数型
    .局部变量 临时数组, 文本型, , "0"
    .局部变量 临时文本, 文本型

    临时数组 ＝ 分割文本 (原文本, #换行符, )
    .如果真 (是否为空 (是否换行) ＝ 真)
        是否换行 ＝ 真
    .如果真结束
    .计次循环首 (取数组成员数 (临时数组), i)
        .如果 (寻找文本 (临时数组 [i], 关键字, , 假) ≠ -1)
            .如果 (是否换行 ＝ 真)
                临时数组 [i] ＝ 临时数组 [i] ＋ #换行符 ＋ 插入内容 ＋ #换行符
            .否则
                临时数组 [i] ＝ 临时数组 [i] ＋ 插入内容 ＋ #换行符
            .如果结束
            
        .否则
            临时数组 [i] ＝ 临时数组 [i] ＋ #换行符
        .如果结束
        临时文本 ＝ 临时文本 ＋ 临时数组 [i]
    .计次循环尾 ()
    返回 (临时文本)

.子程序 文本_删左边, 文本型, 公开
    .参数 欲处理文本, 文本型
    .参数 删除长度, 整数型, , 以字符为单位
    .局部变量 szText, 字节集

    szText ＝ 编码_Ansi到Unicode (欲处理文本, 真)
    szText ＝ 取字节集右边 (szText, 取字节集长度 (szText) － 删除长度 × 2)
    返回 (编码_Unicode到Ansi (szText))

.子程序 文本_删右边, 文本型, 公开
    .参数 欲处理文本, 文本型
    .参数 删除长度, 整数型, , 以字符为单位
    .局部变量 szText, 字节集

    szText ＝ 编码_Ansi到Unicode (欲处理文本, 真)
    szText ＝ 取字节集左边 (szText, 取字节集长度 (szText) － 删除长度 × 2)
    返回 (编码_Unicode到Ansi (szText))

.子程序 文本_删中间, 文本型, 公开
    .参数 欲处理文本, 文本型
    .参数 起始位置, 整数型
    .参数 删除长度, 整数型

    返回 (文本替换 (欲处理文本, 起始位置, 删除长度, “”))

.子程序 文本_删中间2, 文本型, 公开, 本命令会删除前面文本和后面文本之间的所有内容（包括后面文本），如文本中含有多个前面文本或后面文本则删除首个前面文本与最后一个后面文本之间的所有内容。
    .参数 原文本, 文本型, , 待处理的文本
    .参数 前面文本, 文本型
    .参数 后面文本, 文本型
    .参数 是否不区分大小写, 逻辑型, 可空, 默认为假，即区分大小写。
    .参数 保留前面文本, 逻辑型, 可空, 默认为假
    .参数 保留后面文本, 逻辑型, 可空, 默认为假
    .局部变量 局_开始位置, 整数型
    .局部变量 局_结束位置, 整数型
    .局部变量 局_返回文本, 文本型
    .局部变量 局_右边文本, 文本型
    .局部变量 局_返回后文本, 文本型
    .局部变量 局_返回前文本, 文本型

    局_开始位置 ＝ 寻找文本 (原文本, 前面文本, , 是否不区分大小写)
    .如果真 (局_开始位置 ＝ -1)
        返回 (原文本)
    .如果真结束
    局_返回前文本 ＝ 取文本左边 (原文本, 局_开始位置 － 1)
    .如果真 (保留前面文本)
        局_返回前文本 ＝ 局_返回前文本 ＋ 前面文本
    .如果真结束
    
    局_右边文本 ＝ 取文本右边 (原文本, 取文本长度 (原文本) － 取文本长度 (局_返回前文本))
    局_结束位置 ＝ 倒找文本 (局_右边文本, 后面文本, , 是否不区分大小写)
    .如果真 (局_结束位置 ＝ -1)
        返回 (原文本)
    .如果真结束
    局_返回后文本 ＝ 取文本右边 (局_右边文本, 取文本长度 (局_右边文本) － 局_结束位置 － 取文本长度 (后面文本) ＋ 1)
    
    局_返回文本 ＝ 局_返回前文本 ＋ 局_返回后文本
    .如果真 (保留后面文本)
        局_返回文本 ＝ 局_返回前文本 ＋ 后面文本 ＋ 局_返回后文本
    .如果真结束
    
    返回 (局_返回文本)

.子程序 文本_取出文本中汉字, 文本型, 公开, 取出指定文本中的汉字
    .参数 字符串, 文本型

    返回 (_只取汉字 (字符串))

.子程序 文本_取随机Ip, 文本型, 公开, 返回一个随机的IP地址
    .参数 只取国内, 逻辑型, 可空, 可空，默认为真
    .局部变量 局_Ip, 文本型, , "0"
    .局部变量 Arr, 文本型, , "0"
    .局部变量 Str, 文本型
    .局部变量 局_IP1, 文本型
    .局部变量 局_IP2, 文本型
    .局部变量 局_IP头, 文本型
    .局部变量 IP数组1, 文本型, , "0"
    .局部变量 IP数组2, 文本型, , "0"

    置随机数种子 ()
    .如果真 (是否为空 (只取国内))
        只取国内 ＝ 真
    .如果真结束
    .如果真 (只取国内)
        .如果真 (取数组成员数 (局_Ip) ＝ 0)
            局_Ip ＝ 分割文本 (#常量_IP, #换行符, )
        .如果真结束
        Str ＝ 局_Ip [取随机数 (1, 取数组成员数 (局_Ip))]
        局_IP1 ＝ 文本_取左边 (Str, “-”)
        局_IP2 ＝ 文本_取右边 (Str, “-”)
        
        
        IP数组1 ＝ 分割文本 (局_IP1, “.”, )
        IP数组2 ＝ 分割文本 (局_IP2, “.”, )
        .如果真 (取数组成员数 (IP数组1) ≠ 4 或 取数组成员数 (IP数组2) ≠ 4)
            返回 (文本_取随机Ip (只取国内))
        .如果真结束
        
        Str ＝ IP数组1 [1] ＋ “.” ＋ 到文本 (取随机数 (到整数 (IP数组1 [2]), 到整数 (IP数组2 [2])))
        Str ＝ Str ＋ “.” ＋ 到文本 (取随机数 (到整数 (IP数组1 [3]), 到整数 (IP数组2 [3])))
        Str ＝ Str ＋ “.” ＋ 到文本 (取随机数 (到整数 (IP数组1 [4]), 到整数 (IP数组2 [4])))
        返回 (Str)
    .如果真结束
    
    .如果真 (取数组成员数 (局_Ip) ＝ 0)
        Str ＝ 到文本 (取随机数 (50, 254)) ＋ “.” ＋ 到文本 (取随机数 (50, 254)) ＋ “.” ＋ 到文本 (取随机数 (50, 254)) ＋ “.” ＋ 到文本 (取随机数 (50, 254))
    .如果真结束
    返回 (Str)

.子程序 文本_逐字分割, 整数型, 公开, 将指定文本,逐字分割成数组,保存为指定的变量数组中,返回成员个数,可识别换行符及全半角字符和汉字
    .参数 文本, 文本型, , 需要分割的文本
    .参数 返回的数组, 文本型, 参考 可空 数组, 保存分割结果的数组变量
    .局部变量 c, 整数型
    .局部变量 n, 整数型
    .局部变量 z, 整数型
    .局部变量 返回文本, 文本型
    .局部变量 临时字节集, 字节集

    清除数组 (返回的数组)
    临时字节集 ＝ 到字节集 (文本)
    c ＝ 取字节集长度 (临时字节集)
    n ＝ 1
    .判断循环首 (n ≤ c)
        .如果 (n ＋ 1 ＞ c)
            z ＝ 1
        .否则
            .如果 (临时字节集 [n] ＞ 128)
                z ＝ 2
            .否则
                .如果 (临时字节集 [n] ≠ 13)
                    z ＝ 1
                .否则
                    .如果 (临时字节集 [n ＋ 1] ＝ 10)
                        z ＝ 2
                    .否则
                        z ＝ 1
                    .如果结束
                    
                .如果结束
                
            .如果结束
            
        .如果结束
        加入成员 (返回的数组, 到文本 (取字节集中间 (临时字节集, n, z)))
        n ＝ n ＋ z
    .判断循环尾 ()
    返回 (取数组成员数 (返回的数组))

.子程序 文本_逐字分割_汇编, 整数型, 公开, 超长文本计算时有优势 调用该命令前请确定内容不为空
    .参数 参_内容, 文本型
    .参数 参_文本数组, 文本型, 数组
    .局部变量 返回值, 文本型

    ' 例程收录自：https://bbs.125.la/forum.php?mod=viewthread&tid=14228410
    .如果真 (参_内容 ＝ “”)
        返回 (0)
    .如果真结束
    返回值 ＝ 取空白文本 (取文本长度 (参_内容) × 2)
    置入代码 ({ 139, 69, 8, 139, 48, 139, 125, 252, 172, 168, 128, 117, 26, 60, 32, 116, 247, 60, 9, 116, 243, 60, 13, 116, 239, 60, 10, 116, 235, 132, 192, 116, 28, 170, 176, 9, 170, 235, 225, 60, 161, 117, 10, 134, 224, 172, 60, 161, 116, 214, 134, 224, 78, 170, 172, 170, 176, 9, 170, 235, 203, 49, 192, 170 })
    参_文本数组 ＝ 分割文本 (返回值, 到文本 ({ 9 }), )
    返回 (取数组成员数 (参_文本数组))

.子程序 文本_逐字分割_快速, 整数型, 公开, @福仔 【注意】 必须和 文本_逐字分割_快速_释放() 配套使用, 如果不释放可能会导致崩溃, 快速把一个文本按每个字符进行分割, 返回分割后的成员数
    .参数 待分割文本, 文本型
    .参数 接收结果数组, 文本型, 参考 数组, 调用完之后必须调用 文本_逐字分割_快速_释放() 把这个数组传递进去进行释放, 不允许修改这个数组
    .参数 换行符是否为单个字符, 逻辑型, 可空, 为真则 \r\n(13, 10) 算一个成员, 否则会分割成两个成员, 默认为真
    .局部变量 len, 整数型
    .局部变量 i, 整数型
    .局部变量 pBuf, 整数型
    .局部变量 pStr, 整数型
    .局部变量 by, 整数型
    .局部变量 offset, 整数型
    .局部变量 n, 整数型
    .局部变量 pAry, 整数型

    .如果真 (是否为空 (换行符是否为单个字符))
        换行符是否为单个字符 ＝ 真
    .如果真结束
    
    pStr ＝ 取指针_文本型 (待分割文本)
    len ＝ lstrlenA (pStr)
    pBuf ＝ malloc (len × 3)
    memset (pBuf, 0, len × 3)
    
    重定义数组 (接收结果数组, 假, len)
    pAry ＝ 取数据_通用型_数组 (接收结果数组)
    
    .判断循环首 (i ＜ len)
        __set (pAry, n × 4, pBuf ＋ offset)
        by ＝ __get_byte (pStr, i)
        __set_byte (pBuf, offset, by)
        offset ＝ offset ＋ 1
        .如果真 (by ＞ 128 或 (换行符是否为单个字符 且 by ＝ 13))
            i ＝ i ＋ 1
            __set_byte (pBuf, offset, __get_byte (pStr, i))
            offset ＝ offset ＋ 1
        .如果真结束
        
        offset ＝ offset ＋ 1
        n ＝ n ＋ 1
        i ＝ i ＋ 1
    .判断循环尾 ()
    __set (pAry － 4, 0, n) ' 直接修改成员数
    ' 重定义数组 (接收结果数组, 真, n)
    返回 (n)

.子程序 文本_逐字分割_快速_释放, , 公开, @福仔 释放 文本_逐字分割_快速() 参考返回的数组
    .参数 接收结果数组, 文本型, 参考 数组, 文本_逐字分割_快速() 第二个参数
    .局部变量 pAry, 整数型
    .局部变量 ptr, 整数型
    .局部变量 i, 整数型

    pAry ＝ 取数据_通用型_数组 (接收结果数组)
    ptr ＝ __get (pAry, 0) ' 文本_逐字分割_快速是把指针保存在第一个成员里, 取出来释放
    .如果真 (ptr ＝ 0)
        返回 ()
    .如果真结束
    free (ptr)
    .计次循环首 (取数组成员数 (接收结果数组), i)
        __set (pAry, (i － 1) × 4, 0) ' 把易语言的数组逐个赋值为0, 防止易语言会释放
    .计次循环尾 ()

.子程序 文本_递减, 文本型, 公开, 把文本递减1  编辑框1.内容 ＝ 文本_递减 (编辑框1.内容)
    .参数 要递减的文本, 文本型, 参考

    返回 (到文本 (原子递减变量 (到数值 (要递减的文本))))

.子程序 文本_递增, 文本型, 公开, 把文本递增1  编辑框1.内容 ＝ 文本_递增 (编辑框1.内容)
    .参数 要递增的文本, 文本型, 参考

    返回 (到文本 (原子递增变量 (到数值 (要递增的文本))))

.子程序 文本_替换, 文本型, 公开, 批量替换文本；
    .参数 原文本, 文本型
    .参数 替换进行的次数, 整数型, 可空, 可空；参数值指定对子文本进行替换的次数。如果省略，默认进行所有可能的替换。
    .参数 替换的起始位置, 整数型, 可空, 可空；参数值指定被替换子文本的起始搜索位置。如果省略，默认从 1 开始
    .参数 是否区分大小写, 逻辑型, 可空, 可空； 初始值为“假”不区分大小写；为真区分大小写。
    .参数 欲被替换的子文本1, 文本型
    .参数 用作替换的子文本1, 文本型
    .参数 欲被替换的子文本2, 文本型, 可空
    .参数 用作替换的子文本2, 文本型, 可空
    .参数 欲被替换的子文本3, 文本型, 可空
    .参数 用作替换的子文本3, 文本型, 可空
    .参数 欲被替换的子文本4, 文本型, 可空
    .参数 用作替换的子文本4, 文本型, 可空
    .参数 欲被替换的子文本5, 文本型, 可空
    .参数 用作替换的子文本5, 文本型, 可空
    .局部变量 局_文本, 文本型

    .如果真 (替换的起始位置 ＝ 0)
        替换的起始位置 ＝ 1
    .如果真结束
    .如果 (是否为空 (替换进行的次数))
        局_文本 ＝ 子文本替换 (原文本, 欲被替换的子文本1, 用作替换的子文本1, 替换的起始位置, , 是否区分大小写)
        局_文本 ＝ 子文本替换 (局_文本, 欲被替换的子文本2, 用作替换的子文本2, 替换的起始位置, , 是否区分大小写)
        局_文本 ＝ 子文本替换 (局_文本, 欲被替换的子文本3, 用作替换的子文本3, 替换的起始位置, , 是否区分大小写)
        局_文本 ＝ 子文本替换 (局_文本, 欲被替换的子文本4, 用作替换的子文本4, 替换的起始位置, , 是否区分大小写)
        局_文本 ＝ 子文本替换 (局_文本, 欲被替换的子文本5, 用作替换的子文本5, 替换的起始位置, , 是否区分大小写)
    .否则
        局_文本 ＝ 子文本替换 (原文本, 欲被替换的子文本1, 用作替换的子文本1, 替换的起始位置, 替换进行的次数, 是否区分大小写)
        局_文本 ＝ 子文本替换 (局_文本, 欲被替换的子文本2, 用作替换的子文本2, 替换的起始位置, 替换进行的次数, 是否区分大小写)
        局_文本 ＝ 子文本替换 (局_文本, 欲被替换的子文本3, 用作替换的子文本3, 替换的起始位置, 替换进行的次数, 是否区分大小写)
        局_文本 ＝ 子文本替换 (局_文本, 欲被替换的子文本4, 用作替换的子文本4, 替换的起始位置, 替换进行的次数, 是否区分大小写)
        局_文本 ＝ 子文本替换 (局_文本, 欲被替换的子文本5, 用作替换的子文本5, 替换的起始位置, 替换进行的次数, 是否区分大小写)
    .如果结束
    返回 (局_文本)

.子程序 文本_投递, , 公开, 向指定窗口句柄的窗口中后台发送文本内容,对游戏有效(无返回值)
    .参数 窗口句柄, 整数型, , 接收消息的窗口句柄
    .参数 文本内容, 文本型, , 发送的文本内容

    文本_投递W (窗口句柄, 编码_Ansi到Unicode (文本内容, ))

.子程序 文本_投递W, , 公开, 支持Unicode字符。
    .参数 窗口句柄, 整数型
    .参数 文本内容, 字节集, , unicode编码
    .局部变量 计次, 整数型

    .变量循环首 (1, 取字节集长度 (文本内容) － 2, 2, 计次)
        键盘_消息 (窗口句柄, 取字节集数据 (文本内容, #短整数型, 计次), 1, 假)
    .变量循环尾 ()

.子程序 文本_颠倒, 文本型, 公开, 将指定文本倒序 (比如:"123456"倒序后成:"654321")
    .参数 欲转换文本, 文本型, , 欲倒序的文本
    .参数 带有中文, 逻辑型, 可空, 如果要颠倒的文本中带有汉字，请把此参数设置为真。
    .局部变量 字符数, 整数型
    .局部变量 倒序内容, 文本型
    .局部变量 循环变量, 整数型
    .局部变量 字节集, 字节集
    .局部变量 局_结果, 字节集
    .局部变量 i, 整数型

    .如果真 (带有中文)
        字节集 ＝ 编码_Ansi到Unicode (欲转换文本, 真)
        .变量循环首 (取字节集长度 (字节集) － 1, 1, -2, i)
            局_结果 ＝ 局_结果 ＋ 取字节集中间 (字节集, i, 2)
        .变量循环尾 ()
        返回 (编码_Unicode到Ansi (局_结果))
    .如果真结束
    字符数 ＝ 取文本长度 (到文本 (欲转换文本))
    .变量循环首 (1, 字符数, 1, 循环变量)
        倒序内容 ＝ 倒序内容 ＋ 取文本中间 (欲转换文本, 字符数 ＋ 1 － 循环变量, 1)
    .变量循环尾 ()
    返回 (倒序内容)

.子程序 文本_发送, , 公开, 向指定文本框后台发送文本(无返回值)
    .参数 文本框句柄, 整数型, , 文本框的句柄
    .参数 发送的内容, 文本型, , 要发送的文本

    SendMessageA (文本框句柄, 194, 1, 取指针文本_ (发送的内容))

.子程序 文本_粘贴, , 公开, 往指定的窗口粘贴文本
    .参数 窗口句柄, 整数型, 可空, 欲粘贴文本的窗口句柄
    .参数 文本内容, 文本型, 可空, 欲粘贴的文本内容
    .局部变量 局_文本, 文本型

    局_文本 ＝ 取剪辑板文本 ()
    .如果真 (是否为空 (文本内容) ＝ 假)
        置剪辑板文本 (文本内容)
    .如果真结束
    SendMessageA (窗口句柄, 770, 0, 0)
    置剪辑板文本 (局_文本)

.子程序 文本_全选, , 公开, 让指定的文本框内容全部选中
    .参数 文本框句柄, 整数型, , 文本框的句柄
    .参数 类型, 整数型, 可空, 默认为0全选，1=取消全选

    .如果 (类型 ＝ 0)
        SendMessageA (文本框句柄, 177, 0, -1)
    .否则
        SendMessageA (文本框句柄, 177, 0, 0)
    .如果结束
    

.子程序 文本_去重复文本, 文本型, 公开, 去除原文本中重复的文本
    .参数 原文本, 文本型
    .参数 分割符, 文本型, 可空, 原文本单个内容间的分隔符，例如：---  留空为：逐字分割
    .局部变量 局_数组, 文本型, , "0"
    .局部变量 局_数组1, 文本型, , "0"
    .局部变量 局_计次, 整数型
    .局部变量 局_文本, 文本型

    .如果 (是否为空 (分割符))
        文本_逐字分割 (原文本, 局_数组)
    .否则
        局_数组 ＝ 分割文本 (原文本, 分割符, )
    .如果结束
    
    
    .计次循环首 (取数组成员数 (局_数组), 局_计次)
        .如果真 (内部_数组成员是否存在_文本 (局_数组1, 局_数组 [局_计次]) ＝ -1)
            加入成员 (局_数组1, 局_数组 [局_计次])
            局_文本 ＝ 局_文本 ＋ 局_数组 [局_计次] ＋ 分割符
        .如果真结束
        
    .计次循环尾 ()
    局_文本 ＝ 取文本左边 (局_文本, 取文本长度 (局_文本) － 取文本长度 (分割符))
    返回 (局_文本)

.子程序 内部_数组成员是否存在_文本, 整数型
    .参数 数组, 文本型, 数组
    .参数 要判断值, 文本型
    .局部变量 局_计次, 整数型

    .计次循环首 (取数组成员数 (数组), 局_计次)
        .如果真 (数组 [局_计次] ＝ 要判断值)
            返回 (局_计次)
        .如果真结束
        
    .计次循环尾 ()
    返回 (-1)

.子程序 内部_数组成员是否存在_整数, 整数型
    .参数 数组, 整数型, 数组
    .参数 要判断值, 整数型
    .局部变量 局_计次, 整数型

    .计次循环首 (取数组成员数 (数组), 局_计次)
        .如果真 (数组 [局_计次] ＝ 要判断值)
            返回 (局_计次)
        .如果真结束
        
    .计次循环尾 ()
    返回 (-1)
    

.子程序 数组_排序, , 公开, 二分法排序.只能对文本数组进行排序,整数数组请用核心支持库的.
    .参数 要排序的数组, 文本型, 参考 数组
    .参数 排序方式, 字节型, 可空, 可空,默认为0  0=升序排序 1=降序排序
    .参数 区分大小写, 逻辑型, 可空, 可空,默认“真”。真=区分大小写，假=不区分
    .局部变量 N, 整数型
    .局部变量 排序数组, 文本型, , "0"
    .局部变量 成员数量, 整数型
    .局部变量 高位, 整数型
    .局部变量 低位, 整数型
    .局部变量 中间位, 整数型
    .局部变量 比较结果, 整数型, , , 感谢会员 落雪 提供代码

    复制数组 (排序数组, 要排序的数组)
    清除数组 (要排序的数组)
    .如果真 (是否为空 (区分大小写) ＝ 真)
        区分大小写 ＝ 真
    .如果真结束
    
    .计次循环首 (取数组成员数 (排序数组), N)
        .判断开始 (成员数量 ＝ 0)
            插入成员 (要排序的数组, 1, 排序数组 [N])
        .默认
            
            高位 ＝ 成员数量
            低位 ＝ 1
            中间位 ＝ (高位 ＋ 低位) ＼ 2
            ' ; lstrcmp 通过比较ASCII码进行文本的排序,速度快,但存在问题
            .判断开始 (区分大小写 ＝ 假)
                比较结果 ＝ 文本比较 (到大写 (排序数组 [N]), 到大写 (要排序的数组 [成员数量]), 真) ' 不区分就都算大写好了.因为在ACSII码中,大小写字母都是挨着的,所以不会出现"夹"在中间的字符.
            .默认
                比较结果 ＝ 文本比较 (排序数组 [N], 要排序的数组 [成员数量], 真)
            .判断结束
            
            .判断开始 (比较结果 ≥ 0)
                插入成员 (要排序的数组, 成员数量 ＋ 1, 排序数组 [N])
            .判断 (文本比较 (排序数组 [N], 要排序的数组 [1], 真) ≤ 0)
                插入成员 (要排序的数组, 1, 排序数组 [N])
            .默认
                .判断循环首 (高位 － 低位 ＞ 1)
                    .如果真 (排序数组 [N] ＝ 要排序的数组 [中间位])
                        跳出循环 ()
                    .如果真结束
                    .如果 (文本比较 (排序数组 [N], 要排序的数组 [中间位], 真) ＜ 0)
                        高位 ＝ 中间位
                    .否则
                        低位 ＝ 中间位
                    .如果结束
                    中间位 ＝ (高位 ＋ 低位) ＼ 2
                .判断循环尾 ()
                .判断开始 (文本比较 (排序数组 [N], 要排序的数组 [中间位], 真) ≤ 0)
                    插入成员 (要排序的数组, 中间位, 排序数组 [N])
                .默认
                    插入成员 (要排序的数组, 中间位 ＋ 1, 排序数组 [N])
                .判断结束
                
            .判断结束
            
        .判断结束
        成员数量 ＝ 取数组成员数 (要排序的数组)
    .计次循环尾 ()
    .如果真 (排序方式 ＝ 1)
        数组_反转 (要排序的数组)
    .如果真结束
    

.子程序 数组_排序1, , 公开, 通过对字符串逻辑比较后的排序
    .参数 排序数组, 文本型, 数组
    .参数 从大到小, 逻辑型, 可空
    .局部变量 dwCount, 整数型
    .局部变量 szBuf1, 字节集
    .局部变量 szBuf2, 字节集
    .局部变量 pBuffer, 整数型
    .局部变量 psz1, 整数型
    .局部变量 psz2, 整数型
    .局部变量 i, 整数型
    .局部变量 n, 整数型
    .局部变量 j, 整数型

    dwCount ＝ 取数组成员数 (排序数组)
    pBuffer ＝ 取数据_通用型_数组 (排序数组)
    .计次循环首 (dwCount, i)
        n ＝ i
        .计次循环首 (dwCount － i, j)
            szBuf1 ＝ 编码_Ansi到Unicode (排序数组 [n], )
            szBuf2 ＝ 编码_Ansi到Unicode (排序数组 [i ＋ j], )
            .如果 (从大到小)
                .如果真 (StrCmpLogicalW (szBuf1, szBuf2) ＜ 0)
                    n ＝ i ＋ j
                .如果真结束
                
            .否则
                .如果真 (StrCmpLogicalW (szBuf1, szBuf2) ＞ 0)
                    n ＝ i ＋ j
                .如果真结束
                
            .如果结束
            
        .计次循环尾 ()
        .如果真 (n ≠ i)
            psz1 ＝ __get (pBuffer, (n － 1) × 4)
            psz2 ＝ __get (pBuffer, (i － 1) × 4)
            __set (pBuffer, (n － 1) × 4, psz2)
            __set (pBuffer, (i － 1) × 4, psz1)
        .如果真结束
        
    .计次循环尾 ()

.子程序 数组_寻找数组, 整数型, 公开, 寻找指定成员在数组中出现的次数，
    .参数 待查找的数组, 文本型, 数组
    .参数 待查找的成员, 文本型
    .参数 寻找到的数组, 整数型, 参考 数组, 返回出现的位置数组信息
    .局部变量 i, 整数型

    清除数组 (寻找到的数组)
    .计次循环首 (取数组成员数 (待查找的数组), i)
        ' 系统_处理事件 ()
        .如果真 (待查找的成员 ＝ 待查找的数组 [i])
            加入成员 (寻找到的数组, i)
        .如果真结束
        
    .计次循环尾 ()
    返回 (取数组成员数 (寻找到的数组))

.子程序 数组_反转, , 公开, 数组倒序。数组的第一个成员与最后一个成员互换，第二个和倒数第二个互换，以此类推
    .参数 反转的数组, 文本型, 参考 数组
    .局部变量 成员数量, 整数型
    .局部变量 折中数量, 整数型
    .局部变量 N, 整数型

    成员数量 ＝ 取数组成员数 (反转的数组)
    折中数量 ＝ 成员数量 ÷ 2
    .计次循环首 (折中数量, N)
        文本_交换变量 (反转的数组 [N], 反转的数组 [成员数量])
        成员数量 ＝ 成员数量 － 1
    .计次循环尾 ()

.子程序 文本_交换变量
    .参数 参数一, 文本型
    .参数 参数二, 文本型

    置入代码 ({ 139, 69, 8, 139, 77, 12, 139, 16, 135, 17, 137, 16 })
    ' mov eax,[ebp+8]
    ' mov ecx,[ebp+12]
    ' mov edx,dword ptr ds:[eax]
    ' xchg dword ptr ds:[ecx],edx
    ' mov dword ptr ds:[eax],edx

.子程序 数组_输出, , 公开, 输出数组,方便查看
    .参数 文本数组, 文本型, 可空 数组
    .参数 整数数组, 整数型, 可空 数组
    .局部变量 i, 整数型
    .局部变量 局_文本, 文本型

    .如果真 (是否为空 (文本数组) ＝ 假)
        局_文本 ＝ “文本数组 - ”
        .计次循环首 (取数组成员数 (文本数组), i)
            局_文本 ＝ 局_文本 ＋ “成员” ＋ 到文本 (i) ＋ “(” ＋ 文本数组 [i] ＋ “)  ”
        .计次循环尾 ()
        输出调试文本 (删首尾空 (局_文本))
    .如果真结束
    
    .如果真 (是否为空 (整数数组) ＝ 假)
        局_文本 ＝ “整数数组 - ”
        .计次循环首 (取数组成员数 (整数数组), i)
            局_文本 ＝ 局_文本 ＋ “成员” ＋ 到文本 (i) ＋ “(” ＋ 到文本 (整数数组 [i]) ＋ “)  ”
        .计次循环尾 ()
        输出调试文本 (删首尾空 (局_文本))
    .如果真结束
    

.子程序 数组_合并, 文本型, 公开, 连接数组，类似VB中的join方法,合并一个文本数组到字符串。
    .参数 文本数组, 文本型, 数组
    .参数 合并字符, 文本型, 可空, 可空，默认为,
    .局部变量 i, 整数型
    .局部变量 返回文本, 文本型

    合并字符 ＝ 选择 (是否为空 (合并字符), “,”, 合并字符)
    .计次循环首 (取数组成员数 (文本数组), i)
        .如果 (i ＝ 1)
            返回文本 ＝ 文本数组 [i]
        .否则
            返回文本 ＝ 返回文本 ＋ 合并字符 ＋ 文本数组 [i]
        .如果结束
        
    .计次循环尾 ()
    返回 (返回文本)

.子程序 数组_合并_快速, 文本型, 公开, @福仔 把数组里所有的成员组合成一个文本
    .参数 欲处理的数组, 文本型, 数组
    .参数 间隔符, 文本型, 可空
    .局部变量 pArr, 整数型, , , 数组指针
    .局部变量 len, 整数型, , , 数组长度
    .局部变量 i, 整数型
    .局部变量 bufSize, 整数型
    .局部变量 pBuf, 整数型
    .局部变量 pSub, 整数型
    .局部变量 nSub, 整数型
    .局部变量 offset, 整数型
    .局部变量 strLen, 整数型
    .局部变量 pStr, 整数型
    .局部变量 nStr, 整数型
    .局部变量 pTmp, 整数型
    .局部变量 tmpSize, 整数型
    .局部变量 ret, 文本型

    len ＝ 取数组成员数 (欲处理的数组)
    .如果真 (len ＝ 0)
        返回 (“”)
    .如果真结束
    pArr ＝ 取数据_通用型_数组 (欲处理的数组) ' 数组数据指针
    bufSize ＝ len × 260 ' 缓冲区长度
    pBuf ＝ malloc (bufSize ＋ 1) ' 缓冲区
    .如果真 (取反 (是否为空 (间隔符))) ' 间隔符
        pSub ＝ 取指针_文本型 (间隔符)
        .如果真 (pSub ≠ 0) ' 防止用户传递 字符(0)
            nSub ＝ strlen (pSub)
        .如果真结束
        
    .如果真结束
    
    .计次循环首 (len, i)
        pStr ＝ __get (pArr, (i － 1) × 4) ' 取出数组成员
        .如果真 (pStr ≠ 0)
            nStr ＝ strlen (pStr) ' 成员长度
            .如果真 (offset ＋ nStr ＞ bufSize) ' 内存超了, 需要重新分配
                tmpSize ＝ bufSize
                bufSize ＝ bufSize × 2 ＋ nStr ' 原来是内存扩充一倍
                ' pBuf ＝ realloc (bufSize)
                pTmp ＝ malloc (bufSize)
                memcpy (pTmp, pBuf, tmpSize) ' 拷贝原来的数据, 然后释放
                free (pBuf)
                pBuf ＝ pTmp
            .如果真结束
            
            memcpy (pBuf ＋ offset, pStr, nStr)
            offset ＝ offset ＋ nStr
        .如果真结束
        
        .如果真 (pSub ≠ 0 且 i ＜ len)
            memcpy (pBuf ＋ offset, pSub, nSub)
            offset ＝ offset ＋ nSub
        .如果真结束
        
    .计次循环尾 ()
    __set_byte (pBuf, offset, 0) ' 结束标识
    
    ret ＝ 指针到文本 (pBuf)
    free (pBuf)
    返回 (ret)

.子程序 数组_去重复, 整数型, 公开, 返回剩余不重复数组的成员数量，可处理特殊字符效率较慢
    .参数 文本数组, 文本型, 可空 数组, 要去重复的 文本数组
    .参数 整数数组, 整数型, 可空 数组, 要去重复的 整数数组
    .局部变量 局_文本数组, 文本型, 数组, "0"
    .局部变量 局_整数数组, 整数型, 数组, "0"
    .局部变量 局_计次, 整数型

    .如果真 (是否为空 (文本数组) ＝ 假)
        .计次循环首 (取数组成员数 (文本数组), 局_计次)
            .如果真 (内部_数组成员是否存在_文本 (局_文本数组, 文本数组 [局_计次]) ＝ -1)
                加入成员 (局_文本数组, 文本数组 [局_计次])
            .如果真结束
            
        .计次循环尾 ()
        文本数组 ＝ 局_文本数组
        返回 (取数组成员数 (文本数组))
    .如果真结束
    
    .如果真 (是否为空 (整数数组) ＝ 假)
        .计次循环首 (取数组成员数 (整数数组), 局_计次)
            .如果真 (内部_数组成员是否存在_整数 (局_整数数组, 整数数组 [局_计次]) ＝ -1)
                加入成员 (局_整数数组, 整数数组 [局_计次])
            .如果真结束
            
        .计次循环尾 ()
        整数数组 ＝ 局_整数数组
        返回 (取数组成员数 (整数数组))
    .如果真结束
    返回 (0)

.子程序 数组_取次数, 整数型, 公开, 取指定数组成员出现相同数量，源码由易友【C盘是头猪】提供。
    .参数 参数_数组, 文本型, 数组
    .参数 参数_成员, 文本型
    .局部变量 n, 整数型
    .局部变量 i, 整数型

    .计次循环首 (取数组成员数 (参数_数组), i)
        .如果真 (参数_数组 [i] ＝ 参数_成员)
            n ＝ n ＋ 1
        .如果真结束
        处理事件 ()
    .计次循环尾 ()
    返回 (n)

.子程序 文本_取长度, 整数型, 公开, 取一段文本的长度，中文算两个长度，字母算一个长度
    .参数 源文本, 文本型

    返回 (lstrlenA (取指针文本_ (源文本)))

.子程序 文本_取长度W, 整数型, 公开, 取一段文本的长度，中文和字母都算一个长度
    .参数 源文本, 字节集, , Unicode字节集

    返回 (lstrlenW (取指针_字节集型 (源文本)))

.子程序 文本_取声母, 文本型, 公开, 取一组文本中每个字的拼音首字,如果不是中文就直接取
    .参数 文本, 文本型, , 转换前文本
    .局部变量 欲变换的文本, 文本型
    .局部变量 循环次数, 整数型
    .局部变量 结果, 文本型

    欲变换的文本 ＝ 到全角 (文本)
    .计次循环首 (取文本长度 (欲变换的文本), 循环次数)
        .判断开始 (取代码 (到半角 (取文本中间 (欲变换的文本, 循环次数 × 2 － 1, 2)), ) ＞ 0)
            结果 ＝ 结果 ＋ 到半角 (取文本中间 (欲变换的文本, 循环次数 × 2 － 1, 2))
        .默认
            结果 ＝ 结果 ＋ 取文本左边 (取声母 (取文本中间 (欲变换的文本, 循环次数 × 2 － 1, 2), 1), 1)
        .判断结束
        
    .计次循环尾 ()
    返回 (结果)

.子程序 文本_到小写, 文本型, 公开, 把字母转换到小写
    .参数 要转换的文本, 文本型, , 要转换的文本
    .局部变量 局_欲转换的文本, 文本型

    局_欲转换的文本 ＝ 要转换的文本
    返回 (CharLowerA (局_欲转换的文本))

.子程序 文本_到小写EX, 文本型, 公开, 把字母转换到小写
    .参数 要转换的文本, 文本型, , 要转换的文本
    .局部变量 局_转换, 文本型

    局_转换 ＝ 要转换的文本
    返回 (API_文本小写 (局_转换))

.子程序 文本_到小写m, 文本型, 公开, 将文本中的大写英文字母变换为小写，返回变换后的结果文本。本命令为初级命令。
    .参数 欲变换的文本, 文本型

    置入代码 ({ 81 }) ' 00445FC0      51            push ecx
    置入代码 ({ 82 }) ' 00445FC1      52            push edx
    置入代码 ({ 83 }) ' 00445FC2      53            push ebx
    置入代码 ({ 86 }) ' 00445FC3      56            push esi
    置入代码 ({ 87 }) ' 00445FC4      57            push edi
    
    ' -------------------------------------------------------------------
    RtlAllocateHeap (GetProcessHeap (), 0, 32) ' 申请一块栈空间地址
    ' 置入代码 ({ 139, 248 })  ' 8BF8          mov edi,eax           ;  目的内存地址
    置入代码 ({ 80 }) ' 50            push eax                    ;  保存内存地址
    
    ' ------------取参数<欲变换的文本>长度------------------------------
    置入代码 ({ 139, 125, 8 }) ' 8B7D 08       mov edi,dword ptr ss:[ebp+0x8]
    置入代码 ({ 139, 63 }) ' 8B3F          mov edi,dword ptr ds:[edi]
    置入代码 ({ 139, 247 }) ' 8BF7               mov esi,edi
    置入代码 ({ 131, 201, 255 }) ' 83C9 FF       or ecx,0xFFFFFFFF
    置入代码 ({ 51, 192 }) ' 33C0          xor eax,eax
    置入代码 ({ 242, 174 }) ' F2:AE         repne scas byte ptr es:[edi]
    置入代码 ({ 247, 209 }) ' F7D1          not ecx
    置入代码 ({ 73 }) ' 49            dec ecx
    置入代码 ({ 95 }) ' 5F              pop edi
    置入代码 ({ 87 }) ' 57              push edi
    ' -------------复制内容到刚申请的内存地址里-------------------------------------------
    置入代码 ({ 139, 217 }) ' 8BD9             mov ebx,ecx
    置入代码 ({ 193, 233, 2 }) ' C1E9 02          shr ecx,0x2
    置入代码 ({ 38, 243, 165 }) ' 26:F3:A5         rep movs dword ptr es:[edi],dword ptr es:[esi]
    置入代码 ({ 139, 203 }) ' 8BCB             mov ecx,ebx
    置入代码 ({ 131, 225, 3 }) ' 83E1 03          and ecx,0x3
    置入代码 ({ 243, 164 }) ' F3:A4            rep movs byte ptr es:[edi],byte ptr [esi]
    置入代码 ({ 198, 7, 0 }) ' C607 00          mov byte ptr [edi],0x0
    ' ---------------转大写-----------------------------------------------------------------
    置入代码 ({ 51, 210 }) ' 33D2             xor edx,edx
    置入代码 ({ 88 }) ' 58               pop eax
    置入代码 ({ 139, 248 }) ' 8BF8          mov edi,eax
    
    置入代码 ({ 128, 60, 58, 65 }) ' 803C3A 41       cmp byte ptr [edx+edi],0x41
    置入代码 ({ 124, 10 }) ' 7C 0A           jl X0040112F
    置入代码 ({ 128, 60, 58, 90 }) ' 803C3A 5A       cmp byte ptr [edx+edi],0x5A
    置入代码 ({ 127, 4 }) ' 7F 04           jg X0040112F
    置入代码 ({ 128, 12, 58, 32 }) ' 800C3A 20       or byte ptr [edx+edi],0x20
    
    置入代码 ({ 128, 60, 58, 0 }) ' 803C3A 00       cmp byte ptr [edx+edi],0x0
    置入代码 ({ 116, 3 }) ' 74 03            je X0040101E
    置入代码 ({ 66 }) ' 42               inc edx
    置入代码 ({ 235, 231 }) ' EB E7            jmp X00401005
    ' -------------恢复寄存器原状态-------------------------------------------------------------
    置入代码 ({ 95 }) ' 00445FC5      5F            pop edi
    置入代码 ({ 94 }) ' 00445FC6      5E            pop esi
    置入代码 ({ 91 }) ' 00445FC7      5B            pop ebx
    置入代码 ({ 90 }) ' 00445FC8      5A            pop edx
    置入代码 ({ 89 }) ' 00445FC9      59            pop ecx
    置入代码 ({ 201 }) ' C9                       leave
    置入代码 ({ 194, 4, 0 }) ' C2 0400       retn 0x4
    返回 (“”)

.子程序 文本_到大写, 文本型, 公开, 把字母转换到大写
    .参数 要转换的文本, 文本型, , 要转换的文本
    .局部变量 局_欲转换的文本, 文本型

    局_欲转换的文本 ＝ 要转换的文本
    返回 (CharUpperA (局_欲转换的文本))

.子程序 文本_折行, 文本型, 公开, 把一段长文本按你指定的字数分行
    .参数 要处理的文本, 文本型
    .参数 每行字数, 整数型, 可空, 半角字数，如果为空，将不进行分行操作，直接返回文本内容，如果包含文本或全角字符，则需要把每行字数至少设置为2
    .参数 是否强行分行, 逻辑型, 可空, 为真则强行按设定长度分行。为假则保留连续半角数字或字母为一行。默认为假。
    .参数 是否全角, 逻辑型, 可空, 是否将半角转换为全角,如果为空即不转换
    .参数 首空字节数, 整数型, 可空, 在每行前面加入空格,如果为空,为0,即不加空格
    .局部变量 操作文本, 文本型
    .局部变量 开始位置, 整数型
    .局部变量 读取长度, 整数型
    .局部变量 开始计算半角, 逻辑型
    .局部变量 半角位置, 整数型
    .局部变量 结果文本, 文本型

    .如果真 (是否为空 (每行字数))
        返回 (要处理的文本)
    .如果真结束
    .如果真 (是否为空 (是否强行分行))
        是否强行分行 ＝ 假
    .如果真结束
    .如果真 (是否全角 ＝ 真)
        要处理的文本 ＝ 子文本替换 (要处理的文本, “...”, “…”, 1, , 真)
        要处理的文本 ＝ 子文本替换 (要处理的文本, “->”, “→”, 1, , 真)
        要处理的文本 ＝ 子文本替换 (要处理的文本, “<-”, “←”, 1, , 真)
        要处理的文本 ＝ 子文本替换 (要处理的文本, “--”, “—”, 1, , 真)
        要处理的文本 ＝ 到全角 (要处理的文本)
    .如果真结束
    .如果真 (首空字节数 ≥ 1)
        要处理的文本 ＝ 取空白文本 (首空字节数) ＋ 要处理的文本
        要处理的文本 ＝ 子文本替换 (要处理的文本, #换行符, #换行符 ＋ 取空白文本 (首空字节数), 1, , 真)
    .如果真结束
    操作文本 ＝ 要处理的文本
    .判断循环首 (取文本长度 (操作文本) ＞ 每行字数)
        .判断循环首 (读取长度 ＜ 每行字数)
            ' 首先这里存在2个情况，一个是如果为全角或汉字。则他们1位是2个长度，直接取是取不出来的。
            .如果 (取代码 (操作文本, 读取长度 ＋ 1) ≥ 127 或 取代码 (操作文本, 读取长度 ＋ 1) ＜ 0)
                ' 如果不是半角的话。则需要把读取长度增加到2
                半角位置 ＝ 0
                开始计算半角 ＝ 假
                .如果真 (读取长度 ＝ 每行字数 － 1)
                    输出调试文本 (“文本_折行 - 注意：检测到文本中包含中文或全角字符，需要把每行字数至少设置为2.”)
                    ' 返回 (“”)
                    跳出循环 ()
                .如果真结束
                读取长度 ＝ 读取长度 ＋ 2
            .否则
                .判断开始 (取文本中间 (操作文本, 读取长度 ＋ 1, 1) ＝ “ ”)
                    读取长度 ＝ 读取长度 ＋ 1
                    半角位置 ＝ 0
                    开始计算半角 ＝ 假
                .判断 (取文本中间 (操作文本, 读取长度 ＋ 1, 2) ＝ #换行符)
                    读取长度 ＝ 读取长度 ＋ 2
                    跳出循环 ()
                .默认
                    .如果真 (开始计算半角 ＝ 假)
                        半角位置 ＝ 读取长度
                        开始计算半角 ＝ 真
                    .如果真结束
                    读取长度 ＝ 读取长度 ＋ 1
                .判断结束
                
            .如果结束
            
        .判断循环尾 ()
        .如果真 (读取长度 ≥ 每行字数)
            .如果 (是否强行分行 ＝ 假)
                读取长度 ＝ 选择 (半角位置 ＝ 0, 每行字数, 选择 (取代码 (操作文本, 每行字数 ＋ 1) ≥ 127 或 取代码 (操作文本, 每行字数 ＋ 1) ＜ 0, 每行字数, 半角位置))
                开始计算半角 ＝ 假
                半角位置 ＝ 0
            .否则
                读取长度 ＝ 每行字数
            .如果结束
            
        .如果真结束
        .如果真 (是否强行分行 ＝ 假)
            .如果 (取文本中间 (操作文本, 读取长度 － 1, 2) ＝ “《” 或 取文本中间 (操作文本, 读取长度 － 1, 2) ＝ “（” 或 取文本中间 (操作文本, 读取长度 － 1, 2) ＝ #左引号 或 取文本中间 (操作文本, 读取长度 － 1, 2) ＝ “〈” 或 取文本中间 (操作文本, 读取长度 － 11, 2) ＝ “‘”)
                读取长度 ＝ 读取长度 － 2
            .否则
                .如果真 (取文本中间 (操作文本, 读取长度 ＋ 1, 2) ＝ “》” 或 取文本中间 (操作文本, 读取长度 ＋ 1, 2) ＝ “）” 或 取文本中间 (操作文本, 读取长度 ＋ 1, 2) ＝ #右引号 或 取文本中间 (操作文本, 读取长度 ＋ 1, 2) ＝ “〉” 或 取文本中间 (操作文本, 读取长度 ＋ 1, 2) ＝ “，” 或 取文本中间 (操作文本, 读取长度 ＋ 1, 2) ＝ “。” 或 取文本中间 (操作文本, 读取长度 ＋ 1, 2) ＝ “？” 或 取文本中间 (操作文本, 读取长度 ＋ 1, 2) ＝ “：” 或 取文本中间 (操作文本, 读取长度 ＋ 1, 2) ＝ “’” 或 取文本中间 (操作文本, 读取长度 ＋ 1, 2) ＝ “；” 或 取文本中间 (操作文本, 读取长度 ＋ 1, 2) ＝ “、”)
                    .如果 (取代码 (操作文本, 读取长度) ≥ 127 或 取代码 (操作文本, 读取长度) ＜ 0)
                        读取长度 ＝ 读取长度 － 2
                    .否则
                        读取长度 ＝ 读取长度 － 1
                    .如果结束
                    
                .如果真结束
                
            .如果结束
            
        .如果真结束
        .如果 (取文本中间 (操作文本, 读取长度 － 1, 2) ＝ #换行符)
            结果文本 ＝ 结果文本 ＋ 取文本左边 (操作文本, 读取长度)
        .否则
            结果文本 ＝ 结果文本 ＋ 取文本左边 (操作文本, 读取长度) ＋ #换行符
        .如果结束
        操作文本 ＝ 取文本右边 (操作文本, 取文本长度 (操作文本) － 读取长度)
        读取长度 ＝ 0
    .判断循环尾 ()
    结果文本 ＝ 结果文本 ＋ 操作文本
    返回 (结果文本)

.子程序 文本_删首尾空, 文本型, 公开, 删除一段文本前后的空格
    .参数 源文本, 文本型
    .局部变量 局_欲删除空格的文本, 字节集

    局_欲删除空格的文本 ＝ 到字节集 (源文本) ＋ { 0 }
    PathRemoveBlanksA (取指针_字节集型 (局_欲删除空格的文本))
    返回 (取字节集数据 (局_欲删除空格的文本, #文本型, ))

.子程序 文本_删除空行, 文本型, 公开, 删除文本当中的空白行
    .参数 要操作的文本, 文本型
    .局部变量 正则, 正则表达式类
    .局部变量 szTemp, 文本型

    正则.创建 (“\n\s*\r”, 要操作的文本, , 真, 真, )
    szTemp ＝ 正则.替换 ()
    .如果真 (szTemp ≈ #换行符)
        szTemp ＝ 取文本右边 (szTemp, 取文本长度 (szTemp) － 2)
    .如果真结束
    .如果真 (取文本右边 (szTemp, 2) ＝ #换行符)
        szTemp ＝ 取文本左边 (szTemp, 取文本长度 (szTemp) － 2)
    .如果真结束
    返回 (szTemp)

.子程序 文本_是否重复, 逻辑型, 公开, 判断文本中的指定文本是否有重复，有重复返回真，没得复返回假
    .参数 源文本, 文本型
    .参数 查询的文本, 文本型
    .参数 严格模式, 逻辑型, 可空, 可空。默认为正常模式。
    .局部变量 位置1, 整数型
    .局部变量 位置2, 整数型

    位置1 ＝ 寻找文本 (源文本, 查询的文本, , 真)
    .如果 (严格模式)
        返回 (寻找文本 (源文本, 查询的文本, 位置1 ＋ 1, 真) ＞ 0)
        
    .否则
        .如果真 (位置1 ＜ 1)
            返回 (假)
        .如果真结束
        返回 (寻找文本 (源文本, 查询的文本, 位置1 ＋ 取文本长度 (查询的文本), 真) ＞ 0)
    .如果结束
    返回 (假)

.子程序 文本_取左边, 文本型, 公开, 从文本的左边按 欲寻找的文本 开始寻找
    .参数 被查找的文本, 文本型, , 被查找的文本
    .参数 欲寻找的文本, 文本型, , 欲寻找的文本
    .参数 起始寻找位置, 整数型, 可空, 可为空，默认为1，从左往右寻找，如果为负数，则从右往左寻找。
    .参数 是否不区分大小写, 逻辑型, 可空, 初始值为“假”。为真不区分大小写，为假区分。
    .局部变量 局_长度, 整数型
    .局部变量 局_起始搜寻位置, 整数型
    .局部变量 局_方向, 整数型
    .局部变量 局_找到的位置, 整数型
    .局部变量 局_返回结果, 文本型

    局_长度 ＝ 取文本长度 (被查找的文本)
    
    局_起始搜寻位置 ＝ 起始寻找位置
    .如果真 (局_起始搜寻位置 ＜ 0)
        局_起始搜寻位置 ＝ 局_起始搜寻位置 × -1
        .如果真 (局_起始搜寻位置 ＝ 1)
            局_起始搜寻位置 ＝ 0
        .如果真结束
        局_方向 ＝ 1
    .如果真结束
    
    .如果 (局_方向 ＝ 1)
        局_找到的位置 ＝ 倒找文本 (被查找的文本, 欲寻找的文本, 局_长度 － 局_起始搜寻位置 ＋ 1, 是否不区分大小写)
    .否则
        .如果真 (局_起始搜寻位置 ＝ 0)
            局_起始搜寻位置 ＝ 1
        .如果真结束
        局_找到的位置 ＝ 寻找文本 (被查找的文本, 欲寻找的文本, 局_起始搜寻位置, 是否不区分大小写)
    .如果结束
    
    .如果真 (局_找到的位置 ＝ -1)
        返回 (“”)
    .如果真结束
    
    局_返回结果 ＝ 取文本左边 (被查找的文本, 局_找到的位置 － 1)
    返回 (局_返回结果)

.子程序 文本_取右边, 文本型, 公开, 从文本的右边按 欲寻找的文本 开始寻找, 取行右边 (“1234567890”, “5”, 1, 真)
    .参数 被查找的文本, 文本型, , 被查找的文本
    .参数 欲寻找的文本, 文本型, , 欲寻找的文本
    .参数 起始寻找位置, 整数型, 可空, 可为空，默认为1，从右往左寻找，如果为负数，则从左往右寻找。
    .参数 是否不区分大小写, 逻辑型, 可空, 默认为假,区分大小写
    .局部变量 局_长度, 整数型
    .局部变量 局_起始搜寻位置, 整数型
    .局部变量 局_方向, 整数型
    .局部变量 局_找到的位置, 整数型
    .局部变量 局_返回结果, 文本型

    局_长度 ＝ 取文本长度 (被查找的文本)
    
    局_起始搜寻位置 ＝ 起始寻找位置
    .如果真 (局_起始搜寻位置 ＜ 0)
        局_起始搜寻位置 ＝ 局_起始搜寻位置 × -1
        .如果真 (局_起始搜寻位置 ＝ 1)
            局_起始搜寻位置 ＝ 0
        .如果真结束
        局_方向 ＝ 1
    .如果真结束
    
    .如果 (局_方向 ＝ 1)
        .如果真 (局_起始搜寻位置 ＝ 0)
            局_起始搜寻位置 ＝ 1
        .如果真结束
        局_找到的位置 ＝ 寻找文本 (被查找的文本, 欲寻找的文本, 局_起始搜寻位置, 是否不区分大小写)
    .否则
        局_找到的位置 ＝ 倒找文本 (被查找的文本, 欲寻找的文本, 局_长度 － 局_起始搜寻位置 ＋ 1, 是否不区分大小写)
    .如果结束
    
    .如果真 (局_找到的位置 ＝ -1)
        返回 (“”)
    .如果真结束
    
    局_返回结果 ＝ 取文本右边 (被查找的文本, 局_长度 － 取文本长度 (欲寻找的文本) － 局_找到的位置 ＋ 1)
    返回 (局_返回结果)

.子程序 文本_取首拼, 文本型, 公开, 取出给出文本的首拼;注:英文,数字,符号则直接返回.首拼一律为小写[V雪落有声V]
    .参数 文本, 文本型, , 需要取出首拼的文本.可以包含数字,字母.请使用半角格式.
    .局部变量 局_半角文本, 文本型
    .局部变量 局_计次, 整数型
    .局部变量 局_文本, 文本型
    .局部变量 局_返回文本, 文本型

    局_计次 ＝ 1
    局_半角文本 ＝ 到半角 (文本)
    .判断循环首 (局_计次 ≤ 取文本长度 (局_半角文本))
        局_文本 ＝ 取文本中间 (局_半角文本, 局_计次, 1)
        .如果 (取代码 (局_文本, ) ＜ 0)
            局_文本 ＝ 取文本中间 (局_半角文本, 局_计次, 2)
            .如果真 (文本_是否为汉字 (局_文本))
                局_文本 ＝ 取文本左边 (取拼音 (局_文本, 1), 1)
                局_返回文本 ＝ 局_返回文本 ＋ 局_文本
            .如果真结束
            局_计次 ＝ 局_计次 ＋ 1
        .否则
            局_返回文本 ＝ 局_返回文本 ＋ 局_文本
        .如果结束
        局_计次 ＝ 局_计次 ＋ 1
    .判断循环尾 ()
    返回 (局_返回文本)

.子程序 文本_取空白文本, 文本型, 公开, 汇编方式申请空白文本, 返回具有指定数目半角空格的文本; 注意, 命令本身不会处理内存释放, 请不要连续反复调用
    .参数 文本长度, 整数型
    .局部变量 address, 整数型

    address ＝ HeapAlloc (GetProcessHeap (), #HEAP_ZERO_MEMORY, 文本长度 ＋ 8)
    RtlFillMemory_字节 (address, 文本长度, 32)
    置入代码 ({ 139, 69, 8, 3, 69, 252, 139, 69, 252, 137, 236, 93, 194, 4, 0 })
    ' mov eax,[ebp+8]
    ' add eax,[ebp-4]
    ' mov eax,[ebp-4]
    ' mov esp,ebp
    ' pop ebp
    ' retn 4
    返回 (“”)

.子程序 文本_取行数, 整数型, 公开, 取一个文本共有有多少行。
    .参数 文本, 文本型

    置入代码 ({ 87, 51, 192, 139, 125, 8, 139, 63, 133, 255, 116, 24, 51, 201, 138, 15, 71, 128, 249, 10, 117, 1, 64, 132, 201, 117, 243, 138, 79, 255, 128, 249, 10, 116, 1, 64, 95, 139, 229, 93, 194, 4, 0 })
    返回 (0)

.子程序 文本_转拼音, 文本型, 公开, 把一段文本转换到拼音
    .参数 欲转拼音的文本, 文本型
    .参数 是否加空格, 逻辑型, 可空, 可空,默认为假,不加;
    .参数 是否全角, 逻辑型, 可空, 可空，默认为假，半角
    .参数 是否正则, 逻辑型, 可空, 是否正则方式判断，可以判断生僻的汉字，可空，默认为假 
    .局部变量 局_文本, 文本型
    .局部变量 局_字符数量, 整数型
    .局部变量 局_计次, 整数型
    .局部变量 局_结果, 文本型

    欲转拼音的文本 ＝ 到全角 (欲转拼音的文本)
    局_字符数量 ＝ 取文本长度 (欲转拼音的文本) ÷ 2
    .计次循环首 (局_字符数量, 局_计次)
        局_文本 ＝ 取文本中间 (欲转拼音的文本, 局_计次 × 2 － 1, 2)
        .如果 (文本_是否为汉字 (局_文本, 是否正则))
            .判断开始 (是否加空格)
                局_结果 ＝ 局_结果 ＋ 取拼音 (局_文本, 1) ＋ “ ”
            .默认
                局_结果 ＝ 局_结果 ＋ 取拼音 (局_文本, 1)
            .判断结束
            
        .否则
            .判断开始 (是否全角)
                局_结果 ＝ 局_结果 ＋ 到全角 (局_文本)
            .默认
                局_结果 ＝ 局_结果 ＋ 到半角 (局_文本)
            .判断结束
            
        .如果结束
        
    .计次循环尾 ()
    欲转拼音的文本 ＝ 到半角 (欲转拼音的文本)
    返回 (局_结果)

.子程序 文本_替换行内容, 文本型, 公开, 替换指定行整行内容，返回替换后的文本。
    .参数 文本, 文本型
    .参数 行数, 整数型
    .参数 替换内容, 文本型
    .局部变量 输出文本, 文本型
    .局部变量 计次, 整数型
    .局部变量 临时文本, 文本型, , "0"
    .局部变量 局_总数, 整数型

    临时文本 ＝ 分割文本 (文本, #换行符, )
    局_总数 ＝ 取数组成员数 (临时文本)
    .如果真 (行数 ＞ 局_总数)
        输出调试文本 (“传入行数大于实际文本行”)
        返回 (“”)
    .如果真结束
    临时文本 [行数] ＝ 替换内容
    .计次循环首 (局_总数, 计次)
        .如果真 (取数组成员数 (临时文本) ≠ 计次)
            输出文本 ＝ 输出文本 ＋ 临时文本 [计次] ＋ #换行符
            到循环尾 ()
        .如果真结束
        输出文本 ＝ 输出文本 ＋ 临时文本 [计次]
    .计次循环尾 ()
    清除数组 (临时文本)
    返回 (输出文本)

.子程序 文本_取随机汉字, 文本型, 公开, 取常用的随机汉字
    .参数 个数, 整数型, , 要取出多少个汉字！
    .参数 汉字或全拼, 整数型, 可空, 0为汉字，否则为全拼音！
    .局部变量 计次, 整数型
    .局部变量 得到的文本, 文本型

    .判断开始 (汉字或全拼 ＝ 0)
        .计次循环首 (个数, 计次)
            得到的文本 ＝ 得到的文本 ＋ 到文本 (字符 (－汇编_取随机数 (38, 80)) ＋ 字符 (－汇编_取随机数 (38, 80)))
        .计次循环尾 ()
    .默认
        .计次循环首 (个数, 计次)
            得到的文本 ＝ 得到的文本 ＋ 取拼音 (到文本 (字符 (－汇编_取随机数 (38, 80)) ＋ 字符 (－汇编_取随机数 (38, 80))), 1)
        .计次循环尾 ()
    .判断结束
    返回 (得到的文本)

.子程序 文本_取随机汉字_快速, 文本型, 公开, 返回指定个数的汉字
    .参数 个数, 整数型
    .局部变量 i, 整数型
    .局部变量 汉字, 字节集
    .局部变量 指针, 整数型

    ' https://bbs.125.la/forum.php?mod=viewthread&tid=14658489
    
    置随机数种子 ()
    汉字 ＝ 取空白字节集 (左移 (个数, 1))
    .变量循环首 (1, 左移 (个数, 1), 2, i)
        汉字 [i] ＝ 取随机数 (176, 247) ' 176-0xF7
        汉字 [i ＋ 1] ＝ 取随机数 (161, 254) ' 161-0xFE
    .变量循环尾 ()
    返回 (到文本 (汉字))

.子程序 文本_取随机字母, 文本型, 公开, 取随机26个字母！
    .参数 要取的字符数, 整数型, , 要取字符个数；
    .参数 字母类型, 整数型, 可空, 可空：默认为小写字母；0=小写字母；1=大写字母；2=大小写字母混合；
    .局部变量 临时文本, 文本型
    .局部变量 大小写, 整数型

    .判断开始 (字母类型 ＝ 0)
        .计次循环首 (要取的字符数, )
            临时文本 ＝ 临时文本 ＋ 字符 (到字节 (汇编_取随机数 (97, 122)))
        .计次循环尾 ()
    .判断 (字母类型 ＝ 1)
        .计次循环首 (要取的字符数, )
            临时文本 ＝ 临时文本 ＋ 字符 (到字节 (汇编_取随机数 (65, 90)))
        .计次循环尾 ()
    .默认
        .计次循环首 (要取的字符数, )
            大小写 ＝ 汇编_取随机数 (0, 1)
            .如果 (大小写 ＝ 1)
                临时文本 ＝ 临时文本 ＋ 字符 (到字节 (汇编_取随机数 (97, 122)))
            .否则
                临时文本 ＝ 临时文本 ＋ 字符 (到字节 (汇编_取随机数 (65, 90)))
            .如果结束
            
        .计次循环尾 ()
    .判断结束
    返回 (临时文本)

.子程序 文本_取随机姓氏, 文本型, 公开, 取出一个随机的百家姓！
    .参数 汉字或全拼, 整数型, 可空, 0为汉字，否则为全拼音！

    .判断开始 (汉字或全拼 ＝ 0)
        返回 (取文本中间 (#百家姓, 到数值 (文本_取随机范围数字 (1, 814, 1)), 2))
    .默认
        返回 (取拼音 (取文本中间 (#百家姓, 到数值 (文本_取随机范围数字 (1, 814, 1)), 2), 1))
    .判断结束
    

.子程序 文本_取随机数字, 文本型, 公开, 汇编_取随机数字，可选单或双！
    .参数 字符数, 整数型, , 要取字符个数
    .参数 单双选择, 整数型, 可空, 0为单双，1为单，其他数值为双；默认单双一起
    .局部变量 返回的文本, 文本型

    .判断开始 (单双选择 ＝ 0)
        .计次循环首 (字符数, )
            返回的文本 ＝ 返回的文本 ＋ 到文本 (汇编_取随机数 (0, 9))
        .计次循环尾 ()
    .判断 (单双选择 ＝ 1)
        .计次循环首 (字符数, )
            返回的文本 ＝ 返回的文本 ＋ 到文本 (多项选择 (汇编_取随机数 (1, 5), 1, 3, 5, 7, 9))
        .计次循环尾 ()
    .默认
        .计次循环首 (字符数, )
            返回的文本 ＝ 返回的文本 ＋ 到文本 (多项选择 (汇编_取随机数 (1, 5), 0, 2, 4, 6, 8))
        .计次循环尾 ()
    .判断结束
    返回 (返回的文本)

.子程序 汇编_取随机数, 整数型, 公开, 返回一个指定范围内的随机数值。在使用本命令取一系列的随机数之前，应该先使用“置随机数种子”命令为随机数生成器初始化一个种子值。本命令为初级命令。
    .参数 欲取随机数的最小值, 整数型, 可空, 参数必须大于或等于零。本参数如果被省略，默认为 0。
    .参数 欲取随机数的最大值, 整数型, 可空, 参数必须大于最小值。本参数如果被省略或小于等于最小值，默认为无限。

    ' 例程来自：https://bbs.125.la/forum.php?mod=redirect&goto=findpost&ptid=13841642&pid=8692203
    置入代码 ({ 81, 82, 15, 49, 105, 192, 253, 67, 3, 0, 5, 195, 158, 38, 0, 193, 232, 16, 37, 255, 127, 0, 0, 139, 77, 16, 133, 201, 117, 5, 185, 255, 255, 255, 127, 43, 77, 8, 65, 51, 210, 247, 241, 3, 85, 8, 139, 194, 90, 89, 139, 229, 93, 194, 16, 0 })
    ' PUSH EBP
    ' MOV EBP, ESP
    ' PUSH ECX
    ' PUSH EDX
    ' RDTSC
    ' IMUL EAX, EAX, 343FDh
    ' ADD EAX, 269EC3h
    ' SHR EAX, 10h
    ' AND EAX, 7FFFh
    ' MOV ECX, DWORD PTR SS:[EBP+10h]
    ' TEST ECX, ECX
    ' JNZ SHORT Jump
    ' MOV ECX, 7FFFFFFFh
    ' @Jump:
    ' SUB ECX, DWORD PTR SS:[EBP+8h]
    ' INC ECX
    ' XOR EDX, EDX
    ' DIV ECX
    ' ADD EDX, DWORD PTR SS:[EBP+8h]
    ' MOV EAX, EDX
    ' POP EDX
    ' POP ECX
    ' MOV ESP, EBP
    ' POP EBP
    ' RETN 10h
    返回 (0)

.子程序 汇编_取随机数_硬件版, 整数型, 公开, 部分CPU不支持 失败返回 0
    .参数 欲取随机数的最小值, 整数型, 可空
    .参数 欲取随机数的最大值, 整数型, 可空

    ' 例程来自：http://bbs.eyuyan.com/read.php?tid=405670
    .判断开始 (IsRdRandSupported ())
        .如果真 (欲取随机数的最小值 ＝ 0)
            欲取随机数的最小值 ＝ 1
        .如果真结束
        .如果真 (欲取随机数的最大值 ＝ 0)
            欲取随机数的最大值 ＝ 9999
        .如果真结束
        
        返回 (RdRand (欲取随机数的最小值, 欲取随机数的最大值))
    .默认
        返回 (0)
    .判断结束
    

.子程序 汇编_取随机数种子_硬件版, 整数型, 公开, 部分CPU不支持 失败返回 0
    ' 例程来自：http://bbs.eyuyan.com/read.php?tid=405670
    .判断开始 (IsRdSeedSupported ())
        返回 (RdSeed ())
    .默认
        返回 (0)
    .判断结束
    

.子程序 IsRdRandSupported, 逻辑型
    置入代码 ({ 184, 1, 0, 0, 0, 15, 162, 49, 192, 15, 186, 225, 30, 17, 192, 201, 195 })
    返回 (假)

.子程序 IsRdSeedSupported, 逻辑型
    置入代码 ({ 184, 7, 0, 0, 0, 49, 201, 15, 162, 49, 192, 15, 186, 227, 18, 17, 192, 201, 195 })
    返回 (假)

.子程序 RdRand, 整数型, , 直接调用取随机数即可 不需要随机种子 By莽
    .参数 Min, 整数型
    .参数 Max, 整数型

    置入代码 ({ 81, 82, 15, 199, 240, 139, 77, 12, 43, 77, 8, 65, 51, 210, 247, 241, 3, 85, 8, 139, 194, 90, 89, 201, 194, 8, 0 })
    返回 (0)

.子程序 RdSeed, 长整数型, , 取随机数种子 作为其他伪随机数的种子 By莽
    置入代码 ({ 15, 199, 248, 201, 195 })
    返回 (0)

.子程序 文本_取随机字符, 文本型, 公开, 取随机可见字符,只取能显示的字符
    .参数 要取的字符数, 整数型, , 要取字符个数
    .参数 获取模式, 整数型, 可空, 获取模式, 1=数字, 2=小写字母, 4=大写字母, 8=特殊字符, 需要多个组合用位或或起来, 默认为1, 只返回数字
    .局部变量 buffer, 字节集
    .局部变量 pBuffer, 整数型
    .局部变量 bufferSize, 整数型
    .局部变量 str, 文本型
    .局部变量 pStr, 整数型
    .局部变量 tmp, 整数型
    .局部变量 i, 整数型
    .局部变量 n, 整数型

    置随机数种子 ()
    buffer ＝ 取空白字节集 (129)
    pBuffer ＝ 取指针_字节集型 (buffer)
    str ＝ 取空白文本 (要取的字符数)
    pStr ＝ 取指针_文本型 (str)
    .如果真 (位与 (获取模式, 1) ≠ 0)
        tmp ＝ 位或 (tmp, 1)
    .如果真结束
    .如果真 (位与 (获取模式, 2) ≠ 0)
        tmp ＝ 位或 (tmp, 2)
    .如果真结束
    .如果真 (位与 (获取模式, 4) ≠ 0)
        tmp ＝ 位或 (tmp, 4)
    .如果真结束
    .如果真 (位与 (获取模式, 8) ≠ 0)
        tmp ＝ 位或 (tmp, 8)
    .如果真结束
    .如果真 (tmp ＝ 0)
        tmp ＝ 1
    .如果真结束
    获取模式 ＝ tmp
    .如果真 (位与 (获取模式, 1) ≠ 0)
        RtlMoveMemory (pBuffer ＋ bufferSize, 取指针_文本型 (“0123456789”), 10)
        bufferSize ＝ bufferSize ＋ 10
    .如果真结束
    .如果真 (位与 (获取模式, 2) ≠ 0)
        RtlMoveMemory (pBuffer ＋ bufferSize, 取指针_文本型 (“abcdefghijklmnopqrstuvwxyz”), 26)
        bufferSize ＝ bufferSize ＋ 26
    .如果真结束
    .如果真 (位与 (获取模式, 4) ≠ 0)
        RtlMoveMemory (pBuffer ＋ bufferSize, 取指针_文本型 (“ABCDEFGHIJKLMNOPQRSTUVWXYZ”), 26)
        bufferSize ＝ bufferSize ＋ 26
    .如果真结束
    .如果真 (位与 (获取模式, 8) ≠ 0)
        ' 这里的 取指针_文本型() 里面的文本都是常量相加, 所以在编译后就变成了常量, 所以可以这么取指针
        RtlMoveMemory (pBuffer ＋ bufferSize, 取指针_文本型 (“ !” ＋ #引号 ＋ “#$%&'()*+,-./:;<=>?@[\]^_`{|}~”), 33)
        bufferSize ＝ bufferSize ＋ 33
    .如果真结束
    bufferSize ＝ bufferSize － 1
    .计次循环首 (要取的字符数, i)
        RtlMoveMemory (pStr ＋ i － 1, pBuffer ＋ 取随机数 (0, bufferSize), 1)
    .计次循环尾 ()
    返回 (str)

.子程序 文本_插入新一行, 文本型, 公开, 在指定行插入文本，原文本后移，返回插入后的文本。
    .参数 原文本, 文本型
    .参数 行数, 整数型
    .参数 新一文本行内容, 文本型
    .局部变量 文本数组, 文本型, , "0"
    .局部变量 输出文本, 文本型
    .局部变量 计次, 整数型

    文本数组 ＝ 分割文本 (原文本, #换行符, )
    插入成员 (文本数组, 行数, 新一文本行内容)
    .计次循环首 (取数组成员数 (文本数组), 计次)
        .如果真 (取数组成员数 (文本数组) ＝ 计次)
            输出文本 ＝ 输出文本 ＋ 文本数组 [计次]
            跳出循环 ()
        .如果真结束
        输出文本 ＝ 输出文本 ＋ 文本数组 [计次] ＋ #换行符
    .计次循环尾 ()
    清除数组 (文本数组)
    返回 (输出文本)

.子程序 文本_是否为汉字, 逻辑型, 公开, 中间不能有空格,判断一个文本是否全为汉字,是汉字返回真,否则返回假
    .参数 欲判断文本, 文本型
    .参数 正则方式, 逻辑型, 可空, 是否正则方式判断，可以判断生僻的汉字
    .局部变量 局_区码, 字节型
    .局部变量 局_位码, 字节型
    .局部变量 RegExp, 对象
    .局部变量 匹配文本, 文本型
    .局部变量 bool, 逻辑型
    .局部变量 局_长度
    .局部变量 i, 整数型
    .局部变量 局_键代码, 整数型

    局_长度 ＝ 取文本长度 (删全部空 (欲判断文本))
    .如果真 (局_长度 ≤ 1)
        返回 (假)
    .如果真结束
    .如果真 (正则方式)
        CoInitialize (0)
        RegExp.创建 (“VBScript.RegExp”, )
        RegExp.写属性 (“Pattern”, “^[\u4e00-\u9fa5]{1,}$”)
        bool ＝ RegExp.逻辑方法 (“Test”, 欲判断文本)
        RegExp.清除 ()
        CoUninitialize ()
        返回 (bool)
    .如果真结束
    ' 非正则方式判断------------------------------------------------
    .计次循环首 (局_长度, i)
        局_键代码 ＝ 取代码 (欲判断文本, i)
        .如果真 (局_键代码 ≥ 0)
            返回 (假)
        .如果真结束
        
    .计次循环尾 ()
    返回 (真)

.子程序 文本_是否为汉字2, 逻辑型, 公开, 中间不能有空格,判断一个文本第一个字是否是汉字,是汉字返回真,否则返回假
    .参数 欲判断文本, 文本型
    .局部变量 局_欲判断文本, 文本型
    .局部变量 局_长度, 整数型
    .局部变量 局_拼音, 文本型

    局_欲判断文本 ＝ 欲判断文本
    局_欲判断文本 ＝ 删全部空 (局_欲判断文本)
    局_长度 ＝ 取文本长度 (局_欲判断文本)
    .如果真 (局_长度 ＜ 2)
        返回 (假)
    .如果真结束
    局_拼音 ＝ 取拼音 (取文本左边 (局_欲判断文本, 2), 1)
    返回 (局_拼音 ≠ “”)

.子程序 文本_是否为双字节字符, 逻辑型, 公开, By 火威网络 如果为双字节返回真，否则返回假。如果指定位置超出文本长度，返回0
    .参数 欲检查文本, 字节集
    .参数 欲检查的字符位置, 整数型, , 0为首位置，1为第2个位置，如此类推，必须是大于0。

    返回 (IsDBCSLeadByte (取字节集数据 (欲检查文本, #字节型, 欲检查的字符位置)))

.子程序 文本_是否为双字节字符Ex, 逻辑型, 公开, By 火威网络 如果为双字节返回真，否则返回假。如果指定位置超出文本长度，返回0
    .参数 欲检查文本, 字节集
    .参数 欲检查的字符位置, 整数型, , 0为首位置，1为第2个位置，如此类推，必须是大于0。

    返回 (IsDBCSLeadByteEx (0, 取字节集数据 (欲检查文本, #字节型, 欲检查的字符位置))) ' CP_ACP

.子程序 文本_是否为字母, 逻辑型, 公开, 中间不能有空格
    .参数 文本字符, 文本型
    .局部变量 Len, 整数型
    .局部变量 i, 整数型
    .局部变量 asc, 整数型

    Len ＝ 取文本长度 (文本字符)
    .如果真 (Len ＝ 0)
        返回 (假)
    .如果真结束
    .计次循环首 (Len, i)
        asc ＝ 取代码 (文本字符, i)
        .判断开始 (asc ≥ 65 且 asc ≤ 90) ' A-Z
            
        .判断 (asc ≥ 97 且 asc ≤ 122) ' a-z
            
        .默认
            返回 (假)
        .判断结束
        
    .计次循环尾 ()
    返回 (真)

.子程序 文本_取出现次数, 整数型, 公开, 返回指定文本中指定内容出现的次数
    .参数 被搜索文本, 文本型
    .参数 欲搜索文本, 文本型
    .参数 是否区分大小写, 逻辑型, 可空
    .局部变量 dwSeaLen, 整数型
    .局部变量 位置_, 整数型, , , 感谢论坛会员 Mr.Yang提供的代码
    .局部变量 i, 整数型

    dwSeaLen ＝ 取文本长度 (欲搜索文本)
    .如果真 (取文本长度 (被搜索文本) ＞ 0 且 dwSeaLen ＞ 0)
        位置_ ＝ 寻找文本 (被搜索文本, 欲搜索文本, , 取反 (是否区分大小写))
        .判断循环首 (位置_ ≠ -1)
            i ＝ i ＋ 1
            位置_ ＝ 寻找文本 (被搜索文本, 欲搜索文本, 位置_ ＋ dwSeaLen, 取反 (是否区分大小写))
        .判断循环尾 ()
    .如果真结束
    返回 (i)

.子程序 文本_首字母改大写, 文本型, 公开, foxpro返回 Foxpro，注意本命令对首字为汉字的文本无效
    .参数 英文文本, 文本型

    返回 (到大写 (取文本左边 (英文文本, 1)) ＋ 取文本中间 (英文文本, 2, 取文本长度 (英文文本)))

.子程序 文本_取汉字区位码, 文本型, 公开, 返回一个汉字的区位码,如果汉字过长,只取第一个字,如果不是汉字,返回空
    .参数 汉字, 文本型, , 传送一个汉字进行处理
    .参数 区码还是位码, 整数型, 可空, 需返回的内容,1表示区码,2表示位码,3表示区码与位码都返回,默认为3
    .局部变量 区码, 字节型
    .局部变量 位码, 字节型

    区码 ＝ 取代码 (取文本左边 (汉字, 1), )
    位码 ＝ 取代码 (取文本中间 (汉字, 2, 1), )
    .如果真 (区码 ＜ 176 或 区码 ＞ 247 或 位码 ＜ 161 或 位码 ＞ 254)
        返回 (“”)
    .如果真结束
    .判断开始 (区码还是位码 ＝ 1)
        返回 (到文本 (区码))
    .判断 (区码还是位码 ＝ 2)
        返回 (到文本 (位码))
    .判断 (区码还是位码 ＝ 3)
        返回 (到文本 (区码) ＋ 到文本 (位码))
    .默认
        返回 (“”)
    .判断结束
    
    

.子程序 文本_取汉字机内码, 文本型, 公开
    .参数 汉字, 文本型
    .局部变量 机内码, 整数型

    .如果真 (取代码 (汉字, 1) ＞ 0)
        返回 (“”)
    .如果真结束
    机内码 ＝ (取代码 (汉字, 1) ＋ 256) × 256 ＋ 取代码 (汉字, 2) ＋ 256
    返回 (取十六进制文本 (机内码))
    ' 区位码 ＝ 机内码 － 41120  ' 41120=A0A0H

.子程序 文本_取出中间文本, 文本型, 公开, 比如：欲取全文本为“12345”,现在要取出“3”，<3>的前面为“2”，<3>的后面为“4”，
    .参数 欲取全文本, 文本型, , 比如：欲取全文本为 12345
    .参数 前面文本, 文本型, , 3的前面为“2”，引号直接用 #引号，如："<font color="#引号red#引号">"
    .参数 后面文本, 文本型, , 3的后面为“4”，引号直接用 #引号，如："<font color="#引号red#引号">"
    .参数 起始搜寻位置, 整数型, 可空, 可空,这里是指搜寻 参数二 前面文本 的开始位置
    .参数 是否不区分大小写, 逻辑型, 可空, 为真不区分大小写，为假区分。
    .局部变量 局_前面文本位置, 整数型
    .局部变量 局_后面文本位置, 整数型
    .局部变量 局_前面文本, 文本型
    .局部变量 局_后面文本, 文本型

    局_前面文本 ＝ 子文本替换 (前面文本, “#引号”, #引号, , , 真)
    局_后面文本 ＝ 子文本替换 (后面文本, “#引号”, #引号, , , 真)
    局_前面文本位置 ＝ 寻找文本 (欲取全文本, 局_前面文本, 起始搜寻位置, 是否不区分大小写)
    .如果真 (局_前面文本位置 ≠ -1)
        局_前面文本位置 ＝ 局_前面文本位置 ＋ 取文本长度 (局_前面文本)
        局_后面文本位置 ＝ 寻找文本 (欲取全文本, 局_后面文本, 局_前面文本位置, 是否不区分大小写)
        .如果真 (局_后面文本位置 ≠ -1)
            返回 (取文本中间 (欲取全文本, 局_前面文本位置, 局_后面文本位置 － 局_前面文本位置))
        .如果真结束
        
    .如果真结束
    返回 (“”)

.子程序 文本_倒取出中间文本, 文本型, 公开, 比如：欲取全文本为“0012345”,现在要取出“123”，<123>的右边为“4”，<123>的左边为“0”，注意这里是倒取
    .参数 欲取全文本, 文本型, , 比如：欲取全文本为“0012345”
    .参数 右边文本, 文本型, , 123的右边为“4”，引号直接用 #引号，如："<font color=#引号red#引号>" 注意左右
    .参数 左边文本, 文本型, , 123的左边为“0”，引号直接用 #引号，如："<font color=#引号red#引号>" 注意左右
    .参数 倒数搜寻位置, 整数型, 可空, 可空,这里是指搜寻 参数二 右边文本的开始位置
    .参数 是否不区分大小写, 逻辑型, 可空, 默认为假：区分大小写 真：不区分大小写
    .局部变量 局_左边, 文本型
    .局部变量 局_右边, 文本型
    .局部变量 rPos, 整数型
    .局部变量 lPos, 整数型

    局_右边 ＝ 子文本替换 (右边文本, “#引号”, #引号, , , 真)
    局_左边 ＝ 子文本替换 (左边文本, “#引号”, #引号, , , 真)
    倒数搜寻位置 ＝ 选择 (倒数搜寻位置 ≤ 0, -1, 倒数搜寻位置)
    倒数搜寻位置 ＝ 取文本长度 (欲取全文本) － 倒数搜寻位置
    rPos ＝ 倒找文本 (欲取全文本, 局_右边, 倒数搜寻位置, 是否不区分大小写)
    .如果真 (rPos ≠ -1)
        lPos ＝ 倒找文本 (欲取全文本, 局_左边, rPos, 是否不区分大小写)
        .如果真 (lPos ≠ -1)
            lPos ＝ lPos ＋ 取文本长度 (局_左边)
        .如果真结束
        返回 (取文本中间 (欲取全文本, lPos, rPos － lPos))
    .如果真结束
    返回 (“”)

.子程序 文本_取文本所在行, 整数型, 公开, 查找某段字或关键中在文本中的哪一行出现，成功返回行数，失败返回0
    .参数 源文本, 文本型
    .参数 欲查找的文本, 文本型
    .参数 是否区分大小写, 逻辑型, 可空
    .局部变量 局_文本, 文本型, , "0"
    .局部变量 局_计次, 整数型

    局_文本 ＝ 分割文本 (源文本, #换行符, )
    .计次循环首 (取数组成员数 (局_文本), 局_计次)
        .如果真 (寻找文本 (局_文本 [局_计次], 欲查找的文本, , 取反 (是否区分大小写)) ≠ -1)
            返回 (局_计次)
        .如果真结束
        
    .计次循环尾 ()
    返回 (0)

.子程序 文本_取文本所在行_优化版, 整数型, 公开, 查找某段字或关键中在文本中的哪一行出现，成功返回行数，失败返回0
    .参数 源文本, 文本型
    .参数 欲查找的文本, 文本型
    .参数 起始搜寻位置, 整数型, 可空, 位置值从 1 开始。如果本参数被省略，默认为 1 【单位：行】
    .参数 是否区分大小写, 逻辑型, 可空
    .局部变量 局_文本, 文本型, , "0"
    .局部变量 局_计次, 整数型

    局_文本 ＝ 分割文本 (源文本, #换行符, )
    .计次循环首 (取数组成员数 (局_文本), 局_计次)
        .如果真 (是否为空 (起始搜寻位置))
            起始搜寻位置 ＝ 1
        .如果真结束
        .如果真 (寻找文本 (局_文本 [局_计次], 欲查找的文本, , 取反 (是否区分大小写)) ≠ -1)
            .如果真 (局_计次 ≥ 起始搜寻位置)
                返回 (局_计次)
            .如果真结束
            
        .如果真结束
        
    .计次循环尾 ()
    返回 (0)

.子程序 文本_取汉字区位码2, 整数型, 公开
    .参数 汉字, 文本型
    .局部变量 机内码, 整数型

    .如果真 (取代码 (汉字, 1) ＞ 0)
        返回 (0)
    .如果真结束
    机内码 ＝ (取代码 (汉字, 1) ＋ 256) × 256 ＋ 取代码 (汉字, 2) ＋ 256
    ' 返回 (取十六进制文本 (机内码))
    返回 (机内码 － 41120) ' 41120=A0A0H

.子程序 文本_删除指定文本行, 文本型, 公开, 删除指定文本的一行文本，返回删行后的文本
    .参数 源文本, 文本型
    .参数 行数, 整数型, , 输入你想删除的行数，如：想删除第3行的整行文本就直接输3
    .局部变量 临时文本, 文本型, , "0"
    .局部变量 计次, 整数型
    .局部变量 输出文本, 文本型

    输出文本 ＝ 源文本
    .如果真 (寻找文本 (输出文本, #换行符, , 假) ＝ -1)
        输出文本 ＝ 输出文本 ＋ #换行符
    .如果真结束
    临时文本 ＝ 分割文本 (输出文本, #换行符, )
    输出文本 ＝ “”
    删除成员 (临时文本, 行数, )
    .计次循环首 (取数组成员数 (临时文本), 计次)
        .如果 (取数组成员数 (临时文本) ≠ 计次)
            输出文本 ＝ 输出文本 ＋ 临时文本 [计次] ＋ #换行符
        .否则
            输出文本 ＝ 输出文本 ＋ 临时文本 [计次]
        .如果结束
        
    .计次循环尾 ()
    清除数组 (临时文本)
    返回 (输出文本)

.子程序 文本_删除指定文件行, 逻辑型, 公开, 删除指定文件内的一行文本。
    .参数 文件路径, 文本型
    .参数 要删除的文本行文本, 文本型
    .局部变量 内容, 字节集
    .局部变量 行头, 整数型
    .局部变量 局_数据, 字节集

    内容 ＝ 读入文件 (文件路径)
    行头 ＝ 寻找字节集 (内容, 到字节集 (要删除的文本行文本), )
    .如果真 (行头 ＝ -1)
        返回 (假)
    .如果真结束
    局_数据 ＝ 字节集替换 (内容, 行头, 取字节集长度 (到字节集 (要删除的文本行文本) ＋ { 13, 10 }), { })
    返回 (写到文件 (文件路径, 局_数据))

.子程序 文本_取随机范围数字, 文本型, 公开, 如1-100之间的双数或单数或单双一起！
    .参数 起始数, 整数型, , 如：1
    .参数 结束数, 整数型, , 如：1000
    .参数 单双选择, 整数型, 可空, 1为单，2为双,否则为取单双
    .局部变量 临时整数, 整数型

    .判断开始 (起始数 ＝ 结束数)
        返回 (到文本 (起始数))
    .判断 (起始数 ＞ 结束数)
        临时整数 ＝ 汇编_取随机数 (结束数, 起始数)
    .默认
        临时整数 ＝ 汇编_取随机数 (起始数, 结束数)
    .判断结束
    
    
    .判断开始 (单双选择 ＝ 1)
        .如果真 (临时整数 ％ 2 ＝ 0)
            .判断开始 (临时整数 ＝ 结束数)
                临时整数 ＝ 临时整数 － 1
            .默认
                临时整数 ＝ 临时整数 ＋ 1
            .判断结束
            
        .如果真结束
        返回 (到文本 (临时整数))
    .判断 (单双选择 ＝ 2)
        .如果真 (临时整数 ％ 2 ＝ 1)
            .判断开始 (临时整数 ＝ 结束数)
                临时整数 ＝ 临时整数 － 1
            .默认
                临时整数 ＝ 临时整数 ＋ 1
            .判断结束
            
        .如果真结束
        返回 (到文本 (临时整数))
    .默认
        返回 (到文本 (临时整数))
    .判断结束
    

.子程序 文本_删除指定文件文本行1, 逻辑型, 公开, 感谢 @jr21066 分享开源
    .参数 参_文件路径, 文本型
    .参数 参_行号, 整数型
    .局部变量 局_内容, 字节集
    .局部变量 局_行开始, 整数型
    .局部变量 局_行结束, 整数型

    ' 真有人来参数0.也不出错了
    .如果真 (参_行号 ＝ 0)
        返回 (假)
    .如果真结束
    局_内容 ＝ 读入文件 (参_文件路径)
    
    .计次循环首 (参_行号 － 1, )
        ' 行开始定位到换行符的后边
        局_行开始 ＝ 寻找字节集 (局_内容, { 13, 10 }, 局_行开始 ＋ 1)
        .如果 (局_行开始 ＝ -1)
            返回 (假)
        .否则
            局_行开始 ＝ 局_行开始 ＋ 1
        .如果结束
        
    .计次循环尾 ()
    局_行结束 ＝ 寻找字节集 (局_内容, { 13, 10 }, 局_行开始 ＋ 1)
    .如果 (局_行结束 ＝ -1)
        ' 如果文件尾没有换行符就以文件尾为单位
        .如果 (取字节集长度 (局_内容) ＞ 局_行开始)
            局_行结束 ＝ 取字节集长度 (局_内容)
        .否则
            返回 (假)
        .如果结束
        
    .否则
        局_行结束 ＝ 局_行结束 ＋ 1
    .如果结束
    
    .如果真 (写到文件 (参_文件路径, 取字节集左边 (局_内容, 局_行开始) ＋ 取字节集右边 (局_内容, 取字节集长度 (局_内容) － 局_行结束)))
        返回 (真)
    .如果真结束
    
    返回 (假)

.子程序 文本_删除指定变量文本行1, 文本型, 公开, 感谢【@jr21066 】分享开源
    .参数 参_文本, 文本型
    .参数 参_行号, 整数型
    .局部变量 局_行开始, 整数型
    .局部变量 局_行结束, 整数型

    .如果真 (参_行号 ＝ 0)
        返回 (参_文本)
    .如果真结束
    .计次循环首 (参_行号 － 1, )
        局_行开始 ＝ 寻找文本 (参_文本, #换行符, 局_行开始 ＋ 1, 假)
        .如果 (局_行开始 ＝ -1)
            返回 (“”)
        .否则
            局_行开始 ＝ 局_行开始 ＋ 1
        .如果结束
        
    .计次循环尾 ()
    局_行结束 ＝ 寻找文本 (参_文本, #换行符, 局_行开始 ＋ 1, 假)
    .如果 (局_行结束 ＝ -1)
        .如果 (取文本长度 (参_文本) ＞ 局_行开始)
            局_行结束 ＝ 取文本长度 (参_文本)
        .否则
            返回 (“”)
        .如果结束
        
    .否则
        局_行结束 ＝ 局_行结束 ＋ 1
    .如果结束
    返回 (取文本左边 (参_文本, 局_行开始) ＋ 取文本右边 (参_文本, 取文本长度 (参_文本) － 局_行结束))

.子程序 文本_取文本起始位置, , 公开, 返回某个字符的在整个文本中出现的位置数组，数组第一个成员是第一次出现的位置。
    .参数 文本, 文本型
    .参数 欲搜寻的文本, 文本型
    .参数 起始位置, 整数型, 参考 数组
    .局部变量 dwLen, 整数型
    .局部变量 i, 整数型

    清除数组 (起始位置)
    dwLen ＝ 取文本长度 (欲搜寻的文本)
    i ＝ 寻找文本 (文本, 欲搜寻的文本, , 真)
    .判断循环首 (i ≠ -1)
        加入成员 (起始位置, i)
        i ＝ 寻找文本 (文本, 欲搜寻的文本, i ＋ dwLen, 真)
    .判断循环尾 ()

.子程序 字节集_取空白字节集, 字节集, 公开, 汇编方式申请空白字节集, 返回具有特定数目 0 字节的字节集; 注意, 命令本身不会处理内存释放, 请不要连续反复调用
    .参数 字节集长度, 整数型

    HeapAlloc (GetProcessHeap (), #HEAP_ZERO_MEMORY, 字节集长度 ＋ 8)
    置入代码 ({ 199, 0, 1, 0, 0, 0, 255, 117, 8, 143, 64, 4, 139, 229, 93, 194, 4, 0 })
    ' mov dword ptr[eax],01h  ;字节集 前4位 为整数1，第二个4位 是整数 字节集长度，写入1标记为字节集，可以当 字节数组引用
    
    ' push dword ptr[ebp+8]
    ' pop dword ptr[eax+4]
    ' mov esp,ebp
    ' pop ebp
    ' retn 4
    返回 ({ })

.子程序 文本_文本数组排序, , 公开, 排序从z到a排序或从a-z排序
    .参数 要排序的数组, 文本型, 数组, 要排序的数组。
    .参数 排序后的数组, 文本型, 参考 数组, 排序后结果返回的数组。
    .参数 排序方向是否从大到小, 逻辑型, 可空, 如果参数值为真，排序将从小到大；如果为假，则从大到小。如果本参数被省略，将默认为假
    .局部变量 A, 整数型
    .局部变量 B, 整数型
    .局部变量 C, 整数型
    .局部变量 临时_文本, 文本型

    .如果真 (是否为空 (排序方向是否从大到小))
        排序方向是否从大到小 ＝ 假
    .如果真结束
    ' 注意：这里要保证原来的数组不发生改变，所以所有的排序操作都应该在排序后的数组中。
    复制数组 (排序后的数组, 要排序的数组)
    A ＝ 取数组成员数 (排序后的数组)
    .如果 (排序方向是否从大到小 ＝ 真)
        .判断循环首 (A ＞ 0)
            C ＝ 0
            .变量循环首 (1, A － 1, 1, B)
                .如果真 (排序后的数组 [B] ＜ 排序后的数组 [B ＋ 1])
                    临时_文本 ＝ 排序后的数组 [B]
                    排序后的数组 [B] ＝ 排序后的数组 [B ＋ 1]
                    排序后的数组 [B ＋ 1] ＝ 临时_文本
                    C ＝ B
                .如果真结束
                
            .变量循环尾 ()
            A ＝ C
        .判断循环尾 ()
        
    .否则
        .判断循环首 (A ＞ 0)
            C ＝ 0
            .变量循环首 (1, A － 1, 1, B)
                .如果真 (排序后的数组 [B] ＞ 排序后的数组 [B ＋ 1])
                    临时_文本 ＝ 排序后的数组 [B]
                    排序后的数组 [B] ＝ 排序后的数组 [B ＋ 1]
                    排序后的数组 [B ＋ 1] ＝ 临时_文本
                    C ＝ B
                .如果真结束
                
            .变量循环尾 ()
            A ＝ C
        .判断循环尾 ()
        
    .如果结束
    

.子程序 文本_插入文本到某行前, 文本型, 公开, 将文本加入到某行之前，返回加入后的文本。
    .参数 原文本, 文本型
    .参数 行数, 整数型
    .参数 欲插入内容, 文本型
    .局部变量 文本数组, 文本型, , "0"
    .局部变量 输出文本, 文本型
    .局部变量 计次, 整数型

    文本数组 ＝ 分割文本 (原文本, #换行符, )
    .如果真 (行数 ≤ 取数组成员数 (文本数组))
        文本数组 [行数] ＝ 欲插入内容 ＋ 文本数组 [行数]
        .计次循环首 (取数组成员数 (文本数组), 计次)
            .如果真 (取数组成员数 (文本数组) ＝ 计次)
                输出文本 ＝ 输出文本 ＋ 文本数组 [计次]
                跳出循环 ()
            .如果真结束
            输出文本 ＝ 输出文本 ＋ 文本数组 [计次] ＋ #换行符
        .计次循环尾 ()
        清除数组 (文本数组)
        返回 (输出文本)
    .如果真结束
    清除数组 (文本数组)
    返回 (“”)

.子程序 文本_插入文本到某行后, 文本型, 公开, 将文本加入到某行之后，返回加入后的文本。
    .参数 原文本, 文本型
    .参数 行数, 整数型, , 行数不能小于或等于0
    .参数 欲插入内容, 文本型
    .局部变量 文本数组, 文本型, , "0"
    .局部变量 输出文本, 文本型
    .局部变量 计次, 整数型

    文本数组 ＝ 分割文本 (原文本, #换行符, )
    .如果真 (行数 ＞ 0 且 行数 ≤ 取数组成员数 (文本数组))
        文本数组 [行数] ＝ 文本数组 [行数] ＋ 欲插入内容
        .计次循环首 (取数组成员数 (文本数组), 计次)
            .如果真 (取数组成员数 (文本数组) ＝ 计次)
                输出文本 ＝ 输出文本 ＋ 文本数组 [计次]
                跳出循环 ()
            .如果真结束
            输出文本 ＝ 输出文本 ＋ 文本数组 [计次] ＋ #换行符
        .计次循环尾 ()
        清除数组 (文本数组)
        返回 (输出文本)
    .如果真结束
    清除数组 (文本数组)
    返回 (“”)

.子程序 文本_插入文本到某位置, 文本型, 公开, 插入某文本到左起某一位置，原文本后移，返回插入后的文本。
    .参数 原文本, 文本型
    .参数 欲插入的文本, 文本型
    .参数 插入位置, 整数型, , 位置必须为偶数值（字母、数字、标点、符号都和汉字均占2长度)

    返回 (到半角 (文本替换 (到全角 (原文本), 插入位置 － 1, 0, 到全角 (欲插入的文本))))

.子程序 文本_取字符串宽度, 整数型, 公开
    .参数 启动窗口句柄, 整数型
    .参数 欲要取出的字符串, 文本型
    .局部变量 Size, 精易_坐标

    GetTextExtentPointA (GetDC (启动窗口句柄), 欲要取出的字符串, 取文本长度 (欲要取出的字符串), Size)
    返回 (Size.横)

.子程序 文本_取指定文件文本行, 文本型, 公开, 成功返回指定的文本行文本，失败返回空文本。
    .参数 文件路径, 文本型
    .参数 行号, 整数型
    .局部变量 文本数组, 文本型, , "0"
    .局部变量 文本内容, 文本型

    文本内容 ＝ 到文本 (读入文件 (文件路径))
    文本数组 ＝ 分割文本 (文本内容, #换行符, )
    .如果真 (行号 ≤ 0)
        返回 (“”)
    .如果真结束
    .如果真 (行号 ＞ 取数组成员数 (文本数组))
        返回 (“”)
    .如果真结束
    返回 (文本数组 [行号])

.子程序 文本_取指定变量文本行, 文本型, 公开, 成功返回指定的文本行文本，失败返回空文本。
    .参数 文本, 文本型
    .参数 行号, 整数型
    .局部变量 文本数组, 文本型, , "0"

    文本数组 ＝ 分割文本 (文本, #换行符, )
    .如果真 (行号 ≤ 0)
        返回 (“”)
    .如果真结束
    .如果真 (行号 ＞ 取数组成员数 (文本数组))
        返回 (“”)
    .如果真结束
    返回 (文本数组 [行号])

.子程序 文本_取指定文件文本行1, 文本型, 公开, 感谢【@jr21066】分享开源
    .参数 参_文件路径, 文本型
    .参数 参_行号, 整数型
    .局部变量 局_内容, 字节集
    .局部变量 局_行开始, 整数型
    .局部变量 局_行结束, 整数型

    .如果真 (参_行号 ＝ 0)
        返回 (“”)
    .如果真结束
    局_内容 ＝ 读入文件 (参_文件路径)
    .计次循环首 (参_行号 － 1, )
        局_行开始 ＝ 寻找字节集 (局_内容, { 13, 10 }, 局_行开始 ＋ 1)
        .如果 (局_行开始 ＝ -1)
            返回 (“”)
        .否则
            局_行开始 ＝ 局_行开始 ＋ 2
        .如果结束
        
    .计次循环尾 ()
    .如果真 (局_行开始 ＝ 0)
        局_行开始 ＝ 1
    .如果真结束
    局_行结束 ＝ 寻找字节集 (局_内容, { 13, 10 }, 局_行开始 ＋ 1)
    .如果 (局_行结束 ＝ -1)
        .如果 (取字节集长度 (局_内容) ≥ 局_行开始)
            局_行结束 ＝ 取字节集长度 (局_内容) ＋ 1
        .否则
            返回 (“”)
        .如果结束
        
    .否则
        局_行结束 ＝ 局_行结束 ＋ 2
    .如果结束
    返回 (到文本 (取字节集中间 (局_内容, 局_行开始, 局_行结束 － 局_行开始)))

.子程序 文本_取指定变量文本行1, 文本型, 公开
    .参数 欲取其部分的文本, 文本型
    .参数 行号, 整数型
    .局部变量 局_长度, 整数型
    .局部变量 局_次数, 整数型
    .局部变量 i, 整数型
    .局部变量 局_行首, 整数型
    .局部变量 局_行尾, 整数型

    ' https://bbs.125.la/thread-14539818-1-1.html
    .如果真 (行号 ＝ 0)
        返回 (“”)
    .如果真结束
    局_次数 ＝ 行号 － 1
    局_行首 ＝ 1
    .计次循环首 (局_次数, i)
        局_行首 ＝ 寻找文本 (欲取其部分的文本, #换行符, 局_行首, 假)
        .如果真 (局_行首 ＝ -1)
            返回 (“”)
        .如果真结束
        局_行首 ＝ 局_行首 ＋ 2
    .计次循环尾 ()
    局_行尾 ＝ 寻找文本 (欲取其部分的文本, #换行符, 局_行首, 假)
    .如果 (局_行尾 ＝ -1)
        局_长度 ＝ 取文本长度 (欲取其部分的文本)
        返回 (取文本右边 (欲取其部分的文本, 局_长度 － 局_行首 ＋ 1))
    .否则
        返回 (取文本中间 (欲取其部分的文本, 局_行首, 局_行尾 － 局_行首))
    .如果结束
    

.子程序 文本_取文本行出现次数, 整数型, 公开, 取某行文本共出现了多少次，不存在返回-1。
    .参数 被搜寻的文本, 文本型
    .参数 行数, 整数型
    .局部变量 文本数组, 文本型, , "0"
    .局部变量 出现的次数, 整数型

    文本数组 ＝ 分割文本 (被搜寻的文本, 文本_取指定变量文本行 (被搜寻的文本, 行数), )
    出现的次数 ＝ 取数组成员数 (文本数组) － 1
    .如果 (出现的次数 ＜ 0)
        清除数组 (文本数组)
        返回 (-1)
    .否则
        清除数组 (文本数组)
        返回 (出现的次数)
    .如果结束
    

.子程序 文本_取文本行起始位置, , 公开, 返回某行在整个文本中出现的位置数组，数组第一个成员是第一次出现的位置。
    .参数 文本, 文本型
    .参数 行数, 整数型
    .参数 起始位置, 整数型, 参考 数组
    .局部变量 起始位置数值, 整数型
    .局部变量 起始位置数值2, 整数型
    .局部变量 文本行, 文本型
    .局部变量 文本长度, 整数型
    .局部变量 计次, 整数型

    文本行 ＝ 文本_取指定变量文本行 (文本, 行数)
    文本长度 ＝ 取文本长度 (文本行)
    .计次循环首 (文本_取文本行出现次数 (文本, 行数), 计次)
        .如果 (计次 ＝ 1)
            起始位置数值 ＝ 寻找文本 (文本, 文本行, , 真)
            起始位置数值2 ＝ 起始位置数值 ＋ 文本长度 ＋ 1
            加入成员 (起始位置, 起始位置数值)
        .否则
            起始位置数值2 ＝ 寻找文本 (文本, 文本行, 起始位置数值2, 真)
            加入成员 (起始位置, 起始位置数值2)
            起始位置数值2 ＝ 起始位置数值2 ＋ 文本长度
        .如果结束
        
    .计次循环尾 ()

.子程序 文本_寻找出文本并删除, 文本型, 公开, 比如：欲寻找的全文本为<12345789>,现在要删除2到5之间的全部字符，包括2跟5,成功返回删除后的结果文本，失败返回原文本！
    .参数 欲寻找的全文本, 文本型, , 比如：欲寻找的全文本为 12345789
    .参数 前面文本, 文本型, , 前面为“2”
    .参数 后面文本, 文本型, , 后面为“5”
    .参数 是否保留前后文本, 逻辑型, 可空, 默认不保留
    .局部变量 szText, 文本型
    .局部变量 dwStartLen, 整数型
    .局部变量 dwEndLen, 整数型
    .局部变量 aryStartPos, 整数型, , "0"
    .局部变量 len, 整数型
    .局部变量 iStartPos, 整数型
    .局部变量 iEndPos, 整数型
    .局部变量 i, 整数型

    szText ＝ 欲寻找的全文本
    文本_取文本起始位置 (szText, 前面文本, aryStartPos)
    len ＝ 取数组成员数 (aryStartPos)
    .如果真 (len ＞ 0)
        dwStartLen ＝ 取文本长度 (前面文本)
        dwEndLen ＝ 取文本长度 (后面文本)
        .如果真 (dwStartLen ＝ 0 或 dwEndLen ＝ 0)
            输出调试文本 (“前后文本必须传递正确的内容！”)
            返回 (szText)
        .如果真结束
        .变量循环首 (len, 1, -1, i)
            iStartPos ＝ aryStartPos [i]
            iEndPos ＝ 寻找文本 (szText, 后面文本, iStartPos ＋ dwStartLen, 假)
            .如果真 (iEndPos ≠ -1)
                .如果 (是否保留前后文本)
                    iStartPos ＝ iStartPos ＋ dwStartLen
                .否则
                    iEndPos ＝ iEndPos ＋ dwEndLen
                .如果结束
                szText ＝ 文本替换 (szText, iStartPos, iEndPos － iStartPos, )
            .如果真结束
            
        .变量循环尾 ()
    .如果真结束
    返回 (szText)

.子程序 文本_插入文本到某字前, 文本型, 公开, 插入文本到某字前，返回插入后的文本。
    .参数 原文本, 文本型
    .参数 某字, 文本型
    .参数 被插在某字前的文本, 文本型
    .参数 插入次数, 整数型, 可空, 如果省略，默认进行所有可能的插入

    .如果真 (是否为空 (插入次数))
        返回 (子文本替换 (原文本, 某字, 被插在某字前的文本 ＋ 某字, , , 假))
    .如果真结束
    返回 (子文本替换 (原文本, 某字, 被插在某字前的文本 ＋ 某字, , 插入次数, 假))

.子程序 文本_插入文本到某字后, 文本型, 公开, 插入文本到某字后，返回插入后的文本。
    .参数 原文本, 文本型
    .参数 某字, 文本型
    .参数 被插在某字后的文本, 文本型
    .参数 插入次数, 整数型, 可空, 如果省略，默认进行所有可能的插入

    .如果真 (是否为空 (插入次数))
        返回 (子文本替换 (原文本, 某字, 某字 ＋ 被插在某字后的文本, , , 假))
    .如果真结束
    返回 (子文本替换 (原文本, 某字, 某字 ＋ 被插在某字后的文本, , 插入次数, 假))

.子程序 文本_取出N组不重复数字, , 公开, 取出N组不重复数字,如：在1-100之间取出80个数字，要求不重复。
    .参数 返回取出的数组, 整数型, 数组, 存放取出来的数组
    .参数 欲取多少组, 整数型, , 要取多少组
    .参数 最小值, 整数型, , 要取的最小数值
    .参数 最大值, 整数型, , 要取的最大数值
    .局部变量 iTotal, 整数型
    .局部变量 aryTemp, 整数型, , "0"
    .局部变量 pAry, 整数型
    .局部变量 i, 整数型
    .局部变量 n, 整数型

    iTotal ＝ 最大值 － 最小值 ＋ 1
    .如果真 (iTotal ≤ 0 或 欲取多少组 ≤ 0)
        返回 ()
    .如果真结束
    
    重定义数组 (aryTemp, 假, iTotal)
    .计次循环首 (iTotal, i)
        aryTemp [i] ＝ 最小值
        最小值 ＝ 最小值 ＋ 1
    .计次循环尾 ()
    
    置随机数种子 ()
    重定义数组 (返回取出的数组, 假, 欲取多少组)
    pAry ＝ 取数据_通用型_数组 (aryTemp)
    .计次循环首 (欲取多少组, i)
        n ＝ 取随机数 (i, iTotal)
        返回取出的数组 [i] ＝ aryTemp [n]
        __set (pAry, (n － 1) × 4, aryTemp [i])
        __set (pAry, (i － 1) × 4, aryTemp [n])
    .计次循环尾 ()

.子程序 文本_取GB2312简体汉字笔画数, 整数型, 公开
    .参数 汉字, 文本型
    .局部变量 数据, 整数型, 静态, "0", 代码作者：袁晓辉（海洋）
    .局部变量 区码, 字节型
    .局部变量 位码, 字节型
    .局部变量 索引, 整数型

    数据 ＝ { 10, 7, 10, 10, 8, 10, 9, 11, 17, 14, 13, 5, 13, 10, 12, 15, 10, 6, 10, 9, 13, 8, 10, 10, 8, 8, 10, 5, 10, 14, 16, 9, 12, 12, 15, 15, 7, 10, 5, 5, 7, 10, 2, 9, 4, 8, 12, 13, 7, 10, 7, 21, 10, 8, 5, 9, 6, 13, 8, 8, 9, 13, 12, 10, 13, 7, 10, 10, 8, 8, 7, 8, 7, 19, 5, 4, 8, 5, 9, 10, 14, 14, 9, 12, 15, 10, 15, 12, 12, 8, 9, 5, 15, 10, 16, 13, 9, 12, 8, 8, 8, 7, 15, 10, 13, 19, 8, 13, 12, 8, 5, 12, 9, 4, 9, 10, 7, 8, 12, 12, 10, 8, 8, 5, 11, 11, 11, 9, 9, 18, 9, 12, 14, 4, 13, 10, 8, 14, 13, 14, 6, 10, 9, 4, 7, 13, 6, 11, 14, 5, 13, 16, 17, 16, 9, 18, 5, 12, 8, 9, 9, 8, 4, 16, 16, 17, 12, 9, 11, 15, 8, 19, 16, 7, 15, 11, 12, 16, 13, 10, 13, 7, 6, 9, 5, 8, 9, 9, 10, 6, 8, 11, 15, 8, 10, 8, 12, 9, 13, 10, 14, 7, 8, 11, 11, 14, 12, 8, 7, 10, 2, 10, 7, 11, 4, 5, 7, 19, 10, 8, 17, 11, 12, 7, 3, 7, 12, 15, 8, 11, 11, 14, 16, 8, 10, 9, 11, 11, 7, 7, 10, 4, 7, 17, 16, 16, 15, 11, 9, 8, 12, 8, 5, 9, 7, 19, 12, 3, 9, 9, 9, 14, 12, 14, 7, 9, 8, 8, 10, 10, 12, 11, 14, 12, 11, 13, 11, 6, 11, 19, 8, 11, 6, 9, 11, 4, 11, 7, 2, 12, 8, 11, 10, 12, 7, 9, 12, 15, 15, 11, 7, 8, 4, 7, 15, 12, 7, 15, 10, 6, 7, 6, 11, 7, 7, 7, 12, 8, 15, 10, 9, 16, 6, 7, 10, 12, 12, 15, 8, 8, 10, 10, 10, 6, 13, 9, 11, 6, 7, 6, 6, 10, 8, 8, 4, 7, 10, 5, 9, 6, 6, 6, 11, 8, 8, 13, 12, 14, 13, 13, 13, 4, 11, 14, 4, 10, 7, 5, 16, 12, 18, 12, 13, 12, 9, 13, 10, 12, 24, 13, 13, 5, 12, 3, 9, 13, 7, 11, 12, 7, 9, 12, 15, 7, 6, 6, 7, 8, 11, 13, 8, 9, 13, 15, 10, 11, 7, 21, 18, 11, 11, 9, 14, 14, 13, 13, 10, 7, 6, 8, 12, 6, 15, 12, 7, 5, 4, 5, 11, 11, 15, 17, 9, 19, 16, 12, 14, 11, 13, 10, 13, 14, 11, 14, 7, 6, 3, 14, 15, 12, 11, 10, 13, 12, 6, 12, 14, 5, 3, 7, 4, 12, 17, 9, 9, 5, 9, 11, 9, 11, 9, 10, 8, 4, 8, 10, 11, 9, 5, 12, 7, 11, 11, 8, 11, 11, 6, 9, 10, 9, 10, 2, 10, 17, 10, 7, 11, 6, 8, 15, 11, 12, 11, 15, 11, 8, 19, 6, 12, 12, 17, 14, 4, 12, 7, 14, 8, 10, 11, 7, 10, 14, 14, 8, 8, 6, 12, 11, 9, 7, 10, 12, 16, 11, 13, 13, 9, 8, 16, 9, 5, 7, 7, 8, 11, 12, 11, 13, 13, 5, 16, 10, 2, 11, 6, 8, 10, 12, 10, 14, 15, 8, 11, 13, 2, 7, 5, 7, 8, 12, 13, 8, 4, 6, 5, 5, 12, 15, 6, 9, 8, 9, 7, 9, 11, 7, 4, 9, 7, 10, 12, 10, 13, 9, 12, 9, 10, 11, 13, 12, 7, 14, 7, 9, 12, 7, 14, 12, 14, 9, 11, 12, 11, 7, 4, 5, 15, 7, 19, 12, 10, 7, 9, 9, 12, 11, 9, 6, 6, 9, 13, 6, 13, 11, 8, 12, 11, 13, 10, 12, 9, 15, 6, 10, 10, 4, 7, 12, 11, 10, 10, 6, 2, 6, 5, 9, 9, 2, 9, 5, 9, 12, 6, 4, 9, 8, 9, 18, 6, 12, 18, 15, 8, 8, 17, 3, 10, 4, 7, 8, 8, 5, 7, 7, 7, 7, 4, 8, 8, 6, 7, 6, 6, 7, 8, 11, 8, 11, 3, 8, 10, 10, 7, 8, 8, 8, 9, 7, 11, 7, 8, 4, 7, 7, 12, 7, 10, 8, 6, 8, 12, 12, 4, 9, 8, 13, 10, 12, 4, 9, 11, 10, 5, 13, 6, 8, 4, 7, 7, 4, 15, 8, 14, 7, 8, 13, 12, 9, 11, 6, 9, 8, 10, 11, 13, 11, 5, 7, 7, 11, 10, 10, 8, 11, 12, 8, 14, 9, 11, 18, 12, 9, 12, 5, 8, 4, 13, 6, 12, 4, 7, 6, 13, 8, 15, 14, 8, 7, 13, 9, 11, 12, 3, 5, 7, 9, 9, 7, 10, 13, 8, 11, 21, 4, 6, 9, 9, 7, 7, 7, 12, 7, 16, 10, 10, 14, 10, 16, 13, 15, 15, 7, 10, 14, 12, 4, 11, 10, 8, 12, 9, 12, 10, 12, 9, 12, 11, 3, 6, 9, 10, 13, 10, 7, 8, 19, 10, 10, 11, 3, 7, 5, 10, 11, 8, 10, 4, 9, 3, 6, 7, 9, 7, 6, 9, 4, 7, 8, 8, 9, 8, 8, 11, 12, 11, 8, 14, 7, 8, 8, 8, 13, 5, 11, 9, 7, 8, 9, 10, 8, 12, 8, 5, 9, 14, 9, 13, 8, 8, 8, 12, 6, 8, 9, 6, 14, 11, 23, 12, 20, 8, 6, 3, 10, 13, 8, 6, 11, 5, 7, 9, 6, 9, 8, 9, 10, 8, 13, 9, 8, 12, 13, 12, 12, 10, 8, 8, 14, 6, 9, 15, 9, 10, 10, 6, 10, 9, 12, 14, 7, 12, 7, 11, 12, 8, 12, 7, 16, 16, 10, 7, 16, 10, 11, 6, 5, 5, 8, 10, 17, 17, 14, 11, 9, 6, 10, 5, 10, 8, 12, 10, 11, 10, 5, 8, 7, 6, 11, 13, 9, 8, 11, 14, 14, 15, 9, 15, 12, 11, 9, 9, 9, 10, 7, 15, 16, 9, 8, 9, 10, 9, 11, 9, 7, 5, 6, 12, 9, 12, 7, 9, 10, 6, 8, 5, 8, 13, 10, 12, 9, 15, 8, 15, 12, 8, 8, 11, 7, 4, 7, 4, 7, 9, 6, 12, 12, 8, 6, 4, 8, 13, 9, 7, 11, 7, 6, 8, 10, 7, 12, 10, 11, 10, 12, 13, 11, 10, 9, 4, 9, 12, 11, 16, 15, 17, 9, 11, 12, 13, 10, 13, 9, 11, 6, 9, 12, 17, 9, 12, 6, 13, 10, 15, 5, 12, 11, 10, 11, 6, 10, 5, 6, 9, 9, 9, 8, 11, 13, 9, 11, 17, 9, 6, 4, 10, 8, 12, 16, 8, 11, 5, 6, 11, 6, 13, 15, 10, 14, 6, 5, 9, 16, 4, 7, 10, 11, 12, 6, 7, 12, 13, 20, 12, 3, 9, 10, 6, 7, 13, 6, 9, 2, 10, 3, 13, 7, 16, 8, 6, 11, 8, 11, 9, 11, 11, 4, 5, 9, 7, 7, 7, 10, 6, 14, 9, 6, 8, 10, 5, 9, 12, 10, 5, 10, 11, 15, 6, 9, 8, 13, 7, 10, 7, 6, 11, 7, 13, 10, 8, 8, 6, 12, 9, 11, 9, 14, 12, 8, 10, 13, 9, 11, 11, 9, 14, 13, 12, 9, 4, 13, 15, 6, 10, 10, 9, 8, 11, 12, 10, 8, 15, 9, 9, 10, 6, 19, 12, 10, 9, 6, 6, 13, 8, 15, 12, 17, 12, 10, 6, 8, 9, 9, 9, 20, 12, 11, 11, 8, 11, 9, 7, 9, 16, 9, 13, 11, 14, 10, 10, 5, 12, 12, 11, 9, 11, 12, 6, 14, 7, 5, 10, 8, 11, 13, 14, 9, 9, 13, 8, 7, 17, 7, 9, 10, 4, 9, 9, 8, 3, 12, 4, 8, 4, 9, 18, 10, 13, 4, 13, 7, 13, 10, 13, 7, 10, 10, 6, 7, 9, 14, 8, 13, 12, 16, 8, 11, 14, 13, 8, 4, 19, 12, 11, 14, 14, 12, 16, 8, 10, 13, 11, 10, 8, 9, 12, 12, 7, 5, 7, 9, 3, 7, 2, 10, 11, 11, 5, 6, 13, 8, 12, 8, 17, 8, 8, 10, 8, 8, 11, 7, 8, 9, 9, 8, 14, 7, 11, 4, 8, 11, 15, 13, 10, 5, 11, 8, 10, 10, 12, 10, 10, 11, 8, 10, 15, 23, 7, 11, 10, 17, 9, 6, 6, 9, 7, 11, 9, 6, 7, 10, 9, 12, 10, 9, 10, 12, 8, 5, 9, 4, 12, 13, 8, 12, 5, 12, 11, 7, 9, 9, 11, 14, 17, 6, 7, 4, 8, 6, 9, 10, 15, 8, 8, 9, 12, 15, 14, 9, 7, 9, 5, 12, 7, 8, 9, 10, 8, 11, 9, 10, 7, 7, 8, 10, 4, 11, 7, 3, 6, 11, 9, 10, 13, 8, 14, 7, 12, 6, 9, 9, 13, 10, 7, 13, 8, 7, 10, 12, 6, 12, 7, 10, 8, 11, 7, 7, 3, 11, 8, 13, 12, 9, 13, 11, 12, 12, 12, 8, 8, 10, 7, 9, 6, 13, 12, 8, 8, 12, 14, 12, 14, 11, 10, 7, 13, 13, 11, 9, 8, 16, 12, 5, 15, 14, 12, 9, 16, 12, 9, 13, 11, 12, 10, 11, 8, 10, 10, 10, 7, 7, 6, 8, 9, 13, 10, 10, 11, 5, 13, 18, 16, 15, 11, 17, 9, 16, 6, 9, 8, 12, 13, 7, 9, 11, 11, 15, 16, 10, 10, 13, 11, 7, 7, 15, 5, 10, 9, 6, 10, 7, 5, 7, 10, 4, 7, 12, 8, 9, 12, 5, 11, 7, 8, 2, 14, 10, 9, 12, 10, 7, 18, 13, 8, 10, 8, 11, 11, 12, 10, 9, 8, 13, 10, 11, 13, 7, 7, 11, 12, 12, 9, 10, 15, 11, 14, 7, 16, 14, 5, 15, 2, 14, 17, 14, 10, 6, 12, 10, 6, 11, 12, 8, 17, 16, 9, 7, 20, 11, 15, 10, 7, 8, 9, 11, 13, 13, 10, 7, 11, 10, 7, 10, 8, 11, 5, 5, 13, 11, 14, 12, 13, 10, 6, 15, 10, 9, 4, 5, 11, 8, 11, 16, 11, 8, 8, 7, 13, 9, 12, 15, 14, 8, 7, 5, 11, 7, 8, 11, 7, 8, 12, 19, 13, 21, 13, 10, 11, 16, 12, 8, 7, 15, 7, 6, 11, 8, 10, 15, 12, 12, 10, 12, 9, 11, 13, 11, 9, 10, 9, 13, 7, 7, 11, 11, 7, 8, 6, 4, 7, 7, 6, 11, 17, 8, 11, 13, 14, 14, 13, 12, 9, 9, 9, 6, 11, 7, 8, 9, 3, 9, 14, 6, 10, 6, 7, 8, 6, 9, 15, 14, 12, 13, 14, 11, 14, 14, 13, 6, 9, 8, 8, 6, 10, 11, 8, 13, 4, 5, 10, 5, 8, 9, 12, 14, 9, 3, 8, 8, 11, 14, 15, 13, 7, 9, 12, 14, 7, 9, 9, 12, 8, 12, 3, 7, 5, 11, 13, 17, 13, 13, 11, 11, 8, 11, 15, 19, 17, 9, 11, 8, 6, 10, 8, 8, 14, 11, 12, 12, 10, 11, 11, 7, 9, 10, 12, 9, 8, 11, 13, 17, 9, 12, 8, 7, 14, 5, 5, 8, 5, 11, 10, 9, 8, 16, 8, 11, 6, 8, 13, 13, 14, 19, 14, 14, 16, 15, 20, 8, 5, 10, 15, 16, 8, 13, 13, 8, 11, 6, 9, 8, 7, 7, 8, 5, 13, 14, 13, 12, 14, 4, 5, 13, 8, 16, 10, 9, 7, 9, 6, 9, 7, 6, 2, 5, 9, 8, 9, 7, 10, 22, 9, 10, 9, 8, 11, 8, 10, 4, 14, 10, 8, 16, 10, 8, 5, 7, 7, 10, 13, 9, 13, 14, 8, 6, 15, 15, 11, 8, 10, 14, 5, 7, 10, 10, 19, 11, 15, 15, 10, 11, 9, 8, 16, 5, 8, 8, 4, 7, 9, 7, 10, 9, 6, 7, 5, 7, 9, 3, 13, 9, 8, 9, 17, 20, 10, 10, 8, 9, 8, 18, 7, 11, 7, 11, 9, 8, 8, 8, 12, 8, 11, 12, 11, 12, 9, 19, 15, 11, 15, 9, 10, 7, 9, 6, 8, 10, 16, 9, 7, 8, 7, 9, 10, 12, 8, 8, 9, 11, 14, 12, 10, 10, 8, 7, 12, 9, 10, 8, 11, 15, 12, 13, 12, 13, 16, 16, 8, 13, 11, 13, 8, 9, 21, 7, 8, 15, 12, 9, 11, 12, 10, 5, 4, 12, 15, 7, 20, 15, 11, 4, 12, 15, 14, 16, 11, 14, 16, 9, 13, 8, 9, 13, 6, 8, 8, 11, 5, 8, 10, 7, 9, 8, 8, 11, 11, 10, 14, 8, 11, 10, 5, 12, 4, 10, 12, 11, 13, 10, 6, 10, 12, 10, 14, 19, 18, 12, 12, 10, 11, 8, 2, 10, 14, 9, 7, 8, 12, 8, 8, 11, 11, 10, 6, 14, 8, 6, 11, 10, 6, 3, 6, 7, 9, 9, 16, 4, 6, 7, 7, 8, 5, 11, 9, 9, 9, 6, 8, 10, 3, 6, 13, 5, 12, 11, 16, 10, 10, 9, 15, 13, 8, 15, 11, 12, 4, 14, 8, 7, 12, 7, 14, 14, 12, 7, 16, 14, 14, 10, 10, 17, 6, 8, 5, 16, 15, 12, 10, 9, 10, 4, 8, 5, 8, 9, 9, 9, 9, 10, 12, 13, 7, 15, 12, 13, 7, 8, 9, 9, 10, 10, 11, 16, 12, 12, 11, 8, 10, 6, 12, 7, 9, 5, 7, 11, 7, 5, 9, 8, 12, 4, 11, 6, 11, 8, 7, 11, 8, 11, 17, 15, 5, 11, 23, 6, 16, 10, 6, 11, 10, 4, 8, 4, 10, 8, 16, 7, 13, 14, 12, 11, 12, 13, 12, 16, 5, 9, 22, 20, 20, 20, 5, 9, 7, 9, 12, 10, 4, 4, 2, 7, 7, 6, 4, 3, 7, 6, 5, 4, 4, 6, 9, 13, 9, 16, 14, 13, 10, 9, 4, 12, 9, 6, 9, 20, 16, 17, 6, 10, 8, 6, 2, 15, 8, 6, 15, 13, 12, 7, 10, 8, 10, 15, 9, 11, 13, 17, 13, 14, 3, 8, 6, 12, 10, 13, 8, 12, 12, 6, 12, 13, 6, 10, 12, 14, 10, 9, 6, 8, 7, 7, 13, 11, 13, 12, 10, 9, 8, 7, 3, 7, 14, 8, 5, 8, 16, 17, 16, 12, 6, 10, 15, 14, 6, 11, 12, 10, 3, 8, 14, 11, 10, 12, 10, 6, 3, 14, 4, 10, 7, 8, 11, 11, 11, 6, 8, 11, 13, 10, 13, 10, 7, 6, 10, 5, 8, 7, 7, 11, 10, 8, 9, 7, 8, 11, 9, 8, 13, 11, 7, 5, 12, 9, 4, 11, 9, 11, 12, 9, 5, 6, 5, 9, 9, 12, 8, 3, 8, 2, 5, 9, 7, 4, 9, 9, 8, 7, 5, 5, 8, 9, 8, 8, 6, 5, 3, 5, 9, 8, 9, 14, 10, 8, 9, 13, 16, 9, 5, 8, 12, 8, 4, 5, 9, 9, 8, 8, 6, 4, 9, 6, 7, 11, 11, 8, 14, 11, 15, 8, 11, 10, 7, 13, 8, 12, 11, 12, 4, 12, 11, 15, 16, 12, 17, 13, 13, 12, 13, 12, 5, 8, 9, 7, 6, 9, 14, 11, 13, 14, 10, 8, 9, 14, 10, 5, 5, 10, 9, 17, 4, 11, 10, 4, 13, 12, 7, 17, 9, 12, 9, 11, 10, 9, 12, 15, 15, 9, 7, 5, 5, 6, 13, 6, 13, 5, 7, 6, 8, 3, 8, 10, 8, 10, 9, 7, 6, 9, 12, 15, 16, 14, 7, 12, 9, 10, 10, 12, 14, 13, 13, 11, 7, 8, 14, 13, 14, 9, 11, 11, 10, 21, 13, 6, 17, 12, 14, 10, 6, 10, 10, 13, 11, 10, 14, 11, 10, 12, 8, 13, 5, 5, 6, 12, 16, 9, 17, 15, 9, 8, 8, 5, 10, 11, 4, 8, 7, 7, 13, 8, 15, 13, 7, 17, 13, 15, 14, 10, 8, 12, 10, 14, 11, 5, 9, 6, 13, 13, 11, 12, 15, 10, 16, 10, 15, 11, 15, 10, 11, 10, 13, 10, 11, 10, 9, 11, 10, 5, 10, 10, 18, 13, 10, 13, 11, 10, 15, 12, 12, 15, 16, 12, 7, 12, 17, 11, 10, 9, 8, 4, 11, 13, 5, 11, 9, 14, 12, 9, 7, 8, 11, 13, 9, 10, 8, 4, 7, 9, 5, 6, 11, 9, 9, 9, 12, 10, 10, 13, 17, 6, 11, 7, 12, 11, 10, 12, 9, 12, 11, 7, 5, 10, 5, 7, 9, 8, 10, 10, 10, 11, 3, 6, 8, 12, 6, 11, 13, 13, 13, 14, 9, 7, 4, 17, 8, 6, 11, 10, 7, 6, 8, 12, 7, 8, 12, 9, 9, 12, 9, 9, 4, 10, 9, 5, 15, 9, 12, 8, 10, 3, 11, 7, 13, 10, 11, 12, 11, 8, 11, 3, 12, 7, 4, 3, 8, 6, 8, 8, 11, 7, 6, 9, 20, 13, 6, 4, 7, 10, 7, 11, 11, 4, 14, 11, 7, 11, 8, 6, 6, 7, 7, 5, 14, 8, 9, 9, 12, 17, 7, 12, 11, 11, 15, 3, 14, 12, 10, 4, 9, 7, 7, 14, 10, 6, 13, 10, 8, 9, 13, 10, 12, 7, 14, 8, 12, 7, 7, 7, 9, 4, 6, 9, 9, 4, 7, 11, 7, 7, 4, 8, 4, 10, 4, 14, 6, 9, 7, 5, 13, 11, 8, 4, 5, 10, 9, 8, 14, 8, 6, 11, 8, 12, 15, 6, 13, 10, 12, 10, 7, 11, 15, 3, 11, 14, 11, 13, 6, 12, 17, 11, 10, 3, 13, 12, 11, 9, 7, 12, 6, 8, 15, 9, 7, 17, 14, 13, 9, 8, 9, 3, 12, 10, 6, 11, 13, 6, 5, 14, 6, 9, 8, 11, 11, 7, 9, 8, 13, 9, 9, 8, 13, 7, 13, 11, 12, 9, 10, 8, 8, 9, 11, 22, 9, 15, 17, 12, 3, 12, 10, 8, 13, 9, 8, 9, 9, 15, 13, 6, 11, 11, 12, 15, 9, 10, 18, 12, 10, 10, 11, 10, 3, 7, 10, 7, 11, 10, 10, 13, 8, 13, 15, 15, 6, 9, 13, 6, 11, 8, 11, 5, 11, 9, 19, 16, 8, 8, 12, 10, 16, 7, 12, 8, 7, 13, 7, 4, 9, 11, 9, 13, 12, 12, 6, 6, 9, 7, 6, 6, 16, 8, 7, 8, 8, 5, 4, 10, 6, 7, 12, 14, 6, 9, 10, 6, 13, 12, 7, 10, 10, 14, 6, 14, 11, 14, 9, 10, 6, 13, 11, 9, 6, 7, 10, 9, 12, 12, 11, 11, 7, 12, 9, 11, 11, 5, 9, 19, 10, 9, 13, 16, 8, 5, 11, 6, 9, 14, 12, 6, 8, 6, 6, 6, 10, 6, 5, 5, 9, 6, 6, 8, 9, 10, 7, 3, 7, 4, 10, 11, 13, 11, 12, 9, 6, 6, 11, 9, 11, 10, 11, 10, 7, 9, 12, 8, 7, 7, 15, 11, 8, 8, 8, 11, 11, 9, 14, 10, 12, 16, 6, 9, 12, 10, 9, 12, 10, 11, 10, 9, 5, 10, 10, 7, 6, 8, 8, 6, 9, 6, 10, 6, 11, 9, 10, 14, 16, 13, 7, 14, 13, 6, 13, 11, 12, 9, 9, 10, 9, 9, 20, 12, 15, 8, 6, 11, 7, 3, 6, 11, 5, 5, 6, 12, 8, 11, 1, 12, 7, 12, 11, 8, 6, 6, 13, 6, 12, 11, 5, 10, 14, 7, 8, 9, 18, 12, 9, 10, 3, 1, 7, 4, 4, 7, 8, 7, 6, 3, 7, 17, 11, 13, 9, 6, 13, 13, 15, 4, 3, 10, 13, 8, 5, 10, 7, 6, 17, 11, 8, 9, 9, 6, 10, 9, 6, 8, 7, 11, 11, 11, 7, 4, 4, 11, 5, 8, 15, 11, 18, 7, 14, 10, 11, 11, 9, 14, 7, 17, 9, 15, 13, 12, 9, 9, 8, 7, 17, 10, 11, 13, 14, 13, 8, 8, 10, 5, 11, 9, 5, 9, 6, 11, 7, 4, 5, 7, 10, 7, 8, 12, 7, 6, 4, 5, 7, 12, 9, 2, 5, 6, 11, 3, 8, 13, 13, 13, 14, 7, 9, 12, 8, 12, 12, 11, 11, 4, 10, 8, 3, 6, 9, 6, 9, 6, 5, 11, 6, 8, 6, 12, 12, 10, 12, 13, 11, 9, 8, 13, 10, 12, 12, 10, 15, 5, 10, 11, 10, 4, 9, 10, 10, 12, 14, 7, 7, 10, 13, 13, 12, 7, 8, 14, 9, 9, 4, 6, 12, 11, 9, 8, 12, 4, 10, 10, 10, 4, 9, 4, 9, 4, 7, 15, 11, 10, 13, 5, 5, 10, 6, 10, 9, 7, 10, 10, 6, 6, 9, 19, 12, 16, 10, 10, 12, 14, 17, 12, 19, 8, 6, 16, 9, 20, 16, 10, 7, 7, 17, 8, 8, 6, 8, 10, 9, 15, 15, 12, 16, 4, 12, 12, 5, 5, 11, 8, 9, 9, 14, 8, 5, 9, 7, 14, 10, 6, 10, 10, 14, 18, 9, 13, 11, 8, 10, 8, 14, 11, 10, 22, 9, 5, 9, 10, 12, 11, 15, 11, 14, 14, 7, 12, 10, 7, 3, 7, 8, 5, 8, 16, 13, 8, 9, 7, 8, 9, 13, 13, 6, 14, 5, 14, 7, 10, 12, 16, 8, 13, 14, 7, 10, 9, 13, 10, 13, 10, 16, 6, 7, 8, 8, 10, 7, 15, 10, 15, 6, 13, 9, 11, 8, 9, 6, 8, 16, 9, 5, 9, 9, 10, 8, 7, 6, 8, 4, 7, 14, 8, 8, 10, 5, 3, 8, 11, 8, 12, 12, 6, 10, 8, 7, 9, 4, 11, 5, 6, 7, 7, 10, 11, 6, 10, 13, 8, 9, 8, 12, 10, 13, 8, 8, 11, 12, 8, 11, 4, 9, 8, 9, 10, 8, 9, 8, 9, 6, 6, 6, 8, 6, 9, 7, 12, 9, 7, 8, 8, 10, 8, 9, 17, 10, 10, 12, 6, 11, 10, 8, 10, 6, 10, 12, 8, 17, 15, 5, 11, 9, 7, 11, 8, 12, 12, 7, 8, 9, 8, 7, 4, 9, 4, 9, 8, 15, 14, 15, 10, 6, 12, 6, 15, 6, 7, 12, 13, 9, 14, 7, 11, 10, 10, 10, 8, 8, 10, 12, 8, 10, 11, 11, 7, 9, 9, 9, 10, 9, 12, 11, 7, 12, 5, 9, 13, 3, 6, 11, 6, 18, 12, 15, 8, 11, 9, 7, 7, 7, 9, 12, 10, 7, 8, 11, 9, 7, 7, 8, 10, 20, 16, 15, 12, 13, 12, 15, 9, 5, 7, 9, 11, 7, 7, 10, 0, 0, 0, 0, 0, 3, 3, 3, 4, 4, 4, 5, 6, 6, 10, 10, 16, 1, 8, 1, 2, 3, 4, 4, 5, 5, 6, 9, 11, 14, 14, 19, 1, 8, 14, 2, 6, 4, 7, 7, 11, 14, 4, 6, 10, 11, 12, 14, 15, 16, 2, 5, 8, 11, 11, 15, 8, 7, 2, 4, 6, 7, 8, 8, 8, 9, 10, 10, 10, 13, 13, 14, 14, 15, 16, 2, 8, 2, 4, 4, 4, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 13, 14, 14, 14, 14, 14, 14, 15, 15, 5, 6, 7, 7, 9, 17, 6, 8, 4, 12, 16, 17, 18, 21, 2, 9, 9, 11, 6, 6, 7, 2, 8, 10, 10, 11, 12, 12, 12, 13, 16, 19, 19, 2, 6, 8, 8, 10, 2, 10, 10, 2, 5, 5, 5, 6, 6, 6, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 13, 13, 14, 14, 14, 15, 15, 19, 2, 8, 2, 5, 5, 6, 6, 7, 7, 7, 7, 8, 9, 9, 10, 10, 10, 11, 11, 11, 16, 5, 5, 5, 5, 6, 6, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 10, 10, 11, 11, 13, 13, 13, 14, 14, 16, 19, 17, 5, 7, 5, 7, 7, 8, 10, 10, 11, 15, 9, 17, 20, 2, 2, 6, 10, 2, 5, 10, 12, 7, 9, 9, 14, 16, 16, 17, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 14, 14, 14, 15, 20, 21, 22, 3, 5, 5, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 17, 18, 19, 19, 19, 20, 20, 22, 3, 9, 6, 7, 9, 9, 10, 10, 11, 3, 5, 5, 12, 3, 6, 7, 8, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 15, 15, 15, 15, 16, 16, 16, 17, 17, 19, 23, 25, 3, 7, 8, 12, 5, 5, 5, 5, 5, 5, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 17, 17, 19, 25, 3, 6, 6, 7, 7, 8, 9, 10, 11, 11, 16, 7, 8, 8, 8, 10, 11, 11, 11, 12, 14, 14, 15, 15, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 10, 10, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 14, 15, 15, 17, 17, 19, 3, 7, 8, 9, 9, 9, 10, 11, 11, 12, 13, 15, 16, 24, 3, 3, 5, 6, 6, 6, 7, 7, 8, 8, 8, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 14, 14, 15, 15, 16, 17, 20, 6, 14, 12, 14, 3, 3, 6, 7, 7, 7, 7, 7, 8, 9, 10, 10, 11, 12, 12, 13, 13, 14, 15, 15, 25, 5, 7, 7, 8, 9, 9, 11, 11, 11, 11, 12, 13, 14, 15, 16, 16, 17, 3, 5, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 13, 13, 14, 15, 15, 15, 16, 16, 18, 8, 17, 4, 6, 7, 7, 7, 7, 9, 9, 10, 10, 10, 11, 11, 11, 11, 11, 11, 12, 12, 13, 13, 13, 14, 3, 4, 8, 3, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 17, 19, 19, 19, 20, 20, 21, 24, 3, 5, 8, 8, 9, 10, 12, 13, 14, 14, 15, 16, 16, 17, 17, 3, 7, 7, 8, 8, 8, 8, 8, 8, 8, 9, 9, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 15, 15, 16, 16, 17, 17, 18, 3, 11, 9, 12, 5, 9, 10, 10, 12, 14, 15, 21, 8, 8, 9, 11, 12, 22, 3, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 15, 16, 16, 17, 17, 20, 5, 9, 7, 8, 12, 3, 3, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 10, 11, 11, 11, 11, 12, 12, 13, 13, 13, 14, 14, 15, 19, 20, 3, 6, 6, 6, 6, 6, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 15, 15, 15, 16, 16, 16, 16, 19, 3, 15, 3, 8, 10, 6, 6, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 14, 14, 15, 15, 15, 15, 15, 15, 15, 16, 17, 17, 17, 18, 20, 20, 13, 13, 14, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 13, 14, 8, 9, 9, 9, 11, 11, 11, 12, 12, 14, 16, 7, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 11, 12, 12, 12, 12, 13, 15, 16, 10, 5, 8, 11, 12, 12, 13, 13, 13, 14, 14, 8, 9, 12, 16, 16, 17, 4, 6, 6, 7, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 11, 11, 12, 13, 13, 14, 14, 16, 18, 18, 20, 21, 9, 9, 9, 9, 10, 10, 10, 10, 11, 11, 11, 12, 12, 14, 9, 10, 11, 12, 13, 14, 15, 15, 9, 13, 6, 8, 9, 11, 11, 12, 12, 12, 13, 14, 10, 11, 12, 14, 17, 10, 10, 12, 12, 12, 13, 15, 16, 16, 22, 5, 6, 7, 7, 9, 10, 10, 11, 13, 4, 11, 13, 12, 13, 15, 9, 15, 6, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 15, 15, 16, 17, 17, 17, 17, 17, 16, 7, 11, 12, 13, 13, 16, 9, 9, 12, 13, 16, 16, 4, 13, 13, 17, 12, 15, 16, 8, 10, 10, 10, 11, 11, 13, 14, 7, 8, 8, 8, 9, 9, 9, 9, 9, 10, 10, 11, 11, 11, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 14, 15, 15, 15, 15, 16, 16, 16, 18, 21, 30, 4, 11, 13, 16, 8, 8, 9, 11, 12, 4, 7, 8, 8, 9, 9, 9, 9, 9, 9, 9, 10, 10, 12, 12, 13, 14, 16, 21, 7, 7, 9, 10, 10, 10, 10, 10, 10, 11, 13, 13, 14, 16, 16, 17, 17, 24, 4, 6, 8, 9, 12, 7, 8, 8, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 12, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 15, 15, 15, 16, 16, 17, 17, 18, 19, 18, 21, 11, 12, 17, 19, 8, 9, 9, 9, 9, 9, 10, 10, 10, 11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 16, 16, 16, 17, 18, 7, 8, 9, 9, 9, 10, 12, 13, 17, 9, 10, 10, 12, 13, 14, 14, 16, 17, 17, 10, 16, 23, 5, 6, 6, 7, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 19, 20, 14, 9, 12, 13, 9, 9, 10, 10, 11, 12, 12, 12, 13, 13, 15, 15, 16, 17, 18, 22, 9, 11, 12, 13, 17, 10, 11, 7, 7, 8, 9, 9, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 15, 15, 16, 16, 16, 17, 17, 17, 17, 18, 18, 22, 5, 7, 7, 8, 8, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16, 17, 18, 18, 18, 18, 21, 23, 11, 12, 8, 8, 9, 9, 10, 11, 13, 13, 14, 14, 14, 15, 5, 8, 9, 9, 9, 9, 10, 11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 15, 15, 16, 17, 19, 24, 5, 9, 11, 12, 9, 6, 9, 10, 12, 12, 13, 14, 15, 15, 16, 16, 22, 12, 8, 11, 11, 11, 12, 15, 16, 12, 9, 10, 10, 12, 12, 12, 12, 13, 15, 15, 16, 16, 16, 18, 20, 21, 6, 10, 7, 8, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 21, 24, 26, 6, 14, 17, 17, 10, 8, 9, 9, 9, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 18, 18, 18, 19, 19, 19, 8, 9, 11, 12, 10, 10, 9, 9, 9, 10, 10, 10, 10, 11, 11, 11, 11, 12, 13, 13, 14, 15, 17, 18, 19, 10, 10, 11, 13, 13, 19, 11, 11, 13, 15, 15, 16, 9, 10, 10, 11, 11, 12, 12, 13, 14, 14, 14, 15, 15, 15, 15, 15, 16, 18, 6, 15, 9, 11, 12, 14, 14, 15, 15, 16, 17, 6, 12, 14, 14, 17, 25, 11, 19, 9, 12, 13, 13, 23, 11, 15, 10, 11, 9, 10, 10, 10, 12, 12, 12, 13, 13, 13, 14, 14, 14, 14, 14, 15, 15, 16, 16, 16, 17, 17, 18, 19, 19, 19, 20, 20, 21, 7, 16, 10, 13, 14, 18, 18, 10, 10, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 19, 19, 19, 19, 19, 20, 21, 22, 22, 23, 24, 7, 12, 13, 13, 17, 17, 11, 11, 12, 12, 13, 13, 14, 15, 13, 18, 12, 11, 12, 12, 14, 14, 16, 16, 16, 19, 19, 20, 22, 10, 13, 13, 13, 14, 14, 15, 15, 17, 8, 12, 20, 8, 10, 10, 13, 14, 18, 18, 14, 14, 15, 16, 17, 18, 18, 21, 24, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 20, 20, 20, 21, 14, 14, 15, 15, 16, 18, 18, 18, 19, 19, 13, 13, 14, 14, 14, 15, 15, 17, 17, 18, 18, 19, 19, 22, 14, 14, 15, 16, 16, 17, 19, 12, 15, 18, 22, 22, 10, 13, 14, 15, 15, 16, 16, 16, 18, 19, 20, 23, 25, 14, 15, 17, 13, 16, 16, 17, 19, 19, 21, 23, 17, 17, 17, 18, 18, 19, 20, 20, 20, 20, 21, 17, 18, 20, 23, 23, 16, 17, 23 }
    ' unsigned offset;

    if ( c1 < 0xB0 || c1 > 0xF7
        || c2 < 0xA1 || c2 > 0xFE )
    {
        // not a valid gb2312 Chinese character
        return -1;
    }

    offset = ((unsigned)c1-0xB0) * (0xFE-0xA0) + ((unsigned)c2-0xA1);
    return gb2312_stroke_count[ offset ];
    区码 ＝ 取代码 (取文本左边 (汉字, 1), )
    位码 ＝ 取代码 (取文本中间 (汉字, 2, 1), )
    .如果真 (区码 ＜ 176 或 区码 ＞ 247 或 位码 ＜ 161 或 位码 ＞ 254)
        返回 (-1)
    .如果真结束
    索引 ＝ (区码 － 176) × (254 － 160) ＋ (位码 － 161)
    返回 (数据 [索引 ＋ 1])

.子程序 文本_取中间_批量, 整数型, 公开, 比如：欲取全文本为<12345>,现在要取出“3”，<3>的前面为“2”，<3>的后面为“4”
    .参数 源文本, 文本型, , 比如：欲取全文本为 12345
    .参数 前面标识文本, 文本型, , 3的前面为“2”
    .参数 后面标识文本, 文本型, , 3的后面为“4”
    .参数 存放取出文本的数组, 文本型, 可空 数组, 存放取出文本的数组
    .参数 是否不区分大小写, 逻辑型, 可空, 是否区分大小写
    .参数 文本长度大于此数的不要, 整数型, 可空, 文本长度大于此数的不要;如取出的文本大于50的不要;留空为不限制(下面参数中的加入的后缀不算在其中，标志文本为真那么标志算在其中)
    .参数 为取出的文本加上前缀, 文本型, 可空, 在取出的文本前面加上一段字符或汉字！可空！
    .参数 为取出的文本加上后缀, 文本型, 可空, 在取出的文本后面加上一段字符或汉字！可空！
    .参数 连前面标识文本一起取出, 逻辑型, 可空, 是否连<前面标识文本>一起取出? 默认为假，不取出！
    .参数 连后面标识文本一起取出, 逻辑型, 可空, 是否连<后面标识文本>一起取出? 默认为假，不取出！
    .参数 起始位置, 整数型, 可空
    .局部变量 数组数量, 整数型
    .局部变量 已经找到的, 整数型
    .局部变量 StartPos, 整数型
    .局部变量 EndPos, 整数型
    .局部变量 Search, 文本型
    .局部变量 中间长度, 整数型

    清除数组 (存放取出文本的数组)
    StartPos ＝ 起始位置
    .循环判断首 ()
        StartPos ＝ 寻找文本 (源文本, 前面标识文本, StartPos, 是否不区分大小写)
        .如果 (StartPos ≠ -1)
            StartPos ＝ StartPos ＋ 取文本长度 (前面标识文本)
            EndPos ＝ 寻找文本 (源文本, 后面标识文本, StartPos, 是否不区分大小写)
            .如果 (EndPos ≠ -1)
                中间长度 ＝ EndPos － StartPos
                Search ＝ 取文本中间 (源文本, StartPos, 中间长度)
                Search ＝ 为取出的文本加上前缀 ＋ Search ＋ 为取出的文本加上后缀
                
                .如果真 (连前面标识文本一起取出 ＝ 真)
                    Search ＝ 前面标识文本 ＋ Search
                .如果真结束
                .如果真 (连后面标识文本一起取出 ＝ 真)
                    Search ＝ Search ＋ 后面标识文本
                .如果真结束
                
                .如果 (文本长度大于此数的不要 ＝ 0)
                    加入成员 (存放取出文本的数组, Search)
                .否则
                    
                    .如果真 (取文本长度 (Search) ＜ 文本长度大于此数的不要)
                        加入成员 (存放取出文本的数组, Search)
                    .如果真结束
                    
                .如果结束
                处理事件 ()
            .否则
                跳出循环 ()
            .如果结束
            处理事件 ()
        .否则
            跳出循环 ()
        .如果结束
        处理事件 ()
    .循环判断尾 (StartPos ≠ -1)
    返回 (取数组成员数 (存放取出文本的数组))

.子程序 文本_取中间_批量_正则方式, 整数型, 公开, 比如：欲取全文本为<12345>,现在要取出“3”，<3>的前面为“2”，<3>的后面为“4”
    .参数 源文本, 文本型, , 比如：欲取全文本为 12345
    .参数 前面标识文本, 文本型, , 3的前面为“2”
    .参数 后面标识文本, 文本型, , 3的后面为“4”
    .参数 存放取出文本的数组, 文本型, 可空 数组, 存放取出文本的数组
    .参数 是否区分大小写, 逻辑型, 可空, 是否区分大小写
    .参数 文本长度大于此数的不要, 整数型, 可空, 文本长度大于此数的不要，如取出的文本大于50的不要。留空为不限制
    .参数 为取出的文本加上前缀, 文本型, 可空, 在取出的文本前面加上一段字符或汉字！可空！
    .参数 为取出的文本加上后缀, 文本型, 可空, 在取出的文本后面加上一段字符或汉字！可空！
    .参数 连前面标识文本一起取出, 逻辑型, 可空, 是否连<前面标识文本>一起取出?  默认为假，不取出！
    .参数 连后面标识文本一起取出, 逻辑型, 可空, 是否连<后面标识文本>一起取出?  默认为假，不取出！
    .局部变量 局_计次, 整数型
    .局部变量 局_文本, 文本型
    .局部变量 正则, 正则表达式类

    清除数组 (存放取出文本的数组)
    正则.创建 (正则元字符转义 (前面标识文本) ＋ “([\s\S]*?)” ＋ 正则元字符转义 (后面标识文本), 源文本)
    .判断开始 (文本长度大于此数的不要 ≠ 0)
        .计次循环首 (正则.取匹配数量 (), 局_计次)
            局_文本 ＝ 正则.取子匹配文本 (局_计次, 1)
            .如果真 (取文本长度 (局_文本) ≤ 文本长度大于此数的不要)
                局_文本 ＝ 为取出的文本加上前缀 ＋ 局_文本 ＋ 为取出的文本加上后缀
                .如果真 (连前面标识文本一起取出)
                    局_文本 ＝ 前面标识文本 ＋ 局_文本
                .如果真结束
                .如果真 (连后面标识文本一起取出)
                    局_文本 ＝ 局_文本 ＋ 后面标识文本
                .如果真结束
                加入成员 (存放取出文本的数组, 局_文本)
            .如果真结束
            
        .计次循环尾 ()
    .默认
        ' 取匹配到的全部数据，不筛选
        .计次循环首 (正则.取匹配数量 (), 局_计次)
            局_文本 ＝ 正则.取子匹配文本 (局_计次, 1)
            局_文本 ＝ 为取出的文本加上前缀 ＋ 局_文本 ＋ 为取出的文本加上后缀
            .如果真 (连前面标识文本一起取出)
                局_文本 ＝ 前面标识文本 ＋ 局_文本
            .如果真结束
            .如果真 (连后面标识文本一起取出)
                局_文本 ＝ 局_文本 ＋ 后面标识文本
            .如果真结束
            加入成员 (存放取出文本的数组, 局_文本)
        .计次循环尾 ()
    .判断结束
    返回 (取数组成员数 (存放取出文本的数组))

.子程序 文本_倒取中间_批量, 整数型, 公开, 比如：欲取全文本为<12345>,现在要取出“3”，<3>的后面为“4”，<3>的前面为“2”
    .参数 源文本, 文本型, , 比如：欲取全文本为 12345
    .参数 后面标识文本, 文本型, , 3的后面为“4”
    .参数 前面标识文本, 文本型, , 3的前面为“2”
    .参数 存放取出文本的数组, 文本型, 可空 数组, 存放取出文本的数组
    .参数 是否不区分大小写, 逻辑型, 可空, 是否区分大小写
    .参数 文本长度大于此数的不要, 整数型, 可空, 文本长度大于此数的不要;如取出的文本大于50的不要;留空为不限制(下面参数中的加入的后缀不算在其中，标志文本为真那么标志算在其中)
    .参数 为取出的文本加上后缀, 文本型, 可空, 在取出的文本后面加上一段字符或汉字！可空！
    .参数 为取出的文本加上前缀, 文本型, 可空, 在取出的文本前面加上一段字符或汉字！可空！
    .参数 连后面标识文本一起取出, 逻辑型, 可空, 是否连<后面标识文本>一起取出? 默认为假，不取出！
    .参数 连前面标识文本一起取出, 逻辑型, 可空, 是否连<前面标识文本>一起取出? 默认为假，不取出！
    .参数 起始位置, 整数型, 可空
    .局部变量 StartPos, 整数型
    .局部变量 EndPos, 整数型
    .局部变量 Search, 文本型
    .局部变量 中间长度, 整数型
    .局部变量 lpos, 整数型

    清除数组 (存放取出文本的数组)
    EndPos ＝ 选择 (起始位置 ≤ 0, 取文本长度 (源文本) ＋ 取文本长度 (后面标识文本), 起始位置)
    .循环判断首 ()
        EndPos ＝ 倒找文本 (源文本, 后面标识文本, EndPos, 是否不区分大小写)
        .如果 (EndPos ≠ -1)
            StartPos ＝ 倒找文本 (源文本, 前面标识文本, EndPos, 是否不区分大小写)
            .如果 (StartPos ≠ -1)
                lpos ＝ StartPos ＋ 取文本长度 (前面标识文本)
                中间长度 ＝ EndPos － lpos
                EndPos ＝ StartPos
                Search ＝ 取文本中间 (源文本, lpos, 中间长度)
                Search ＝ 为取出的文本加上前缀 ＋ Search ＋ 为取出的文本加上后缀
                
                .如果真 (连后面标识文本一起取出 ＝ 真)
                    Search ＝ Search ＋ 后面标识文本
                .如果真结束
                .如果真 (连前面标识文本一起取出 ＝ 真)
                    Search ＝ 前面标识文本 ＋ Search
                .如果真结束
                
                .如果 (文本长度大于此数的不要 ＝ 0)
                    加入成员 (存放取出文本的数组, Search)
                .否则
                    .如果真 (取文本长度 (Search) ＜ 文本长度大于此数的不要)
                        加入成员 (存放取出文本的数组, Search)
                    .如果真结束
                    
                .如果结束
                处理事件 ()
            .否则
                跳出循环 ()
            .如果结束
            处理事件 ()
        .否则
            跳出循环 ()
        .如果结束
        处理事件 ()
    .循环判断尾 (EndPos ≠ -1)
    返回 (取数组成员数 (存放取出文本的数组))

.子程序 正则元字符转义, 文本型
    .参数 要处理的文本, 文本型
    .局部变量 局_文本, 文本型

    局_文本 ＝ 文本_替换 (要处理的文本, , , , “?”, “\?”, “*”, “\*”, “+”, “\+”, “[”, “\[”, “]”, “\]”)
    局_文本 ＝ 文本_替换 (局_文本, , , , “(”, “\(”, “)”, “\)”, “{”, “\{”, “}”, “\}”, “#引号”, #引号)
    局_文本 ＝ 文本_替换 (局_文本, , , , #换行符, “\n”, “|”, “\|”, , , , , , )
    返回 (局_文本)

.子程序 文本区分_只取汉字, 文本型, 公开, 在一大串网页源码中 只取出汉字
    .参数 源文本, 文本型, , 要取出汉字的源文本
    .参数 是否正则, 逻辑型, 可空, 可空，默认为假 不使用正则方式
    .参数 是否去除空格和空行, 逻辑型, 可空, 可为空，默认为假。
    .局部变量 正则, 正则表达式类
    .局部变量 局_临时文本, 文本型
    .局部变量 局_计次, 整数型
    .局部变量 局_源文本, 文本型

    .如果 (是否正则)
        正则.创建 (“[^\x20-\x7f]”, 源文本)
        .计次循环首 (正则.取匹配数量 (), 局_计次)
            局_临时文本 ＝ 局_临时文本 ＋ 正则.取匹配文本 (局_计次)
        .计次循环尾 ()
        .如果真 (是否去除空格和空行)
            正则.创建 (“\s”, 局_临时文本)
            局_临时文本 ＝ 正则.替换 (“”)
        .如果真结束
        返回 (局_临时文本)
    .否则
        局_源文本 ＝ 源文本
        .如果真 (是否去除空格和空行)
            局_源文本 ＝ 文本_替换 (源文本, , , , #换行符, “”, “ ”, “”)
        .如果真结束
        返回 (_只取汉字 (源文本))
    .如果结束
    ' 中文编码范围，中文汉字的正则也许用的着。
    ' 双字节字符编码范围：
    ' 一、 GBK (GB2312/GB18030)
    ' \x00-\xff          →GBK双字节编码范围
    ' \x20-\x7f         →ASCII
    ' \xa1-\xff 中文 →gb2312 取出所有中文
    ' \x80-\xff 中文 →gbk  取出所有中文
    
    ' 二、 UTF-8 (Unicode)
    
    ' \u4e00-\u9fa5     →(中文) 取出所有中文
    ' \x3130-\x318F    →(韩文)  取出所有韩文
    ' \xAC00-\xD7A3   →(韩文)  取出所有韩文
    ' \u0800-\u4e00   →(日文)   取出所有日文
    

.子程序 _只取汉字, 文本型, 公开
    .参数 字符串, 文本型
    .局部变量 aryBin, 字节集
    .局部变量 nMaxCount, 整数型
    .局部变量 szString, 文本型
    .局部变量 pszString, 整数型
    .局部变量 i, 整数型
    .局部变量 n, 整数型

    aryBin ＝ 到字节集 (字符串)
    nMaxCount ＝ 取字节集长度 (aryBin)
    szString ＝ 取空白文本 (nMaxCount)
    pszString ＝ 取指针文本_ (szString)
    i ＝ 1
    .判断循环首 (i ＜ nMaxCount)
        .如果真 (aryBin [i] ≥ 176 且 aryBin [i ＋ 1] ≥ 161 且 aryBin [i] ≤ 247 且 aryBin [i ＋ 1] ≤ 254)
            memcpy (pszString ＋ n, 取指针字节集_ (aryBin) ＋ i － 1, 2)
            n ＝ n ＋ 2
            i ＝ i ＋ 2
            到循环尾 ()
        .如果真结束
        .如果真 (aryBin [i] ≥ 129 且 aryBin [i] ≤ 160)
            .如果真 (aryBin [i ＋ 1] ≥ 64 且 aryBin [i ＋ 1] ≤ 126 或 (aryBin [i ＋ 1] ≥ 128 且 aryBin [i ＋ 1] ≤ 161) 或 (aryBin [i ＋ 1] ≥ 128 且 aryBin [i ＋ 1] ≤ 254))
                memcpy (pszString ＋ n, 取指针字节集_ (aryBin) ＋ i － 1, 2)
                n ＝ n ＋ 2
                i ＝ i ＋ 2
                到循环尾 ()
            .如果真结束
            
        .如果真结束
        .如果真 (aryBin [i] ≥ 170 且 aryBin [i] ≤ 254)
            .如果真 (aryBin [i ＋ 1] ≥ 64 且 aryBin [i ＋ 1] ≤ 126 或 (aryBin [i ＋ 1] ≥ 128 且 aryBin [i ＋ 1] ≤ 160))
                memcpy (pszString ＋ n, 取指针字节集_ (aryBin) ＋ i － 1, 2)
                n ＝ n ＋ 2
                i ＝ i ＋ 2
                到循环尾 ()
            .如果真结束
            
        .如果真结束
        .如果真 (aryBin [i] ≥ 170 且 aryBin [i] ≤ 176)
            .如果真 (aryBin [i ＋ 1] ≥ 64 且 aryBin [i ＋ 1] ≤ 126 或 (aryBin [i ＋ 1] ≥ 128 且 aryBin [i ＋ 1] ≤ 161))
                memcpy (pszString ＋ n, 取指针字节集_ (aryBin) ＋ i － 1, 2)
                n ＝ n ＋ 2
                i ＝ i ＋ 2
                到循环尾 ()
            .如果真结束
            
        .如果真结束
        .如果真 (aryBin [i] ＞ 127 且 aryBin [i ＋ 1] ＞ 127)
            i ＝ i ＋ 2
            到循环尾 ()
        .如果真结束
        i ＝ i ＋ 1
    .判断循环尾 ()
    assignZero (szString, n, )
    返回 (szString)

.子程序 文本区分_只取字母, 文本型, 公开, 在一大串网页源码中 只取字母
    .参数 源文本, 文本型, , 要取出字母的源文本
    .参数 大小写类型, 整数型, 可空, 默认为0  0=取大小写  1只取小写  2只取大写
    .局部变量 正则, 正则表达式类
    .局部变量 局_临时文本, 文本型
    .局部变量 局_计次, 整数型

    .判断开始 (大小写类型 ＝ 0)
        正则.创建 (“[a-zA-Z]”, 源文本, 真)
    .判断 (大小写类型 ＝ 1)
        正则.创建 (“[a-z]”, 源文本, 真)
    .判断 (大小写类型 ＝ 2)
        正则.创建 (“[A-Z]”, 源文本, 真)
    .默认
        
    .判断结束
    .计次循环首 (正则.取匹配数量 (), 局_计次)
        局_临时文本 ＝ 局_临时文本 ＋ 正则.取匹配文本 (局_计次)
    .计次循环尾 ()
    返回 (局_临时文本)

.子程序 文本区分_只取符号, 文本型, 公开, 在一大串网页源码中 只取符号
    .参数 源文本, 文本型, , 要取出符号的源文本
    .局部变量 正则, 正则表达式类
    .局部变量 局_临时文本, 文本型
    .局部变量 局_计次, 整数型

    正则.创建 (“[^0-9a-z\u4e00-\u9fa5]”, 源文本)
    .计次循环首 (正则.取匹配数量 (), 局_计次)
        局_临时文本 ＝ 局_临时文本 ＋ 正则.取匹配文本 (局_计次)
    .计次循环尾 ()
    返回 (局_临时文本)

.子程序 文本区分_只取数字, 文本型, 公开, 在一大串网页源码中 只取数字
    .参数 源文本, 文本型, , 要取出数字的源文本
    .局部变量 正则, 正则表达式类
    .局部变量 局_临时文本, 文本型
    .局部变量 局_计次, 整数型

    正则.创建 (“[0-9]”, 源文本)
    .计次循环首 (正则.取匹配数量 (), 局_计次)
        局_临时文本 ＝ 局_临时文本 ＋ 正则.取匹配文本 (局_计次)
    .计次循环尾 ()
    返回 (局_临时文本)

.子程序 文本_朗读, , 公开, 朗读一段指定的文本
    .参数 朗读的文本, 文本型, 可空
    .参数 百度语音引擎, 逻辑型, 可空, 可为空，默认使用微软语音引擎。
    .参数 音频数据, 字节集, 可空
    .参数 音频文件, 文本型, 可空, 如：C:\mp3，C:\MAV等等
    .参数 保存朗读文本至文件, 文本型, 可空, 只针对“朗读的文本”和“音频数据”有效，请提供要保存至的文件夹路径，如：C:\
    .参数 朗读方式, 逻辑型, 可空, 真=支持库方式  假=API方式  默认为假  API方式
    .局部变量 局_语音, 字节集
    .局部变量 局_文件名, 文本型
    .局部变量 局_引擎地址, 文本型

    输出调试文本 (“文本_朗读 命令已弃用，请改用 文本_到语音。”)
    
    局_文件名 ＝ “”
    .如果真 (是否为空 (保存朗读文本至文件) ＝ 假 且 目录_是否存在 (保存朗读文本至文件))
        .如果真 (取文本左边 (保存朗读文本至文件, 1) ≠ “\”)
            保存朗读文本至文件 ＝ 保存朗读文本至文件 ＋ “\”
        .如果真结束
        
    .如果真结束
    .判断开始 (删首尾空 (朗读的文本) ≠ “”)
        局_文件名 ＝ 目录_取临时目录 () ＋ 校验_取md5 (到字节集 (朗读的文本)) ＋ “.mp3”
        .如果真 (文件_是否存在 (局_文件名) ＝ 假)
            .如果 (百度语音引擎)
                局_引擎地址 ＝ “http://tts.baidu.com/text2audio?lan=zh&ie=UTF-8&text=” ＋ 编码_URL编码 (朗读的文本, , 真)
            .否则
                局_引擎地址 ＝ “http://api.microsofttranslator.com/V2/Http.svc/Speak?language=zh-CN&appid=05DBC69E5594C137B9E22680F92F8E5E115A7817&text=” ＋ 编码_URL编码 (朗读的文本, , 真) ＋ “&format=audio/mp3&options=MaxQuality”
            .如果结束
            局_语音 ＝ 网页_访问 (局_引擎地址)
            写到文件 (局_文件名, 局_语音)
        .如果真结束
        
        .如果真 (是否为空 (保存朗读文本至文件) ＝ 假)
            .如果 (取字节集长度 (局_语音) ＝ 0)
                文件_复制 (局_文件名, 保存朗读文本至文件 ＋ 朗读的文本 ＋ “.mp3”, 0)
            .否则
                写到文件 (保存朗读文本至文件 ＋ 朗读的文本 ＋ “.mp3”, 局_语音)
            .如果结束
            
        .如果真结束
        
    .判断 (是否为空 (音频数据) ＝ 假)
        局_文件名 ＝ 目录_取临时目录 () ＋ 校验_取md5 (音频数据) ＋ “.mp3”
        .如果真 (文件_是否存在 (局_文件名) ＝ 假)
            写到文件 (局_文件名, 音频数据)
        .如果真结束
        
        .如果真 (是否为空 (保存朗读文本至文件) ＝ 假)
            写到文件 (保存朗读文本至文件 ＋ “音频数据.mp3”, 音频数据)
        .如果真结束
        
        
    .判断 (文件_是否存在 (音频文件))
        局_文件名 ＝ 音频文件
        
    .默认
        输出调试文本 (“朗读的文本、音频数据和音频文件必须提供一个”)
    .判断结束
    
    .如果真 (文件_是否存在 (局_文件名))
        .判断开始 (朗读方式)
            播放MP3 (1, 局_文件名)
        .默认
            音乐_播放 (局_文件名, 文本_取随机汉字 (10, ))
        .判断结束
        
    .如果真结束
    

.子程序 文本_朗读Ex, 逻辑型, 公开, 本命令由【sizaizuotian】提供接口
    .参数 朗读文本, 文本型
    .参数 保存朗读文本至文件, 文本型, 可空
    .参数 朗读方式, 逻辑型, 可空, 真=支持库方式  假=API方式  默认为假  API方式
    .局部变量 局_朗读内容, 文本型
    .局部变量 局_接口地址, 文本型
    .局部变量 局_朗读文件, 字节集
    .局部变量 局_临时文件, 文本型
    .局部变量 局_保存结果, 逻辑型

    局_朗读内容 ＝ 编码_URL编码 (朗读文本, , 真)
    局_接口地址 ＝ “http://fanyi.baidu.com/gettts?lan=zh&text=” ＋ 局_朗读内容 ＋ “&spd=5&source=web.mp3”
    局_朗读文件 ＝ 网页_访问_对象 (局_接口地址)
    .如果 (是否为空 (保存朗读文本至文件) ＝ 假)
        局_保存结果 ＝ 写到文件 (保存朗读文本至文件, 局_朗读文件)
        返回 (局_保存结果)
    .否则
        局_临时文件 ＝ 目录_取临时目录 () ＋ 校验_取md5 (到字节集 (局_朗读文件)) ＋ “.mp3”
        局_保存结果 ＝ 写到文件 (局_临时文件, 局_朗读文件)
        .判断开始 (朗读方式)
            播放MP3 (1, 局_临时文件)
        .默认
            音乐_播放 (局_临时文件, 文本_取随机汉字 (10, ))
        .判断结束
        
        返回 (局_保存结果)
    .如果结束
    返回 (真)
    

.子程序 文本_指针到文本A, 文本型, 公开, 返回指定内存指针所指向地址处的文本，注意调用本命令前一定要确保所提供的内存指针真实有效，且指向一个以零字符结束的文本串。
    .参数 内存文本指针, 整数型

    返回 (lstrcat (内存文本指针, 0))

.子程序 文本_指针到文本W, 文本型, 公开, 取内存中Unicode字符串文本。返回指定内存指针所指向地址处的文本，注意调用本命令前一定要确保所提供的内存指针真实有效，且指向一个以零字符结束的文本串。 
    .参数 Unicode内存指针
    .局部变量 tmp, 字节型, , "0"
    .局部变量 tmpLen

    .如果真 (Unicode内存指针 ≠ 0)
        tmpLen ＝ lstrlen (Unicode内存指针) × 2 ＋ 8
        .如果真 (tmpLen ≠ 0)
            重定义数组 (tmp, 假, tmpLen － 1)
            RtlMoveMemory (取数据_通用型_数组 (tmp), Unicode内存指针, tmpLen)
            返回 (编码_Unicode到Ansi (到字节集 (tmp)))
        .如果真结束
        
    .如果真结束
    返回 (“”)
    

.子程序 文本_加密c, 字节集, 公开, 支持密钥加密，成功返回加密后文本，失败返回空。
    .参数 欲加密文本, 文本型
    .参数 密码, 文本型, 可空, 可为空，默认为 “bbs.125.la”
    .局部变量 lHHash
    .局部变量 lHkey
    .局部变量 lHCryptprov
    .局部变量 lCryptLength
    .局部变量 lCryptBufLen
    .局部变量 sCryptBuffer, 字节集
    .局部变量 bresult, 逻辑型

    .如果真 (取文本长度 (欲加密文本) ≠ 0)
        bresult ＝ 1 ＝ CryptAcquireContextA (lHCryptprov, 字符 (0), “Microsoft Base Cryptographic Provider v1.0”, 1, 0)
        .如果真 (bresult ＝ 假) ' 如果没有默认密钥容器，然后创建一个
            bresult ＝ 1 ＝ CryptAcquireContextA (lHCryptprov, 字符 (0), “Microsoft Base Cryptographic Provider v1.0”, 1, 8)
            .如果真 (bresult ＝ 假)
                返回 ({ })
            .如果真结束
            
        .如果真结束
        密码 ＝ 选择 (是否为空 (密码), “bbs.125.la”, 密码)
        CryptCreateHash (lHCryptprov, 32771, 0, 0, lHHash)
        CryptHashData (lHHash, 到字节集 (密码), 取文本长度 (密码), 0)
        CryptDeriveKey (lHCryptprov, 26625, lHHash, 0, lHkey)
        CryptDestroyHash (lHHash)
        
        lCryptLength ＝ 取文本长度 (欲加密文本)
        lCryptBufLen ＝ lCryptLength
        sCryptBuffer ＝ 取空白字节集 (lCryptLength)
        sCryptBuffer ＝ 到字节集 (欲加密文本)
        
        bresult ＝ CryptEncrypt (lHkey, 0, 1, 0, sCryptBuffer, lCryptLength, lCryptBufLen)
        CryptDestroyKey (lHkey)
        CryptDestroyHash (lHHash)
        CryptReleaseContext (lHCryptprov, 0)
    .如果真结束
    返回 (选择 (bresult, sCryptBuffer, { }))

.子程序 文本_解密c, 文本型, 公开, 支持密钥解密，成功返回解密后文本，失败返回空。
    .参数 加密后文本, 字节集
    .参数 密码, 文本型, 可空, 可为空，默认为 “bbs.125.la”
    .局部变量 lHCryptprov
    .局部变量 lHHash
    .局部变量 lHkey
    .局部变量 bResult, 逻辑型
    .局部变量 sCryptBuffer, 字节集
    .局部变量 lCryptBufLen
    .局部变量 lCryptPoint

    .如果真 (取字节集长度 (加密后文本) ≠ 0)
        bResult ＝ 1 ＝ CryptAcquireContextA (lHCryptprov, 字符 (0), “Microsoft Base Cryptographic Provider v1.0”, 1, 0)
        .如果真 (bResult ＝ 假)
            bResult ＝ 1 ＝ CryptAcquireContextA (lHCryptprov, 字符 (0), “Microsoft Base Cryptographic Provider v1.0”, 1, 8)
            .如果真 (bResult ＝ 假)
                返回 (“”)
            .如果真结束
            
        .如果真结束
        密码 ＝ 选择 (是否为空 (密码), “bbs.125.la”, 密码)
        CryptCreateHash (lHCryptprov, 32771, 0, 0, lHHash)
        CryptHashData (lHHash, 到字节集 (密码), 取文本长度 (密码), 0)
        CryptDeriveKey (lHCryptprov, 26625, lHHash, 0, lHkey)
        CryptDestroyHash (lHHash)
        
        lCryptBufLen ＝ 取字节集长度 (加密后文本)
        sCryptBuffer ＝ 取空白字节集 (lCryptBufLen)
        sCryptBuffer ＝ 加密后文本
        bResult ＝ CryptDecrypt (lHkey, 0, 1, 0, sCryptBuffer, lCryptBufLen)
        
        CryptDestroyKey (lHkey)
        CryptDestroyHash (lHHash)
        CryptReleaseContext (lHCryptprov, 0)
    .如果真结束
    返回 (选择 (bResult, 到文本 (sCryptBuffer), “”))
    
    
    
    
    

.子程序 文本_加密, 文本型, 公开, 失败返回空文本
    .参数 参数_待加密文本, 文本型, , 待加密文本
    .参数 参数_加密的密码, 文本型, , 加密的密码<建议5位以上的数字>
    .局部变量 局_计次, 整数型
    .局部变量 局_过度字节集, 字节集
    .局部变量 局_待加密文本, 字节集

    局_待加密文本 ＝ 到字节集 (参数_待加密文本)
    .计次循环首 (取字节集长度 (局_待加密文本), 局_计次)
        局_过度字节集 ＝ 局_过度字节集 ＋ 到字节集 (到字节 (位异或 (局_待加密文本 [局_计次], 3600)))
    .计次循环尾 ()
    返回 (字节集_字节集到十六进制 (局_过度字节集) ＋ 到大写 (取文本中间 (校验_取md5 (到字节集 (参数_加密的密码)), 3, 9)))

.子程序 文本_解密, 文本型, 公开, 失败返回空文本
    .参数 参数_待解密文本, 文本型, , 待解密文本
    .参数 参数_解密的密码, 文本型, , 解密的密码<建议5位以上的数字>
    .局部变量 局_计次, 整数型
    .局部变量 局_过度字节集, 字节集
    .局部变量 局_待加密文本, 字节集

    .如果真 (取文本右边 (参数_待解密文本, 9) ≠ 到大写 (取文本中间 (校验_取md5 (到字节集 (参数_解密的密码)), 3, 9)))
        返回 (“”)
    .如果真结束
    局_待加密文本 ＝ 字节集_十六进制到字节集 (取文本左边 (参数_待解密文本, 取文本长度 (参数_待解密文本) － 9))
    .计次循环首 (取字节集长度 (局_待加密文本), 局_计次)
        局_过度字节集 ＝ 局_过度字节集 ＋ 到字节集 (到字节 (位异或 (局_待加密文本 [局_计次], 3600)))
    .计次循环尾 ()
    返回 (到文本 (局_过度字节集))

.子程序 文本_加密_优化, 文本型, 公开, 失败返回空文本
    .参数 参数_待加密文本, 文本型, , 待加密文本
    .参数 参数_加密的密码, 文本型, , 加密的密码<建议5位以上的数字>
    .局部变量 局_计次, 整数型
    .局部变量 局_待加密文本, 字节集

    ' https://bbs.125.la/forum.php?mod=viewthread&tid=14655519
    局_待加密文本 ＝ 到字节集 (参数_待加密文本)
    .计次循环首 (取字节集长度 (局_待加密文本), 局_计次)
        局_待加密文本 [局_计次] ＝ 位异或 (局_待加密文本 [局_计次], 3600)
    .计次循环尾 ()
    返回 (字节集_字节集到十六进制2 (局_待加密文本) ＋ 到大写 (取文本中间 (校验_取md5 (到字节集 (参数_加密的密码), , ), 3, 9)))

.子程序 文本_解密_优化, 文本型, 公开, 失败返回空文本
    .参数 参数_待解密文本, 文本型, , 待解密文本
    .参数 参数_解密的密码, 文本型, , 解密的密码<建议5位以上的数字>
    .局部变量 局_计次, 整数型
    .局部变量 局_待加密文本, 字节集

    ' https://bbs.125.la/forum.php?mod=viewthread&tid=14655519
    .如果真 (取文本右边 (参数_待解密文本, 9) ≠ 到大写 (取文本中间 (校验_取md5 (到字节集 (参数_解密的密码), , ), 3, 9)))
        返回 (“”)
    .如果真结束
    局_待加密文本 ＝ 字节集_十六进制到字节集2 (取文本左边 (参数_待解密文本, 取文本长度 (参数_待解密文本) － 9))
    .计次循环首 (取字节集长度 (局_待加密文本), 局_计次)
        局_待加密文本 [局_计次] ＝ 位异或 (局_待加密文本 [局_计次], 3600)
    .计次循环尾 ()
    返回 (到文本 (局_待加密文本))

.子程序 文本_是否为数字, 逻辑型, 公开, 中间不能有空格,判断指定文本是否是数字
    .参数 参_文本, 文本型
    .局部变量 i, 整数型
    .局部变量 Len, 整数型
    .局部变量 asc, 整数型

    
    Len ＝ 取文本长度 (参_文本)
    .如果真 (Len ＝ 0)
        返回 (假)
    .如果真结束
    .计次循环首 (Len, i)
        asc ＝ 取代码 (参_文本, i)
        .判断开始 (asc ＜ 48) ' a=97
            返回 (假)
        .判断 (asc ＞ 57) ' z=122
            返回 (假)
        .默认
            
        .判断结束
        
    .计次循环尾 ()
    返回 (真)
    

.子程序 文本_自动补零, 文本型, 公开, 当指定文本长度不足时前面自动补零，通用用于数据库序列号
    .参数 参_欲补齐文本, 文本型
    .参数 参_补齐长度

    返回 (取重复文本 (参_补齐长度 － 取文本长度 (参_欲补齐文本), “0”) ＋ 参_欲补齐文本)

.子程序 文本_是否小写字母, 逻辑型, 公开, 中间不能有空格,By:邓学彬(泪闯天涯)
    .参数 字符串, 文本型
    .局部变量 Len, 整数型
    .局部变量 i, 整数型
    .局部变量 asc, 整数型

    Len ＝ 取文本长度 (字符串)
    .如果真 (Len ＝ 0)
        返回 (假)
    .如果真结束
    .计次循环首 (Len, i)
        asc ＝ 取代码 (字符串, i)
        .判断开始 (asc ＜ 97) ' a=97
            返回 (假)
        .判断 (asc ＞ 122) ' z=122
            返回 (假)
        .默认
            
        .判断结束
        
    .计次循环尾 ()
    返回 (真)

.子程序 文本_是否大写字母, 逻辑型, 公开, 中间不能有空格,By:邓学彬(泪闯天涯)
    .参数 字符串, 文本型
    .局部变量 Len, 整数型
    .局部变量 i, 整数型
    .局部变量 asc, 整数型

    Len ＝ 取文本长度 (字符串)
    .如果真 (Len ＝ 0)
        返回 (假)
    .如果真结束
    .计次循环首 (Len, i)
        asc ＝ 取代码 (字符串, i)
        .判断开始 (asc ＜ 65) ' A=65
            返回 (假)
        .判断 (asc ＞ 90) ' Z=90
            返回 (假)
        .默认
            
        .判断结束
        
    .计次循环尾 ()
    返回 (真)

.子程序 文本_取某位置文本, 文本型, 公开, 取某位置下的文本，如果指定位置超出文本长度，返回空文本。
    .参数 文本, 文本型
    .参数 位置, 整数型
    .参数 取出文本类型, 逻辑型, 参考 可空, 得到指定位置的文本类型，全角为真，半角为假。
    .局部变量 _局部变量1, 文本型

    ' https://bbs.125.la/thread-14428295-1-1.html
    .如果真 (位置 ＞ 取文本长度 (文本) 或 位置 ≤ 0)
        返回 (“”)
    .如果真结束
    _局部变量1 ＝ 取文本中间 (文本, 位置, 2)
    .如果真 (取代码 (_局部变量1, ) ＜ 0)
        _局部变量1 ＝ 取文本中间 (文本, 位置 － 1, 2)
        .如果真 (取代码 (_局部变量1, ) ＜ 0)
            取出文本类型 ＝ 真
            返回 (_局部变量1)
        .如果真结束
        取出文本类型 ＝ 真
        返回 (取文本中间 (文本, 位置, 2))
    .如果真结束
    取出文本类型 ＝ 假
    返回 (取文本中间 (文本, 位置, 1))

.子程序 文本_文本比较W, 整数型, 公开, 如果返回值小于0，表示文本一小于文本二；如果等于0，表示文本一等于文本二；如果大于0，表示文本一大于文本二。
    .参数 待比较文本一, 整数型
    .参数 待比较文本二, 整数型
    .参数 是否区分大小写, 逻辑型, 可空, 为真区分大小写，为假不区分。
    .局部变量 sByte1, 短整数型
    .局部变量 sByte2, 短整数型
    .局部变量 iRet, 整数型
    .局部变量 bRet, 逻辑型

    .循环判断首 ()
        ' 传入指针无效按相减结果判断
        .如果真 (指针_是否有效 (待比较文本一) ＝ 假 或 指针_是否有效 (待比较文本二) ＝ 假)
            iRet ＝ 待比较文本一 － 待比较文本二
            跳出循环 ()
        .如果真结束
        sByte1 ＝ 指针_到短整数型_汇编 (待比较文本一)
        sByte2 ＝ 指针_到短整数型_汇编 (待比较文本二)
        iRet ＝ sByte1 － sByte2
        .判断开始 (iRet ＝ 0)
            bRet ＝ 真
        .判断 (是否区分大小写 ＝ 假 且 (sByte1 ≥ 65 且 sByte1 ≤ 90 或 (sByte1 ≥ 97 且 sByte1 ≤ 122))) ' a-z A-Z
            bRet ＝ iRet ＝ 32 或 iRet ＝ -32
        .默认
            bRet ＝ 假
        .判断结束
        待比较文本一 ＝ 待比较文本一 ＋ 2
        待比较文本二 ＝ 待比较文本二 ＋ 2
    .循环判断尾 (bRet 且 sByte1 ≠ 0)
    .判断开始 (iRet ＜ 0)
        返回 (-1)
    .判断 (iRet ＞ 0)
        返回 (1)
    .默认
        返回 (0)
    .判断结束
    

.子程序 文本_行尾序列转换, 文本型, 公开, LF转CRLF
    .参数 欲被转换的文本, 文本型
    .局部变量 szText, 文本型
    .局部变量 aryPos, 整数型, , "0"
    .局部变量 len, 整数型
    .局部变量 i, 整数型

    szText ＝ 欲被转换的文本
    文本_取文本起始位置 (szText, 字符 (10), aryPos)
    len ＝ 取数组成员数 (aryPos)
    .变量循环首 (len, 1, -1, i)
        .如果真 (取文本中间 (szText, aryPos [i] － 1, 1) ≠ 字符 (13))
            szText ＝ 文本替换 (szText, aryPos [i], 1, #换行符)
        .如果真结束
        
    .变量循环尾 ()
    返回 (szText)

.子程序 格式化文本A, 文本型, 公开, 字节集类型的参数必须传递数据指针, 比如 取指针_字节集型() 
    .参数 格式, 文本型
    .参数 参数1, 通用型, 参考 可空
    .参数 参数2, 通用型, 参考 可空
    .参数 参数3, 通用型, 参考 可空
    .参数 参数4, 通用型, 参考 可空
    .参数 参数5, 通用型, 参考 可空
    .参数 参数6, 通用型, 参考 可空
    .参数 参数7, 通用型, 参考 可空
    .参数 参数8, 通用型, 参考 可空
    .参数 参数9, 通用型, 参考 可空
    .参数 参数10, 通用型, 参考 可空
    .参数 参数11, 通用型, 参考 可空
    .参数 参数12, 通用型, 参考 可空
    .参数 参数13, 通用型, 参考 可空
    .参数 参数14, 通用型, 参考 可空
    .参数 参数15, 通用型, 参考 可空
    .参数 参数16, 通用型, 参考 可空
    .参数 参数17, 通用型, 参考 可空
    .参数 参数18, 通用型, 参考 可空
    .参数 参数19, 通用型, 参考 可空
    .参数 参数20, 通用型, 参考 可空
    .局部变量 buf, 整数型
    .局部变量 bufSize, 整数型
    .局部变量 list, 整数型
    .局部变量 i, 整数型
    .局部变量 len, 整数型
    .局部变量 ret, 文本型
    .局部变量 format, 整数型

    list ＝ __make_list ()
    .如果真 (list ＝ 0)
        返回 (“”)
    .如果真结束
    bufSize ＝ 4096
    buf ＝ malloc (bufSize)
    format ＝ 取指针_文本型 (格式)
    len ＝ _vsnprintf_s (buf, bufSize, bufSize － 1, format, list)
    .判断循环首 (len ＝ -1)
        free (buf)
        bufSize ＝ bufSize × 2
        buf ＝ malloc (bufSize)
        len ＝ _vsnprintf_s (buf, bufSize, bufSize － 1, format, list)
    .判断循环尾 ()
    ret ＝ 指针到文本 (buf)
    free (buf)
    free (list)
    返回 (ret)

.子程序 格式化文本W, 字节集, 公开, Unicode文本必须以\0\0结尾, 字节集类型的参数必须传递数据指针, 比如 取指针_字节集型() 
    .参数 格式, 字节集
    .参数 参数1, 通用型, 参考 可空
    .参数 参数2, 通用型, 参考 可空
    .参数 参数3, 通用型, 参考 可空
    .参数 参数4, 通用型, 参考 可空
    .参数 参数5, 通用型, 参考 可空
    .参数 参数6, 通用型, 参考 可空
    .参数 参数7, 通用型, 参考 可空
    .参数 参数8, 通用型, 参考 可空
    .参数 参数9, 通用型, 参考 可空
    .参数 参数10, 通用型, 参考 可空
    .参数 参数11, 通用型, 参考 可空
    .参数 参数12, 通用型, 参考 可空
    .参数 参数13, 通用型, 参考 可空
    .参数 参数14, 通用型, 参考 可空
    .参数 参数15, 通用型, 参考 可空
    .参数 参数16, 通用型, 参考 可空
    .参数 参数17, 通用型, 参考 可空
    .参数 参数18, 通用型, 参考 可空
    .参数 参数19, 通用型, 参考 可空
    .参数 参数20, 通用型, 参考 可空
    .局部变量 buf, 整数型
    .局部变量 bufSize, 整数型
    .局部变量 format, 整数型
    .局部变量 list, 整数型
    .局部变量 i, 整数型
    .局部变量 len, 整数型
    .局部变量 ret, 字节集

    list ＝ __make_list ()
    .如果真 (list ＝ 0)
        返回 ({ })
    .如果真结束
    bufSize ＝ 4096
    buf ＝ malloc (bufSize × 2) ' Unicode单位是字符长度, 这里申请的长度需要按字节来申请
    format ＝ 取指针_字节集型 (格式)
    len ＝ _vsnwprintf_s (buf, bufSize, bufSize － 1, format, list)
    .判断循环首 (len ＝ -1)
        free (buf)
        bufSize ＝ bufSize × 2
        buf ＝ malloc (bufSize × 2)
        len ＝ _vsnwprintf_s (buf, bufSize, bufSize － 1, format, list)
    .判断循环尾 ()
    ret ＝ 指针到字节集 (buf, len × 2 ＋ 2)
    free (buf)
    返回 (ret)

.子程序 格式化文本A_数组, 文本型, 公开, 数组里如果用到字节集参数那这个成员必须指向字节集数据地址, 可以使用 取指针_字节集型() 来获取
    .参数 格式, 文本型
    .参数 参数, 整数型, 参考 可空 数组
    .局部变量 buf, 整数型
    .局部变量 bufSize, 整数型
    .局部变量 format, 整数型
    .局部变量 list, 整数型
    .局部变量 i, 整数型
    .局部变量 len, 整数型
    .局部变量 ret, 文本型

    bufSize ＝ 4096
    buf ＝ malloc (bufSize)
    list ＝ 取数据_通用型_数组 (参数)
    format ＝ 取指针_文本型 (格式)
    len ＝ _vsnprintf_s (buf, bufSize, bufSize － 1, format, list)
    .判断循环首 (len ＝ -1)
        free (buf)
        bufSize ＝ bufSize × 2
        buf ＝ malloc (bufSize)
        len ＝ _vsnprintf_s (buf, bufSize, bufSize － 1, format, list)
    .判断循环尾 ()
    ret ＝ 指针到文本 (buf)
    free (buf)
    返回 (ret)
    

.子程序 格式化文本W_数组, 字节集, 公开, 数组里如果用到字节集参数那这个成员必须指向字节集数据地址, 可以使用 取指针_字节集型() 来获取
    .参数 格式, 字节集
    .参数 参数, 整数型, 参考 可空 数组
    .局部变量 buf, 整数型
    .局部变量 bufSize, 整数型
    .局部变量 format, 整数型
    .局部变量 list, 整数型
    .局部变量 i, 整数型
    .局部变量 len, 整数型
    .局部变量 ret, 字节集

    bufSize ＝ 4096
    buf ＝ malloc (bufSize × 2) ' Unicode单位是字符长度, 这里申请的长度需要按字节来申请
    list ＝ 取数据_通用型_数组 (参数)
    format ＝ 取指针_字节集型 (格式)
    len ＝ _vsnwprintf_s (buf, bufSize, bufSize － 1, format, list)
    .判断循环首 (len ＝ -1)
        free (buf)
        bufSize ＝ bufSize × 2
        buf ＝ malloc (bufSize × 2)
        len ＝ _vsnwprintf_s (buf, bufSize, bufSize － 1, format, list)
    .判断循环尾 ()
    ret ＝ 指针到字节集 (buf, len × 2 ＋ 2)
    free (buf)
    返回 (ret)
    

.子程序 文本_数字字符串格式化, 文本型, 公开, 将数字字符串格式化为为名称指定的区域设置定制的数字字符串。
    .参数 欲格式化的数字字符串, 文本型, , "10462486528" => "10,462,486,528"
    .参数 每组数字中的位数, 整数型, 可空, 默认为3
    .局部变量 iNumber, 整数型
    .局部变量 Format, NUMBERFMTA
    .局部变量 pNumberStr, 整数型
    .局部变量 szNumberStr, 文本型

    .如果 (是否为空 (每组数字中的位数))
        Format.Grouping ＝ 3
    .否则
        Format.Grouping ＝ 每组数字中的位数
    .如果结束
    ' Format.lpThousandSep ＝ “,”
    Format.lpThousandSep ＝ 取空白文本 (4)
    GetLocaleInfo (#LOCALE_USER_DEFAULT, #LOCALE_STHOUSAND, Format.lpThousandSep, 4)
    Format.lpDecimalSep ＝ “”
    iNumber ＝ GetNumberFormatA (#LOCALE_ITIME, 0, 欲格式化的数字字符串, 取数据_通用型 (Format), #NULL, 0)
    .如果真 (iNumber ≠ 0)
        pNumberStr ＝ LocalAlloc (#LMEM_ZEROINIT, iNumber)
        GetNumberFormatA (#LOCALE_ITIME, 0, 欲格式化的数字字符串, 取数据_通用型 (Format), pNumberStr, iNumber)
        szNumberStr ＝ 指针到文本 (pNumberStr)
        LocalFree (pNumberStr)
    .如果真结束
    返回 (szNumberStr)

.子程序 文本_到语音, 逻辑型, 公开, 通过微软语音Api将一段字符串转成语音朗读或保存。
    .参数 要发音的数据, 文本型
    .参数 保存文件名, 文本型, 可空, *.wav

    返回 (文本_到语音W (编码_Ansi到Unicode (要发音的数据, ), 编码_Ansi到Unicode (保存文件名, )))

.子程序 文本_到语音W, 逻辑型, 公开, 通过微软语音Api将一段字符串转成语音朗读或保存。
    .参数 要发音的数据, 字节集
    .参数 保存文件名, 字节集, 可空, *.wav
    .局部变量 pISpVoice, 整数型
    .局部变量 pISpStream, 整数型
    .局部变量 pISpStreamFormat, 整数型
    .局部变量 pguidFormatId, 整数型
    .局部变量 pCoMemWaveFormatEx, 整数型
    .局部变量 isRes, 逻辑型
    .局部变量 hr, 整数型

    .如果真 (_WIN32_WINNT ＜ #_WIN32_WINNT_WIN10)
        输出调试文本 (#ERROR_NOTVERSION)
        返回 (假)
    .如果真结束
    CoInitialize (#NULL)
    hr ＝ CoCreateInstance1 (取指针字节集_ (#CLSID_SpVoice), #NULL, #CLSCTX_ALL, 取指针字节集_ (#IID_ISpVoice), pISpVoice)
    .如果真 (hr ＝ #S_OK 且 pISpVoice ≠ #NULL)
        .如果 (保存文件名 ≠ { } 且 保存文件名 ≠ { 0, 0 })
            hr ＝ CoCreateInstance1 (取指针字节集_ (#CLSID_SpStream), #NULL, #CLSCTX_INPROC_SERVER, 取指针字节集_ (#IID_ISpStream), pISpStream)
            .如果真 (hr ＝ #S_OK 且 pISpStream ≠ #NULL)
                hr ＝ CallObject (pISpVoice, #ISpVoice_GetOutputStream, 取指针整数_ (pISpStreamFormat), , , , , , , , )
                .如果真 (hr ＝ #S_OK 且 pISpStreamFormat ≠ #NULL)
                    pguidFormatId ＝ LocalAlloc (#LMEM_ZEROINIT, 16) ' sizeof(GUID)
                    .如果真 (pguidFormatId ≠ #NULL)
                        hr ＝ CallObject (pISpStreamFormat, #ISpStreamFormat_GetFormat, pguidFormatId, 取指针整数_ (pCoMemWaveFormatEx), , , , , , , )
                        .如果真 (hr ＝ #S_OK 且 pCoMemWaveFormatEx ≠ #NULL)
                            hr ＝ CallObject (pISpStream, #ISpStream_BindToFile, 取指针_字节集型 (保存文件名), #SPFM_CREATE_ALWAYS, pguidFormatId, pCoMemWaveFormatEx, 0, , , , )
                            .如果真 (hr ＝ #S_OK)
                                hr ＝ CallObject (pISpVoice, #ISpVoice_SetOutput, pISpStream, 1, , , , , , , ) ' TRUE
                                .如果真 (hr ＝ #S_OK)
                                    hr ＝ CallObject (pISpVoice, #ISpVoice_Speak, 取指针_字节集型 (要发音的数据), #SPF_DEFAULT, #NULL, , , , , , )
                                    isRes ＝ hr ＝ #S_OK
                                .如果真结束
                                hr ＝ CallObject (pISpVoice, #ISpVoice_SetOutput, #NULL, 1, , , , , , , ) ' TRUE
                            .如果真结束
                            CoTaskMemFree (pCoMemWaveFormatEx)
                        .如果真结束
                        LocalFree (pguidFormatId)
                    .如果真结束
                    SafeRelease (pISpStreamFormat)
                .如果真结束
                SafeRelease (pISpStream)
            .如果真结束
            
        .否则
            hr ＝ CallObject (pISpVoice, #ISpVoice_Speak, 取指针_字节集型 (要发音的数据), #SPF_DEFAULT, #NULL, , , , , , )
            isRes ＝ hr ＝ #S_OK
        .如果结束
        SafeRelease (pISpVoice)
    .如果真结束
    CoUninitialize ()
    返回 (isRes)

.子程序 文本_分割文本排序_冒泡, 文本型, 公开, 将多行用特定字符间隔的文本按某一列排序。失败返回空。冒泡排序算法，少量数据可以用，量大了建议用快速排序 【afu45】
    .参数 要排序的文本, 文本型, , 原文本
    .参数 行分隔符, 文本型, 可空, 按行分割出每条数据，默认#换行符
    .参数 列分隔符, 文本型, 可空, 按列分割出每个字段数据。如果本参数被省略，默认用字符|分割
    .参数 排序的列, 整数型, 可空, 按哪一列排序，从1开始。如果本参数被省略，默认按第1列排序
    .参数 数据类型, 整数型, 可空, 指定按哪种数据类型来排序，1.文本 2.整数 3.小数 4.日期时间(格式参考 到时间 ())。 默认按 1.文本排序
    .参数 排序方向正向, 逻辑型, 可空, 如果参数值为真，排序将从小到大；如果为假，则为从大到小。如果本参数被省略，将默认为真
    .参数 返回数组, 文本型, 可空 数组, 返回排序后的数组
    .局部变量 排序数组, 自定义排序数组, , "0"
    .局部变量 tmp, 自定义排序数组
    .局部变量 文本数组, 文本型, , "0"
    .局部变量 文本数组2, 文本型, , "0"
    .局部变量 i, 整数型
    .局部变量 未比数据数量, 整数型
    .局部变量 最后位置, 整数型
    .局部变量 交换变量, 自定义排序数组
    .局部变量 结果, 文本型

    ' 该历程收录自: https://bbs.125.la/forum.php?mod=viewthread&tid=14759043
    .如果真 (是否为空 (行分隔符))
        行分隔符 ＝ #换行符
    .如果真结束
    .如果真 (是否为空 (列分隔符))
        列分隔符 ＝ “|”
    .如果真结束
    .如果真 (是否为空 (排序的列))
        排序的列 ＝ 1
    .如果真结束
    .如果真 (是否为空 (数据类型))
        数据类型 ＝ 1
    .如果真结束
    .如果真 (是否为空 (排序方向正向))
        排序方向正向 ＝ 真
    .如果真结束
    
    文本数组 ＝ 分割文本 (要排序的文本, 行分隔符, )
    .计次循环首 (取数组成员数 (文本数组), i)
        文本数组2 ＝ 分割文本 (文本数组 [i], 列分隔符, )
        .如果真 (排序的列 ＜ 1 或 排序的列 ＞ 取数组成员数 (文本数组2))
            返回 (“”)
        .如果真结束
        .判断开始 (数据类型 ＝ 2) ' 整数
            tmp.整数 ＝ 到整数 (文本数组2 [排序的列])
        .判断 (数据类型 ＝ 3) ' 小数
            tmp.小数 ＝ 到小数 (文本数组2 [排序的列])
        .判断 (数据类型 ＝ 4) ' 日期时间
            tmp.日期时间 ＝ 到时间 (文本数组2 [排序的列])
        .默认
            tmp.文本 ＝ 文本数组2 [排序的列] ' 其他情况都按文本
            数据类型 ＝ 1 ' 文本
        .判断结束
        tmp.原数据 ＝ 文本数组 [i]
        加入成员 (排序数组, tmp)
    .计次循环尾 ()
    未比数据数量 ＝ 取数组成员数 (排序数组) ' 第一行排序比较所有数
    .判断循环首 (未比数据数量 ＞ 0)
        最后位置 ＝ 0
        .变量循环首 (1, 未比数据数量 － 1, 1, i)
            ' 前一个数大于后一个数，就将两数的位置交换
            .如果真 (选择 (排序方向正向, 数据类型 ＝ 2 且 排序数组 [i].整数 ＞ 排序数组 [i ＋ 1].整数 或 (数据类型 ＝ 3 且 排序数组 [i].小数 ＞ 排序数组 [i ＋ 1].小数) 或 (数据类型 ＝ 4 且 排序数组 [i].日期时间 ＞ 排序数组 [i ＋ 1].日期时间) 或 (数据类型 ＝ 1 且 文本比较 (排序数组 [i].文本, 排序数组 [i ＋ 1].文本, 真) ＞ 0), 数据类型 ＝ 2 且 排序数组 [i].整数 ＜ 排序数组 [i ＋ 1].整数 或 (数据类型 ＝ 3 且 排序数组 [i].小数 ＜ 排序数组 [i ＋ 1].小数) 或 (数据类型 ＝ 4 且 排序数组 [i].日期时间 ＜ 排序数组 [i ＋ 1].日期时间) 或 (数据类型 ＝ 1 且 文本比较 (排序数组 [i].文本, 排序数组 [i ＋ 1].文本, 真) ＜ 0)))
                交换变量 ＝ 排序数组 [i]
                排序数组 [i] ＝ 排序数组 [i ＋ 1]
                排序数组 [i ＋ 1] ＝ 交换变量
                最后位置 ＝ i
            .如果真结束
            
        .变量循环尾 ()
        未比数据数量 ＝ 最后位置
    .判断循环尾 ()
    
    .如果真 (是否为空 (返回数组) ＝ 假)
        重定义数组 (返回数组, 假, 0)
    .如果真结束
    
    .计次循环首 (取数组成员数 (排序数组), i)
        结果 ＝ 结果 ＋ 排序数组 [i].原数据 ＋ 选择 (取数组成员数 (排序数组) ＝ i, “”, 行分隔符)
        .如果真 (是否为空 (返回数组) ＝ 假)
            加入成员 (返回数组, 排序数组 [i].原数据)
        .如果真结束
        
    .计次循环尾 ()
    
    返回 (结果)

.子程序 文本_分割文本排序_快速, 文本型, 公开, 将多行用特定字符间隔的文本按某一列排序。支持文本、整数、小数和日期时间类型。失败返回空。快速排序算法 【afu45】
    .参数 要排序的文本, 文本型, , 原文本
    .参数 行分隔符, 文本型, 可空, 按行分割出每条数据，默认 #换行符
    .参数 列分隔符, 文本型, 可空, 按列分割出每个字段数据。如果本参数被省略，默认用字符|分割
    .参数 排序的列, 整数型, 可空, 按哪一列排序，从1开始。如果本参数被省略，默认按第1列排序
    .参数 数据类型, 整数型, 可空, 指定按哪种数据类型来排序，1.文本 2.整数 3.小数 4.日期时间(格式参考 到时间 ())。 默认按 1.文本排序
    .参数 排序方向正向, 逻辑型, 可空, 如果参数值为真，排序将从小到大；如果为假，则为从大到小。如果本参数被省略，将默认为真
    .参数 返回数组, 文本型, 可空 数组, 返回排序后的数组
    .局部变量 排序数组, 自定义排序数组, , "0"
    .局部变量 文本数组, 文本型, , "0"
    .局部变量 文本数组2, 文本型, , "0"
    .局部变量 i, 整数型
    .局部变量 结果, 文本型
    .局部变量 排序变量, 自定义排序数组, , "0"
    .局部变量 数据成员数量, 整数型
    .局部变量 插入位置, 整数型
    .局部变量 当前数据, 自定义排序数组
    .局部变量 当前分区成员数, 整数型
    .局部变量 当前位置, 整数型
    .局部变量 中间位置, 整数型
    .局部变量 中间数据, 自定义排序数组

    ' 该历程收录自: https://bbs.125.la/forum.php?mod=viewthread&tid=14759043
    .如果真 (要排序的文本 ＝ “”)
        返回 (“”)
    .如果真结束
    .如果真 (是否为空 (行分隔符))
        行分隔符 ＝ #换行符
    .如果真结束
    .如果真 (是否为空 (列分隔符))
        列分隔符 ＝ “|”
    .如果真结束
    .如果真 (是否为空 (排序的列))
        排序的列 ＝ 1
    .如果真结束
    .如果真 (是否为空 (数据类型))
        数据类型 ＝ 1
    .如果真结束
    .如果真 (是否为空 (排序方向正向))
        排序方向正向 ＝ 真
    .如果真结束
    
    文本数组 ＝ 分割文本 (要排序的文本, 行分隔符, )
    .计次循环首 (取数组成员数 (文本数组), i)
        文本数组2 ＝ 分割文本 (文本数组 [i], 列分隔符, )
        .如果真 (排序的列 ＜ 1 或 排序的列 ＞ 取数组成员数 (文本数组2))
            返回 (“”)
        .如果真结束
        .判断开始 (数据类型 ＝ 2) ' 整数
            当前数据.整数 ＝ 到整数 (文本数组2 [排序的列])
        .判断 (数据类型 ＝ 3) ' 小数
            当前数据.小数 ＝ 到小数 (文本数组2 [排序的列])
        .判断 (数据类型 ＝ 4) ' 日期时间
            当前数据.日期时间 ＝ 到时间 (文本数组2 [排序的列])
        .默认
            当前数据.文本 ＝ 文本数组2 [排序的列] ' 其他情况都按文本
            数据类型 ＝ 1
        .判断结束
        当前数据.原数据 ＝ 文本数组 [i]
        加入成员 (排序数组, 当前数据)
    .计次循环尾 ()
    
    数据成员数量 ＝ 取数组成员数 (排序数组)
    .计次循环首 (数据成员数量, i)
        当前位置 ＝ 1
        当前分区成员数 ＝ 取数组成员数 (排序变量)
        当前数据 ＝ 排序数组 [i]
        .判断开始 (i ＝ 1)
            插入成员 (排序变量, 1, 当前数据)
            到循环尾 ()
        .判断 (数据类型 ＝ 1 且 文本比较 (当前数据.文本, 排序变量 [当前分区成员数].文本, 真) ≥ 0 或 (数据类型 ＝ 2 且 当前数据.整数 ≥ 排序变量 [当前分区成员数].整数) 或 (数据类型 ＝ 3 且 当前数据.小数 ≥ 排序变量 [当前分区成员数].小数) 或 (数据类型 ＝ 4 且 当前数据.日期时间 ＞ 排序变量 [当前分区成员数].日期时间))
            插入成员 (排序变量, 当前分区成员数 ＋ 1, 当前数据)
            到循环尾 ()
        .判断 (数据类型 ＝ 1 且 文本比较 (当前数据.文本, 排序变量 [1].文本, 真) ≤ 0 或 (数据类型 ＝ 2 且 当前数据.整数 ≤ 排序变量 [1].整数) 或 (数据类型 ＝ 3 且 当前数据.小数 ≤ 排序变量 [1].小数) 或 (数据类型 ＝ 4 且 当前数据.日期时间 ≤ 排序变量 [1].日期时间))
            插入成员 (排序变量, 1, 当前数据)
            到循环尾 ()
        .默认
            
        .判断结束
        
        .判断循环首 (当前位置 ＜ 当前分区成员数 － 1)
            中间位置 ＝ (当前位置 ＋ 当前分区成员数) ＼ 2
            中间数据 ＝ 排序变量 [中间位置]
            .如果真 (数据类型 ＝ 1 且 当前数据.文本 ＝ 中间数据.文本 或 (数据类型 ＝ 2 且 当前数据.整数 ＝ 中间数据.整数) 或 (数据类型 ＝ 3 且 当前数据.小数 ＝ 中间数据.小数) 或 (数据类型 ＝ 4 且 当前数据.日期时间 ＝ 中间数据.日期时间))
                当前位置 ＝ 中间位置
                跳出循环 ()
            .如果真结束
            .如果 (数据类型 ＝ 1 且 当前数据.文本 ＜ 中间数据.文本 或 (数据类型 ＝ 2 且 当前数据.整数 ＜ 中间数据.整数) 或 (数据类型 ＝ 3 且 当前数据.小数 ＜ 中间数据.小数) 或 (数据类型 ＝ 4 且 当前数据.日期时间 ＜ 中间数据.日期时间))
                当前分区成员数 ＝ 中间位置
            .否则
                当前位置 ＝ 中间位置
            .如果结束
            
        .判断循环尾 ()
        插入位置 ＝ 当前位置 ＋ 1
        插入成员 (排序变量, 插入位置, 当前数据)
    .计次循环尾 ()
    
    .如果真 (是否为空 (返回数组) ＝ 假)
        重定义数组 (返回数组, 假, 0)
    .如果真结束
    
    .如果 (排序方向正向)
        .计次循环首 (取数组成员数 (排序变量), i)
            结果 ＝ 结果 ＋ 排序变量 [i].原数据 ＋ 选择 (取数组成员数 (排序数组) ＝ i, “”, 行分隔符)
            .如果真 (是否为空 (返回数组) ＝ 假)
                加入成员 (返回数组, 排序变量 [i].原数据)
            .如果真结束
            
        .计次循环尾 ()
    .否则
        
        .计次循环首 (取数组成员数 (排序变量), i)
            结果 ＝ 结果 ＋ 排序变量 [数据成员数量 － i ＋ 1].原数据 ＋ 选择 (取数组成员数 (排序数组) ＝ i, “”, 行分隔符)
            .如果真 (是否为空 (返回数组) ＝ 假)
                加入成员 (返回数组, 排序变量 [i].原数据)
            .如果真结束
            
        .计次循环尾 ()
    .如果结束
    
    返回 (结果)

.子程序 文本_取代码, 字节型, 公开, 返回文本中指定位置处字符的代码，命令本身不判断文本长度。
    .参数 欲取字符代码的文本, 文本型
    .参数 欲取其代码的字符位置, 整数型, , 1为首位置，2为第2个位置，如此类推。

    置入代码 ({ 139, 69, 12, 72, 107, 200, 1, 139, 85, 8, 139, 18, 51, 192, 138, 4, 10, 201, 194, 8, 0 })
    ' mov eax, dword ptr [ebp+0Ch]
    ' dec eax
    ' imul ecx, eax, 01h
    ' mov edx, dword ptr [ebp+08h]
    ' mov edx, dword ptr [edx]
    ' xor eax, eax
    ' mov al, byte ptr [edx+ecx]
    ' leave
    ' retn 0008h
    返回 (0)

.子程序 文本_取代码1, 整数型, 公开, 返回文本中指定位置处字符的代码，命令本身不判断文本长度。
    .参数 欲取字符代码的文本, 文本型
    .参数 欲取其代码的字符位置, 整数型, , 1为首位置，2为第2个位置，如此类推。

    置入代码 ({ 139, 69, 12, 72, 107, 200, 1, 139, 85, 8, 139, 18, 51, 192, 102, 139, 4, 17, 201, 194, 8, 0 })
    ' mov eax, dword ptr [ebp+0Ch]
    ' dec eax
    ' imul ecx, eax, 01h
    ' mov edx, dword ptr [ebp+08h]
    ' mov edx, dword ptr [edx]
    ' xor eax, eax
    ' mov ax, word ptr [edx+ecx]
    ' leave
    ' retn 0008h
    返回 (0)

.子程序 文本_取代码W, 整数型, 公开, 返回文本中指定位置处字符的代码，命令本身不判断文本长度。
    .参数 欲取字符代码的文本, 字节集
    .参数 欲取其代码的字符位置, 整数型, , 1为首位置，2为第2个位置，如此类推。

    置入代码 ({ 139, 69, 12, 72, 107, 200, 2, 139, 85, 8, 139, 18, 131, 194, 8, 51, 192, 102, 139, 4, 17, 201, 194, 8, 0 })
    ' mov eax, dword ptr [ebp+0Ch]
    ' dec eax
    ' imul ecx, eax, 02h
    ' mov edx, dword ptr [ebp+08h]
    ' mov edx, dword ptr [edx]
    ' add edx, 08h
    ' xor eax, eax
    ' mov ax, word ptr [ecx+edx]
    ' leave
    ' retn 0008h
    返回 (0)

.版本 2

.程序集 COM
.子程序 COM_bstr_t, 整数型, 公开
    .参数 _bstr_t, 文本型

    返回 (SysAllocString (编码_Ansi到Unicode (_bstr_t)))

.子程序 COM_QueryInterface, 整数型, 公开
    .参数 this_, 整数型
    .参数 refiid_, 整数型
    .参数 pvoid_, 整数型, 参考
    .局部变量 index, 整数型

    index ＝ 0
    置入代码 (#COM调用)
    返回 (0)

.子程序 COM_AddRef, 整数型, 公开
    .参数 this_, 整数型
    .局部变量 index, 整数型

    index ＝ 1
    置入代码 (#COM调用)
    返回 (0)

.子程序 COM_Release, 整数型, 公开
    .参数 this_, 整数型
    .局部变量 index, 整数型

    index ＝ 2
    置入代码 (#COM调用)
    返回 (0)

.子程序 _GetMethodAddr, 整数型
    .参数 Instance, 整数型
    .参数 index, 整数型, , 索引从0开始
    .局部变量 var, 整数型

    var ＝ 取字节集数据 (指针到字节集 (Instance, 4), #整数型, )
    var ＝ var ＋ index × 4
    var ＝ 取字节集数据 (指针到字节集 (var, 4), #整数型, )
    返回 (var)

.子程序 COM_调用COM方法, 整数型, 公开
    .参数 pThis, 整数型
    .参数 Index, 整数型, , 索引从1开始
    .参数 arg1, 整数型, 可空
    .参数 arg2, 整数型, 可空
    .参数 arg3, 整数型, 可空
    .参数 arg4, 整数型, 可空
    .参数 arg5, 整数型, 可空
    .参数 arg6, 整数型, 可空
    .参数 arg7, 整数型, 可空
    .参数 arg8, 整数型, 可空
    .参数 arg9, 整数型, 可空
    .参数 arg10, 整数型, 可空
    .局部变量 参数数组, 整数型, , "0"

    加入成员 (参数数组, pThis)
    .计次循环首 (1, )
        .如果 (是否为空 (arg1))
            跳出循环 ()
        .否则
            加入成员 (参数数组, arg1)
        .如果结束
        .如果 (是否为空 (arg2))
            跳出循环 ()
        .否则
            加入成员 (参数数组, arg2)
        .如果结束
        .如果 (是否为空 (arg3))
            跳出循环 ()
        .否则
            加入成员 (参数数组, arg3)
        .如果结束
        .如果 (是否为空 (arg4))
            跳出循环 ()
        .否则
            加入成员 (参数数组, arg4)
        .如果结束
        .如果 (是否为空 (arg5))
            跳出循环 ()
        .否则
            加入成员 (参数数组, arg5)
        .如果结束
        .如果 (是否为空 (arg6))
            跳出循环 ()
        .否则
            加入成员 (参数数组, arg6)
        .如果结束
        .如果 (是否为空 (arg7))
            跳出循环 ()
        .否则
            加入成员 (参数数组, arg7)
        .如果结束
        .如果 (是否为空 (arg8))
            跳出循环 ()
        .否则
            加入成员 (参数数组, arg8)
        .如果结束
        .如果 (是否为空 (arg9))
            跳出循环 ()
        .否则
            加入成员 (参数数组, arg9)
        .如果结束
        .如果 (是否为空 (arg10))
            跳出循环 ()
        .否则
            加入成员 (参数数组, arg10)
        .如果结束
        
    .计次循环尾 ()
    返回 (CallWindowProcA (取指针_字节集型 (#动态调用代码), _GetMethodAddr (pThis, Index), 取数据_通用型_数组 (参数数组), 取数组成员数 (参数数组), 0))

.子程序 COM_StringToCLSID, GUID, 公开
    .参数 参数_文本, 文本型
    .局部变量 局部_clsid, GUID

    CLSIDFromString_GUID (编码_Ansi到Unicode (参数_文本, ), 局部_clsid)
    返回 (局部_clsid)
    

.子程序 COM_StringtoIID, GUID, 公开, 把COM中的接口名转换成接口标识GUID结构
    .参数 接口类型, 文本型
    .局部变量 iid, GUID
    .局部变量 dwError

    dwError ＝ IIDFromString (编码_Ansi到Unicode (接口类型), iid)
    返回 (iid)

.子程序 取对象指针, 整数型, 公开
    .参数 对象数据, 对象
    .局部变量 pThisF, 整数型

    CopyMemory_objcet2int (pThisF, 对象数据, 4)
    返回 (pThisF)

.子程序 取变体型指针, 整数型, 公开
    .参数 变体型, 变体型

    返回 (lstrcat_int2variant (变体型, 0))

.子程序 COM_连接命名空间, 整数型, 公开, 成功返回一个IWbemServices类指针，失败返回零。
    .参数 名字空间, 文本型, , 如“root\CIMV2”
    .局部变量 CLSID_WbemLocator, GUID
    .局部变量 IID_IWbemLocator, GUID
    .局部变量 hresult, 整数型
    .局部变量 WbemLocator, 整数型
    .局部变量 ppNamespace, 整数型
    .局部变量 strNetworkResource

    CoInitialize (#NULL)
    CoInitializeSecurity (0, -1, 0, 0, 0, 3, 0, 0, 0)
    CLSID_WbemLocator ＝ COM_StringToCLSID (“{4590f811-1d3a-11d0-891f-00aa004b2e24}”)
    IID_IWbemLocator ＝ COM_StringtoIID (“{dc12a687-737f-11cf-884d-00aa004b2e24}”)
    hresult ＝ CoCreateInstance (CLSID_WbemLocator, 0, 1, IID_IWbemLocator, WbemLocator)
    .如果真 (hresult ＝ 0)
        strNetworkResource ＝ COM_bstr_t (名字空间)
        hresult ＝ IWbemLocator_ConnectServer (WbemLocator, strNetworkResource, 0, 0, 0, 0, 0, 0, ppNamespace)
        SysFreeString (strNetworkResource)
        .如果 (hresult ＝ 0)
            hresult ＝ CoSetProxyBlanket (ppNamespace, 10, 0, 0, 3, 3, 0, 0)
            COM_Release (WbemLocator)
            返回 (ppNamespace)
        .否则
            输出调试文本 (“Windows Management Instrumentation 服务已禁用，请启动后重试！”)
        .如果结束
        
    .如果真结束
    CoUninitialize ()
    返回 (0)

.子程序 IWbemLocator_ConnectServer, 整数型
    .参数 this
    .参数 strNetworkResource
    .参数 strUser
    .参数 strPassword
    .参数 strLocale
    .参数 lSecurityFlags
    .参数 strAuthority
    .参数 pCtx
    .参数 ppNamespace, , 参考
    .局部变量 index

    index ＝ 3
    置入代码 ({ 139, 69, 8, 139, 0, 107, 77, 252, 4, 3, 193, 131, 196, 4, 93, 255, 32 })
    返回 (0)

.子程序 IEnumVARIANT_Next, 整数型
    .参数 this
    .参数 celt
    .参数 rgvar
    .参数 pceltFetched, , 参考
    .局部变量 index

    index ＝ 3
    置入代码 ({ 139, 69, 8, 139, 0, 107, 77, 252, 4, 3, 193, 131, 196, 4, 93, 255, 32 })
    返回 (0)

.子程序 IWbemServices_ExecQuery, 整数型
    .参数 This, , , __RPC__in IWbemServices
    .参数 strQueryLanguage, , , /* [in] */ __RPC__in const BSTR
    .参数 strQuery, , , /* [in] */ __RPC__in const BSTR 
    .参数 lFlags, , , /* [in] */ long
    .参数 pCtx, , , /* [in] */ __RPC__in_opt IWbemContext
    .参数 ppEnum, , 参考, /* [out] */ __RPC__deref_out_opt IEnumWbemClassObject
    .局部变量 index

    index ＝ 20
    置入代码 ({ 139, 69, 8, 139, 0, 107, 77, 252, 4, 3, 193, 131, 196, 4, 93, 255, 32 })
    返回 (0)

.子程序 IEnumWbemClassObject_Next, 整数型
    .参数 This, , , __RPC__in IEnumWbemClassObject
    .参数 lTimeout, , , /* [in] */ long
    .参数 uCount, , , /* [in] */ ULONG
    .参数 apObjects, , 参考, /* [length_is][size_is][out] */ __RPC__out_ecount_part(uCount, *puReturned) IWbemClassObject 
    .参数 puReturned, , 参考, /* [out] */ __RPC__out ULONG
    .局部变量 index

    index ＝ 4
    置入代码 ({ 139, 69, 8, 139, 0, 107, 77, 252, 4, 3, 193, 131, 196, 4, 93, 255, 32 })
    返回 (0)

.子程序 IWbemClassObject_Get, 整数型
    .参数 This, , , IWbemClassObject
    .参数 wszName, , , /* [string][in] */ LPCWSTR
    .参数 lFlags, , , /* [in] */ long
    .参数 pVal, , , /* [unique][in][out] */
    .参数 pType, , 参考, /* [unique][in][out] */ CIMTYPE
    .参数 plFlavor, , 参考, /* [unique][in][out] */
    .局部变量 index

    index ＝ 4
    置入代码 ({ 139, 69, 8, 139, 0, 107, 77, 252, 4, 3, 193, 131, 196, 4, 93, 255, 32 })
    返回 (0)

.子程序 查询类属性, 变体型, , ExecQuery
    .参数 wSql语句, 文本型, , 如“Select * From Win32_OperatingSystem”
    .参数 属性名称, 文本型, , 如属性名“BuildNumber”
    .局部变量 pWbemServices, 整数型
    .局部变量 hresult, 整数型
    .局部变量 ppObject, 整数型
    .局部变量 pEnumerator, 整数型
    .局部变量 var, 变体型
    .局部变量 pcFetched, 整数型
    .局部变量 strQueryLanguage, 整数型, , , /* [in] */ __RPC__in const BSTR
    .局部变量 strQuery, 整数型, , , /* [in] */ __RPC__in const BSTR 
    .局部变量 wszName, 整数型

    pWbemServices ＝ COM_连接命名空间 (“root\CIMV2”)
    .如果真 (pWbemServices ＞ 0)
        strQueryLanguage ＝ COM_bstr_t (“WQL”)
        strQuery ＝ COM_bstr_t (wSql语句)
        hresult ＝ IWbemServices_ExecQuery (pWbemServices, strQueryLanguage, strQuery, 位或 (32, 16), 0, pEnumerator)
        .如果真 (hresult ＝ 0)
            .循环判断首 ()
                hresult ＝ IEnumWbemClassObject_Next (pEnumerator, 2000, 1, ppObject, pcFetched)
                .如果真 (hresult ＝ 0)
                    wszName ＝ COM_bstr_t (属性名称)
                    hresult ＝ IWbemClassObject_Get (ppObject, wszName, 0, 取变体型指针 (var), 0, 0)
                    SysFreeString (wszName)
                    COM_Release (ppObject)
                .如果真结束
                
            .循环判断尾 (pcFetched ＝ 1)
            COM_Release (pEnumerator)
        .如果真结束
        COM_Release (pWbemServices)
        SysFreeString (strQueryLanguage)
        SysFreeString (strQuery)
    .如果真结束
    返回 (var)

.版本 2

.程序集 内存共享, , 公开
.程序集变量 集_内存数组, 整数型, , "0"

.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
    

.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
    全部释放 ()

.子程序 申请, 整数型, 公开, 申请指定大小的内存空间,返回内存地址
    .参数 内存大小, 整数型, , 要申请的内存空间大小
    .局部变量 lpdata, 整数型

    lpdata ＝ LocalAlloc (0, 内存大小)
    增加地址 (lpdata)
    返回 (lpdata)

.子程序 写入, 整数型, 公开, 如果指定的内存地址不存在,将自动申请并返回新内存地址,否则将返回原来的内存地址
    .参数 地址, 整数型, 可空, 指定写入地址,如果为空将自动创建
    .参数 数据, 字节集, 参考, 欲写入的字节集数据
    .局部变量 length, 整数型, , , 数据长度

    length ＝ 取字节集长度 (数据)
    .如果真 (length ＝ 0)
        返回 (0)
    .如果真结束
    .如果真 (地址 ＝ 0)
        地址 ＝ 申请 (length)
    .如果真结束
    RtlMoveMemory_字节集 (地址, 数据, length)
    返回 (地址)

.子程序 读取, 字节集, 公开, 读取地址数据！！注意，也可以调用核心库方法 指针到字节集(地址,内存共享.取内存长度(地址)) 来同样取得数据
    .参数 地址, 整数型, , 由内存映射返回的地址
    .参数 读取位置, 整数型, 可空, 从1开始到结束,如果留空则从首地址开始,超出作用范围将指定0
    .参数 长度, 整数型, 可空, 若读取位置+长度超过总数据长度,将自动指定0
    .局部变量 数据, 字节集, , , 指定缓冲区,如果缓冲区长度不够或超出将自动匹配,如果包含数据将自动清空
    .局部变量 length, 整数型
    .局部变量 offset, 整数型, , , 偏移,位置

    length ＝ LocalSize (地址)
    .如果真 (length ＝ 0) ' 无效地址或空数据
        返回 ({ })
    .如果真结束
    长度 ＝ 选择 (长度 ＝ 0, LocalSize (地址) － 读取位置, 长度)
    数据 ＝ 选择 (长度 ≤ 0, 选择 (length ≠ 取字节集长度 (数据), 取空白字节集 (length), { }), 取空白字节集 (长度))
    offset ＝ 选择 (读取位置 ＜ 0 或 读取位置 ＋ 长度 ＞ length, 0, 读取位置)
    RtlMoveMemory_int2Bytes (数据, 地址 ＋ offset, 长度)
    返回 (数据)

.子程序 释放, 逻辑型, 公开, 释放指定的内存
    .参数 内存地址, 整数型, , 由内存映射返回的地址

    删除地址 (内存地址)
    返回 (LocalFree (内存地址) ＝ 0)

.子程序 取内存长度, 整数型, 公开, 取指定内存地址的长度
    .参数 地址, 整数型, , 内存地址

    返回 (LocalSize (地址))

.子程序 全部释放, , 公开, 释放所有申请的内存
    .局部变量 局_计次, 整数型

    .计次循环首 (取数组成员数 (集_内存数组), 局_计次)
        LocalFree (集_内存数组 [局_计次])
    .计次循环尾 ()
    清除数组 (集_内存数组)

.子程序 增加地址
    .参数 地址, 整数型
    .局部变量 局_计次, 整数型
    .局部变量 局_记录, 整数型

    .计次循环首 (取数组成员数 (集_内存数组), 局_计次)
        .如果真 (集_内存数组 [局_计次] ≠ 地址)
            局_记录 ＝ 局_记录 ＋ 1
        .如果真结束
        
    .计次循环尾 ()
    .如果真 (局_记录 ＝ 取数组成员数 (集_内存数组))
        加入成员 (集_内存数组, 地址)
    .如果真结束
    

.子程序 删除地址
    .参数 内存地址, 整数型
    .局部变量 局_计次, 整数型

    .计次循环首 (取数组成员数 (集_内存数组), 局_计次)
        .如果真 (集_内存数组 [局_计次] ＝ 内存地址)
            删除成员 (集_内存数组, 局_计次, 1)
            跳出循环 ()
        .如果真结束
        
    .计次循环尾 ()

.版本 2

.程序集 字节流, , 公开
.程序集变量 内存指针, 整数型
.程序集变量 字节流对象, 整数型

.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
    

.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
    释放字节流 ()

.子程序 创建字节流, 整数型, 公开, 创建一个字节集流,并返回字节流对象指针
    .参数 字节集, 字节集, 可空
    .局部变量 局_指针, 整数型
    .局部变量 局_字节集长度, 整数型

    释放字节流 ()
    .如果 (是否为空 (字节集))
        内存指针 ＝ GlobalAlloc (2, 0) ' GMEM_MOVEABLE=2
        CreateStreamOnHGlobal (内存指针, 真, 字节流对象)
    .否则
        局_字节集长度 ＝ 取字节集长度 (字节集)
        内存指针 ＝ GlobalAlloc (0, 局_字节集长度) ' GMEM_FIXED=0
        局_指针 ＝ GlobalLock (内存指针)
        写到内存 (字节集, 局_指针, 局_字节集长度)
        GlobalUnlock (内存指针)
        CreateStreamOnHGlobal (内存指针, 假, 字节流对象)
    .如果结束
    返回 (字节流对象)

.子程序 释放字节流, , 公开, 释放字节集流,使用后释放掉内存空间
    .如果真 (字节流对象 ≠ 0)
        COM_Release (字节流对象)
        字节流对象 ＝ 0
    .如果真结束
    
    .如果真 (内存指针 ≠ 0)
        GlobalFree (内存指针)
        内存指针 ＝ 0
    .如果真结束
    

.子程序 取字节流指针, 整数型, 公开, 返回字节流对象指针
    返回 (字节流对象)

.子程序 取字节流尺寸, 整数型, 公开, 返回字节流的字节集尺寸
    返回 (GlobalSize (内存指针))

.子程序 取出字节集, 字节集, 公开, 取出字节流中的字节集数据
    .局部变量 局_字节集, 字节集
    .局部变量 局_指针, 整数型
    .局部变量 局_字节流尺寸, 整数型

    局_字节流尺寸 ＝ 取字节流尺寸 ()
    局_指针 ＝ GlobalLock (内存指针)
    局_字节集 ＝ 指针到字节集 (局_指针, 局_字节流尺寸)
    GlobalUnlock (内存指针)
    返回 (局_字节集)

.版本 2

.程序集 汇编类, , 公开, 注：本来源于网络，只是整合到精易模块，方便大家使用
.程序集变量 汇编代码, 字节集

.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
    

.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
    

.子程序 取库程序地址, 整数型, 公开, 取子程序地址，成功返回子程序地址，失败返回0。
    .参数 库文件名, 文本型, , 库文件名称
    .参数 方法名称, 文本型, , 欲调用的方法的名称
    .局部变量 动态库句柄
    .局部变量 取得函数, 整数型

    动态库句柄 ＝ LoadLibraryA (库文件名) ' 动态加载dll
    取得函数 ＝ GetProcAddress (动态库句柄, 方法名称) ' 获取我们规定的接口函数
    .如果真 (取得函数 ＝ 0) ' 为0表示不存在我们规定的接口，返回
        FreeLibrary (动态库句柄) ' 释放加载的文件
        返回 (0)
    .如果真结束
    FreeLibrary (动态库句柄) ' 释放加载的文件
    返回 (取得函数)

.子程序 到子程序指针, 子程序指针, 公开, 将整数型指针转换成易自己的子程序指针类型。
    .参数 整数指针, 整数型

    返回 (lstrcpynA_指针 (整数指针, 整数指针, 0))

.子程序 转为十六进制, 文本型, 公开, 字节集转到十六进制文本。
    .参数 字节集, 字节集, , 用于转换的字节集
    .局部变量 返回值, 文本型
    .局部变量 i, 整数型

    .计次循环首 (取字节集长度 (字节集), i)
        .判断开始 (字节集 [i] ＜ 16)
            返回值 ＝ 返回值 ＋ “ 0” ＋ 取十六进制文本 (字节集 [i])
        .默认
            返回值 ＝ 返回值 ＋ “ ” ＋ 取十六进制文本 (字节集 [i])
        .判断结束
        
    .计次循环尾 ()
    返回 (删首空 (返回值))

.子程序 置入汇编代码, , 公开, 置入汇编代码
    .参数 代码内容, 字节集, 可空
    .参数 追加模式, 逻辑型, 可空, 可为空，默认为追加模式。

    .如果 (是否为空 (追加模式) 或 追加模式)
        汇编代码 ＝ 汇编代码 ＋ 代码内容
    .否则
        汇编代码 ＝ 代码内容
    .如果结束
    

.子程序 取出汇编代码, 字节集, 公开, 取出汇编代码：重要说明：如未执行->运行汇编代码 时，请不进行清空汇编代码
    .参数 是否清空, 逻辑型, 可空, 取出时是否进行清空
    .局部变量 汇编码, 字节集

    .如果真 (是否为空 (是否清空))
        是否清空 ＝ 假
    .如果真结束
    .如果 (是否清空)
        汇编码 ＝ 汇编代码
        汇编代码 ＝ { }
    .否则
        汇编码 ＝ 汇编代码
    .如果结束
    返回 (汇编码)

.子程序 运行汇编代码, 整数型, 公开, 执行->运行汇编代码 时，将清空汇编代码
    .参数 参数个数, 整数型, 可空
    .参数 参数数组, 整数型, 可空 数组
    .局部变量 首地址, 整数型
    .局部变量 指令长度, 整数型
    .局部变量 返回值, 整数型
    .局部变量 代码, 字节集
    .局部变量 bin, 字节集

    代码 ＝ 取出汇编代码 (真)
    指令长度 ＝ 取字节集长度 (代码)
    首地址 ＝ GlobalAlloc (0, 指令长度)
    写到内存 (代码, 首地址, )
    bin ＝ { 85, 139, 236, 86, 139, 117, 16, 141, 78, 255, 133, 201, 124, 21, 139, 69, 12, 141, 4, 136, 65, 139, 16, 137, 85, 16, 255, 117, 16, 131, 232, 4, 73, 117, 242, 255, 85, 8, 137, 69, 12, 139, 69, 20, 133, 192, 116, 13, 141, 4, 181, 0, 0, 0, 0, 137, 69, 16, 3, 101, 16, 139, 69, 12, 94, 93, 194, 16, 0 }
    
    返回值 ＝ CallWindowProcA (取指针_字节集型 (bin), 首地址, 取数据_通用型_数组 (参数数组), 参数个数, 0)
    GlobalFree (首地址)
    返回 (返回值)
    

.子程序 转到十六进制, 文本型, 公开
    返回 (转为十六进制 (取出汇编代码 ()))

.子程序 取指定字节集, 字节集
    .参数 指令参数, 整数型

    返回 (取字节集左边 (到字节集 (指令参数), 1))

.子程序 ADD_EAX_EDX, , 公开
    汇编代码 ＝ 汇编代码 ＋ { 1, 208 }

.子程序 MOV_EAX_PTR, , 公开
    .参数 常数, 整数型

    汇编代码 ＝ 汇编代码 ＋ { 161 } ＋ 到字节集 (常数)

.子程序 PUSH_参常数, , 公开
    .参数 常数, 整数型

    汇编代码 ＝ 汇编代码 ＋ { 104 } ＋ 到字节集 (常数)

.子程序 POP_ECX, , 公开
    汇编代码 ＝ 汇编代码 ＋ { 89 }

.子程序 POP_EBP, , 公开
    汇编代码 ＝ 汇编代码 ＋ { 93 }

.子程序 JMP_EAX, , 公开
    汇编代码 ＝ 汇编代码 ＋ { 255, 224 }

.子程序 CALL_EAX, , 公开
    汇编代码 ＝ 汇编代码 ＋ { 255, 208 }

.子程序 RET_参数, , 公开
    .参数 参数, 整数型

    汇编代码 ＝ 汇编代码 ＋ { 194 } ＋ 到字节集 (到字节 (参数 × 4)) ＋ { 0 }

.子程序 MOV_EDX_EAX, , 公开
    汇编代码 ＝ 汇编代码 ＋ { 139, 208 }

.子程序 MOV_EBP_ESP, , 公开
    汇编代码 ＝ 汇编代码 ＋ { 139, 236 }

.子程序 MOV_EAX_PTR_EBP加字节, , 公开
    .参数 字节, 整数型

    汇编代码 ＝ 汇编代码 ＋ { 139, 69 } ＋ 取字节集左边 (到字节集 (字节), 1)

.子程序 ADD_EAX_常数, , 公开, 加法指令
    .参数 常数, 整数型

    汇编代码 ＝ 汇编代码 ＋ { 5 } ＋ 到字节集 (常数)

.子程序 SUB_EAX_常数, , 公开, 减法指令
    .参数 常数, 整数型

    汇编代码 ＝ 汇编代码 ＋ { 45 } ＋ 到字节集 (常数)

.子程序 IMUL_EAX_常数, , 公开, 乘法指令
    .参数 常数, 整数型

    汇编代码 ＝ 汇编代码 ＋ { 105, 192 } ＋ 到字节集 (常数)

.子程序 IDIV_ECX, , 公开
    汇编代码 ＝ 汇编代码 ＋ { 247, 249 }

.子程序 CMP_PTR_常数, , 公开
    .参数 地址, 整数型
    .参数 常数, 整数型

    汇编代码 ＝ 汇编代码 ＋ { 131, 61 } ＋ 到字节集 (地址) ＋ 取字节集左边 (到字节集 (常数), 1)

.子程序 SHL_EAX_常数, , 公开
    .参数 常数, 整数型

    汇编代码 ＝ 汇编代码 ＋ { 193, 224 } ＋ 取字节集左边 (到字节集 (常数), 1)

.子程序 SHR_EAX_常数, , 公开, 右移
    .参数 常数, 整数型

    汇编代码 ＝ 汇编代码 ＋ { 193, 232 } ＋ 取字节集左边 (到字节集 (常数), 1)

.子程序 PUSHAD, , 公开, 对应指令PUSHAD
    汇编代码 ＝ 汇编代码 ＋ { 96 }

.子程序 PUSH_EAX, , 公开, 对应指令PUSH EAX
    汇编代码 ＝ 汇编代码 ＋ { 80 }

.子程序 POP_EAX, , 公开, 对应指令POP EAX
    汇编代码 ＝ 汇编代码 ＋ { 88 }

.子程序 POPAD, , 公开, 对应指令POPAD
    汇编代码 ＝ 汇编代码 ＋ { 97 }

.子程序 PUSH_EBX, , 公开, 对应指令PUSH_EBX
    汇编代码 ＝ 汇编代码 ＋ { 83 }

.子程序 PUSH_ECX, , 公开, 对应指令PUSH_ECX
    汇编代码 ＝ 汇编代码 ＋ { 81 }

.子程序 PUSH_EDX, , 公开, 对应指令PUSH_EDX
    汇编代码 ＝ 汇编代码 ＋ { 82 }

.子程序 PUSH_ESI, , 公开, 对应指令PUSH_ESI
    汇编代码 ＝ 汇编代码 ＋ { 86 }

.子程序 PUSH_EDI, , 公开, 对应指令PUSH_EDI
    汇编代码 ＝ 汇编代码 ＋ { 87 }

.子程序 PUSH_EBP, , 公开, 对应指令PUSH_EBP
    汇编代码 ＝ 汇编代码 ＋ { 85 }

.子程序 PUSH_ESP, , 公开, 对应指令PUSH_ESP
    汇编代码 ＝ 汇编代码 ＋ { 84 }

.子程序 PUSH_常数, , 公开, 对应指令PUSH_常数
    汇编代码 ＝ 汇编代码 ＋ { 106 }

.子程序 MOV_EAX_常数, , 公开, MOV_EAX_常数
    .参数 参数

    汇编代码 ＝ 汇编代码 ＋ { 184 } ＋ 到字节集 (参数)

.子程序 MOV_EBX_常数, , 公开, MOV_EBX_常数
    .参数 参数

    汇编代码 ＝ 汇编代码 ＋ { 187 } ＋ 到字节集 (参数)

.子程序 MOV_ECX_常数, , 公开, MOV_ECX_常数
    .参数 参数

    汇编代码 ＝ 汇编代码 ＋ { 185 } ＋ 到字节集 (参数)

.子程序 MOV_EDX_常数, , 公开, MOV_EDX_常数
    .参数 参数

    汇编代码 ＝ 汇编代码 ＋ { 186 } ＋ 到字节集 (参数)

.子程序 MOV_ESI_常数, , 公开, MOV_ESI_常数
    .参数 参数

    汇编代码 ＝ 汇编代码 ＋ { 190 } ＋ 到字节集 (参数)

.子程序 MOV_EDI_常数, , 公开, MOV_EDI_常数
    .参数 参数

    汇编代码 ＝ 汇编代码 ＋ { 191 } ＋ 到字节集 (参数)

.子程序 MOV_EBP_常数, , 公开, MOV_EBP_常数
    .参数 参数

    汇编代码 ＝ 汇编代码 ＋ { 189 } ＋ 到字节集 (参数)

.子程序 MOV_ESP_常数, , 公开, MOV_ESP_常数
    .参数 参数

    汇编代码 ＝ 汇编代码 ＋ { 188 } ＋ 到字节集 (参数)

.子程序 MOV_EAX_PRT, , 公开, 对应指令MOV EAX []
    .参数 参数

    汇编代码 ＝ 汇编代码 ＋ { 161 } ＋ 到字节集 (参数)

.子程序 MOV_EBX_PRT, , 公开, 对应指令MOV EBX []
    .参数 参数

    汇编代码 ＝ 汇编代码 ＋ { 137, 29 } ＋ 到字节集 (参数)

.子程序 MOV_ECX_PRT, , 公开, 对应指令MOV ECX []
    .参数 参数

    汇编代码 ＝ 汇编代码 ＋ { 139, 13 } ＋ 到字节集 (参数)

.子程序 MOV_EDX_PRT, , 公开, 对应指令MOV EDX []
    .参数 参数

    汇编代码 ＝ 汇编代码 ＋ { 139, 21 } ＋ 到字节集 (参数)

.子程序 MOV_ESI_PRT, , 公开, 对应指令MOV ESI,[]
    .参数 参数

    汇编代码 ＝ 汇编代码 ＋ { 139, 53 } ＋ 到字节集 (参数)

.子程序 MOV_EDI_PRT, , 公开, 对应指令MOV EDI,[]
    .参数 参数

    汇编代码 ＝ 汇编代码 ＋ { 139, 61 } ＋ 到字节集 (参数)

.子程序 MOV_EBP_PRT, , 公开, 对应指令MOV EBP,[]
    .参数 参数

    汇编代码 ＝ 汇编代码 ＋ { 139, 45 } ＋ 到字节集 (参数)

.子程序 MOV_ESP_PRT, , 公开, 对应指令MOV ESP,[]
    .参数 参数

    汇编代码 ＝ 汇编代码 ＋ { 139, 37 } ＋ 到字节集 (参数)

.子程序 MOV_PRT_EAX, , 公开, 对应指令MOV [],EAX
    .参数 参数

    汇编代码 ＝ 汇编代码 ＋ { 137, 5 } ＋ 到字节集 (参数)

.子程序 MOV_PRT_EBX, , 公开, 对应指令MOV [],EBX
    .参数 参数

    汇编代码 ＝ 汇编代码 ＋ { 137, 29 } ＋ 到字节集 (参数)

.子程序 MOV_PRT_ECX, , 公开, 对应指令MOV [],ECX
    .参数 参数

    汇编代码 ＝ 汇编代码 ＋ { 137, 13 } ＋ 到字节集 (参数)

.子程序 MOV_PRT_EDX, , 公开, 对应指令MOV [],EDX
    .参数 参数

    汇编代码 ＝ 汇编代码 ＋ { 137, 21 } ＋ 到字节集 (参数)

.子程序 MOV_PRT_ESI, , 公开, 对应指令MOV [],ESI
    .参数 参数

    汇编代码 ＝ 汇编代码 ＋ { 137, 53 } ＋ 到字节集 (参数)

.子程序 MOV_PRT_EDI, , 公开, 对应指令MOV [],EDI
    .参数 参数

    汇编代码 ＝ 汇编代码 ＋ { 137, 61 } ＋ 到字节集 (参数)

.子程序 MOV_PRT_EBP, , 公开, 对应指令MOV [],EBP
    .参数 参数

    汇编代码 ＝ 汇编代码 ＋ { 137, 45 } ＋ 到字节集 (参数)

.子程序 MOV_PRT_ESP, , 公开, 对应指令MOV [],ESP
    .参数 参数

    汇编代码 ＝ 汇编代码 ＋ { 137, 37 } ＋ 到字节集 (参数)

.子程序 JMP, , 公开, 对应指令JMP
    .参数 参数

    汇编代码 ＝ 汇编代码 ＋ { 233 } ＋ 到字节集 (参数)

.子程序 CALL_EBX, , 公开, CALL_EBX
    汇编代码 ＝ 汇编代码 ＋ { 255, 211 }

.子程序 CALL_, , , CALL 地址 未成功---------原
    .参数 偏移地址

    汇编代码 ＝ 汇编代码 ＋ { 232, 92, 199, 191, 255 } ＋ 到字节集 (偏移地址)

.子程序 CALL, , 公开, CALL 地址
    .参数 偏移地址

    汇编代码 ＝ 汇编代码 ＋ { 232 } ＋ 到字节集 (偏移地址)

.子程序 RET, , 公开, RET
    汇编代码 ＝ 汇编代码 ＋ { 195 }

.子程序 ADD_EBX_EAX, , 公开
    汇编代码 ＝ 汇编代码 ＋ { 3, 216 }

.子程序 ADD_EBX_PTR, , 公开
    .参数 地址, 整数型

    汇编代码 ＝ 汇编代码 ＋ { 3, 29 } ＋ 到字节集 (地址)

.子程序 ADD_EBX_字节, , 公开
    .参数 字节, 整数型

    汇编代码 ＝ 汇编代码 ＋ { 131, 195 } ＋ 取指定字节集 (字节)

.子程序 ADD_ECX_常数, , 公开
    .参数 常数, 整数型

    汇编代码 ＝ 汇编代码 ＋ { 129, 193 } ＋ 到字节集 (常数)

.子程序 ADD_EDX_字节, , 公开
    .参数 字节, 整数型

    汇编代码 ＝ 汇编代码 ＋ { 131, 194 } ＋ 取指定字节集 (字节)

.子程序 ADD_ESI_常数, , 公开, 加法指令
    .参数 常数, 整数型

    汇编代码 ＝ 汇编代码 ＋ { 129, 198 } ＋ 到字节集 (常数)

.子程序 ADD_ESP_字节, , 公开
    .参数 字节, 整数型

    汇编代码 ＝ 汇编代码 ＋ { 131, 196 } ＋ 取指定字节集 (字节)

.子程序 AND_EAX_整数, , 公开, 位与运算
    .参数 数值, 整数型

    汇编代码 ＝ 汇编代码 ＋ { 37 } ＋ 到字节集 (数值)

.子程序 CALL_PTR, , 公开
    .参数 地址, 整数型

    汇编代码 ＝ 汇编代码 ＋ { 255, 21 } ＋ 到字节集 (地址)

.子程序 CMP_EAX_EDX, , 公开
    汇编代码 ＝ 汇编代码 ＋ { 59, 194 }

.子程序 CMP_EAX_PTR, , 公开
    .参数 地址, 整数型

    汇编代码 ＝ 汇编代码 ＋ { 59, 5 } ＋ 到字节集 (地址)

.子程序 CMP_EAX_常数, , 公开
    .参数 常数, 整数型

    汇编代码 ＝ 汇编代码 ＋ { 61 } ＋ 到字节集 (常数)

.子程序 DEC_EAX, , 公开, 递减1指令
    汇编代码 ＝ 汇编代码 ＋ { 72 }

.子程序 DEC_EBX, , 公开
    汇编代码 ＝ 汇编代码 ＋ { 75 }

.子程序 DEC_ECX, , 公开
    汇编代码 ＝ 汇编代码 ＋ { 73 }

.子程序 DEC_EDX, , 公开
    汇编代码 ＝ 汇编代码 ＋ { 74 }

.子程序 IDIV_EBX, , 公开, 除法指令
    汇编代码 ＝ 汇编代码 ＋ { 247, 251 }

.子程序 IMUL_EAX_EDX, , 公开
    汇编代码 ＝ 汇编代码 ＋ { 15, 175, 194 }

.子程序 IN_AL_DX, , 公开
    汇编代码 ＝ 汇编代码 ＋ { 236 }

.子程序 IN_AL_端口号, , 公开
    .参数 端口号, 整数型

    汇编代码 ＝ 汇编代码 ＋ { 228 } ＋ 取指定字节集 (端口号)

.子程序 IN_AX_DX, , 公开
    汇编代码 ＝ 汇编代码 ＋ { 237 }

.子程序 IN_AX_端口号, , 公开
    .参数 端口号, 整数型

    汇编代码 ＝ 汇编代码 ＋ { 229 } ＋ 取指定字节集 (端口号)

.子程序 INC_EAX, , 公开
    汇编代码 ＝ 汇编代码 ＋ { 64 }

.子程序 INC_ECX, , 公开
    汇编代码 ＝ 汇编代码 ＋ { 65 }

.子程序 INC_EDI, , 公开
    汇编代码 ＝ 汇编代码 ＋ { 71 }

.子程序 INC_ESI, , 公开
    汇编代码 ＝ 汇编代码 ＋ { 70 }

.子程序 INC_PTR, , 公开, 递增1指令
    .参数 地址, 整数型

    汇编代码 ＝ 汇编代码 ＋ { 255, 5 } ＋ 到字节集 (地址)

.子程序 INC_PTR_EAX, , 公开
    汇编代码 ＝ 汇编代码 ＋ { 255, 0 }

.子程序 INC_PTR_EDX, , 公开
    汇编代码 ＝ 汇编代码 ＋ { 255, 2 }

.子程序 JE_整数, 整数型, , 等于则转移指令
    汇编代码 ＝ 汇编代码 ＋ { 15, 132, 0, 0, 0, 0 }
    返回 (0)

.子程序 JE_字节, 整数型, , 等于则转移指令
    汇编代码 ＝ 汇编代码 ＋ { 116, 0 }
    返回 (0)

.子程序 JG_整数, 整数型, , 大于则转移
    汇编代码 ＝ 汇编代码 ＋ { 15, 143, 0, 0, 0, 0 }
    返回 (0)

.子程序 JG_字节, 整数型, , 大于则转移
    汇编代码 ＝ 汇编代码 ＋ { 127, 0 }
    返回 (0)

.子程序 JGE_字节, 整数型, , 大于或等于则转移
    汇编代码 ＝ 汇编代码 ＋ { 125, 0 }
    返回 (0)

.子程序 JL_字节, 整数型, , 小于则转移
    汇编代码 ＝ 汇编代码 ＋ { 124, 0 }
    返回 (0)

.子程序 JLE_字节, 整数型, , 小于或等于则转移
    汇编代码 ＝ 汇编代码 ＋ { 126, 0 }
    返回 (0)

.子程序 JMP_字节, 整数型
    汇编代码 ＝ 汇编代码 ＋ { 235, 0 }
    返回 (0)

.子程序 JNE_字节, 整数型, , 不等于则转移指令
    汇编代码 ＝ 汇编代码 ＋ { 117, 0 }
    返回 (0)

.子程序 LEA_EAX_PTR_EAX加字节, , 公开
    .参数 字节, 整数型

    汇编代码 ＝ 汇编代码 ＋ { 141, 64 } ＋ 取指定字节集 (字节)

.子程序 LEA_ECX_PTR_EAX加整数, , 公开
    .参数 数值, 整数型

    汇编代码 ＝ 汇编代码 ＋ { 141, 136 } ＋ 到字节集 (数值)

.子程序 LEA_ECX_PTR_ESI加字节, , 公开
    .参数 字节, 整数型

    汇编代码 ＝ 汇编代码 ＋ { 141, 78 } ＋ 取指定字节集 (字节)

.子程序 LEA_ECX_PTR_ESP加字节, , 公开
    .参数 字节, 整数型

    汇编代码 ＝ 汇编代码 ＋ { 141, 76, 36 } ＋ 取指定字节集 (字节)

.子程序 LEAVE, , 公开
    汇编代码 ＝ 汇编代码 ＋ { 201 }

.子程序 LOOP, , , 以ECX计次循环指令,ECX不为零时循环,每次循环ECX递减1
    .参数 编号, 整数型

    

.子程序 LOOPNZ, , , 不等于则循环,ECX不为零且标志Z=0时循环
    .参数 编号, 整数型

    

.子程序 LOOPZ, , , 等于则循环,ECX不为零且标志Z=1时循环.
    .参数 编号, 整数型

    汇编代码 ＝ 汇编代码 ＋ { 161 } ＋ 到字节集 (编号)

.子程序 MOV_EAX_EBX, , 公开
    汇编代码 ＝ 汇编代码 ＋ { 139, 195 }

.子程序 MOV_EAX_EDX, , 公开
    汇编代码 ＝ 汇编代码 ＋ { 139, 194 }

.子程序 MOV_EAX_ESI, , 公开
    汇编代码 ＝ 汇编代码 ＋ { 139, 198 }

.子程序 MOV_EAX_PTR_DS整数, , 公开, 等于MOV_EAX_PTR
    .参数 地址, 整数型

    汇编代码 ＝ 汇编代码 ＋ { 161 } ＋ 到字节集 (地址)

.子程序 MOV_EAX_PTR_EAX, , 公开
    汇编代码 ＝ 汇编代码 ＋ { 139, 0 }

.子程序 MOV_EAX_PTR_EAX加整数, , 公开
    .参数 数值, 整数型

    汇编代码 ＝ 汇编代码 ＋ { 139, 128 } ＋ 到字节集 (数值)

.子程序 MOV_EAX_PTR_EAX加字节, , 公开
    .参数 字节, 整数型

    汇编代码 ＝ 汇编代码 ＋ { 139, 64 } ＋ 取指定字节集 (字节)

.子程序 MOV_EAX_PTR_EBX, , 公开
    汇编代码 ＝ 汇编代码 ＋ { 139, 3 }

.子程序 MOV_EAX_PTR_EDX, , 公开
    汇编代码 ＝ 汇编代码 ＋ { 139, 2 }

.子程序 MOV_EAX_PTR_EDX加字节, , 公开
    .参数 字节, 整数型

    汇编代码 ＝ 汇编代码 ＋ { 139, 66 } ＋ 取指定字节集 (字节)

.子程序 MOV_EAX_PTR_ESP加字节, , 公开
    .参数 字节, 整数型

    汇编代码 ＝ 汇编代码 ＋ { 139, 68 } ＋ 取指定字节集 (字节)

.子程序 MOV_EBX_EAX, , 公开
    汇编代码 ＝ 汇编代码 ＋ { 139, 216 }

.子程序 MOV_EBX_EDX, , 公开
    汇编代码 ＝ 汇编代码 ＋ { 139, 218 }

.子程序 MOV_EBX_PTR_EAX加字节, , 公开
    .参数 字节, 整数型

    汇编代码 ＝ 汇编代码 ＋ { 139, 88 } ＋ 取指定字节集 (字节)

.子程序 MOV_ECX_EAX, , 公开
    汇编代码 ＝ 汇编代码 ＋ { 139, 200 }

.子程序 MOV_ECX_EDI, , 公开
    汇编代码 ＝ 汇编代码 ＋ { 139, 207 }

.子程序 MOV_ECX_ESI, , 公开
    汇编代码 ＝ 汇编代码 ＋ { 139, 206 }

.子程序 MOV_ECX_PTR, , 公开
    .参数 地址, 整数型

    汇编代码 ＝ 汇编代码 ＋ { 139, 13 } ＋ 到字节集 (地址)

.子程序 MOV_ECX_PTR_EAX加字节, , 公开
    .参数 字节, 整数型

    汇编代码 ＝ 汇编代码 ＋ { 139, 72 } ＋ 取指定字节集 (字节)

.子程序 MOV_ECX_PTR_EBX加整数, , 公开
    .参数 数值, 整数型

    汇编代码 ＝ 汇编代码 ＋ { 139, 139 } ＋ 到字节集 (数值)

.子程序 MOV_ECX_PTR_ECX加字节, , 公开
    .参数 字节, 整数型

    汇编代码 ＝ 汇编代码 ＋ { 139, 73 } ＋ 取指定字节集 (字节)

.子程序 MOV_ECX_PTR_EDX加字节, , 公开
    .参数 字节, 整数型

    汇编代码 ＝ 汇编代码 ＋ { 139, 74 } ＋ 取指定字节集 (字节)

.子程序 MOV_EDI_EAX, , 公开
    汇编代码 ＝ 汇编代码 ＋ { 139, 248 }

.子程序 MOV_EDX_PTR_ECX加字节, , 公开
    .参数 字节, 整数型

    汇编代码 ＝ 汇编代码 ＋ { 139, 81 } ＋ 取指定字节集 (字节)

.子程序 MOV_EDX_PTR_EDI加整数, , 公开
    .参数 数值, 整数型

    汇编代码 ＝ 汇编代码 ＋ { 139, 151 } ＋ 到字节集 (数值)

.子程序 MOV_EDX_PTR_EDI加字节, , 公开
    .参数 字节, 整数型

    汇编代码 ＝ 汇编代码 ＋ { 139, 87 } ＋ 取指定字节集 (字节)

.子程序 MOV_ESI_EAX, , 公开
    汇编代码 ＝ 汇编代码 ＋ { 139, 240 }

.子程序 MOV_ESI_EBX, , 公开
    汇编代码 ＝ 汇编代码 ＋ { 139, 243 }

.子程序 MOV_ESI_PTR, , 公开
    .参数 地址, 整数型

    汇编代码 ＝ 汇编代码 ＋ { 139, 53 } ＋ 到字节集 (地址)

.子程序 MOV_ESI_PTR_EBP加字节, , 公开
    .参数 字节, 整数型

    汇编代码 ＝ 汇编代码 ＋ { 139, 117 } ＋ 取指定字节集 (字节)

.子程序 MOV_ESP_EBP, , 公开
    汇编代码 ＝ 汇编代码 ＋ { 139, 229 }

.子程序 MOV_PTR_EAX, , 公开
    .参数 地址, 整数型

    汇编代码 ＝ 汇编代码 ＋ { 163 } ＋ 到字节集 (地址)

.子程序 MOV_PTR_EBX_EAX, , 公开
    汇编代码 ＝ 汇编代码 ＋ { 137, 3 }

.子程序 MOV_PTR_ECX加字节_EAX, , 公开
    .参数 字节, 整数型

    汇编代码 ＝ 汇编代码 ＋ { 231 } ＋ 取指定字节集 (字节)

.子程序 MOV_PTR_EDX_EAX, , 公开
    汇编代码 ＝ 汇编代码 ＋ { 137, 2 }

.子程序 MOV_PTR_常数, , 公开
    .参数 地址, 整数型
    .参数 常数, 整数型

    汇编代码 ＝ 汇编代码 ＋ { 199, 5 } ＋ 到字节集 (地址) ＋ 到字节集 (常数)

.子程序 NOP, , 公开, 空指令
    汇编代码 ＝ 汇编代码 ＋ { 144 }

.子程序 NOT_EAX, , 公开, 取反指令
    汇编代码 ＝ 汇编代码 ＋ { 247, 208 }

.子程序 OUT_DX_AL, , 公开
    汇编代码 ＝ 汇编代码 ＋ { 238 }

.子程序 OUT_端口号_AX, , 公开
    .参数 端口号, 整数型

    汇编代码 ＝ 汇编代码 ＋ { 231 } ＋ 取指定字节集 (端口号)

.子程序 POP_EBX, , 公开
    汇编代码 ＝ 汇编代码 ＋ { 91 }

.子程序 POP_EDX, , 公开
    汇编代码 ＝ 汇编代码 ＋ { 90 }

.子程序 POP_ESI, , 公开
    汇编代码 ＝ 汇编代码 ＋ { 94 }

.子程序 PUSH_PTR, , 公开
    .参数 地址, 整数型

    汇编代码 ＝ 汇编代码 ＋ { 43, 5 } ＋ 到字节集 (地址)

.子程序 SHL_EBX_常数, , 公开
    .参数 常数, 整数型

    汇编代码 ＝ 汇编代码 ＋ { 193, 227 } ＋ 取指定字节集 (常数)

.子程序 SHR_EBX_常数, , 公开
    .参数 常数, 整数型

    汇编代码 ＝ 汇编代码 ＋ { 193, 235 } ＋ 取指定字节集 (常数)

.子程序 SUB_EAX_PTR, , 公开
    .参数 地址, 整数型

    汇编代码 ＝ 汇编代码 ＋ { 43, 5 } ＋ 到字节集 (地址)

.子程序 SUB_EBX_EAX, , 公开
    汇编代码 ＝ 汇编代码 ＋ { 43, 216 }

.子程序 SUB_EDX_字节, , 公开
    .参数 字节, 整数型

    汇编代码 ＝ 汇编代码 ＋ { 131, 234 } ＋ 取指定字节集 (字节)

.子程序 TEST_EAX_EAX, , 公开
    汇编代码 ＝ 汇编代码 ＋ { 133, 192 }

.子程序 TEST_EAX_常数, , 公开
    .参数 常数, 整数型

    汇编代码 ＝ 汇编代码 ＋ { 169 } ＋ 到字节集 (常数)

.子程序 XOR_EAX_EBX, , 公开, 异或运算
    汇编代码 ＝ 汇编代码 ＋ { 51, 195 }

.子程序 XOR_EDI_EDI, , 公开
    汇编代码 ＝ 汇编代码 ＋ { 51, 255 }

.版本 2

.程序集 类_APIHOOK, , 公开
.程序集变量 集_HOOK, 数据_APIHOOK类, , "0"

.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
    清除数组 (集_HOOK)

.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
    卸载全部 ()

.子程序 安装, 逻辑型, 公开
    .参数 动态链接库名, 文本型, , 要拦截的【函数名】所在【动态链接库】的路径，如：user32.dll
    .参数 API命令名, 文本型, , 要拦截的函数名，如：FindWindowA
    .参数 现子程序指针, 子程序指针, , 回调子程序
    .局部变量 局_模块句柄, 整数型
    .局部变量 局_计次, 整数型
    .局部变量 局_成员数, 整数型
    .局部变量 局_HOOK, 数据_APIHOOK类

    动态链接库名 ＝ 选择 (取文本右边 (到小写 (动态链接库名), 3) ≠ “dll”, 动态链接库名 ＋ “.dll”, 动态链接库名)
    局_成员数 ＝ 取数组成员数 (集_HOOK)
    .计次循环首 (局_成员数, 局_计次) ' 判断是否已经HOOKAPI过了
        .如果真 (到小写 (集_HOOK [局_计次].API命令名) ＝ 到小写 (动态链接库名 ＋ API命令名))
            继续 (动态链接库名, API命令名)
            返回 (真)
        .如果真结束
        
    .计次循环尾 ()
    ' ========================================
    局_模块句柄 ＝ GetModuleHandleA (动态链接库名) ' 取模块句柄
    .如果真 (局_模块句柄 ＝ 0)
        局_模块句柄 ＝ LoadLibraryA (动态链接库名) ' 装载DLL
    .如果真结束
    .如果真 (局_模块句柄 ＝ 0)
        返回 (假)
    .如果真结束
    
    局_HOOK.命令标识 ＝ 到小写 (动态链接库名 ＋ API命令名)
    局_HOOK.原函数地址 ＝ GetProcAddress (局_模块句柄, API命令名)
    
    局_HOOK.原字节 ＝ 指针到字节集 (局_HOOK.原函数地址, 8)
    局_HOOK.新函数地址 ＝ 到字节集 (到整数 (现子程序指针))
    .如果 (修改虚拟保护 (真, 局_HOOK))
        局_HOOK.继续暂停 ＝ “继续”
        加入成员 (集_HOOK, 局_HOOK)
        返回 (真)
    .否则
        返回 (假)
    .如果结束
    返回 (真)

.子程序 修改虚拟保护, 逻辑型, , 成功返回真，失败返回假
    .参数 参_是否HOOK, 逻辑型, , 否则还原
    .参数 参_HOOK, 数据_APIHOOK类, 参考
    .局部变量 局_原地址, 字节集
    .局部变量 虚拟信息, 精易_内存属性
    .局部变量 结果, 逻辑型
    .局部变量 局_保护值, 整数型

    .如果真 (参_HOOK.原函数地址 ＝ 0)
        返回 (假)
    .如果真结束
    .如果 (参_是否HOOK)
        局_保护值 ＝ VirtualQueryEx (-1, 参_HOOK.原函数地址, 虚拟信息, 28) ' 取内存保护值属性
        .如果真 (局_保护值 ＝ 0)
            返回 (假)
        .如果真结束
        .如果真 (VirtualProtectEx (-1, 虚拟信息.区域地址, 8, 64, 虚拟信息.当前属性) ＝ 0) ' 修改内存属性'
            返回 (假)
        .如果真结束
        参_HOOK.原保护值 ＝ 虚拟信息.当前属性
        参_HOOK.区域地址 ＝ 虚拟信息.区域地址
        局_原地址 ＝ { 184 } ＋ 参_HOOK.新函数地址 ＋ { 255, 224 }
        结果 ＝ WriteProcessMemory_字节集 (-1, 参_HOOK.原函数地址, 局_原地址, 取字节集长度 (局_原地址), 0)
    .否则
        结果 ＝ WriteProcessMemory_字节集 (-1, 参_HOOK.原函数地址, 参_HOOK.原字节, 取字节集长度 (参_HOOK.原字节), 0)
    .如果结束
    返回 (结果)

.子程序 继续, 逻辑型, 公开, 继续拦截指定的函数名，成功返回真，失败返回假。
    .参数 动态链接库, 文本型, , 要拦截的【函数名】所在【动态链接库】的路径，如：user32.dll
    .参数 函数名, 文本型, , 要继续HOOK的函数名 如：FindWindowA
    .局部变量 局_计次, 整数型

    动态链接库 ＝ 选择 (取文本右边 (到小写 (动态链接库), 3) ≠ “dll”, 动态链接库 ＋ “.dll”, 动态链接库)
    .计次循环首 (取数组成员数 (集_HOOK), 局_计次) ' 判断是否已经HOOKAPI过了
        .如果真 (到小写 (集_HOOK [局_计次].命令标识) ＝ 到小写 (动态链接库 ＋ 函数名))
            .如果真 (集_HOOK [局_计次].继续暂停 ＝ “继续”)
                返回 (真)
            .如果真结束
            修改虚拟保护 (真, 集_HOOK [局_计次])
            集_HOOK [局_计次].继续暂停 ＝ “继续”
            返回 (真)
            跳出循环 ()
        .如果真结束
        
    .计次循环尾 ()
    返回 (假)

.子程序 是否已安装, 逻辑型, 公开, 判断此HOOK函数是否已安装，真=已安装，假=未安装。
    .参数 动态链接库, 文本型, , 要拦截的【函数名】所在【动态链接库】的路径，如：user32.dll
    .参数 函数名, 文本型, , 要暂停HOOK的函数名 如：FindWindowA
    .局部变量 局_计次, 整数型

    动态链接库 ＝ 选择 (取文本右边 (到小写 (动态链接库), 3) ≠ “dll”, 动态链接库 ＋ “.dll”, 动态链接库)
    .计次循环首 (取数组成员数 (集_HOOK), 局_计次) ' 判断是否已经HOOKAPI过了3
        .如果真 (到小写 (集_HOOK [局_计次].命令标识) ＝ 到小写 (动态链接库 ＋ 函数名))
            返回 (真)
        .如果真结束
        
    .计次循环尾 ()
    返回 (假)

.子程序 暂停, 逻辑型, 公开, 暂停拦截指定的函数名，成功返回真，失败返回假。
    .参数 动态链接库, 文本型, , 要拦截的【函数名】所在【动态链接库】的路径，如：user32.dll
    .参数 函数名, 文本型, , 要暂停HOOK的函数名 如：FindWindowA
    .局部变量 局_计次, 整数型

    动态链接库 ＝ 选择 (取文本右边 (到小写 (动态链接库), 3) ≠ “dll”, 动态链接库 ＋ “.dll”, 动态链接库)
    .计次循环首 (取数组成员数 (集_HOOK), 局_计次) ' 判断是否已经HOOKAPI过了
        .如果真 (到小写 (集_HOOK [局_计次].命令标识) ＝ 到小写 (动态链接库 ＋ 函数名))
            .如果真 (集_HOOK [局_计次].继续暂停 ＝ “暂停”)
                返回 (真)
            .如果真结束
            修改虚拟保护 (假, 集_HOOK [局_计次])
            集_HOOK [局_计次].继续暂停 ＝ “暂停”
            返回 (真)
            跳出循环 ()
        .如果真结束
        
    .计次循环尾 ()
    返回 (假)

.子程序 取地址, 整数型, 公开, 取指定函数名原始数据地址，回调原指针时使用。成功返回地址，失败返回-1。
    .参数 动态链接库, 文本型, , 要拦截的【函数名】所在【动态链接库】的路径，如：user32.dll
    .参数 函数名, 文本型, , 要取出地址的函数名 如：FindWindowA
    .局部变量 局_成员数, 整数型
    .局部变量 局_计次, 整数型

    动态链接库 ＝ 选择 (取文本右边 (到小写 (动态链接库), 3) ≠ “dll”, 动态链接库 ＋ “.dll”, 动态链接库)
    局_成员数 ＝ 取数组成员数 (集_HOOK)
    .计次循环首 (局_成员数, 局_计次) ' 判断是否已经HOOKAPI过了
        .如果真 (到小写 (集_HOOK [局_计次].命令标识) ＝ 到小写 (动态链接库 ＋ 函数名))
            返回 (集_HOOK [局_计次].区域地址)
            跳出循环 ()
        .如果真结束
        
    .计次循环尾 ()
    返回 (-1)

.子程序 卸载, 逻辑型, 公开, 卸载指定的函数名的APIHOOK，成功返回真，失败返回假。
    .参数 动态链接库, 文本型, , 要拦截的【函数名】所在【动态链接库】的路径，如：user32.dll
    .参数 函数名, 文本型, , 要卸载HOOK的函数名 如：FindWindowA
    .局部变量 局_计次, 整数型

    动态链接库 ＝ 选择 (取文本右边 (到小写 (动态链接库), 3) ≠ “dll”, 动态链接库 ＋ “.dll”, 动态链接库)
    .计次循环首 (取数组成员数 (集_HOOK), 局_计次) ' 判断是否已经HOOKAPI过了
        .如果真 (到小写 (集_HOOK [局_计次].命令标识) ＝ 到小写 (动态链接库 ＋ 函数名))
            WriteProcessMemory_字节集 (-1, 集_HOOK [局_计次].原函数地址, 集_HOOK [局_计次].原字节, 取字节集长度 (集_HOOK [局_计次].原字节), 0)
            VirtualProtectEx (-1, 集_HOOK [局_计次].区域地址, 8, 32, 集_HOOK [局_计次].原保护值) ' 改回只读模式
            删除成员 (集_HOOK, 局_计次, 1)
            返回 (真)
            跳出循环 ()
        .如果真结束
        
    .计次循环尾 ()
    返回 (假)

.子程序 卸载全部, , 公开, 卸载全部的HOOK，程序关闭时，本命令会被自动调用
    .局部变量 局_计次, 整数型

    ' .计次循环首 (取数组成员数 (集_HOOK), 局_计次) ' 判断是否已经HOOKAPI过了
        ' WriteProcessMemory_字节集 (-1, 集_HOOK [局_计次].原函数地址, 集_HOOK [局_计次].原字节, 取字节集长度 (集_HOOK [局_计次].原字节), 0)
        ' VirtualProtectEx (-1, 集_HOOK [局_计次].区域地址, 8, 32, 集_HOOK [局_计次].原保护值)  ' 改回只读模式
        ' 删除成员 (集_HOOK, 局_计次, 1)
    ' .计次循环尾 ()
    .变量循环首 (取数组成员数 (集_HOOK), 1, -1, 局_计次)
        WriteProcessMemory_字节集 (-1, 集_HOOK [局_计次].原函数地址, 集_HOOK [局_计次].原字节, 取字节集长度 (集_HOOK [局_计次].原字节), 0)
        VirtualProtectEx (-1, 集_HOOK [局_计次].区域地址, 8, 32, 集_HOOK [局_计次].原保护值) ' 改回只读模式
        删除成员 (集_HOOK, 局_计次, 1)
    .变量循环尾 ()

.版本 2

.程序集 类_HOOK_EX, , 公开
.程序集变量 集_回调地址, 整数型
.程序集变量 集_回调指针, 整数型
.程序集变量 集_回调指针ex, 整数型
.程序集变量 集_原代码, 字节集
.程序集变量 集_原长度, 整数型

.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
    ' 本类收录自：https://bbs.125.la/forum.php?mod=viewthread&tid=14327228

.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
    卸载 ()

.子程序 安装, 逻辑型, 公开, 将某个地址指向某个新地址，俗称hook。如果hook api 新地址参数必须全部为指针型(即整数型)，否则会有不可预知的错误。    如hook指令(即任意位置，非函数。此情况注意新地址取真实地址，否则状态可能被更改，和堆栈平衡。)，请勿使用静态回调功能。    开启回调：调用方法 回调() 或 回调ex() 即可全静态回调原函数，无需频繁安装与卸载，减少资源浪费CPU消耗。
    .参数 参_源地址, 整数型
    .参数 参_新地址, 整数型
    .参数 参_关闭回调, 逻辑型, 可空, 默认为假，开启静态回调 【非hook函数头部请勿开启。。用于不需要频繁安装与卸载的情况下，如果需要频繁安装与卸载，请关闭。】如果开启可使用方法 回调() 或者 回调ex()  直接回调
    .局部变量 局_回调代码, 字节集
    .局部变量 局_原代码, 字节集
    .局部变量 局_函数代码, 字节集
    .局部变量 局_理想长度, 整数型
    .局部变量 局_新代码, 字节集
    .局部变量 局_回调头部, 字节集
    .局部变量 局_参数个数, 整数型
    .局部变量 局_回调参数入栈, 字节集
    .局部变量 局_回调参数修改, 字节集
    .局部变量 i, 整数型
    .局部变量 局_回调开栈, 字节集
    .局部变量 局_回调保存, 字节集
    .局部变量 局_回调计数, 字节集
    .局部变量 局_回调源地址, 字节集
    .局部变量 局_回调写入加恢复, 字节集
    .局部变量 局_返回地址入栈, 字节集
    .局部变量 局_函数清栈加返回, 字节集

    .如果真 (集_回调地址 ＞ 0)
        返回 (假)
    .如果真结束
    局_新代码 ＝ { 104 } ＋ 到字节集 (参_新地址) ＋ { 195 }
    局_函数代码 ＝ 指针到字节集 (参_源地址, 12)
    .如果真 (参_关闭回调) ' 未开启回调直接修改。
        集_原长度 ＝ 6
        集_回调地址 ＝ 参_源地址 ＋ 6
        集_原代码 ＝ 取字节集左边 (局_函数代码, 6)
        返回 (内存_修改内存 (参_源地址, 局_新代码, 6))
    .如果真结束
    局_理想长度 ＝ 内存_取指令对其长度 (6, 局_函数代码)
    .如果真 (局_理想长度 ＜ 6)
        返回 (假)
    .如果真结束
    局_原代码 ＝ 取字节集左边 (局_函数代码, 局_理想长度)
    局_原代码 ＝ 内存_跳转偏移处理 (局_原代码, 参_源地址)
    集_原长度 ＝ 局_理想长度
    集_回调地址 ＝ 参_源地址 ＋ 局_理想长度
    集_原代码 ＝ 局_原代码
    局_回调代码 ＝ { 97, 201, 201 } ＋ 局_原代码 ＋ { 104 } ＋ 到字节集 (集_回调地址) ＋ { 195 }
    集_回调指针 ＝ 内存_拷贝字节集 (局_回调代码)
    集_回调指针ex ＝ 内存_拷贝字节集 (取空白字节集 (1024))
    局_参数个数 ＝ 程序_取参数个数 (参_新地址)
    .判断开始 (局_参数个数 ＞ 0)
        局_回调头部 ＝ { 97, 201 }
        局_回调开栈 ＝ { 129, 236 } ＋ 到字节集 (到整数 (局_参数个数 × 4)) ' { 129, 196, 16, 0, 0, 0 }
        局_回调保存 ＝ { 81, 87, 86 }
        局_回调计数 ＝ { 199, 193 } ＋ 到字节集 (局_参数个数) ' {199,193,4,0,0,0}
        局_回调源地址 ＝ { 141, 188, 36, 12, 0, 0, 0 } ' { 141, 188, 36, 12, 0, 0, 0 }
        局_回调写入加恢复 ＝ { 141, 181, 8, 0, 0, 0, 243, 165, 94, 95, 89 }
        局_返回地址入栈 ＝ { 104 } ＋ 到字节集 (到整数 (集_回调指针ex ＋ 512))
        局_回调代码 ＝ 局_回调头部 ＋ 局_回调开栈 ＋ 局_回调保存 ＋ 局_回调计数 ＋ 局_回调源地址 ＋ 局_回调写入加恢复 ＋ 局_返回地址入栈 ＋ 局_原代码 ＋ { 104 } ＋ 到字节集 (集_回调地址) ＋ { 195 }
        内存_写到内存 (集_回调指针ex, 取指针_字节集型 (局_回调代码), 取字节集长度 (局_回调代码))
        ' 恢复代码
        局_回调源地址 ＝ { 141, 180, 36, 12, 0, 0, 0 }
        局_回调写入加恢复 ＝ { 141, 189, 8, 0, 0, 0, 243, 165, 94, 95, 89 }
        局_函数清栈加返回 ＝ { 129, 196 } ＋ 到字节集 (到整数 (局_参数个数 × 4)) ＋ { 194, 4, 0 }
        局_回调代码 ＝ 局_回调开栈 ＋ 局_回调保存 ＋ 局_回调计数 ＋ 局_回调源地址 ＋ 局_回调写入加恢复 ＋ 局_函数清栈加返回
        内存_写到内存 (集_回调指针ex ＋ 512, 取指针_字节集型 (局_回调代码), 取字节集长度 (局_回调代码))
    .默认
        局_回调头部 ＝ { 97, 201 }
        局_返回地址入栈 ＝ { 104 } ＋ 到字节集 (到整数 (集_回调指针ex ＋ 512))
        局_回调代码 ＝ 局_回调头部 ＋ 局_返回地址入栈 ＋ 局_原代码 ＋ { 104 } ＋ 到字节集 (集_回调地址) ＋ { 195 }
        内存_写到内存 (集_回调指针ex, 取指针_字节集型 (局_回调代码), 取字节集长度 (局_回调代码))
        ' 返回代码
        局_回调代码 ＝ { 194, 4, 0 }
        内存_写到内存 (集_回调指针ex ＋ 512, 取指针_字节集型 (局_回调代码), 取字节集长度 (局_回调代码))
    .判断结束
    返回 (内存_修改内存 (参_源地址, 局_新代码, 6))
    
    ' 调用前：
    ' sub esp,10
    ' push ecx
    ' push edi
    ' push esi
    ' mov ecx,4
    ' lea edi,[esp+0xc]
    ' lea esi,[ebp+8]
    ' rep movsd
    ' pop esi
    ' pop edi
    ' pop ecx
    ' push 0
    ' 调用后:
    ' sub esp,10
    ' push ecx
    ' push edi
    ' push esi
    ' mov ecx,4
    ' lea esi,[esp+0xc]
    ' lea edi,[ebp+8]
    ' rep movsd
    ' pop esi
    ' pop edi
    ' pop ecx
    ' add esp,10
    ' retn
    
    

.子程序 卸载, , 公开, 对象被销毁前自动调用,无特殊情况无需使用。
    .如果真 (集_回调地址 ＞ 0)
        内存_修改内存 (集_回调地址 － 集_原长度, 集_原代码, 6)
        集_回调地址 ＝ 0
        集_回调指针 ＝ 0
        集_原代码 ＝ { }
        集_原长度 ＝ 0
    .如果真结束
    

.子程序 回调, , 公开, 【静态回掉，需在安装时开启了回调功能。仅适用于函数hook】使用该方法后 将忽略该调用该方法处往后的一切代码 包括返回值。  如果对返回值和参数有要求可使用 回调ex()
    置入代码 ({ 96 })
    到整数 (集_回调指针)
    置入代码 ({ 80, 195 })

.子程序 回调ex, 整数型, 公开, 【静态回调，需在安装时开启了回调功能。仅适用于函数hook】使用该方法后，返回值为原函数返回值，如原函数返回的非整数型，那么此返回值可能是一个指针。如原函数会改动参数，那么改动后的参数便是函数内的参数，直接读取即可。 如果对返回值和参数无要求可使用 回调()
    置入代码 ({ 96 })
    到整数 (集_回调指针ex)
    置入代码 ({ 80, 195 })
    返回 (0)
    

.子程序 取原代码, 字节集, 公开, 返回原始代码。
    返回 (集_原代码)
    

.版本 2

.程序集 类_HOOK_Send, , 公开
.程序集变量 集_函数地址, 整数型
.程序集变量 集_原保护值, 整数型
.程序集变量 集_原字节, 字节集
.程序集变量 集_原地址, 整数型
.程序集变量 集_操作句柄, 整数型
.程序集变量 集_已经提升, 逻辑型
.程序集变量 集_新字节, 字节集

.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
    

.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
    

.子程序 安装, 逻辑型, , 安装APIHOOK
    .参数 参_动态链接库路径, 文本型, , 欲截获的函数名所在动态链接库的路径
    .参数 参_函数名, 文本型, , 欲截获的函数名
    .参数 参_新函数地址, 整数型, , 回调子程序指针地址.可以用 到整数(子程序指针) 获得
    .局部变量 局_模块句柄, 整数型

    .如果真 (集_函数地址 ≠ 0)
        返回 (真)
    .如果真结束
    局_模块句柄 ＝ GetModuleHandleA (参_动态链接库路径)
    .如果真 (局_模块句柄 ＝ 0)
        局_模块句柄 ＝ LoadLibraryA (参_动态链接库路径)
    .如果真结束
    .如果真 (局_模块句柄 ＝ 0)
        返回 (假)
    .如果真结束
    集_函数地址 ＝ GetProcAddress (局_模块句柄, 参_函数名) ' 获取API函数地址
    .如果真 (集_函数地址 ＝ 0)
        返回 (假)
    .如果真结束
    .如果真 (VirtualProtect (集_函数地址, 5, #PAGE_EXECUTE_READWRITE, 集_原保护值) ＝ 假)
        返回 (假)
    .如果真结束
    集_原字节 ＝ 指针到字节集 (集_函数地址, 5) ' 保存API入口前5个字节
    集_新字节 ＝ { 233 } ＋ 到字节集 (到整数 (参_新函数地址 － (集_函数地址 ＋ 5)))
    写到内存 (集_新字节, 集_函数地址, 5) ' 修改API入口前5字节
    集_原字节 ＝ 集_原字节 ＋ { 233, 0, 0, 0, 0 }
    集_原地址 ＝ lstrcpynA_Bin (集_原字节, 集_原字节, 0)
    写到内存 (到整数 (集_函数地址 ＋ 5 － (集_原地址 ＋ 10)), 集_原地址 ＋ 6, 4)
    FreeLibrary (局_模块句柄)
    返回 (真)
    

.子程序 安装send, 逻辑型, 公开, 安装send     
    .参数 新函数地址, 子程序指针, , 回调子程序指针  该子程序有三个整型参数与一个整型返回值,封包接口(套接字,数据指针,长度指针) 返回 0=放行,-1=拦截

    返回 (安装 (“ws2_32.dll”, “send”, 到整数 (新函数地址)))

.子程序 继续send, , 公开, 取消暂停,继续进行拦截send
    写到内存 (集_新字节, 集_函数地址, 5)
    

.子程序 暂停send, , 公开, 暂停现在的拦截send
    写到内存 (集_原字节, 集_函数地址, 5)
    

.子程序 发送send, 整数型, 公开
    .参数 参_套接字, 整数型
    .参数 参_数据地址, 整数型
    .参数 参_数据长度, 整数型

    返回 (send (参_套接字, 参_数据地址, 参_数据长度, 0))

.子程序 取地址, 整数型, 公开, 取原始数据地址,回调原指针时使用
    返回 (集_原地址)

.子程序 卸载send, 逻辑型, 公开, 卸载send (本命令会在类变量被销毁时自动被调用)
    .局部变量 temp, 整数型

    .如果真 (集_函数地址 ＝ 0)
        返回 (假)
    .如果真结束
    写到内存 (集_原字节, 集_函数地址, 5)
    VirtualProtect (集_函数地址, 5, 集_原保护值, temp)
    集_函数地址 ＝ 0
    集_原字节 ＝ { }
    集_原地址 ＝ 0
    返回 (真)

.版本 2

.程序集 类_InlineHook, , 公开
.程序集变量 私有_是否被HOOK, 逻辑型
.程序集变量 私有_原字节, 字节集
.程序集变量 私有_新字节, 字节集
.程序集变量 私有_新函数地址, 整数型
.程序集变量 私有_内存地址, 整数型
.程序集变量 私有_内存属性, 精易_内存属性
.程序集变量 私有_目标进程句柄, 整数型
.程序集变量 私有_暂停状态, 逻辑型

.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
    ' https://bbs.125.la/forum.php?mod=viewthread&tid=14313676

.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
    .如果真 (私有_是否被HOOK)
        卸载HOOK ()
    .如果真结束
    

.子程序 安装HOOK, 整数型, 公开, 安装HOOK，如果已安装HOOK将直接失败。成功返回 #HOOK状态_成功，失败请自行匹配 #HOOK状态_ 系列常量。请在Hook卸载前不要关闭进程句柄！
    .参数 目标进程句柄, 整数型, , -1等于自身进程。如果是其他进程请使用 进程_打开进程() 方法获取句柄。如果是远程进程那么 新函数地址 无论是否为空，都视为拦截HOOK，不会调用到指定函数。
    .参数 欲HOOK的地址, 整数型, , 可通过 地址_取API地址() 方法获取地址。
    .参数 新函数地址, 子程序指针, 可空, 如果为空则设置为拦截HOOK，当被HOOK函数调用时不执行内容，直接返回0。
    .参数 参数数量, 整数型, 可空, 只有新函数地址为空时才有效。这个参数将决定HOOK函数被调用后堆栈平衡问题，请认真填写。
    .局部变量 Temp字节集, 字节集

    .如果真 (私有_是否被HOOK)
        返回 (#HOOK状态_已HOOK)
    .如果真结束
    .如果真 (欲HOOK的地址 ＝ 0)
        返回 (#HOOK状态_欲HOOK地址为0)
    .如果真结束
    私有_内存地址 ＝ 欲HOOK的地址
    私有_目标进程句柄 ＝ 目标进程句柄
    修改内存保护属性 (-1, 欲HOOK的地址, 私有_内存属性)
    ' 首先判断目标进程PID。如果是-1则对自身HOOK
    .如果真 (目标进程句柄 ＝ -1)
        ' 对自身HOOK步骤：修改内存保护属性
        ' 判断是否有新函数地址, 决定HOOK方式(拦截or调用到指定子程序)
        ' 保存原字节集并修改成新字节集
        ' HOOK成功
        .如果 (是否为空 (新函数地址))
            ' 为空则将函数入口修改成 xor eax,eax ret 到整数(参数数量×4)
            私有_新字节 ＝ { 51, 192, 194 } ＋ 到字节集 (到短整数 (参数数量 × 4)) ' 解释：{51,192}=xor eax,eax(eax清0) {194} =ret ,后面两个字节是ret的具体数字，相当于add esp,数字
            ' 因为易语言会把参数数量×4自动传换成小数型数据，所以到短整数是必须的。否则将得不到预期的结果
        .否则
            ' 不为空则将函数入口修改成 jmp [目标地址]
            私有_新字节 ＝ { 233 } ＋ 到字节集 (到整数 (到整数 (新函数地址) － (欲HOOK的地址 ＋ 5))) ' 解释：{233}=jmp，更多细节请自行理解
        .如果结束
        ' 保存原字节
        私有_原字节 ＝ 指针到字节集 (欲HOOK的地址, 5)
        ' 修改新内存, 并在原字节的基础上制作往回的跳转(用于被CALL回调原函数)
        .如果真 (WriteProcessMemory_字节集 (-1, 欲HOOK的地址, 私有_新字节, 5, 0) ＝ 假)
            返回 (#HOOK状态_写入内存失败)
        .如果真结束
        私有_原字节 ＝ 私有_原字节 ＋ { 233, 0, 0, 0, 0 } ' 解释：233依旧是jmp← ←和上面不同的是这个是跳回去的，思路无非就是先执行备份的5字节，然后跳到原函数5字节后的位置继续执行
        ' 至于后面的0,0,0,0是缓冲区, 因为是相对跳转, 需要用到字节的内存地址, 如果直接修改会导致字节集内存地址变化...所以只能提前弄好缓冲区, 然后直接用写内存的方式修改字节集
        私有_新函数地址 ＝ lstrcpyn_字节集 (私有_原字节, 私有_原字节, 取字节集长度 (私有_原字节))
        ' 计算跳转的位置并写入新字节
        .如果真 (WriteProcessMemory_字节集 (-1, 私有_新函数地址 ＋ 6, 到字节集 (到整数 (欲HOOK的地址 ＋ 5 － (私有_新函数地址 ＋ 10))), 4, 0) ＝ 假)
            返回 (#HOOK状态_写入内存失败)
        .如果真结束
        ' 至此, 进程自身的HOOK成功
        私有_是否被HOOK ＝ 真
        返回 (#HOOK状态_成功)
    .如果真结束
    ' 如果进程句柄不等于-1则为远程HOOK
    ' 远程HOOK因为进程边界问题无法远程调用自身程序的子程序
    ' 所以如果是远程HOOK，则无视 新函数地址
    ' 首先计算字节集
    私有_新字节 ＝ { 51, 192, 194 } ＋ 到字节集 (到短整数 (参数数量 × 4))
    ' 保存原字节
    私有_原字节 ＝ 取空白字节集 (5) ' 初始化缓冲区
    .如果真 (ReadProcessMemory_字节集 (私有_目标进程句柄, 私有_内存地址, 私有_原字节, 5, 0) ＝ 假)
        ' 访问远程内存失败。
        返回 (#HOOK状态_读取内存失败)
    .如果真结束
    ' 读取完毕则计算新的原字节, 然后将新字节写到远程内存
    私有_新函数地址 ＝ 内存_远程创建内存_字节集 (私有_目标进程句柄, 私有_原字节 ＋ { 233, 0, 0, 0, 0 })
    .如果真 (私有_新函数地址 ＝ 0)
        返回 (#HOOK状态_申请远程内存失败)
    .如果真结束
    Temp字节集 ＝ 到字节集 (到整数 (欲HOOK的地址 ＋ 5 － (私有_新函数地址 ＋ 10)))
    .如果真 (WriteProcessMemory_字节集 (私有_目标进程句柄, 私有_新函数地址 ＋ 6, Temp字节集, 4, 0) ＝ 假)
        返回 (#HOOK状态_写入内存失败)
    .如果真结束
    ' 写到远程内存
    .如果真 (WriteProcessMemory_字节集 (私有_目标进程句柄, 私有_内存地址, 私有_新字节, 5, 0) ＝ 假)
        返回 (#HOOK状态_写入内存失败)
    .如果真结束
    私有_是否被HOOK ＝ 真
    返回 (#HOOK状态_成功)

.子程序 修改内存保护属性, 逻辑型
    .参数 进程句柄, 整数型
    .参数 函数地址, 整数型
    .参数 内存属性, 精易_内存属性, , 请保存好这个参数，还原内存保护需要使用！

    .如果真 (VirtualQueryEx (进程句柄, 函数地址, 内存属性, 28) ＝ 0) ' 取内存保护属性
        输出调试文本 (“取内存保护属性失败”)
        返回 (假)
    .如果真结束
    .如果真 (VirtualProtectEx (进程句柄, 内存属性.区域地址, 8, 64, 内存属性.当前属性) ＝ 0) ' 修改内存保护属性(读写)
        输出调试文本 (“修改内存保护属性失败”)
        返回 (假)
    .如果真结束
    返回 (真)

.子程序 还原内存保护属性, 逻辑型
    .参数 进程句柄, 整数型
    .参数 内存属性, 精易_内存属性

    .如果真 (VirtualProtectEx (进程句柄, 内存属性.区域地址, 8, 32, 内存属性.当前属性) ＝ 0) ' 还原虚拟内存属性(只读)
        返回 (假)
    .如果真结束
    返回 (真)

.子程序 卸载HOOK, 逻辑型, 公开, 卸载HOOK，如果卸载失败可尝试 还原_InlineHook()，传递 取原字节集() 函数即可
    .如果真 (私有_是否被HOOK ＝ 假)
        返回 (假)
    .如果真结束
    ' 无论本地进程或者远程进程，都可以通过写WeiteProcessMemory函数修改
    WriteProcessMemory_字节集 (私有_目标进程句柄, 私有_内存地址, 私有_原字节, 5, 0)
    ' 如果远程进程已退出也可能导致卸载HOOK失败, 所以这里不做判断
    ' 如果需要带判断版本请使用 InlineHook还原() 方法
    .如果真 (私有_目标进程句柄 ≠ -1)
        内存_释放远程内存 (私有_目标进程句柄, 私有_新函数地址)
    .如果真结束
    还原内存保护属性 (私有_目标进程句柄, 私有_内存属性)
    私有_是否被HOOK ＝ 假
    连续赋值 ({ }, 私有_原字节, 私有_新字节)
    连续赋值 (0, 私有_内存地址, 私有_新函数地址, 私有_目标进程句柄)
    返回 (真)

.子程序 暂停HOOK, 逻辑型, 公开, 暂停(还原)HOOK
    .如果真 (私有_暂停状态 ＝ 假)
        WriteProcessMemory_字节集 (私有_目标进程句柄, 私有_内存地址, 私有_原字节, 5, 0)
        私有_暂停状态 ＝ 真
        返回 (真)
    .如果真结束
    返回 (假)

.子程序 继续HOOK, 逻辑型, 公开, 继续(安装)HOOK
    .如果真 (私有_暂停状态 ＝ 真)
        WriteProcessMemory_字节集 (私有_目标进程句柄, 私有_内存地址, 私有_新字节, 5, 0)
        私有_暂停状态 ＝ 假
        返回 (真)
    .如果真结束
    返回 (假)

.子程序 取地址, 整数型, 公开, 获取一个HOOK地址，这个地址允许被 调用子程序_ 来调用，当调用这个地址时不会触发HOOK函数。请自行区分远程调用和本地调用！
    返回 (私有_新函数地址)

.子程序 取原字节集, 字节集, 公开, 取出备份的原字节集，可用于 还原_InlineHook()函数上
    返回 (私有_原字节)

.版本 2

.程序集 类_ODBC数据库, , 公开, 此类为易友 校长小猪猪 提供。
.程序集变量 m_hENV, 整数型
.程序集变量 m_hDBC, 整数型

.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
    SQLAllocHandle (#SQL_HANDLE_ENV, #SQL_NULL_HANDLE, m_hENV) ' 申请环境句柄
    SQLSetEnvAttr (m_hENV, #SQL_ATTR_ODBC_VERSION, #SQL_OV_ODBC3, #SQL_IS_INTEGER)

.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
    关闭 ()
    SQLFreeHandle (#SQL_HANDLE_ENV, m_hENV)

.子程序 取数据库句柄, 整数型, 公开
    返回 (m_hDBC)

.子程序 置数据库句柄, , 公开
    .参数 参数_数据库句柄, 整数型

    m_hDBC ＝ 参数_数据库句柄

.子程序 连接, 逻辑型, 公开
    .参数 参数_连接字符串, 文本型
    .局部变量 局部_实际长度, 整数型
    .局部变量 局部_输出, 文本型
    .局部变量 局部_长度, 整数型
    .局部变量 ret, 短整数型

    .如果真 (m_hDBC ＝ 0)
        ret ＝ SQLAllocHandle (#SQL_HANDLE_DBC, m_hENV, m_hDBC) ' 申请连接句柄
        .如果真 (ret ≠ #SQL_SUCCESS)
            返回 (假)
        .如果真结束
        
    .如果真结束
    局部_长度 ＝ 取文本长度 (参数_连接字符串)
    局部_输出 ＝ 取空白文本 (1024)
    ret ＝ SQLDriverConnect (m_hDBC, 0, 参数_连接字符串, 局部_长度, 局部_输出, 1024, 局部_实际长度, #SQL_DRIVER_NOPROMPT)
    返回 (ret ＝ #SQL_SUCCESS 或 ret ＝ #SQL_SUCCESS_WITH_INFO)

.子程序 连接SQLServer, 逻辑型, 公开
    .参数 参数_服务器名, 文本型
    .参数 参数_数据库, 文本型
    .参数 参数_用户名, 文本型, 可空, 为空默认以Windows账户登录
    .参数 参数_密码, 文本型, 可空, 为空默认以Windows账户登录
    .局部变量 局_连接字符串, 文本型

    局_连接字符串 ＝ “driver={sql server};server=” ＋ 参数_服务器名 ＋ “;database=” ＋ 参数_数据库 ＋ “;uid=” ＋ 参数_用户名 ＋ “;pwd=” ＋ 参数_密码
    .如果真 (是否为空 (参数_用户名) 且 是否为空 (参数_密码))
        局_连接字符串 ＝ “Driver=SQL Server;Server=” ＋ 参数_服务器名 ＋ “;Database=” ＋ 参数_数据库 ＋ “;Trusted_Connection=Yes;Connect Timeout=90”
    .如果真结束
    返回 (连接 (局_连接字符串))

.子程序 连接Access, 逻辑型, 公开, 连接mdb或accdb数据库
    .参数 参数_文件名, 文本型, , 本参数提供Access数据库文件的完整路径名。
    .参数 参数_密码, 文本型, 可空, 本参数提供Access数据库的访问密码。可以为空，若为空，表示Access数据库没有密码。
    .参数 参数_Accdb, 逻辑型, 可空, 数据库类型。默认为假=mdb，真=accdb。
    .局部变量 局_连接语句, 文本型

    .如果 (参数_Accdb)
        局_连接语句 ＝ “ODBC;DSN=MS Access Database;DBQ=” ＋ 参数_文件名 ＋ “;Driver={Microsoft Access Driver (*.mdb, *.accdb)};;DriverId=25;FIL=MS Access;MaxBufferSize=2048;PageTimeout=5;PWD=” ＋ 参数_密码
    .否则
        局_连接语句 ＝ “DBQ=” ＋ 参数_文件名 ＋ “;Pwd=” ＋ 参数_密码 ＋ “;DRIVER={Microsoft Access Driver (*.mdb)};”
    .如果结束
    返回 (连接 (局_连接语句))

.子程序 关闭, 逻辑型, 公开
    .局部变量 ret, 短整数型

    ret ＝ SQLDisconnect (m_hDBC)
    .如果真 (ret ≠ #SQL_SUCCESS)
        返回 (假)
    .如果真结束
    ret ＝ SQLFreeHandle (#SQL_HANDLE_DBC, m_hDBC)
    m_hDBC ＝ 0
    返回 (真)

.子程序 执行SQL, 逻辑型, 公开
    .参数 参数_SQL语句, 文本型
    .参数 参数_影响行, 整数型, 参考 可空
    .局部变量 ret, 短整数型
    .局部变量 hSTMT, 整数型

    ret ＝ SQLAllocHandle (#SQL_HANDLE_STMT, m_hDBC, hSTMT)
    .如果真 (ret ≠ #SQL_SUCCESS)
        返回 (假)
    .如果真结束
    ret ＝ SQLExecDirect (hSTMT, 参数_SQL语句, 取文本长度 (参数_SQL语句))
    .如果真 (是否为空 (参数_影响行) ＝ 假)
        SQLRowCount (hSTMT, 参数_影响行)
    .如果真结束
    SQLFreeHandle (#SQL_HANDLE_STMT, hSTMT)
    返回 (ret ＝ #SQL_SUCCESS)

.子程序 执行, 逻辑型, 公开
    .参数 参数_SQL语句, 文本型, , 语句中的第几个“?”，表示参数几
    .参数 参数_影响行, 整数型, 参考 可空
    .参数 参数一, 字节集, 可空
    .参数 参数二, 字节集, 可空
    .参数 参数三, 字节集, 可空
    .参数 参数四, 字节集, 可空
    .参数 参数五, 字节集, 可空
    .局部变量 ret, 短整数型
    .局部变量 hSTMT, 整数型
    .局部变量 len, 整数型, , "5"

    ret ＝ SQLAllocHandle (#SQL_HANDLE_STMT, m_hDBC, hSTMT)
    .如果真 (ret ≠ #SQL_SUCCESS)
        返回 (假)
    .如果真结束
    ret ＝ SQLPrepare (hSTMT, 参数_SQL语句, #SQL_NTS)
    .如果真 (ret ≠ #SQL_SUCCESS)
        SQLFreeHandle (#SQL_HANDLE_STMT, hSTMT)
        返回 (假)
    .如果真结束
    
    .计次循环首 (1, )
        .如果真 (是否为空 (参数一))
            跳出循环 ()
        .如果真结束
        len [1] ＝ 取字节集长度 (参数一)
        ret ＝ SQLBindParameter (hSTMT, 1, #SQL_PARAM_INPUT, #SQL_C_BINARY, #SQL_LONGVARBINARY, len [1], 0, 参数一, len [1], len [1])
        .如果真 (是否为空 (参数二))
            跳出循环 ()
        .如果真结束
        len [2] ＝ 取字节集长度 (参数二)
        ret ＝ SQLBindParameter (hSTMT, 2, #SQL_PARAM_INPUT, #SQL_C_BINARY, #SQL_LONGVARBINARY, len [2], 0, 参数二, len [2], len [2])
        .如果真 (是否为空 (参数三))
            跳出循环 ()
        .如果真结束
        len [3] ＝ 取字节集长度 (参数三)
        ret ＝ SQLBindParameter (hSTMT, 3, #SQL_PARAM_INPUT, #SQL_C_BINARY, #SQL_LONGVARBINARY, len [3], 0, 参数三, len [3], len [3])
        .如果真 (是否为空 (参数四))
            跳出循环 ()
        .如果真结束
        len [4] ＝ 取字节集长度 (参数四)
        ret ＝ SQLBindParameter (hSTMT, 4, #SQL_PARAM_INPUT, #SQL_C_BINARY, #SQL_LONGVARBINARY, len [4], 0, 参数四, len [4], len [4])
        .如果真 (是否为空 (参数五))
            跳出循环 ()
        .如果真结束
        len [5] ＝ 取字节集长度 (参数五)
        ret ＝ SQLBindParameter (hSTMT, 5, #SQL_PARAM_INPUT, #SQL_C_BINARY, #SQL_LONGVARBINARY, len [5], 0, 参数五, len [5], len [5])
        
    .计次循环尾 ()
    ret ＝ SQLExecute (hSTMT)
    .如果真 (是否为空 (参数_影响行) ＝ 假)
        SQLRowCount (hSTMT, 参数_影响行)
    .如果真结束
    SQLFreeHandle (#SQL_HANDLE_STMT, hSTMT)
    返回 (ret ＝ #SQL_SUCCESS)

.子程序 查询, 整数型, 公开, 返回记录集句柄。此时记录集位置在首记录前
    .参数 参数_SQL语句, 文本型
    .参数 参数_光标类型, 整数型, 可空, “光标类型_”开头常量。默认为“光标类型_键集”
    .局部变量 ret, 短整数型
    .局部变量 hSTMT, 整数型

    ret ＝ SQLAllocHandle (#SQL_HANDLE_STMT, m_hDBC, hSTMT)
    .如果真 (ret ≠ #SQL_SUCCESS)
        返回 (0)
    .如果真结束
    .如果真 (是否为空 (参数_光标类型))
        参数_光标类型 ＝ #光标类型_键集
    .如果真结束
    ret ＝ SQLSetStmtAttr (hSTMT, #SQL_ATTR_CURSOR_TYPE, 参数_光标类型, 0)
    ret ＝ SQLExecDirect (hSTMT, 参数_SQL语句, 取文本长度 (参数_SQL语句))
    .如果真 (ret ≠ #SQL_SUCCESS)
        SQLFreeHandle (#SQL_HANDLE_STMT, hSTMT)
        返回 (0)
    .如果真结束
    返回 (hSTMT)

.子程序 置SQL语句, 整数型, 公开, 准备一条SQL语句，此时并没有执行。返回记录集句柄
    .参数 参数_SQL语句, 文本型
    .参数 参数_光标类型, 整数型, 可空, “光标类型_”开头常量。默认为“光标类型_向前”
    .局部变量 ret, 短整数型
    .局部变量 hSTMT, 整数型

    ret ＝ SQLAllocHandle (#SQL_HANDLE_STMT, m_hDBC, hSTMT)
    .如果真 (ret ≠ #SQL_SUCCESS)
        返回 (0)
    .如果真结束
    .如果真 (是否为空 (参数_光标类型))
        参数_光标类型 ＝ #光标类型_键集
    .如果真结束
    
    ret ＝ SQLSetStmtAttr (hSTMT, #SQL_ATTR_CURSOR_TYPE, 参数_光标类型, 0)
    ret ＝ SQLPrepare (hSTMT, 参数_SQL语句, #SQL_NTS)
    .如果真 (ret ≠ #SQL_SUCCESS)
        SQLFreeHandle (#SQL_HANDLE_STMT, hSTMT)
        返回 (0)
    .如果真结束
    返回 (hSTMT)

.子程序 执行记录集, 逻辑型, 公开, 执行由“置SQL语句”返回的记录集。
    .参数 参数_记录集句柄, 整数型
    .局部变量 ret, 短整数型

    ret ＝ SQLExecute (参数_记录集句柄)
    返回 (ret ＝ #SQL_SUCCESS)

.子程序 绑定参数, 逻辑型, 公开, 给记录集绑定参数。
    .参数 参数_记录集句柄, 整数型
    .参数 参数_参数索引, 整数型, , 表示第几个参数，索引从1开始
    .参数 参数_字节集, 字节集
    .局部变量 len, 整数型
    .局部变量 ret, 短整数型

    len ＝ 取字节集长度 (参数_字节集)
    ret ＝ SQLBindParameter (参数_记录集句柄, 参数_参数索引, #SQL_PARAM_INPUT, #SQL_C_BINARY, #SQL_LONGVARBINARY, len, 0, 参数_字节集, len, len)
    返回 (ret ≠ #SQL_SUCCESS)

.子程序 释放记录集, 逻辑型, 公开
    .参数 参数_记录集句柄, 整数型

    返回 (SQLFreeHandle (#SQL_HANDLE_STMT, 参数_记录集句柄) ＝ #SQL_SUCCESS)

.子程序 到下一条, 逻辑型, 公开, 如果到最后一行，返回假
    .参数 参数_记录集句柄, 整数型
    .局部变量 ret, 短整数型

    ret ＝ SQLFetchScroll (参数_记录集句柄, #SQL_FETCH_NEXT, 0)
    返回 (ret ＝ #SQL_SUCCESS)

.子程序 到上一条, 逻辑型, 公开
    .参数 参数_记录集句柄, 整数型
    .局部变量 ret, 短整数型

    ret ＝ SQLFetchScroll (参数_记录集句柄, #SQL_FETCH_PRIOR, 0)
    返回 (ret ＝ #SQL_SUCCESS)

.子程序 到首记录, 逻辑型, 公开
    .参数 参数_记录集句柄, 整数型
    .局部变量 ret, 短整数型

    ret ＝ SQLFetchScroll (参数_记录集句柄, #SQL_FETCH_FIRST, 0)
    返回 (ret ＝ #SQL_SUCCESS)

.子程序 到尾记录, 逻辑型, 公开
    .参数 参数_记录集句柄, 整数型
    .局部变量 ret, 短整数型

    ret ＝ SQLFetchScroll (参数_记录集句柄, #SQL_FETCH_LAST, 0)
    返回 (ret ＝ #SQL_SUCCESS)

.子程序 移到, 逻辑型, 公开
    .参数 参数_记录集句柄, 整数型
    .参数 参数_行号, 整数型
    .局部变量 ret, 短整数型

    ret ＝ SQLFetchScroll (参数_记录集句柄, #SQL_FETCH_ABSOLUTE, 参数_行号)
    返回 (ret ＝ #SQL_SUCCESS)

.子程序 字段名到序号, 整数型
    .参数 参数_记录集句柄, 整数型
    .参数 参数_字段名, 文本型
    .局部变量 i, 整数型

    .计次循环首 (取字段数 (参数_记录集句柄), i)
        .如果真 (取字段名 (参数_记录集句柄, i － 1) ＝ 参数_字段名)
            返回 (i － 1)
        .如果真结束
        
    .计次循环尾 ()
    返回 (-1)

.子程序 读字段文本, 文本型, 公开, 用字段名读
    .参数 参数_记录集句柄, 整数型
    .参数 参数_字段名, 文本型
    .局部变量 局部_序号, 整数型

    局部_序号 ＝ 字段名到序号 (参数_记录集句柄, 参数_字段名)
    .如果真 (局部_序号 ＝ -1)
        返回 (“”)
    .如果真结束
    返回 (读文本 (参数_记录集句柄, 局部_序号))

.子程序 读字段字节集, 字节集, 公开, 用字段名读
    .参数 参数_记录集句柄, 整数型
    .参数 参数_字段名, 文本型
    .局部变量 局部_序号, 整数型

    局部_序号 ＝ 字段名到序号 (参数_记录集句柄, 参数_字段名)
    .如果真 (局部_序号 ＝ -1)
        返回 ({ })
    .如果真结束
    返回 (读字节集 (参数_记录集句柄, 局部_序号))

.子程序 读字段整数, 整数型, 公开, 用字段名读
    .参数 参数_记录集句柄, 整数型
    .参数 参数_字段名, 文本型
    .局部变量 局部_实际长度, 整数型
    .局部变量 ret, 短整数型
    .局部变量 局部_整数, 整数型
    .局部变量 局部_序号, 整数型

    局部_序号 ＝ 字段名到序号 (参数_记录集句柄, 参数_字段名)
    .如果真 (局部_序号 ＝ -1)
        返回 (0)
    .如果真结束
    ret ＝ SQLGetData (参数_记录集句柄, 局部_序号 ＋ 1, #SQL_C_LONG, 取指针整数_ (局部_整数), 4, 局部_实际长度)
    返回 (局部_整数)

.子程序 读字段单精度, 小数型, 公开, 用字段名读
    .参数 参数_记录集句柄, 整数型
    .参数 参数_字段名, 文本型
    .局部变量 局部_实际长度, 整数型
    .局部变量 ret, 短整数型
    .局部变量 value, 小数型
    .局部变量 局部_序号, 整数型

    局部_序号 ＝ 字段名到序号 (参数_记录集句柄, 参数_字段名)
    .如果真 (局部_序号 ＝ -1)
        返回 (0)
    .如果真结束
    ret ＝ SQLGetData (参数_记录集句柄, 局部_序号 ＋ 1, #SQL_C_FLOAT, 取指针小数_ (value), 4, 局部_实际长度)
    返回 (value)

.子程序 读字段双精度, 双精度小数型, 公开, 用字段名读
    .参数 参数_记录集句柄, 整数型
    .参数 参数_字段名, 文本型
    .局部变量 局部_实际长度, 整数型
    .局部变量 ret, 短整数型
    .局部变量 value, 双精度小数型
    .局部变量 局部_序号, 整数型

    局部_序号 ＝ 字段名到序号 (参数_记录集句柄, 参数_字段名)
    .如果真 (局部_序号 ＝ -1)
        返回 (0)
    .如果真结束
    ret ＝ SQLGetData (参数_记录集句柄, 局部_序号 ＋ 1, #SQL_C_DOUBLE, 取指针双精度_ (value), 8, 局部_实际长度)
    返回 (value)

.子程序 读文本, 文本型, 公开
    .参数 参数_记录集句柄, 整数型
    .参数 参数_列号, 整数型, , 索引从0开始
    .局部变量 局部_实际长度, 整数型
    .局部变量 buffer, 文本型
    .局部变量 ret, 短整数型
    .局部变量 局部_返回值, 文本型

    .如果真 (参数_记录集句柄 ＝ 0)
        返回 (“”)
    .如果真结束
    局部_实际长度 ＝ 255
    .循环判断首 ()
        buffer ＝ 取空白文本 (局部_实际长度)
        ret ＝ SQLGetData (参数_记录集句柄, 参数_列号 ＋ 1, #SQL_C_CHAR, 取指针文本_ (buffer), 局部_实际长度, 局部_实际长度)
        .如果真 (ret ＝ #SQL_ERROR 或 ret ＝ #SQL_INVALID_HANDLE 或 局部_实际长度 ＝ -1)
            返回 (“”)
        .如果真结束
        局部_返回值 ＝ 局部_返回值 ＋ 取文本左边 (buffer, 局部_实际长度)
    .循环判断尾 (ret ＝ #SQL_SUCCESS_WITH_INFO)
    返回 (局部_返回值)

.子程序 读字节集, 字节集, 公开
    .参数 参数_记录集句柄, 整数型
    .参数 参数_列号, 整数型, , 索引从0开始
    .局部变量 局部_实际长度, 整数型
    .局部变量 ret, 短整数型
    .局部变量 buffer, 字节集
    .局部变量 局部_返回值, 字节集

    .如果真 (参数_记录集句柄 ＝ 0)
        返回 ({ })
    .如果真结束
    局部_实际长度 ＝ 10240
    .循环判断首 ()
        buffer ＝ 取空白字节集 (局部_实际长度)
        ret ＝ SQLGetData (参数_记录集句柄, 参数_列号 ＋ 1, #SQL_C_BINARY, 取指针字节集_ (buffer), 局部_实际长度, 局部_实际长度)
        .如果真 (ret ＝ #SQL_ERROR 或 ret ＝ #SQL_INVALID_HANDLE 或 局部_实际长度 ＝ -1)
            返回 ({ })
        .如果真结束
        局部_返回值 ＝ 局部_返回值 ＋ 取字节集左边 (buffer, 局部_实际长度)
    .循环判断尾 (ret ＝ #SQL_SUCCESS_WITH_INFO)
    返回 (局部_返回值)

.子程序 读整数, 整数型, 公开
    .参数 参数_记录集句柄, 整数型
    .参数 参数_列号, 整数型, , 索引从0开始
    .局部变量 局部_实际长度, 整数型
    .局部变量 ret, 短整数型
    .局部变量 局部_整数, 整数型

    .如果真 (参数_记录集句柄 ＝ 0)
        返回 (0)
    .如果真结束
    ret ＝ SQLGetData (参数_记录集句柄, 参数_列号 ＋ 1, #SQL_C_LONG, 取指针整数_ (局部_整数), 4, 局部_实际长度)
    返回 (局部_整数)

.子程序 读单精度, 小数型, 公开
    .参数 参数_记录集句柄, 整数型
    .参数 参数_列号, 整数型, , 索引从0开始
    .局部变量 局部_实际长度, 整数型
    .局部变量 ret, 短整数型
    .局部变量 value, 小数型

    .如果真 (参数_记录集句柄 ＝ 0)
        返回 (0)
    .如果真结束
    ret ＝ SQLGetData (参数_记录集句柄, 参数_列号 ＋ 1, #SQL_C_FLOAT, 取指针小数_ (value), 4, 局部_实际长度)
    返回 (value)

.子程序 读双精度, 双精度小数型, 公开
    .参数 参数_记录集句柄, 整数型
    .参数 参数_列号, 整数型, , 索引从0开始
    .局部变量 局部_实际长度, 整数型
    .局部变量 ret, 短整数型
    .局部变量 value, 双精度小数型

    .如果真 (参数_记录集句柄 ＝ 0)
        返回 (0)
    .如果真结束
    ret ＝ SQLGetData (参数_记录集句柄, 参数_列号 ＋ 1, #SQL_C_DOUBLE, 取指针双精度_ (value), 8, 局部_实际长度)
    返回 (value)

.子程序 取字段名, 文本型, 公开
    .参数 参数_记录集句柄, 整数型
    .参数 参数_列号, 整数型, , 列号从0开始
    .局部变量 局部_字段名, 文本型

    局部_字段名 ＝ 取空白文本 (255)
    .如果 (SQLDescribeCol (参数_记录集句柄, 参数_列号 ＋ 1, 局部_字段名, 255, 0, 0, 0, 0, 0) ≠ #SQL_SUCCESS)
        返回 (“”)
    .否则
        返回 (局部_字段名)
    .如果结束
    

.子程序 取字段数, 整数型, 公开
    .参数 参数_记录集句柄, 整数型
    .局部变量 ColumnCount, 整数型

    SQLNumResultCols (参数_记录集句柄, ColumnCount)
    返回 (ColumnCount)

.子程序 取字段类型, 整数型, 公开, 返回“SQL_”开头常量
    .参数 参数_记录集句柄, 整数型
    .参数 参数_列号, 整数型, , 列号从0开始
    .局部变量 局部_类型, 整数型

    .如果 (SQLDescribeCol (参数_记录集句柄, 参数_列号 ＋ 1, 字符 (0), 0, 0, 局部_类型, 0, 0, 0) ≠ #SQL_SUCCESS)
        返回 (0)
    .否则
        返回 (局部_类型)
    .如果结束
    

.子程序 取字段定义长度, 整数型, 公开
    .参数 参数_记录集句柄, 整数型
    .参数 参数_列号, 整数型, , 列号从0开始
    .局部变量 局部_长度, 整数型

    .如果 (SQLDescribeCol (参数_记录集句柄, 参数_列号 ＋ 1, 字符 (0), 0, 0, 0, 局部_长度, 0, 0) ≠ #SQL_SUCCESS)
        返回 (0)
    .否则
        返回 (局部_长度)
    .如果结束
    

.子程序 字段是否可空, 逻辑型, 公开
    .参数 参数_记录集句柄, 整数型
    .参数 参数_字段序号, 整数型, , 列号从0开始
    .局部变量 局部_是否为空, 整数型

    .如果 (SQLDescribeCol (参数_记录集句柄, 参数_字段序号 ＋ 1, 字符 (0), 0, 0, 0, 0, 0, 局部_是否为空) ≠ #SQL_SUCCESS)
        返回 (假)
    .否则
        返回 (局部_是否为空 ≠ 0)
    .如果结束
    

.子程序 取记录数, 整数型, 公开
    .参数 参数_表名, 文本型
    .参数 参数_条件, 文本型, 可空
    .局部变量 sql, 文本型
    .局部变量 局部_行数, 整数型
    .局部变量 res, 整数型

    sql ＝ “select count(1) from ” ＋ 参数_表名 ＋ “ ”
    .如果真 (是否为空 (参数_条件) ＝ 假)
        sql ＝ sql ＋ 参数_条件
    .如果真结束
    res ＝ 查询 (sql, #光标类型_向前)
    到下一条 (res)
    局部_行数 ＝ 读整数 (res, 0)
    SQLFreeHandle (#SQL_HANDLE_STMT, res)
    返回 (局部_行数)

.子程序 开始事务, 逻辑型, 公开
    .局部变量 ret, 短整数型

    ret ＝ SQLSetConnectAttr (m_hDBC, #SQL_ATTR_AUTOCOMMIT, #SQL_AUTOCOMMIT_OFF, #SQL_IS_UINTEGER)
    返回 (ret ＝ #SQL_SUCCESS)

.子程序 回滚事务, 逻辑型, 公开
    .局部变量 ret, 短整数型

    ret ＝ SQLEndTran (#SQL_HANDLE_DBC, m_hDBC, #SQL_ROLLBACK)
    SQLSetConnectAttr (m_hDBC, #SQL_ATTR_AUTOCOMMIT, #SQL_AUTOCOMMIT_ON, #SQL_IS_UINTEGER)
    返回 (ret ＝ #SQL_SUCCESS)

.子程序 提交事务, 逻辑型, 公开
    .局部变量 ret, 短整数型

    ret ＝ SQLEndTran (#SQL_HANDLE_DBC, m_hDBC, #SQL_COMMIT)
    SQLSetConnectAttr (m_hDBC, #SQL_ATTR_AUTOCOMMIT, #SQL_AUTOCOMMIT_ON, #SQL_IS_UINTEGER)
    返回 (ret ＝ #SQL_SUCCESS)

.子程序 设超时时间, 逻辑型, 公开
    .参数 参数_要设置的时间, 整数型
    .局部变量 ret, 短整数型

    .如果真 (m_hDBC ＝ 0)
        ret ＝ SQLAllocHandle (#SQL_HANDLE_DBC, m_hENV, m_hDBC) ' 申请连接句柄
        .如果真 (ret ≠ #SQL_SUCCESS)
            返回 (假)
        .如果真结束
        
    .如果真结束
    返回 (SQLSetConnectAttr (m_hDBC, #SQL_ATTR_CONNECTION_TIMEOUT, 取指针整数_ (参数_要设置的时间), 0) ＝ #SQL_SUCCESS)

.子程序 取超时时间, 整数型, 公开
    .局部变量 ret, 短整数型
    .局部变量 value, 整数型

    .如果真 (m_hDBC ＝ 0)
        ret ＝ SQLAllocHandle (#SQL_HANDLE_DBC, m_hENV, m_hDBC) ' 申请连接句柄
        .如果真 (ret ≠ #SQL_SUCCESS)
            返回 (0)
        .如果真结束
        
    .如果真结束
    ret ＝ SQLGetConnectAttr (m_hDBC, #SQL_ATTR_CONNECTION_TIMEOUT, 取指针整数_ (value), #SQL_IS_UINTEGER, 0)
    返回 (value)

.子程序 取最后错误, 整数型, 公开, 返回错误号。
    .参数 参数_错误状态, 文本型, 参考 可空
    .参数 参数_错误描述, 文本型, 参考 可空
    .局部变量 局部_实际长度, 整数型
    .局部变量 ret, 短整数型
    .局部变量 state, 文本型
    .局部变量 message, 文本型
    .局部变量 index, 整数型
    .局部变量 error, 整数型

    .循环判断首 ()
        index ＝ index ＋ 1
        state ＝ 取空白文本 (6)
        message ＝ 取空白文本 (#SQL_MAX_MESSAGE_LENGTH)
        ret ＝ SQLGetDiagRec (#SQL_HANDLE_DBC, m_hDBC, index, state, error, message, #SQL_MAX_MESSAGE_LENGTH, 局部_实际长度)
        .如果真 (ret ＝ #SQL_ERROR 或 ret ＝ #SQL_INVALID_HANDLE 或 局部_实际长度 ＝ -1)
            返回 (0)
        .如果真结束
        参数_错误状态 ＝ 参数_错误状态 ＋ state
        参数_错误描述 ＝ 参数_错误描述 ＋ 取文本左边 (message, 局部_实际长度)
    .循环判断尾 (ret ≠ #SQL_NO_DATA)
    返回 (error)

.子程序 取查询信息, 文本型
    .参数 参_查询参数, 文本型
    .局部变量 ret, 整数型
    .局部变量 szConnStrOut, 文本型
    .局部变量 sConnStrOut, 整数型

    .如果真 (m_hDBC ＝ 0)
        ret ＝ SQLAllocHandle (#SQL_HANDLE_DBC, m_hENV, m_hDBC) ' 申请连接句柄
        .如果真 (ret ≠ #SQL_SUCCESS)
            返回 (“”)
        .如果真结束
        
    .如果真结束
    szConnStrOut ＝ 取空白文本 (2048)
    SQLBrowseConnect (m_hDBC, 参_查询参数, #SQL_NTS, szConnStrOut, 2048, sConnStrOut)
    返回 (删首尾空 (szConnStrOut))

.子程序 枚举SQL服务器, 整数型, 公开, 枚举局域网内中SQL服务器，成功返回服务器名称数量，失败返回0
    .参数 参_服务列表, 文本型, 数组, 变量储存返回值
    .局部变量 szConnStrOut, 文本型
    .局部变量 strText, 文本型

    szConnStrOut ＝ 取查询信息 (“Driver={SQL Server}”)
    .如果真 (szConnStrOut ＝ “”)
        返回 (0)
    .如果真结束
    清除数组 (参_服务列表)
    .如果真 (寻找文本 (szConnStrOut, “SERVER:”, , 假) ＝ -1)
        返回 (0)
    .如果真结束
    strText ＝ 文本_取出中间文本 (szConnStrOut, “={”, “}”)
    参_服务列表 ＝ 分割文本 (strText, “,”, )
    返回 (取数组成员数 (参_服务列表))

.子程序 枚举SQL数据库, 整数型, 公开, 枚举指定SQL服务器的数据库，成功返回数据列表数量，失败返回0
    .参数 参_服务器, 文本型
    .参数 参_登录用户名, 文本型
    .参数 参_登录密码, 文本型
    .参数 参_数据库列表, 文本型, 数组, 变量储存返回值
    .局部变量 szConnStrOut, 文本型
    .局部变量 strText, 文本型

    szConnStrOut ＝ 取查询信息 (“Driver={SQL Server};SERVER=” ＋ 参_服务器 ＋ “;UID=” ＋ 参_登录用户名 ＋ “;PWD=” ＋ 参_登录密码)
    .如果真 (szConnStrOut ＝ “”)
        返回 (0)
    .如果真结束
    清除数组 (参_数据库列表)
    .如果真 (寻找文本 (szConnStrOut, “DATABASE”, , 假) ＝ -1)
        返回 (0)
    .如果真结束
    strText ＝ 文本_取出中间文本 (szConnStrOut, “={”, “}”)
    参_数据库列表 ＝ 分割文本 (strText, “,”, )
    返回 (取数组成员数 (参_数据库列表))

.版本 2

.程序集 类_内存, , 公开
.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
    

.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
    

.子程序 置属性, 整数型, 公开
    .参数 进程句柄, 整数型, , 目标进程句柄,用 进程_打开() 命令取得
    .参数 内存地址, 整数型
    .参数 内存属性, 整数型, , 2 = 只读; 4 = 可读写
    .局部变量 虚拟保护, 精易_内存属性
    .局部变量 原保护, 整数型
    .局部变量 返回, 整数型

    .如果真 (VirtualQueryEx (进程句柄, 内存地址, 虚拟保护, 28) ≠ 0)
        返回 ＝ VirtualProtectEx (进程句柄, 虚拟保护.区域地址, 虚拟保护.区域长度, 内存属性, 虚拟保护.当前属性)
    .如果真结束
    返回 (返回)

.子程序 取属性, 逻辑型, 公开, 取内存属性信息;成功返回真,失败返回假;
    .参数 进程句柄, 整数型, , 目标进程句柄,用 进程_打开() 命令取得
    .参数 内存地址, 整数型, , 要取内存属性的内存地址;
    .参数 内存属性, 精易_内存属性, 参考, 内存属性.当前属性 0=未分配,不可访问=1,2=可读,读写=4,可写与拷贝=8,可运行=16,可运行与可读=32,可运行可读写=64,可运行读写拷贝=128,guard=256,非物理内存=512

    返回 (VirtualQueryEx (进程句柄, 内存地址, 内存属性, 28) ≠ 0)

.子程序 搜索, 整数型, 公开, 某些情况，需提升权限(返回结果数目,失败返回0)
    .参数 进程ID, 整数型, , 进程ID
    .参数 搜索内容, 字节集, , 欲搜索的内容  其他类型-需自行转换为字节集类型
    .参数 结果数组, 整数型, 参考 数组, 用来保存搜索的结果
    .局部变量 长度, 整数型
    .局部变量 操作句柄, 整数型
    .局部变量 内存地址, 整数型
    .局部变量 内存块信息, 精易_内存属性
    .局部变量 数据缓冲区, 字节集
    .局部变量 读取结果, 逻辑型
    .局部变量 找到地址, 整数型

    清除数组 (结果数组)
    长度 ＝ 取字节集长度 (搜索内容)
    操作句柄 ＝ OpenProcess (#PROCESS_ALL_ACCESS, 0, 进程ID) ' 取得操作句柄
    .判断循环首 (VirtualQueryEx (操作句柄, 内存地址, 内存块信息, 28) ≠ 0) ' 取得内存块信息
        .如果真 (内存块信息.当前属性 ≠ 16 且 内存块信息.当前属性 ≠ 1 且 内存块信息.当前属性 ≠ 512) ' 判断保护状态
            数据缓冲区 ＝ 取空白字节集 (内存块信息.区域长度)
            读取结果 ＝ ReadProcessMemory_字节集 (操作句柄, 内存地址, 数据缓冲区, 内存块信息.区域长度, 0)
            .判断循环首 (读取结果 ≠ 假)
                找到地址 ＝ 寻找字节集 (数据缓冲区, 搜索内容, 找到地址) ' 查找是否有要搜索的数据
                .如果 (找到地址 ＝ -1) ' 跳出 进行下次循环
                    跳出循环 ()
                    
                .否则
                    加入成员 (结果数组, 到数值 (内存地址 ＋ 找到地址 － 1))
                .如果结束
                找到地址 ＝ 找到地址 ＋ 长度
            .判断循环尾 ()
        .如果真结束
        内存地址 ＝ 内存地址 ＋ 内存块信息.区域长度 ' 搜索下一内存块
        处理事件 ()
    .判断循环尾 ()
    CloseHandle (操作句柄)
    返回 (取数组成员数 (结果数组))

.子程序 读小数, 小数型, 公开, 失败返回0。
    .参数 进程ID, 整数型
    .参数 内存地址, 整数型
    .局部变量 临时整数, 小数型
    .局部变量 操作句柄, 整数型
    .局部变量 bool, 逻辑型

    操作句柄 ＝ OpenProcess (#PROCESS_ALL_ACCESS, 0, 进程ID) ' 取得操作句柄
    bool ＝ ReadProcessMemory_小数型 (操作句柄, 内存地址, 临时整数, 4, 0)
    CloseHandle (操作句柄)
    返回 (选择 (bool, 临时整数, 0))

.子程序 写小数, 逻辑型, 公开
    .参数 进程ID, 整数型, , 进程ID
    .参数 内存地址, 整数型, , 内存地址
    .参数 要写入的值, 小数型, , 写入数据
    .局部变量 局_进程句柄, 整数型
    .局部变量 bool, 逻辑型
    .局部变量 局_长度, 整数型

    局_进程句柄 ＝ OpenProcess (#PROCESS_ALL_ACCESS, 0, 进程ID)
    bool ＝ WriteProcessMemory_小数型 (局_进程句柄, 内存地址, 要写入的值, 4, 0)
    CloseHandle (局_进程句柄)
    返回 (bool)

.子程序 读文本, 文本型, 公开, 读取文本型数据(返回文本 失败返回空文本)
    .参数 进程ID, 整数型
    .参数 内存地址, 整数型
    .参数 长度, 整数型, 可空, 默认为20 欲读取的长度字节
    .局部变量 临时字节集, 字节集
    .局部变量 操作句柄, 整数型
    .局部变量 bool, 逻辑型

    .如果真 (长度 ＝ 0)
        长度 ＝ 20
    .如果真结束
    ' --读文本---------------------------------
    临时字节集 ＝ 取空白字节集 (长度)
    操作句柄 ＝ OpenProcess (#PROCESS_ALL_ACCESS, 0, 进程ID) ' 取得操作句柄
    bool ＝ ReadProcessMemory_字节集 (操作句柄, 内存地址, 临时字节集, 长度, 长度)
    CloseHandle (操作句柄)
    返回 (选择 (bool, 到文本 (临时字节集), “”))

.子程序 读文本1, 文本型, 公开, 读取文本型数据(返回文本 失败返回空文本)
    .参数 进程句柄, 整数型, , 进程句柄
    .参数 内存地址, 整数型
    .参数 长度, 整数型, 可空, 默认为20 欲读取的长度字节
    .局部变量 临时文本, 文本型
    .局部变量 bool, 逻辑型

    .如果真 (长度 ＝ 0)
        长度 ＝ 20
    .如果真结束
    ' --读文本---------------------------------
    临时文本 ＝ 取空白文本 (长度)
    bool ＝ ReadProcessMemory_文本型 (进程句柄, 内存地址, 临时文本, 长度, 长度)
    返回 (选择 (bool, 临时文本, “”))

.子程序 写文本, 逻辑型, 公开, 写入文本数据(成功返回真,失败返回假)
    .参数 进程ID, 整数型, , 进程ID
    .参数 内存地址, 整数型, , 内存地址
    .参数 要写入的数据, 文本型, , 写入数据
    .局部变量 操作句柄, 整数型
    .局部变量 bool, 逻辑型

    操作句柄 ＝ OpenProcess (#PROCESS_ALL_ACCESS, 0, 进程ID)
    bool ＝ WriteProcessMemory_文本型 (操作句柄, 内存地址, 要写入的数据, 取文本长度 (要写入的数据), 0)
    CloseHandle (操作句柄)
    返回 (bool)

.子程序 读整数, 整数型, 公开, 读取整数型数据(返回整数内容 失败返回0) 
    .参数 进程ID, 整数型
    .参数 内存地址, 整数型
    .局部变量 临时整数, 整数型
    .局部变量 操作句柄, 整数型
    .局部变量 bool, 逻辑型

    操作句柄 ＝ OpenProcess (#PROCESS_ALL_ACCESS, 0, 进程ID) ' 取得操作句柄
    bool ＝ ReadProcessMemory_整数型 (操作句柄, 内存地址, 临时整数, 4, 0)
    CloseHandle (操作句柄)
    返回 (选择 (bool, 临时整数, 0))

.子程序 读整数1, 整数型, 公开, 读取整数型数据(返回整数内容 失败返回0) 
    .参数 进程句柄, 整数型, , 进程句柄
    .参数 内存地址, 整数型
    .局部变量 临时整数, 整数型
    .局部变量 bool, 逻辑型

    bool ＝ ReadProcessMemory_整数型 (进程句柄, 内存地址, 临时整数, 4, 0)
    返回 (选择 (bool, 临时整数, 0))

.子程序 读短整数, 短整数型, 公开, 读取短整数型数据(返回整数内容 失败返回0)
    .参数 进程ID, 整数型
    .参数 内存地址, 整数型
    .局部变量 临时整数, 短整数型
    .局部变量 操作句柄, 整数型
    .局部变量 bool, 逻辑型

    操作句柄 ＝ OpenProcess (#PROCESS_ALL_ACCESS, 0, 进程ID) ' 取得操作句柄
    bool ＝ ReadProcessMemory_短整数型 (操作句柄, 内存地址, 临时整数, 2, 0)
    CloseHandle (操作句柄)
    返回 (选择 (bool, 临时整数, 0))

.子程序 读短整数1, 短整数型, 公开, 读取短整数型数据(返回整数内容 失败返回0)
    .参数 进程句柄, 整数型, , 进程句柄
    .参数 内存地址, 整数型
    .局部变量 临时整数, 整数型
    .局部变量 bool, 逻辑型

    bool ＝ ReadProcessMemory_短整数型 (进程句柄, 内存地址, 临时整数, 2, 0)
    返回 (选择 (bool, 临时整数, 0))

.子程序 读长整数, 长整数型, 公开, 失败返回0
    .参数 进程ID, 整数型
    .参数 内存地址, 整数型
    .局部变量 临时整数, 长整数型
    .局部变量 操作句柄, 整数型
    .局部变量 bool, 逻辑型

    操作句柄 ＝ OpenProcess (#PROCESS_ALL_ACCESS, 0, 进程ID) ' 取得操作句柄
    bool ＝ ReadProcessMemory_长整数型 (操作句柄, 内存地址, 临时整数, 8, 0)
    CloseHandle (操作句柄)
    返回 (选择 (bool, 临时整数, 0))

.子程序 读长整数1, 长整数型, 公开, 失败返回0
    .参数 进程句柄, 整数型, , 进程句柄
    .参数 内存地址, 整数型
    .局部变量 临时整数, 长整数型

    .如果真 (ReadProcessMemory_长整数型 (进程句柄, 内存地址, 临时整数, 8, 0))
        返回 (临时整数)
    .如果真结束
    返回 (0)

.子程序 写整数, 逻辑型, 公开, 写入四字节数据(成功返回真,失败返回假) 
    .参数 进程ID, 整数型, , 进程ID
    .参数 内存地址, 整数型, , 内存地址
    .参数 要写入的值, 整数型, , 写入数据
    .参数 写入类型, 整数型, 可空, 默认为1  0=短整数型 1=整数型 2=长整数型
    .局部变量 局_进程句柄, 整数型
    .局部变量 bool, 逻辑型
    .局部变量 局_长度, 整数型

    .如果 (是否为空 (写入类型))
        局_长度 ＝ 4
    .否则
        .判断开始 (写入类型 ＝ 0)
            局_长度 ＝ 2
        .判断 (写入类型 ＝ 1)
            局_长度 ＝ 4
        .判断 (写入类型 ＝ 2)
            局_长度 ＝ 8
        .默认
            
        .判断结束
        
    .如果结束
    局_进程句柄 ＝ OpenProcess (#PROCESS_ALL_ACCESS, 0, 进程ID)
    bool ＝ WriteProcessMemory_整数3 (局_进程句柄, 内存地址, 要写入的值, 局_长度, 0)
    CloseHandle (局_进程句柄)
    返回 (bool)

.子程序 读字节, 字节型, 公开, 读取字节型数据(返回整数内容 失败返回0) 
    .参数 进程ID, 整数型
    .参数 内存地址, 整数型
    .局部变量 临时整数, 字节型
    .局部变量 长度, 整数型
    .局部变量 操作句柄, 整数型
    .局部变量 bool, 逻辑型

    ' ---读整数----------------------------------
    操作句柄 ＝ OpenProcess (#PROCESS_ALL_ACCESS, 0, 进程ID) ' 取得操作句柄
    bool ＝ ReadProcessMemory_字节型 (操作句柄, 内存地址, 临时整数, 1, 0)
    CloseHandle (操作句柄)
    返回 (选择 (bool, 临时整数, 0))

.子程序 写字节, 逻辑型, 公开, 写入1字节数据(成功返回真,失败返回假) 
    .参数 进程ID, 整数型, , 进程ID
    .参数 内存地址, 整数型, , 内存地址
    .参数 要写入的数据, 字节型, , 写入数据
    .局部变量 操作句柄, 整数型
    .局部变量 bool, 逻辑型

    操作句柄 ＝ OpenProcess (#PROCESS_ALL_ACCESS, 0, 进程ID)
    bool ＝ WriteProcessMemory_写字节 (操作句柄, 内存地址, 要写入的数据, 1, 0)
    CloseHandle (操作句柄)
    返回 (bool)

.子程序 读字节集, 字节集, 公开, 读取字节集数据(返回字节集 失败返回空) 
    .参数 进程ID, 整数型, , 进程ID
    .参数 内存地址, 整数型, , 内存地址
    .参数 长度, 整数型, 可空, 可空。留空将智能读取长度
    .局部变量 变量, 字节集, , , 保存读取数据的变量
    .局部变量 操作句柄, 整数型
    .局部变量 内存块信息, 精易_内存属性
    .局部变量 bool, 逻辑型

    操作句柄 ＝ OpenProcess (#PROCESS_ALL_ACCESS, 0, 进程ID) ' 取得操作句柄
    .如果真 (长度 ＝ 0)
        VirtualQueryEx (操作句柄, 内存地址, 内存块信息, 28)
        长度 ＝ 内存块信息.区域长度 ＋ 内存块信息.区域地址 － 内存地址
    .如果真结束
    变量 ＝ 取空白字节集 (长度)
    bool ＝ ReadProcessMemory_字节集 (操作句柄, 内存地址, 变量, 长度, 0)
    CloseHandle (操作句柄)
    返回 (选择 (bool, 变量, { }))

.子程序 写字节集, 逻辑型, 公开, 写入字节集数据(成功返回真,失败返回假)
    .参数 进程ID, 整数型, , 进程ID
    .参数 内存地址, 整数型, , 内存地址
    .参数 要写入的数据, 字节集, , 写入数据
    .局部变量 操作句柄, 整数型
    .局部变量 bool, 逻辑型

    操作句柄 ＝ OpenProcess (#PROCESS_ALL_ACCESS, 0, 进程ID)
    bool ＝ WriteProcessMemory_字节集 (操作句柄, 内存地址, 要写入的数据, 取字节集长度 (要写入的数据), 0)
    CloseHandle (操作句柄)
    返回 (bool)

.子程序 读日期时间, 日期时间型, 公开, 从内存中读取日期时间型数据,失败将返回100年1月1日
    .参数 进程ID, 整数型, , 进程ID
    .参数 地址, 整数型, , 内存地址
    .局部变量 局_变量, 字节集, , , 保存读取数据的变量
    .局部变量 局_进程句柄, 整数型
    .局部变量 bool, 逻辑型
    .局部变量 局_长度, 整数型

    局_长度 ＝ 8
    局_变量 ＝ 取空白字节集 (局_长度)
    局_进程句柄 ＝ OpenProcess (#PROCESS_ALL_ACCESS, 0, 进程ID) ' 取得操作句柄
    bool ＝ ReadProcessMemory_字节集 (局_进程句柄, 地址, 局_变量, 局_长度, 0)
    CloseHandle (局_进程句柄)
    .如果真 (bool ＝ 假)
        返回 (到时间 (0))
    .如果真结束
    返回 (取字节集数据 (局_变量, #日期时间型, ))

.子程序 读子程序指针, 子程序指针, 公开, 从内存中读取子程序指针,失败返回空指针
    .参数 进程ID, 整数型, , 进程ID
    .参数 地址, 整数型, , 内存地址
    .局部变量 空指针, 子程序指针
    .局部变量 变量, 字节集, , , 保存读取数据的变量
    .局部变量 操作句柄, 整数型
    .局部变量 bool, 逻辑型
    .局部变量 长度, 整数型

    长度 ＝ 4
    变量 ＝ 取空白字节集 (长度)
    操作句柄 ＝ OpenProcess (#PROCESS_ALL_ACCESS, 0, 进程ID) ' 取得操作句柄
    bool ＝ ReadProcessMemory_字节集 (操作句柄, 地址, 变量, 长度, 0)
    CloseHandle (操作句柄)
    .如果真 (bool ＝ 假)
        返回 (空指针)
    .如果真结束
    返回 (取字节集数据 (变量, #子程序指针型, ))

.子程序 读双精度小数, 双精度小数型, 公开, 从内存中读取双精度小数型数据,失败返回0
    .参数 进程ID, 整数型, , 进程ID
    .参数 地址, 整数型, , 内存地址
    .局部变量 变量, 字节集, , , 保存读取数据的变量
    .局部变量 操作句柄, 整数型
    .局部变量 bool, 逻辑型
    .局部变量 长度, 整数型

    长度 ＝ 8
    变量 ＝ 取空白字节集 (长度)
    操作句柄 ＝ OpenProcess (#PROCESS_ALL_ACCESS, 0, 进程ID) ' 取得操作句柄
    bool ＝ ReadProcessMemory_字节集 (操作句柄, 地址, 变量, 长度, 0)
    CloseHandle (操作句柄)
    返回 (选择 (bool, 取字节集数据 (变量, #双精度小数型, ), 0))

.子程序 写代码, 逻辑型, 公开, 写内存整数型,写内存字节集。[坛友：“啄啄”提供]
    .参数 进程ID, 整数型, , 要操作的进程ID
    .参数 地址表达式, 文本型, , 比如“0A1574D+1D45+547=999”
    .局部变量 局部_写入的值, 文本型
    .局部变量 局部_一级分割, 文本型, , "0"
    .局部变量 局部_二级分割, 文本型, , "0"
    .局部变量 局部_计次, 整数型
    .局部变量 局部_读取的值, 整数型

    局部_一级分割 ＝ 分割文本 (地址表达式, “=”, )
    局部_写入的值 ＝ 局部_一级分割 [2]
    局部_二级分割 ＝ 分割文本 (局部_一级分割 [1], “+”, )
    .判断开始 (取文本左边 (局部_写入的值, 1) ＝ “{”)
        .计次循环首 (取数组成员数 (局部_二级分割), 局部_计次)
            .判断开始 (局部_计次 ＝ 取数组成员数 (局部_二级分割))
                局部_读取的值 ＝ 进制_十六到十 (局部_二级分割 [局部_计次]) ＋ 局部_读取的值
            .默认
                局部_读取的值 ＝ 到整数 (读字节集 (进程ID, 进制_十六到十 (局部_二级分割 [局部_计次]) ＋ 局部_读取的值, ))
            .判断结束
            
        .计次循环尾 ()
        返回 (写字节集 (进程ID, 局部_读取的值, 字节集_十六进制到字节集 (局部_写入的值)))
    .默认
        .计次循环首 (取数组成员数 (局部_二级分割), 局部_计次)
            .判断开始 (局部_计次 ＝ 取数组成员数 (局部_二级分割))
                局部_读取的值 ＝ 进制_十六到十 (局部_二级分割 [局部_计次]) ＋ 局部_读取的值
            .默认
                局部_读取的值 ＝ 读整数 (进程ID, 进制_十六到十 (局部_二级分割 [局部_计次]) ＋ 局部_读取的值)
            .判断结束
            
        .计次循环尾 ()
        返回 (写整数 (进程ID, 局部_读取的值, 到整数 (局部_写入的值)))
    .判断结束
    

.子程序 读代码_整数, 整数型, 公开, 读内存整数型。[坛友：“啄啄”提供]
    .参数 进程ID, 整数型, , 要操作的进程ID
    .参数 地址表达式, 文本型, , 比如“0A1574D+1D45+547”
    .局部变量 局部_计次, 整数型
    .局部变量 局部_读取的值, 整数型
    .局部变量 局部_分割, 文本型, , "0"

    局部_分割 ＝ 分割文本 (地址表达式, “+”, )
    .计次循环首 (取数组成员数 (局部_分割), 局部_计次)
        .判断开始 (局部_计次 ＝ 取数组成员数 (局部_分割))
            局部_读取的值 ＝ 进制_十六到十 (局部_分割 [局部_计次]) ＋ 局部_读取的值
        .默认
            局部_读取的值 ＝ 读整数 (进程ID, 进制_十六到十 (局部_分割 [局部_计次]) ＋ 局部_读取的值)
        .判断结束
        
    .计次循环尾 ()
    返回 (读整数 (进程ID, 局部_读取的值))

.子程序 读代码_字节集, 字节集, 公开, 读内存字节集。[坛友：“啄啄”提供]
    .参数 进程ID, 整数型, , 要操作的进程ID
    .参数 地址表达式, 文本型, , 比如“0A1574D+1D45+547”
    .局部变量 局部_计次, 整数型
    .局部变量 局部_读取的值, 整数型
    .局部变量 局部_分割, 文本型, , "0"

    局部_分割 ＝ 分割文本 (地址表达式, “+”, )
    .计次循环首 (取数组成员数 (局部_分割), 局部_计次)
        .判断开始 (局部_计次 ＝ 取数组成员数 (局部_分割))
            局部_读取的值 ＝ 进制_十六到十 (局部_分割 [局部_计次]) ＋ 局部_读取的值
        .默认
            局部_读取的值 ＝ 读整数 (进程ID, 进制_十六到十 (局部_分割 [局部_计次]) ＋ 局部_读取的值)
        .判断结束
        
    .计次循环尾 ()
    返回 (读字节集 (进程ID, 局部_读取的值, ))

.子程序 读字节集_64, 字节集, 公开, 成功返回字节集数据，如果失败返回空字节集。不同类型的内存值可用 取字节集数据(字节集，#整数型) 取得对应的内存值。
    .参数 PID, 整数型, , 进程PID
    .参数 表达式地址, 文本型, , 如：141FF33E8+170+7EC
    .参数 读入长度, 长整数型, , 4，一般内存地址都是4个字节为一个地址{xxx,xxx,xxx,xxx}
    .局部变量 分割的文本, 文本型, , "0"
    .局部变量 成员数, 整数型
    .局部变量 n, 整数型
    .局部变量 进程句柄, 整数型
    .局部变量 返回字节集, 字节集
    .局部变量 指针, 长整数型
    .局部变量 地址, 长整数型

    ' 该命令收录自：https://bbs.125.la/thread-14405734-1-1.html
    分割的文本 ＝ 分割文本 (表达式地址, “+”, )
    成员数 ＝ 取数组成员数 (分割的文本)
    .计次循环首 (成员数, n)
        .判断开始 (n ＝ 成员数)
            进程句柄 ＝ OpenProcess (#PROCESS_ALL_ACCESS, 0, PID)
            返回字节集 ＝ 取空白字节集 (读入长度)
            地址 ＝ 进制_十六到十 (分割的文本 [n])
            指针 ＝ 指针 ＋ 地址
            ZwWow64ReadVirtualMemory64 (进程句柄, 指针, 返回字节集, 读入长度, 0)
            CloseHandle (进程句柄)
            返回 (返回字节集)
        .默认
            进程句柄 ＝ OpenProcess (#PROCESS_ALL_ACCESS, 0, PID) ' 打开进程，返回进程句柄，每次打开都回返回不同句柄
            返回字节集 ＝ 取空白字节集 (读入长度) ' 得先初始化，不然读内存传参不过来
            地址 ＝ 进制_十六到十 (分割的文本 [n])
            指针 ＝ 指针 ＋ 地址
            ZwWow64ReadVirtualMemory64 (进程句柄, 指针, 返回字节集, 读入长度, 0)
            CloseHandle (进程句柄) ' 读完一次内存，及时关闭进程句柄，防止对象没关闭照成程序崩溃
            指针 ＝ 取字节集数据 (返回字节集, #长整数型, ) ' 有偏移的内存地址，中间过程都是返回地址的，所以要取出字节集数据，得到偏移后的指针
            .如果真 (指针 ＝ 0) ' 通常指针为0就是取不出来了
                ' 调试输出 (分割的文本 [n], 指针, n, “此处失败”)
                返回 ({ })
            .如果真结束
            
        .判断结束
        
    .计次循环尾 ()
    返回 ({ })

.子程序 写字节集_64, 整数型, 公开, 写内存字节集，失败返回-1，成功非-1
    .参数 PID, 整数型, , 进程PID
    .参数 表达式地址, 文本型, , 如：141FF33E8+170+7EC
    .参数 写入长度, 长整数型, , 4，一般内存地址都是4个字节为一个地址{xxx,xxx,xxx,xxx}
    .参数 写入数据, 字节集, , 用法：如果写入整数型数据→到字节集(123) 文本型数据→到字节集（“123”）。
    .局部变量 分割的文本, 文本型, , "0"
    .局部变量 成员数, 整数型
    .局部变量 n, 整数型
    .局部变量 进程句柄, 整数型
    .局部变量 返回字节集, 字节集
    .局部变量 指针, 长整数型
    .局部变量 地址, 长整数型
    .局部变量 结果, 整数型

    分割的文本 ＝ 分割文本 (表达式地址, “+”, )
    成员数 ＝ 取数组成员数 (分割的文本)
    .计次循环首 (成员数, n)
        .判断开始 (n ＝ 成员数)
            进程句柄 ＝ OpenProcess (#PROCESS_ALL_ACCESS, 0, PID)
            返回字节集 ＝ 取空白字节集 (写入长度)
            地址 ＝ 进制_十六到十 (分割的文本 [n])
            指针 ＝ 指针 ＋ 地址
            结果 ＝ ZwWow64WriteVirtualMemory64 (进程句柄, 指针, 写入数据, 写入长度, 0)
            CloseHandle (进程句柄)
            返回 (结果)
        .默认
            进程句柄 ＝ OpenProcess (#PROCESS_ALL_ACCESS, 0, PID) ' 打开进程，返回进程句柄，每次打开都回返回不同句柄
            返回字节集 ＝ 取空白字节集 (写入长度) ' 得先初始化，不然读内存传参不过来
            地址 ＝ 进制_十六到十 (分割的文本 [n])
            指针 ＝ 指针 ＋ 地址
            ZwWow64ReadVirtualMemory64 (进程句柄, 指针, 返回字节集, 写入长度, 0)
            CloseHandle (进程句柄) ' 读完一次内存，及时关闭进程句柄，防止对象没关闭照成程序崩溃
            指针 ＝ 取字节集数据 (返回字节集, #长整数型, ) ' 有偏移的内存地址，中间过程都是返回地址的，所以要取出字节集数据，得到偏移后的指针
            .如果真 (指针 ＝ 0) ' 通常指针为0就是取不出来了
                ' 调试输出 (分割的文本 [n], 指针, n, “此处失败”)
                返回 (-1)
            .如果真结束
            
        .判断结束
        
    .计次循环尾 ()
    返回 (-1)

.版本 2

.程序集 类_屏蔽菜单, , 公开
.程序集变量 OldhWnd, 整数型
.程序集变量 OldProc, 整数型
.程序集变量 address, 整数型
.程序集变量 Callback, 整数型

.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
    

.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
    销毁 ()
    Callback ＝ 0

.子程序 初始化, , 公开
    .参数 窗口句柄, 整数型
    .参数 回调子程序, 整数型, 可空, 到整数 (&xxx)

    OldhWnd ＝ 窗口句柄
    Callback ＝ 回调子程序
    address ＝ 类_取内部方法地址 (5)
    OldProc ＝ SetWindowLongA (OldhWnd, #GWL_WNDPROC, address)

.子程序 销毁, , 公开
    .如果真 (OldProc ≠ 0)
        SetWindowLongA (OldhWnd, #GWL_WNDPROC, OldProc)
        类_释放内部方法地址 (address)
    .如果真结束
    

.子程序 NewProc, 整数型
    .参数 hWnd, 整数型
    .参数 message, 整数型
    .参数 wParam, 整数型
    .参数 lParam, 整数型

    .判断开始 (message ＝ #WM_CONTEXTMENU)
        .如果真 (Callback ≠ 0)
            调用子程序_ (Callback, , , , , , , , , , , , , , , )
        .如果真结束
        返回 (0)
    .判断 (message ＝ #WM_NCLBUTTONDOWN)
        .如果真 (wParam ＝ 3) ' #HTSYSMENU
            .如果真 (Callback ≠ 0)
                调用子程序_ (Callback, , , , , , , , , , , , , , , )
            .如果真结束
            返回 (0)
        .如果真结束
        
    .默认
        
    .判断结束
    返回 (CallWindowProcA (OldProc, hWnd, message, wParam, lParam))

.版本 2

.程序集 类_数据报
.程序集变量 数据报句柄, 整数型

.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
    .局部变量 StartupData, 套接字信息

    ' StartupData.版本 ＝ 1
    ' StartupData.高版本 ＝ 2
    .如果真 (WSAStartup (2, StartupData) ≠ 0)
        输出调试文本 (“初始化失败”)
    .如果真结束
    

.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
    关闭 ()
    WSACleanup ()

.子程序 配置, 逻辑型, 公开, 配置网络数据报,成功返回真，失败返回假。
    .参数 端口, 整数型, , 初始值为“0”。数据报监视的端口。
    .局部变量 地址信息, 套接字地址

    .如果真 (数据报句柄 ＞ 0)
        关闭 ()
    .如果真结束
    数据报句柄 ＝ socket (#PF_INET, #SOCK_DGRAM, #IPPROTO_UDP)
    .如果真 (数据报句柄 ＝ -1)
        返回 (假)
    .如果真结束
    地址信息.端口 ＝ htons (端口)
    地址信息.常量 ＝ #PF_INET
    地址信息.地址 ＝ inet_addr (“0.0.0.0”)
    .如果真 (地址信息.地址 ＝ -1 或 地址信息.端口 ＝ -1)
        关闭 ()
        返回 (假)
    .如果真结束
    .如果真 (bind (数据报句柄, 地址信息, 16) ＝ -1)
        关闭 ()
        返回 (假)
    .如果真结束
    返回 (真)

.子程序 关闭, 逻辑型, 公开,  关闭网络数据报，成功返回真，失败返回假。
    .如果真 (closesocket (数据报句柄) ＝ -1)
        返回 (假)
    .如果真结束
    数据报句柄 ＝ 0
    返回 (真)

.子程序 接收, 字节集, 公开, 接收来自网络服务器的数据,出错返回空字节集,每次接受的最大长度为20480个字节。
    .参数 对方信息, 地址信息, 参考, 提供参数数据时只能提供变量。获得对方的IP及端口信息。
    .局部变量 临时变量, 字节集
    .局部变量 实际接收字节数, 整数型
    .局部变量 地址信息2, 套接字地址
    .局部变量 信息长度, 整数型

    临时变量 ＝ 取空白字节集 (20480)
    实际接收字节数 ＝ recvfrom (数据报句柄, 临时变量, 20480, 0, 地址信息2, 16)
    .如果真 (实际接收字节数 ＜ 1)
        返回 ({ })
    .如果真结束
    对方信息.地址 ＝ 指针到文本 (inet_ntoa (地址信息2.地址))
    对方信息.端口 ＝ ntohs (地址信息2.端口)
    返回 (取字节集左边 (临时变量, 实际接收字节数))

.子程序 发送, 逻辑型, 公开, 向指定网络服务器发送数据。
    .参数 对方信息, 地址信息, , 接收方IP及端口信息。
    .参数 数据, 字节集, , 准备发送的数据。
    .局部变量 实际发送字节数, 整数型
    .局部变量 地址信息2, 套接字地址

    地址信息2.端口 ＝ htons (对方信息.端口)
    地址信息2.地址 ＝ inet_addr (对方信息.地址)
    .如果真 (地址信息2.地址 ＝ -1 或 地址信息2.端口 ＝ -1)
        返回 (假)
    .如果真结束
    地址信息2.常量 ＝ #PF_INET
    实际发送字节数 ＝ sendto (数据报句柄, 数据, 取字节集长度 (数据), 0, 地址信息2, 16)
    .如果真 (实际发送字节数 ＝ -1)
        返回 (假)
    .如果真结束
    返回 (真)

.子程序 取本机端口, 整数型, 公开, 取本机对外端口,成功返回本机端口，失败返回-1。
    .局部变量 本地地址信息, 套接字地址

    GetsockName (数据报句柄, 本地地址信息, 16)
    返回 (ntohs (本地地址信息.端口))
    

.版本 2

.程序集 类_钩子, , 公开
.程序集变量 Keyboard, HOOKPROC
.程序集变量 Mouse, HOOKPROC

.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
    

.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
    

.子程序 LowLevelKeyboardProc, 整数型, , WH_KEYBOARD_LL
    .参数 nCode, 整数型, , 钩子过程用来确定如何处理消息的代码。
    .参数 wParam, 整数型, , 键盘消息的标识符。
    .参数 lParam, 整数型, , 指向KBDLLHOOKSTRUCT结构的指针。
    .局部变量 kblp, KBDLLHOOKSTRUCT

    .如果真 (nCode ＝ #HC_ACTION 且 lParam ≠ #NULL)
        .如果真 (wParam ＝ #WM_KEYDOWN 或 wParam ＝ #WM_KEYUP 或 wParam ＝ #WM_CHAR)
            RtlMoveMemory_KBDLLHOOKSTRUCT (kblp, lParam, 20)
            .如果真 (程序_执行整数子程序 (Keyboard.lpfn, wParam, kblp.vkCode, 0) ＝ 1)
                返回 (1) ' 拦截
            .如果真结束
            
        .如果真结束
        
    .如果真结束
    返回 (CallNextHookEx (Keyboard.HHOOK, nCode, wParam, lParam))

.子程序 KeyboardProc, 整数型, , WH_KEYBOARD
    .参数 code, 整数型, , 钩子过程用来确定如何处理消息的代码。
    .参数 wParam, 整数型, , 生成击键消息的键的虚拟键代码。
    .参数 lParam, 整数型, , 重复计数、扫描代码、扩展键标志、上下文代码、先前键状态标志和转换状态标志。
    .局部变量 isKeyUp, 逻辑型

    .如果真 (code ＝ #HC_ACTION 且 lParam ≠ #NULL)
        取键盘消息lParam (lParam, , , , , , isKeyUp)
        .如果真 (程序_执行整数子程序 (Keyboard.lpfn, 选择 (isKeyUp, #WM_KEYUP, #WM_KEYDOWN), wParam, 0) ＝ 1)
            返回 (1) ' 拦截
        .如果真结束
        
    .如果真结束
    返回 (CallNextHookEx (Keyboard.HHOOK, code, wParam, lParam))

.子程序 LowLevelMouseProc, 整数型, , WH_MOUSE_LL
    .参数 nCode, 整数型
    .参数 wParam, 整数型
    .参数 lParam, 整数型
    .局部变量 mslp, MSLLHOOKSTRUCT
    .局部变量 KeyCode, 整数型
    .局部变量 KeyStatus, 整数型
    .局部变量 dwData, 整数型

    .如果真 (nCode ＝ #HC_ACTION 且 lParam ≠ #NULL)
        RtlMoveMemory_MSLLHOOKSTRUCT (mslp, lParam, 24)
        .判断开始 (wParam ＝ #WM_LBUTTONDOWN)
            KeyCode ＝ #KEYCODE_LBUTTON
            KeyStatus ＝ #KEYSTATUS_DOWN
        .判断 (wParam ＝ #WM_LBUTTONUP)
            KeyCode ＝ #KEYCODE_LBUTTON
            KeyStatus ＝ #KEYSTATUS_UP
        .判断 (wParam ＝ #WM_LBUTTONDBLCLK)
            KeyCode ＝ #KEYCODE_LBUTTON
            KeyStatus ＝ #KEYSTATUS_DBLCLK
        .判断 (wParam ＝ #WM_RBUTTONDOWN)
            KeyCode ＝ #KEYCODE_RBUTTON
            KeyStatus ＝ #KEYSTATUS_DOWN
        .判断 (wParam ＝ #WM_RBUTTONUP)
            KeyCode ＝ #KEYCODE_RBUTTON
            KeyStatus ＝ #KEYSTATUS_UP
        .判断 (wParam ＝ #WM_RBUTTONDBLCLK)
            KeyCode ＝ #KEYCODE_RBUTTON
            KeyStatus ＝ #KEYSTATUS_DBLCLK
        .判断 (wParam ＝ #WM_MBUTTONDOWN)
            KeyCode ＝ #KEYCODE_MBUTTON
            KeyStatus ＝ #KEYSTATUS_DOWN
        .判断 (wParam ＝ #WM_MBUTTONUP)
            KeyCode ＝ #KEYCODE_MBUTTON
            KeyStatus ＝ #KEYSTATUS_UP
        .判断 (wParam ＝ #WM_MBUTTONDBLCLK)
            KeyCode ＝ #KEYCODE_MBUTTON
            KeyStatus ＝ #KEYSTATUS_DBLCLK
        .判断 (wParam ＝ #WM_MOUSEWHEEL)
            dwData ＝ HIWORD (mslp.mouseData)
            .如果 (dwData ＝ #WHEEL_DELTA)
                KeyCode ＝ #KEYCODE_WHEEL
                KeyStatus ＝ #KEYSTATUS_WHEELUP
            .否则
                KeyCode ＝ #KEYCODE_WHEEL
                KeyStatus ＝ #KEYSTATUS_WHEELDOWN
            .如果结束
            
        .判断 (wParam ＝ #WM_XBUTTONDOWN)
            dwData ＝ HIWORD (mslp.mouseData)
            .判断开始 (dwData ＝ #XBUTTON2)
                KeyCode ＝ #KEYCODE_SIDEKEYUP
                KeyStatus ＝ #KEYSTATUS_DOWN
            .判断 (dwData ＝ #XBUTTON1)
                KeyCode ＝ #KEYCODE_SIDEKEYDOWN
                KeyStatus ＝ #KEYSTATUS_DOWN
            .默认
                
            .判断结束
            
        .判断 (wParam ＝ #WM_XBUTTONUP)
            dwData ＝ HIWORD (mslp.mouseData)
            .判断开始 (dwData ＝ #XBUTTON2)
                KeyCode ＝ #KEYCODE_SIDEKEYUP
                KeyStatus ＝ #KEYSTATUS_UP
            .判断 (dwData ＝ #XBUTTON1)
                KeyCode ＝ #KEYCODE_SIDEKEYDOWN
                KeyStatus ＝ #KEYSTATUS_UP
            .默认
                
            .判断结束
            
        .默认
            
        .判断结束
        
        .如果真 (程序_执行整数子程序 (Mouse.lpfn, KeyCode, KeyStatus, 0) ＝ 1)
            返回 (1) ' 拦截
        .如果真结束
        
    .如果真结束
    返回 (CallNextHookEx (Mouse.HHOOK, nCode, wParam, lParam))

.子程序 MouseProc, 整数型, , WH_MOUSE
    .参数 nCode, 整数型
    .参数 wParam, 整数型
    .参数 lParam, 整数型
    .局部变量 molp, MOUSEHOOKSTRUCT
    .局部变量 KeyCode, 整数型
    .局部变量 KeyStatus, 整数型
    .局部变量 dwData, 整数型

    .如果真 (nCode ≥ #HC_ACTION 且 lParam ≠ #NULL)
        RtlMoveMemory_MOUSEHOOKSTRUCT (molp, lParam, 20)
        .判断开始 (wParam ＝ #WM_LBUTTONDOWN)
            KeyCode ＝ #KEYCODE_LBUTTON
            KeyStatus ＝ #KEYSTATUS_DOWN
        .判断 (wParam ＝ #WM_LBUTTONUP)
            KeyCode ＝ #KEYCODE_LBUTTON
            KeyStatus ＝ #KEYSTATUS_UP
        .判断 (wParam ＝ #WM_LBUTTONDBLCLK)
            KeyCode ＝ #KEYCODE_LBUTTON
            KeyStatus ＝ #KEYSTATUS_DBLCLK
        .判断 (wParam ＝ #WM_RBUTTONDOWN)
            KeyCode ＝ #KEYCODE_RBUTTON
            KeyStatus ＝ #KEYSTATUS_DOWN
        .判断 (wParam ＝ #WM_RBUTTONUP)
            KeyCode ＝ #KEYCODE_RBUTTON
            KeyStatus ＝ #KEYSTATUS_UP
        .判断 (wParam ＝ #WM_RBUTTONDBLCLK)
            KeyCode ＝ #KEYCODE_RBUTTON
            KeyStatus ＝ #KEYSTATUS_DBLCLK
        .判断 (wParam ＝ #WM_MBUTTONDOWN)
            KeyCode ＝ #KEYCODE_MBUTTON
            KeyStatus ＝ #KEYSTATUS_DOWN
        .判断 (wParam ＝ #WM_MBUTTONUP)
            KeyCode ＝ #KEYCODE_MBUTTON
            KeyStatus ＝ #KEYSTATUS_UP
        .判断 (wParam ＝ #WM_MBUTTONDBLCLK)
            KeyCode ＝ #KEYCODE_MBUTTON
            KeyStatus ＝ #KEYSTATUS_DBLCLK
        .默认
            
        .判断结束
        
        .如果真 (程序_执行整数子程序 (Mouse.lpfn, KeyCode, KeyStatus, 0) ＝ 1)
            返回 (1) ' 拦截
        .如果真结束
        
    .如果真结束
    返回 (CallNextHookEx (Mouse.HHOOK, nCode, wParam, lParam))

.子程序 安装钩子_键盘, 整数型, 公开, 成功安装返回钩子句柄，失败返回0
    .参数 窗口句柄, 整数型
    .参数 钩子回调函数, 子程序指针, 可空, 参数一[按键类型],256=按下，257=放开,258=单击,参数二[键代码]
    .参数 是否全局, 逻辑型, 可空, 可空，默认为全局。注意，为假 局部时 无单击消息
    .局部变量 lpfunc, 子程序指针

    .如果真 (是否为空 (是否全局))
        是否全局 ＝ 真
    .如果真结束
    
    .如果 (是否全局)
        Keyboard.lpAddress ＝ 类_取内部方法地址 (3) ' LowLevelKeyboardProc
        lpfunc ＝ lstrcpynA_指针 (Keyboard.lpAddress, Keyboard.lpAddress, 0)
        Keyboard.HHOOK ＝ SetWindowsHookExA (#WH_KEYBOARD_LL, lpfunc, GetModuleHandleA1 (#NULL), 0)
    .否则
        Keyboard.lpAddress ＝ 类_取内部方法地址 (4) ' KeyboardProc
        lpfunc ＝ lstrcpynA_指针 (Keyboard.lpAddress, Keyboard.lpAddress, 0)
        Keyboard.HHOOK ＝ SetWindowsHookExA (#WH_KEYBOARD, lpfunc, GetModuleHandleA1 (#NULL), GetWindowThreadProcessId (窗口句柄, 0))
    .如果结束
    Keyboard.lpfn ＝ 钩子回调函数
    返回 (Keyboard.HHOOK)

.子程序 卸载, 逻辑型, 公开, 可以卸载所有使用“钩子_安装xx”命令安装的钩子
    .参数 钩子句柄, 整数型, 可空, 通过“钩子_安装xx”返回的钩子句柄
    .局部变量 bRet, 逻辑型

    .如果真 (钩子句柄 ≠ 0)
        返回 (UnhookWindowsHookEx (钩子句柄))
    .如果真结束
    
    .如果真 (Keyboard.HHOOK ≠ 0)
        bRet ＝ UnhookWindowsHookEx (Keyboard.HHOOK)
        Keyboard.HHOOK ＝ 0
    .如果真结束
    
    .如果真 (Keyboard.lpAddress ≠ 0)
        类_释放内部方法地址 (Keyboard.lpAddress)
        Keyboard.lpAddress ＝ 0
    .如果真结束
    
    .如果真 (Mouse.HHOOK ≠ 0)
        bRet ＝ UnhookWindowsHookEx (Mouse.HHOOK)
        Mouse.HHOOK ＝ 0
    .如果真结束
    
    .如果真 (Mouse.lpAddress ≠ 0)
        类_释放内部方法地址 (Mouse.lpAddress)
        Mouse.lpAddress ＝ 0
    .如果真结束
    
    返回 (bRet)

.子程序 安装钩子_鼠标, 整数型, 公开, 成功安装返回钩子句柄，失败返回0
    .参数 窗口句柄, 整数型
    .参数 钩子回调函数, 子程序指针, 可空, 参数一[键代码],1=左键 2=右键 3=中键 4=滚轮 5=侧键上 6=侧键下,参数二[按键类型] 1=按下 2=弹起 3=双击 4=滚轮往上 5=滚轮往下
    .参数 是否全局, 逻辑型, 可空, 可空，默认为全局。为 假 局部时无滚轮上下消息及侧键消息
    .局部变量 lpfunc, 子程序指针

    .如果真 (是否为空 (是否全局))
        是否全局 ＝ 真
    .如果真结束
    
    .如果 (是否全局)
        Mouse.lpAddress ＝ 类_取内部方法地址 (5) ' LowLevelMouseProc
        lpfunc ＝ lstrcpynA_指针 (Mouse.lpAddress, Mouse.lpAddress, 0)
        Mouse.HHOOK ＝ SetWindowsHookExA (#WH_MOUSE_LL, lpfunc, GetModuleHandleA1 (#NULL), 0)
    .否则
        Mouse.lpAddress ＝ 类_取内部方法地址 (6) ' MouseProc
        lpfunc ＝ lstrcpynA_指针 (Mouse.lpAddress, Mouse.lpAddress, 0)
        Mouse.HHOOK ＝ SetWindowsHookExA (#WH_MOUSE, lpfunc, GetModuleHandleA1 (#NULL), GetWindowThreadProcessId (窗口句柄, 0))
    .如果结束
    Mouse.lpfn ＝ 钩子回调函数
    返回 (Mouse.HHOOK)

.版本 2

.程序集 集_IPropertyStore
.子程序 媒体属性_取标题, 文本型, 公开
    .参数 文件路径, 文本型

    返回 (编码_Unicode到Ansi (媒体属性_取标题W (编码_Ansi到Unicode (文件路径, ))))

.子程序 媒体属性_取标题W, 字节集, 公开
    .参数 文件路径, 字节集
    .局部变量 szPropKey, 字节集
    .局部变量 pv, 字节集
    .局部变量 vt, 短整数型
    .局部变量 pbstrVal, 整数型
    .局部变量 nMaxCount, 整数型

    szPropKey ＝ #FMTID_SummaryInformation ＋ 到字节集 (2)
    pv ＝ GetIPropertyStore (文件路径, szPropKey)
    vt ＝ 取字节集数据 (pv, #短整数型, )
    .如果真 (vt ＝ 31) ' VT_LPWSTR
        pbstrVal ＝ 取字节集数据 (pv, #整数型, 9)
        .如果真 (pbstrVal ≠ #NULL)
            nMaxCount ＝ lstrlenW (pbstrVal)
            .如果真 (nMaxCount ＞ 0)
                nMaxCount ＝ nMaxCount × 2 ＋ 2
            .如果真结束
            返回 (指针到字节集 (pbstrVal, nMaxCount))
        .如果真结束
        
    .如果真结束
    返回 ({ })

.子程序 媒体属性_置标题, 逻辑型, 公开
    .参数 文件路径, 文本型
    .参数 标题, 文本型

    返回 (媒体属性_置标题W (编码_Ansi到Unicode (文件路径, ), 编码_Ansi到Unicode (标题, )))

.子程序 媒体属性_置标题W, 逻辑型, 公开
    .参数 文件路径, 字节集
    .参数 标题, 字节集
    .局部变量 szPropKey, 字节集
    .局部变量 pbVal, 字节集
    .局部变量 pv, 整数型

    szPropKey ＝ #FMTID_SummaryInformation ＋ 到字节集 (2)
    pbVal ＝ 取空白字节集 (16)
    pv ＝ 取指针字节集_ (pbVal)
    __set_short (pv, 0, 31) ' VT_LPWSTR
    __set (pv, 8, 取指针_字节集型 (标题))
    返回 (SetIPropertyStore (文件路径, szPropKey, pbVal))

.子程序 媒体属性_取副标题, 文本型, 公开
    .参数 文件路径, 文本型

    返回 (编码_Unicode到Ansi (媒体属性_取副标题W (编码_Ansi到Unicode (文件路径, ))))

.子程序 媒体属性_取副标题W, 字节集, 公开
    .参数 文件路径, 字节集
    .局部变量 szPropKey, 字节集
    .局部变量 pv, 字节集
    .局部变量 vt, 短整数型
    .局部变量 pbstrVal, 整数型
    .局部变量 nMaxCount, 整数型

    szPropKey ＝ #FMTID_MUSIC ＋ 到字节集 (38)
    pv ＝ GetIPropertyStore (文件路径, szPropKey)
    vt ＝ 取字节集数据 (pv, #短整数型, )
    .如果真 (vt ＝ 31) ' VT_LPWSTR
        pbstrVal ＝ 取字节集数据 (pv, #整数型, 9)
        .如果真 (pbstrVal ≠ #NULL)
            nMaxCount ＝ lstrlenW (pbstrVal)
            .如果真 (nMaxCount ＞ 0)
                nMaxCount ＝ nMaxCount × 2 ＋ 2
            .如果真结束
            返回 (指针到字节集 (pbstrVal, nMaxCount))
        .如果真结束
        
    .如果真结束
    返回 ({ })

.子程序 媒体属性_置副标题, 逻辑型, 公开
    .参数 文件路径, 文本型
    .参数 副标题, 文本型

    返回 (媒体属性_置副标题W (编码_Ansi到Unicode (文件路径, ), 编码_Ansi到Unicode (副标题, )))

.子程序 媒体属性_置副标题W, 逻辑型, 公开
    .参数 文件路径, 字节集
    .参数 副标题, 字节集
    .局部变量 szPropKey, 字节集
    .局部变量 pbVal, 字节集
    .局部变量 pv, 整数型

    szPropKey ＝ #FMTID_MUSIC ＋ 到字节集 (38)
    pbVal ＝ 取空白字节集 (16)
    pv ＝ 取指针字节集_ (pbVal)
    __set_short (pv, 0, 31) ' VT_LPWSTR
    __set (pv, 8, 取指针_字节集型 (副标题))
    返回 (SetIPropertyStore (文件路径, szPropKey, pbVal))

.子程序 媒体属性_取分级, 整数型, 公开
    .参数 文件路径, 文本型

    返回 (媒体属性_取分级W (编码_Ansi到Unicode (文件路径, )))

.子程序 媒体属性_取分级W, 整数型, 公开
    .参数 文件路径, 字节集
    .局部变量 szPropKey, 字节集
    .局部变量 pv, 字节集
    .局部变量 vt, 短整数型
    .局部变量 nMaxValue, 整数型

    szPropKey ＝ #PSGUID_MEDIAFILESUMMARYINFORMATION ＋ 到字节集 (9)
    pv ＝ GetIPropertyStore (文件路径, szPropKey)
    vt ＝ 取字节集数据 (pv, #短整数型, )
    .如果真 (vt ＝ 19) ' VT_UI4
        nMaxValue ＝ 取字节集数据 (pv, #整数型, 9)
        .判断开始 (nMaxValue ＝ 1)
            返回 (1)
        .判断 (nMaxValue ＝ 25)
            返回 (2)
        .判断 (nMaxValue ＝ 50)
            返回 (3)
        .判断 (nMaxValue ＝ 75)
            返回 (4)
        .判断 (nMaxValue ＝ 99)
            返回 (5)
        .默认
            
        .判断结束
        
    .如果真结束
    返回 (0)

.子程序 媒体属性_置分级, 逻辑型, 公开
    .参数 文件路径, 文本型
    .参数 星级, 整数型

    返回 (媒体属性_置分级W (编码_Ansi到Unicode (文件路径, ), 星级))

.子程序 媒体属性_置分级W, 逻辑型, 公开
    .参数 文件路径, 字节集
    .参数 星级, 整数型
    .局部变量 szPropKey, 字节集
    .局部变量 pbVal, 字节集
    .局部变量 pv, 整数型

    szPropKey ＝ #PSGUID_MEDIAFILESUMMARYINFORMATION ＋ 到字节集 (9)
    pbVal ＝ 取空白字节集 (16)
    pv ＝ 取指针字节集_ (pbVal)
    __set_short (pv, 0, 19) ' VT_UI4
    .判断开始 (星级 ＝ 1)
        __set (pv, 8, 1)
    .判断 (星级 ＝ 2)
        __set (pv, 8, 25)
    .判断 (星级 ＝ 3)
        __set (pv, 8, 50)
    .判断 (星级 ＝ 4)
        __set (pv, 8, 75)
    .判断 (星级 ＝ 5)
        __set (pv, 8, 99)
    .默认
        
    .判断结束
    返回 (SetIPropertyStore (文件路径, szPropKey, pbVal))

.子程序 媒体属性_取备注, 文本型, 公开
    .参数 文件路径, 文本型

    返回 (编码_Unicode到Ansi (媒体属性_取备注W (编码_Ansi到Unicode (文件路径, ))))

.子程序 媒体属性_取备注W, 字节集, 公开
    .参数 文件路径, 字节集
    .局部变量 szPropKey, 字节集
    .局部变量 pv, 字节集
    .局部变量 vt, 短整数型
    .局部变量 pbstrVal, 整数型
    .局部变量 nMaxCount, 整数型

    szPropKey ＝ #FMTID_SummaryInformation ＋ 到字节集 (6)
    pv ＝ GetIPropertyStore (文件路径, szPropKey)
    vt ＝ 取字节集数据 (pv, #短整数型, )
    .如果真 (vt ＝ 31) ' VT_LPWSTR
        pbstrVal ＝ 取字节集数据 (pv, #整数型, 9)
        .如果真 (pbstrVal ≠ #NULL)
            nMaxCount ＝ lstrlenW (pbstrVal)
            .如果真 (nMaxCount ＞ 0)
                nMaxCount ＝ nMaxCount × 2 ＋ 2
            .如果真结束
            返回 (指针到字节集 (pbstrVal, nMaxCount))
        .如果真结束
        
    .如果真结束
    返回 ({ })

.子程序 媒体属性_置备注, 逻辑型, 公开
    .参数 文件路径, 文本型
    .参数 备注, 文本型

    返回 (媒体属性_置备注W (编码_Ansi到Unicode (文件路径, ), 编码_Ansi到Unicode (备注, )))

.子程序 媒体属性_置备注W, 逻辑型, 公开
    .参数 文件路径, 字节集
    .参数 备注, 字节集
    .局部变量 szPropKey, 字节集
    .局部变量 pbVal, 字节集
    .局部变量 pv, 整数型

    szPropKey ＝ #FMTID_SummaryInformation ＋ 到字节集 (6)
    pbVal ＝ 取空白字节集 (16)
    pv ＝ 取指针字节集_ (pbVal)
    __set_short (pv, 0, 31) ' VT_LPWSTR
    __set (pv, 8, 取指针_字节集型 (备注))
    返回 (SetIPropertyStore (文件路径, szPropKey, pbVal))

.子程序 媒体属性_取帧宽度, 整数型, 公开
    .参数 文件路径, 文本型

    返回 (媒体属性_取帧宽度W (编码_Ansi到Unicode (文件路径, )))

.子程序 媒体属性_取帧宽度W, 整数型, 公开
    .参数 文件路径, 字节集
    .局部变量 szPropKey, 字节集
    .局部变量 pv, 字节集
    .局部变量 vt, 短整数型
    .局部变量 nMaxValue, 整数型

    szPropKey ＝ #FMTID_VideoSummaryInformation ＋ 到字节集 (3)
    pv ＝ GetIPropertyStore (文件路径, szPropKey)
    vt ＝ 取字节集数据 (pv, #短整数型, )
    .如果真 (vt ＝ 19) ' VT_UI4
        nMaxValue ＝ 取字节集数据 (pv, #整数型, 9)
        返回 (nMaxValue)
    .如果真结束
    返回 (0)

.子程序 媒体属性_取帧高度, 整数型, 公开
    .参数 文件路径, 文本型

    返回 (媒体属性_取帧高度W (编码_Ansi到Unicode (文件路径, )))

.子程序 媒体属性_取帧高度W, 整数型, 公开
    .参数 文件路径, 字节集
    .局部变量 szPropKey, 字节集
    .局部变量 pv, 字节集
    .局部变量 vt, 短整数型
    .局部变量 nMaxValue, 整数型

    szPropKey ＝ #FMTID_VideoSummaryInformation ＋ 到字节集 (4)
    pv ＝ GetIPropertyStore (文件路径, szPropKey)
    vt ＝ 取字节集数据 (pv, #短整数型, )
    .如果真 (vt ＝ 19) ' VT_UI4
        nMaxValue ＝ 取字节集数据 (pv, #整数型, 9)
        返回 (nMaxValue)
    .如果真结束
    返回 (0)

.子程序 媒体属性_取创建媒体日期, 日期时间型, 公开
    .参数 文件路径, 文本型

    返回 (媒体属性_取创建媒体日期W (编码_Ansi到Unicode (文件路径, )))

.子程序 媒体属性_取创建媒体日期W, 日期时间型, 公开
    .参数 文件路径, 字节集
    .局部变量 szPropKey, 字节集
    .局部变量 pv, 字节集
    .局部变量 vt, 短整数型
    .局部变量 FileTime, FILETIME

    szPropKey ＝ { 13, 100, 75, 46, 25, 80, 216, 70, 136, 129, 85, 65, 76, 197, 202, 160, 100, 0, 0, 0 }
    pv ＝ GetIPropertyStore (文件路径, szPropKey)
    vt ＝ 取字节集数据 (pv, #短整数型, )
    .如果真 (vt ＝ 64) ' VT_FILETIME
        FileTime.dwLowDateTime ＝ 取字节集数据 (pv, #整数型, 9)
        FileTime.dwHighDateTime ＝ 取字节集数据 (pv, #整数型, 13)
        返回 (FileTimeToVariantTime (FileTime))
    .如果真结束
    返回 ([1899年12月30日])

.子程序 媒体属性_置创建媒体日期, 逻辑型, 公开
    .参数 文件路径, 文本型
    .参数 创建媒体日期, 日期时间型

    返回 (媒体属性_置创建媒体日期W (编码_Ansi到Unicode (文件路径, ), 创建媒体日期))

.子程序 媒体属性_置创建媒体日期W, 逻辑型, 公开
    .参数 文件路径, 字节集
    .参数 创建媒体日期, 日期时间型
    .局部变量 szPropKey, 字节集
    .局部变量 pbVal, 字节集
    .局部变量 pv, 整数型
    .局部变量 FileTime, FILETIME

    szPropKey ＝ { 13, 100, 75, 46, 25, 80, 216, 70, 136, 129, 85, 65, 76, 197, 202, 160, 100, 0, 0, 0 }
    pbVal ＝ 取空白字节集 (16)
    pv ＝ 取指针字节集_ (pbVal)
    __set_short (pv, 0, 64) ' VT_FILETIME
    FileTime ＝ VariantTimeToFileTime (创建媒体日期)
    __set (pv, 8, FileTime.dwLowDateTime)
    __set (pv, 12, FileTime.dwHighDateTime)
    返回 (SetIPropertyStore (文件路径, szPropKey, pbVal))

.子程序 媒体属性_取编码人员, 文本型, 公开
    .参数 文件路径, 文本型

    返回 (编码_Unicode到Ansi (媒体属性_取编码人员W (编码_Ansi到Unicode (文件路径, ))))

.子程序 媒体属性_取编码人员W, 字节集, 公开
    .参数 文件路径, 字节集
    .局部变量 szPropKey, 字节集
    .局部变量 pv, 字节集
    .局部变量 vt, 短整数型
    .局部变量 pbstrVal, 整数型
    .局部变量 nMaxCount, 整数型

    szPropKey ＝ #PSGUID_MEDIAFILESUMMARYINFORMATION ＋ 到字节集 (36)
    pv ＝ GetIPropertyStore (文件路径, szPropKey)
    vt ＝ 取字节集数据 (pv, #短整数型, )
    .如果真 (vt ＝ 31) ' VT_LPWSTR
        pbstrVal ＝ 取字节集数据 (pv, #整数型, 9)
        .如果真 (pbstrVal ≠ #NULL)
            nMaxCount ＝ lstrlenW (pbstrVal)
            .如果真 (nMaxCount ＞ 0)
                nMaxCount ＝ nMaxCount × 2 ＋ 2
            .如果真结束
            返回 (指针到字节集 (pbstrVal, nMaxCount))
        .如果真结束
        
    .如果真结束
    返回 ({ })

.子程序 媒体属性_置编码人员, 逻辑型, 公开
    .参数 文件路径, 文本型
    .参数 编码人员, 文本型

    返回 (媒体属性_置编码人员W (编码_Ansi到Unicode (文件路径, ), 编码_Ansi到Unicode (编码人员, )))

.子程序 媒体属性_置编码人员W, 逻辑型, 公开
    .参数 文件路径, 字节集
    .参数 编码人员, 字节集
    .局部变量 szPropKey, 字节集
    .局部变量 pbVal, 字节集
    .局部变量 pv, 整数型

    szPropKey ＝ #PSGUID_MEDIAFILESUMMARYINFORMATION ＋ 到字节集 (36)
    pbVal ＝ 取空白字节集 (16)
    pv ＝ 取指针字节集_ (pbVal)
    __set_short (pv, 0, 31) ' VT_LPWSTR
    __set (pv, 8, 取指针_字节集型 (编码人员))
    返回 (SetIPropertyStore (文件路径, szPropKey, pbVal))

.子程序 媒体属性_取作者URL, 文本型, 公开
    .参数 文件路径, 文本型

    返回 (编码_Unicode到Ansi (媒体属性_取作者URLW (编码_Ansi到Unicode (文件路径, ))))

.子程序 媒体属性_取作者URLW, 字节集, 公开
    .参数 文件路径, 字节集
    .局部变量 szPropKey, 字节集
    .局部变量 pv, 字节集
    .局部变量 vt, 短整数型
    .局部变量 pbstrVal, 整数型
    .局部变量 nMaxCount, 整数型

    szPropKey ＝ #PSGUID_MEDIAFILESUMMARYINFORMATION ＋ 到字节集 (32)
    pv ＝ GetIPropertyStore (文件路径, szPropKey)
    vt ＝ 取字节集数据 (pv, #短整数型, )
    .如果真 (vt ＝ 31) ' VT_LPWSTR
        pbstrVal ＝ 取字节集数据 (pv, #整数型, 9)
        .如果真 (pbstrVal ≠ #NULL)
            nMaxCount ＝ lstrlenW (pbstrVal)
            .如果真 (nMaxCount ＞ 0)
                nMaxCount ＝ nMaxCount × 2 ＋ 2
            .如果真结束
            返回 (指针到字节集 (pbstrVal, nMaxCount))
        .如果真结束
        
    .如果真结束
    返回 ({ })

.子程序 媒体属性_置作者URL, 逻辑型, 公开
    .参数 文件路径, 文本型
    .参数 作者URL, 文本型

    返回 (媒体属性_置作者URLW (编码_Ansi到Unicode (文件路径, ), 编码_Ansi到Unicode (作者URL, )))

.子程序 媒体属性_置作者URLW, 逻辑型, 公开
    .参数 文件路径, 字节集
    .参数 作者URL, 字节集
    .局部变量 szPropKey, 字节集
    .局部变量 pbVal, 字节集
    .局部变量 pv, 整数型

    szPropKey ＝ #PSGUID_MEDIAFILESUMMARYINFORMATION ＋ 到字节集 (32)
    pbVal ＝ 取空白字节集 (16)
    pv ＝ 取指针字节集_ (pbVal)
    __set_short (pv, 0, 31) ' VT_LPWSTR
    __set (pv, 8, 取指针_字节集型 (作者URL))
    返回 (SetIPropertyStore (文件路径, szPropKey, pbVal))

.子程序 媒体属性_取促销URL, 文本型, 公开
    .参数 文件路径, 文本型

    返回 (编码_Unicode到Ansi (媒体属性_取促销URLW (编码_Ansi到Unicode (文件路径, ))))

.子程序 媒体属性_取促销URLW, 字节集, 公开
    .参数 文件路径, 字节集
    .局部变量 szPropKey, 字节集
    .局部变量 pv, 字节集
    .局部变量 vt, 短整数型
    .局部变量 pbstrVal, 整数型
    .局部变量 nMaxCount, 整数型

    szPropKey ＝ #PSGUID_MEDIAFILESUMMARYINFORMATION ＋ 到字节集 (33)
    pv ＝ GetIPropertyStore (文件路径, szPropKey)
    vt ＝ 取字节集数据 (pv, #短整数型, )
    .如果真 (vt ＝ 31) ' VT_LPWSTR
        pbstrVal ＝ 取字节集数据 (pv, #整数型, 9)
        .如果真 (pbstrVal ≠ #NULL)
            nMaxCount ＝ lstrlenW (pbstrVal)
            .如果真 (nMaxCount ＞ 0)
                nMaxCount ＝ nMaxCount × 2 ＋ 2
            .如果真结束
            返回 (指针到字节集 (pbstrVal, nMaxCount))
        .如果真结束
        
    .如果真结束
    返回 ({ })

.子程序 媒体属性_置促销URL, 逻辑型, 公开
    .参数 文件路径, 文本型
    .参数 促销URL, 文本型

    返回 (媒体属性_置促销URLW (编码_Ansi到Unicode (文件路径, ), 编码_Ansi到Unicode (促销URL, )))

.子程序 媒体属性_置促销URLW, 逻辑型, 公开
    .参数 文件路径, 字节集
    .参数 促销URL, 字节集
    .局部变量 szPropKey, 字节集
    .局部变量 pbVal, 字节集
    .局部变量 pv, 整数型

    szPropKey ＝ #PSGUID_MEDIAFILESUMMARYINFORMATION ＋ 到字节集 (33)
    pbVal ＝ 取空白字节集 (16)
    pv ＝ 取指针字节集_ (pbVal)
    __set_short (pv, 0, 31) ' VT_LPWSTR
    __set (pv, 8, 取指针_字节集型 (促销URL))
    返回 (SetIPropertyStore (文件路径, szPropKey, pbVal))

.子程序 媒体属性_取数据速率, 整数型, 公开
    .参数 文件路径, 文本型

    返回 (媒体属性_取数据速率W (编码_Ansi到Unicode (文件路径, )))

.子程序 媒体属性_取数据速率W, 整数型, 公开
    .参数 文件路径, 字节集
    .局部变量 szPropKey, 字节集
    .局部变量 pv, 字节集
    .局部变量 vt, 短整数型
    .局部变量 nMaxValue, 整数型

    szPropKey ＝ #FMTID_VideoSummaryInformation ＋ 到字节集 (8)
    pv ＝ GetIPropertyStore (文件路径, szPropKey)
    vt ＝ 取字节集数据 (pv, #短整数型, )
    .如果真 (vt ＝ 19) ' VT_UI4
        nMaxValue ＝ 取字节集数据 (pv, #整数型, 9)
        返回 (nMaxValue)
    .如果真结束
    返回 (0)

.子程序 媒体属性_取总比特率, 整数型, 公开
    .参数 文件路径, 文本型

    返回 (媒体属性_取总比特率W (编码_Ansi到Unicode (文件路径, )))

.子程序 媒体属性_取总比特率W, 整数型, 公开
    .参数 文件路径, 字节集
    .局部变量 szPropKey, 字节集
    .局部变量 pv, 字节集
    .局部变量 vt, 短整数型
    .局部变量 nMaxValue, 整数型

    szPropKey ＝ #FMTID_VideoSummaryInformation ＋ 到字节集 (43)
    pv ＝ GetIPropertyStore (文件路径, szPropKey)
    vt ＝ 取字节集数据 (pv, #短整数型, )
    .如果真 (vt ＝ 19) ' VT_UI4
        nMaxValue ＝ 取字节集数据 (pv, #整数型, 9)
        返回 (nMaxValue)
    .如果真结束
    返回 (0)

.子程序 媒体属性_取帧速率, 整数型, 公开
    .参数 文件路径, 文本型

    返回 (媒体属性_取帧速率W (编码_Ansi到Unicode (文件路径, )))

.子程序 媒体属性_取帧速率W, 整数型, 公开
    .参数 文件路径, 字节集
    .局部变量 szPropKey, 字节集
    .局部变量 pv, 字节集
    .局部变量 vt, 短整数型
    .局部变量 nMaxValue, 整数型

    szPropKey ＝ #FMTID_VideoSummaryInformation ＋ 到字节集 (6)
    pv ＝ GetIPropertyStore (文件路径, szPropKey)
    vt ＝ 取字节集数据 (pv, #短整数型, )
    .如果真 (vt ＝ 19) ' VT_UI4
        nMaxValue ＝ 取字节集数据 (pv, #整数型, 9)
        返回 (nMaxValue)
    .如果真结束
    返回 (0)

.子程序 媒体属性_取比特率, 整数型, 公开
    .参数 文件路径, 文本型

    返回 (媒体属性_取比特率W (编码_Ansi到Unicode (文件路径, )))

.子程序 媒体属性_取比特率W, 整数型, 公开
    .参数 文件路径, 字节集
    .局部变量 szPropKey, 字节集
    .局部变量 pv, 字节集
    .局部变量 vt, 短整数型
    .局部变量 nMaxValue, 整数型

    szPropKey ＝ #FMTID_AudioSummaryInformation ＋ 到字节集 (4)
    pv ＝ GetIPropertyStore (文件路径, szPropKey)
    vt ＝ 取字节集数据 (pv, #短整数型, )
    .如果真 (vt ＝ 19) ' VT_UI4
        nMaxValue ＝ 取字节集数据 (pv, #整数型, 9)
        返回 (nMaxValue)
    .如果真结束
    返回 (0)

.子程序 媒体属性_取音频采样频率, 整数型, 公开
    .参数 文件路径, 文本型

    返回 (媒体属性_取音频采样频率W (编码_Ansi到Unicode (文件路径, )))

.子程序 媒体属性_取音频采样频率W, 整数型, 公开
    .参数 文件路径, 字节集
    .局部变量 szPropKey, 字节集
    .局部变量 pv, 字节集
    .局部变量 vt, 短整数型
    .局部变量 nMaxValue, 整数型

    szPropKey ＝ #FMTID_AudioSummaryInformation ＋ 到字节集 (5)
    pv ＝ GetIPropertyStore (文件路径, szPropKey)
    vt ＝ 取字节集数据 (pv, #短整数型, )
    .如果真 (vt ＝ 19) ' VT_UI4
        nMaxValue ＝ 取字节集数据 (pv, #整数型, 9)
        返回 (nMaxValue)
    .如果真结束
    返回 (0)

.子程序 媒体属性_取类型, 文本型, 公开
    .参数 文件路径, 文本型

    返回 (编码_Unicode到Ansi (媒体属性_取类型W (编码_Ansi到Unicode (文件路径, ))))

.子程序 媒体属性_取类型W, 字节集, 公开
    .参数 文件路径, 字节集
    .局部变量 szPropKey, 字节集
    .局部变量 pv, 字节集
    .局部变量 vt, 短整数型
    .局部变量 pbstrVal, 整数型
    .局部变量 nMaxCount, 整数型

    szPropKey ＝ { 80, 227, 99, 11, 204, 156, 208, 17, 188, 219, 0, 128, 95, 204, 206, 4, 5, 0, 0, 0 }
    pv ＝ GetIPropertyStore (文件路径, szPropKey)
    vt ＝ 取字节集数据 (pv, #短整数型, )
    .如果真 (vt ＝ 31) ' VT_LPWSTR
        pbstrVal ＝ 取字节集数据 (pv, #整数型, 9)
        .如果真 (pbstrVal ≠ #NULL)
            nMaxCount ＝ lstrlenW (pbstrVal)
            .如果真 (nMaxCount ＞ 0)
                nMaxCount ＝ nMaxCount × 2 ＋ 2
            .如果真结束
            返回 (指针到字节集 (pbstrVal, nMaxCount))
        .如果真结束
        
    .如果真结束
    返回 ({ })

.版本 2

.程序集 集_修复堆内存重释放
.程序集变量 hook, 类_HOOK_EX

.子程序 收录说明
    ' 本程序集名收录自：https://bbs.125.la/forum.php?mod=viewthread&tid=14327228

.子程序 内存_修复堆内存重释放, 逻辑型, 公开, 由于重释放会产生崩溃，因此修复
    返回 (hook.安装 (程序_取函数地址_API (“kernel32”, “HeapFree”), 程序_取子程序地址 (&hook), 假))

.子程序 hook, 整数型
    .参数 参_堆句柄, 整数型
    .参数 参_无用值, 整数型, , 一般为0 锁内存。。
    .参数 参_内存指针, 整数型
    .局部变量 局_返回值, 整数型

    局_返回值 ＝ HeapSize (参_堆句柄, 0, 参_内存指针)
    .判断开始 (局_返回值 ＝ -1)
        返回 (1) ' 返回真，让它以为释放了。。
    .默认
        返回 (hook.回调ex ())
    .判断结束
    

.子程序 程序_取函数地址_API, 整数型, 公开, 取得函数地址，api版
    .参数 参_模块名, 文本型
    .参数 参_命令名, 文本型

    返回 (GetProcAddress (LoadLibraryA (参_模块名), 参_命令名))

.子程序 内存_修改内存, 逻辑型, 公开, 非高段地址可使用 内存_写到内存（） 或 内存_写到内存_dw
    .参数 参_目的地址, 整数型, , 目的地址的缓冲区长度需大于或等于长度
    .参数 参_字节集, 字节集, , 用于写入到目的地址的 数据
    .参数 参_长度, 整数型, , 需要写入的长度
    .局部变量 局_保护值, 整数型
    .局部变量 局_虚拟信息, 精易_内存属性

    局_保护值 ＝ VirtualQueryEx (-1, 参_目的地址, 局_虚拟信息, 28) ' 取内存保护值属性
    .如果真 (局_保护值 ＝ 0)
        返回 (假)
    .如果真结束
    .如果真 (VirtualProtectEx (-1, 局_虚拟信息.区域地址, 6, 64, 局_虚拟信息.当前属性) ＝ 0) ' 修改内存属性'
        返回 (假)
    .如果真结束
    内存_写到内存 (参_目的地址, 取指针_字节集型 (参_字节集), 参_长度)
    返回 (真)

.子程序 内存_写到内存, , 公开, 高段地址可使用 内存_修改内存（）
    .参数 参_目的地址, 整数型, , 目的地址的缓冲区长度需大于或等于长度
    .参数 参_源地址, 整数型, , 用于写入到目的地址的 数据的指针
    .参数 参_长度, 整数型, , 需要写入的长度

    置入代码 ({ 96, 139, 77, 16, 139, 125, 8, 139, 117, 12, 243, 164, 97 })

.子程序 内存_取指令对其长度, 整数型, 公开, 返回大于或等于给定长度的理想值。
    .参数 参_预算长度, 整数型
    .参数 参_被扫描的字节集, 字节集
    .局部变量 局_扫描表, 字节集
    .局部变量 局_长度, 整数型
    .局部变量 i, 整数型
    .局部变量 局_字节, 字节型
    .局部变量 局_记录值, 整数型
    .局部变量 局_理想长度, 整数型

    局_长度 ＝ 取字节集长度 (参_被扫描的字节集)
    .如果真 (局_长度 ≤ 参_预算长度)
        返回 (0)
    .如果真结束
    局_扫描表 ＝ { 1, 1, 1, 1, 1, 4, 0, 0, 1, 1, 1, 1, 1, 4, 0, 2, 1, 1, 1, 1, 1, 4, 0, 0, 1, 1, 1, 1, 1, 4, 0, 0, 1, 1, 1, 1, 1, 4, 0, 0, 1, 1, 1, 1, 1, 4, 0, 0, 1, 1, 1, 1, 1, 4, 0, 0, 1, 1, 1, 1, 1, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 2, 0, 4, 5, 1, 2, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 5, 0, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0, 0, 1, 4, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 0, 1, 1, 2, 5, 3, 0, 2, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 4, 4, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 5, 0, 0, 0, 0, 0, 0, 1, 1 } ' 256
    局_记录值 ＝ 0
    .计次循环首 (局_长度, i)
        局_记录值 ＝ 局_记录值 － 1
        .如果真 (局_记录值 ＞ -1) ' 跳过下面记录的次数 延长i .  理想长度
            到循环尾 ()
        .如果真结束
        局_字节 ＝ 参_被扫描的字节集 [i]
        局_记录值 ＝ 局_扫描表 [局_字节 ＋ 1] ' 从1开始
        局_理想长度 ＝ i ＋ 局_记录值
        .如果真 (局_理想长度 ≥ 参_预算长度)
            返回 (局_理想长度)
        .如果真结束
        
    .计次循环尾 ()
    返回 (0)

.子程序 内存_跳转偏移处理, 字节集, 公开, 返回 偏移call  jmp  转成成绝对call  jmp后的代码集 
    .参数 参_字节集, 字节集
    .参数 参_函数地址, 整数型, , 函数基址
    .局部变量 局_长度, 整数型
    .局部变量 局_扫描表, 字节集
    .局部变量 局_记录值, 整数型
    .局部变量 i, 整数型
    .局部变量 局_字节, 字节型
    .局部变量 局_返回字节集, 字节集
    .局部变量 局_偏移缓冲, 字节集
    .局部变量 局_替换缓冲, 字节集
    .局部变量 局_绝对地址, 整数型
    .局部变量 局_尾部, 字节集
    .局部变量 局_替换长度, 整数型
    .局部变量 局_替换位置, 整数型
    .局部变量 局_替换增加, 整数型
    .局部变量 局_绝对跳转代码, 字节集

    局_长度 ＝ 取字节集长度 (参_字节集)
    局_扫描表 ＝ { 1, 1, 1, 1, 1, 4, 0, 0, 1, 1, 1, 1, 1, 4, 0, 2, 1, 1, 1, 1, 1, 4, 0, 0, 1, 1, 1, 1, 1, 4, 0, 0, 1, 1, 1, 1, 1, 4, 0, 0, 1, 1, 1, 1, 1, 4, 0, 0, 1, 1, 1, 1, 1, 4, 0, 0, 1, 1, 1, 1, 1, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 2, 0, 4, 5, 1, 2, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 5, 0, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0, 0, 1, 4, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 0, 1, 1, 2, 5, 3, 0, 2, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 4, 4, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 5, 0, 0, 0, 0, 0, 0, 1, 1 } ' 256
    局_返回字节集 ＝ 参_字节集
    局_偏移缓冲 ＝ 取空白字节集 (4)
    局_记录值 ＝ 0
    .计次循环首 (局_长度, i)
        局_记录值 ＝ 局_记录值 － 1
        .如果真 (局_记录值 ＞ -1) ' 跳过下面记录的次数 延长i .
            到循环尾 ()
        .如果真结束
        局_字节 ＝ 参_字节集 [i]
        局_记录值 ＝ 局_扫描表 [局_字节 ＋ 1] ' 从1开始 记录代码后面跟随的字节宽度 再跳过。
        ' 逆出绝对地址： 偏移call 或 jmp指令位置-1 +5(一个完整偏移call5字节) +偏移(call后面的数) +函数基址 =绝对地址
        .判断开始 (局_字节 ＝ 232) ' 偏移call 4
            局_偏移缓冲 [1] ＝ 参_字节集 [i ＋ 1]
            局_偏移缓冲 [2] ＝ 参_字节集 [i ＋ 2]
            局_偏移缓冲 [3] ＝ 参_字节集 [i ＋ 3]
            局_偏移缓冲 [4] ＝ 参_字节集 [i ＋ 4]
            局_绝对地址 ＝ 参_函数地址 ＋ i ＋ 4 ＋ 取字节集数据 (局_偏移缓冲, 3, )
            局_尾部 ＝ { 255, 208 }
            局_替换长度 ＝ 5
        .判断 (局_字节 ＝ 233) ' 偏移jmp 4
            局_偏移缓冲 [1] ＝ 参_字节集 [i ＋ 1]
            局_偏移缓冲 [2] ＝ 参_字节集 [i ＋ 2]
            局_偏移缓冲 [3] ＝ 参_字节集 [i ＋ 3]
            局_偏移缓冲 [4] ＝ 参_字节集 [i ＋ 4]
            局_绝对地址 ＝ 参_函数地址 ＋ i ＋ 4 ＋ 取字节集数据 (局_偏移缓冲, 3, )
            局_尾部 ＝ { 255, 224 }
            局_替换长度 ＝ 5
        .判断 (局_字节 ＝ 235) ' 偏移jmp 1
            局_偏移缓冲 ＝ 到字节集 (到整数 (参_字节集 [i ＋ 1] × 1))
            局_绝对地址 ＝ 参_函数地址 ＋ i ＋ 1 ＋ 取字节集数据 (局_偏移缓冲, 3, )
            ' 调试输出 (绝对地址)
            ' 调试输出 (函数地址)
            ' 调试输出 (取字节集数据 (偏移缓冲, 3, ))
            局_尾部 ＝ { 255, 224 }
            局_替换长度 ＝ 2
        .默认
            到循环尾 () ' 非call jmp 不处理。
        .判断结束
        局_绝对跳转代码 ＝ { 199, 192 } ＋ 到字节集 (局_绝对地址) ＋ 局_尾部
        局_替换位置 ＝ 局_替换增加 ＋ i
        局_返回字节集 ＝ 字节集替换 (局_返回字节集, 局_替换位置, 局_替换长度, 局_绝对跳转代码)
        局_替换增加 ＝ 局_替换增加 ＋ 取字节集长度 (局_绝对跳转代码) － 局_替换长度 ' ----替换位置偏移
    .计次循环尾 ()
    
    返回 (局_返回字节集)
    

.子程序 内存_拷贝字节集, 整数型, 公开, 拷贝一段字节集并返回内存指针,自动释放（申请内存与写到内存的结合。）
    .参数 参_字节集, 字节集, , 需要拷贝的字节集
    .局部变量 局_内存地址, 整数型

    局_内存地址 ＝ 内存_申请内存 (取字节集长度 (参_字节集))
    内存_写到内存 (局_内存地址, 取指针_字节集型 (参_字节集), 取字节集长度 (参_字节集))
    返回 (局_内存地址)

.子程序 内存_申请内存, 整数型, 公开, 返回指针  自动释放，属性：不使用连续加填充0
    .参数 参_长度, 整数型, , 字节

    返回 (HeapAlloc (GetProcessHeap (), 9, 参_长度))

.子程序 程序_取参数个数, 整数型, 公开, 【扫描函数 勿频繁】取得函数参数个数，4字节对齐。特殊情况下，个数不等同于实际个数。仅用于计算栈平衡数值。
    .参数 参_被扫描函数指针, 整数型
    .局部变量 局_扫描表, 字节集
    .局部变量 局_字节集, 字节集
    .局部变量 i, 整数型
    .局部变量 局_字节, 字节型
    .局部变量 局_记录值, 整数型

    局_扫描表 ＝ { 1, 1, 1, 1, 1, 4, 0, 0, 1, 1, 1, 1, 1, 4, 0, 2, 1, 1, 1, 1, 1, 4, 0, 0, 1, 1, 1, 1, 1, 4, 0, 0, 1, 1, 1, 1, 1, 4, 0, 0, 1, 1, 1, 1, 1, 4, 0, 0, 1, 1, 1, 1, 1, 4, 0, 0, 1, 1, 1, 1, 1, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 2, 0, 4, 5, 1, 2, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 5, 0, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0, 0, 1, 4, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 0, 1, 1, 2, 5, 3, 0, 2, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 4, 4, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 5, 0, 0, 0, 0, 0, 0, 1, 1 } ' 256
    局_字节集 ＝ { 0 }
    局_记录值 ＝ 0
    .判断循环首 (i ＞ -1)
        局_记录值 ＝ 局_记录值 － 1
        .如果真 (局_记录值 ＞ -1) ' 跳过下面记录的次数 延长i .  理想长度
            i ＝ i ＋ 1
            到循环尾 ()
        .如果真结束
        内存_写到内存 (取指针_字节集型 (局_字节集), 参_被扫描函数指针 ＋ i, 1)
        局_字节 ＝ 局_字节集 [1]
        局_记录值 ＝ 局_扫描表 [局_字节 ＋ 1]
        i ＝ i ＋ 1
        .判断开始 (局_字节 ＝ 195)
            返回 (0)
        .默认
            .如果真 (局_字节 ＝ 194)
                局_字节集 ＝ { 0, 0, 0, 0 }
                内存_写到内存 (取指针_字节集型 (局_字节集), 参_被扫描函数指针 ＋ i, 2)
                返回 (取字节集数据 (局_字节集, 3, ) ÷ 4)
            .如果真结束
            
        .判断结束
        
    .判断循环尾 ()
    返回 (0)

.子程序 程序_取子程序地址, 整数型, 公开, 【扫描函数 勿频繁】动态扫描子程序真实地址，勿频繁调用  失败返回0
    .参数 参_子程序指针, 子程序指针
    .局部变量 局_字节集, 字节集
    .局部变量 局_存放数组, 整数型, , "0"
    .局部变量 局_伪造数组, 整数型, , "0"
    .局部变量 i, 整数型
    .局部变量 局_头部字节, 字节集
    .局部变量 局_伪造数组2, 整数型, , "0"

    局_字节集 ＝ 取子程序字节集代码 (参_子程序指针)
    内存_取calljmp地址 (局_字节集, 到整数 (参_子程序指针), 局_存放数组)
    .计次循环首 (取数组成员数 (局_存放数组), i)
        局_头部字节 ＝ 指针到字节集 (局_存放数组 [i], 3)
        .如果真 (局_头部字节 ＝ { 85, 139, 236 })
            加入成员 (局_伪造数组, 局_存放数组 [i])
        .如果真结束
        
    .计次循环尾 ()
    .如果真 (取数组成员数 (局_伪造数组) ＝ 1)
        返回 (局_伪造数组 [1])
    .如果真结束
    
    .计次循环首 (取数组成员数 (局_伪造数组), i)
        局_字节集 ＝ 取子程序字节集代码 (参_子程序指针)
        内存_取calljmp地址 (局_字节集, 到整数 (参_子程序指针), 局_存放数组)
        .计次循环首 (取数组成员数 (局_存放数组), i)
            局_头部字节 ＝ 指针到字节集 (局_存放数组 [i], 3)
            .如果真 (局_头部字节 ＝ { 85, 139, 236 })
                加入成员 (局_伪造数组2, 局_存放数组 [i])
            .如果真结束
            
        .计次循环尾 ()
    .计次循环尾 ()
    .如果真 (取数组成员数 (局_伪造数组2) ＝ 1)
        返回 (局_伪造数组2 [1])
    .如果真结束
    
    返回 (0)
    

.子程序 内存_取calljmp地址, 整数型, 公开, 将代码集中的偏移地址 转成绝对地址保存在数组里  并 返回成员数 
    .参数 参_字节集, 字节集
    .参数 参_函数地址, 整数型, , 函数基址
    .参数 参_存放数组, 整数型, 参考 数组, 存放已经转为绝对地址的偏移地址
    .局部变量 局_长度, 整数型
    .局部变量 局_扫描表, 字节集
    .局部变量 局_记录值, 整数型
    .局部变量 i, 整数型
    .局部变量 局_字节, 字节型
    .局部变量 局_返回字节集, 字节集
    .局部变量 局_偏移缓冲, 字节集
    .局部变量 局_替换缓冲, 字节集
    .局部变量 局_绝对地址, 整数型
    .局部变量 局_尾部, 字节集
    .局部变量 局_替换长度, 整数型
    .局部变量 局_替换位置, 整数型
    .局部变量 局_替换增加, 整数型
    .局部变量 局_绝对跳转代码, 字节集

    清除数组 (参_存放数组)
    局_长度 ＝ 取字节集长度 (参_字节集)
    局_扫描表 ＝ { 1, 1, 1, 1, 1, 4, 0, 0, 1, 1, 1, 1, 1, 4, 0, 2, 1, 1, 1, 1, 1, 4, 0, 0, 1, 1, 1, 1, 1, 4, 0, 0, 1, 1, 1, 1, 1, 4, 0, 0, 1, 1, 1, 1, 1, 4, 0, 0, 1, 1, 1, 1, 1, 4, 0, 0, 1, 1, 1, 1, 1, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 2, 0, 4, 5, 1, 2, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 5, 0, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0, 0, 1, 4, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 0, 1, 1, 2, 5, 3, 0, 2, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 4, 4, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 5, 0, 0, 0, 0, 0, 0, 1, 1 } ' 256
    局_返回字节集 ＝ 参_字节集
    局_偏移缓冲 ＝ 取空白字节集 (4)
    局_记录值 ＝ 0
    .计次循环首 (局_长度, i)
        局_记录值 ＝ 局_记录值 － 1
        .如果真 (局_记录值 ＞ -1) ' 跳过下面记录的次数 延长i .
            到循环尾 ()
        .如果真结束
        局_字节 ＝ 参_字节集 [i]
        局_记录值 ＝ 局_扫描表 [局_字节 ＋ 1] ' 从1开始 记录代码后面跟随的字节宽度 再跳过。
        ' 逆出绝对地址： 偏移call 或 jmp指令位置-1 +5(一个完整偏移call5字节) +偏移(call后面的数) +函数基址 =绝对地址
        .判断开始 (局_字节 ＝ 232) ' 偏移call 4
            局_偏移缓冲 [1] ＝ 参_字节集 [i ＋ 1]
            局_偏移缓冲 [2] ＝ 参_字节集 [i ＋ 2]
            局_偏移缓冲 [3] ＝ 参_字节集 [i ＋ 3]
            局_偏移缓冲 [4] ＝ 参_字节集 [i ＋ 4]
            局_绝对地址 ＝ 参_函数地址 ＋ i ＋ 4 ＋ 取字节集数据 (局_偏移缓冲, 3, )
            局_尾部 ＝ { 255, 208 }
            局_替换长度 ＝ 5
        .判断 (局_字节 ＝ 233) ' 偏移jmp 4
            局_偏移缓冲 [1] ＝ 参_字节集 [i ＋ 1]
            局_偏移缓冲 [2] ＝ 参_字节集 [i ＋ 2]
            局_偏移缓冲 [3] ＝ 参_字节集 [i ＋ 3]
            局_偏移缓冲 [4] ＝ 参_字节集 [i ＋ 4]
            局_绝对地址 ＝ 参_函数地址 ＋ i ＋ 4 ＋ 取字节集数据 (局_偏移缓冲, 3, )
            局_尾部 ＝ { 255, 224 }
            局_替换长度 ＝ 5
        .判断 (局_字节 ＝ 235) ' 偏移jmp 1
            局_偏移缓冲 ＝ 到字节集 (到整数 (参_字节集 [i ＋ 1] × 1))
            局_绝对地址 ＝ 参_函数地址 ＋ i ＋ 1 ＋ 取字节集数据 (局_偏移缓冲, 3, )
            ' 调试输出 (绝对地址)
            ' 调试输出 (函数地址)
            ' 调试输出 (取字节集数据 (偏移缓冲, 3, ))
            局_尾部 ＝ { 255, 224 }
            局_替换长度 ＝ 2
        .默认
            到循环尾 () ' 非call jmp 不处理。
        .判断结束
        加入成员 (参_存放数组, 局_绝对地址)
        ' 绝对跳转代码 ＝ { 199, 192 } ＋ 到字节集 (绝对地址) ＋ 尾部
        ' 替换位置 ＝ 替换增加 ＋ i
        ' 返回字节集 ＝ 字节集替换 (返回字节集, 替换位置, 替换长度, 绝对跳转代码)
        ' 替换增加 ＝ 替换增加 ＋ 取字节集长度 (绝对跳转代码) － 替换长度  ' ----替换位置偏移
    .计次循环尾 ()
    返回 (取数组成员数 (参_存放数组))
    

.子程序 取子程序字节集代码, 字节集, 公开, 返回 子程序头部到第一个返回处的代码集
    .参数 参_子程序指针, 子程序指针
    .局部变量 局_扫描表, 字节集
    .局部变量 局_字节集, 字节集
    .局部变量 局_记录值, 整数型
    .局部变量 i, 整数型
    .局部变量 局_被扫描函数指针, 整数型
    .局部变量 局_字节, 字节型

    局_扫描表 ＝ { 1, 1, 1, 1, 1, 4, 0, 0, 1, 1, 1, 1, 1, 4, 0, 2, 1, 1, 1, 1, 1, 4, 0, 0, 1, 1, 1, 1, 1, 4, 0, 0, 1, 1, 1, 1, 1, 4, 0, 0, 1, 1, 1, 1, 1, 4, 0, 0, 1, 1, 1, 1, 1, 4, 0, 0, 1, 1, 1, 1, 1, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 2, 0, 4, 5, 1, 2, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 5, 0, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0, 0, 1, 4, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 0, 1, 1, 2, 5, 3, 0, 2, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 4, 4, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 5, 0, 0, 0, 0, 0, 0, 1, 1 } ' 256
    局_字节集 ＝ { 0 }
    局_被扫描函数指针 ＝ 到整数 (参_子程序指针)
    局_记录值 ＝ 0
    .判断循环首 (i ＞ -1)
        局_记录值 ＝ 局_记录值 － 1
        .如果真 (局_记录值 ＞ -1) ' 跳过下面记录的次数 延长i .  理想长度
            i ＝ i ＋ 1
            到循环尾 ()
        .如果真结束
        内存_写到内存 (取指针_字节集型 (局_字节集), 局_被扫描函数指针 ＋ i, 1)
        局_字节 ＝ 局_字节集 [1]
        局_记录值 ＝ 局_扫描表 [局_字节 ＋ 1]
        i ＝ i ＋ 1
        .判断开始 (局_字节 ＝ 195)
            返回 (指针到字节集 (局_被扫描函数指针, i))
        .默认
            .如果真 (局_字节 ＝ 194)
                返回 (指针到字节集 (局_被扫描函数指针, i ＋ 2))
            .如果真结束
            
        .判断结束
        
    .判断循环尾 ()
    返回 ({ })

.版本 2

.程序集 集_易语言相关
.子程序 易语言_取易语言安装目录, 文本型, 公开, 成功返回路径,不需要文件名时,路径以\结尾,失败返回空文本
    .参数 是否需要文件名, 逻辑型, 可空, 默认为假,即为不需要留文件名
    .局部变量 path, 文本型
    .局部变量 hkey, 整数型
    .局部变量 port, 字节集
    .局部变量 size, 整数型
    .局部变量 ret, 整数型

    RegOpenKeyA (#HKEY_CURRENT_USER, “Software\FlySky\E\Install”, hkey)
    size ＝ #MAX_PATH
    port ＝ 取空白字节集 (size)
    ret ＝ RegQueryValueExA (hkey, “Path”, #NULL, #NULL, port, size)
    RegCloseKey (hkey)
    .如果真 (ret ＝ #ERROR_SUCCESS)
        path ＝ 到文本 (port)
        path ＝ 取文本左边 (path, 取文本长度 (path) － 4) ' lib\
        .如果真 (是否需要文件名)
            path ＝ path ＋ “e.exe”
        .如果真结束
        
    .如果真结束
    返回 (path)

.子程序 易语言_加快捷方式到IE浏览器, 逻辑型, 公开
    .参数 图标所在路径文件名, 文本型, , 用于加载到IE浏览器快捷按钮上所用原始图标的路径文件名,以ICO结束,如:"e.ico"
    .参数 提示文字, 文本型, , 用于在IE浏览器中用于提示的文字,如:“易语言3.6”
    .参数 添加还是清除, 逻辑型
    .局部变量 路径, 文本型

    .如果真 (文件是否存在 (图标所在路径文件名) ＝ 假)
        返回 (假)
    .如果真结束
    路径 ＝ 取文本注册项 (#现行用户, “Software\FlySky\E\Install\Path”, “”)
    路径 ＝ 取文本左边 (路径, 取文本长度 (路径) － 4)
    .如果真 (路径 ≠ “”)
        写到文件 (路径 ＋ “e.ico”, 读入文件 (图标所在路径文件名))
    .如果真结束
    
    .如果 (添加还是清除 ＝ 真)
        写注册项 (#本地机器, “SOFTWARE\Microsoft\Internet Explorer\Extensions\{BF5DC4AE-258C-43d5-9D80-1F7ACD734DD8}\ButtonText”, 提示文字)
        写注册项 (#本地机器, “SOFTWARE\Microsoft\Internet Explorer\Extensions\{BF5DC4AE-258C-43d5-9D80-1F7ACD734DD8}\CLSID”, “{1FBA04EE-3024-11D2-8F1F-0000F87ABD16}”)
        写注册项 (#本地机器, “SOFTWARE\Microsoft\Internet Explorer\Extensions\{BF5DC4AE-258C-43d5-9D80-1F7ACD734DD8}\Default visible”, “Yes”)
        写注册项 (#本地机器, “SOFTWARE\Microsoft\Internet Explorer\Extensions\{BF5DC4AE-258C-43d5-9D80-1F7ACD734DD8}\Exec”, 路径 ＋ “e.exe”) ' 程序位置(路径)
        写注册项 (#本地机器, “SOFTWARE\Microsoft\Internet Explorer\Extensions\{BF5DC4AE-258C-43d5-9D80-1F7ACD734DD8}\HotIcon”, 路径 ＋ “e.ico”) ' 点燃图标
        写注册项 (#本地机器, “SOFTWARE\Microsoft\Internet Explorer\Extensions\{BF5DC4AE-258C-43d5-9D80-1F7ACD734DD8}\Icon”, 路径 ＋ “e.ico”) ' 程序图标
        写注册项 (#本地机器, “SOFTWARE\Microsoft\Internet Explorer\Extensions\{BF5DC4AE-258C-43d5-9D80-1F7ACD734DD8}\MenuText”, 提示文字)
        写注册项 (#本地机器, “SOFTWARE\Microsoft\Internet Explorer\Extensions\{BF5DC4AE-258C-43d5-9D80-1F7ACD734DD8}\MenuStatusBar”, 提示文字)
    .否则
        删除注册项 (#本地机器, “SOFTWARE\Microsoft\Internet Explorer\Extensions\{BF5DC4AE-258C-43d5-9D80-1F7ACD734DD8}\ButtonText”)
        删除注册项 (#本地机器, “SOFTWARE\Microsoft\Internet Explorer\Extensions\{BF5DC4AE-258C-43d5-9D80-1F7ACD734DD8}\CLSID”)
        删除注册项 (#本地机器, “SOFTWARE\Microsoft\Internet Explorer\Extensions\{BF5DC4AE-258C-43d5-9D80-1F7ACD734DD8}\Default visible”)
        删除注册项 (#本地机器, “SOFTWARE\Microsoft\Internet Explorer\Extensions\{BF5DC4AE-258C-43d5-9D80-1F7ACD734DD8}\Exec”) ' 程序位置(路径)
        删除注册项 (#本地机器, “SOFTWARE\Microsoft\Internet Explorer\Extensions\{BF5DC4AE-258C-43d5-9D80-1F7ACD734DD8}\HotIcon”) ' 点燃图标
        删除注册项 (#本地机器, “SOFTWARE\Microsoft\Internet Explorer\Extensions\{BF5DC4AE-258C-43d5-9D80-1F7ACD734DD8}\Icon”) ' 程序图标
        删除注册项 (#本地机器, “SOFTWARE\Microsoft\Internet Explorer\Extensions\{BF5DC4AE-258C-43d5-9D80-1F7ACD734DD8}\MenuText”)
        删除注册项 (#本地机器, “SOFTWARE\Microsoft\Internet Explorer\Extensions\{BF5DC4AE-258C-43d5-9D80-1F7ACD734DD8}\MenuStatusBar”)
        删除注册项 (#本地机器, “SOFTWARE\Microsoft\Internet Explorer\Extensions\{BF5DC4AE-258C-43d5-9D80-1F7ACD734DD8}”)
    .如果结束
    返回 (真)

.子程序 易语言_引用易模块, , 公开, 必须编译出来才行,因为在调试状态下,易语言不允许添加模块的
    .参数 模块路径, 文本型, , 如：C:\精易模块.ec
    .局部变量 局_模块句柄, 整数型
    .局部变量 局_模块对话框, 整数型
    .局部变量 局_打开按钮句柄, 整数型
    .局部变量 局_Edit句柄, 整数型
    .局部变量 局_树型框, 外部树型框
    .局部变量 局_计次, 整数型
    .局部变量 局_超时返回, 整数型

    局_模块句柄 ＝ 窗口_取句柄_模糊 (“易语言 - ”, “ENewFrame”)
    .如果真 (局_模块句柄 ≤ 0)
        提示框 (“易语言未打开,无法引用模块”)
        返回 ()
    .如果真结束
    窗口_置焦点 (局_模块句柄)
    局_模块句柄 ＝ 功能_取模块引用表句柄 (局_模块句柄)
    .如果真 (局_模块句柄 ≤ 0)
        提示框 (“引用表提取失败”)
        返回 ()
    .如果真结束
    局_树型框.初始化 (局_模块句柄)
    .计次循环首 (局_树型框.取项目数 (), 局_计次)
        .如果真 (局_树型框.取项目文本 (局_计次 － 1) ＝ “模块引用表”)
            局_树型框.置现行选中项 (局_计次 － 1)
            跳出循环 ()
        .如果真结束
        
    .计次循环尾 ()
    程序_延时 (10)
    鼠标_消息 (局_模块句柄, 185, 13, 2) ' 发送鼠标右键消息
    程序_延时 (10, )
    键盘_消息 (局_模块句柄, #I键, 3, 假) ' 发送消息点击菜单上的添加模块引用
    局_超时返回 ＝ 取启动时间 ()
    .判断循环首 (0 ＜ 1)
        局_模块对话框 ＝ 窗口_取句柄 (, , “#32770”, “请选择欲加入易模块文件:”)
        .判断开始 (局_模块对话框 ＞ 0)
            局_Edit句柄 ＝ 窗口_取句柄 (局_模块对话框, , “Edit”, )
            局_打开按钮句柄 ＝ 窗口_取句柄 (局_模块对话框, , “Button”, “打开(&O)”)
            窗口_置控件内容 (局_Edit句柄, 模块路径)
            程序_延时 (10)
            .如果真 (窗口_取控件内容 (局_Edit句柄) ≠ 模块路径)
                窗口_置控件内容 (局_Edit句柄, 模块路径)
            .如果真结束
            鼠标_消息 (局_打开按钮句柄, 5, 5) ' 发送消息点击打开按钮
            跳出循环 ()
        .判断 (取启动时间 () － 局_超时返回 ＞ 5000)
            提示框 (“超时,引用失败”)
            跳出循环 ()
        .默认
            
        .判断结束
        
    .判断循环尾 ()

.子程序 功能_取模块引用表句柄, 整数型
    .参数 顶级句柄, 整数型
    .局部变量 局_1级句柄, 整数型
    .局部变量 局_2级句柄, 整数型
    .局部变量 局_3级句柄, 整数型
    .局部变量 局_4级句柄, 整数型
    .局部变量 局_5级句柄, 整数型
    .局部变量 子窗口数组, 整数型, , "0"

    局_1级句柄 ＝ 窗口_取句柄 (顶级句柄, , “AfxControlBar42s”, “工作夹”)
    .如果真 (局_1级句柄 ≤ 0)
        返回 (0)
    .如果真结束
    局_2级句柄 ＝ 窗口_取句柄 (局_1级句柄, , “Afx:400000:8:10011:1900015:0”, “工作夹”)
    .如果真 (局_2级句柄 ≤ 0)
        返回 (0)
    .如果真结束
    局_3级句柄 ＝ 窗口_取句柄 (局_2级句柄, , “#32770”, )
    .如果真 (局_3级句柄 ≤ 0)
        返回 (0)
    .如果真结束
    局_4级句柄 ＝ 窗口_取句柄 (局_3级句柄, , “SysTabControl32”, “Tab1”)
    .如果真 (局_4级句柄 ≤ 0)
        返回 (0)
    .如果真结束
    .如果真 (窗口_枚举子窗口 (局_4级句柄, 子窗口数组, “SysTreeView32”) ＝ 2)
        返回 (子窗口数组 [2])
    .如果真结束
    返回 (0)
    

.版本 2

.程序集 集_杂合________
.程序集变量 FLSAList, Stroks, , "0"

.子程序 ADD__, 整数型, , 加法指令 返回值=操作数1+操作数2+操作数3
    .参数 操作数1, 整数型
    .参数 操作数2, 整数型
    .参数 操作数3, 整数型, 可空

    ' 0045E3BF      8B45 0C       mov     eax, dword ptr [ebp+C]
    ' 0045E3C2      0345 10       add     eax, dword ptr [ebp+10]
    ' 0045E3C5      0145 08       add     dword ptr [ebp+8], eax
    ' 8B 45 0C 03 45 10 01 45 08
    置入代码 ({ 139, 69, 12, 3, 69, 16, 1, 69, 8 })
    返回 (操作数1)

.子程序 取字节集指针, 整数型
    .参数 参_字节集, 字节集, 参考

    置入代码 ({ 139, 69, 8, 139, 0, 131, 248, 0, 116, 3, 131, 192, 8, 201, 194, 4, 0 })
    返回 (0)

.子程序 SUB__, 整数型, , 减法指令 返回值=操作数1-操作数2-操作数3
    .参数 操作数1, 整数型
    .参数 操作数2, 整数型
    .参数 操作数3, 整数型, 可空

    ' 0045E379      8B45 0C       mov     eax, dword ptr [ebp+C]
    ' 0045E37C      0345 10       add     eax, dword ptr [ebp+10]
    ' 0045E37F      2945 08       sub     dword ptr [ebp+8], eax
    ' 8B 45 0C 03 45 10 29 45 08
    置入代码 ({ 139, 69, 12, 3, 69, 16, 41, 69, 8 })
    返回 (操作数1)

.子程序 递增, 整数型, , 对提供的整数型变量值+1,注意:不支持字节型,短整数型,长整数型等的操作
    .参数 整数变量, 整数型, 参考, 此参数必须为整数型变量,会被+1保存回去.显示为符号整数型

    ' 0040113B    51              push    ecx
    ' 0040113C    B8 01000000     mov     eax, 1
    ' 00401141    8B4D 08         mov     ecx, dword ptr [ebp+8]
    ' 00401144    F0:0FC101       lock xadd dword ptr [ecx], eax
    ' 00401148    40              inc     eax
    ' 00401149    59              pop     ecx
    ' 0040114A    C9              leave
    ' 0040114B    C2 0400         retn    4
    ' 51 B8 01 00 00 00 8B 4D 08 F0 0F C1 01 40 59 C9 C2 04 00
    置入代码 ({ 81, 184, 1, 0, 0, 0, 139, 77, 8, 240, 15, 193, 1, 64, 89, 201, 194, 4, 0 })
    返回 (0)
    ' 004034A8    F0:FF00               lock inc dword ptr [eax]

.子程序 递减, 整数型, , 对提供的整数型变量值-1,注意:不支持字节型,短整数型,长整数型等的操作
    .参数 整数变量, 整数型, 参考, 此参数必须为整数型变量,会被-1保存回去.显示为符号整数型

    ' 0040113B    51              push    ecx
    ' 0040113C    B8 FFFFFFFF     mov     eax, -1
    ' 00401141    8B4D 08         mov     ecx, dword ptr [ebp+8]
    ' 00401144    F0:0FC101       lock xadd dword ptr [ecx], eax
    ' 00401148    48              dec     eax
    ' 00401149    59              pop     ecx
    ' 0040114A    C9              leave
    ' 0040114B    C2 0400         retn    4
    ' 51 B8 FF FF FF FF 8B 4D 08 F0 0F C1 01 48 59 C9 C2 04 00
    置入代码 ({ 81, 184, 255, 255, 255, 255, 139, 77, 8, 240, 15, 193, 1, 72, 89, 201, 194, 4, 0 })
    返回 (0)
    ' 004034A8    F0:FF08               lock dec dword ptr [eax]

.子程序 转换_转数据大小为标准显示, 文本型, 公开, '最高支持pb位 以科学的方式显示文件大小 不清楚在32位下的反应 注意返回虽然是kbtb什么的 但实际是kib mib 进制为1024 1000是标准的kb mb的进制位 KiB  一共四种 1Kb表示1000个bit 1Kib表示1024个bit 1KB表示1000个Byte字节 KiB表示1024个Byte字节
    .参数 b, 文本型, , ‘文本型的b大小 不是bit比特 是Byte字节 如取文件大小返回的就是byte
    .局部变量 小数文本, 双精度小数型
    .局部变量 预处理数, 双精度小数型

    ' 源码采纳地址：https://bbs.125.la/thread-14311769-1-1.html
    ' 1024=1kb
    ' 1048576=1mb
    ' 1073741824=1gb
    ' 1099511627776=1tb
    ' 1.1259e+15=1pb
    ' 1024  kb
    ' 1024*1024 mb
    ' 1024*1024*1024 gb
    ' 1024*1024*1024*1024 tb
    ' 1024*1024*1024*1024*1024 pb
    ' 1024*1024*1024*1024*1024*1024 eb
    ' 先判断是否大于 大于则按文本处理转换后返回
    .如果真 (取文本长度 (b) ＞ 19 或 到整数 (取文本左边 (b, 10)) ＞ 9223372036 或 到整数 (取文本右边 (b, 9)) ＞ 854775807) ' 超过小数最大尾数会出错 或处理结果超过最大长整数
        .如果 (取文本长度 (b) ＝ 19) ' 如果是19位但超过了最大长整数就除10处理 文本处理方式
            小数文本 ＝ 到数值 (取文本左边 (b, 18) ＋ “.” ＋ 取文本右边 (b, 1))
            预处理数 ＝ 小数文本 ÷ 1024 ÷ 1024 ÷ 1024 ÷ 1024 ÷ 1024 ÷ 1024
            返回 (到文本 (四舍五入 (预处理数 × 10, 2)) ＋ “eb”)
        .否则
            小数文本 ＝ 到数值 (取文本左边 (b, 19) ＋ “.” ＋ 取文本右边 (b, 取文本长度 (b) － 19)) ' 转换到双精度小数型
            预处理数 ＝ 小数文本 ÷ 1024 ÷ 1024 ÷ 1024 ÷ 1024 ÷ 1024 ÷ 1024
            .计次循环首 (取文本长度 (b) － 19, )
                预处理数 ＝ 预处理数 × 10
            .计次循环尾 ()
            返回 (到文本 (四舍五入 (预处理数, 2)) ＋ “eb”)
        .如果结束
        
    .如果真结束
    ' 正式按整数处理
    .如果真 (到长整数 (b) ＜ 1024) ' 小于这个则为  b
        返回 (b ＋ “b”)
    .如果真结束
    .如果真 (到长整数 (b) ＜ 1048576) ' 小于这个则为  kb
        返回 (到文本 (四舍五入 (到长整数 (b) ÷ 1024, 2)) ＋ “kb”)
    .如果真结束
    .如果真 (到长整数 (b) ＜ 1073741824) ' 小于这个则为 mb
        返回 (到文本 (四舍五入 (到长整数 (b) ÷ 1024 ÷ 1024, 2)) ＋ “mb”)
    .如果真结束
    .如果真 (到长整数 (b) ＜ 1099511627776) ' 小于这个则为  gb
        返回 (到文本 (四舍五入 (到长整数 (b) ÷ 1024 ÷ 1024 ÷ 1024, 2)) ＋ “gb”)
    .如果真结束
    .如果真 (到长整数 (b) ＜ 1.1259e+015) ' 小于这个则为  tb
        返回 (到文本 (四舍五入 (到长整数 (b) ÷ 1024 ÷ 1024 ÷ 1024 ÷ 1024, 2)) ＋ “tb”)
    .如果真结束
    .如果真 (到长整数 (b) ＜ 1.1529e+018) ' 小于这个则为  pb
        返回 (到文本 (四舍五入 (到长整数 (b) ÷ 1024 ÷ 1024 ÷ 1024 ÷ 1024 ÷ 1024, 2)) ＋ “pb”)
    .如果真结束
    返回 (到文本 (四舍五入 (到长整数 (b) ÷ 1024 ÷ 1024 ÷ 1024 ÷ 1024 ÷ 1024 ÷ 1024, 2)) ＋ “eb”)

.子程序 控制台_快速编辑模式, , 公开, 禁用快速编辑模式可以防止鼠标点击暂停控制台程序
    .参数 参_是否禁止, 逻辑型, 可空, 默认禁止
    .局部变量 局_句柄, 整数型
    .局部变量 局_标志值, 整数型

    局_句柄 ＝ GetStdHandle (-10)
    GetConsoleMode (局_句柄, 取变量地址_整数 (局_标志值))
    .如果真 (是否为空 (参_是否禁止))
        参_是否禁止 ＝ 真
    .如果真结束
    .如果 (参_是否禁止)
        局_标志值 ＝ 位与 (局_标志值, 位取反 (位与 (2147483647, 96)))
    .否则
        局_标志值 ＝ 位或 (局_标志值, 96)
    .如果结束
    SetConsoleMode (局_句柄, 局_标志值)
    

.子程序 控制台_添加回调函数, 逻辑型, 公开, 控制台进程使用此函数来处理进程接收的控制信号
    .参数 接收信号的处理函数, 子程序指针, , BOOL CtrlTypeProc(DWORD CtrlType);

    返回 (SetConsoleCtrlHandler (到整数 (接收信号的处理函数), 真)) ' CTRL_*

.子程序 CtrlTypeProc, 逻辑型
    .参数 CtrlType, 整数型

    .如果真 (CtrlType ＝ #CTRL_CLOSE_EVENT)
        输出调试文本 (“控制台程序关闭”)
    .如果真结束
    返回 (假)

.子程序 取错误信息文本_API, 文本型, 公开, GetLastError
    .参数 错误码, 整数型, 可空
    .参数 模块名, 文本型, 可空
    .局部变量 nSize, 整数型
    .局部变量 Buffer, 文本型
    .局部变量 hlocal, 整数型
    .局部变量 dwError, 整数型
    .局部变量 hModule, 整数型
    .局部变量 isFree, 逻辑型
    .局部变量 isModule, 整数型

    .如果 (是否为空 (错误码))
        dwError ＝ _GetLastError ()
    .否则
        dwError ＝ 错误码
    .如果结束
    .如果真 (模块名 ≠ “”)
        hModule ＝ GetModuleHandleA (模块名)
        .如果真 (hModule ＝ 0)
            hModule ＝ LoadLibraryA (模块名)
            isFree ＝ hModule ≠ 0
        .如果真结束
        isModule ＝ 选择 (hModule ≠ 0, #FORMAT_MESSAGE_FROM_HMODULE, 0)
    .如果真结束
    nSize ＝ FormatMessageA (位或 (#FORMAT_MESSAGE_FROM_SYSTEM, #FORMAT_MESSAGE_IGNORE_INSERTS, #FORMAT_MESSAGE_ALLOCATE_BUFFER, isModule), hModule, dwError, #NULL, 取指针整数_ (hlocal), 0, #NULL)
    .如果真 (isFree)
        FreeLibrary (hModule)
    .如果真结束
    .如果真 (nSize ＞ 0)
        Buffer ＝ 取空白文本 (nSize)
        RtlMoveMemory (取指针_文本型 (Buffer), hlocal, nSize)
        LocalFree (hlocal)
        返回 (“错误码：” ＋ 到文本 (dwError) ＋ “│” ＋ 删首尾空 (Buffer))
    .如果真结束
    返回 (“找不到信息！”)

.子程序 类_取内部方法地址, 整数型, 公开, 返回方法地址，只能类内部使用
    .参数 方法序号, 整数型, , 方法序号,从1开始,_初始化是1,_销毁是2
    .局部变量 方法地址, 整数型

    ' 方法地址 ＝ HeapAlloc (GetProcessHeap (), 0, 14)
    方法地址 ＝ VirtualAlloc (0, 4096, #MEM_COMMIT, #PAGE_EXECUTE_READWRITE)
    置入代码 ({ 139, 69, 0, 139, 64, 8, 139, 200, 139, 93, 8, 75, 107, 219, 4, 139, 0, 139, 0, 3, 195, 139, 24, 139, 69, 252, 102, 199, 0, 91, 184, 137, 88, 2, 198, 64, 6, 104, 137, 72, 7, 102, 199, 64, 11, 83, 255, 198, 64, 13, 224 })
    返回 (方法地址)

.子程序 类_释放内部方法地址, 逻辑型, 公开
    .参数 方法地址, 整数型, , 取类内部方法地址（）的返回值

    ' 返回 (HeapFree (GetProcessHeap (), 0, 方法地址) ≠ 0)
    返回 (VirtualFree (方法地址, 0, #MEM_RELEASE) ≠ 0)

.子程序 整数转浮点数, 文本型, 公开, 整数数值转为十六进制浮点数文本带空格
    .参数 局_整数参数, 整数型, , 整数参数
    .局部变量 局_浮点数, 双精度小数型
    .局部变量 局_浮点数据地址, 整数型
    .局部变量 局_汇编转进制, 汇编类
    .局部变量 局_浮点数字节集, 字节集

    局_浮点数 ＝ 到数值 (局_整数参数)
    局_浮点数据地址 ＝ 取变量地址_整数 (局_浮点数)
    局_浮点数字节集 ＝ 指针到字节集 (局_浮点数据地址, 8)
    返回 (局_汇编转进制.转为十六进制 (局_浮点数字节集))

.子程序 __set, 整数型, 公开, 请确保指针的合法性,写到内存
    .参数 lpAddr, 整数型, , 内存地址
    .参数 offset, 整数型, , 偏移
    .参数 value, 整数型, , 写入值

    置入代码 ({ 139, 93, 8, 139, 77, 12, 139, 4, 25, 139, 85, 16, 137, 20, 25, 201, 194, 12, 0 })
    ' mov ebx,[ebp+8]
    ' mov ecx,[ebp+12]
    ' mov eax,[ebx+ecx]
    ' mov edx,[ebp+16]
    ' mov [ebx+ecx],edx
    ' leave
    ' ret 12
    返回 (0)

.子程序 __get, 整数型, 公开, 请确保指针的合法性,读取内存
    .参数 lpAddr, 整数型, , 内存地址
    .参数 offset, 整数型, , 偏移

    置入代码 ({ 139, 69, 8, 139, 93, 12, 139, 4, 24, 201, 194, 8, 0 })
    ' mov eax,[ebp+8]
    ' mov ebx,[ebp+12]
    ' mov eax,[eax+ebx]
    ' leave
    ' ret 8
    返回 (0)

.子程序 __query_bit, 逻辑型, 公开, 查询一个整数 32位中的某一位是否为 1  @福仔
    .参数 num, 整数型
    .参数 bit, 字节型, , 只支持 0 - 31, 越界返回假

    置入代码 ({ 138, 77, 12, 51, 192, 128, 249, 32, 115, 14, 139, 69, 8, 133, 192, 116, 7, 51, 219, 67, 211, 227, 35, 195, 201, 194, 8, 0 })
    ' mov cl, [ebp+12]
    ' xor eax,eax
    ' cmp cl, 32
    ' jae exit    ; 位数大于等于32则返回
    ' mov eax, [ebp+8]
    ' test eax,eax
    ' jz exit     ; 参数1位0返回0
    ' mov ebx, 1
    ' shl ebx, cl
    ' and eax, ebx
    ' exit:
    ' leave
    ' ret 8
    
    ' 返回 (位与 (a, 左移 (1, offset)) ≠ 0)' 与上面的汇编效果差不多
    返回 (假)

.子程序 __set_bit_on, 整数型, 公开, 设置一个整数 32位中的某一位为1, 返回设置后的值  @福仔
    .参数 num, 整数型
    .参数 bit, 字节型, , 只支持 0 - 31, 越界返回0

    置入代码 ({ 138, 77, 12, 51, 192, 128, 249, 32, 115, 10, 139, 69, 8, 51, 219, 67, 211, 227, 11, 195, 201, 194, 8, 0 })
    ' mov cl,[ebp+12]
    ' xor eax, eax
    ' cmp cl, 32
    ' jae exit
    ' mov eax,[ebp+8]
    ' xor ebx,ebx
    ' inc ebx
    ' shl ebx, cl
    ' or eax, ebx
    ' exit:
    ' leave
    ' ret 8
    返回 (0)

.子程序 __set_bit_off, 整数型, 公开, 设置一个整数 32位中的某一位为0, 返回设置后的值  @福仔
    .参数 num, 整数型
    .参数 bit, 字节型, , 只支持 0 - 31, 越界返回0

    置入代码 ({ 138, 77, 12, 51, 192, 128, 249, 32, 115, 12, 139, 69, 8, 51, 219, 67, 211, 227, 247, 211, 35, 195, 201, 194, 8, 0 })
    ' mov cl,[ebp+12]
    ' xor eax, eax
    ' cmp cl, 32
    ' jae exit
    ' mov eax,[ebp+8]
    ' xor ebx,ebx
    ' inc ebx
    ' shl ebx, cl
    ' not ebx
    ' and eax, ebx
    ' exit:
    ' leave
    ' ret 8
    返回 (0)

.子程序 __make_list, 整数型, , 根据上一个函数栈地址生成一个list数据, 返回的数据需要调用free释放
    .局部变量 ebp, 整数型
    .局部变量 list, 整数型
    .局部变量 i, 整数型
    .局部变量 offset, 整数型
    .局部变量 pAddr, 整数型
    .局部变量 data, 整数型
    .局部变量 size, 整数型
    .局部变量 len, 整数型

    ebp ＝ 0
    置入代码 ({ 62, 139, 69, 0, 62, 137, 69, 252 })
    ' mov eax, dword ptr ds:[ebp]
    ' mov dword ptr ds:[ebp-4], eax
    .如果真 (ebp ＝ 0)
        返回 (0)
    .如果真结束
    ebp ＝ ebp ＋ 12 ' 指向第一个参数
    list ＝ malloc (200) ' 缓冲区给大点无所谓
    .计次循环首 (20, i)
        ' 这里的ebp结构为,每个成员占4字节
        ' 有可空标志的在栈里占用8个字节,前4个是参数,后4个标记是否为空,1为非空 0为空
        ' +0 参数地址
        ' +4 参数是否不为空, 1=不为空, 0=为空
        offset ＝ (i － 1) × 8
        .如果真 (__get (ebp, offset ＋ 4) ＝ 0) ' 参数为空,不继续取后面的参数
            跳出循环 ()
        .如果真结束
        ' 走到这里表示参数不为空,取出参数的栈地址
        pAddr ＝ __get (ebp, offset) ' 这里取到的是栈地址
        data ＝ __get (pAddr, 0) ' 如果这个数据恰巧是整数, 而且也是一个指针, 那就会误判了
        ' .如果真 (IsBadCodePtr (data) ＝ 假) ' 指针有效, 有效就校验里面的数据, 数组格式是n,0,0,0, 字节集就是字节数组
            ' ' 没法获取变量数据类型, 只能用第一个成员来判断是否为数组/字节集
            ' len ＝ __get (data, 0)
            ' 如果真 (len ＜ 10)  ' 最多10维数组
            ' data ＝ data ＋ len × 4 ＋ 4  ' 指向数据起始位置, len=维数
            
            
        ' .如果真结束
        __set (list, (i － 1) × 4, data) ' 把参数数据写入参数列表里
    .计次循环尾 ()
    返回 (list)

.子程序 __set_byte, 整数型, 公开, 请确保指针的合法性,写到内存
    .参数 lpAddr, 整数型, , 内存地址
    .参数 offset, 整数型, , 偏移
    .参数 value, 字节型, , 写入值

    置入代码 ({ 139, 93, 8, 139, 77, 12, 139, 4, 11, 138, 85, 16, 136, 20, 11, 201, 194, 12, 0 })
    ' mov ebx,[ebp+8]
    ' mov ecx,[ebp+12]
    ' mov eax,[ecx+ebx]
    ' mov dl,[ebp+16]
    ' mov [ecx+ebx],dl
    ' leave
    ' ret 12
    返回 (0)

.子程序 __get_byte, 字节型, 公开, 请确保指针的合法性,读取内存
    .参数 lpAddr, 整数型, , 内存地址
    .参数 offset, 整数型, , 偏移

    置入代码 ({ 139, 69, 8, 139, 93, 12, 139, 4, 24, 201, 194, 8, 0 })
    ' mov eax,[ebp+8]
    ' mov ebx,[ebp+12]
    ' mov eax,[eax+ebx]
    ' leave
    ' ret 8
    返回 (0)

.子程序 __get_bytes, 字节集, 公开, 请确保指针的合法性,读取内存
    .参数 lpAddr, 整数型, , 内存地址

    置入代码 ({ 139, 69, 8, 139, 88, 252, 131, 232, 8, 201, 194, 4, 0 })
    ' mov eax, [ebp+08h]
    ' mov ebx, [eax-04h]
    ' sub eax, 08h
    ' leave
    ' retn 0004h
    返回 ({ })

.子程序 __get_int64, 长整数型, 公开, 请确保指针的合法性,读取内存
    .参数 arg1, 整数型
    .参数 arg2, 整数型

    置入代码 ({ 139, 93, 8, 133, 219, 116, 10, 139, 77, 12, 139, 84, 11, 4, 139, 4, 11, 201, 194, 8, 0 })
    ' mov ebx, dword [ebp+08h]
    ' test ebx, ebx
    ' je label1
    ' mov ecx, dword [ebp+0Ch]
    ' mov edx, dword [ebx+ecx+04h]
    ' mov eax, dword [ebx+ecx]
    ' label1:
    ' leave
    ' retn 08h
    返回 (0)

.子程序 __get_ptr, 通用型, 公开, 子程序指针
    .参数 arg1, 整数型

    置入代码 ({ 185, 6, 0, 0, 128, 139, 69, 8, 201, 194, 4, 0 })
    ' mov ecx, 80000006h
    ' mov eax, dword [ebp+8]
    ' leave
    ' retn 4h
    返回 (0)

.子程序 __memcpy, 整数型
    .参数 _Dst, 整数型, , 目标指针
    .参数 _Src, 整数型, , 源指针
    .参数 _Size, 整数型, , 拷贝长度

    置入代码 ({ 139, 77, 16, 139, 116, 36, 12, 139, 124, 36, 8, 139, 193, 139, 215, 193, 233, 2, 243, 165, 139, 200, 139, 194, 131, 225, 3, 243, 164, 201, 194, 12, 0 })
    返回 (0)

.子程序 CallObject, 整数型, 公开, 调用对象
    .参数 对象指针, 整数型
    .参数 方法索引, 整数型
    .参数 附加参数1, 整数型, 可空
    .参数 附加参数2, 整数型, 可空
    .参数 附加参数3, 整数型, 可空
    .参数 附加参数4, 整数型, 可空
    .参数 附加参数5, 整数型, 可空
    .参数 附加参数6, 整数型, 可空
    .参数 附加参数7, 整数型, 可空
    .参数 附加参数8, 整数型, 可空
    .参数 附加参数9, 整数型, 可空
    .局部变量 pThis, 整数型

    .如果真 (取反 (IsBadReadPtr (对象指针, 4)))
        指针到变量 (对象指针, pThis)
        .如果真 (取反 (IsBadCodePtr (pThis)))
            返回 (调用子程序_ (__get (pThis, 方法索引 × 4), 对象指针, 附加参数1, 附加参数2, 附加参数3, 附加参数4, 附加参数5, 附加参数6, 附加参数7, 附加参数8, 附加参数9))
        .如果真结束
        
    .如果真结束
    返回 (0)

.子程序 SafeRelease, 整数型, 公开, 释放对象,调用对象的第二个方法
    .参数 pObj, 整数型, 参考, 释放后把原来的对象清0
    .局部变量 index, 整数型
    .局部变量 pThis, 整数型
    .局部变量 ret, 整数型

    .如果真 (pObj ≠ 0)
        ret ＝ CallObject (pObj, 2, , , , , , , , , ) ' 调用对象的第二个方法
        pObj ＝ 0
    .如果真结束
    返回 (ret)
    ' index ＝ 2   '精易模块的调用方法,应该都一样,这个变量请放在第一个位置,还有参数的参考要去掉
    ' 置入代码 ({ 139, 69, 8, 139, 0, 107, 77, 252, 4, 3, 193, 131, 196, 4, 93, 255, 32 })
    ' 返回 (0)

.子程序 调用子程序_, 整数型, 公开, call
    .参数 调用地址, 整数型
    .参数 参数1, 整数型, 可空
    .参数 参数2, 整数型, 可空
    .参数 参数3, 整数型, 可空
    .参数 参数4, 整数型, 可空
    .参数 参数5, 整数型, 可空
    .参数 参数6, 整数型, 可空
    .参数 参数7, 整数型, 可空
    .参数 参数8, 整数型, 可空
    .参数 参数9, 整数型, 可空
    .参数 参数10, 整数型, 可空
    .参数 参数11, 整数型, 可空
    .参数 参数12, 整数型, 可空
    .参数 参数13, 整数型, 可空
    .参数 参数14, 整数型, 可空
    .参数 参数15, 整数型, 可空

    .如果真 (IsBadCodePtr (调用地址))
        返回 (0)
    .如果真结束
    置入代码 ({ 86, 190, 15, 0, 0, 0, 141, 77, 8, 141, 76, 241, 252, 139, 65, 4, 133, 192, 116, 2, 255, 49, 78, 131, 233, 8, 133, 246, 117, 239, 255, 85, 8, 94, 201, 194, 124, 0 })
    返回 (0)

.子程序 调用子程序x64_, 整数型, 公开, call
    .参数 调用地址, 整数型
    .参数 参数1, 长整数型, 可空
    .参数 参数2, 长整数型, 可空
    .参数 参数3, 长整数型, 可空
    .参数 参数4, 长整数型, 可空
    .参数 参数5, 长整数型, 可空
    .参数 参数6, 长整数型, 可空
    .参数 参数7, 长整数型, 可空
    .参数 参数8, 长整数型, 可空
    .参数 参数9, 长整数型, 可空
    .参数 参数10, 长整数型, 可空
    .参数 参数11, 长整数型, 可空
    .参数 参数12, 长整数型, 可空
    .参数 参数13, 长整数型, 可空
    .参数 参数14, 长整数型, 可空
    .参数 参数15, 长整数型, 可空

    置入代码 ({ 86, 190, 15, 0, 0, 0, 107, 246, 12, 141, 77, 8, 141, 76, 49, 252, 139, 65, 4, 133, 192, 116, 5, 255, 49, 255, 113, 252, 131, 238, 12, 131, 233, 12, 133, 246, 117, 234, 255, 85, 8, 94, 201, 194, 184, 0 })
    ' push esi
    ' mov esi, 0Fh
    ' imul esi, esi, 0Ch
    ' lea ecx, dword [ebp+08h]
    ' lea ecx, dword [ecx+esi-04h]
    ' label1:
    ' mov eax, dword [ecx+04h]
    ' test eax, eax
    ' je label2
    ' push dword [ecx]
    ' push dword [ecx-04h]
    ' label2:
    ' sub esi, 0Ch
    ' sub ecx, 0Ch
    ' test esi, esi
    ' jne label1
    ' call dword [ebp+08h]
    ' pop esi
    ' leave
    ' retn 0B8h
    返回 (0)

.子程序 取数据_通用型, 整数型, 公开, 取到的是变量在堆中的地址,和 取变量数据地址() 一样,注意: 字节集数据需要+8,前8位是标准,字节集型数据建议使用 取指针_字节集型()
    .参数 数据, 通用型, 参考, 不建议传递字节集型变量

    置入代码 ({ 139, 69, 8, 139, 0, 201, 194, 4, 0 })
    返回 (0)

.子程序 取指针_通用型, 整数型, 公开, 取到的是变量在栈中的地址,和 取变量地址() 一样
    .参数 变量, 通用型, 参考, 基本支持所有类型

    置入代码 ({ 139, 69, 8, 201, 194, 4, 0 })
    返回 (0)

.子程序 取指针_通用型_数组, 整数型, 公开, 取到的是变量在栈中的地址,和 取变量地址() 一样
    .参数 变量, 通用型, 参考 数组

    置入代码 ({ 139, 69, 8, 201, 194, 4, 0 })
    返回 (0)

.子程序 取指针_文本型, 整数型, 公开, 取到的是变量在堆中的地址,和 取变量数据地址() 一样
    .参数 文本, 文本型, 参考

    置入代码 ({ 139, 69, 8, 139, 0, 201, 194, 4, 0 })
    返回 (0)

.子程序 取指针_字节集型, 整数型, 公开, 取到的是变量堆地址,和 取变量数据地址() 一样
    .参数 字节集, 字节集, 参考

    置入代码 ({ 139, 69, 8, 139, 0, 133, 192, 15, 132, 3, 0, 0, 0, 131, 192, 8, 201, 194, 4, 0 })
    返回 (0)
    

.子程序 取数据_通用型_数组, 整数型, 公开, 取到的是变量在堆中的地址,和 取变量数据地址() 一样
    .参数 数据, 通用型, 参考 数组, 基本支持所有类型

    置入代码 ({ 139, 69, 8, 139, 0, 133, 192, 116, 10, 139, 24, 193, 227, 2, 131, 192, 4, 1, 216, 201, 194, 4, 0 })
    返回 (0)

.子程序 指针到变量, , 公开, 本函数用于指针转基本数据类型.(字节,短整数,整数,小数,逻辑,子程序指针).请确保指针的合法性
    .参数 指针, 整数型
    .参数 变量, 通用型, 参考

    置入代码 ({ 139, 93, 8, 139, 69, 12, 255, 51, 143, 0, 201, 194, 8, 0 })

.子程序 指针转移, 整数型, 公开, 设置将第一个参数转移到第二个同类型的变量去处理,此时操作第二个变量相当于操作第一个变量,功能类似于核心库的 事件转移(),成功返回还原指针时需要的地址,调用此函数后在必须调用 指针还原() 来还原指针,否则90%以上的几率会崩溃,调用后在没有还原指针之前不能操作第一个变量
    .参数 源指针, 整数型, , 被操作的指针,一般是exe传给dll的,这里不能传递变量数据地址,使用特殊库的 取变量地址() 获取的值
    .参数 转移到, 整数型, , 把源指针转移到这里,这样操作这个变量相当于操作源变量,这里不能传递变量数据地址,使用特殊库的 取变量地址() 获取的值
    .局部变量 pMem, 整数型

    pMem ＝ 指针_到整数 (转移到) ' 记录第二个变量原来的数据地址,在还原时要把这个地址还原回去
    __set (转移到, 0, 指针_到整数 (源指针)) ' 把源指针放到局部变量里,让局部变量指向源指针
    返回 (pMem)
    

.子程序 指针还原, , 公开, 调用此函数前必须先调用 指针转移() 
    .参数 源指针, 整数型, , 被操作的指针,一般是exe传给dll的,这里不能传递变量数据地址,使用特殊库的 取变量地址() 获取的值
    .参数 转移到, 整数型, , 把源指针转移到这里,这样操作这个变量相当于操作源变量,这里不能传递变量数据地址,使用特殊库的 取变量地址() 获取的值
    .参数 还原指针, 整数型, , 指针转移() 函数返回的指针

    __set (源指针, 0, 指针_到整数 (转移到)) ' 因为操作后局部变量的指针会发生改变,所以要重新取一下地址,放到源指针里,这样的话源指针指向的是局部变量修改后的地址
    __set (转移到, 0, 还原指针) ' 把原来的局部变量数据还原,因为局部变量在子程序执行完后会释放,把原来的指针还回去,让他释放原来的指针

.子程序 A2W_指针, 整数型, , 返回的指针需要释放
    .参数 A, 整数型, , 窄字符指针
    .参数 Alen, 整数型, , 窄字符长度(如需返回0,0结尾的传入Alen+1)或者-1
    .参数 CodePage, 整数型, , #CP_
    .参数 Wlen, 整数型, 参考, 宽字符长度
    .局部变量 W, 整数型

    连续赋值 (0, Wlen)
    Wlen ＝ MultiByteToWideChar (CodePage, 0, A, Alen, W, 0)
    W ＝ HeapAlloc (GetProcessHeap (), #HEAP_ZERO_MEMORY, Wlen × 2)
    .如果真 (W ＝ 0)
        返回 (0)
    .如果真结束
    MultiByteToWideChar (CodePage, 0, A, Alen, W, Wlen)
    返回 (W)

.子程序 W2A_指针, 整数型, , 返回的指针需要释放
    .参数 W, 整数型, , 宽字符指针
    .参数 Wlen, 整数型, , 宽字符长度
    .参数 CodePage, 整数型, , #CP_
    .参数 Alen, 整数型, 参考, 窄字符长度
    .局部变量 A, 整数型

    连续赋值 (0, Alen)
    Alen ＝ WideCharToMultiByte (CodePage, 0, W, Wlen, 0, 0, 0, 0)
    A ＝ HeapAlloc (GetProcessHeap (), #HEAP_ZERO_MEMORY, Alen)
    .如果真 (A ＝ 0)
        返回 (0)
    .如果真结束
    WideCharToMultiByte (CodePage, 0, W, Wlen, A, Alen, 0, 0)
    返回 (A)

.子程序 SEH_安装简单SEH, 逻辑型, 公开, 如果真(SEH_简单SEH())   配对函数 SEH_删除SEH()
    .参数 保留参数, 子程序指针, 可空

    保留参数 ＝ &SEH_简单SEH接口
    ' 0042866B    8B45 08               mov     eax, dword ptr [ebp+8]           ; EAX=简单SEH接口
    ' 0042866E    C9                    leave                                    ; 平衡堆栈
    ' 0042866F    83EC 60               sub     esp, 60                          ; 申请浮点寄存器
    ' 00428672    9C                    pushfd                                   ; 保存标志寄存器
    ' 00428673    60                    pushad                                   ; 保存通用寄存器
    ' 00428674    FFB424 84000000       push    dword ptr [esp+84]               ; 保存安装返回
    ' 0042867B    6A 00                 push    0                                ; 保存用户接口
    ' 0042867D    50                    push    eax                              ; SEH_接口
    ' 0042867E    DD7424 30             fsave   (108-byte) ptr [esp+30]          ; 备份浮点寄存器
    ' 77EC2FD4    9B                    wait
    ' 00428682    64:FF35 00000000      push    dword ptr fs:[0]                 ; 保存 原SEH栈
    ' 00428689    64:8925 00000000      mov     dword ptr fs:[0], esp            ; 设置 现SEH栈
    ' 00428690    B8 01000000           mov     eax, 1                           ; EAX=1=安装成功
    ' 00428695    FF6424 0C             jmp     dword ptr [esp+C]                ; 安装 SEH 返回
    ' 8B 45 08 C9 83 EC 60 9C 60 FF B4 24 84 00 00 00 6A 00 50 DD 74 24 30 9B 64 FF 35 00 00 00 00 64 89
    ' 25 00 00 00 00 B8 01 00 00 00 FF 64 24 0C
    置入代码 ({ 139, 69, 8, 201, 131, 236, 96, 156, 96, 255, 180, 36, 132, 0, 0, 0, 106, 0, 80, 221, 116, 36, 48, 155, 100, 255, 53, 0, 0, 0, 0, 100, 137, 37, 0, 0, 0, 0, 184, 1, 0, 0, 0, 255, 100, 36, 12 })
    返回 (真)

.子程序 SEH_简单SEH接口, 整数型, 公开, 该子程序供  如果真(SEH_安装简单SEH(&SEH_SEH简单处理))  使用
    .参数 异常代码, 整数型
    .参数 堆栈结构, 整数型
    .参数 线程环境, 整数型
    .参数 调度环境, 整数型, , DispatcherContext

    ' 00401095    8B45 08                mov     eax, dword ptr [ebp+8]           ; 接口 参数1 异常结构
    ' 00401098    8138 250000C0          cmp     dword ptr [eax], C0000025        ; 不可处理异常?
    ' 0040109E    74 45                  je      short 004010E5                   ; 不可处理  跳
    ' 004010A0    8378 04 00             cmp     dword ptr [eax+4], 0             ; 可处理异常?
    ' 004010A4    75 3F                  jnz     short 004010E5                   ; 不可处理 跳
    ' 004010A6    E8 00000000            call    004010AB                         ; 计算2次处理偏移
    ' 004010AB    58                     pop     eax                              ; 计算2次处理偏移
    ' 004010AC    83C0 06                add     eax, 6                           ; 计算2次处理偏移
    ' 004010AF    EB 1C                  jmp     short 004010CD                   ; 转到1次处理
    ' 004010B1    64:8925 00000000       mov     dword ptr fs:[0], esp            ; 2次处理代码
    ' 004010B8    83C4 10                add     esp, 10                          ; 2次处理代码
    ' 004010BB    61                     popad                                    ; 2次处理代码
    ' 004010BC    9D                     popfd                                    ; 2次处理代码
    ' 004010BD    DD2424                 frstor  (108-byte) ptr [esp]             ; 2次处理代码
    ' 77EC2FD4    9B                     wait
    ' 004010C0    64:8B25 00000000       mov     esp, dword ptr fs:[0]            ; 2次处理代码
    ' 004010C7    33C0                   xor     eax, eax                         ; 2次处理  安装假
    ' 004010C9    FF6424 0C              jmp     dword ptr [esp+C]                ; 2次处理完成返回
    ' 004010CD    51                     push    ecx                              ; 1次处理 备份ECX
    ' 004010CE    8B4D 10                mov     ecx, dword ptr [ebp+10]          ; 接口 参数3 线程环境
    ' 004010D1    8981 B8000000          mov     dword ptr [ecx+B8], eax          ; 新EIP = 2次处理
    ' 004010D7    8B45 0C                mov     eax, dword ptr [ebp+C]           ; 接口 参数2 异常堆栈
    ' 004010DA    8981 C4000000          mov     dword ptr [ecx+C4], eax          ; 新ESP =现异常栈
    ' 004010E0    59                     pop     ecx                              ; 1次处理 恢复ECX
    ' 004010E1    33C0                   xor     eax, eax                         ; EAX=0 异常已处理
    ' 004010E3    EB 05                  jmp     short 004010EA                   ; 跳到  返回
    ' 004010E5    B8 01000000            mov     eax, 1                           ; EAX=1 异常未处理
    ' 77682FDA    8945 08                mov     dword ptr [ebp+8], eax           ; 保存返回值
    
    ' 8B 45 08 81 38 25 00 00 C0 74 46 83 78 04 00 75 40 E8 00 00 00 00 58 83 C0 06 EB 1D 64 89 25 00
    ' 00 00 00 83 C4 10 61 9D DD 24 24 9B 64 8B 25 00 00 00 00 33 C0 FF 64 24 0C 51 8B 4D 10 89 81 B8
    ' 00 00 00 8B 45 0C 89 81 C4 00 00 00 59 33 C0 EB 05 B8 01 00 00 00 89 45 08
    置入代码 ({ 139, 69, 8, 129, 56, 37, 0, 0, 192, 116, 70, 131, 120, 4, 0, 117, 64, 232, 0, 0, 0, 0, 88, 131, 192, 6, 235, 29, 100, 137, 37, 0, 0, 0, 0, 131, 196, 16, 97, 157, 221, 36, 36, 155, 100, 139, 37, 0, 0, 0, 0, 51, 192, 255, 100, 36, 12, 81, 139, 77, 16, 137, 129, 184, 0, 0, 0, 139, 69, 12, 137, 129, 196, 0, 0, 0, 89, 51, 192, 235, 5, 184, 1, 0, 0, 0, 137, 69, 8 })
    返回 (异常代码)

.子程序 SEH_删除简单SEH, , 公开, 与 SEH_安装简单SEH() 配对使用
    .参数 保留参数, 子程序指针, 可空

    保留参数 ＝ &SEH_简单SEH接口
    ' 00401106    51                    push    ecx                              ; 备份 寄存器
    ' 00401107    64:8B0D 00000000      mov     ecx, dword ptr fs:[0]            ; 指向现异常栈
    ' 0040110E    81F9 FFFF0000         cmp     ecx, 0FFFF                       ; 是否有效栈址
    ' 00401114    7E 2A                 jle     short 0040113F                   ; 无效栈址 跳
    ' 00401116    8B41 04               mov     eax, dword ptr [ecx+4]           ; 获取异常接口
    ' 00401119    3B45 08               cmp     eax, dword ptr [ebp+8]           ; 判断异常接口
    ' 0040111C    74 04                 je      short 00401122                   ; 简单接口 跳
    ' 0040111E    8B09                  mov     ecx, dword ptr [ecx]             ; 下个异常栈指
    ' 00401120  ^ EB EC                 jmp     short 0040110E                   ; 继续循环判断
    ' 00401122    8B45 04               mov     eax, dword ptr [ebp+4]           ; EAX=返回地址
    ' 00401125    8BE1                  mov     esp, ecx                         ; ESP=本层SEH栈
    ' 00401127    64:8F05 00000000      pop     dword ptr fs:[0]                 ; 恢复上层SEH栈
    ' 0040112E    83C4 0C               add     esp, 0C                          ; ESP  指向备份
    ' 00401131    894424 1C             mov     dword ptr [esp+1C], eax          ; 保存返回地址
    ' 00401135    61                    popad                                    ; 恢复通用寄存器
    ' 00401136    9D                    popfd                                    ; 恢复标志寄存器
    ' 00401137    DD2424                frstor  (108-byte) ptr [esp]             ; 恢复浮点寄存器
    ' 77EC2FD4    9B                    wait
    ' 0040113A    83C4 6C               add     esp, 6C                          ; 弹掉浮点栈数据
    ' 0040113D  ^ FFE0                  jmp     eax                              ; 主要代码段返回
    ' 0040113F    59                    pop     ecx                              ; 恢复 寄存器
    ' 00401140    90                    nop                                      ; 无符合接口 返回
    ' 51 64 8B 0D 00 00 00 00 81 F9 FF FF 00 00 7E 2A 8B 41 04 3B 45 08 74 04 8B 09 EB EC 8B 45 04 8B
    ' E1 64 8F 05 00 00 00 00 83 C4 0C 89 44 24 1C 61 9D DD 24 24 9B 83 C4 6C FF E0 59 90
    
    置入代码 ({ 81, 100, 139, 13, 0, 0, 0, 0, 129, 249, 255, 255, 0, 0, 126, 42, 139, 65, 4, 59, 69, 8, 116, 4, 139, 9, 235, 236, 139, 69, 4, 139, 225, 100, 143, 5, 0, 0, 0, 0, 131, 196, 12, 137, 68, 36, 28, 97, 157, 221, 36, 36, 155, 131, 196, 108, 255, 224, 89, 144 })

.子程序 提示框, 整数型, 公开, 跟系统自带的信息框()一样，不同的是 窗口“总在最前”属性设置为真也能显示出来；
    .参数 提示信息, 文本型, 可空
    .参数 按钮, 整数型, 可空, 可空：默认为 #确认钮；0、#确认钮； 1、#确认取消钮； 2、#放弃重试忽略钮； 3、#取消是否钮； 4、#是否钮； 5、#重试取消钮；16、#错误图标； 32、#询问图标； 48、#警告图标； 64、#信息图标；524288、#文本右对齐
    .参数 窗口标题, 文本型, 可空, 可空：默认为“友情提醒”；
    .参数 父窗口句柄, 整数型, 可空, 可空:默认为自动程序
    .参数 超时时间, 整数型, 可空, 超过指定的时间后，信息框将自动关闭。可空：默认为5秒超时，单位为毫秒。
    .局部变量 局_返回值, 整数型

    ' 0、#确认钮； 1、#确认取消钮； 2、#放弃重试忽略钮； 3、#取消是否钮；     4、#是否钮； 5、#重试取消钮
    ' 16、#错误图标； 32、#询问图标； 48、#警告图标； 64、#信息图标
    ' 0、#程序等待； 4096、#系统等待
    ' 65536、#位于前台； 524288、#文本右对齐
    .如果真 (是否为空 (父窗口句柄))
        父窗口句柄 ＝ 进程_ID取窗口句柄 (GetCurrentProcessId (), , , 1000, )
    .如果真结束
    .如果真 (是否为空 (窗口标题))
        窗口标题 ＝ “友情提醒”
    .如果真结束
    .如果真 (是否为空 (按钮))
        按钮 ＝ #确认钮
    .如果真结束
    .如果真 (是否为空 (超时时间))
        超时时间 ＝ 5000
    .如果真结束
    局_返回值 ＝ MessageBoxTimeoutA (父窗口句柄, 提示信息, 窗口标题, 按钮, 0, 超时时间)
    返回 (局_返回值 － 1)

.子程序 E数据库_快速查询, , 公开, 在易数据库已打开的情况下,对某字段进行快速查询,勤快的人可把记录分成两个数组，用多线程分开查询，应该更快。把记录添加完了在显示控件，这样就快多了
    .参数 查询的字段名, 文本型, , 必须为文本型字段
    .参数 查询内容, 文本型, 可空, 可以为空,为空即为查询空记录
    .参数 返回记录号数组名, 整数型, 数组, 本数据内容将直接返回结果
    .局部变量 次数, 整数型
    .局部变量 数组, 文本型, , "3"
    .局部变量 数组1, 整数型, , "3"

    到首记录 ()
    .计次循环首 (取记录数 (), )
        加入成员 (数组, 读 (查询的字段名))
        加入成员 (数组1, 取记录号 ())
        跳过 ()
    .计次循环尾 ()
    次数 ＝ 1
    .计次循环首 (取数组成员数 (数组), 次数)
        .如果真 (数组 [次数] ＝ 查询内容)
            输出调试文本 (数组 [次数])
            加入成员 (返回记录号数组名, 数组1 [次数])
        .如果真结束
        
    .计次循环尾 ()

.子程序 E数据库_修复易数据库, 逻辑型, 公开, 修复一个被破坏的易语言数据库
    .参数 易数据库名, 文本型, , 易数据库全路径文件名
    .参数 错误信息, 文本型, 可空, 如果修复失败，返回对应的错误文本。如果本参数为空，则不记录错误信息。
    .局部变量 备份文件, 文本型
    .局部变量 记录数1, 长整数型
    .局部变量 记录数2, 长整数型
    .局部变量 文件号, 整数型
    .局部变量 可否打开, 逻辑型
    .局部变量 当前库, 文本型, , , 已经打开的当前数据库。

    ' 非正常关机时，常常可能导致易数据库损坏，其出错信息一般为：数据库尺寸错误。具体指：数据库文件头的记录数与数据库实际的记录数不相符，一般是相差一个记录（前者>后者）。所以尝试做这个模块，通过修改数据库文件头记录的记录数来修复损坏的数据库。
    ' 一开始，只是简单地修复了一下，没有成功，还以为是模块的问题，后来，看到银戒指修复的数据库，损失了6个记录，才意识到，可能损坏的数据库，其所记录的记录数与实际记录数可能相差不止一个，于是用了一个循环，果然修好了，呵呵。
    ' 在此还劝大家在使用易数据库时，使用到数据库时再打开，用完立即关闭数据库，这样可确保不会因为长时间打开数据库，一旦有断电、死机、重启等发生时产生易数据库损坏。并且要定期备份重要的数据库。
    当前库 ＝ 取当前库 () ' 取出当前数据库名称，用于修复数据库后重置当前库。
    可否打开 ＝ 打开 (易数据库名, “要用模块修复的数据库”, , , , , ) ' 使用较长的别名，是为了防止与调用模块的程序的当前库有冲突。下同。
    .如果真 (可否打开)
        关闭 (“要用模块修复的数据库”)
        置当前库 (当前库) ' 重置原来的当前数据库。
        返回 (真)
    .如果真结束
    .如果真 (取错误码 () ≠ -48)
        .如果真 (是否为空 (错误信息) ＝ 假)
            错误信息 ＝ “指定文件非数据库，或数据库损坏类型不是数据库文件尺寸错误，不能用本模块修复。”
        .如果真结束
        返回 (假)
    .如果真结束
    备份文件 ＝ 取临时文件名 ()
    复制文件 (易数据库名, 备份文件) ' 备份数据库，如果修复失败则恢复它。
    .判断循环首 (可否打开 ＝ 假) ' 循环修复，将文件头中记录的记录数递减，直到数据库能正确打开。
        文件号 ＝ 打开文件 (易数据库名, , )
        .如果真 (文件号 ＝ 0)
            .如果真 (是否为空 (错误信息) ＝ 假)
                错误信息 ＝ “读取数据库文件失败。”
                复制文件 (备份文件, 易数据库名) ' 用备份的数据库文件恢复被修改过的数据库文件。
            .如果真结束
            返回 (假)
        .如果真结束
        移动读写位置 (文件号, #文件首, 16)
        记录数1 ＝ 取字节集数据 (读入字节集 (文件号, 4), #长整数型) ' 从第17位开始读取，共4位。
        .如果真 (记录数1 ＝ 0) ' 如果经过递减，记录数为0时仍不能打开，说明修复失败，返回假。
            .如果真 (是否为空 (错误信息) ＝ 假)
                错误信息 ＝ “修复数据库未成功，原因未知。”
                复制文件 (备份文件, 易数据库名)
            .如果真结束
            返回 (假)
        .如果真结束
        移动读写位置 (文件号, #文件首, 20)
        记录数2 ＝ 取字节集数据 (读入字节集 (文件号, 4), #长整数型) ' 从第21位开始读取，共4位。
        记录数1 ＝ 记录数1 － 1 ' 记录数1递减1。
        记录数2 ＝ 记录数2 － 1 ' 记录数2递减1。
        移动读写位置 (文件号, #文件首, 16)
        写出字节集 (文件号, 取字节集左边 (到字节集 (记录数1) ＋ { 0, 0, 0, 0 }, 4)) ' 将记录数递减1，写出至数据库文件头，并确保写出字节集长度为4位，下同。
        移动读写位置 (文件号, #文件首, 20)
        写出字节集 (文件号, 取字节集左边 (到字节集 (记录数2) ＋ { 0, 0, 0, 0 }, 4)) ' 将记录数递减1，并写出至数据库文件头。
        关闭文件 (文件号)
        可否打开 ＝ 打开 (易数据库名, “要用模块修复的数据库”, , , , , )
    .判断循环尾 ()
    关闭 (“要用模块修复的数据库”)
    置当前库 (当前库) ' 重置原来的当前数据库。
    .如果真 (是否为空 (错误信息) ＝ 假)
        错误信息 ＝ “”
    .如果真结束
    返回 (真) ' 如果能跳出循环，说明打开数据库成功，数据库被修复。将其关闭后，返回真。
    

.子程序 取默认目录, 文本型
    .如果真 (目录_是否存在 (取运行目录 () ＋ “\data”) ＝ 假)
        目录_创建 (取运行目录 () ＋ “\data”)
    .如果真结束
    返回 (取运行目录 () ＋ “\data\setsoft.ini”)

.子程序 内部_对比, 逻辑型
    .参数 对比原文本, 文本型
    .参数 对比文本, 文本型
    .局部变量 局_数组, 文本型, , "0"
    .局部变量 局_计次, 整数型

    清除数组 (局_数组)
    局_数组 ＝ 分割文本 (对比原文本, “|”, )
    .计次循环首 (取数组成员数 (局_数组), 局_计次)
        .如果真 (文本比较 (局_数组 [局_计次], 对比文本, 真) ＝ 0)
            返回 (假)
        .如果真结束
        
    .计次循环尾 ()
    返回 (真)

.子程序 批量_单选框_保存配置, 整数型, 公开, 保存窗口上所有选择框的选中状态!与"批量_单选框_读取配置()"命令一起用的!  返回被操作的单选框数量!
    .参数 组件的父窗口, 窗口, , 直接填写顶级窗口就行了,如:_启动窗口
    .参数 配置文件名, 文本型, 可空, 可空:默认保存在根目录\data目录下,名为setsoft.ini
    .参数 不保存的控件名称, 文本型, 可空, 不需要自动保存数据的控件名称,以|分开;
    .局部变量 局_寻找句柄, 整数型
    .局部变量 局_计次, 整数型
    .局部变量 局_组件, 单选框
    .局部变量 局_组件数量, 整数型

    .如果真 (配置文件名 ＝ “”)
        配置文件名 ＝ 取默认目录 ()
    .如果真结束
    局_寻找句柄 ＝ 寻找组件 (组件的父窗口, , “单选框”, , )
    局_组件数量 ＝ 取找到组件数目 (局_寻找句柄)
    
    
    .计次循环首 (局_组件数量, 局_计次)
        局_组件 ＝ 取所找到组件 (局_寻找句柄, 局_计次 － 1)
        .如果真 (内部_对比 (不保存的控件名称, 取组件名称 (局_组件)))
            写配置项 (配置文件名, “单选框”, 取组件名称 (局_组件), 到文本 (局_组件.选中))
        .如果真结束
        
    .计次循环尾 ()
    清除组件寻找句柄 (局_寻找句柄)
    返回 (局_组件数量)

.子程序 批量_单选框_读取配置, 整数型, 公开, 与"批量_单选框_保存配置()"命令一起用的!  返回被操作的单选框数量!
    .参数 组件的父窗口, 窗口, , 直接填写顶级窗口就行了,如:_启动窗口
    .参数 配置文件名, 文本型, 可空, 可空:默认保存在根目录\data目录下,名为setsoft.ini
    .局部变量 局_寻找句柄, 整数型
    .局部变量 局_计次, 整数型
    .局部变量 局_组件, 单选框
    .局部变量 局_组件数量, 整数型
    .局部变量 局_临时文本, 文本型

    .如果真 (配置文件名 ＝ “”)
        配置文件名 ＝ 取默认目录 ()
    .如果真结束
    局_寻找句柄 ＝ 寻找组件 (组件的父窗口, , “单选框”, , )
    局_组件数量 ＝ 取找到组件数目 (局_寻找句柄)
    .计次循环首 (局_组件数量, 局_计次)
        局_组件 ＝ 取所找到组件 (局_寻找句柄, 局_计次 － 1)
        局_临时文本 ＝ 读配置项 (配置文件名, “单选框”, 取组件名称 (局_组件), )
        .如果真 (局_临时文本 ＝ “”)
            到循环尾 ()
        .如果真结束
        局_组件.选中 ＝ 选择 (局_临时文本 ＝ “假”, 假, 真)
    .计次循环尾 ()
    清除组件寻找句柄 (局_寻找句柄)
    返回 (局_组件数量)

.子程序 批量_选择框_保存配置, 整数型, 公开, 保存窗口上所有选择框的选中状态!与"批量_选择框_读取配置()"命令一起用的!  返回被操作的选择框数量!
    .参数 组件的父窗口, 窗口, , 直接填写顶级窗口就行了,如:_启动窗口
    .参数 配置文件名, 文本型, 可空, 可空:默认保存在根目录\data目录下,名为setsoft.ini
    .参数 不保存的控件名称, 文本型, 可空, 不需要自动保存数据的控件名称,以|分开;
    .局部变量 局_寻找句柄, 整数型
    .局部变量 局_计次, 整数型
    .局部变量 局_组件, 选择框
    .局部变量 局_组件数量, 整数型

    .如果真 (配置文件名 ＝ “”)
        配置文件名 ＝ 取默认目录 ()
    .如果真结束
    局_寻找句柄 ＝ 寻找组件 (组件的父窗口, , “选择框”, , )
    局_组件数量 ＝ 取找到组件数目 (局_寻找句柄)
    .计次循环首 (局_组件数量, 局_计次)
        局_组件 ＝ 取所找到组件 (局_寻找句柄, 局_计次 － 1)
        .如果真 (内部_对比 (不保存的控件名称, 取组件名称 (局_组件)))
            写配置项 (配置文件名, “选择框”, 取组件名称 (局_组件), 到文本 (局_组件.选中))
        .如果真结束
        
    .计次循环尾 ()
    清除组件寻找句柄 (局_寻找句柄)
    返回 (局_组件数量)

.子程序 批量_选择框_读取配置, 整数型, 公开, 与"批量_选择框_保存配置()"命令一起用的!  返回被操作的选择框数量!
    .参数 组件的父窗口, 窗口, , 直接填写顶级窗口就行了,如:_启动窗口
    .参数 配置文件名, 文本型, 可空, 可空:默认保存在根目录\data目录下,名为setsoft.ini
    .局部变量 局_寻找句柄, 整数型
    .局部变量 局_计次, 整数型
    .局部变量 局_组件, 选择框
    .局部变量 局_组件数量, 整数型
    .局部变量 局_临时文本, 文本型

    .如果真 (配置文件名 ＝ “”)
        配置文件名 ＝ 取默认目录 ()
    .如果真结束
    局_寻找句柄 ＝ 寻找组件 (组件的父窗口, , “选择框”, , )
    局_组件数量 ＝ 取找到组件数目 (局_寻找句柄)
    .计次循环首 (局_组件数量, 局_计次)
        局_组件 ＝ 取所找到组件 (局_寻找句柄, 局_计次 － 1)
        局_临时文本 ＝ 读配置项 (配置文件名, “选择框”, 取组件名称 (局_组件), )
        .如果真 (局_临时文本 ＝ “”)
            到循环尾 ()
        .如果真结束
        局_组件.选中 ＝ 选择 (局_临时文本 ＝ “假”, 假, 真)
    .计次循环尾 ()
    清除组件寻找句柄 (局_寻找句柄)
    返回 (局_组件数量)

.子程序 批量_编辑框_保存配置, 整数型, 公开, 保存窗口上所有编辑框的内容!与"批量_编辑框_读取配置()"命令一起用的!  返回被操作的编辑框数量!
    .参数 组件的父窗口, 窗口, , 直接填写顶级窗口就行了,如:_启动窗口
    .参数 配置文件名, 文本型, 可空, 可空:默认保存在根目录\data目录下,名为setsoft.ini
    .参数 不保存的控件名称, 文本型, 可空, 不需要自动保存数据的控件名称,以|分开;
    .局部变量 局_寻找句柄, 整数型
    .局部变量 局_计次, 整数型
    .局部变量 局_组件, 编辑框
    .局部变量 局_临时文本, 文本型
    .局部变量 局_组件数量, 整数型

    .如果真 (配置文件名 ＝ “”)
        配置文件名 ＝ 取默认目录 ()
    .如果真结束
    局_寻找句柄 ＝ 寻找组件 (组件的父窗口, , “编辑框”, , )
    局_组件数量 ＝ 取找到组件数目 (局_寻找句柄)
    .计次循环首 (局_组件数量, 局_计次)
        局_组件 ＝ 取所找到组件 (局_寻找句柄, 局_计次 － 1)
        .如果真 (内部_对比 (不保存的控件名称, 取组件名称 (局_组件)))
            局_临时文本 ＝ 子文本替换 (局_组件.内容, #换行符, “><br><”, , , 真)
            局_临时文本 ＝ 子文本替换 (局_临时文本, #引号, “#引号”, , , 真)
            写配置项 (配置文件名, “编辑框”, 取组件名称 (局_组件), 局_临时文本)
        .如果真结束
        
    .计次循环尾 ()
    清除组件寻找句柄 (局_寻找句柄)
    返回 (局_组件数量)

.子程序 批量_编辑框_读取配置, 整数型, 公开, 与"批量_编辑框_保存配置()"命令一起用的!  返回被操作的编辑框数量!
    .参数 组件的父窗口, 窗口, , 直接填写顶级窗口就行了,如:_启动窗口
    .参数 配置文件名, 文本型, 可空, 可空:默认保存在根目录\data目录下,名为setsoft.ini
    .局部变量 局_寻找句柄, 整数型
    .局部变量 局_计次, 整数型
    .局部变量 局_组件, 编辑框
    .局部变量 局_组件数量, 整数型
    .局部变量 局_临时文本, 文本型

    .如果真 (配置文件名 ＝ “”)
        配置文件名 ＝ 取默认目录 ()
    .如果真结束
    局_寻找句柄 ＝ 寻找组件 (组件的父窗口, , “编辑框”, , )
    局_组件数量 ＝ 取找到组件数目 (局_寻找句柄)
    .计次循环首 (局_组件数量, 局_计次)
        局_组件 ＝ 取所找到组件 (局_寻找句柄, 局_计次 － 1)
        局_临时文本 ＝ 读配置项 (配置文件名, “编辑框”, 取组件名称 (局_组件), )
        .如果真 (局_临时文本 ＝ “”)
            到循环尾 ()
        .如果真结束
        局_临时文本 ＝ 子文本替换 (局_临时文本, “><br><”, #换行符, , , 真)
        局_组件.内容 ＝ 子文本替换 (局_临时文本, “#引号”, #引号, , , 真)
    .计次循环尾 ()
    清除组件寻找句柄 (局_寻找句柄)
    返回 (局_组件数量)

.子程序 批量_组合框_保存配置, 整数型, 公开, 保存窗口上所有组合框的内容!与"批量_组合框_读取配置()"命令一起用的!  返回被操作的组合框数量!
    .参数 组件的父窗口, 窗口, , 直接填写顶级窗口就行了,如:_启动窗口
    .参数 配置文件名, 文本型, 可空, 可空:默认保存在根目录\data目录下,名为setsoft.ini
    .参数 不保存的控件名称, 文本型, 可空, 不需要自动保存数据的控件名称,以|分开;
    .局部变量 局_寻找句柄, 整数型
    .局部变量 局_计次, 整数型
    .局部变量 局_组件, 组合框
    .局部变量 局_临时文本, 文本型
    .局部变量 局_组件数量, 整数型
    .局部变量 局_组合框计次, 整数型

    .如果真 (配置文件名 ＝ “”)
        配置文件名 ＝ 取默认目录 ()
    .如果真结束
    局_寻找句柄 ＝ 寻找组件 (组件的父窗口, , “组合框”, , )
    局_组件数量 ＝ 取找到组件数目 (局_寻找句柄)
    .计次循环首 (局_组件数量, 局_计次)
        局_临时文本 ＝ “”
        局_组件 ＝ 取所找到组件 (局_寻找句柄, 局_计次 － 1)
        .如果真 (内部_对比 (不保存的控件名称, 取组件名称 (局_组件)))
            .计次循环首 (局_组件.取项目数 (), 局_组合框计次)
                局_临时文本 ＝ 局_临时文本 ＋ 局_组件.取项目文本 (局_组合框计次 － 1) ＋ “<|>” ＋ 到文本 (局_组件.取项目数值 (局_组合框计次 － 1)) ＋ “<||>”
            .计次循环尾 ()
            局_临时文本 ＝ 局_临时文本 ＋ 到文本 (局_组件.现行选中项) ＋ “<|>” ＋ 局_组件.内容
            局_临时文本 ＝ 子文本替换 (局_临时文本, #引号, “#引号”, , , 真)
            写配置项 (配置文件名, “组合框”, 取组件名称 (局_组件), 局_临时文本)
        .如果真结束
        
    .计次循环尾 ()
    清除组件寻找句柄 (局_寻找句柄)
    返回 (局_组件数量)

.子程序 批量_组合框_读取配置, 整数型, 公开, 与"批量_组合框_保存配置()"命令一起用的!  返回被操作的编辑框数量!
    .参数 组件的父窗口, 窗口, , 直接填写顶级窗口就行了,如:_启动窗口
    .参数 配置文件名, 文本型, 可空, 可空:默认保存在根目录\data目录下,名为setsoft.ini
    .局部变量 局_寻找句柄, 整数型
    .局部变量 局_计次, 整数型
    .局部变量 局_组件, 组合框
    .局部变量 局_临时文本, 文本型
    .局部变量 局_组件数量, 整数型
    .局部变量 局_组合框计次, 整数型
    .局部变量 局_临时数组, 文本型, , "0"

    .如果真 (配置文件名 ＝ “”)
        配置文件名 ＝ 取默认目录 ()
    .如果真结束
    局_寻找句柄 ＝ 寻找组件 (组件的父窗口, , “组合框”, , )
    局_组件数量 ＝ 取找到组件数目 (局_寻找句柄)
    .计次循环首 (局_组件数量, 局_计次)
        局_组件 ＝ 取所找到组件 (局_寻找句柄, 局_计次 － 1)
        局_临时文本 ＝ 读配置项 (配置文件名, “组合框”, 取组件名称 (局_组件), “”)
        局_临时文本 ＝ 子文本替换 (局_临时文本, “#引号”, #引号, , , 真)
        .如果真 (局_临时文本 ＝ “”)
            到循环尾 ()
        .如果真结束
        局_组件.清空 ()
        局_临时数组 ＝ 分割文本 (局_临时文本, “<||>”, )
        .计次循环首 (取数组成员数 (局_临时数组) － 1, 局_组合框计次)
            局_组件.加入项目 (文本_取左边 (局_临时数组 [局_组合框计次], “<|>”), 到数值 (文本_取右边 (局_临时数组 [局_组合框计次], “<|>”)))
        .计次循环尾 ()
        .如果真 (取数组成员数 (局_临时数组) ＞ 0)
            局_组件.现行选中项 ＝ 到数值 (文本_取左边 (局_临时数组 [取数组成员数 (局_临时数组)], “<|>”))
            局_组件.内容 ＝ 文本_取右边 (局_临时数组 [取数组成员数 (局_临时数组)], “<|>”)
        .如果真结束
        清除数组 (局_临时数组)
    .计次循环尾 ()
    清除组件寻找句柄 (局_寻找句柄)
    返回 (局_组件数量)

.子程序 批量_日期框_保存配置, 整数型, 公开, 保存窗口上所有日期框的内容!与"批量_日期框_读取配置()"命令一起用的!  返回被操作的日期框数量!
    .参数 组件的父窗口, 窗口, , 直接填写顶级窗口就行了,如:_启动窗口
    .参数 配置文件名, 文本型, 可空, 可空:默认保存在根目录\data目录下,名为setsoft.ini
    .参数 不保存的控件名称, 文本型, 可空, 不需要自动保存数据的控件名称,以|分开;
    .局部变量 局_寻找句柄, 整数型
    .局部变量 局_计次, 整数型
    .局部变量 局_组件, 日期框
    .局部变量 局_临时文本, 文本型
    .局部变量 局_组件数量, 整数型

    .如果真 (配置文件名 ＝ “”)
        配置文件名 ＝ 取默认目录 ()
    .如果真结束
    局_寻找句柄 ＝ 寻找组件 (组件的父窗口, , “日期框”, , )
    局_组件数量 ＝ 取找到组件数目 (局_寻找句柄)
    .计次循环首 (局_组件数量, 局_计次)
        局_临时文本 ＝ “”
        局_组件 ＝ 取所找到组件 (局_寻找句柄, 局_计次 － 1)
        .如果真 (内部_对比 (不保存的控件名称, 取组件名称 (局_组件)))
            局_临时文本 ＝ 时间到文本 (局_组件.今天, )
            写配置项 (配置文件名, “日期框”, 取组件名称 (局_组件), 局_临时文本)
        .如果真结束
        
    .计次循环尾 ()
    清除组件寻找句柄 (局_寻找句柄)
    返回 (局_组件数量)

.子程序 批量_日期框_读取配置, 整数型, 公开, 与"批量_日期框_保存配置()"命令一起用的!  返回被操作的编辑框数量!
    .参数 组件的父窗口, 窗口, , 直接填写顶级窗口就行了,如:_启动窗口
    .参数 配置文件名, 文本型, 可空, 可空:默认保存在根目录\data目录下,名为setsoft.ini
    .局部变量 局_寻找句柄, 整数型
    .局部变量 局_计次, 整数型
    .局部变量 局_组件, 日期框
    .局部变量 局_临时文本, 文本型
    .局部变量 局_组件数量, 整数型

    .如果真 (配置文件名 ＝ “”)
        配置文件名 ＝ 取默认目录 ()
    .如果真结束
    局_寻找句柄 ＝ 寻找组件 (组件的父窗口, , “日期框”, , )
    局_组件数量 ＝ 取找到组件数目 (局_寻找句柄)
    .计次循环首 (局_组件数量, 局_计次)
        局_组件 ＝ 取所找到组件 (局_寻找句柄, 局_计次 － 1)
        局_临时文本 ＝ 读配置项 (配置文件名, “日期框”, 取组件名称 (局_组件), “”)
        局_组件.今天 ＝ 到时间 (局_临时文本)
    .计次循环尾 ()
    清除组件寻找句柄 (局_寻找句柄)
    返回 (局_组件数量)

.子程序 OCX_注册, , 公开, 注册OCX组件
    .参数 OCX文件路径, 文本型

    运行 (“regsvr32 ” ＋ OCX文件路径 ＋ “ /s”, 假, 1)

.子程序 OCX_卸载, , 公开, 卸载OCX组件
    .参数 OCX文件路径, 文本型

    运行 (“regsvr32 ” ＋ OCX文件路径 ＋ “ /u”, 假, 1)

.子程序 文件拖放_回调函数, 整数型, , [文件拖放]
    .参数 hwnd, 整数型
    .参数 iMsg, 整数型
    .参数 hDrop, 整数型
    .参数 lParam, 整数型
    .局部变量 sFileName, 文本型
    .局部变量 IReturn, 整数型
    .局部变量 nCount, 整数型
    .局部变量 局_计次, 整数型
    .局部变量 数组位置, 整数型
    .局部变量 文件后缀名, 文本型
    .局部变量 局_窗口过程
    .局部变量 局_函数指针

    局_窗口过程 ＝ GetPropA (hwnd, “NewWindowsProc”)
    局_函数指针 ＝ GetPropA (hwnd, “Subaddress”)
    .判断开始 (iMsg ＝ 563)
        nCount ＝ DragQueryFileA (hDrop, -1, #NULL, 0)
        .计次循环首 (nCount, 局_计次)
            sFileName ＝ 取空白文本 (260)
            IReturn ＝ DragQueryFileA (hDrop, 局_计次 － 1, 取指针文本_ (sFileName), 260)
            .如果真 (IReturn ＞ 0)
                文件后缀名 ＝ 取文本右边 (sFileName, 取文本长度 (sFileName) － 倒找文本 (sFileName, “.”, , 假))
                CallWindowProcA (局_函数指针, nCount, 局_计次, 取指针_文本型 (sFileName), 取指针_文本型 (文件后缀名))
            .如果真结束
            
        .计次循环尾 ()
        DragFinish (hDrop)
        返回 (1)
    .默认
        
    .判断结束
    返回 (CallWindowProcA (局_窗口过程, hwnd, iMsg, hDrop, lParam))

.子程序 子_字节型数组到文本, 文本型
    .参数 字节, 字节型, 数组
    .局部变量 局_计次, 整数型
    .局部变量 局_ret, 文本型

    局_ret ＝ “”
    .计次循环首 (取数组成员数 (字节), 局_计次)
        .如果 (字节 [局_计次] ≠ 0)
            局_ret ＝ 局_ret ＋ 字符 (字节 [局_计次])
        .否则
            跳出循环 ()
        .如果结束
        
    .计次循环尾 ()
    返回 (局_ret)

.子程序 子_文本到字节型数组
    .参数 字节, 字节型, 参考 数组
    .参数 文本, 文本型
    .局部变量 局_计次, 整数型

    局_计次 ＝ 取文本长度 (文本)
    重定义数组 (字节, 假, 局_计次 ＋ 2)
    .计次循环首 (取数组成员数 (字节), 局_计次)
        字节 [局_计次] ＝ 取代码 (取文本中间 (文本, 局_计次, 1), )
    .计次循环尾 ()

.子程序 子_GetRasEntryCount, 整数型, , 获取RAS项计数
    .局部变量 局_SizeOfRasEntryName, 整数型
    .局部变量 局_Ret, 整数型
    .局部变量 局_Count, 整数型
    .局部变量 局_RasEntry, 取连接信息用结构

    局_SizeOfRasEntryName ＝ GlobalSize_取连接信息用结构 (局_RasEntry)
    局_RasEntry.内存大小 ＝ 局_SizeOfRasEntryName
    局_Ret ＝ RasEnumEntrie (0, 0, 局_RasEntry, 局_SizeOfRasEntryName, 局_Count)
    .如果 (局_Ret ＝ 603 或 局_Ret ＝ 0)
        重定义数组 (FLSAList, 假, 局_Count)
        局_Ret ＝ 局_Count
    .否则
        局_Ret ＝ 0
    .如果结束
    返回 (局_Ret)

.子程序 子_GetLSAPasswords, , , 获取LSA的密码
    .局部变量 局_PrivateData, LSA_UNICODE_STRING

    .如果真 (子_GetLsaData (4, “RasDialParams!” ＋ 子_GetLocalSid () ＋ “#0”, 局_PrivateData))
        子_ProcessLSABuffer (局_PrivateData.缓冲区, 局_PrivateData.长度)
        LsaFreeMemory (局_PrivateData.缓冲区)
    .如果真结束
    .如果真 (子_GetLsaData (4, “L$_RasDefaultCredentials#0”, 局_PrivateData))
        子_ProcessLSABuffer (局_PrivateData.缓冲区, 局_PrivateData.长度)
        LsaFreeMemory (局_PrivateData.缓冲区)
    .如果真结束
    

.子程序 子_GetLocalSid, 文本型, , 获取本地SID
    .局部变量 局_sUserName, 文本型
    .局部变量 局_iResult, 整数型
    .局部变量 局_bUserSid, 字节集
    .局部变量 局_iUserSIDSize, 整数型
    .局部变量 局_sDomainName, 文本型
    .局部变量 局_iDomainNameLength, 整数型
    .局部变量 局_iSIDType, 整数型
    .局部变量 局_sUserSid, 文本型
    .局部变量 局_hUserSid, 整数型

    局_sUserName ＝ 取空白文本 (256)
    GetUserNameA (局_sUserName, 255)
    局_bUserSid ＝ 取空白字节集 (255)
    局_iResult ＝ LookupAccountName (取空白文本 (0), 局_sUserName, 局_bUserSid, 局_iUserSIDSize, 局_sDomainName, 局_iDomainNameLength, 局_iSIDType)
    局_sDomainName ＝ 取空白文本 (局_iDomainNameLength)
    局_bUserSid ＝ 取空白字节集 (局_iUserSIDSize)
    局_iResult ＝ LookupAccountName (取空白文本 (0), 局_sUserName, 局_bUserSid, 局_iUserSIDSize, 局_sDomainName, 局_iDomainNameLength, 局_iSIDType)
    .如果真 (IsValidSid (取指针地址_字节集型 (局_bUserSid)) ＝ 0)
        返回 (“”)
    .如果真结束
    局_iResult ＝ ConvertSidToStringSid (局_bUserSid, 局_hUserSid)
    .如果真 (局_iResult ≠ 0)
        局_iResult ＝ lstrlen (局_hUserSid)
        .如果真 (局_iResult ＞ 0)
            局_sUserSid ＝ 取空白文本 (局_iResult × 2)
            局_bUserSid ＝ 取空白字节集 (局_iResult × 2)
            RtlMoveMemory (取指针地址_字节集型 (局_bUserSid), 局_hUserSid, 局_iResult × 2)
            局_sUserSid ＝ 编码_Unicode到Ansi (局_bUserSid)
        .如果真结束
        
    .如果真结束
    返回 (局_sUserSid)

.子程序 子_GetLsaData, 逻辑型, , 获取LSA的数据
    .参数 Policy, 整数型
    .参数 KeyName, 文本型
    .参数 OutData, LSA_UNICODE_STRING, 参考
    .局部变量 局_LsaObjectAttribs, LSA_OBJECT_ATTRIBUTES
    .局部变量 局_LsaHandle, 整数型
    .局部变量 局_LsaKeyName, LSA_UNICODE_STRING
    .局部变量 局_LsaPrivateData, 整数型
    .局部变量 局_status, 整数型
    .局部变量 局_temp1, 字节集
    .局部变量 局_temp2, 整数型

    .如果真 (LsaOpenPolicy (0, 局_LsaObjectAttribs, Policy, 局_LsaHandle) ＞ 0)
        返回 (假)
    .如果真结束
    子_AnsiStringToLsaStr (KeyName, 局_LsaKeyName)
    局_status ＝ LsaRetrievePrivateData (局_LsaHandle, 局_LsaKeyName, 局_LsaPrivateData)
    .如果真 (局_status ＝ 0)
        局_temp1 ＝ 指针到字节集 (局_LsaPrivateData, 8)
        RtlMoveMemory_LSA_UNICODE_STRING (OutData, 局_temp1, 8)
        局_temp1 ＝ 取字节集右边 (局_temp1, 4)
        局_temp2 ＝ 取字节集数据 (局_temp1, #整数型, )
        OutData.缓冲区 ＝ 指针到字节集 (局_temp2, OutData.长度)
        LsaClose (局_LsaHandle)
        返回 (真)
    .如果真结束
    返回 (假)

.子程序 子_AnsiStringToLsaStr, , , ANSI字符串str中的LSA
    .参数 AValue, 文本型
    .参数 LStr, LSA_UNICODE_STRING, 参考

    LStr.长度 ＝ 取文本长度 (AValue) × 2
    LStr.最大长度 ＝ LStr.长度 ＋ 2
    LStr.缓冲区 ＝ 编码_Ansi到Unicode (AValue)

.子程序 子_ProcessLSABuffer, , , LSA的缓冲过程
    .参数 Buffer, 字节集
    .参数 BufLen, 整数型
    .局部变量 局_c, 字节集
    .局部变量 局_记录, 整数型
    .局部变量 局_计次, 整数型
    .局部变量 局_SPos, 整数型
    .局部变量 局_S, 字节集
    .局部变量 局_BookID, 文本型
    .局部变量 局_用户名, 文本型
    .局部变量 局_密码, 文本型

    局_记录 ＝ 1
    .变量循环首 (1, BufLen, 2, 局_计次)
        局_c ＝ 取字节集中间 (Buffer, 局_计次, 2)
        .如果 (局_c ＝ { 0, 0 })
            局_SPos ＝ 局_SPos ＋ 1
            .判断开始 (局_SPos ＝ 1)
                局_BookID ＝ 编码_Unicode到Ansi (局_S)
            .判断 (局_SPos ＝ 6)
                局_用户名 ＝ 编码_Unicode到Ansi (局_S)
            .判断 (局_SPos ＝ 7)
                局_密码 ＝ 编码_Unicode到Ansi (局_S)
                .如果真 (取数组成员数 (FLSAList) ＜ 局_记录)
                    重定义数组 (FLSAList, 真, 局_记录)
                .如果真结束
                FLSAList [局_记录].名字 ＝ 局_BookID
                FLSAList [局_记录].值 ＝ 局_密码
                FLSAList [局_记录].用户 ＝ 局_用户名
            .默认
                
            .判断结束
            局_S ＝ { }
        .否则
            局_S ＝ 局_S ＋ 局_c
        .如果结束
        .如果真 (局_SPos ＝ 9)
            局_记录 ＝ 局_记录 ＋ 1
            局_BookID ＝ “”
            局_SPos ＝ 0
        .如果真结束
        
    .变量循环尾 ()

.子程序 内部_线程, , , 线程池相关
    .参数 数据传递指针, 整数型, , 单位为：毫秒
    .局部变量 lpNumberOfBytesTransferred, 整数型
    .局部变量 IOCP句柄, 整数型
    .局部变量 线程池状态, 逻辑型
    .局部变量 处理函数, 整数型
    .局部变量 超时时间, 整数型

    .局部变量 处理状态, 整数型

    ' 地址结构依次为：
    ' 完成端口IOCP句柄
    ' 线程池状态。 1运行，0停止
    ' 处理函数。到整数(子程序指针)
    ' 超时时间
    
    IOCP句柄 ＝ 指针_到整数 (数据传递指针)
    ' 线程池状态 ＝ 指针_到整数 (数据传递指针 ＋ 4) ＝ 1  ' 暂时废弃 退出时发送一个退出的消息给循环，让循环退出
    线程池状态 ＝ 真
    处理函数 ＝ 指针_到整数 (数据传递指针 ＋ 8)
    超时时间 ＝ 指针_到整数 (数据传递指针 ＋ 12)
    HeapFree (GetProcessHeap (), 0, 数据传递指针)
    
    .判断循环首 (线程池状态)
        .如果 (GetQueuedCompletionStatus (IOCP句柄, lpNumberOfBytesTransferred, 处理状态, 0, -1) ＝ 1)
            .判断开始 (处理状态 ＝ 0)
                ' 输出调试文本 (lpNumberOfBytesTransferred)
                call (处理函数, lpNumberOfBytesTransferred)
            .判断 (处理状态 ＝ -999)
                返回 () ' 退出线程
            .默认
                
            .判断结束
            
        .否则
            ' GetLastError ()
            ' GetLastError ()
            跳出循环 () ' 错误后跳出，避免CPU增涨
        .如果结束
        
        
    .判断循环尾 ()
    输出调试文本 (“线程退出”)

.子程序 call, 整数型, , 线程池相关
    .参数 参数一, 整数型
    .参数 参数二, 整数型

    置入代码 ({ 201, 88, 135, 4, 36, 255, 224 })
    返回 (0)

.子程序 ___RAR解压_测试, , , ---------
    

.子程序 RAR_解压文件, 逻辑型, 公开, 解压 RAR 档案的所有文件或指定文件，成功返回真，失败返回假。本命令需要unrar.dll的支持,下载地址:http://www.rarlab.com/rar_add.htm
    .参数 待解压文件, 文本型, , 欲解压文件的压缩档案全路径名称
    .参数 解压密码, 文本型, 可空, 欲解压文件的压缩档案密码，无密码时为空
    .参数 解压路径, 文本型, 可空, 指定解压文件的路径，为空表示解压到压缩档案所在目录

    .如果真 (是否为空 (解压路径) 或 解压路径 ＝ “”)
        解压路径 ＝ 文件_取目录 (待解压文件)
    .如果真结束
    返回 (RAR_操作档案文件 (2, 待解压文件, 解压密码, 解压路径)) ' 文件数据 中保存符合条件且被成功处理的文件信息列表，如果需要可将其返回。（如转为 压缩文件信息 自定义类型返回）

.子程序 RAR_测试压缩文件, 逻辑型, 公开, 测试RAR压缩文件是否无误，如：压缩包损坏将返回假，否则返回真。
    .参数 待测试压缩文件, 文本型, , 欲解压文件的压缩档案全路径名称
    .参数 解压密码, 文本型, 可空, 欲解压文件的压缩档案密码，无密码时为空

    返回 (RAR_操作档案文件 (0, 待测试压缩文件, 解压密码))

.子程序 RAR_操作档案文件, 逻辑型, , 操作 RAR 档案文件，如获取信息、文件列表、测试文件、解压文件等，成功返回真，失败返回假。
    .参数 操作方式, 整数型, , RAR_SKIP/RAR_TEST/RAR_EXTRACT，分别用于 信息获取/测试/解压
    .参数 待解压文件, 文本型, , 欲进行的压缩档案全路径名称
    .参数 解压密码, 文本型, 可空, 可空。欲进行操作的压缩档案密码，无密码时为空
    .参数 解压路径, 文本型, 可空, 可空。留空将解压在当前目录。 指定解压文件的路径
    .局部变量 档案数据, RAROpenArchiveDataEx
    .局部变量 打开句柄, 整数型
    .局部变量 读取结果, 整数型
    .局部变量 处理结果, 整数型
    .局部变量 临时数据, RARHeaderData
    .局部变量 临时名称, 文本型, , , 该名称由于要传递指针，应单独使用不再赋值后再次修改
    .局部变量 文件有效, 逻辑型
    .局部变量 是否解压成功, 短整数型

    档案数据.ArcName ＝ 待解压文件
    档案数据.OpenMode ＝ 选择 (操作方式 ＝ 0, 2, 1)
    打开句柄 ＝ RAROpenArchiveEx (档案数据)
    .如果真 (档案数据.OpenResult ≠ 0) ' 函数执行失败
        返回 (假)
    .如果真结束
    .如果真 (是否为空 (解压密码) ＝ 假 且 解压密码 ≠ “”)
        RARSetPassword (打开句柄, 解压密码)
    .如果真结束
    .判断循环首 (真) ' 无限循环
        读取结果 ＝ RARReadHeader (打开句柄, 临时数据)
        .判断开始 (读取结果 ＝ 0) ' 成功
            临时名称 ＝ 到文本 (临时数据.FileName)
            RARSetCallback (打开句柄, &RAR_档案回调函数, 取指针地址_文本型 (临时名称)) ' 设置回调函数
            .如果 (操作方式 ＝ 0)
                文件有效 ＝ 真 ' 测试压缩包
            .否则
                文件有效 ＝ 是否匹配文件 (临时名称, “*.*”) ' 解压
            .如果结束
            处理结果 ＝ RARProcessFile (打开句柄, 选择 (文件有效, 操作方式, 0), 选择 (操作方式 ＝ 2, 解压路径, “”), “”)
            .如果 (处理结果 ＝ 0) ' 成功执行处理函数
                .如果真 (文件有效)
                    是否解压成功 ＝ 是否解压成功 ＋ 1
                .如果真结束
                
            .否则
                RARCloseArchive (打开句柄)
                返回 (假)
            .如果结束
            
        .判断 (读取结果 ＝ 10) ' 到达档案末尾
            跳出循环 ()
        .默认
            RARCloseArchive (打开句柄)
            返回 (假)
        .判断结束
        
    .判断循环尾 ()
    RARCloseArchive (打开句柄)
    返回 (是否解压成功 ＞ 0)

.子程序 RAR_档案回调函数, 整数型
    .参数 信息, 整数型
    .参数 用户数据, 整数型
    .参数 参数一, 整数型
    .参数 参数二, 整数型

    返回 (0)

.子程序 是否匹配文件, 逻辑型, , 文件名辅助处理函数,判断指定文件名是否符合过滤器
    .参数 文件名, 文本型, , 欲判断的文件名，可以包含路径
    .参数 过滤器, 文本型, , 允许，多个过滤器以 ; 间隔,支持通配符 */?
    .参数 区分大小写, 逻辑型, 可空, 是否区分大小写, 默认不区分
    .局部变量 过滤数组, 文本型, , "0"
    .局部变量 计次, 整数型
    .局部变量 字符, 文本型

    .如果真 (过滤器 ＝ “”)
        返回 (假)
    .如果真结束
    .如果真 (过滤器 ＝ “*.*”)
        返回 (真)
    .如果真结束
    文件名 ＝ PathFindFileNameA (文件名)
    .如果真 (区分大小写)
        .变量循环首 (65, 122, 1, 计次) ' A~Z,a~z
            .如果真 (计次 ≥ 91 且 计次 ≤ 96) ' [ \ ] ^ _ ` 不转换
                到循环尾 ()
            .如果真结束
            字符 ＝ 字符 (计次)
            文件名 ＝ 子文本替换 (文件名, 字符, 到全角 (字符), , , 真)
            过滤器 ＝ 子文本替换 (过滤器, 字符, 到全角 (字符), , , 真)
        .变量循环尾 ()
    .如果真结束
    过滤数组 ＝ 分割文本 (过滤器, “;”, )
    .计次循环首 (取数组成员数 (过滤数组), 计次)
        .如果真 (PathMatchSpec (文件名, 过滤数组 [计次]))
            返回 (真)
        .如果真结束
        
    .计次循环尾 ()
    返回 (假)

.子程序 取指针文本_, 整数型, 公开
    .参数 参数_文本, 文本型

    置入代码 ({ 139, 69, 8, 139, 0, 201, 194, 4, 0 })
    ' mov eax,[ebp+8]
    ' mov eax,[eax]
    ' leave
    ' retn 04
    返回 (0)

.子程序 取指针整数_, 整数型, 公开
    .参数 参数_整数, 整数型, 参考

    置入代码 ({ 139, 69, 8, 201, 194, 4, 0 })
    ' mov eax,[ebp+8]
    ' leave
    ' retn 04
    返回 (0)

.子程序 取指针小数_, 整数型, 公开
    .参数 参数_小数, 小数型, 参考

    置入代码 ({ 139, 69, 8, 201, 194, 4, 0 })
    ' mov eax,[ebp+8]
    ' leave
    ' retn 04
    返回 (0)

.子程序 取指针双精度_, 整数型, 公开
    .参数 参数_双精度小数, 双精度小数型, 参考

    置入代码 ({ 139, 69, 8, 201, 194, 4, 0 })
    ' mov eax,[ebp+8]
    ' leave
    ' retn 04
    返回 (0)

.子程序 取指针字节集_, 整数型, 公开
    .参数 参数_字节集, 字节集

    置入代码 ({ 139, 69, 8, 139, 0, 5, 8, 0, 0, 0, 201, 194, 4, 0 })
    ' mov eax,[ebp+08]
    ' mov eax,[eax]
    ' add eax,08
    ' leave
    ' retn 04
    返回 (0)

.子程序 取指针长整数_, 整数型, 公开
    .参数 arg1, 长整数型, 参考

    置入代码 ({ 139, 69, 8, 139, 85, 12, 201, 194, 8, 0 })
    ' mov eax,[ebp+8]
    ' mov edx,[ebp+12]
    ' leave
    ' ret 08
    返回 (0)

.子程序 MyGetOpenFileNameA, 整数型
    .参数 参数, 整数型, , 这里获得OpenFilename这个结构的地址
    .局部变量 指针地址, 整数型

    指针地址 ＝ 取字节集数据 (指针到字节集 (参数 ＋ 28, 4), #整数型, 1) ' 结构地址偏移28的地址取整数是文件名的在内存中的地址
    写到内存 (编码_Ansi到Unicode (全_文本), 指针地址, ) ' 写入新的文件名
    返回 (1)

.子程序 系统_取宽带用户名密码, 逻辑型, 公开, 成功返回真,失败返回假  注：只有ADSL拨号上网的才能取
    .参数 连接名称, 文本型, 可空, 请提供一个文本变量,用于存放 连接名称
    .参数 宽带用户名, 文本型, 可空, 请提供一个文本变量,用于存放 宽带用户名
    .参数 宽带密码, 文本型, 可空, 请提供一个文本变量,用于存放 宽带密码
    .局部变量 局_RasArraySize, 整数型
    .局部变量 局_信息, 整数型
    .局部变量 局_RasCount, 整数型
    .局部变量 局_RasArray, 取连接信息用结构, , "0"
    .局部变量 局_图书1, 文本型
    .局部变量 局_图书2, 文本型
    .局部变量 局_osi, OSVersionInfo
    .局部变量 局_计次, 整数型
    .局部变量 局_RasParams, ADSL拨号0
    .局部变量 局_RasEntryProperties, RasEntry
    .局部变量 局_名字1, 字节集
    .局部变量 局_名字2, 字节集
    .局部变量 局_DialParamsUID, 整数型

    局_RasCount ＝ 子_GetRasEntryCount ()
    .如果真 (局_RasCount ＝ 0)
        返回 (假)
    .如果真结束
    重定义数组 (局_RasArray, 假, 局_RasCount)
    .如果真 (取数组成员数 (局_RasArray) ≥ 1)
        局_RasArray [1].内存大小 ＝ GlobalSize_取连接信息用结构 (局_RasArray [1])
        局_RasArraySize ＝ 局_RasCount × 局_RasArray [1].内存大小
    .如果真结束
    .如果真 (RasEnumEntries (0, 0, 局_RasArray, 局_RasArraySize, 局_RasCount) ≠ 0)
        返回 (假)
    .如果真结束
    ' 局_osi.版本信息大小 ＝ 148
    ' 局_osi.CSD版本 ＝ 取空白文本 (128)
    ' API_GetVersionEx (局_osi)
    ' .如果真 (局_osi.平台标识符 ＝ 2 且 局_osi.主版本 ≥ 5)
        局_图书1 ＝ 取空白文本 (255)
        局_图书2 ＝ 取空白文本 (255)
        .如果真 (SHGetSpecialFolderPathA (0, 局_图书1, 26, 假))
            局_图书1 ＝ 局_图书1 ＋ “\Microsoft\Network\Connections\pbk\rasphone.pbk”
        .如果真结束
        .如果真 (SHGetSpecialFolderPathA (0, 局_图书2, 35, 假))
            局_图书2 ＝ 局_图书2 ＋ “\Microsoft\Network\Connections\pbk\rasphone.pbk”
        .如果真结束
        子_GetLSAPasswords ()
    ' .如果真结束
    .计次循环首 (取数组成员数 (局_RasArray), 局_计次)
        局_RasParams.结构的大小 ＝ GlobalSize_RASDIALPARAMS (局_RasParams)
        RtlMoveMemory_字节型_数组 (局_RasParams.访问的入口名, 局_RasArray [局_计次].拨号连接名称, 255)
        RasGetEntryDialParams (“”, 局_RasParams, 真)
        局_RasArraySize ＝ GlobalSize_RASENTRY (局_RasEntryProperties)
        局_RasEntryProperties.dwSize ＝ 局_RasArraySize
        RasGetEntryProperties (“”, 局_RasArray [局_计次].拨号连接名称, 局_RasEntryProperties, 局_RasArraySize, “”, 局_信息)
        .如果真 (局_图书1 ≠ “” 或 局_图书2 ≠ “”)
            局_名字1 ＝ 到字节集 (子_字节型数组到文本 (局_RasParams.访问的入口名)) ＋ { 0 }
            局_名字2 ＝ 编码_Ansi到Utf8 (子_字节型数组到文本 (局_RasParams.访问的入口名)) ＋ { 0 }
            局_DialParamsUID ＝ GetPrivateProfileInt (局_名字1, “DialParamsUID”, 0, 局_图书1)
            .如果真 (局_DialParamsUID ＝ 0)
                局_DialParamsUID ＝ GetPrivateProfileInt (局_名字1, “DialParamsUID”, 0, 局_图书2)
            .如果真结束
            .如果真 (局_DialParamsUID ＝ 0)
                局_DialParamsUID ＝ GetPrivateProfileInt (局_名字2, “DialParamsUID”, 0, 局_图书1)
            .如果真结束
            .如果真 (局_DialParamsUID ＝ 0)
                局_DialParamsUID ＝ GetPrivateProfileInt (局_名字2, “DialParamsUID”, 0, 局_图书2)
            .如果真结束
            .如果真 (局_DialParamsUID ＞ 0)
                .计次循环首 (取数组成员数 (FLSAList), 局_计次)
                    .如果真 (FLSAList [局_计次].名字 ＝ 到文本 (局_DialParamsUID) 且 FLSAList [局_计次].值 ≠ “”)
                        子_文本到字节型数组 (局_RasParams.指定用户名称, FLSAList [局_计次].用户)
                        子_文本到字节型数组 (局_RasParams.指定用户密码, FLSAList [局_计次].值)
                    .如果真结束
                    
                .计次循环尾 ()
            .如果真结束
            
        .如果真结束
        连接名称 ＝ 子_字节型数组到文本 (局_RasParams.访问的入口名)
        宽带用户名 ＝ 子_字节型数组到文本 (局_RasParams.指定用户名称)
        宽带密码 ＝ 子_字节型数组到文本 (局_RasParams.指定用户密码)
    .计次循环尾 ()
    返回 (删首尾空 (宽带用户名) ≠ “”)

.子程序 取_类_函数地址, 整数型
    .参数 this
    .参数 index, , , 从1开始,[_初始化][_销毁],[xx]
    .局部变量 函数数组

    index ＝ index － 1
    函数数组 ＝ 取指针内容_整数 (this)
    返回 (取指针内容_整数 (函数数组 ＋ index × 4))

.子程序 到数值_从子程序指针, 整数型
    .参数 proc, 子程序指针
    .局部变量 ret, 整数型

    置入代码 ({ 139, 69, 8, 137, 69, 252 })
    ' 置入代码 (“mov eax,[ebp+8] | mov [ebp-4],eax”)
    返回 (ret)

.子程序 到子程序指针_从数值, 子程序指针
    .参数 val, 整数型
    .局部变量 ret, 子程序指针

    置入代码 ({ 139, 69, 8, 137, 69, 252 })
    ' 置入代码 (“mov eax,[ebp+8] | mov [ebp-4],eax”)
    返回 (ret)

.子程序 取上层函数首参, 整数型
    .局部变量 ret

    置入代码 ({ 139, 69, 0, 139, 0, 139, 64, 8, 137, 69, 252 })
    ' 置入代码 ({ 139, 69, 0, 139, 0, 139, 64, 8, 137, 69, 252 })
    返回 (ret)

.子程序 get_retn_code, 整数型
    .局部变量 static_ptr, , 静态
    .局部变量 data, 字节集

    .如果真 (static_ptr ≠ 0)
        返回 (static_ptr)
    .如果真结束
    ' mov     edx, dword ptr [ebp-4]
    ' mov     ebx, dword ptr [ebp-8]
    ' mov     esi, dword ptr [ebp-C]
    ' mov     edi, dword ptr [ebp-10]
    ' fldcw   word ptr [ebp-14]
    ' mov     esp, ebp
    ' pop     ebp
    ' pop     ecx
    ' add     esp, edx
    ' jmp     ecx
    data ＝ { 139, 77, 252, 139, 93, 248, 139, 117, 244, 139, 125, 240, 217, 109, 236, 139, 229, 93, 141, 100, 12, 4, 247, 217, 139, 76, 12, 252, 255, 225 }
    static_ptr ＝ DumpCode (data)
    返回 (static_ptr)

.子程序 辅_生成_方法回调, 整数型, , [不需要fcw复位]
    .参数 回调地址
    .参数 参数个数, , 可空
    .参数 push_ecx, 逻辑型, 可空, 当有[附加参数1]附加到第二个参数，当没有[附加参数1]时附加到第一个参数;默认为假
    .参数 cdecl方式, 逻辑型, 可空, 默认为假
    .参数 附加参数1, , 可空, 附加到第一个的参数.不为0则附加
    .局部变量 data, 字节集

    .局部变量 arg_length
    .局部变量 ret_len_WORD, 短整数型

    .如果真 (回调地址 ＝ 0)
        输出调试文本 (“[辅_生成_方法回调][失败]：回调地址错误”)
        返回 (0)
    .如果真结束
    .如果 (cdecl方式)
        ret_len_WORD ＝ 0
    .否则
        ret_len_WORD ＝ 参数个数 × 4
    .如果结束
    arg_length ＝ 参数个数 × 4
    .如果真 (arg_length ＞ 512 或 arg_length ＜ 0)
        输出调试文本 (“[辅_生成_方法回调]局部变量长度错误”)
        返回 (0)
    .如果真结束
    data ＝ { }
    data ＝ data ＋ { 85 } ' push ebp;
    data ＝ data ＋ { 139, 236 } ' mov ebp,esp;
    data ＝ data ＋ { 106 } ＋ 到字节集_从字节 (ret_len_WORD) ' push [retn_size]; // [ebp-04]
    data ＝ data ＋ { 83 } ' push ebx; // [ebp-08]
    data ＝ data ＋ { 86 } ' push esi; // [ebp-0C]
    data ＝ data ＋ { 87 } ' push edi; // [ebp-10]
    data ＝ data ＋ { 106 } ＋ { 0 } ' push 0; // [ebp-14]
    data ＝ data ＋ { 217, 60, 36 } ' fstcw [esp];
    data ＝ data ＋ { 219, 227 } ' finit;
    ' ////////////////////////////////////////////////////////////////////////////
    .如果真 (参数个数 ≠ 0)
        data ＝ data ＋ { 185 } ＋ 到字节集_从整数_ (arg_length) ' mov ecx,arg_length;
        data ＝ data ＋ { 43, 225 } ' sub esp,ecx;
        data ＝ data ＋ { 141, 117, 8 } ' lea esi,[ebp+8];
        data ＝ data ＋ { 141, 60, 36 } ' lea edi,[esp];
        data ＝ data ＋ { 252 } ' cld;
        data ＝ data ＋ { 243, 164 } ' rep movsb;
        data ＝ data ＋ { 139, 77, 248 } ' mov ecx,[ebp-8];
        data ＝ data ＋ { 139, 117, 244 } ' mov esi.[ebp-C];
        data ＝ data ＋ { 139, 125, 240 } ' mov edi,[ebp-10];
    .如果真结束
    .如果真 (push_ecx)
        data ＝ data ＋ { 81 } ' push ecx;
    .如果真结束
    .如果真 (附加参数1 ≠ 0)
        data ＝ data ＋ { 104 } ＋ 到字节集_从整数_ (附加参数1) ' push arg_1
    .如果真结束
    data ＝ data ＋ { 184 } ＋ 到字节集_从整数_ (回调地址) ' mov eax,addr;
    data ＝ data ＋ { 104 } ＋ 到字节集_从整数_ (get_retn_code ()) ' push arg_1; //retn to static code
    data ＝ data ＋ { 255, 224 } ' jmp eax
    返回 (DumpCode (data))

.子程序 类回调_取类地址, 整数型, 公开, [只能在类里调用]
    .参数 函数序号, , , 从1开始,[_初始化][_销毁],[xx]
    .参数 参数个数, , 可空
    .参数 push_ecx, 逻辑型, 可空, 附加到第一个参数;默认为假
    .参数 cdecl方式, 逻辑型, 可空, 默认为假
    .局部变量 this

    .局部变量 回调地址
    .局部变量 data, 字节集

    .局部变量 arg_length
    .局部变量 sizeof_int
    .局部变量 ret_len_WORD, 短整数型

    this ＝ 取指针内容_整数 (取上层函数首参 ())
    回调地址 ＝ 取_类_函数地址 (this, 函数序号)
    
    .如果真 (回调地址 ≤ 0)
        输出调试文本 (“[辅_生成_类回调_易][失败]：回调地址错误”)
        返回 (0)
    .如果真结束
    sizeof_int ＝ 4 ' #sizeof_int
    .如果 (cdecl方式)
        ret_len_WORD ＝ 0
    .否则
        ret_len_WORD ＝ 参数个数 × sizeof_int
    .如果结束
    arg_length ＝ 参数个数 × sizeof_int
    .如果真 (arg_length ＞ 512 或 arg_length ＜ 0)
        输出调试文本 (“[辅_生成_类回调_易]局部变量长度错误”)
        返回 (0)
    .如果真结束
    data ＝ { }
    data ＝ data ＋ { 85 } ' push ebp;
    data ＝ data ＋ { 139, 236 } ' mov ebp,esp;
    data ＝ data ＋ { 106 } ＋ 到字节集_从字节 (ret_len_WORD) ' push [retn_size]; // [ebp-04]
    data ＝ data ＋ { 83 } ' push ebx; // [ebp-8]
    data ＝ data ＋ { 86 } ' push esi; // [ebp-0C]
    data ＝ data ＋ { 87 } ' push edi; // [ebp-10]
    data ＝ data ＋ { 106 } ＋ { 0 } ' push 0; // [ebp-14]
    data ＝ data ＋ { 217, 60, 36 } ' fstcw [esp];
    data ＝ data ＋ { 219, 227 } ' finit;
    data ＝ data ＋ { 104 } ＋ 到字节集_从整数_ (this) ' push dwThis;
    data ＝ data ＋ { 139, 196 } ' mov eax,esp
    .如果真 (参数个数 ≠ 0)
        data ＝ data ＋ { 185 } ＋ 到字节集_从整数_ (arg_length) ' mov ecx,arg_length;
        data ＝ data ＋ { 43, 225 } ' sub esp,ecx;
        data ＝ data ＋ { 141, 117, 8 } ' lea esi,[ebp+8];
        data ＝ data ＋ { 141, 60, 36 } ' lea edi,[esp];
        data ＝ data ＋ { 252 } ' cld;
        data ＝ data ＋ { 243, 164 } ' rep movsb;
        data ＝ data ＋ { 139, 77, 248 } ' mov ecx,[ebp-8];
        data ＝ data ＋ { 139, 117, 244 } ' mov esi.[ebp-C];
        data ＝ data ＋ { 139, 125, 240 } ' mov edi,[ebp-10];
    .如果真结束
    .如果真 (push_ecx)
        data ＝ data ＋ { 81 } ' push ecx;
    .如果真结束
    data ＝ data ＋ { 80 } ' push eax;  // push &(this)
    data ＝ data ＋ { 184 } ＋ 到字节集_从整数_ (回调地址) ' mov eax,addr;
    data ＝ data ＋ { 104 } ＋ 到字节集_从整数_ (get_retn_code ()) ' push arg_1; //retn to static code
    data ＝ data ＋ { 255, 224 } ' jmp eax
    返回 (DumpCode (data))
    

.子程序 类回调_释放回调, , 公开, 用于释放生成代码后的返回指针，若你确定你的回调已经停用了才能释放
    .参数 ptr

    VirtualFreeEx (GetCurrentProcess (), ptr, 0, 32768)

.子程序 DumpCode, 整数型
    .参数 data, 字节集
    .局部变量 hMem
    .局部变量 Ptr
    .局部变量 len

    len ＝ 取字节集长度 (data)
    hMem ＝ VirtualAlloc (0, len, 4096, 64)
    CopyMemory_Bytes2int (hMem, data, len)
    返回 (hMem)

.子程序 取指针内容_整数, 整数型
    .参数 内存地址
    .局部变量 ret

    置入代码 ({ 139, 69, 8, 139, 0, 137, 69, 252 })
    ' 置入代码 (“mov eax,[ebp+8] | mov eax,[eax] | mov [ebp-4],eax”)
    返回 (ret)

.子程序 到字节集_从整数_, 字节集
    .参数 欲转换的数值, 整数型, 参考
    .局部变量 ptr

    ptr ＝ 取变量地址_整数 (欲转换的数值)
    返回 (指针到字节集 (ptr, 4))

.子程序 到字节集_从短整数_, 字节集
    .参数 欲转换的数值, 短整数型, 参考
    .局部变量 ptr

    ptr ＝ 取变量地址_短整数 (欲转换的数值)
    返回 (指针到字节集 (ptr, 2))

.子程序 到字节集_从字节, 字节集
    .参数 欲转换的数值, 短整数型, 参考
    .局部变量 ptr

    ptr ＝ 取变量地址_短整数 (欲转换的数值)
    返回 (指针到字节集 (ptr, 1))

.子程序 取变量地址_字节, 整数型
    .参数 变量, 字节型, 参考
    .局部变量 reuslt

    置入代码 ({ 139, 69, 8, 137, 69, 252 })
    ' 置入代码 (“mov eax,[ebp+8] | mov [ebp-4],eax”)
    返回 (reuslt)

.子程序 取变量堆栈地址_字节集, 整数型, 公开
    .参数 字节集变量, 字节集

    置入代码 ({ 139, 69, 8, 201, 194, 4, 0 })
    返回 (0)

.子程序 取变量地址_整数, 整数型
    .参数 var, 整数型, 参考
    .局部变量 ptr

    置入代码 ({ 139, 69, 8, 137, 69, 252 })
    ' 置入代码 (“mov eax,[ebp+8] | mov [ebp-4],eax”)
    返回 (ptr)

.子程序 取变量地址_短整数, 整数型
    .参数 变量, 短整数型, 参考
    .局部变量 reuslt

    置入代码 ({ 139, 69, 8, 137, 69, 252 })
    ' 置入代码 (“mov eax,[ebp+8] | mov [ebp-4],eax”)
    返回 (reuslt)

.子程序 辅_取字节集长度, 整数型
    .参数 v, 字节集
    .局部变量 len

    .如果真 (v ＝ { })
        返回 (0)
    .如果真结束
    置入代码 ({ 139, 69, 8, 139, 0, 139, 64, 4, 137, 69, 252 })
    ' 置入代码 (“mov eax,[ebp+8] | mov eax,[eax] | mov eax,[eax+4] | mov [ebp-4],eax ”)
    返回 (len)

.子程序 托盘消息回调, 整数型
    .参数 hwnd
    .参数 uMsg
    .参数 wParam
    .参数 lParam
    .局部变量 pointer
    .局部变量 Message
    .局部变量 TaskbarCreated
    .局部变量 Event

    pointer ＝ GetPropA (hwnd, “WinProc”)
    Message ＝ GetPropA (hwnd, “CallbackMessage”)
    TaskbarCreated ＝ GetPropA (hwnd, “TaskbarCreatedMessage”)
    Event ＝ GetPropA (hwnd, “Exec Event”)
    .判断开始 (uMsg ＝ Message)
        .如果真 (Event ≠ 0)
            程序_Call (Event, lParam)
            返回 (0)
        .如果真结束
        
    .判断 (uMsg ＝ TaskbarCreated)
        .如果真 (Event ≠ 0)
            程序_Call (Event, 1120)
            返回 (0)
        .如果真结束
        
    .判断 (uMsg ＝ 2)
        .如果真 (Event ≠ 0)
            程序_Call (Event, 1130)
        .如果真结束
        
    .默认
        
    .判断结束
    返回 (CallWindowProcA (pointer, hwnd, uMsg, wParam, lParam))
    

.子程序 逻辑左移, 整数型, , （逻辑左移） （算术左移） 
    .参数 欲移动的整数, 整数型
    .参数 欲被移动的位数, 字节型

    置入代码 ({ 81, 139, 69, 8, 138, 77, 12, 211, 224, 89, 139, 229, 93, 194, 8, 0 })
    返回 (-1)

.子程序 逻辑右移, 整数型, , （逻辑右移） （算术右移） 寄存器，1
    .参数 欲移动的整数, 整数型
    .参数 欲被移动的位数, 字节型

    置入代码 ({ 81, 139, 69, 8, 138, 77, 12, 211, 232, 89, 139, 229, 93, 194, 8, 0 })
    返回 (-1)
    

.子程序 地址_取API地址, 整数型, 公开, 返回API地址
    .参数 动态链接库名, 文本型
    .参数 函数名, 文本型
    .局部变量 模块句柄, 整数型
    .局部变量 是否加载模块, 逻辑型
    .局部变量 返回值, 整数型

    模块句柄 ＝ GetModuleHandleA (动态链接库名) ' 获取动态库句柄(如果已被加载)
    .如果真 (模块句柄 ＝ 0)
        是否加载模块 ＝ 真
        模块句柄 ＝ LoadLibraryA (动态链接库名) ' 加载动态库并获取句柄
    .如果真结束
    .如果真 (模块句柄 ＝ 0)
        返回 (0)
    .如果真结束
    返回值 ＝ GetProcAddress (模块句柄, 函数名)
    .如果真 (是否加载模块 ＝ 真)
        FreeLibrary (模块句柄)
    .如果真结束
    返回 (返回值)

.子程序 调用子程序_数组, 整数型, 公开
    .参数 调用地址, 整数型
    .参数 参数数组, 整数型, 可空 数组
    .参数 是否为C调用, 逻辑型, 可空

    .如果真 (IsBadCodePtr (调用地址))
        返回 (0)
    .如果真结束
    置入代码 ({ 131, 236, 8, 86, 62, 139, 117, 12, 139, 54, 139, 118, 4, 141, 78, 255, 133, 201, 124, 18, 139, 69, 12, 139, 0, 141, 68, 136, 8, 65, 255, 48, 131, 232, 4, 73, 117, 248, 255, 85, 8, 137, 69, 252, 139, 69, 20, 133, 192, 116, 10, 62, 141, 4, 181, 0, 0, 0, 0, 3, 224, 139, 69, 252, 94, 139, 229, 93, 194, 20, 0 })
    返回 (0)

.子程序 整数_有符号转无符号, 长整数型, 公开
    .参数 arglist, 整数型

    置入代码 ({ 51, 210, 139, 69, 8, 201, 194, 4, 0 })
    ' xor edx, edx
    ' mov eax, [ebp+08h]
    ' leave
    ' retn 0004h
    返回 (0)

.子程序 短整数_有符号转无符号, 整数型, 公开
    .参数 arglist, 短整数型

    置入代码 ({ 51, 192, 102, 139, 69, 8, 201, 194, 4, 0 })
    ' xor eax, eax
    ' mov ax, [ebp+08h]
    ' leave
    ' retn 0004h
    返回 (0)

.子程序 长整数_有符号转无符号, 文本型, 公开
    .参数 arglist, 长整数型
    .局部变量 arg1, 文本型

    arg1 ＝ 取空白文本 (32)
    sprintf_长整数型 (取指针文本_ (arg1), “%I64u”, arglist)
    返回 (arg1)

.子程序 生成键盘消息lParam, 整数型
    .参数 重复计数, 短整数型
    .参数 扫描代码, 字节型
    .参数 是否为扩展键, 逻辑型
    .参数 上下文代码, 逻辑型, , 对于WM_KEYDOWN消息，该值始终为0
    .参数 先前的键状态, 逻辑型, , 如果在发送消息之前按键已按下，则值为1；如果按键已按下，则值为0
    .参数 过渡状态, 逻辑型, , 对于WM_KEYDOWN消息，该值始终为0
    .局部变量 ret, 整数型

    ret ＝ 左移 (扫描代码, 16)
    ret ＝ 位或 (ret, 重复计数)
    .如果真 (是否为扩展键)
        ret ＝ 位或 (ret, 左移 (1, 24))
    .如果真结束
    .如果真 (上下文代码)
        ret ＝ 位或 (ret, 左移 (1, 29))
    .如果真结束
    .如果真 (先前的键状态)
        ret ＝ 位或 (ret, 左移 (1, 30))
    .如果真结束
    .如果真 (过渡状态)
        ret ＝ 位或 (ret, 左移 (1, 31))
    .如果真结束
    返回 (ret)

.子程序 取键盘消息lParam
    .参数 lParam, 整数型
    .参数 重复计数, 短整数型, 参考 可空
    .参数 扫描代码, 字节型, 参考 可空
    .参数 是否为扩展键, 逻辑型, 参考 可空
    .参数 上下文代码, 逻辑型, 参考 可空, 对于WM_KEYDOWN消息，该值始终为0
    .参数 先前的键状态, 逻辑型, 参考 可空, 如果在发送消息之前按键已按下，则值为1；如果按键已按下，则值为0
    .参数 过渡状态, 逻辑型, 参考 可空, 对于WM_KEYDOWN消息，该值始终为0

    扫描代码 ＝ 位与 (右移 (lParam, 16), 255)
    重复计数 ＝ 位与 (lParam, 65535)
    是否为扩展键 ＝ 位与 (lParam, 左移 (1, 24)) ≠ 0
    上下文代码 ＝ 位与 (lParam, 左移 (1, 29)) ≠ 0
    先前的键状态 ＝ 位与 (lParam, 左移 (1, 30)) ≠ 0
    过渡状态 ＝ 位与 (lParam, 左移 (1, 31)) ≠ 0

.子程序 Asm_idiv64, 长整数型, , 长整数相除
    .参数 int64, 长整数型
    .参数 nint64, 长整数型

    置入代码 ({ 139, 69, 20, 139, 77, 16, 139, 85, 12, 80, 139, 69, 8, 81, 82, 80, 232, 4, 0, 0, 0, 93, 194, 16, 0, 83, 86, 139, 68, 36, 24, 11, 192, 117, 24, 139, 76, 36, 20, 139, 68, 36, 16, 51, 210, 247, 241, 139, 216, 139, 68, 36, 12, 247, 241, 139, 211, 235, 65, 139, 200, 139, 92, 36, 20, 139, 84, 36, 16, 139, 68, 36, 12, 209, 233, 209, 219, 209, 234, 209, 216, 11, 201, 117, 244, 247, 243, 139, 240, 247, 100, 36, 24, 139, 200, 139, 68, 36, 20, 247, 230, 3, 209, 114, 14, 59, 84, 36, 16, 119, 8, 114, 7, 59, 68, 36, 12, 118, 1, 78, 51, 210, 139, 198, 94, 91, 194, 16, 0 })
    返回 (0)

.子程序 InterlockedAddNoFence64, 长整数型, 公开, InterlockedAddNoFence64, 返回操作的结果
    .参数 Addend, 长整数型, 参考, 把这个参数累加, 结果保存到这个参数里
    .参数 Value, 长整数型, , 累加的值, 写负数就是减

    ' https://bbs.125.la/forum.php?mod=redirect&goto=findpost&ptid=14714626&pid=22732509
    ' 85, 139, 236, push ebp    mov ebp, esp
    置入代码 ({ 131, 236, 16, 83, 86, 87, 139, 69, 8, 139, 8, 139, 80, 4, 137, 77, 248, 137, 85, 252, 139, 69, 248, 139, 85, 252, 139, 77, 248, 3, 77, 12, 139, 117, 252, 19, 117, 16, 139, 125, 8, 139, 217, 139, 206, 240, 15, 199, 15, 137, 69, 240, 137, 85, 244, 139, 85, 240, 59, 85, 248, 117, 199, 139, 69, 244, 59, 69, 252, 117, 191, 139, 69, 248, 3, 69, 12, 139, 85, 252, 19, 85, 16, 95, 94, 91, 139, 229, 93, 194, 12, 0 })
    ' 00510000 55                   push        ebp
    ' 00510001 8B EC                mov         ebp,esp    这两行易语言的子程序已经包含了, 去除这两行
    
    ' 00510003 83 EC 10             sub         esp,10h
    ' 00510006 53                   push        ebx
    ' 00510007 56                   push        esi
    ' 00510008 57                   push        edi
    ' 00510009 8B 45 08             mov         eax,dword ptr [ebp+8]
    ' 0051000C 8B 08                mov         ecx,dword ptr [eax]
    ' 0051000E 8B 50 04             mov         edx,dword ptr [eax+4]
    ' 00510011 89 4D F8             mov         dword ptr [ebp-8],ecx
    ' 00510014 89 55 FC             mov         dword ptr [ebp-4],edx
    ' 00510017 8B 45 F8             mov         eax,dword ptr [ebp-8]
    ' 0051001A 8B 55 FC             mov         edx,dword ptr [ebp-4]
    ' 0051001D 8B 4D F8             mov         ecx,dword ptr [ebp-8]
    ' 00510020 03 4D 0C             add         ecx,dword ptr [ebp+0Ch]
    ' 00510023 8B 75 FC             mov         esi,dword ptr [ebp-4]
    ' 00510026 13 75 10             adc         esi,dword ptr [ebp+10h]
    ' 00510029 8B 7D 08             mov         edi,dword ptr [ebp+8]
    ' 0051002C 8B D9                mov         ebx,ecx
    ' 0051002E 8B CE                mov         ecx,esi
    ' 00510030 F0 0F C7 0F          lock cmpxchg8b qword ptr [edi]
    ' 00510034 89 45 F0             mov         dword ptr [ebp-10h],eax
    ' 00510037 89 55 F4             mov         dword ptr [ebp-0Ch],edx
    ' 0051003A 8B 55 F0             mov         edx,dword ptr [ebp-10h]
    ' 0051003D 3B 55 F8             cmp         edx,dword ptr [ebp-8]
    ' 00510040 75 C7                jne         00510009
    ' 00510042 8B 45 F4             mov         eax,dword ptr [ebp-0Ch]
    ' 00510045 3B 45 FC             cmp         eax,dword ptr [ebp-4]
    ' 00510048 75 BF                jne         00510009
    ' 0051004A 8B 45 F8             mov         eax,dword ptr [ebp-8]
    ' 0051004D 03 45 0C             add         eax,dword ptr [ebp+0Ch]
    ' 00510050 8B 55 FC             mov         edx,dword ptr [ebp-4]
    ' 00510053 13 55 10             adc         edx,dword ptr [ebp+10h]
    ' 00510056 5F                   pop         edi
    ' 00510057 5E                   pop         esi
    ' 00510058 5B                   pop         ebx
    ' 00510059 8B E5                mov         esp,ebp
    ' 0051005B 5D                   pop         ebp
    ' 0051005C C2 0C 00             ret         0Ch
    返回 (0)

.子程序 某舍某入, 整数型, , 舍与入应该是连续的数，若不连续，且原值小数点后第一位介于舍入之间，则返回-1
    .参数 原值小数, 小数型, , 欲判断值
    .参数 某舍, 整数型, , 参考四舍五入，传参为小数点后第一位数 <=4的舍去.传参<0默认0
    .参数 某入, 整数型, , 参考四舍五入，传参为小数点后第一位数 >=5的加入.传参>9默认9
    .局部变量 某舍值, 小数型
    .局部变量 某入值, 小数型

    某舍 ＝ 选择 (某舍 ＜ 0, 0, 某舍)
    某入 ＝ 选择 (某入 ＞ 9, 9, 某入)
    .如果真 (取整 (原值小数 × 10) ％ 10 ≤ 某舍)
        返回 (取整 (原值小数))
    .如果真结束
    .如果真 (取整 (原值小数 × 10) ％ 10 ≥ 某入)
        返回 (取整 (原值小数) ＋ 1)
    .如果真结束
    返回 (-1)

.子程序 字号转换毫米, 小数型
    .参数 字号, 小数型

    返回 (字号 × 0.35)

.子程序 毫米转换字号, 小数型
    .参数 毫米, 小数型

    返回 (毫米 ÷ 0.35)

.子程序 毫米转像素, 小数型
    .参数 毫米, 小数型

    返回 (毫米 × 系统_取系统DPI_注册表版 () ÷ 25.4)

.子程序 像素转毫米, 小数型
    .参数 像素, 小数型

    返回 (像素 × 25.4 ÷ 系统_取系统DPI_注册表版 ())

.子程序 取整加一, 整数型, , 若小数点后第一位数大于0则返回取整数并加一后的结果
    .参数 小数型, 小数型

    .判断开始 (小数型 ＝ 到整数 (小数型))
        返回 (到整数 (小数型))
    .默认
        返回 (到整数 (小数型) ＋ 1)
    .判断结束
    

.子程序 inet_ntop1, 整数型, , inet_ntop
    .参数 Family, 整数型
    .参数 pAddr, 整数型
    .参数 pStringBuf, 整数型
    .参数 StringBufSize, 整数型

    .如果 (_WIN32_WINNT ＜ #_WIN32_WINNT_VISTA)
        .如果真 (pStringBuf ＝ #NULL 或 StringBufSize ＝ 0)
            WSASetLastError (#ERROR_INVALID_PARAMETER)
            返回 (#NULL)
        .如果真结束
        .判断开始 (Family ＝ #AF_INET6)
            .如果真 (WSAAddressToStringA (pAddr, 4, #NULL, pStringBuf, StringBufSize) ≠ 0) ' sizeof(PSOCKADDR)
                返回 (#NULL)
            .如果真结束
            
        .判断 (Family ＝ #AF_INET)
            pStringBuf ＝ inet_ntoa (pAddr)
        .默认
            WSASetLastError (#WSAEAFNOSUPPORT)
            返回 (#NULL)
        .判断结束
        返回 (pStringBuf)
    .否则
        返回 (inet_ntop (Family, pAddr, pStringBuf, StringBufSize))
    .如果结束
    

.子程序 GetWinver, , , 取系统版本
    .局部变量 Major, 整数型
    .局部变量 Minor, 整数型

    进程_取系统版本 (, Major, Minor, m_Build)
    _WIN32_WINNT ＝ MAKEWORD (Minor, Major) ' 指定代码可以运行的 Windows 版本
    .如果真 (是否为调试版 ())
        .判断开始 (Major ＝ HIBYTE (#_WIN32_WINNT_WINXP) 且 Minor ＝ LOBYTE (#_WIN32_WINNT_WINXP))
            输出调试文本 (“Windows XP”)
        .判断 (Major ＝ HIBYTE (#_WIN32_WINNT_WIN7) 且 Minor ＝ LOBYTE (#_WIN32_WINNT_WIN7))
            输出调试文本 (“Windows 7”)
        .判断 (Major ＝ HIBYTE (#_WIN32_WINNT_WIN8) 且 Minor ＝ LOBYTE (#_WIN32_WINNT_WIN8))
            输出调试文本 (“Windows 8”)
        .判断 (Major ＝ HIBYTE (#_WIN32_WINNT_WIN10) 且 Minor ＝ LOBYTE (#_WIN32_WINNT_WIN10))
            .如果真 (m_Build ≥ 22000)
                输出调试文本 (“Windows 11”)
                返回 ()
            .如果真结束
            输出调试文本 (“Windows 10”)
        .默认
            
        .判断结束
        
    .如果真结束
    

.子程序 VariantToSize
    .参数 pvarg, 整数型
    .局部变量 vt, 短整数型
    .局部变量 pbstr, 整数型
    .局部变量 dwSize, 整数型

    .如果真 (pvarg ≠ #NULL)
        vt ＝ __get_short (pvarg, 0)
        .如果真 (位与 (vt, 8) ≠ 0) ' VT_BSTR
            pbstr ＝ __get (pvarg, 8)
            .如果真 (pbstr ≠ #NULL)
                dwSize ＝ __get (pbstr, -4)
                .如果真 (dwSize ＞ 0)
                    __set (pbstr, -4, dwSize ＋ 2) ' sizeof(wchar_t)
                .如果真结束
                
            .如果真结束
            
        .如果真结束
        
    .如果真结束
    

.子程序 合并长整数, 长整数型, 公开, 将第一个整数放置到结果长整数的低32位，将第二个整数放置到结果长整数的高32位，以此合并成一个长整数，并返回合并后的结果。
    .参数 低32位, 整数型
    .参数 高32位, 整数型

    置入代码 ({ 139, 69, 8, 139, 85, 12, 201, 194, 8, 0 })
    ' mov eax,[ebp+8]
    ' mov edx,[ebp+12]
    ' leave
    ' ret 08
    返回 (0)

.子程序 MAKEWORD, 整数型, 公开, 合并短整数
    .参数 l, 整数型
    .参数 h, 整数型

    置入代码 ({ 51, 192, 138, 69, 8, 138, 101, 12, 201, 194, 8, 0 })
    ' xor eax, eax
    ' mov al, [ebp+08h]
    ' mov ah, [ebp+0Ch]
    ' leave
    ' retn 0008h
    返回 (0)

.子程序 MAKELONG, 长整数型, 公开, 合并整数
    .参数 l, 整数型
    .参数 h, 整数型

    置入代码 ({ 51, 210, 102, 139, 69, 12, 193, 192, 16, 102, 139, 69, 8, 201, 194, 8, 0 })
    ' xor edx, edx
    ' mov ax, [ebp+0Ch]
    ' rol eax, 0010h
    ' mov ax, [ebp+08h]
    ' leave
    ' retn 0008h
    返回 (0)

.子程序 assignZero, 整数型, 公开, 赋值为零
    .参数 arg1, 通用型, 参考, !const
    .参数 arg2, 整数型
    .参数 arg3, 逻辑型, 可空, BYTE*

    置入代码 ({ 139, 93, 8, 139, 3, 139, 77, 12, 131, 125, 16, 1, 116, 8, 198, 4, 8, 0, 201, 194, 16, 0, 131, 192, 4, 59, 8, 127, 245, 137, 8, 235, 241 })
    ' mov ebx, dword [ebp+08h]
    ' mov eax, dword [ebx]
    ' mov ecx, dword [ebp+0Ch]
    ' cmp dword [ebp+10h], 01h
    ' je label2
    ' mov byte [eax+ecx], 00h
    ' label1:
    ' leave
    ' retn 10h
    ' label2:
    ' add eax, 04h
    ' cmp ecx, dword [eax]
    ' jg label1
    ' mov dword [eax], ecx
    ' jmp label1
    返回 (0)

.子程序 _GetLastError, 整数型, 公开
    置入代码 ({ 100, 161, 52, 0, 0, 0, 201, 195 })
    ' mov eax, dword [fs:34h]
    ' leave
    ' ret
    返回 (0)

.子程序 incShl, 整数型, 公开
    .参数 arg1, 整数型
    .参数 arg2, 逻辑型, 可空

    置入代码 ({ 139, 69, 8, 139, 77, 12, 131, 249, 1, 116, 1, 64, 209, 224, 201, 194, 8, 0 })
    ' mov eax, dword [ebp+08h]
    ' mov ecx, dword [ebp+0Ch]
    ' cmp ecx, 01h
    ' je label1
    ' inc eax
    ' label1:
    ' shl eax, 1
    ' leave
    ' retn 08h
    返回 (0)

.子程序 decSar, 整数型, 公开
    .参数 arg1, 整数型
    .参数 arg2, 逻辑型, 可空

    置入代码 ({ 139, 69, 8, 139, 77, 12, 209, 248, 131, 249, 1, 116, 1, 72, 201, 194, 8, 0 })
    ' mov eax, dword [ebp+08h]
    ' mov ecx, dword [ebp+0Ch]
    ' sar eax, 1
    ' cmp ecx, 01h
    ' je label1
    ' dec eax
    ' label1:
    ' leave
    ' retn 08h
    返回 (0)

.版本 2

.程序集 集_音乐音量, , , 该类仅支持同线程下使用 
.子程序 音乐_时长, 整数型, 公开, 获取音乐文件时长，获取总毫秒数
    .参数 文件路径, 文本型, , 音乐文件的完整路径
    .局部变量 总时间, 文本型

    总时间 ＝ 取空白文本 (255)
    mciSendStringA (“open ” ＋ #引号 ＋ 文件路径 ＋ #引号 ＋ “ alias tmpMusiczxczzcx”, 字符 (0), 0, 0)
    mciSendStringA (“status ” ＋ “tmpMusiczxczzcx” ＋ “ length”, 总时间, 128, 0) ' 取总时间
    mciSendStringA (“close ” ＋ “tmpMusiczxczzcx”, 字符 (0), 0, 0) ' 取总时间
    返回 (到整数 (总时间))

.子程序 音乐_进度, 整数型, 公开, 播放后用线程或者时钟 实时获取当前播放长度
    .参数 标识, 文本型
    .局部变量 进度, 文本型

    进度 ＝ 取空白文本 (255)
    mciSendStringA (“status ” ＋ 标识 ＋ “ position”, 进度, 256, 0)
    返回 (到整数 (进度))

.子程序 音乐_置进度, , 公开, 移动到指定位置并开始播放
    .参数 标识, 文本型, , 音乐_播放中使用的标识
    .参数 位置, 整数型

    mciSendStringA (“seek ” ＋ 标识 ＋ “ to ” ＋ 到文本 (位置), “0”, 0, 0)
    mciSendStringA (“play ” ＋ 标识, “0”, 0, 0)

.子程序 音乐_播放, 逻辑型, 公开, 真=播放成功,假=播放失败。可用于同时播放多首音乐，只要标识不同
    .参数 文件名, 文本型, , 支持格式:mp3,wav,其他格式没有测试..也可以是网络地址
    .参数 标识, 文本型, , 不可以含有空格，用于标识播放了哪个歌曲,可用来控制该音乐。比如:mysong
    .参数 是否等待播放完毕, 逻辑型, 可空, 默认为假，不等待播放完毕直接返回，如果为真，则等待播放完毕后才会返回。
    .参数 是否重新开始, 逻辑型, 可空, 默认为假

    .如果真 (是否重新开始)
        mciSendStringA (“close ” ＋ 标识, “0”, 0, 0)
    .如果真结束
    mciSendStringA (“open ” ＋ #引号 ＋ 文件名 ＋ #引号 ＋ “ alias ” ＋ 标识, “0”, 0, 0)
    返回 (mciSendStringA (“play ” ＋ 标识 ＋ 选择 (是否等待播放完毕 ＝ 真, “ wait”, “”), “0”, 0, 0) ＝ 0)

.子程序 音乐_暂停, 逻辑型, 公开, 暂时后，可调用 音乐_播放() 继续播放
    .参数 标识, 文本型, , 音乐_播放中使用的标识

    返回 (mciSendStringA (“pause ” ＋ 标识, “0”, 0, 0) ＝ 0)

.子程序 音乐_停止, 逻辑型, 公开, 禁止指定标识正在播放的音乐
    .参数 标识, 文本型, , 音乐_播放中使用的标识，即使播放完毕也记得调用一次

    返回 (mciSendStringA (“close ” ＋ 标识, “0”, 0, 0) ＝ 0)

.子程序 音量_置声道, , 公开, 设置左右声道的音量，从0～100
    .参数 左声道音量, 整数型, , 0～100
    .参数 右声道音量, 整数型, , 0～100
    .局部变量 音量, 整数型
    .局部变量 左, 整数型
    .局部变量 右, 整数型

    左 ＝ (100 － 左声道音量) ÷ 100 × 256
    右 ＝ (100 － 右声道音量) ÷ 100 × 256
    音量 ＝ (257 － 左) × 255 ＋ 16711680 × (257 － 右)
    waveOutSetVolume (0, 音量)

.子程序 音量_取声道, , 公开, 取出左右声道的音量，用参考变量，0～100
    .参数 左声道音量, 整数型, 参考, 装载左声道音量的变量
    .参数 右声道音量, 整数型, 参考, 装载右声道音量的变量
    .局部变量 音量值, 整数型

    .如果真 (waveOutGetVolume (0, 音量值) ＝ 0) ' 成功
        左声道音量 ＝ 位与 (位或 (音量值, 4294901760), 65535) ＼ 256
        左声道音量 ＝ 左声道音量 × 100 ÷ 256
        右声道音量 ＝ 位与 (位或 (音量值, 65535), 4294901760) ÷ 65536 ＼ 256
        右声道音量 ＝ 右声道音量 × 100 ÷ 256
        .如果真 (右声道音量 ＜ 0)
            .如果真 (右声道音量 ＝ -50)
                右声道音量 ＝ 0
            .如果真结束
            右声道音量 ＝ 49 ＋ 取绝对值 (50 ＋ 右声道音量)
        .如果真结束
        
    .如果真结束
    

.子程序 音量_静音, , 公开, 设置静音或解除静音,如果已经静音就解除，否则静音
    .参数 窗口句柄, 整数型, , 可以通过“取窗口句柄（）”获得

    SendMessageA (窗口句柄, 793, 2100912, 524288)

.子程序 音量_增加, , 公开, 控制声卡方式增加音量
    .参数 窗口句柄, 整数型, , 可以通过“取窗口句柄（）”获得

    SendMessageA (窗口句柄, 793, 197266, 655360)

.子程序 音量_减少, , 公开, 控制声卡方式减少音量
    .参数 窗口句柄, 整数型, , 可以通过“取窗口句柄（）”获得

    SendMessageA (窗口句柄, 793, 197266, 589824)

.子程序 GetRenderSimpleVol, 整数型, , COM_Release (pRenderSimpleVol)
    .局部变量 hr, 整数型
    .局部变量 pIMMEnumerator, 整数型
    .局部变量 pIMMDeivce, 整数型
    .局部变量 pSessionManager, 整数型
    .局部变量 pRenderSimpleVol, 整数型

    hr ＝ CoCreateInstance1 (取指针_字节集型 (#CLSID_MMDeviceEnumerator), #NULL, #CLSCTX_INPROC_SERVER, 取指针_字节集型 (#IID_IMMDeviceEnumerator), pIMMEnumerator)
    .如果真 (hr ＝ #S_OK 且 pIMMEnumerator ≠ #NULL)
        hr ＝ CallObject (pIMMEnumerator, #IMMDeviceEnumerator_GetDefaultAudioEndpoint, 0, 0, 取指针整数_ (pIMMDeivce), , , , , , ) ' eRender,eConsole
        SafeRelease (pIMMEnumerator)
        .如果真 (hr ＝ #S_OK 且 pIMMDeivce ≠ #NULL)
            hr ＝ CallObject (pIMMDeivce, #IMMDevice_Activate, 取指针_字节集型 (#CLSID_IAudioSessionManager), #CLSCTX_INPROC_SERVER, #NULL, 取指针整数_ (pSessionManager), , , , , )
            SafeRelease (pIMMDeivce)
            .如果真 (hr ＝ #S_OK 且 pSessionManager ≠ #NULL)
                hr ＝ CallObject (pSessionManager, #IAudioSessionManager_GetSimpleAudioVolume, #NULL, 0, 取指针整数_ (pRenderSimpleVol), , , , , , )
                SafeRelease (pSessionManager)
                .如果真 (hr ＝ #S_OK 且 pRenderSimpleVol ≠ #NULL)
                    返回 (pRenderSimpleVol)
                .如果真结束
                
            .如果真结束
            
        .如果真结束
        
    .如果真结束
    返回 (#NULL)

.子程序 音量_设置当前程序音量, 逻辑型, 公开, 设置当前程序在音量合成器中与扬声器的音量比
    .参数 音量, 整数型, , 0-100
    .局部变量 pRenderSimpleVol, 整数型
    .局部变量 hr, 整数型
    .局部变量 fLevel, 小数型

    pRenderSimpleVol ＝ GetRenderSimpleVol ()
    .如果真 (pRenderSimpleVol ≠ #NULL)
        .判断开始 (音量 ≥ 100)
            fLevel ＝ 1
        .判断 (音量 ≤ 0)
            fLevel ＝ 0
        .默认
            fLevel ＝ 音量 ÷ 100 ' 音量合成器中扬声器与应用程序的音量比例
        .判断结束
        hr ＝ CallObject (pRenderSimpleVol, #ISimpleAudioVolume_SetMasterVolume, 指针_到整数 (取指针地址_小数型 (fLevel)), #NULL, , , , , , , )
        SafeRelease (pRenderSimpleVol)
        返回 (hr ＝ #S_OK)
    .如果真结束
    返回 (假)

.子程序 音量_取当前程序音量, 整数型, 公开, 取当前程序在音量合成器中与扬声器的音量比
    .局部变量 pRenderSimpleVol, 整数型
    .局部变量 hr, 整数型
    .局部变量 fLevel, 小数型

    pRenderSimpleVol ＝ GetRenderSimpleVol ()
    .如果真 (pRenderSimpleVol ≠ #NULL)
        hr ＝ CallObject (pRenderSimpleVol, #ISimpleAudioVolume_GetMasterVolume, 取指针地址_小数型 (fLevel), , , , , , , , )
        SafeRelease (pRenderSimpleVol)
        .如果真 (hr ＝ #S_OK)
            返回 (到整数 (四舍五入 (fLevel × 100, 0)))
        .如果真结束
        
    .如果真结束
    返回 (-1)

.子程序 音量_设置当前程序静音, 逻辑型, 公开, 设置当前程序在音量合成器中静音或取消静音
    .参数 是否静音, 逻辑型, , 为真静音，为假取消静音
    .局部变量 pRenderSimpleVol, 整数型
    .局部变量 hr, 整数型

    pRenderSimpleVol ＝ GetRenderSimpleVol ()
    .如果真 (pRenderSimpleVol ≠ #NULL)
        hr ＝ CallObject (pRenderSimpleVol, #ISimpleAudioVolume_SetMute, 到整数 (是否静音), #NULL, , , , , , , )
        SafeRelease (pRenderSimpleVol)
        返回 (hr ＝ #S_OK)
    .如果真结束
    返回 (假)

.子程序 音量_当前程序是否静音, 逻辑型, 公开, 取当前程序在音量合成器中是否静音
    .局部变量 pRenderSimpleVol, 整数型
    .局部变量 hr, 整数型
    .局部变量 bMute, 逻辑型

    pRenderSimpleVol ＝ GetRenderSimpleVol ()
    .如果真 (pRenderSimpleVol ≠ #NULL)
        hr ＝ CallObject (pRenderSimpleVol, #ISimpleAudioVolume_GetMute, 取指针_通用型 (bMute), , , , , , , , )
        SafeRelease (pRenderSimpleVol)
        .如果真 (hr ＝ #S_OK)
            返回 (bMute)
        .如果真结束
        
    .如果真结束
    返回 (假)

.版本 2

.程序集 集_程序
.子程序 程序_运行Ex, 逻辑型, 公开
    .参数 命令行, 文本型
    .参数 等待运行完毕, 逻辑型, 可空
    .参数 窗口显示方式, 整数型, 可空, 参数值可以为以下常量之一：1、#隐藏窗口； 2、#普通激活； 3、#最小化激活； 4、#最大化激活； 5、#普通不激活； 6、#最小化不激活。如果省略本参数，默认为“普通激活”方式。
    .参数 标准输入数据, 字节集, 可空
    .参数 运行返回值, 整数型, 参考 可空, 该参数值为返回值，且[等待运行完毕]必须为真。
    .参数 标准输出数据, 字节集, 参考 可空, 该参数值为返回值，且[等待运行完毕]必须为真。
    .参数 标准错误数据, 字节集, 参考 可空, 该参数值为返回值，且[等待运行完毕]必须为真。
    .局部变量 startupInfo, STARTUPINFO
    .局部变量 pipeAttr, SECURITY_ATTRIBUTES
    .局部变量 processInfo, 精易_进程结构
    .局部变量 hRead, 整数型
    .局部变量 hWrite, 整数型
    .局部变量 hErrorRead, 整数型
    .局部变量 hErrorWrite, 整数型
    .局部变量 size, 整数型
    .局部变量 result, 逻辑型

    startupInfo.cb ＝ 68 ' sizeof(STARTUPINFO)
    startupInfo.dwFlags ＝ #STARTF_USESHOWWINDOW
    .判断开始 (窗口显示方式 ＝ #隐藏窗口)
        startupInfo.wShowWindow ＝ #SW_HIDE
    .判断 (窗口显示方式 ＝ #最小化激活)
        startupInfo.wShowWindow ＝ #SW_SHOWMINIMIZED
    .判断 (窗口显示方式 ＝ #最大化激活)
        startupInfo.wShowWindow ＝ #SW_SHOWMAXIMIZED
    .判断 (窗口显示方式 ＝ #普通不激活)
        startupInfo.wShowWindow ＝ #SW_SHOWNOACTIVATE
    .判断 (窗口显示方式 ＝ #最小化不激活)
        startupInfo.wShowWindow ＝ #SW_SHOWMINNOACTIVE
    .默认
        ' #普通激活
        startupInfo.wShowWindow ＝ #SW_SHOWNORMAL
    .判断结束
    .如果真 (是否为空 (标准输入数据) ＝ 假 或 是否为空 (标准输出数据) ＝ 假 或 是否为空 (标准错误数据) ＝ 假)
        startupInfo.dwFlags ＝ 位或 (startupInfo.dwFlags, #STARTF_USESTDHANDLES)
        pipeAttr.nLength ＝ #sizeof_SECURITY_ATTRIBUTES
        pipeAttr.bInheritHandle ＝ 真
        CreatePipe (hRead, hWrite, pipeAttr, 0)
        CreatePipe (hErrorRead, hErrorWrite, pipeAttr, 0)
        .如果真 (是否为空 (标准输入数据) ＝ 假)
            WriteFile (hWrite, 标准输入数据, 取字节集长度 (标准输入数据), 0, 0)
            startupInfo.hStdInput ＝ hRead
        .如果真结束
        .如果真 (是否为空 (标准输出数据) ＝ 假)
            startupInfo.hStdOutput ＝ hWrite
        .如果真结束
        .如果真 (是否为空 (标准错误数据) ＝ 假)
            startupInfo.hStdError ＝ hErrorWrite
        .如果真结束
        
    .如果真结束
    .如果真 (CreateProcessA (0, 命令行, 0, 0, 真, 0, 0, 0, startupInfo, processInfo))
        result ＝ 真
        .如果真 (等待运行完毕)
            WaitForSingleObject (processInfo.进程句柄, #INFINITE)
            .如果真 (是否为空 (运行返回值) ＝ 假)
                GetExitCodeProcess (processInfo.进程句柄, 运行返回值)
            .如果真结束
            .如果真 (是否为空 (标准输出数据) ＝ 假)
                .如果真 (PeekNamedPipe_字节集 (hRead, 标准输出数据, 0, 0, size, 0))
                    标准输出数据 ＝ 取空白字节集 (size)
                    .如果真 (size ＞ 0)
                        ReadFile (hRead, 标准输出数据, size, 0, 0)
                    .如果真结束
                    
                .如果真结束
                
            .如果真结束
            .如果真 (是否为空 (标准错误数据) ＝ 假)
                .如果真 (PeekNamedPipe_字节集 (hErrorRead, 标准错误数据, 0, 0, size, 0))
                    标准错误数据 ＝ 取空白字节集 (size)
                    .如果真 (size ＞ 0)
                        ReadFile (hErrorRead, 标准错误数据, size, 0, 0)
                    .如果真结束
                    
                .如果真结束
                
            .如果真结束
            
        .如果真结束
        CloseHandle (processInfo.进程句柄)
        CloseHandle (processInfo.线程句柄)
    .如果真结束
    .如果真 (是否为空 (标准输入数据) ＝ 假 或 是否为空 (标准输出数据) ＝ 假 或 是否为空 (标准错误数据) ＝ 假)
        CloseHandle (hRead)
        CloseHandle (hWrite)
        CloseHandle (hErrorRead)
        CloseHandle (hErrorWrite)
    .如果真结束
    返回 (result)

.子程序 程序_标准输入, 逻辑型, 公开
    .参数 数据, 字节集, 参考 可空, 该参数值为返回值
    .局部变量 handle, 整数型
    .局部变量 max, 整数型
    .局部变量 size, 整数型

    handle ＝ GetStdHandle (#STD_INPUT_HANDLE)
    .如果真 (handle ≠ 0)
        .如果真 (PeekNamedPipe_字节集 (handle, 数据, 0, 0, size, 0))
            数据 ＝ 取空白字节集 (size)
            .如果真 (size ＞ 0)
                ReadFile_字节集 (handle, 数据, size, 0, 0)
            .如果真结束
            返回 (真)
        .如果真结束
        
    .如果真结束
    返回 (假)

.子程序 程序_标准输出, 逻辑型, 公开
    .参数 数据, 字节集
    .局部变量 handle, 整数型

    handle ＝ GetStdHandle (#STD_OUTPUT_HANDLE)
    .如果真 (handle ≠ 0)
        返回 (WriteFile (handle, 数据, 取字节集长度 (数据), 0, 0))
    .如果真结束
    返回 (假)

.子程序 程序_锁定到任务栏, 逻辑型, 公开, 将指定的文件锁定到任务栏
    .参数 文件路径, 文本型

    返回 (程序_锁定到任务栏W (编码_Ansi到Unicode (文件路径, )))

.子程序 程序_锁定到任务栏W, 逻辑型, 公开, 将指定的文件锁定到任务栏
    .参数 文件路径, 字节集
    .局部变量 szMenuName, 字节集

    .如果真 (程序_伪装资源管理器 ())
        szMenuName ＝ 进程_取资源字符串W (编码_Ansi到Unicode (“shell32.dll”, ), 5386)
        返回 (系统_遍历右键菜单并执行W (文件路径, szMenuName))
    .如果真结束
    返回 (假)

.子程序 程序_从任务栏解锁, 逻辑型, 公开, 将指定的文件从任务栏取消固定
    .参数 文件路径, 文本型

    返回 (程序_从任务栏解锁W (编码_Ansi到Unicode (文件路径, )))

.子程序 程序_从任务栏解锁W, 逻辑型, 公开, 将指定的文件从任务栏取消固定
    .参数 文件路径, 字节集
    .局部变量 szMenuName, 字节集

    .如果真 (程序_伪装资源管理器 ())
        szMenuName ＝ 进程_取资源字符串W (编码_Ansi到Unicode (“shell32.dll”, ), 5387)
        返回 (系统_遍历右键菜单并执行W (文件路径, szMenuName))
    .如果真结束
    返回 (假)

.子程序 程序_内存中运行EXE, 逻辑型, 公开, 可以直接运行资源中的程序，不必释放。成功返回真，失败返回假。
    .参数 欲执行的程序, 字节集, , 欲执行的程序，不支持某些加了壳的程序，请自行测试。
    .参数 命令行, 文本型, 可空, 为程序提供的命令行参数，不需要请留空。
    .参数 外壳程序路径, 文本型, 可空, 外壳程序的路径(如果用系统程序做外壳，如cmd.exe、svchost.exe，可以实现穿防火墙，呵呵)，不支持某些程序，请自行测试；不在当前目录下要提供绝对路径；留空默认为cmd.exe，如果无法运行，请换用不同的程序尝试。
    .参数 等待程序运行完毕, 逻辑型, 可空, 默认为假，即不等待。
    .参数 窗口显示方式, 整数型, 可空, 1#隐藏窗口； 2#普通激活； 3#最小化激活； 4#最大化激活； 5#普通不激活； 6#最小化不激活。如果省略本参数，默认为“普通激活”方式。
    .参数 运行信息, 精易_进程结构, 参考 可空, 用来接收在内存中执行的exe的运行信息(进程、主线程的句柄和ID)。不需要可留空。
    .局部变量 idh, IMAGE_DOS_HEADER
    .局部变量 inh, IMAGE_NT_HEADERS
    .局部变量 ish, IMAGE_SECTION_HEADER
    .局部变量 si, STARTUPINFO
    .局部变量 context, CONTEXT86
    .局部变量 ImageBase, 整数型
    .局部变量 i, 整数型
    .局部变量 addr, 整数型
    .局部变量 lOffset, 整数型

    连续赋值 (0, 运行信息.进程标识符, 运行信息.进程句柄, 运行信息.线程标识符, 运行信息.线程句柄)
    .如果真 (欲执行的程序 ＝ { })
        返回 (假)
    .如果真结束
    RtlMoveMemory_IMAGE_DOS_HEADER (idh, 欲执行的程序 [1], Len_idh (idh))
    .如果真 (idh.e_magic ≠ 23117)
        返回 (假)
    .如果真结束
    RtlMoveMemory_IMAGE_NT_HEADERS (inh, 欲执行的程序 [idh.e_lfanew ＋ 1], Len_inh (inh))
    .如果真 (inh.Signature ≠ 17744)
        返回 (假)
    .如果真结束
    si.cb ＝ 68 ' sizeof(STARTUPINFO)
    .如果真 (是否为空 (窗口显示方式) ＝ 假 且 窗口显示方式 ≠ 2 且 窗口显示方式 ＞ 0 且 窗口显示方式 ≤ 6)
        si.dwFlags ＝ 1
        si.wShowWindow ＝ 多项选择 (窗口显示方式, 0, 5, 2, 3, 8, 7)
    .如果真结束
    .如果真 (CreateProcessA (0, 选择 (是否为空 (外壳程序路径), 取cmd路径 (), 外壳程序路径) ＋ 选择 (是否为空 (命令行) 或 命令行 ＝ “”, “”, “ ” ＋ 命令行), 0, 0, 假, 4, 0, 0, si, 运行信息) ＝ 假)
        返回 (假)
    .如果真结束
    context.ContextFlags ＝ 65538
    .如果真 (GetThreadContext (运行信息.线程句柄, context) ＝ 0)
        ClearProcess (运行信息)
        返回 (假)
    .如果真结束
    ReadProcessMemory (运行信息.进程句柄, context.Ebx ＋ 8, addr, 4, 0)
    .如果真 (addr ＝ 0)
        ClearProcess (运行信息)
        返回 (假)
    .如果真结束
    .如果真 (ZwUnmapViewOfSection (运行信息.进程句柄, addr) ＝ 0)
        ClearProcess (运行信息)
        返回 (假)
    .如果真结束
    ImageBase ＝ VirtualAllocEx (运行信息.进程句柄, inh.OptionalHeader.ImageBase, inh.OptionalHeader.SizeOfImage, 12288, 4)
    .如果真 (ImageBase ＝ 0)
        ImageBase ＝ VirtualAllocEx (运行信息.进程句柄, 0, inh.OptionalHeader.SizeOfImage, 12288, 4)
    .如果真结束
    .如果真 (ImageBase ＝ 0)
        ClearProcess (运行信息)
        返回 (假)
    .如果真结束
    WriteProcessMemory (运行信息.进程句柄, ImageBase, 欲执行的程序 [1], inh.OptionalHeader.SizeOfHeaders, 0)
    lOffset ＝ idh.e_lfanew ＋ Len_inh (inh)
    .计次循环首 (inh.FileHeader.NumberOfSections, i)
        RtlMoveMemory_IMAGE_SECTION_HEADER (ish, 欲执行的程序 [lOffset ＋ (i － 1) × 40 ＋ 1], Len_ish (ish))
        .如果真 (ish.PointerToRawData ＋ 1 ＞ 字节集_取长度 (欲执行的程序))
            ClearProcess (运行信息)
            返回 (假)
        .如果真结束
        WriteProcessMemory (运行信息.进程句柄, ImageBase ＋ ish.VirtualAddress, 欲执行的程序 [ish.PointerToRawData ＋ 1], ish.SizeOfRawData, 0)
        VirtualProtectEx (运行信息.进程句柄, ImageBase ＋ ish.VirtualAddress, ish.VirtualSize, Protect (ish.characteristics), addr)
    .计次循环尾 ()
    WriteProcessMemory_整数35 (运行信息.进程句柄, context.Ebx ＋ 8, ImageBase, 4, 0)
    context.Eax ＝ ImageBase ＋ inh.OptionalHeader.AddressOfEntryPoint
    SetThreadContext (运行信息.线程句柄, context)
    ResumeThread (运行信息.线程句柄)
    .如果真 (等待程序运行完毕)
        WaitForSingleObject (运行信息.进程句柄, -1)
    .如果真结束
    .如果真 (是否为空 (运行信息))
        CloseHandle (运行信息.线程句柄)
        CloseHandle (运行信息.进程句柄)
    .如果真结束
    返回 (真)

.子程序 取cmd路径, 文本型
    .局部变量 size, 整数型
    .局部变量 name, 文本型

    size ＝ GetEnvironmentVariable (“ComSpec”, “”, 0)
    .计次循环首 (size, )
        name ＝ name ＋ “ ”
    .计次循环尾 ()
    GetEnvironmentVariable (“ComSpec”, name, size)
    返回 (name)

.子程序 ClearProcess
    .参数 运行信息, 精易_进程结构, 参考

    TerminateProcess (运行信息.进程句柄, 0)
    CloseHandle (运行信息.线程句柄)
    CloseHandle (运行信息.进程句柄)
    连续赋值 (0, 运行信息.进程标识符, 运行信息.进程句柄, 运行信息.线程标识符, 运行信息.线程句柄)

.子程序 Protect, 整数型
    .参数 characteristics, 整数型

    返回 (多项选择 (RShift (characteristics, 29) ＋ 1, 1, 16, 2, 32, 4, 64, 4, 64))

.子程序 RShift, 整数型
    .参数 lValue, 整数型
    .参数 lNumberOfBitsToShift, 整数型

    返回 (vbLongToULong (lValue) ÷ 数值_求次方 (2, lNumberOfBitsToShift))

.子程序 vbLongToULong, 双精度小数型
    .参数 Value, 双精度小数型

    .如果真 (Value ＜ 0)
        返回 (Value ＋ 4294967296)
    .如果真结束
    返回 (Value)

.子程序 数值_求次方, 双精度小数型
    .参数 欲求次方数值, 双精度小数型
    .参数 次方数, 双精度小数型

    置入代码 ({ 221, 69, 16, 221, 69, 8, 217, 241, 217, 192, 217, 252, 220, 225, 217, 201, 217, 224, 217, 240, 217, 232, 222, 193, 217, 253, 221, 217, 221, 93, 248, 139, 85, 252, 139, 69, 248, 201, 194, 16, 0 })
    返回 (0)

.子程序 程序_生成GUID, 文本型, 公开, 生成标准的GUID格式：635897F8-2A48-4882-B3E1-823B8E5B6DF8
    .局部变量 guid, 字节集
    .局部变量 b2hex, 文本型
    .局部变量 pb2hex, 整数型
    .局部变量 szTemp, 文本型
    .局部变量 pszTemp, 整数型

    guid ＝ 取空白字节集 (16) ' sizeof(GUID)
    CoCreateGuid (guid)
    b2hex ＝ 字节集_字节集到十六进制2 (guid)
    pb2hex ＝ 取指针文本_ (b2hex)
    ' b2hex ＝ bin2hex (guid)  ' 汇编版本会更快
    szTemp ＝ 取空白文本 (37)
    pszTemp ＝ 取指针文本_ (szTemp)
    memcpy (pszTemp ＋ 6, pb2hex ＋ 0, 2)
    memcpy (pszTemp ＋ 4, pb2hex ＋ 2, 2)
    memcpy (pszTemp ＋ 2, pb2hex ＋ 4, 2)
    memcpy (pszTemp ＋ 0, pb2hex ＋ 6, 2)
    __set_byte (pszTemp, 8, 45)
    memcpy (pszTemp ＋ 11, pb2hex ＋ 8, 2)
    memcpy (pszTemp ＋ 9, pb2hex ＋ 10, 2)
    __set_byte (pszTemp, 13, 45)
    memcpy (pszTemp ＋ 16, pb2hex ＋ 12, 2)
    memcpy (pszTemp ＋ 14, pb2hex ＋ 14, 2)
    __set_byte (pszTemp, 18, 45)
    memcpy (pszTemp ＋ 19, pb2hex ＋ 16, 2)
    memcpy (pszTemp ＋ 21, pb2hex ＋ 18, 2)
    __set_byte (pszTemp, 23, 45)
    memcpy (pszTemp ＋ 24, pb2hex ＋ 20, 12)
    __set_byte (pszTemp, 36, 0)
    返回 (szTemp)

.子程序 程序_COM生成GUID, 文本型, 公开, 生成返回一个新的全球唯一的随机GUID文本值
    .参数 GUID, GUID, 参考 可空, 保存生成的GUID到此参数变量中
    .局部变量 TEMP, 字节集

    TEMP ＝ 取空白字节集 (128)
    COM_创建GUID_ (GUID)
    StringFromGUID (GUID, TEMP, 128)
    返回 (编码_Unicode到Ansi (TEMP))

.子程序 程序_取文件版本号, 文本型, 公开, 取某程序的版本号信息，若为易语言程序，该版本号可以在配置里修改，如果在调试中，则返回空文本。一个易语言程序会获取到版本号和创建号，比如1.1.0.0，如果只需要1.1的部分，第三个参数设置为真即可。如果第一个参数不为空，则获取其他文件的版本号信息。源码由雪山凌狐提供
    .参数 程序路径, 文本型, 可空, 取出指定程序的版本号信息，如果留空，则取当前执行文件的版本号
    .参数 错误信息, 文本型, 参考 可空, 用于返回错误信息的
    .参数 忽略创建号, 逻辑型, 可空, 默认为真，忽略创建号，比如获取到的版本号为1.1.0.0，会返回1.1
    .局部变量 版本号, 文本型
    .局部变量 临时文件名, 文本型
    .局部变量 内容分割, 文本型, , "0"

    临时文件名 ＝ 程序路径
    
    .如果真 (是否为空 (忽略创建号))
        忽略创建号 ＝ 真
    .如果真结束
    
    .如果真 (目录_是否符合规范 (临时文件名) ＝ 假 且 临时文件名 ≠ “”)
        错误信息 ＝ “当前文件名不符合规范”
        返回 (“”)
    .如果真结束
    .如果真 (临时文件名 ＝ “”)
        临时文件名 ＝ 取运行目录 () ＋ “\” ＋ 取执行文件名 ()
    .如果真结束
    
    版本号 ＝ 文件_取文件版本号 (临时文件名, 错误信息)
    
    .如果真 (忽略创建号)
        内容分割 ＝ 分割文本 (版本号, “.”, )
        .如果真 (取数组成员数 (内容分割) ＝ 4)
            版本号 ＝ 内容分割 [1] ＋ “.” ＋ 内容分割 [2]
        .如果真结束
        
    .如果真结束
    
    返回 (版本号)

.子程序 程序_是否关闭, 逻辑型, 公开, 弹出一个信息框，返回操作信息框的结果
    返回 (信息框 (“确定要关闭本窗口吗？”, 位或 (#确认取消钮, #询问图标), “友情提醒”) ＝ #确认钮)

.子程序 程序_调用DLL命令, 整数型, 公开, 调用失败返回-1，调用成功返回命令自身的值。 注意：被调用的命令必须有4个参数（前2个整数型,后2个文本型），否则会调用失败。
    .参数 DLL路径, 文本型, , DLL完整路径
    .参数 函数名称, 文本型, , 要调用的子程序命令名称
    .参数 参数1, 整数型, 可空, 参数如果非整数可用指针传递
    .参数 参数2, 整数型, 可空
    .参数 参数3, 整数型, 可空
    .参数 参数4, 整数型, 可空
    .参数 参数5, 整数型, 可空
    .参数 参数6, 整数型, 可空
    .参数 参数7, 整数型, 可空
    .参数 参数8, 整数型, 可空
    .参数 参数9, 整数型, 可空
    .参数 参数10, 整数型, 可空
    .参数 参数11, 整数型, 可空
    .参数 参数12, 整数型, 可空
    .参数 参数13, 整数型, 可空
    .参数 参数14, 整数型, 可空
    .参数 参数15, 整数型, 可空
    .局部变量 模块句柄, 整数型
    .局部变量 函数地址, 整数型
    .局部变量 ret, 整数型

    模块句柄 ＝ LoadLibraryA (DLL路径) ' 载入指定的动态链接库，并将它映射到当前进程使用的地址空间
    .如果真 (模块句柄 ＝ 0)
        返回 (-1)
    .如果真结束
    函数地址 ＝ GetProcAddress (模块句柄, 函数名称)
    .如果 (函数地址 ≠ 0)
        ret ＝ 调用子程序_ (函数地址, 参数1, 参数2, 参数3, 参数4, 参数5, 参数6, 参数7, 参数8, 参数9, 参数10, 参数11, 参数12, 参数13, 参数14, 参数15)
    .否则
        ret ＝ -1
    .如果结束
    FreeLibrary (模块句柄) ' 释放动态链接库
    返回 (ret)

.子程序 程序_延时, 逻辑型, 公开, 不占用cpu，窗口不卡死，不影响其它代码执行
    .参数 延时间隔, 长整数型, 可空, 1000毫秒 = 1秒  留空为无限等待
    .参数 延时单位, 整数型, 可空, 默认为毫秒  0=毫秒  1=秒  2=分钟  3=小时
    .局部变量 局_时间句柄, 整数型
    .局部变量 局_时间, 程序延时

    .判断开始 (延时单位 ＝ 0 且 是否为空 (延时间隔))
        延时间隔 ＝ 5000 × 60 × 60
        延时单位 ＝ 5000 × 60 × 60
    .判断 (延时单位 ＝ 0)
        延时单位 ＝ 1
    .判断 (延时单位 ＝ 1)
        延时单位 ＝ 1000
    .判断 (延时单位 ＝ 2)
        延时单位 ＝ 1000 × 60
    .判断 (延时单位 ＝ 3)
        延时单位 ＝ 1000 × 60 × 60
    .默认
        
    .判断结束
    局_时间.成员_时间 ＝ -10 × 延时间隔 × 1000 × 延时单位
    局_时间句柄 ＝ CreateWaitableTimerA (0, 假, 0)
    SetWaitableTimer (局_时间句柄, 局_时间, 0, 0, 0, 假)
    .判断循环首 (MsgWaitForMultipleObjects (1, 局_时间句柄, 假, -1, 255) ≠ 0)
        处理事件 ()
    .判断循环尾 ()
    CloseHandle (局_时间句柄)
    返回 (真)

.子程序 程序_延时1, 逻辑型, 公开, 通过创建一个 I/O 完成端口并等待操作完成来实现延迟执行的效果
    .参数 延时间隔, 整数型, , 毫秒
    .局部变量 hCompletionPort, 整数型

    hCompletionPort ＝ CreateIoCompletionPort (GetCurrentProcess (), #NULL, 0, 0)
    .如果真 (hCompletionPort ≠ #NULL)
        GetQueuedCompletionStatus (hCompletionPort, #NULL, #NULL, #NULL, 延时间隔)
        CloseHandle (hCompletionPort)
        返回 (真)
    .如果真结束
    返回 (假)

.子程序 程序_条件判断, 逻辑型, 公开
    .参数 条件文本, 文本型
    .参数 条件内存地址, 整数型, 可空
    .局部变量 局_时间句柄, 整数型
    .局部变量 局_时间, 程序延时
    .局部变量 延时间隔, 整数型
    .局部变量 内存共享, 内存共享

    局_时间.成员_时间 ＝ -10 × 5000 × 1000 × 1000
    局_时间句柄 ＝ CreateWaitableTimerA (0, 假, 0)
    SetWaitableTimer (局_时间句柄, 局_时间, 0, 0, 0, 假)
    .判断循环首 (MsgWaitForMultipleObjects (1, 局_时间句柄, 假, -1, 255) ≠ 0)
        .如果真 (条件文本 ＝ 到文本 (内存共享.读取 (条件内存地址)))
            内存共享.释放 (条件内存地址)
            CloseHandle (局_时间句柄)
            返回 (真)
        .如果真结束
        处理事件 ()
    .判断循环尾 ()
    .如果真 (局_时间句柄 ≠ 0)
        CloseHandle (局_时间句柄)
    .如果真结束
    返回 (假)

.子程序 程序_等待窗口出现, 整数型, 公开, 如果目标窗口出现则返回窗口句柄，否则将一直等待，超时返回 -1 。
    .参数 父句柄, 整数型, 可空, 父窗口句柄
    .参数 窗口标题, 文本型, 可空, 指定窗口标题。二选一
    .参数 窗口类名, 文本型, 可空, 指定窗口类名。二选一
    .参数 超时返回, 整数型, 可空, 单位为毫秒，超过此时间等待还没结果则返回假，留空则一直等待
    .参数 是否顶端, 逻辑型, 可空, 默认为假。如果为真，顶端窗口的标题或类名和指定的相同才返回窗口句柄。
    .局部变量 局_延时, 整数型
    .局部变量 局_启动时间, 整数型
    .局部变量 局_窗口句柄, 整数型

    .如果真 (是否为空 (窗口标题) 且 是否为空 (窗口类名))
        输出调试文本 (“需指定一个窗口标题或窗口类名！”)
        返回 (-1)
    .如果真结束
    .如果 (超时返回 ＞ 0)
        局_延时 ＝ 超时返回
    .否则
        局_延时 ＝ 1000 × 10000
    .如果结束
    局_启动时间 ＝ 取启动时间 ()
    .判断循环首 (取启动时间 () － 局_启动时间 ＜ 局_延时)
        .如果 (是否顶端)
            局_窗口句柄 ＝ 窗口_取顶端窗口句柄 ()
            .如果真 (是否为空 (窗口标题) ＝ 假 且 窗口_取标题 (局_窗口句柄) ＝ 窗口标题)
                返回 (局_窗口句柄)
            .如果真结束
            .如果真 (是否为空 (窗口类名) ＝ 假 且 窗口_取类名 (局_窗口句柄) ＝ 窗口类名)
                返回 (局_窗口句柄)
            .如果真结束
            
        .否则
            局_窗口句柄 ＝ 窗口_取句柄 (父句柄, , 窗口类名, 窗口标题)
            .如果真 (窗口_句柄是否有效 (局_窗口句柄))
                返回 (局_窗口句柄)
            .如果真结束
            
        .如果结束
        程序_延时 (50, )
    .判断循环尾 ()
    返回 (-1)

.子程序 程序_等待窗口消失, 逻辑型, 公开, 如果目标窗口不存在返回真 否则将一直等待，可以在第三个参数中设置超时返回
    .参数 窗口标题, 文本型, 可空, 窗口标题
    .参数 窗口类名, 文本型, 可空, 窗口类名
    .参数 超时返回, 整数型, 可空, 单位为毫秒,超过此时间等待还没结果则返回假,留空则一直等待
    .局部变量 局_启动时间, 整数型
    .局部变量 局_窗口句柄, 整数型
    .局部变量 局_延时, 整数型

    .如果 (超时返回 ＞ 0)
        局_延时 ＝ 超时返回
    .否则
        局_延时 ＝ 1000 × 10000
    .如果结束
    局_启动时间 ＝ 取启动时间 ()
    .判断循环首 (取启动时间 () － 局_启动时间 ＜ 局_延时)
        局_窗口句柄 ＝ 窗口_取句柄 (, , 窗口类名, 窗口标题)
        .如果真 (窗口_句柄是否有效 (局_窗口句柄) ＝ 假)
            返回 (真)
        .如果真结束
        程序_延时 (50)
    .判断循环尾 ()
    返回 (假)

.子程序 程序_等待句柄消失, 逻辑型, 公开, 如果目标句柄存在返回真 否则将一直等待，可以在第二个参数中设置超时返回
    .参数 窗口句柄, 整数型, , 目标窗口句柄
    .参数 超时返回, 整数型, 可空, 单位为毫秒,超过此时间等待还没结果则返回假,留空则一直等待
    .局部变量 局_启动时间, 整数型
    .局部变量 局_延时, 整数型

    .如果 (超时返回 ＞ 0)
        局_延时 ＝ 超时返回
    .否则
        局_延时 ＝ 1000 × 10000
    .如果结束
    局_启动时间 ＝ 取启动时间 ()
    .判断循环首 (取启动时间 () － 局_启动时间 ＜ 局_延时)
        .如果真 (窗口_句柄是否有效 (窗口句柄) ＝ 假)
            返回 (真)
        .如果真结束
        程序_延时 (50)
    .判断循环尾 ()
    返回 (假)

.子程序 程序_等待控件内容改变, 逻辑型, 公开, 等待一个控件的内容被改变，如果该控件的内容和第2个参数的文本一样，则返回真
    .参数 控件句柄, 整数型, , 目标窗口句柄
    .参数 控件内容, 文本型, , 控件的内容
    .参数 超时返回, 整数型, 可空, 单位为毫秒,超过此时间等待还没结果则返回假,留空则一直等待
    .局部变量 局_启动时间, 整数型
    .局部变量 局_延时, 整数型

    .如果 (超时返回 ＞ 0)
        局_延时 ＝ 超时返回
    .否则
        局_延时 ＝ 1000 × 10000
    .如果结束
    局_启动时间 ＝ 取启动时间 ()
    .判断循环首 (取启动时间 () － 局_启动时间 ＜ 局_延时)
        .如果真 (窗口_取控件内容 (控件句柄) ＝ 控件内容)
            返回 (真)
        .如果真结束
        程序_延时 (50)
    .判断循环尾 ()
    返回 (假)

.子程序 程序_重启, , 公开, 重启当前程序
    .参数 窗口显示方式, 整数型, 可空, 可空：默认为正常。说明：重启后，窗口的显示方式。1、#隐藏窗口； 2、#普通激活； 3、#最小化激活； 4、#最大化激活； 5、#普通不激活； 6、#最小化不激活
    .参数 重启延时, 整数型, 可空, 可空。默认为1秒，最快。
    .局部变量 局_文本, 文本型
    .局部变量 局_临时文件名, 文本型

    .如果真 (是否为调试版 ())
        提示框 (“你好，在调试状态下不能重启程序”)
        返回 ()
    .如果真结束
    .如果真 (是否为空 (重启延时) 或 重启延时 ＜ 1)
        重启延时 ＝ 2
    .如果真结束
    局_临时文件名 ＝ 取运行目录 () ＋ “\” ＋ 取执行文件名 ()
    .如果真 (文件是否存在 (局_临时文件名) ＝ 假)
        返回 ()
    .如果真结束
    局_文本 ＝ 子文本替换 (#常量_重启, “<文件名>”, 文件_到短文件名 (局_临时文件名), , 1, 真)
    局_文本 ＝ 子文本替换 (局_文本, “秒数”, 到文本 (重启延时), , 1, 真)
    写到文件 (取运行目录 () ＋ “\Restart.bat”, 到字节集 (局_文本))
    运行 (取运行目录 () ＋ “\Restart.bat”, 假, 1)
    进程_结束 ()

.子程序 程序_更新, 文本型, 公开, 返回要运行命令行 万能更新程序 下载和例程使用说明地址: http://bbs.125.la/thread-20780-1-1.html
    .参数 万能更新程序地址, 文本型, , 万能更新程序地址
    .参数 启动窗口标题, 文本型, , 更新程序的启动窗口标题
    .参数 超级链接标题, 文本型, , 更新进度条下方的超级链接标题
    .参数 超级链接地址, 文本型, , 更新进度条下方的超级链接地址
    .参数 本地程序地址, 文本型, , 要更新的文件路径地址
    .参数 网络程序地址, 文本型, , 只支持zip和exe格式的下载文件
    .参数 信息框提示文本, 文本型, , 程序更新完成后的信息框提示文本,如果填入 不提示 三个汉字,将不会弹出信息框提示
    .参数 是否运行程序, 逻辑型, , 更新完成是否运行程序,一般为软件的主程序才设置为真
    .局部变量 局_临时文本, 文本型
    .局部变量 局_分割符, 文本型

    局_分割符 ＝ “<#>”
    局_临时文本 ＝ 启动窗口标题 ＋ 局_分割符 ＋ 超级链接标题 ＋ 局_分割符 ＋ 超级链接地址 ＋ 局_分割符 ＋ 本地程序地址 ＋ 局_分割符 ＋ 网络程序地址 ＋ 局_分割符 ＋ 信息框提示文本 ＋ 局_分割符 ＋ 到文本 (是否运行程序)
    局_临时文本 ＝ “ ” ＋ 子文本替换 (局_临时文本, “ ”, “<?>”, , , 真)
    ShellExecuteA (GetActiveWindow (), “”, 万能更新程序地址, 局_临时文本, “”, 5)
    返回 (局_临时文本)

.子程序 程序_删除自身, , 公开, 删除程序自身EXE文件
    .局部变量 路径, 文本型
    .局部变量 后缀, 文本型

    路径 ＝ 取运行目录 () ＋ “\”
    后缀 ＝ #引号 ＋ “)”
    写到文件 (路径 ＋ “tem.vbs”, 到字节集 (#自我删除1 ＋ 路径 ＋ 取执行文件名 () ＋ 后缀 ＋ #换行符 ＋ #自我删除0 ＋ 路径 ＋ “tem.vbs” ＋ 后缀))
    置文件属性 (路径 ＋ “tem.vbs”, 2)
    文件_执行 (路径 ＋ “tem.vbs”)
    结束 ()

.子程序 程序_删除自身1, , 公开, 删除程序自身EXE文件
    .局部变量 nSize, 整数型
    .局部变量 szFileName, 字节集
    .局部变量 szComspec, 字节集
    .局部变量 szBat, 字节集
    .局部变量 stShellDel, SHELLEXECUTEINFOW
    .局部变量 len, 整数型

    nSize ＝ #MAX_PATH × 2
    szFileName ＝ 取空白字节集 (nSize)
    szComspec ＝ 取空白字节集 (nSize)
    
    GetModuleFileNameW (0, szFileName, #MAX_PATH)
    len ＝ GetShortPathNameW (szFileName, szFileName, #MAX_PATH)
    .如果真 (len ≠ 0 且 GetEnvironmentVariableW (编码_Ansi到Unicode (“COMSPEC”, ), szComspec, #MAX_PATH) ≠ 0)
        
        ' /c del xxx > nul
        szBat ＝ { 47, 0, 99, 0, 32, 0, 100, 0, 101, 0, 108, 0, 32, 0 } ＋ 取字节集左边 (szFileName, len × 2) ＋ { 32, 0, 62, 0, 32, 0, 110, 0, 117, 0, 108, 0, 0, 0 }
        stShellDel.cbSize ＝ 60 ' sizeof(SHELLEXECUTEINFO)
        
        ' 命令窗口进程句柄，ShellExecuteEx函数执行时设置
        stShellDel.hwnd ＝ 0
        stShellDel.lpVerb ＝ 编码_Ansi到Unicode (“Open”, )
        stShellDel.lpFile ＝ szComspec
        stShellDel.lpParameters ＝ szBat
        stShellDel.lpDirectory ＝ { }
        stShellDel.nShow ＝ #SW_HIDE
        
        ' 设置为SellExecuteEx函数结束后进程退出
        stShellDel.fMask ＝ #SEE_MASK_NOCLOSEPROCESS
        
        ' 创建执行命令窗口进程
        .如果真 (ShellExecuteExW (stShellDel))
            ' 设置命令行进程的执行级别为空闲执行，这使本程序有足够的时间从内存中退出
            SetPriorityClass (stShellDel.hProcess, #IDLE_PRIORITY_CLASS)
            
            ' 设置本程序进程的执行级别为实时执行，这保证本程序能立即获取CPU执行权，快速退出
            SetPriorityClass (GetCurrentProcess (), #REALTIME_PRIORITY_CLASS)
            SetThreadPriority (GetCurrentThread (), #THREAD_PRIORITY_TIME_CRITICAL)
            
            ' 通知Windows资源管理器，本程序文件已经被删除
            SHChangeNotify (#SHCNE_DELETE, #SHCNF_PATH, 取指针字节集_ (szFileName), 0)
            ExitProcess (0)
        .如果真结束
        
    .如果真结束
    

.子程序 程序_出错退出, , 公开, 让程序内部崩溃方式结束运行。感谢goomoo提供提示
    .局部变量 字集, 字节集

    .判断循环首 (字集 ＝ { })
        字集 ＝ 字集 ＋ 取空白字节集 (1024 × 1024 × 1024)
    .判断循环尾 ()

.子程序 程序_是否被调试, 逻辑型, 公开, 判断自己的软件是否被调试；返回真，正在被调试，返回假，没有被调试；
    返回 (IsDebuggerPresent ())

.子程序 程序_禁止重复运行, , 公开, 禁止当前程序多开运行
    .参数 标识文本, 文本型, 可空, 尽量输复杂一点的文本！反斜杠字符除外
    .参数 是否弹出信息框提示, 逻辑型, 可空, 默认为假,不弹出提示;
    .参数 消息框提示文本, 文本型, 可空, 第二个参数设置为假,该参数则无效
    .参数 消息框提示图标, 整数型, 可空, 默认为信息图标，如：#信息图标
    .参数 是否前端显示程序, 逻辑型, 可空, 如果已重复运行,是否将程序在前端显示
    .参数 挂接事件, 子程序指针, 可空, 本参数不为空时优先执行
    .局部变量 局_句柄, 整数型
    .局部变量 hEvent, 整数型

    .如果真 (标识文本 ＝ “”)
        标识文本 ＝ 校验_取md5 (到字节集 (“你懒得输入，我就写死，略略”)) ' 标识文本，如果有重复的，就不能打开事件，实现禁止
    .如果真结束
    hEvent ＝ OpenEventA (#EVENT_ALL_ACCESS, 假, 标识文本)
    .如果真 (hEvent ≠ #NULL)
        .如果真 (是否为空 (挂接事件) ＝ 假)
            调用子程序_ (到整数 (挂接事件), , , , , , , , , , , , , , , )
        .如果真结束
        .如果真 (是否弹出信息框提示)
            .如果真 (是否为空 (消息框提示文本))
                消息框提示文本 ＝ “对不起,该进程已打开!”
            .如果真结束
            信息框 (消息框提示文本, 消息框提示图标, “友情提醒:”)
        .如果真结束
        .如果真 (是否前端显示程序)
            局_句柄 ＝ 进程_名取句柄 (取执行文件名 ())
            .如果真 (IsWindowVisible (局_句柄) ＝ 假)
                窗口_强制显示 (局_句柄, 假)
            .如果真结束
            .如果真 (窗口_是否最小化 (局_句柄))
                窗口_还原 (局_句柄)
            .如果真结束
            窗口_激活 (局_句柄)
        .如果真结束
        结束 ()
    .如果真结束
    CreateEvent (#NULL, 假, 假, 标识文本)

.子程序 程序_添加到IE工具栏, , 公开, 在IE的工具栏上添加自己的软件快捷方式
    .参数 主程序路径, 文本型, , 主程序路径
    .参数 提示内容, 文本型, , 如:精易编程助手
    .参数 程序图标路径, 文本型, , 在工具栏上显示的图标,格式为 ico
    .参数 程序图标点燃图标路径, 文本型, , 在工具栏上显示的图标,格式为 ico

    写注册项 (#本地机器, “SOFTWARE\Microsoft\Internet Explorer\Extensions\{BF5DC4AE-258C-43d5-9D80-1F7ACD734DD8}\ButtonText”, 提示内容)
    写注册项 (#本地机器, “SOFTWARE\Microsoft\Internet Explorer\Extensions\{BF5DC4AE-258C-43d5-9D80-1F7ACD734DD8}\CLSID”, “{1FBA04EE-3024-11D2-8F1F-0000F87ABD16}”)
    写注册项 (#本地机器, “SOFTWARE\Microsoft\Internet Explorer\Extensions\{BF5DC4AE-258C-43d5-9D80-1F7ACD734DD8}\Default visible”, “Yes”)
    写注册项 (#本地机器, “SOFTWARE\Microsoft\Internet Explorer\Extensions\{BF5DC4AE-258C-43d5-9D80-1F7ACD734DD8}\Exec”, 主程序路径) ' 程序路径
    写注册项 (#本地机器, “SOFTWARE\Microsoft\Internet Explorer\Extensions\{BF5DC4AE-258C-43d5-9D80-1F7ACD734DD8}\HotIcon”, 程序图标点燃图标路径) ' 点燃图标
    写注册项 (#本地机器, “SOFTWARE\Microsoft\Internet Explorer\Extensions\{BF5DC4AE-258C-43d5-9D80-1F7ACD734DD8}\Icon”, 程序图标路径) ' 程序图标
    写注册项 (#本地机器, “SOFTWARE\Microsoft\Internet Explorer\Extensions\{BF5DC4AE-258C-43d5-9D80-1F7ACD734DD8}\MenuText”, 提示内容)
    写注册项 (#本地机器, “SOFTWARE\Microsoft\Internet Explorer\Extensions\{BF5DC4AE-258C-43d5-9D80-1F7ACD734DD8}\MenuStatusBar”, 提示内容)

.子程序 程序_加入右键菜单, 逻辑型, 公开, 把目标程序加入到右键菜单中,成功=真
    .参数 菜单显示名, 文本型, , 不能有符号，如“\”等
    .参数 目标程序名称, 文本型, 可空, 填空为程序本身
    .参数 是否删除, 逻辑型, 可空, 真=删除，假=不删除，默认为假，添加右键菜单
    .参数 命令行, 文本型, 可空
    .局部变量 局_命令行, 文本型

    .如果真 (是否删除 ＝ 真)
        .如果真 (删除注册项 (#根类, “*\shell\” ＋ 菜单显示名 ＋ “\command”) ＝ 真)
            删除注册项 (#根类, “*\shell\” ＋ 菜单显示名)
            返回 (真)
        .如果真结束
        返回 (假)
    .如果真结束
    .如果真 (取文本长度 (命令行) ＞ 0)
        局_命令行 ＝ “ ” ＋ 命令行
    .如果真结束
    .如果真 (寻找文本 (菜单显示名, “\”, , 假) ＝ -1)
        .如果真 (是否为空 (目标程序名称) ＝ 真)
            目标程序名称 ＝ 取运行目录 () ＋ “\” ＋ 取执行文件名 ()
        .如果真结束
        .如果真 (写注册项 (#根类, “*\shell\” ＋ 菜单显示名 ＋ “\command\”, 目标程序名称 ＋ 局_命令行 ＋ “ ” ＋ #引号 ＋ “%1” ＋ #引号) ＝ 真)
            返回 (真)
        .如果真结束
        
    .如果真结束
    返回 (假)
    
    

.子程序 系统_关联右键菜单带图标, , 公开, 在win7系统中的右键菜单最上方添加一个带图标的菜单
    .参数 右键名称, 文本型
    .参数 程序路径, 文本型, 可空, 可空，留空为程序自身
    .参数 图标路径, 文本型, 可空, 留空为程序的图标
    .参数 是否删除, 逻辑型, 可空, 真为删除指定右键名称
    .局部变量 注册表, 注册表操作

    .如果真 (是否删除 ＝ 真)
        注册表.删除项 (“HKEY_LOCAL_MACHINE\SOFTWARE\Classes\*\shell\” ＋ 右键名称)
        返回 ()
    .如果真结束
    注册表.写字符串值 (“HKEY_LOCAL_MACHINE\SOFTWARE\Classes\*\shell\”, 右键名称, “”)
    注册表.写多字符串值 (“HKEY_LOCAL_MACHINE\SOFTWARE\Classes\*\shell\” ＋ 右键名称, “”, 右键名称)
    .如果真 (是否为空 (程序路径) ＝ 真)
        程序路径 ＝ 取运行目录 () ＋ “\” ＋ 取执行文件名 ()
    .如果真结束
    .如果 (是否为空 (图标路径) ＝ 真)
        注册表.写字符串值 (“HKEY_LOCAL_MACHINE\SOFTWARE\Classes\*\shell\” ＋ 右键名称, “Icon”, 程序路径 ＋ “,0”) ' 取程序的图标为右击图标
    .否则
        注册表.写字符串值 (“HKEY_LOCAL_MACHINE\SOFTWARE\Classes\*\shell\” ＋ 右键名称, “Icon”, 图标路径 ＋ “,0”)
    .如果结束
    注册表.写字符串值 (“HKEY_LOCAL_MACHINE\SOFTWARE\Classes\*\shell\” ＋ 右键名称 ＋ “\command”, “”, 程序路径 ＋ “ ” ＋ #引号 ＋ “%1” ＋ #引号)

.子程序 程序_写日志, , 公开, 在程序根目录建立一个txt文件用于记录相关日志内容
    .参数 日志内容, 文本型
    .参数 日志文件路径, 文本型, 可空, 写日记文件的路径，可空，默认在运行目录下写出
    .局部变量 文件号, 整数型

    .如果真 (是否为空 (日志文件路径))
        日志文件路径 ＝ 取运行目录 () ＋ “\运行日志.txt”
    .如果真结束
    
    .如果真 (文件是否存在 (日志文件路径) ＝ 假)
        写到文件 (日志文件路径, { })
    .如果真结束
    文件号 ＝ 打开文件 (日志文件路径, , )
    插入文本行 (文件号, 到文本 (取现行时间 ()) ＋ “   ” ＋ 日志内容)
    关闭文件 (文件号)

.子程序 程序_加入IE工具栏, , 公开, 把程序加入到IE工具栏,重启IE生效
    .参数 程序名称, 文本型
    .参数 程序路径, 文本型, 可空, 留空为自身程序路径
    .参数 显示图标, 文本型, 可空, 留空为系统默认程序图标
    .参数 是否删除, 逻辑型, 可空, 真=删除

    .如果真 (是否删除 ＝ 真)
        删除注册项 (#本地机器, “SOFTWARE\Microsoft\Internet Explorer\Extensions\{BF5DC4AE-258C-43d5-9D80-1F7ACD734DD8}\ButtonText”)
        删除注册项 (#本地机器, “SOFTWARE\Microsoft\Internet Explorer\Extensions\{BF5DC4AE-258C-43d5-9D80-1F7ACD734DD8}\CLSID”)
        删除注册项 (#本地机器, “SOFTWARE\Microsoft\Internet Explorer\Extensions\{BF5DC4AE-258C-43d5-9D80-1F7ACD734DD8}\Default visible”)
        删除注册项 (#本地机器, “SOFTWARE\Microsoft\Internet Explorer\Extensions\{BF5DC4AE-258C-43d5-9D80-1F7ACD734DD8}\Exec”) ' 程序位置(路径)
        删除注册项 (#本地机器, “SOFTWARE\Microsoft\Internet Explorer\Extensions\{BF5DC4AE-258C-43d5-9D80-1F7ACD734DD8}\HotIcon”) ' 点燃图标
        删除注册项 (#本地机器, “SOFTWARE\Microsoft\Internet Explorer\Extensions\{BF5DC4AE-258C-43d5-9D80-1F7ACD734DD8}\Icon”) ' 程序图标
        删除注册项 (#本地机器, “SOFTWARE\Microsoft\Internet Explorer\Extensions\{BF5DC4AE-258C-43d5-9D80-1F7ACD734DD8}\MenuText”)
        删除注册项 (#本地机器, “SOFTWARE\Microsoft\Internet Explorer\Extensions\{BF5DC4AE-258C-43d5-9D80-1F7ACD734DD8}\MenuStatusBar”)
        删除注册项 (#本地机器, “SOFTWARE\Microsoft\Internet Explorer\Extensions\{BF5DC4AE-258C-43d5-9D80-1F7ACD734DD8}”)
        返回 ()
    .如果真结束
    .如果真 (是否为空 (程序路径))
        程序路径 ＝ 取运行目录 () ＋ “\” ＋ 取执行文件名 ()
    .如果真结束
    写注册项 (#本地机器, “SOFTWARE\Microsoft\Internet Explorer\Extensions\{BF5DC4AE-258C-43d5-9D80-1F7ACD734DD8}\ButtonText”, 程序名称)
    写注册项 (#本地机器, “SOFTWARE\Microsoft\Internet Explorer\Extensions\{BF5DC4AE-258C-43d5-9D80-1F7ACD734DD8}\CLSID”, “{1FBA04EE-3024-11D2-8F1F-0000F87ABD16}”)
    写注册项 (#本地机器, “SOFTWARE\Microsoft\Internet Explorer\Extensions\{BF5DC4AE-258C-43d5-9D80-1F7ACD734DD8}\Default visible”, “Yes”)
    写注册项 (#本地机器, “SOFTWARE\Microsoft\Internet Explorer\Extensions\{BF5DC4AE-258C-43d5-9D80-1F7ACD734DD8}\Exec”, 程序路径) ' 程序位置(路径)
    写注册项 (#本地机器, “SOFTWARE\Microsoft\Internet Explorer\Extensions\{BF5DC4AE-258C-43d5-9D80-1F7ACD734DD8}\HotIcon”, 显示图标) ' 点燃图标
    写注册项 (#本地机器, “SOFTWARE\Microsoft\Internet Explorer\Extensions\{BF5DC4AE-258C-43d5-9D80-1F7ACD734DD8}\Icon”, 显示图标) ' 程序图标
    写注册项 (#本地机器, “SOFTWARE\Microsoft\Internet Explorer\Extensions\{BF5DC4AE-258C-43d5-9D80-1F7ACD734DD8}\MenuText”, 程序名称)
    写注册项 (#本地机器, “SOFTWARE\Microsoft\Internet Explorer\Extensions\{BF5DC4AE-258C-43d5-9D80-1F7ACD734DD8}\MenuStatusBar”, 程序名称)
    
    
    
    
    

.子程序 内部_Call, 整数型, , 内部调用
    .参数 子程序指针, 整数型
    .参数 参数1, 整数型
    .参数 参数2, 整数型
    .参数 参数3, 整数型
    .参数 参数4, 整数型
    .参数 参数5, 整数型

    置入代码 ({ 201, 88, 135, 4, 36, 255, 224 })
    返回 (0)

.子程序 程序_Call, 整数型, 公开, 少在计次循环里使用
    .参数 子程序指针, 整数型
    .参数 参数1, 整数型, 可空
    .参数 参数2, 整数型, 可空
    .参数 参数3, 整数型, 可空
    .参数 参数4, 整数型, 可空
    .参数 参数5, 整数型, 可空

    返回 (内部_Call (子程序指针, 参数1, 参数2, 参数3, 参数4, 参数5))

.子程序 程序_执行文本子程序, 文本型, 公开, 执行子程序参数为文本的；并返回文本；
    .参数 欲执行的子程序, 子程序指针
    .参数 参数一, 文本型, 可空
    .参数 参数二, 文本型, 可空
    .参数 参数三, 整数型, 可空
    .局部变量 bin, 字节集
    .局部变量 lpText, 整数型

    bin ＝ { 85, 139, 236, 255, 117, 20, 255, 117, 16, 255, 117, 12, 255, 85, 8, 201, 194, 16, 0 }
    lpText ＝ CallWindowProcA (取指针_字节集型 (bin), 到整数 (欲执行的子程序), 取指针_文本型 (参数一), 取指针_文本型 (参数二), 参数三)
    返回 (指针到文本 (lpText))
    

.子程序 程序_执行整数子程序, 整数型, 公开, 执行子程序参数为整数的；并返回整数；
    .参数 子程序, 子程序指针
    .参数 参数一, 整数型, 可空
    .参数 参数二, 整数型, 可空
    .参数 参数三, 整数型, 可空
    .局部变量 bin, 字节集

    bin ＝ { 85, 139, 236, 255, 117, 20, 255, 117, 16, 255, 117, 12, 255, 85, 8, 201, 194, 16, 0 }
    返回 (CallWindowProcA (取指针_字节集型 (bin), 到整数 (子程序), 参数一, 参数二, 参数三))

.子程序 程序_执行整数子程序1, 整数型, 公开, 执行子程序参数为整数的；并返回整数；
    .参数 子程序, 整数型
    .参数 参数一, 整数型, 可空
    .参数 参数二, 整数型, 可空
    .参数 参数三, 整数型, 可空
    .局部变量 bin, 字节集

    bin ＝ { 85, 139, 236, 255, 117, 20, 255, 117, 16, 255, 117, 12, 255, 85, 8, 201, 194, 16, 0 }
    返回 (CallWindowProcA (取指针_字节集型 (bin), 子程序, 参数一, 参数二, 参数三))
    

.子程序 程序_取命令行, 整数型, 公开, 本命令可以取出在启动易程序时附加在其可执行文件名后面的所有以空格分隔的命令行文本段
    .参数 命令行数组, 文本型, 数组, 存放被取回命令行文本的数组变量,本变量数组内被顺序填入在启动易程序时附加在其可执行文件名后面的以空格分隔的命令行文本段
    .局部变量 szArglist
    .局部变量 nArgs
    .局部变量 Command, , , "0"
    .局部变量 Length
    .局部变量 i, 整数型

    清除数组 (命令行数组)
    szArglist ＝ CommandLineToArgvW (GetCommandLineW (), nArgs)
    .如果真 (nArgs ＝ 1)
        返回 (0)
    .如果真结束
    重定义数组 (Command, 假, nArgs)
    Length ＝ lstrlen (szArglist) × 2
    RtlMoveMemory (取数据_通用型_数组 (Command), szArglist, Length)
    .变量循环首 (2, nArgs, 1, i)
        加入成员 (命令行数组, 编码_Unicode到Ansi (指针到字节集 (Command [i], lstrlen (Command [i]) × 2)))
    .变量循环尾 ()
    LocalFree (szArglist)
    返回 (取数组成员数 (命令行数组))

.子程序 程序_隐藏托盘图标, , 公开, 隐藏托盘上指定按钮,和 程序_显示托盘图标 配合使用
    .参数 任务栏按钮标题, 文本型
    .局部变量 局_按钮序号, 整数型
    .局部变量 局_任务栏句柄, 整数型

    局_任务栏句柄 ＝ 功能_取托盘区句柄 ()
    局_按钮序号 ＝ 托盘_取按钮位置 (任务栏按钮标题, 局_任务栏句柄)
    SendMessageA (局_任务栏句柄, 1028, 局_按钮序号, 1)

.子程序 程序_显示托盘图标, , 公开, 显示托盘上指定按钮,和 程序_隐藏托盘图标 配合使用
    .参数 任务栏按钮标题, 文本型
    .局部变量 局_按钮序号, 整数型
    .局部变量 局_任务栏句柄, 整数型

    局_任务栏句柄 ＝ 功能_取托盘区句柄 ()
    局_按钮序号 ＝ 托盘_取按钮位置 (任务栏按钮标题, 局_任务栏句柄)
    SendMessageA (局_任务栏句柄, 1028, 局_按钮序号, 0)

.子程序 程序_隐藏任务栏图标, , 公开, 隐藏任务栏上指定按钮,和 程序_显示任务栏图标 配合使用（本命令不兼容Win7或以上系统）
    .参数 任务栏按钮标题, 文本型
    .局部变量 局_按钮序号, 整数型
    .局部变量 局_任务栏句柄, 整数型

    局_任务栏句柄 ＝ 功能_取任务栏句柄 ()
    局_按钮序号 ＝ 托盘_取按钮位置 (任务栏按钮标题, 局_任务栏句柄)
    SendMessageA (局_任务栏句柄, 1028, 局_按钮序号, 1)

.子程序 程序_显示任务栏图标, , 公开, 显示任务栏上指定按钮,和 程序_隐藏任务栏图标 配合使用（本命令不兼容Win7或以上系统）
    .参数 任务栏按钮标题, 文本型
    .局部变量 局_按钮序号, 整数型
    .局部变量 局_任务栏句柄, 整数型

    局_任务栏句柄 ＝ 功能_取任务栏句柄 ()
    局_按钮序号 ＝ 托盘_取按钮位置 (任务栏按钮标题, 局_任务栏句柄)
    SendMessageA (局_任务栏句柄, 1028, 局_按钮序号, 0)

.子程序 程序_取安装目录, 文本型, 公开, 成功返回目录，以“\”结尾。失败返回空文本。
    .参数 程序名称, 文本型, , 如：e.exe
    .局部变量 局_路径, 文本型

    局_路径 ＝ 取文本注册项 (#本地机器, “SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\App Paths\” ＋ 程序名称 ＋ “\Path”, )
    .如果 (局_路径 ≠ “”)
        .如果真 (取文本右边 (局_路径, 1) ≠ “\”)
            局_路径 ＝ 局_路径 ＋ “\”
        .如果真结束
        
    .否则
        局_路径 ＝ 取文本注册项 (#根类, “Applications\” ＋ 程序名称 ＋ “\shell\open\command\”, )
        .如果真 (局_路径 ≠ “”)
            .如果 (局_路径 ≈ #引号)
                局_路径 ＝ 文本_取出中间文本 (局_路径, #引号, #引号, , )
                局_路径 ＝ 文件_取目录 (局_路径)
            .否则
                ' 部分系统记录安装路径不规范导致
                局_路径 ＝ 文本_取左边 (局_路径, 取空白文本 (1), -1, )
            .如果结束
            
        .如果真结束
        
    .如果结束
    返回 (局_路径)

.子程序 功能_取托盘区句柄, 整数型, , 取出当前桌面托盘区域的句柄
    .局部变量 局_系统句柄, 整数型, , , SysPager
    .局部变量 局_句柄, 整数型
    .局部变量 局_托盘句柄, 整数型

    局_句柄 ＝ FindWindowA (“Shell_TrayWnd”, 字符 (0))
    局_句柄 ＝ 窗口_取句柄 (局_句柄, 0, “TrayNotifyWnd”)
    局_系统句柄 ＝ 窗口_取句柄 (局_句柄, 0, “SysPager”)
    .如果真 (局_系统句柄 ≠ 0) ' 2003,XP,2000； Windows ME没有 "SysPager" 容器,“TrayNotifyWnd”容器中直接就是“ToolbarWindow32”
        局_句柄 ＝ 局_系统句柄
    .如果真结束
    局_托盘句柄 ＝ 窗口_取句柄 (局_句柄, 0, “ToolbarWindow32”)
    .如果真 (局_托盘句柄 ＝ 0) ' Windows 98没有“ToolbarWindow32”
        局_托盘句柄 ＝ 局_句柄
    .如果真结束
    返回 (局_托盘句柄)

.子程序 功能_取任务栏句柄, 整数型, , 本子程序采用【精易编程助手】生成,成功返回窗口句柄,失败返回0
    .局部变量 局_1级句柄, 整数型
    .局部变量 局_2级句柄, 整数型
    .局部变量 局_3级句柄, 整数型
    .局部变量 局_4级句柄, 整数型

    局_1级句柄 ＝ 窗口_取句柄 (, , “Shell_TrayWnd”, “”)
    .如果真 (局_1级句柄 ＝ -1)
        返回 (0)
    .如果真结束
    局_2级句柄 ＝ 窗口_取句柄 (局_1级句柄, , “ReBarWindow32”, “”)
    .如果真 (局_2级句柄 ＝ -1)
        返回 (0)
    .如果真结束
    局_3级句柄 ＝ 窗口_取句柄 (局_2级句柄, , “MSTaskSwWClass”, “运行应用程序”)
    .如果真 (局_3级句柄 ＝ -1)
        返回 (0)
    .如果真结束
    局_4级句柄 ＝ 窗口_取句柄 (局_3级句柄, , “ToolbarWindow32”, “运行应用程序”)
    .如果真 (局_4级句柄 ＝ -1)
        返回 (0)
    .如果真结束
    返回 (局_4级句柄)

.子程序 托盘_取按钮位置, 整数型, , 取任务栏或托盘的按钮位置
    .参数 按钮标题, 文本型
    .参数 托盘或任务栏句柄, 整数型, 可空
    .局部变量 局_进程ID, 整数型
    .局部变量 局_进程句柄, 整数型
    .局部变量 局_hTargetHandle, 整数型
    .局部变量 局_pStart, 整数型
    .局部变量 局_Result, 整数型
    .局部变量 局_pBufStart, 整数型
    .局部变量 局_dwWrite, 整数型, , , 0
    .局部变量 局_dwRead, 整数型, , , 0
    .局部变量 局_txtLen, 整数型
    .局部变量 局_计次, 整数型
    .局部变量 局_TextBufSize, 整数型
    .局部变量 局_dwAllocSize, 整数型
    .局部变量 局_TempBuf, 字节型, , "254"
    .局部变量 局_图标数, 整数型
    .局部变量 局_当前进程句柄, 整数型
    .局部变量 TBi, 按钮信息

    局_TextBufSize ＝ 255
    局_dwAllocSize ＝ 32
    GetWindowThreadProcessId (托盘或任务栏句柄, 局_进程ID) ' 获取进程句柄
    局_进程句柄 ＝ OpenProcess (#PROCESS_ALL_ACCESS, 0, 局_进程ID) ' 打开进程
    .如果真 (局_进程句柄 ＝ 0) ' 打开进程失败
        返回 (-1) ' 0)
    .如果真结束
    局_当前进程句柄 ＝ GetCurrentProcess () ' 取自身程序的进程句柄
    局_Result ＝ DuplicateHandle (局_当前进程句柄, 局_进程句柄, 局_当前进程句柄, 局_hTargetHandle, #PROCESS_ALL_ACCESS, 0, 0) ' 复制对象句柄
    .如果真 (局_Result ＝ 0) ' 复制句柄失败
        CloseHandle (局_进程句柄)
        返回 (-1) ' 0)
    .如果真结束
    局_pStart ＝ VirtualAllocEx (局_hTargetHandle, 0, 局_dwAllocSize, 4096, 4) ' 分配外部指针
    局_pBufStart ＝ VirtualAllocEx (局_hTargetHandle, 0, 局_TextBufSize, 4096, 4) ' 工具提示信息 存放空间
    .如果真 (局_pStart ＝ 0 或 局_pBufStart ＝ 0) ' 分配内存失败
        CloseHandle (局_hTargetHandle) ' 关闭一个内核对象
        返回 (-1) ' 0)
    .如果真结束
    局_图标数 ＝ SendMessageA (托盘或任务栏句柄, 1048, 0, 0)
    .变量循环首 (1, 局_图标数, 1, 局_计次)
        TBi.cbSize ＝ 局_dwAllocSize
        TBi.dwMask ＝ 位或 (2147483648, 32, 4, 8, 1, 16, 64) ' 'Or TBIF_TEXT
        WriteProcessMemory_整数3 (局_hTargetHandle, 局_pStart, SetHandleCount_字节型 (TBi.cbSize), 局_dwAllocSize, 局_dwWrite) ' 写整数内存
        SendMessageA (托盘或任务栏句柄, 1089, 局_计次 － 1, 局_pStart)
        ReadProcessMemory_整数型 (局_hTargetHandle, 局_pStart, SetHandleCount_字节型 (TBi.cbSize), 局_dwAllocSize, 局_dwRead) ' 读整数内存
        重定义数组 (局_TempBuf, 假, 局_TextBufSize)
        WriteProcessMemory_整数3 (局_hTargetHandle, 局_pBufStart, SetHandleCount_字节型 (局_TempBuf [1]), 局_TextBufSize, 局_dwWrite) ' 写整数内存
        局_txtLen ＝ SendMessageA (托盘或任务栏句柄, 1069, TBi.idCommand, 局_pBufStart)
        ReadProcessMemory_整数型 (局_hTargetHandle, 局_pBufStart, SetHandleCount_字节型 (局_TempBuf [1]), 局_TextBufSize, 局_dwRead) ' 读整数内存
        .如果真 (局_txtLen ＞ 0)
            重定义数组 (局_TempBuf, 真, 局_txtLen)
            .如果真 (寻找文本 (到文本 (局_TempBuf), 按钮标题, , 假) ≠ -1)
                跳出循环 ()
            .如果真结束
            
        .如果真结束
        
    .变量循环尾 ()
    VirtualFreeEx (局_hTargetHandle, 局_pStart, 局_dwAllocSize, 16384)
    VirtualFreeEx (局_hTargetHandle, 局_pBufStart, 局_TextBufSize, 16384)
    返回 (TBi.idCommand)

.子程序 程序_任务栏窗口图标状态, 逻辑型, 公开, 设置或获取指定窗口的任务栏图标状态
    .参数 窗口句柄, 整数型
    .参数 参数, 整数型, , 1、隐藏图标；2、显示图标；3、取得当前显示状态
    .局部变量 局_父窗口句柄, 整数型
    .局部变量 局_是否可见, 逻辑型
    .局部变量 局_是否最小化, 逻辑型

    ' https://bbs.125.la/thread-14498152-1-1.html
    
    .如果真 (IsWindow (窗口句柄) ＝ 0)
        返回 (假)
    .如果真结束
    
    .如果真 (参数 ＝ 3)
        局_父窗口句柄 ＝ GetWindowLongA (窗口句柄, #GWL_HWNDPARENT)
        .如果真 (局_父窗口句柄 ＝ 0)
            .如果真 (GetWindowLongA (局_父窗口句柄, #GWL_EXSTYLE) ≠ 384 或 GetWindowLongA (局_父窗口句柄, #GWL_STYLE) ≠ 79691776)
                返回 (真)
            .如果真结束
            
        .如果真结束
        返回 (假)
    .如果真结束
    
    .如果真 (参数 ＝ 2)
        .如果真 (程序_任务栏窗口图标状态 (窗口句柄, 3))
            返回 (真)
        .如果真结束
        局_是否最小化 ＝ IsIconic (窗口句柄)
        局_是否可见 ＝ IsWindowVisible (窗口句柄)
        局_父窗口句柄 ＝ GetWindowLongA (窗口句柄, #GWL_HWNDPARENT)
        SetWindowLongA (窗口句柄, #GWL_HWNDPARENT, 0)
        PostThreadMessageA (GetWindowThreadProcessId (局_父窗口句柄, 0), #WM_QUIT, 0, 0)
        SendMessageA (局_父窗口句柄, #WM_CLOSE, 0, 0)
        SendMessageA (窗口句柄, #WM_SETREDRAW, 0, 0)
        ShowWindow (窗口句柄, #SW_SHOWMINNOACTIVE)
        .如果真 (局_是否最小化 ＝ 假)
            ShowWindow (窗口句柄, #SW_SHOWNOACTIVATE)
        .如果真结束
        SendMessageA (窗口句柄, #WM_SETREDRAW, 1, 0)
        .如果真 (局_是否可见 ＝ 假)
            ShowWindow (窗口句柄, #SW_HIDE)
        .如果真结束
        返回 (真)
    .如果真结束
    
    .如果真 (程序_任务栏窗口图标状态 (窗口句柄, 3) ＝ 假)
        返回 (真)
    .如果真结束
    
    SetWindowLongA (窗口句柄, #GWL_HWNDPARENT, GetDesktopWindow ())
    返回 (真)

.子程序 程序_是否在虚拟机中运行, 逻辑型, 公开, 通过BIOS信息检测程序是否在虚拟机中运行（不支持XP）
    .局部变量 iSignature, 整数型
    .局部变量 dwSize, 整数型
    .局部变量 dwWriteSize, 整数型
    .局部变量 pBuffer, 字节集
    .局部变量 i, 整数型

    iSignature ＝ 取代码 (“R”, )
    iSignature ＝ 位或 (左移 (iSignature, 8), 取代码 (“S”, ))
    iSignature ＝ 位或 (左移 (iSignature, 8), 取代码 (“M”, ))
    iSignature ＝ 位或 (左移 (iSignature, 8), 取代码 (“B”, ))
    dwSize ＝ GetSystemFirmwareTable (iSignature, 0, 0, 0)
    pBuffer ＝ 取空白字节集 (dwSize)
    dwWriteSize ＝ GetSystemFirmwareTable (iSignature, 0, 取指针_字节集型 (pBuffer), dwSize)
    .如果真 (dwWriteSize ≤ dwSize)
        .变量循环首 (9, dwSize － 8, 1, i)
            .如果真 (pBuffer [i] ＝ 取代码 (“V”, ))
                .如果真 (取字节集数据 (pBuffer, #文本型, i) ≈ “VMware”)
                    返回 (真)
                .如果真结束
                
            .如果真结束
            
        .变量循环尾 ()
    .如果真结束
    返回 (假)

.子程序 程序_伪装资源管理器, 逻辑型, 公开, 修改指定PEB中的路径实现进程伪装
    .参数 进程ID, 整数型, 可空
    .参数 伪装程序的路径, 文本型, 可空, 资源管理器

    返回 (程序_伪装资源管理器W (进程ID, 编码_Ansi到Unicode (伪装程序的路径, )))

.子程序 程序_伪装资源管理器W, 逻辑型, 公开, 修改指定PEB中的路径实现进程伪装
    .参数 进程ID, 整数型, 可空
    .参数 伪装程序的路径, 字节集, 可空, 资源管理器
    .局部变量 hProcess, 整数型
    .局部变量 pszPath, 整数型
    .局部变量 nSize, 整数型
    .局部变量 szExplor, 字节集
    .局部变量 pbi, 整数型
    .局部变量 peb, 整数型
    .局部变量 Param, 整数型
    .局部变量 uLength, 短整数型
    .局部变量 uMaximumLength, 短整数型
    .局部变量 lRes, 整数型

    .如果真 (进程ID ≤ 0)
        进程ID ＝ GetCurrentProcessId ()
    .如果真结束
    hProcess ＝ OpenProcess (#PROCESS_ALL_ACCESS, 0, 进程ID)
    .如果真 (hProcess ≠ #NULL)
        pszPath ＝ LocalAlloc (#LMEM_ZEROINIT, #MAX_PATH × 2)
        .如果 (伪装程序的路径 ＝ { })
            nSize ＝ GetWindowsDirectoryW (pszPath, #MAX_PATH)
            szExplor ＝ 编码_Ansi到Unicode (“\explorer.exe”, )
            memcpy (pszPath ＋ nSize × 2, 取指针_字节集型 (szExplor), 取字节集长度 (szExplor))
        .否则
            memcpy (pszPath, 取指针_字节集型 (伪装程序的路径), 取字节集长度 (伪装程序的路径))
        .如果结束
        pbi ＝ LocalAlloc (#LMEM_ZEROINIT, 24) ' sizeof(PROCESS_BASIC_INFORMATION)
        .如果真 (NtQueryInformationProcess (hProcess, #ProcessBasicInformation, pbi, 24, #NULL) ＝ #ERROR_SUCCESS)
            peb ＝ LocalAlloc (#LMEM_ZEROINIT, 472) ' sizeof(PEB)
            ReadProcessMemory_整数型1 (hProcess, __get (pbi, 4), peb, 472, #NULL) ' PROCESS_BASIC_INFORMATION => PebBaseAddress
            Param ＝ LocalAlloc (#LMEM_ZEROINIT, 72) ' sizeof(RTL_USER_PROCESS_PARAMETERS)
            ReadProcessMemory_整数型1 (hProcess, __get (peb, 16), Param, 72, #NULL) ' PEB => ProcessParameters
            uLength ＝ 指针_到短整数型_汇编 (Param ＋ 56)
            uMaximumLength ＝ 指针_到短整数型_汇编 (Param ＋ 58)
            nSize ＝ lstrlenW (pszPath)
            .如果真 (到整数 (uMaximumLength ÷ 2) ＞ nSize)
                __set_short (Param, 56, nSize × 2) ' RTL_USER_PROCESS_PARAMETERS => ImagePathName.Length
                WriteProcessMemory_整数型 (hProcess, __get (peb, 16), Param, 72, #NULL) ' PEB => ProcessParameters
                lRes ＝ WriteProcessMemory_整数型 (hProcess, __get (Param, 60), pszPath, uMaximumLength, #NULL) ' RTL_USER_PROCESS_PARAMETERS => ImagePathName.Buffer
            .如果真结束
            LocalFree (Param)
            LocalFree (peb)
        .如果真结束
        LocalFree (pbi)
        LocalFree (pszPath)
        CloseHandle (hProcess)
    .如果真结束
    返回 (lRes ≠ 0)

.子程序 程序_自定义列表项目W, 逻辑型, 公开, 指定要包含在自定义跳转列表的任务类别中的项目
    .参数 任务列表项目, 精易_任务列表项目, 数组
    .局部变量 pICustomDestinationList, 整数型
    .局部变量 uMinSlots, 整数型
    .局部变量 pIObjectArray, 整数型
    .局部变量 pIObjectCollection, 整数型
    .局部变量 pIShellLinkW, 整数型
    .局部变量 pIPropertyStore, 整数型
    .局部变量 szPath, 字节集
    .局部变量 szTitle, 字节集
    .局部变量 pVal, 整数型
    .局部变量 BitKey, 字节集
    .局部变量 len, 整数型
    .局部变量 hr, 整数型
    .局部变量 i, 整数型

    len ＝ 取数组成员数 (任务列表项目)
    .如果真 (len ＝ 0)
        返回 (假)
    .如果真结束
    
    CoInitialize (#NULL)
    hr ＝ CoCreateInstance1 (取指针_字节集型 (#CLSID_DestinationList), #NULL, #CLSCTX_INPROC_SERVER, 取指针_字节集型 (#IID_ICustomDestinationList), pICustomDestinationList)
    .如果真 (hr ＝ #S_OK 且 pICustomDestinationList ≠ #NULL)
        hr ＝ CallObject (pICustomDestinationList, #ICustomDestinationList_BeginList, 取指针整数_ (uMinSlots), 取指针_字节集型 (#IID_IObjectArray), 取指针整数_ (pIObjectArray), , , , , , )
        .如果真 (hr ＝ #S_OK 且 pIObjectArray ≠ #NULL)
            hr ＝ CoCreateInstance1 (取指针_字节集型 (#CLSID_EnumerableObjectCollection), #NULL, #CLSCTX_INPROC_SERVER, 取指针_字节集型 (#IID_IObjectCollection), pIObjectCollection)
            .如果真 (hr ＝ #S_OK 且 pIObjectCollection ≠ #NULL)
                pVal ＝ LocalAlloc (#LMEM_ZEROINIT, 16)
                __set_short (pVal, 0, 8) ' VT_BSTR
                BitKey ＝ #FMTID_SummaryInformation ＋ 到字节集 (2) ' PKEY_Title
                .计次循环首 (len, i)
                    hr ＝ CoCreateInstance1 (取指针_字节集型 (#CLSID_ShellLink), #NULL, #CLSCTX_INPROC_SERVER, 取指针_字节集型 (#IID_IShellLinkW), pIShellLinkW)
                    .如果真 (hr ＝ #S_OK 且 pIShellLinkW ≠ #NULL)
                        hr ＝ CallObject (pIShellLinkW, #IShellLinkW_SetPath, 取指针_字节集型 (任务列表项目 [i].目标), , , , , , , , )
                        .如果 (任务列表项目 [i].起始位置 ＝ { }) ' 可空
                            szPath ＝ 字节集_寻找取左 (任务列表项目 [i].目标, { 92, 0 }, -1) ＋ { 0, 0 }
                            hr ＝ CallObject (pIShellLinkW, #IShellLinkW_SetWorkingDirectory, 取指针_字节集型 (szPath), , , , , , , , )
                        .否则
                            hr ＝ CallObject (pIShellLinkW, #IShellLinkW_SetWorkingDirectory, 取指针_字节集型 (任务列表项目 [i].起始位置), , , , , , , , )
                        .如果结束
                        .如果 (任务列表项目 [i].图标路径 ＝ { }) ' 可空
                            hr ＝ CallObject (pIShellLinkW, #IShellLinkW_SetIconLocation, 取指针_字节集型 (任务列表项目 [i].目标), 0, , , , , , , )
                        .否则
                            hr ＝ CallObject (pIShellLinkW, #IShellLinkW_SetIconLocation, 取指针_字节集型 (任务列表项目 [i].图标路径), 0, , , , , , , )
                        .如果结束
                        .如果真 (任务列表项目 [i].描述 ≠ { })
                            hr ＝ CallObject (pIShellLinkW, #IShellLinkW_SetDescription, 取指针_字节集型 (任务列表项目 [i].描述), , , , , , , , )
                        .如果真结束
                        hr ＝ CallObject (pIShellLinkW, #IUnknown_QueryInterface, 取指针_字节集型 (#IID_IPropertyStore), 取指针整数_ (pIPropertyStore), , , , , , , )
                        .如果真 (hr ＝ #S_OK 且 pIPropertyStore ≠ #NULL)
                            .如果 (任务列表项目 [i].标题 ＝ { })
                                szTitle ＝ 文件_取文件版本信息W (任务列表项目 [i].目标, 2)
                                __set (pVal, 8, 取指针_字节集型 (szTitle))
                            .否则
                                __set (pVal, 8, 取指针_字节集型 (任务列表项目 [i].标题))
                            .如果结束
                            hr ＝ CallObject (pIPropertyStore, #IPropertyStore_SetValue, 取指针_字节集型 (BitKey), pVal, , , , , , , )
                            .如果真 (hr ＝ #S_OK)
                                hr ＝ CallObject (pIPropertyStore, #IPropertyStore_Commit, , , , , , , , , )
                            .如果真结束
                            SafeRelease (pIPropertyStore)
                            hr ＝ CallObject (pIObjectCollection, #IObjectCollection_AddObject, pIShellLinkW, , , , , , , , )
                        .如果真结束
                        SafeRelease (pIShellLinkW)
                    .如果真结束
                    
                .计次循环尾 ()
                LocalFree (pVal)
                hr ＝ CallObject (pICustomDestinationList, #ICustomDestinationList_AddUserTasks, pIObjectCollection, , , , , , , , )
                hr ＝ CallObject (pICustomDestinationList, #ICustomDestinationList_CommitList, , , , , , , , , )
                SafeRelease (pIObjectCollection)
            .如果真结束
            SafeRelease (pIObjectArray)
        .如果真结束
        SafeRelease (pICustomDestinationList)
    .如果真结束
    CoUninitialize ()
    返回 (真)

.子程序 程序_禁用固定设置, 逻辑型, 公开, 禁用将快捷方式或窗口固定到任务栏或开始菜单的功能
    .参数 窗口句柄, 整数型
    .局部变量 pIPropertyStore, 整数型
    .局部变量 BitKey, 字节集
    .局部变量 pv, 整数型
    .局部变量 hr, 整数型

    CoInitialize (#NULL)
    hr ＝ SHGetPropertyStoreForWindow (窗口句柄, 取指针_字节集型 (#IID_IPropertyStore), pIPropertyStore)
    .如果真 (hr ＝ #S_OK 且 pIPropertyStore ≠ #NULL)
        pv ＝ LocalAlloc (#LMEM_ZEROINIT, 16)
        __set_short (pv, 0, 11) ' VT_BOOL
        __set (pv, 8, #VARIANT_TRUE)
        BitKey ＝ #System_AppUserModel ＋ 到字节集 (9) ' PKEY_AppUserModel_PreventPinning
        hr ＝ CallObject (pIPropertyStore, #IPropertyStore_SetValue, 取指针_字节集型 (BitKey), pv, , , , , , , )
        LocalFree (pv)
        SafeRelease (pIPropertyStore)
    .如果真结束
    CoUninitialize ()
    返回 (hr ＝ #S_OK)

.子程序 程序_禁止运行, , 公开, 把指定的程序添加到不允许运行的应用程序列表中。
    .参数 参_文件名, 文本型
    .局部变量 局_值列表, 字节集, , "0"
    .局部变量 局_注册表, 注册表操作
    .局部变量 局_次数, 整数型

    .如果 (局_注册表.取DWORD值 (“HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer”, “DisallowRun”) ＝ 1)
        局_注册表.枚举键名 (“HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\DisallowRun\”, , 局_值列表, )
        .计次循环首 (取数组成员数 (局_值列表), 局_次数)
            .如果真 (到文本 (局_值列表 [局_次数]) ＝ 参_文件名)
                返回 ()
            .如果真结束
            
        .计次循环尾 ()
    .否则
        局_注册表.写注册项Ex (#现行用户, “SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\Explorer\”, “DisallowRun”, 到字节集 (1), #REG_DWORD_LITTLE_ENDIAN)
    .如果结束
    加入成员 (局_值列表, 到字节集 (参_文件名))
    .计次循环首 (取数组成员数 (局_值列表), 局_次数)
        局_注册表.写注册项Ex (#现行用户, “SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\Explorer\DisallowRun\”, 到文本 (局_次数), 到字节集 (局_值列表 [局_次数]), #REG_SZ)
    .计次循环尾 ()

.子程序 程序_允许运行, , 公开, 把指定的程序从不允许运行的应用程序列表中删除。
    .参数 参_文件名, 文本型
    .局部变量 局_注册表, 注册表操作
    .局部变量 局_值列表, 字节集, , "0"
    .局部变量 局_次数, 整数型
    .局部变量 局_键列表, 文本型, , "0"
    .局部变量 局_是否删除, 逻辑型

    .如果真 (局_注册表.取DWORD值 (“HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer”, “DisallowRun”) ≠ 1)
        返回 ()
    .如果真结束
    局_注册表.枚举键名 (“HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\DisallowRun\”, 局_键列表, 局_值列表, )
    .计次循环首 (取数组成员数 (局_值列表), 局_次数)
        .如果真 (到文本 (局_值列表 [局_次数]) ＝ 参_文件名)
            局_注册表.删除键名 (“HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\DisallowRun\”, 局_键列表 [局_次数])
            局_是否删除 ＝ 真
            跳出循环 ()
        .如果真结束
        
    .计次循环尾 ()
    .如果真 (取数组成员数 (局_值列表) ＝ 1 且 局_是否删除 ＝ 真)
        局_注册表.删除键名 (“HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\”, “DisallowRun”)
        局_注册表.删除项 (“HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\DisallowRun”)
    .如果真结束
    

.版本 2

.程序集 类_Accessible, , 公开, 感谢会员【酷宝贝】提供Accessible接口
.程序集变量 m_parent, 对象
.程序集变量 m_self, 对象
.程序集变量 m_id, 整数型

.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
    

.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
    

.子程序 创建自窗口句柄, 逻辑型, 公开, 从指定窗口句柄处获取自绘对象
    .参数 参数_窗口句柄, 整数型, , 目标自绘窗口句柄
    .局部变量 hr, 整数型
    .局部变量 ppObj, 整数型

    m_self.清除 ()
    m_parent.清除 ()
    m_id ＝ 0
    ppObj ＝ _取对象指针的地址 (m_self)
    hr ＝ AccessibleObjectFromWindow (参数_窗口句柄, #OBJID_WINDOW, #IID_IAccessible, ppObj)
    返回 (hr ＝ 0)

.子程序 创建自屏幕坐标, 逻辑型, 公开, 从桌面坐标处获取自绘窗口对象
    .参数 参数_X, 整数型, , 桌面X坐标
    .参数 参数_Y, 整数型, , 桌面Y坐标
    .局部变量 hr, 整数型
    .局部变量 ppObj, 整数型
    .局部变量 item, 变体型

    m_self.清除 ()
    m_parent.清除 ()
    m_id ＝ 0
    ppObj ＝ _取对象指针的地址 (m_self)
    hr ＝ AccessibleObjectFromPoint (参数_X, 参数_Y, ppObj, item)
    .如果真 (hr ≠ 0)
        返回 (假)
    .如果真结束
    
    m_id ＝ item.取数值 ()
    .如果真 (m_id ≠ 0)
        m_parent ＝ m_self
        m_self.清除 ()
    .如果真结束
    返回 (真)

.子程序 创建自对象, , 公开, 内部使用，从指定对象获取自绘窗口对象
    .参数 参数_对象, 对象

    m_self.清除 ()
    m_parent.清除 ()
    m_id ＝ 0
    m_self ＝ 参数_对象

.子程序 创建自ID, , 公开, 内部使用，用从指定ID获取自绘窗口对象
    .参数 参数_ID, 整数型
    .参数 参数_父对象, 对象

    m_self.清除 ()
    m_parent.清除 ()
    m_id ＝ 参数_ID
    m_parent ＝ 参数_父对象

.子程序 到变体型, 变体型, 公开
    .局部变量 var, 变体型

    .如果 (m_id ＝ 0)
        var.赋值 (m_self, )
    .否则
        var.赋值 (m_id, )
    .如果结束
    返回 (var)

.子程序 是否空, 逻辑型, 公开
    .如果 (m_id ≠ 0)
        返回 (m_parent.是否为空 ())
    .否则
        返回 (m_self.是否为空 ())
    .如果结束
    

.子程序 取ID, 整数型, 公开
    返回 (m_id)

.子程序 取父元素, 逻辑型, 公开, accParent
    .参数 参数_父元素, 类_Accessible, 参考

    .如果 (m_id ≠ 0)
        参数_父元素.创建自对象 (m_parent)
    .否则
        参数_父元素.创建自对象 (m_self.读对象型属性 (“accParent”, ))
    .如果结束
    返回 (取反 (参数_父元素.是否空 ()))
    

.子程序 取子元素总数, 整数型, 公开, accChildCount
    返回 (m_self.读数值属性 (“accChildCount”, ))
    

.子程序 取子元素, 逻辑型, 公开, accChild
    .参数 参数_索引, 整数型, , 索引从1开始
    .参数 参数_子元素, 类_Accessible, 参考
    .局部变量 obj, 对象
    .局部变量 var, 变体型, , "1"
    .局部变量 cObtained, 整数型
    .局部变量 hr, 整数型

    hr ＝ AccessibleChildren (_取对象指针 (m_self), 参数_索引 － 1, 1, var, cObtained)
    .如果真 (hr ＝ 0 且 cObtained ＝ 1)
        .如果 (var [1].取类型 () ＝ #变体类型.数值型)
            obj ＝ m_self.读对象型属性 (“accChild”, var [1])
        .否则
            obj ＝ var [1].取对象 ()
        .如果结束
        
        .如果 (obj.是否为空 ()) ' 如果为空说明子元素是一个简单元素
            参数_子元素.创建自ID (var [1].取数值 (), m_self)
        .否则
            参数_子元素.创建自对象 (obj)
        .如果结束
        
    .如果真结束
    返回 (取反 (参数_子元素.是否空 ()))

.子程序 枚举子元素, 整数型, 公开, 从指定节点对象枚举下级全部子元素
    .参数 参数_子元素组, 类_Accessible, 参考 数组
    .局部变量 obj, 对象
    .局部变量 var, 变体型, , "0"
    .局部变量 cObtained, 整数型
    .局部变量 hr, 整数型
    .局部变量 i, 整数型
    .局部变量 count, 整数型

    count ＝ 取子元素总数 ()
    .如果真 (count ＝ 0)
        返回 (0)
    .如果真结束
    重定义数组 (var, 假, count)
    hr ＝ AccessibleChildren (_取对象指针 (m_self), 0, count, var, cObtained)
    .如果真 (hr ≠ 0)
        返回 (0)
    .如果真结束
    重定义数组 (参数_子元素组, 假, count)
    .计次循环首 (count, i)
        .如果 (var [i].取类型 () ＝ #变体类型.数值型)
            obj ＝ m_self.读对象型属性 (“accChild”, var [i])
        .否则
            obj ＝ var [i].取对象 ()
        .如果结束
        
        .如果 (obj.是否为空 ()) ' 如果为空说明子元素是一个简单元素
            参数_子元素组 [i].创建自ID (var [i].取数值 (), m_self)
        .否则
            参数_子元素组 [i].创建自对象 (obj)
        .如果结束
        
    .计次循环尾 ()
    返回 (count)
    

.子程序 取名称, 文本型, 公开, accName
    .局部变量 var, 变体型

    .如果 (m_id ≠ 0)
        var.赋值 (m_id, )
        返回 (m_parent.读文本属性 (“accName”, var))
    .否则
        var.赋值 (0, )
        返回 (m_self.读文本属性 (“accName”, var))
    .如果结束
    

.子程序 置名称, 逻辑型, 公开, accName
    .参数 参数_名称, 文本型
    .局部变量 var, 变体型

    .如果 (m_id ≠ 0)
        var.赋值 (m_id, )
        返回 (m_parent.写属性 (“accName”, var, 参数_名称))
    .否则
        var.赋值 (0, )
        返回 (m_self.写属性 (“accName”, var, 参数_名称))
    .如果结束
    

.子程序 取值, 文本型, 公开, accValue
    .局部变量 var, 变体型

    .如果 (m_id ≠ 0)
        var.赋值 (m_id, )
        返回 (m_parent.读文本属性 (“accValue”, var))
    .否则
        var.赋值 (0, )
        返回 (m_self.读文本属性 (“accValue”, var))
    .如果结束
    

.子程序 赋值, 逻辑型, 公开, accValue
    .参数 参数_值, 文本型
    .局部变量 var, 变体型

    .如果 (m_id ≠ 0)
        var.赋值 (m_id, )
        返回 (m_parent.写属性 (“accValue”, var, 参数_值))
    .否则
        var.赋值 (0, )
        返回 (m_self.写属性 (“accValue”, var, 参数_值))
    .如果结束
    

.子程序 取描述, 文本型, 公开, accDescription
    .局部变量 var, 变体型

    .如果 (m_id ≠ 0)
        var.赋值 (m_id, )
        返回 (m_parent.读文本属性 (“accDescription”, var))
    .否则
        var.赋值 (0, )
        返回 (m_self.读文本属性 (“accDescription”, var))
    .如果结束
    

.子程序 取角色, 整数型, 公开, accRole 返回 #ROLE_SYSTEM_ 常量之一
    .局部变量 var, 变体型

    .如果 (m_id ≠ 0)
        var.赋值 (m_id, )
        返回 (m_parent.读数值属性 (“accRole”, var))
    .否则
        var.赋值 (0, )
        返回 (m_self.读数值属性 (“accRole”, var))
    .如果结束
    

.子程序 取角色文本, 文本型, 公开, accRole 
    .局部变量 var, 变体型
    .局部变量 role, 整数型
    .局部变量 lpstr, 文本型
    .局部变量 len, 整数型

    .如果 (m_id ≠ 0)
        var.赋值 (m_id, )
        role ＝ m_parent.读数值属性 (“accRole”, var)
    .否则
        var.赋值 (0, )
        role ＝ m_self.读数值属性 (“accRole”, var)
    .如果结束
    len ＝ GetRoleText_int (role, 0, 0) ＋ 1
    lpstr ＝ 取空白文本 (len)
    GetRoleText (role, lpstr, len)
    返回 (lpstr)

.子程序 取状态, 整数型, 公开, accState 返回 #STATE_SYSTEM_ 常量组合
    .局部变量 var, 变体型

    .如果 (m_id ≠ 0)
        var.赋值 (m_id, )
        返回 (m_parent.读数值属性 (“accState”, var))
    .否则
        var.赋值 (0, )
        返回 (m_self.读数值属性 (“accState”, var))
    .如果结束
    

.子程序 取状态文本, 文本型, 公开, GetStateText 
    .局部变量 var, 变体型
    .局部变量 state, 整数型
    .局部变量 i, 整数型
    .局部变量 str, 文本型
    .局部变量 lpstr, 文本型
    .局部变量 len, 整数型

    .如果 (m_id ≠ 0)
        var.赋值 (m_id, )
        state ＝ m_parent.读数值属性 (“accState”, var)
    .否则
        var.赋值 (0, )
        state ＝ m_self.读数值属性 (“accState”, var)
    .如果结束
    
    .如果真 (state ＝ #STATE_SYSTEM_NORMAL)
        len ＝ GetStateText_int (state, 0, 0) ＋ 1
        lpstr ＝ 取空白文本 (len)
        GetStateText (state, lpstr, len)
        返回 (lpstr)
    .如果真结束
    
    i ＝ #STATE_SYSTEM_UNAVAILABLE
    .循环判断首 ()
        .如果真 (位与 (state, i) ≠ 0)
            len ＝ GetStateText_int (i, 0, 0) ＋ 1
            lpstr ＝ 取空白文本 (len)
            GetStateText (i, lpstr, len)
            str ＝ str ＋ lpstr ＋ “,”
        .如果真结束
        i ＝ 左移 (i, 1)
    .循环判断尾 (i ≤ #STATE_SYSTEM_ALERT_HIGH)
    返回 (str)
    

.子程序 取帮助, 文本型, 公开, accHelp
    .局部变量 var, 变体型

    .如果 (m_id ≠ 0)
        var.赋值 (m_id, )
        返回 (m_parent.读文本属性 (“accHelp”, var))
    .否则
        var.赋值 (0, )
        返回 (m_self.读文本属性 (“accHelp”, var))
    .如果结束
    

.子程序 取帮助主题, 整数型, 公开, accHelpTopic
    .局部变量 var, 变体型
    .局部变量 HelpFile, 变体型

    .如果 (m_id ≠ 0)
        var.赋值 (m_id, )
        返回 (m_parent.读数值属性 (“accHelpTopic”, HelpFile, var))
    .否则
        var.赋值 (0, )
        返回 (m_self.读数值属性 (“accHelpTopic”, HelpFile, var))
    .如果结束
    

.子程序 取快捷键, 文本型, 公开, accKeyboardShortcut
    .局部变量 var, 变体型

    .如果 (m_id ≠ 0)
        var.赋值 (m_id, )
        返回 (m_parent.读文本属性 (“accKeyboardShortcut”, var))
    .否则
        var.赋值 (0, )
        返回 (m_self.读文本属性 (“accKeyboardShortcut”, var))
    .如果结束
    

.子程序 取默认动作, 文本型, 公开, accDefaultAction
    .局部变量 var, 变体型

    .如果 (m_id ≠ 0)
        var.赋值 (m_id, )
        返回 (m_parent.读文本属性 (“accDefaultAction”, var))
    .否则
        var.赋值 (0, )
        返回 (m_self.读文本属性 (“accDefaultAction”, var))
    .如果结束
    

.子程序 取焦点元素, 逻辑型, 公开, accFocus
    .参数 参数_焦点元素, 类_Accessible, 参考
    .局部变量 var, 变体型

    .如果 (m_id ＝ 0)
        var ＝ m_self.读属性 (“accFocus”, )
        .如果真 (var.取类型 () ＝ #变体类型.空)
            返回 (假)
        .如果真结束
        .如果 (var.取类型 () ＝ #变体类型.数值型)
            参数_焦点元素.创建自ID (var.取数值 (), m_self)
        .否则
            参数_焦点元素.创建自对象 (var.取对象 ())
        .如果结束
        
    .否则
        var ＝ m_parent.读属性 (“accFocus”, )
        .如果真 (var.取类型 () ＝ #变体类型.空)
            返回 (假)
        .如果真结束
        .如果 (var.取类型 () ＝ #变体类型.数值型)
            参数_焦点元素.创建自ID (var.取数值 (), m_parent)
        .否则
            参数_焦点元素.创建自对象 (var.取对象 ())
        .如果结束
        
    .如果结束
    
    返回 (取反 (参数_焦点元素.是否空 ()))
    

.子程序 取选择元素, 逻辑型, 公开, accSelection
    .参数 参数_选择元素, 类_Accessible, 参考
    .局部变量 var, 变体型

    .如果 (m_id ＝ 0)
        var ＝ m_self.读属性 (“accSelection”, )
        .如果真 (var.取类型 () ＝ #变体类型.空)
            返回 (假)
        .如果真结束
        .如果 (var.取类型 () ＝ #变体类型.数值型)
            参数_选择元素.创建自ID (var.取数值 (), m_self)
        .否则
            参数_选择元素.创建自对象 (var.取对象 ())
        .如果结束
        
    .否则
        var ＝ m_parent.读属性 (“accSelection”, )
        .如果真 (var.取类型 () ＝ #变体类型.空)
            返回 (假)
        .如果真结束
        .如果 (var.取类型 () ＝ #变体类型.数值型)
            参数_选择元素.创建自ID (var.取数值 (), m_parent)
        .否则
            参数_选择元素.创建自对象 (var.取对象 ())
        .如果结束
        
    .如果结束
    
    返回 (取反 (参数_选择元素.是否空 ()))
    

.子程序 选择元素, , 公开, accSelect
    .参数 参数_标志, 整数型, , #SELFLAG_ 常量组合
    .参数 参数_被选择元素, 类_Accessible, 可空, 如果为空则表示自身被选择
    .局部变量 var, 变体型

    .如果 (是否为空 (参数_被选择元素))
        var.赋值 (0, )
    .否则
        var ＝ 参数_被选择元素.到变体型 ()
    .如果结束
    
    .如果 (m_id ＝ 0)
        m_self.方法 (“accSelect”, 参数_标志, var)
    .否则
        m_parent.方法 (“accSelect”, 参数_标志, var)
    .如果结束
    

.子程序 取位置, , 公开, accLocation
    .参数 参数_左边, 整数型, 参考
    .参数 参数_顶边, 整数型, 参考
    .参数 参数_宽度, 整数型, 参考
    .参数 参数_高度, 整数型, 参考
    .局部变量 var, 变体型

    .如果 (m_id ≠ 0)
        var.赋值 (m_id, )
        m_parent.方法 (“accLocation”, 参数_左边, 参数_顶边, 参数_宽度, 参数_高度, var)
    .否则
        var.赋值 (0, )
        m_self.方法 (“accLocation”, 参数_左边, 参数_顶边, 参数_宽度, 参数_高度, var)
    .如果结束
    

.子程序 导航, 逻辑型, 公开, accNavigate
    .参数 参数_标志, 整数型, , #NAVDIR_ 常量之一
    .参数 参数_开始元素, 类_Accessible, 可空
    .参数 参数_返回元素, 类_Accessible, 参考
    .局部变量 varStart, 变体型
    .局部变量 varEnd, 变体型

    varStart ＝ 参数_开始元素.到变体型 ()
    .如果 (m_id ≠ 0)
        varEnd ＝ m_parent.通用方法 (“accNavigate”, 参数_标志, varStart)
        .如果 (varEnd.取类型 () ＝ #变体类型.数值型)
            参数_返回元素.创建自ID (varEnd.取数值 (), m_parent)
        .否则
            参数_返回元素.创建自对象 (varEnd.取对象 ())
        .如果结束
        
    .否则
        varEnd ＝ m_self.通用方法 (“accNavigate”, 参数_标志, varStart)
        .如果 (varEnd.取类型 () ＝ #变体类型.数值型)
            参数_返回元素.创建自ID (varEnd.取数值 (), m_self)
        .否则
            参数_返回元素.创建自对象 (varEnd.取对象 ())
        .如果结束
        
    .如果结束
    返回 (取反 (参数_返回元素.是否空 ()))
    

.子程序 命中测试, 逻辑型, 公开, accHitTest
    .参数 参数_左边, 整数型
    .参数 参数_顶边, 整数型
    .参数 参数_元素, 类_Accessible, 参考
    .局部变量 var, 变体型

    .如果 (m_id ≠ 0)
        var ＝ m_parent.通用方法 (“accHitTest”, 参数_左边, 参数_顶边)
    .否则
        var ＝ m_self.通用方法 (“accHitTest”, 参数_左边, 参数_顶边)
    .如果结束
    
    .如果真 (var.取类型 () ＝ #变体类型.空)
        返回 (假)
    .如果真结束
    
    .如果真 (var.取类型 () ＝ #变体类型.数值型)
        .如果 (var.取数值 () ＝ 0)
            参数_元素.创建自对象 (m_self)
        .否则
            参数_元素.创建自ID (var.取数值 (), m_self)
        .如果结束
        返回 (真)
    .如果真结束
    
    .如果真 (var.取类型 () ＝ #变体类型.对象型)
        参数_元素.创建自对象 (var.取对象 ())
        返回 (真)
    .如果真结束
    返回 (假)
    
    

.子程序 执行默认动作, , 公开, accDoDefaultAction
    .局部变量 var, 变体型

    .如果 (m_id ≠ 0)
        var.赋值 (m_id, )
        m_parent.方法 (“accDoDefaultAction”, var)
    .否则
        var.赋值 (0, )
        m_self.方法 (“accDoDefaultAction”, var)
    .如果结束
    

.子程序 取窗口句柄, 整数型, 公开
    .局部变量 pobj, 整数型
    .局部变量 hwnd, 整数型

    .如果 (m_id ≠ 0)
        pobj ＝ _取对象指针 (m_parent)
    .否则
        pobj ＝ _取对象指针 (m_self)
    .如果结束
    .如果真 (SEH_安装简单SEH ())
        WindowFromAccessibleObject (pobj, hwnd)
        SEH_删除简单SEH ()
    .如果真结束
    返回 (hwnd)

.子程序 获取对象, , 公开
    .参数 参_对象m_parent, 对象, 参考
    .参数 参_对象m_self, 对象, 参考

    参_对象m_parent ＝ m_parent
    参_对象m_self ＝ m_self
    

.版本 2

.程序集 集_窗口句柄
.程序集变量 当前窗口列表, 精易_窗口信息, , "0", 枚举出来的窗口句柄列表
.程序集变量 集_Hook, 整数型, , , 监视热键
.程序集变量 集_监视事件, 子程序指针, , , 监视热键
.程序集变量 集_控件调整, 整数型

.程序集变量 g_HotkeyMsg, 整数型
.程序集变量 m_oldMsgProc, 整数型
.程序集变量 m_HandleMsgProc, 整数型

.程序集变量 _workerw, 整数型

.子程序 窗口_重画, 逻辑型, 公开, InvalidateRect
    .参数 窗口句柄, 整数型
    .参数 清除背景, 逻辑型, 可空

    返回 (InvalidateRect (窗口句柄, 0, 选择 (清除背景, 1, 0)) ≠ 0)

.子程序 窗口_隐藏任务按钮, , 公开, 顶级窗口,会在任务条里显示一个按钮.通过本功能可以将其隐藏
    .参数 窗口句柄, 整数型

    SetWindowLongA (窗口句柄, -8, GetDesktopWindow ())

.子程序 窗口_是否响应, 逻辑型, 公开, 返回 真=窗口有效且能及时响应.假=窗口无效或已死掉失去了响应
    .参数 窗口句柄, 整数型

    返回 (SendMessageTimeoutA (窗口句柄, 0, 0, 0, #SMTO_ABORTIFHUNG, 128, 0) ≠ 0)

.子程序 窗口_取光标坐标, 逻辑型, 公开, 将插入标记的位置（按客户区坐标）信息拷贝到指定的POINT结构中
    .参数 参_坐标, 精易_坐标, 参考
    .局部变量 局_结果, 逻辑型

    局_结果 ＝ GetCaretPos (参_坐标) ≠ 0
    返回 (局_结果)

.子程序 窗口_发送拖放消息, 逻辑型, 公开, 向指定窗口发送拖拽消息_该函数为ANSIC文件名使用；不支持拖放对象
    .参数 参_句柄, 整数型, , 接受拖拽消息的句柄
    .参数 参_路径, 文本型, , 需要拖放的文件路径
    .局部变量 dwStyle, 整数型
    .局部变量 dwProcessId, 整数型
    .局部变量 hProcess, 整数型
    .局部变量 pMem, 整数型
    .局部变量 nMaxCount, 整数型

    dwStyle ＝ GetWindowLongA (参_句柄, #GWL_EXSTYLE)
    .如果真 (位与 (dwStyle, #WS_EX_ACCEPTFILES) ＝ 0)
        输出调试文本 (“窗口缺少接受拖放文件标识符！”)
        返回 (假)
    .如果真结束
    .如果真 (GetWindowThreadProcessId (参_句柄, dwProcessId) ＝ 0)
        返回 (假)
    .如果真结束
    hProcess ＝ OpenProcess (位或 (#PROCESS_VM_OPERATION, #PROCESS_VM_WRITE), 0, dwProcessId)
    .如果真 (hProcess ＝ #NULL)
        输出调试文本 (取错误信息文本_API (, ))
        返回 (假)
    .如果真结束
    nMaxCount ＝ 取文本长度 (删首尾空 (参_路径))
    .如果真 (nMaxCount ＝ 0)
        CloseHandle (hProcess)
        返回 (假)
    .如果真结束
    pMem ＝ VirtualAllocEx (hProcess, #NULL, 20 ＋ nMaxCount ＋ 1, #MEM_COMMIT, #PAGE_READWRITE)
    .如果真 (pMem ＝ #NULL)
        CloseHandle (hProcess)
        返回 (假)
    .如果真结束
    WriteProcessMemory_整数3 (hProcess, pMem, 20, 4, #NULL)
    WriteProcessMemory_文本型 (hProcess, pMem ＋ 20, 参_路径, nMaxCount, #NULL)
    SendMessageTimeoutA (参_句柄, #WM_DROPFILES, pMem, #NULL, #SMTO_ABORTIFHUNG, 3000, #NULL)
    VirtualFreeEx (hProcess, pMem, 0, #MEM_RELEASE)
    CloseHandle (hProcess)
    返回 (真)

.子程序 窗口_循环关闭, , 公开, 循环关闭一个窗口
    .参数 类名, 文本型, 可空, 窗口类名，可空
    .参数 标题, 文本型, 可空, 窗口标题，可空

    .判断循环首 (FindWindowA (类名, 标题) ≠ 0)
        PostMessageA (FindWindowA (类名, 标题), 16, 0, 0)
    .判断循环尾 ()

.子程序 窗口_嵌入桌面, 整数型, 公开, 返回前一个父窗口的句柄 (兼容Win10)
    .参数 窗口句柄, 整数型
    .局部变量 hwndWorker, 整数型
    .局部变量 hwndParent, 整数型

    hwndWorker ＝ GetWorkerW ()
    hwndParent ＝ SetParent (窗口句柄, hwndWorker)
    窗口_置位置和大小 (窗口句柄, , , , )
    返回 (hwndParent)

.子程序 GetWorkerW, 整数型
    .局部变量 windowHandle, 整数型
    .局部变量 result, 整数型

    windowHandle ＝ FindWindowA (“Progman”, 字符 (0))
    SendMessageTimeoutA (windowHandle, 1324, 0, 0, #SMTO_NORMAL, 1000, result)
    EnumWindows (&EnumWindowsProc, 0)
    ShowWindow (_workerw, #SW_HIDE)
    返回 (windowHandle)

.子程序 EnumWindowsProc, 逻辑型
    .参数 tophandle, 整数型
    .参数 topparamhandle, 整数型
    .局部变量 defview, 整数型

    defview ＝ FindWindowExA (tophandle, 0, 取指针_文本型 (“SHELLDLL_DefView”), 0)
    .如果真 (defview ≠ 0)
        _workerw ＝ FindWindowExA (0, tophandle, 取指针_文本型 (“WorkerW”), 0)
    .如果真结束
    返回 (真)

.子程序 窗口_是否全屏, 逻辑型, 公开
    .参数 窗口句柄, 整数型
    .局部变量 矩形, 精易_矩形
    .局部变量 窗口宽度, 整数型
    .局部变量 窗口高度, 整数型

    GetWindowRect (窗口句柄, 矩形)
    窗口宽度 ＝ 取屏幕宽度 () － 矩形.左边 ＋ 矩形.右边 － 取屏幕宽度 ()
    窗口高度 ＝ 取屏幕高度 () － 矩形.顶边 ＋ 矩形.底边 － 取屏幕高度 ()
    .如果真 (窗口宽度 ＞ 到整数 (取屏幕宽度 () － 50) 且 窗口高度 ＞ 到整数 (取屏幕高度 () － 50))
        返回 (真)
    .如果真结束
    返回 (假)

.子程序 窗口_取光标位置, 精易_矩形, 公开, 命令使用请查看例题。注意!.使用该命令时,需要保证被取光标位置的编辑框 [拥有输入焦点] 否则命令将会失败
    .参数 窗口句柄, 整数型, , 如果是自身，请直接输入-1
    .局部变量 p, PGUITHREADINFO
    .局部变量 局_矩形, 精易_矩形
    .局部变量 局_线程Id, 整数型

    .判断开始 (窗口句柄 ＝ -1)
        局_线程Id ＝ 线程_取自线程ID ()
    .默认
        局_线程Id ＝ 线程_取ID (窗口句柄)
    .判断结束
    p.cbSize ＝ 48
    GetGUIThreadInfo (局_线程Id, p)
    局_矩形 ＝ p.rcCaret
    返回 (局_矩形)
    

.子程序 窗口_控件调整_销毁, , 公开, 销毁指定句柄的窗口控件
    .参数 窗口句柄, 整数型

    SetWindowLongA (窗口句柄, -4, 集_控件调整)

.子程序 窗口控件调整过程, 整数型
    .参数 hwnd, 整数型
    .参数 msg, 整数型
    .参数 wparam, 整数型
    .参数 iparam, 整数型
    .局部变量 WndProc, 整数型

    WndProc ＝ CallWindowProcA (集_控件调整, hwnd, msg, wparam, iparam)
    .如果真 (msg ＝ 132)
        .如果真 (WndProc ＝ 1) ' 用户区域
            WndProc ＝ 2
        .如果真结束
        ' 如果真 (WndProc ＝ 2)  ' 标题区域
        
        ' WndProc ＝ 1  ' 用户区域
        ' WndProc ＝ 2  ' 标题区域
        ' WndProc ＝ 10  ' 边框_左
        ' WndProc ＝ 11  ' 边框_右
        ' WndProc ＝ 12  ' 边框_上
        ' WndProc ＝ 13  ' 边框_左上
        ' WndProc ＝ 14  ' 边框_右上
        ' WndProc ＝ 15  ' 边框_下
        ' WndProc ＝ 16  ' 边框_左下
        ' WndProc ＝ 17  ' 边框_右下
    .如果真结束
    返回 (WndProc)

.子程序 窗口_控件调整_创建, , 公开, 在指定句柄窗口上创建自定义的控件
    .参数 窗口句柄, 整数型

    集_控件调整 ＝ GetWindowLongA (窗口句柄, #GWL_WNDPROC)
    SetWindowLongA (窗口句柄, #GWL_WNDPROC, 到整数 (&窗口控件调整过程))

.子程序 窗口_取光标位置1, 精易_坐标, 公开
    .参数 线程ID, 整数型, 可空, 可空，留空为自身的线程ID
    .局部变量 p, PGUITHREADINFO
    .局部变量 局_坐标, 精易_坐标

    .如果真 (是否为空 (线程ID))
        线程ID ＝ GetCurrentThread ()
    .如果真结束
    p.cbSize ＝ 64
    p.cbSize ＝ 48
    GetGUIThreadInfo (线程ID, p)
    局_坐标.横 ＝ p.rcCaret.左边
    局_坐标.纵 ＝ p.rcCaret.顶边
    返回 (局_坐标)

.子程序 窗口_是否在屏幕内, 逻辑型, 公开, 判断指定窗口是否在屏幕内，在屏幕内返回真，否则返回假
    .参数 窗口句柄, 整数型, , 要判断的窗口句柄
    .参数 是否自动校正, 逻辑型, , 如果窗口的左边、顶边小于0或大于屏蔽宽度或高度，将自动校正。
    .局部变量 精易_矩形, 精易_位置和大小
    .局部变量 局_成立, 逻辑型
    .局部变量 屏幕宽度, 整数型
    .局部变量 屏幕高度, 整数型

    精易_矩形 ＝ 窗口_取位置和大小 (窗口句柄)
    .如果真 (精易_矩形.左边 ＜ 0 或 精易_矩形.顶边 ＜ 0)
        局_成立 ＝ 真
    .如果真结束
    系统_取屏幕分辨率 (, , 屏幕宽度, 屏幕高度, )
    .如果真 (精易_矩形.左边 ＞ 屏幕宽度 或 精易_矩形.顶边 ＞ 屏幕高度)
        局_成立 ＝ 真
    .如果真结束
    .如果真 (局_成立 且 是否自动校正)
        窗口_置位置和大小 (窗口句柄, 50, 50, 精易_矩形.宽度, 精易_矩形.高度)
    .如果真结束
    返回 (局_成立 ＝ 假)

.子程序 窗口_监视热键_注册, , 公开, 使用例程：http://bbs.125.la/thread-40592-1-1.html  卸载：窗口_监视热键_卸载
    .参数 响应监视事件, 子程序指针, , 响应监视事件,3个参数,都为整数型,第1个为功能键,第2个为键代码,第3个为按键状态(1为按下，2为放开)

    .如果真 (集_Hook ≠ 0)
        返回 ()
    .如果真结束
    集_监视事件 ＝ 响应监视事件
    集_Hook ＝ SetWindowsHookExA (13, &监视处理, GetModuleHandleA1 (0), 0)

.子程序 监视处理, 整数型
    .参数 nCode, 整数型
    .参数 Wparam, 整数型
    .参数 Lparam, 整数型
    .局部变量 局_状态键, 整数型, 静态
    .局部变量 局_键代码, 整数型
    .局部变量 MSG, MSG

    .如果真 (nCode ＝ 0)
        RtlMoveMemory_MSG1 (MSG, Lparam, 20)
        .判断开始 (MSG.wParam ＜ 35) ' 按下
            局_键代码 ＝ MSG.hwnd
            .判断开始 (MSG.hwnd ＝ 160 或 MSG.hwnd ＝ 161) ' 左Shift键 和 右Shift键
                局_状态键 ＝ #Shift键
            .判断 (MSG.hwnd ＝ 162 或 MSG.hwnd ＝ 163) ' 左Ctrl键 和 右Ctrl键
                局_状态键 ＝ #Ctrl键
            .判断 (MSG.hwnd ＝ 164 或 MSG.hwnd ＝ 165) ' 左Alt键 和 右Alt键
                局_状态键 ＝ #Alt键
            .判断 (MSG.hwnd ＝ 91 或 MSG.hwnd ＝ 92) ' 左Win键 和 右Win键
                局_状态键 ＝ 91
            .默认
                
            .判断结束
            程序_执行整数子程序 (集_监视事件, 局_状态键, 局_键代码, 1)
            
        .判断 (MSG.wParam ＞ 127) ' 放开
            局_键代码 ＝ MSG.hwnd
            .判断开始 (MSG.hwnd ＝ 160 或 MSG.hwnd ＝ 161) ' 左Shift键 和 右Shift键
                局_状态键 ＝ 0
                
            .判断 (MSG.hwnd ＝ 162 或 MSG.hwnd ＝ 163) ' 左Ctrl键 和 右Ctrl键
                局_状态键 ＝ 0
                
            .判断 (MSG.hwnd ＝ 164 或 MSG.hwnd ＝ 165) ' 左Alt键 和 右Alt键
                局_状态键 ＝ 0
                
            .判断 (MSG.hwnd ＝ 91 或 MSG.hwnd ＝ 92) ' 左Win键 和 右Win键
                局_状态键 ＝ 0
            .默认
                
            .判断结束
            程序_执行整数子程序 (集_监视事件, 局_状态键, 局_键代码, 2)
        .默认
            
        .判断结束
        
    .如果真结束
    返回 (CallNextHookEx (集_Hook, nCode, Wparam, Lparam))

.子程序 窗口_取小图标, 字节集, 公开, 成功返回图标数据，失败返回空字节集{ }。
    .参数 主窗口句柄, 整数型, , 当前窗口的句柄
    .参数 hWnd, 整数型, , 目标窗口的句柄
    .局部变量 图标句柄, 整数型

    图标句柄 ＝ GetClassLongA (hWnd, -34) ' #GCL_HICONSM
    .如果真 (图标句柄 ＝ 0)
        图标句柄 ＝ SendMessageA (hWnd, 127, 0, 0) ' #WM_GETICON
    .如果真结束
    .如果真 (图标句柄 ＝ 0)
        .如果真 (窗口_取父句柄 (hWnd) ＝ 0)
            图标句柄 ＝ 文件_取图标句柄 (进程_取程序路径 (窗口_句柄取进程ID (hWnd)))
        .如果真结束
        
    .如果真结束
    返回 (图片_通过句柄取图标 (主窗口句柄, 图标句柄, 16, 16, #白色))

.子程序 窗口_监视热键_卸载, , 公开, 卸载键盘HOOK
    UnhookWindowsHookEx (集_Hook)
    集_Hook ＝ 0

.子程序 窗口_取控件ID, 整数型, 公开, 根据窗口句柄取出窗口控件的ID,顶级窗口将返回0;
    .参数 子窗口句柄, 整数型

    返回 (GetDlgCtrlID (子窗口句柄))

.子程序 窗口_控件ID取句柄, 整数型, 公开, 根据控件ID取出窗口句柄;
    .参数 父句柄, 整数型, , 上一级的窗口句柄;
    .参数 欲取句柄的控件ID, 整数型, , 控件ID用 "窗口_取控件ID()"命令取回;

    返回 (GetDlgItem (父句柄, 欲取句柄的控件ID))

.子程序 窗口_句柄取线程句柄, 整数型, 公开, 成功返回线程句柄,失败返回0
    .参数 窗口句柄, 整数型, 可空, 目标窗口句柄

    返回 (OpenThread (2032639, 0, 线程_取ID (窗口句柄)))

.子程序 窗口_置透明颜色, , 公开, 透明窗口指定的底色
    .参数 窗口句柄, 整数型, , 目标窗口句柄
    .参数 透明的颜色, 整数型

    SetWindowLongA (窗口句柄, -20, 524288)
    SetLayeredWindowAttributes (窗口句柄, 透明的颜色, 255, 1)

.子程序 窗口_激活, 整数型, 公开, 若函数调用成功，则返回原先活动窗口的句柄。若函数调用失败，则返回值为NULL   。
    .参数 窗口句柄, 整数型, 可空, 欲激活窗口的句柄
    .局部变量 局_当前线程ID
    .局部变量 局_目标线程ID
    .局部变量 局_返回值, 整数型

    局_当前线程ID ＝ GetCurrentThreadId ()
    局_目标线程ID ＝ GetWindowThreadProcessId (窗口句柄, 0)
    AttachThreadInput (局_目标线程ID, 局_当前线程ID, 真)
    局_返回值 ＝ SetActiveWindow (窗口句柄)
    AttachThreadInput (局_目标线程ID, 局_当前线程ID, 假)
    返回 (局_返回值)

.子程序 窗口_还原, 逻辑型, 公开, 恢复一个最小化的程序，并将其激活；成功把回真，失败返回假；
    .参数 窗口句柄, 整数型, , 欲还原的窗口句柄

    返回 (OpenIcon (窗口句柄))

.子程序 窗口_置顶, 逻辑型, 公开, 设置窗口在最顶端,成功返回真，失败返回假
    .参数 窗口句柄, 整数型, , 欲设置的窗口句柄
    .参数 是否激活, 逻辑型, 可空, 默认为激活,如果为假,窗口显示后不激活,不获取键盘焦点

    是否激活 ＝ 是否为空 (是否激活) 或 是否激活
    返回 (SetWindowPos (窗口句柄, #HWND_TOPMOST, 0, 0, 0, 0, 位或 (#SWP_NOMOVE, #SWP_NOSIZE, 选择 (是否激活, 0, #SWP_NOACTIVATE))) ≠ 0)

.子程序 窗口_关闭, , 公开, 将指定窗口销毁(无返回值)
    .参数 窗口句柄, 整数型, , 欲销毁窗口的句柄

    PostMessageW (窗口句柄, #WM_CLOSE, #NULL, #NULL)

.子程序 窗口_取字符串宽度, 整数型, 公开, 取一段文本在屏幕上有多少个像素宽
    .参数 窗口句柄, 整数型
    .参数 字符串, 文本型
    .局部变量 rect, 精易_矩形
    .局部变量 dc, 整数型

    GetWindowRect (窗口句柄, rect)
    dc ＝ GetDC (窗口句柄)
    DrawTextA (dc, 字符串, -1, rect, 位或 (1024, 32))
    ReleaseDC (0, dc)
    返回 (rect.右边 － rect.左边)

.子程序 窗口_按类名枚举, , 公开, 根据类名枚举窗口
    .参数 类名, 文本型
    .参数 子程序地址, 子程序指针, , 第一个参数为句柄
    .参数 备用参数, 整数型, 可空, 弄完记得释放
    .局部变量 hWnd, 整数型
    .局部变量 lRes, 整数型

    hWnd ＝ FindWindowExA (#NULL, #NULL, 取指针文本_ (类名), #NULL)
    .判断循环首 (hWnd ≠ 0)
        lRes ＝ 调用子程序_ (到整数 (子程序地址), hWnd, 备用参数, , , , , , , , , , , , , )
        .如果真 (lRes ＝ 0)
            跳出循环 ()
        .如果真结束
        hWnd ＝ FindWindowExA (#NULL, hWnd, 取指针文本_ (类名), #NULL)
    .判断循环尾 ()

.子程序 窗口_强制显示, 整数型, 公开, 对窗口进行置顶、激活等操作（注：非强制显示隐藏窗口）
    .参数 句柄, 整数型, , 目标窗口句柄
    .参数 总在最前, 逻辑型, 可空, 默认为假:取消总在最前  真:总在最前

    返回 (SetWindowPos (句柄, 选择 (总在最前, #HWND_TOPMOST, #HWND_NOTOPMOST), 0, 0, 0, 0, 位或 (#SWP_NOMOVE, #SWP_NOSIZE, #SWP_SHOWWINDOW)))

.子程序 窗口_创建Flash, 整数型, 公开, 在指定句柄窗口上创建一个FLASH控件
    .参数 父窗口句柄, 整数型
    .参数 Flash地址, 文本型, , 可以为网络和本地的
    .参数 窗口宽度, 整数型
    .参数 窗口高度, 整数型
    .参数 窗口左边, 整数型, 可空, 可空。默认为1。
    .参数 窗口顶边, 整数型, 可空, 可空。默认为1。

    .如果真 (是否为空 (窗口左边))
        窗口左边 ＝ 1
    .如果真结束
    .如果真 (是否为空 (窗口顶边))
        窗口顶边 ＝ 1
    .如果真结束
    AtlAxWinInit ()
    返回 (CreateWindowExA (512, “AtlAxWin”, Flash地址, 位或 (1073741826, 268435456, 65536, 33554432), 窗口左边, 窗口顶边, 窗口宽度, 窗口高度, 父窗口句柄, 0, GetWindowLongA (父窗口句柄, -6), 0))

.子程序 窗口_闪动, , 公开, 无返回值
    .参数 窗口句柄, 整数型, , 指定闪动的窗口句柄 
    .参数 是否闪动, 逻辑型, , 是否闪动指定的窗口

    FlashWindow (窗口句柄, 是否闪动)

.子程序 窗口_闪动Ex, 逻辑型, 公开, 闪烁指定窗口，可选闪烁标题、任务栏、次数、速度，成功返回真，失败返回假。
    .参数 窗口句柄, 整数型, , 指定闪动的窗口句柄 
    .参数 闪烁类型, , 可空, 可为空,默认为标题闪烁,可选参数(多个值可相加);0=停止;1=标题;2=任务栏;3=标题与任务栏;4=连续
    .参数 闪烁次数, , 可空, 可为空,默认即1次.
    .参数 闪烁速度, , 可空, 可为空,即默认速度.单位为"毫秒"
    .局部变量 pfwi, PFLASHWINFO

    pfwi.cbSize ＝ 20
    pfwi.hwnd ＝ 窗口句柄
    pfwi.uCount ＝ 选择 (是否为空 (闪烁次数), 1, 闪烁次数)
    pfwi.dwFlags ＝ 选择 (是否为空 (闪烁类型), 1, 闪烁类型)
    pfwi.dwTimeout ＝ 闪烁速度
    返回 (FlashWindowEx (pfwi))

.子程序 窗口_写字, , 公开, 在指定的窗口上写字;
    .参数 窗口句柄, 整数型, 可空, 可空:默认为"当前窗口"
    .参数 内容, 文本型, 可空, 可空:默认为"精易论坛 bbs.125.la"
    .参数 字体, 文本型, 可空, 可空:默认为"宋体"
    .参数 字体大小, 整数型, 可空, 可空:默认为"28"
    .参数 字体颜色, 整数型, 可空, 可空:默认为"红色"
    .参数 横坐标, 整数型, 可空, 可空:默认为"0"
    .参数 纵坐标, 整数型, 可空, 可空:默认为"0"
    .局部变量 hDC, 整数型
    .局部变量 lpLogFont, LOGFONT
    .局部变量 hFont, 整数型, , , 新创建的字体
    .局部变量 hFontOld, 整数型, , , 窗口DC原来的字体
    .局部变量 bkModeOld, 整数型, , , 窗口原来的背景模式
    .局部变量 crFontOld, 整数型, , , 窗口原来的字体

    .判断开始 (是否为空 (窗口句柄))
        hDC ＝ GetDC (GetForegroundWindow ())
    .默认
        hDC ＝ GetDC (窗口句柄)
    .判断结束
    .如果真 (是否为空 (内容))
        内容 ＝ “精易论坛 bbs.125.la”
    .如果真结束
    .如果真 (是否为空 (字体))
        字体 ＝ “宋体”
    .如果真结束
    .如果真 (是否为空 (字体颜色))
        字体颜色 ＝ 255
    .如果真结束
    .如果真 (是否为空 (字体大小))
        字体大小 ＝ 26
    .如果真结束
    .如果真 (hDC ＝ 0)
        返回 ()
    .如果真结束
    lpLogFont.lfCharSet ＝ #GB2312_CHARSET
    memcpy (取数据_通用型_数组 (lpLogFont.lfFaceName), 取指针_文本型 (字体), 取文本长度 (字体))
    lpLogFont.lfHeight ＝ 字体大小
    hFont ＝ CreateFontIndirectA (lpLogFont)
    hFontOld ＝ SelectObject (hDC, hFont)
    bkModeOld ＝ SetBkMode (hDC, #TRANSPARENT)
    crFontOld ＝ SetTextColor (hDC, 字体颜色)
    TextOutA (hDC, 横坐标, 纵坐标, 内容, 取文本长度 (内容))
    SetBkMode (hDC, bkModeOld)
    SetTextColor (hDC, crFontOld)
    SelectObject (hDC, hFontOld)
    DeleteObject (hFont)
    ReleaseDC (窗口句柄, hDC)

.子程序 窗口_置父, 整数型, 公开, 指定一个窗口的新父(返回  前一个父窗口的句柄)
    .参数 子窗口句柄, 整数型, , 子窗口的句柄
    .参数 父窗口句柄, 整数型, , hWndChild的新父
    .局部变量 hParent, 整数型

    hParent ＝ SetParent (子窗口句柄, 父窗口句柄)
    .如果真 (hParent ＝ #NULL)
        输出调试文本 (取错误信息文本_API (, ))
    .如果真结束
    返回 (hParent)

.子程序 窗口_置父彗星, 逻辑型, 公开, 真正的置父窗口  By:邓学彬(泪闯天涯)
    .参数 父窗口句柄, 整数型
    .参数 子窗口句柄, 整数型
    .参数 子窗口左边, 整数型, 可空, 留空默认为0
    .参数 子窗口顶边, 整数型, 可空, 留空默认为0
    .参数 子窗口宽度, 整数型, 可空, 留空宽度不变
    .参数 子窗口高度, 整数型, 可空, 留空高度不变
    .局部变量 dwStyle, 整数型
    .局部变量 dwNewStyle, 整数型
    .局部变量 Rect, 精易_矩形
    .局部变量 hWndParentOld, 整数型
    .局部变量 dwStyleOld, 整数型

    .判断开始 (父窗口句柄 ＝ 0)
        hWndParentOld ＝ GetPropA (子窗口句柄, “hwndparentold_tmp”) ' 获取子窗口原父句柄
        dwStyle ＝ GetPropA (子窗口句柄, “styleold_tmp”) ' 获取子窗口原样式
        SetWindowLongA (子窗口句柄, #GWL_STYLE, dwStyle) ' 还原原样式
        SetParent (子窗口句柄, hWndParentOld) ' 还原原父窗口
        RemovePropA (子窗口句柄, “hwndparentold_tmp”)
        RemovePropA (子窗口句柄, “styleold_tmp”)
        
    .默认
        ' 设置父窗口
        SetParent (子窗口句柄, 父窗口句柄)
        ' 设置窗口样式 去除WS_POPUP,加入WS_CHILD
        hWndParentOld ＝ GetParent (子窗口句柄) ' 获取窗口原父句柄,恢复时用到
        dwStyleOld ＝ GetWindowLongA (子窗口句柄, #GWL_STYLE)
        dwStyle ＝ GetWindowLongA (子窗口句柄, #GWL_STYLE) ' 窗口原来的样式,还原时用到
        
        dwNewStyle ＝ 位与 (dwStyle, 位取反 (#WS_POPUP)) ' 去除WS_POPUP
        dwNewStyle ＝ 位或 (dwNewStyle, #WS_CHILD) ' 加入WS_CHILD
        
        SetPropA (子窗口句柄, “hwndparentold_tmp”, hWndParentOld) ' 记录原父句柄
        SetPropA (子窗口句柄, “styleold_tmp”, dwStyle) ' 记录原样式
        
        .如果真 (dwStyle ≠ dwNewStyle)
            SetWindowLongA (子窗口句柄, #GWL_STYLE, dwNewStyle)
        .如果真结束
        
    .判断结束
    ' 调整子窗口位置
    GetWindowRect (子窗口句柄, Rect)
    .如果真 (是否为空 (子窗口宽度))
        子窗口宽度 ＝ Rect.右边 － Rect.左边
    .如果真结束
    .如果真 (是否为空 (子窗口高度))
        子窗口高度 ＝ Rect.底边 － Rect.顶边
    .如果真结束
    返回 (MoveWindow (子窗口句柄, 子窗口左边, 子窗口顶边, 子窗口宽度, 子窗口高度, 真))
    
    
    

.子程序 窗口_取句柄, 整数型, 公开, 成功返回控件的句柄，失败返回0
    .参数 父窗口句柄, 整数型, 可空, 如果是取顶级的窗口句柄请留空
    .参数 子窗口句柄, 整数型, 可空, 如果是取顶级的窗口句柄请留空
    .参数 窗口类名, 文本型, 可空, 窗口的类名
    .参数 窗口标题, 文本型, 可空, 窗口的标题

    返回 (FindWindowExA (父窗口句柄, 子窗口句柄, 取指针文本_ (窗口类名), 取指针文本_ (窗口标题)))

.子程序 窗口_取句柄_模糊, 整数型, 公开, 成功返回指定窗口句柄,失败返回0
    .参数 窗口标题, 文本型, 可空, 标题支持模糊，如窗口的标题为【精易⌒技术交流群①】你只需要【流群①】取可
    .参数 窗口类名, 文本型, 可空, 类名必须为精确的,或者不填
    .局部变量 局_窗口句柄, 整数型
    .局部变量 TitleName, 文本型

    .判断循环首 (真)
        局_窗口句柄 ＝ FindWindowExA (0, 局_窗口句柄, 取指针文本_ (窗口类名), 0)
        .如果 (局_窗口句柄 ≠ 0)
            TitleName ＝ 到小写 (窗口_取标题 (局_窗口句柄))
            .如果真 (寻找文本 (TitleName, 到小写 (窗口标题), , 假) ≠ -1)
                返回 (局_窗口句柄)
            .如果真结束
            
        .否则
            跳出循环 ()
        .如果结束
        
    .判断循环尾 ()
    返回 (0)

.子程序 窗口_取坐标, 精易_坐标, 公开, 取鼠标在指定窗口上的坐标；
    .参数 窗口句柄, 整数型, , 目标窗口句柄
    .局部变量 屏幕坐标, 精易_坐标
    .局部变量 矩形, 精易_位置和大小
    .局部变量 结果坐标, 精易_坐标

    屏幕坐标 ＝ 鼠标_取位置 ()
    矩形 ＝ 窗口_取位置和大小 (窗口句柄)
    结果坐标.横 ＝ 屏幕坐标.横 － 矩形.左边
    结果坐标.纵 ＝ 屏幕坐标.纵 － 矩形.顶边
    返回 (结果坐标)

.子程序 窗口_取控件坐标, 精易_坐标, 公开, 取指定窗口(左上角\顶点)在屏幕中的位置
    .参数 窗口句柄, 整数型, 可空, 可空:则取当前窗口句柄的位置
    .局部变量 坐标变量, 精易_坐标

    .如果真 (窗口句柄 ＝ 0)
        窗口句柄 ＝ GetFocus ()
    .如果真结束
    坐标变量.横 ＝ 0
    坐标变量.纵 ＝ 0
    ClientToScreen (窗口句柄, 坐标变量)
    返回 (坐标变量)

.子程序 窗口_置焦点, 逻辑型, 公开, 把焦点置到指定的控件上,成功返回真，失败返回假；
    .参数 窗口句柄, 整数型, , 要置焦点的窗口句柄

    返回 (SetForegroundWindow (窗口句柄))

.子程序 窗口_取标题, 文本型, 公开, 获取指定窗口句柄的标题
    .参数 窗口句柄, 整数型

    返回 (编码_Unicode到Ansi (窗口_取标题W (窗口句柄)))

.子程序 窗口_取标题W, 字节集, 公开, 获取指定窗口句柄的标题
    .参数 窗口句柄, 整数型
    .局部变量 dwSize, 整数型
    .局部变量 szTitle, 字节集

    dwSize ＝ GetWindowTextLengthW (窗口句柄)
    .如果真 (dwSize ＝ 0)
        返回 ({ })
    .如果真结束
    dwSize ＝ dwSize ＋ 1 ' 必须算上空字符
    szTitle ＝ 取空白字节集 (dwSize × 2)
    GetWindowTextW (窗口句柄, 取指针_字节集型 (szTitle), dwSize)
    返回 (szTitle)

.子程序 窗口_置标题, 逻辑型, 公开, 改指定窗口句柄的窗口标题(非"0"表示成功,返回"0"表示失败)
    .参数 窗口句柄, 整数型, , 欲更改窗口标题的句柄
    .参数 新标题, 文本型, , 欲改成的新标题

    返回 (SetWindowTextA (窗口句柄, 新标题))

.子程序 窗口_取类名, 文本型, 公开, 取指定窗口句柄的窗口类名(返回窗口类名,失败返回空文本)
    .参数 窗口句柄, 整数型, , 欲取类名的窗口句柄
    .局部变量 szClassName, 文本型

    szClassName ＝ 取空白文本 (#MAX_PATH ＋ 1)
    assignZero (szClassName, GetClassNameA (窗口句柄, szClassName, #MAX_PATH))
    返回 (szClassName)

.子程序 窗口_置状态, 逻辑型, 公开, 成功返回真，失败返回假
    .参数 窗口句柄, 整数型, , 欲设置状态的窗口句柄
    .参数 状态类型, 整数型, , 0 隐藏取消激活 1 还原激活 2 最小化激活 3 最大化激活 4 还原 6 最小化取消激活 7 最小化 9 还原激活

    返回 (ShowWindow (窗口句柄, 状态类型))

.子程序 窗口_最大化, , 公开, 将指定窗口最大化(无返回值) 
    .参数 窗口句柄, 整数型, , 欲最大化窗口的句柄
    .参数 是否无边框, 逻辑型, 可空, 如果窗口边框为[无边框]请将此参数设置为真

    窗口_置焦点 (窗口句柄)
    .如果 (是否无边框)
        窗口_置位置和大小 (窗口句柄, -2, -2, GetSystemMetrics (62), GetSystemMetrics (61))
    .否则
        PostMessageA (窗口句柄, #WM_SYSCOMMAND, #SC_MAXIMIZE, 0)
    .如果结束
    

.子程序 窗口_最小化, 逻辑型, 公开, 成功返回真，失败返回假
    .参数 窗口句柄, 整数型, , 欲最小化的窗口句柄

    返回 (CloseWindow (窗口句柄) ≠ 0)

.子程序 窗口_圆角化, , 公开, 把窗口的四个直角设置成圆角
    .参数 窗口句柄, 整数型, , 要设置圆角的窗口
    .参数 圆角椭圆的宽, 整数型, 可空, 一般为50
    .参数 圆角椭圆的高, 整数型, 可空, 一般为50
    .局部变量 矩形区域句柄, 整数型
    .局部变量 窗口宽度, 整数型
    .局部变量 窗口高度, 整数型

    .如果真 (是否为空 (圆角椭圆的宽))
        圆角椭圆的宽 ＝ 50
    .如果真结束
    .如果真 (是否为空 (圆角椭圆的高))
        圆角椭圆的高 ＝ 50
    .如果真结束
    窗口_取控件大小 (窗口句柄, 窗口宽度, 窗口高度)
    矩形区域句柄 ＝ CreateRoundRectRgn (0, 0, 窗口宽度, 窗口高度, 圆角椭圆的宽, 圆角椭圆的高)
    SetWindowRgn (窗口句柄, 矩形区域句柄, 真)
    DeleteObject (矩形区域句柄)

.子程序 控件_圆角化, , 公开, 把窗口的四个直角设置成圆角
    .参数 控件句柄, 整数型, , 要设置圆角的窗口
    .参数 圆角椭圆的宽, 整数型, , 一般为50
    .参数 圆角椭圆的高, 整数型, , 一般为50
    .局部变量 矩形区域句柄, 整数型
    .局部变量 局_宽度, 整数型
    .局部变量 局_高度, 整数型

    窗口_取控件大小 (控件句柄, 局_宽度, 局_高度)
    矩形区域句柄 ＝ CreateRoundRectRgn (0, 0, 局_宽度, 局_高度, 圆角椭圆的宽, 圆角椭圆的高)
    SetWindowRgn (控件句柄, 矩形区域句柄, 真)
    DeleteObject (矩形区域句柄)

.子程序 控件_隐藏滚动条, 逻辑型, 公开, 隐藏控件的滚动条
    .参数 窗口句柄, 整数型
    .参数 指定要隐藏的滚动条, 整数型, 可空, #SB_xxx
    .局部变量 oldCtrlProc, 整数型

    控件_显示滚动条 (窗口句柄)
    oldCtrlProc ＝ SetWindowLongA (窗口句柄, #GWL_WNDPROC, 到整数 (&CtrlProc))
    .如果真 (oldCtrlProc ≠ #NULL)
        SetPropA (窗口句柄, “{005A681D-41C3-4289-AB0B-38EAC54A8462}|oldCtrlProc”, oldCtrlProc)
        ShowScrollBar (窗口句柄, 指定要隐藏的滚动条, 假)
        SetPropA (窗口句柄, “{005A681D-41C3-4289-AB0B-38EAC54A8462}|wBar”, 指定要隐藏的滚动条)
    .如果真结束
    返回 (oldCtrlProc ≠ #NULL)

.子程序 CtrlProc, 整数型
    .参数 hCtrl, 整数型
    .参数 uMsg, 整数型
    .参数 wParam, 整数型
    .参数 lParam, 整数型
    .局部变量 oldCtrlProc, 整数型
    .局部变量 wBar, 整数型

    oldCtrlProc ＝ GetPropA (hCtrl, “{005A681D-41C3-4289-AB0B-38EAC54A8462}|oldCtrlProc”)
    .如果真 (uMsg ＝ #WM_PAINT 或 uMsg ＝ #WM_NCCALCSIZE)
        wBar ＝ GetPropA (hCtrl, “{005A681D-41C3-4289-AB0B-38EAC54A8462}|wBar”)
        ShowScrollBar (hCtrl, wBar, 假)
    .如果真结束
    返回 (CallWindowProcA (oldCtrlProc, hCtrl, uMsg, wParam, lParam))

.子程序 控件_显示滚动条, 逻辑型, 公开, 显示控件的滚动条
    .参数 窗口句柄, 整数型
    .局部变量 oldCtrlProc, 整数型
    .局部变量 wBar, 整数型

    oldCtrlProc ＝ GetPropA (窗口句柄, “{005A681D-41C3-4289-AB0B-38EAC54A8462}|oldCtrlProc”)
    .如果真 (oldCtrlProc ≠ #NULL)
        SetWindowLongA (窗口句柄, #GWL_WNDPROC, oldCtrlProc)
    .如果真结束
    RemovePropA (窗口句柄, “{005A681D-41C3-4289-AB0B-38EAC54A8462}|oldCtrlProc”)
    wBar ＝ GetPropA (窗口句柄, “{005A681D-41C3-4289-AB0B-38EAC54A8462}|wBar”)
    ShowScrollBar (窗口句柄, wBar, 真)
    RemovePropA (窗口句柄, “{005A681D-41C3-4289-AB0B-38EAC54A8462}|wBar”)
    返回 (oldCtrlProc ≠ #NULL)

.子程序 窗口_置窗口化, , 公开, 将指定窗口窗口化.通常用于游戏中..
    .参数 句柄, 整数型, , 欲窗口化的窗口句柄(通常有这一个参数就可以了,其它可以不设定)
    .参数 新宽度, 整数型, 可空, 窗口化后的窗口宽度 可空:800
    .参数 新高度, 整数型, 可空, 窗口化后的窗口高度 可空:600
    .参数 窗口标题, 文本型, 可空, 窗口化后的窗口标题 可空:不修改原窗口标题(有的游戏修改标题后会自动退出)
    .参数 是否带边框, 逻辑型, 可空, 可空:无边框窗口 真:带标题栏(有的游戏屏蔽了边框的修改,可通过其它方法来实现)
    .参数 分辨率_宽, 整数型, 可空, 可空:不修改分辨率(有的游戏全屏时修改了其分辨率,需改回去..)
    .参数 分辨率_高, 整数型, 可空, 可空:不修改分辨率

    .如果真 (是否带边框)
        SetWindowLongA (句柄, -16, 348913664)
    .如果真结束
    .如果真 (是否为空 (窗口标题) ＝ 假)
        SetWindowTextA (句柄, 窗口标题)
    .如果真结束
    .如果真 (是否为空 (新宽度))
        新宽度 ＝ 800
    .如果真结束
    .如果真 (是否为空 (新高度))
        新高度 ＝ 600
    .如果真结束
    MoveWindow (句柄, 0, 0, 新宽度, 新高度, 真)
    .如果真 (取反 (是否为空 (分辨率_宽) 且 是否为空 (分辨率_高)))
        系统_置屏幕分辨率 (, 分辨率_宽, 分辨率_高, , 1)
    .如果真结束
    

.子程序 窗口_取祖句柄, 整数型, 公开, 取一个窗口的顶级句柄，如果提供的句柄已是顶级句柄，将直接返回。
    .参数 窗口句柄, 整数型, , 欲取祖窗口句柄的子窗口句柄

    返回 (GetAncestor (窗口句柄, #GA_ROOTOWNER))

.子程序 窗口_取父句柄, 整数型, 公开, 判断一个窗口是否有父窗口，如有直接返回该窗口的像窗口句柄，否则返回0
    .参数 窗口句柄, 整数型, , 欲取父窗口的窗口句柄

    返回 (GetParent (窗口句柄))

.子程序 窗口_取父句柄EX, 整数型, 公开, 获取指定窗口句柄的父句柄
    .参数 窗口句柄, 整数型
    .参数 超时, 整数型, 可空, 为空则无限循环
    .局部变量 局_祖句柄, 整数型
    .局部变量 局_数组, 整数型, , "0"
    .局部变量 计次, 整数型

    .如果真 (是否为空 (超时))
        超时 ＝ -1
    .如果真结束
    局_祖句柄 ＝ 进程_ID取窗口句柄 (窗口_句柄取进程ID (窗口句柄), , , 超时) ' 获取这个窗口同进程ID的实际祖句柄
    窗口_枚举所有子窗口 (局_祖句柄, 局_数组) ' 再获取这个祖窗口下所有窗口句柄
    加入成员 (局_数组, 局_祖句柄) ' 当然祖句柄也算进去
    .计次循环首 (取数组成员数 (局_数组), 计次)
        .如果真 (GetWindow (局_数组 [计次], 5) ＝ 窗口句柄) ' 获取每个窗口的第一个子窗口句柄是否是我们查询的
            返回 (局_数组 [计次]) ' 是就返回这个句柄
        .如果真结束
        
    .计次循环尾 ()
    返回 (0)

.子程序 窗口_是否可见, 逻辑型, 公开, 返回真为可见，否则为不可见
    .参数 窗口句柄, 整数型, , 窗口句柄

    返回 (IsWindowVisible (窗口句柄))

.子程序 窗口_显示隐藏, 逻辑型, 公开, 窗口显示或隐藏
    .参数 窗口句柄, 整数型, , 欲操作的窗口句柄
    .参数 显示隐藏, 逻辑型, , 真 = 显示；假 = 隐藏；

    返回 (ShowWindowAsync (窗口句柄, 显示隐藏))

.子程序 窗口_置透明度, 逻辑型, 公开, 设置窗口透明状态(成功返回真,失败返回假)  
    .参数 窗口句柄, 整数型, , 设置透明化窗口的句柄
    .参数 透明度, 字节型, 可空, 设置整个窗口的透明度  取值范围是[0,255] 可空为不设定此参数
    .参数 透明色, 整数型, 可空, (#颜色)指定某颜色为完全透明(完全透明处不属于该窗口)  可空为不指定
    .参数 鼠标穿透, 逻辑型, 可空, 可空为假   真:窗口被鼠标穿透
    .局部变量 临时变量, 整数型
    .局部变量 临时方法, 整数型

    .如果 (鼠标穿透)
        临时变量 ＝ GetWindowLongA (窗口句柄, #GWL_EXSTYLE)
        临时变量 ＝ 位或 (临时变量, 32, 524288)
        SetWindowLongA (窗口句柄, #GWL_EXSTYLE, 临时变量) ' 设置鼠标穿透
    .否则
        SetWindowLongA (窗口句柄, #GWL_EXSTYLE, 524288)
    .如果结束
    
    .判断开始 (透明色 ＝ 0)
        临时方法 ＝ 2
    .默认
        .如果 (透明度 ＝ 0)
            临时方法 ＝ 1
        .否则
            临时方法 ＝ 3
        .如果结束
        
    .判断结束
    返回 (SetLayeredWindowAttributes (窗口句柄, 透明色, 透明度, 临时方法))

.子程序 窗口_取透明度, 整数型, 公开, 成功返回窗口的透明度，失败返回-1。
    .参数 窗口句柄, 整数型
    .局部变量 dwStyle, 整数型
    .局部变量 dwAlpha, 整数型

    dwStyle ＝ GetWindowLongA (窗口句柄, #GWL_EXSTYLE)
    .如果 (位与 (dwStyle, #WS_EX_LAYERED) ≠ 0)
        GetLayeredWindowAttributes (窗口句柄, #NULL, dwAlpha, #NULL)
    .否则
        dwAlpha ＝ -1
    .如果结束
    返回 (dwAlpha)

.子程序 窗口_置穿透, 逻辑型, 公开, @福仔
    .参数 窗口句柄, 整数型
    .参数 是否穿透, 逻辑型, 可空, 真为穿透,假为不穿透,默认为假
    .局部变量 dwStyleEx, 整数型
    .局部变量 dwStyleExNew, 整数型

    .如果真 (取反 (是否穿透))
        dwStyleEx ＝ GetPropA (窗口句柄, “transparent_tmp”)
        RemovePropA (窗口句柄, “transparent_tmp”) ' 删除这个属性
        SetWindowLongA (窗口句柄, #GWL_EXSTYLE, dwStyleEx) ' 重新取一下,看是否设置成功
        返回 (dwStyleEx ＝ GetWindowLongA (窗口句柄, #GWL_EXSTYLE)) ' 重新取一下,看是否设置成功
    .如果真结束
    
    dwStyleEx ＝ GetWindowLongA (窗口句柄, #GWL_EXSTYLE)
    .如果真 (位与 (dwStyleExNew, #WS_EX_TRANSPARENT) ＝ 0) ' 如果窗口没有这个样式,就加上这个样式
        dwStyleExNew ＝ 位或 (dwStyleExNew, #WS_EX_TRANSPARENT)
    .如果真结束
    .如果真 (位与 (dwStyleExNew, #WS_EX_LAYERED) ＝ 0) ' 如果窗口没有这个样式,就加上这个样式
        dwStyleExNew ＝ 位或 (dwStyleExNew, #WS_EX_LAYERED)
    .如果真结束
    SetPropA (窗口句柄, “transparent_tmp”, dwStyleEx) ' 记录原样式,取消穿透时用到
    SetWindowLongA (窗口句柄, #GWL_EXSTYLE, dwStyleExNew)
    dwStyleEx ＝ GetWindowLongA (窗口句柄, #GWL_EXSTYLE) ' 重新取一下,看是否设置成功
    返回 (位与 (dwStyleEx, #WS_EX_TRANSPARENT, #WS_EX_LAYERED) ≠ 0) ' 如果有这两个样式就表示成功

.子程序 窗口_总在最前, 逻辑型, 公开, 将指定窗口设为总在最前
    .参数 窗口句柄, 整数型, , 欲设置的窗口句柄
    .参数 是否总在最前, 逻辑型, 可空, 默认为假:取消总在最前  真:总在最前

    .如果真 (是否总在最前)
        窗口_置焦点 (窗口句柄)
    .如果真结束
    返回 (SetWindowPos (窗口句柄, 选择 (是否总在最前, #HWND_TOPMOST, #HWND_NOTOPMOST), 0, 0, 0, 0, 位或 (#SWP_NOSIZE, #SWP_NOMOVE)) ≠ 0)

.子程序 窗口_锁住解锁, 逻辑型, 公开, 在指定的窗口里允许或禁止所有鼠标及键盘输入
    .参数 窗口句柄, 整数型, , 要锁住或解锁的窗口句柄
    .参数 类型, 逻辑型, , 真 = 锁住；假 = 解锁；

    返回 (EnableWindow (窗口句柄, 取反 (类型)))

.子程序 窗口_禁止关闭, 逻辑型, 公开, 控制窗口关闭按钮,(允许/禁止)关闭窗口 (成功返回真,失败返回假)
    .参数 窗口句柄, 整数型, , 欲禁止或解除禁止的窗口句柄
    .参数 禁止关闭, 逻辑型, 可空, 默认为真,禁止关闭； 假:允许关闭； 真:禁止关闭；
    .局部变量 系统菜单句柄, 整数型
    .局部变量 矩形, 精易_矩形

    .如果真 (是否为空 (禁止关闭))
        禁止关闭 ＝ 真
    .如果真结束
    
    系统菜单句柄 ＝ GetSystemMenu (窗口句柄, 0)
    .如果真 (系统菜单句柄 ＝ 0)
        返回 (假)
    .如果真结束
    .如果 (禁止关闭 ＝ 真)
        EnableMenuItem (系统菜单句柄, 6, 1025) ' 禁止关闭
    .否则
        EnableMenuItem (系统菜单句柄, 6, 1024) ' 允许关闭
    .如果结束
    .如果真 (取反 (GetWindowRect (窗口句柄, 矩形)))
        返回 (假)
    .如果真结束
    .如果真 (取反 (RedrawWindow (0, 矩形, 0, 位或 (1, 128, 256))))
        返回 (假)
    .如果真结束
    返回 (真)

.子程序 窗口_热键注册, 逻辑型, 公开, 注册一个全局热键, 成功返回真, 失败返回假
    .参数 窗口句柄, 整数型
    .参数 功能键, 整数型, 可空, 1 Alt  2 Ctrl  4 Shift  8 Win 若要两个或以上的状态按键则把它们的值位或
    .参数 键代码, 整数型, , 如：#F键
    .参数 响应热键事件, 子程序指针, , 响应热键事件的子程序指针, 四个参数(窗口句柄, 消息, 热键ID, 参数)
    .参数 热键ID, 整数型, , 标识！必须大于0，销毁时用；
    .局部变量 pHotKeyList, 整数型
    .局部变量 WndProc, 整数型
    .局部变量 dwCount, 整数型
    .局部变量 pHotKeyInfo, 整数型
    .局部变量 ptr, 整数型

    .如果真 (热键ID ≠ 0)
        窗口_热键卸载 (窗口句柄, 热键ID)
        .如果真 (RegisterHotKey (窗口句柄, 热键ID, 功能键, 键代码))
            pHotKeyList ＝ GetPropA (窗口句柄, “HOTKEYLIST”)
            .如果真 (pHotKeyList ＝ #NULL)
                pHotKeyList ＝ LocalAlloc (#LMEM_ZEROINIT, 12)
            .如果真结束
            .如果真 (pHotKeyList ≠ #NULL)
                SetPropA (窗口句柄, “HOTKEYLIST”, pHotKeyList)
                dwCount ＝ __get (pHotKeyList, 0)
                WndProc ＝ __get (pHotKeyList, 4)
                .如果真 (WndProc ＝ #NULL)
                    WndProc ＝ SetWindowLongA (窗口句柄, #GWL_WNDPROC, 到整数 (&HotkeyCallbackEvent))
                    __set (pHotKeyList, 4, WndProc)
                .如果真结束
                ptr ＝ LocalAlloc (#LMEM_ZEROINIT, (dwCount ＋ 1) × 12) ' (dwCount + 1) * sizeof(HOTKEYINFO)
                .如果真 (ptr ≠ #NULL)
                    pHotKeyInfo ＝ __get (pHotKeyList, 8)
                    .如果真 (pHotKeyInfo ≠ #NULL)
                        memcpy (ptr, pHotKeyInfo, dwCount × 12) ' dwCount * sizeof(HOTKEYINFO)
                        LocalFree (pHotKeyInfo)
                    .如果真结束
                    __set (pHotKeyList, 8, ptr)
                    ptr ＝ ptr ＋ dwCount × 12
                    __set (ptr, 0, 窗口句柄) ' hWnd
                    __set (ptr, 4, 热键ID) ' dwHotKeyId
                    __set (ptr, 8, 到整数 (响应热键事件)) ' WndProc
                .如果真结束
                __set (pHotKeyList, 0, dwCount ＋ 1)
            .如果真结束
            返回 (真)
        .如果真结束
        
    .如果真结束
    返回 (假)

.子程序 窗口_热键卸载, 逻辑型, 公开, 成功返回真，失败返回假；
    .参数 窗口句柄, 整数型
    .参数 热键ID, 整数型, , 窗口_热键注册 时用的热键ID
    .局部变量 pHotKeyList, 整数型
    .局部变量 dwCount, 整数型
    .局部变量 WndProc, 整数型
    .局部变量 pHotKeyInfo, 整数型
    .局部变量 dwHotKeyId, 整数型
    .局部变量 isRet, 逻辑型
    .局部变量 i, 整数型

    .如果真 (热键ID ≠ 0)
        pHotKeyList ＝ GetPropA (窗口句柄, “HOTKEYLIST”)
        .如果真 (pHotKeyList ≠ #NULL)
            dwCount ＝ __get (pHotKeyList, 0)
            WndProc ＝ __get (pHotKeyList, 4)
            pHotKeyInfo ＝ __get (pHotKeyList, 8)
            .如果真 (pHotKeyInfo ≠ #NULL)
                .计次循环首 (dwCount, i)
                    dwHotKeyId ＝ __get (pHotKeyInfo, (i － 1) × 12 ＋ 4)
                    .如果真 (dwHotKeyId ＝ 热键ID)
                        isRet ＝ UnregisterHotKey (窗口句柄, dwHotKeyId)
                        .如果 (dwCount ＝ 1)
                            .如果真 (WndProc ≠ #NULL)
                                SetWindowLongA (窗口句柄, #GWL_WNDPROC, WndProc)
                            .如果真结束
                            LocalFree (pHotKeyInfo)
                            RemovePropA (窗口句柄, “HOTKEYLIST”)
                        .否则
                            .如果真 (i ＜ dwCount)
                                memcpy (pHotKeyInfo ＋ (i － 1) × 12, pHotKeyInfo ＋ i × 12, (dwCount － i) × 12)
                            .如果真结束
                            memset (pHotKeyInfo ＋ (dwCount － 1) × 12, 0, 12)
                            __set (pHotKeyList, 0, dwCount － 1)
                        .如果结束
                        跳出循环 ()
                    .如果真结束
                    
                .计次循环尾 ()
            .如果真结束
            
        .如果真结束
        
    .如果真结束
    返回 (isRet)

.子程序 HotkeyCallbackEvent, 整数型
    .参数 hwnd, 整数型
    .参数 message, 整数型
    .参数 wParam, 整数型
    .参数 lParam, 整数型
    .局部变量 pHotKeyList, 整数型
    .局部变量 dwCount, 整数型
    .局部变量 WndProc, 整数型
    .局部变量 pHotKeyInfo, 整数型
    .局部变量 dwHotKeyId, 整数型
    .局部变量 i, 整数型

    pHotKeyList ＝ GetPropA (hwnd, “HOTKEYLIST”)
    dwCount ＝ __get (pHotKeyList, 0)
    WndProc ＝ __get (pHotKeyList, 4)
    pHotKeyInfo ＝ __get (pHotKeyList, 8)
    .如果真 (message ＝ #WM_HOTKEY)
        .计次循环首 (dwCount, i)
            dwHotKeyId ＝ __get (pHotKeyInfo ＋ (i － 1) × 12, 4)
            .如果真 (dwHotKeyId ＝ wParam)
                WndProc ＝ __get (pHotKeyInfo ＋ (i － 1) × 12, 8)
                跳出循环 ()
            .如果真结束
            
        .计次循环尾 ()
    .如果真结束
    返回 (CallWindowProcA (WndProc, hwnd, message, wParam, lParam))

.子程序 窗口_热键卸载所有, , 公开, 卸载所有热键
    .参数 窗口句柄, 整数型, , 目标窗口句柄
    .局部变量 pHotKeyList, 整数型
    .局部变量 dwCount, 整数型
    .局部变量 WndProc, 整数型
    .局部变量 pHotKeyInfo, 整数型
    .局部变量 dwHotKeyId, 整数型
    .局部变量 i, 整数型

    pHotKeyList ＝ GetPropA (窗口句柄, “HOTKEYLIST”)
    .如果真 (pHotKeyList ≠ #NULL)
        dwCount ＝ __get (pHotKeyList, 0)
        WndProc ＝ __get (pHotKeyList, 4)
        .如果真 (WndProc ≠ #NULL)
            SetWindowLongA (窗口句柄, #GWL_WNDPROC, WndProc)
        .如果真结束
        pHotKeyInfo ＝ __get (pHotKeyList, 8)
        .如果真 (pHotKeyInfo ≠ #NULL)
            .计次循环首 (dwCount, i)
                dwHotKeyId ＝ __get (pHotKeyInfo, (i － 1) × 12 ＋ 4)
                UnregisterHotKey (窗口句柄, dwHotKeyId)
            .计次循环尾 ()
            LocalFree (pHotKeyInfo)
        .如果真结束
        RemovePropA (窗口句柄, “HOTKEYLIST”)
    .如果真结束
    

.子程序 窗口_渐隐渐现, , 公开, 让你的窗口渐隐或渐现；
    .参数 窗口句柄, 整数型, , 要设置渐隐渐现的窗口句柄；
    .参数 操作类型, 整数型, 可空, 可空，默认为渐隐；0=渐隐，1=渐现；
    .参数 渐隐渐现速度, 整数型, 可空, 可空，默认为3；1-10,越小超快；
    .参数 渐隐后操作, 整数型, 可空, 可空，默认为0，结束进程；1=关闭窗口，2=隐藏窗口
    .局部变量 局_进程ID, 整数型
    .局部变量 i, 整数型

    .如果真 (渐隐渐现速度 ＝ 0)
        渐隐渐现速度 ＝ 3
    .如果真结束
    
    .如果 (操作类型 ＝ 1)
        .计次循环首 (255, i)
            窗口_置透明度 (窗口句柄, i, , )
            延时 (渐隐渐现速度)
            处理事件 ()
        .计次循环尾 ()
    .否则
        
        .计次循环首 (255, i)
            窗口_置透明度 (窗口句柄, 255 － i, , )
            延时 (渐隐渐现速度)
            处理事件 ()
        .计次循环尾 ()
        
        .判断开始 (渐隐后操作 ＝ 1)
            窗口_关闭 (窗口句柄)
        .判断 (渐隐后操作 ＝ 2)
            窗口_显示隐藏 (窗口句柄, 假)
        .默认
            局_进程ID ＝ 窗口_取祖句柄 (窗口句柄)
            局_进程ID ＝ 窗口_句柄取进程ID (局_进程ID)
            进程_结束 (局_进程ID)
        .判断结束
        
    .如果结束
    

.子程序 窗口_是否有子窗口, 逻辑型, 公开, 判断某个窗口下是否有子级窗口控件;
    .参数 窗口句柄, 整数型, , 目标窗口句柄

    返回 (选择 (窗口_取句柄 (窗口句柄) ＝ 0, 假, 真))

.子程序 窗口_控件加边框, , 公开, 在控件的边上加上一层边框;
    .参数 控件句柄, 整数型, 可空, 要加边框的控件句柄;
    .参数 鼠标被放开, 逻辑型, 可空, 在图片框鼠标被放开的时候把这个参数设置为真,控件句柄留空;
    .局部变量 局_矩形, 精易_矩形
    .局部变量 局_场景, 整数型
    .局部变量 局_窗口句柄, 整数型, 静态
    .局部变量 局_画框, 逻辑型, 静态

    局_场景 ＝ CreateDCA (“DISPLAY”, “”, “”, 0)
    .如果真 (鼠标被放开)
        .如果真 (局_画框 ＝ 假)
            返回 ()
        .如果真结束
        局_画框 ＝ 真
        GetWindowRect (局_窗口句柄, 局_矩形)
        子程序_画边框 (局_场景, 局_矩形)
        局_画框 ＝ 取反 (局_画框)
        DeleteDC (局_场景)
    .如果真结束
    .判断开始 (局_窗口句柄 ≠ 控件句柄)
        .如果真 (局_画框)
            GetWindowRect (局_窗口句柄, 局_矩形)
            子程序_画边框 (局_场景, 局_矩形)
            局_画框 ＝ 假
        .如果真结束
        GetWindowRect (控件句柄, 局_矩形)
        子程序_画边框 (局_场景, 局_矩形)
        DeleteDC (局_场景)
        局_窗口句柄 ＝ 控件句柄
        局_画框 ＝ 真
    .默认
        GetWindowRect (局_窗口句柄, 局_矩形)
        子程序_画边框 (局_场景, 局_矩形)
        局_画框 ＝ 取反 (局_画框)
        DeleteDC (局_场景)
    .判断结束
    

.子程序 窗口_画矩形, , 公开, 本函数为微凉提供
    .参数 窗口句柄, 整数型, , 要画矩形的窗口的句柄
    .参数 矩形粗细, 整数型, 可空, 默认为3
    .参数 矩形颜色, 整数型, 可空, 默认为红色
    .参数 是否闪烁, 逻辑型, 可空
    .局部变量 窗口矩形A, 精易_矩形
    .局部变量 屏幕句柄A, 整数型
    .局部变量 屏幕场景A, 整数型
    .局部变量 旧混合模式A, 整数型
    .局部变量 新画笔A, 整数型
    .局部变量 旧画笔A, 整数型

    .如果真 (矩形粗细 ＝ 0)
        矩形粗细 ＝ 3
    .如果真结束
    .如果真 (矩形颜色 ＝ 0)
        矩形颜色 ＝ #红色
    .如果真结束
    屏幕句柄A ＝ GetDesktopWindow () ' 取得桌面句柄
    屏幕场景A ＝ GetWindowDC (屏幕句柄A) ' 取得桌面设备场景
    旧混合模式A ＝ SetROP2 (屏幕场景A, 10) ' 10:R2_NOTXORPEN
    GetWindowRect (窗口句柄, 窗口矩形A) ' 获得窗口矩形
    .如果真 (窗口矩形A.左边 ＜ 0)
        窗口矩形A.左边 ＝ 0
    .如果真结束
    .如果真 (窗口矩形A.顶边 ＜ 0)
        窗口矩形A.顶边 ＝ 0
    .如果真结束
    新画笔A ＝ CreatePen (0, 矩形粗细, 矩形颜色) ' 建立新画笔,载入DeskDC。取颜色值 (237, 15, 40)
    旧画笔A ＝ SelectObject (屏幕场景A, 新画笔A)
    Rectangle (屏幕场景A, 窗口矩形A.左边, 窗口矩形A.顶边, 窗口矩形A.右边, 窗口矩形A.底边) ' 在窗口周围画矩形
    .如果真 (是否闪烁 ＝ 真)
        程序_延时 (100) ' 刷新时间
        Rectangle (屏幕场景A, 窗口矩形A.左边, 窗口矩形A.顶边, 窗口矩形A.右边, 窗口矩形A.底边) ' 刷新画矩形
        SetROP2 (屏幕场景A, 旧混合模式A)
    .如果真结束
    SelectObject (屏幕场景A, 旧画笔A)
    DeleteObject (新画笔A)
    ReleaseDC (屏幕句柄A, 屏幕场景A)

.子程序 子程序_画边框
    .参数 场景, 整数型
    .参数 矩形边框, 精易_矩形

    .如果真 (lpRect (矩形边框) ＝ 0)
        PatBlt (场景, 矩形边框.左边, 矩形边框.顶边, 矩形边框.右边 － 矩形边框.左边, 3, 5570569)
        PatBlt (场景, 矩形边框.左边, 矩形边框.顶边 ＋ 3, 3, 矩形边框.底边 － 矩形边框.顶边 － 6, 5570569)
        PatBlt (场景, 矩形边框.右边, 矩形边框.顶边 ＋ 3, -3, 矩形边框.底边 － 矩形边框.顶边 － 6, 5570569)
        PatBlt (场景, 矩形边框.左边, 矩形边框.底边, 矩形边框.右边 － 矩形边框.左边, -3, 5570569)
    .如果真结束
    

.子程序 窗口_取点标题, 文本型, 公开, 取出指定坐标的组件上的文字内容或标题(返回文字内容)
    .参数 水平位置, 整数型, 可空, (可空为鼠标当前坐标x)   文字所在的x坐标“X轴光标”
    .参数 垂直位置, 整数型, 可空, (可空为鼠标当前坐标y)   文字所以的y坐标“Y轴光标”
    .局部变量 文本内容, 文本型
    .局部变量 坐标变量, 精易_坐标

    .如果真 (水平位置 ＝ 0 或 垂直位置 ＝ 0)
        坐标变量 ＝ 鼠标_取位置 ()
        水平位置 ＝ 坐标变量.横
        垂直位置 ＝ 坐标变量.纵
    .如果真结束
    文本内容 ＝ 取空白文本 (256)
    SendMessageA (WindowFromPoint (水平位置, 垂直位置), 13, 256, 取指针文本_ (文本内容))
    返回 (文本内容)

.子程序 窗口_取桌面句柄, 整数型, 公开, 返回一个桌面的句柄
    返回 (FindWindowA (“Progman”, “Program Manager”))

.子程序 窗口_取坐标距离, 整数型, 公开, 返回两坐标点之间的距离
    .参数 坐标1, 精易_坐标, , 起始坐标
    .参数 坐标2, 精易_坐标, , 终点坐标

    返回 (取绝对值 (求平方根 (求次方 (坐标1.横 － 坐标2.横, 2) ＋ 求次方 (坐标1.纵 － 坐标2.纵, 2))))

.子程序 窗口_取控件大小, 逻辑型, 公开, 获取一个控件的大小（宽度和高度）
    .参数 窗口句柄, 整数型, , 欲获取一个控件大小窗口句柄
    .参数 窗口的宽度, 整数型, 参考 可空, 用来存放取回来的窗口宽度
    .参数 窗口的高度, 整数型, 参考 可空, 用来存放取回来的窗口高度
    .局部变量 矩形区域, 精易_矩形
    .局部变量 是否成功, 逻辑型

    是否成功 ＝ GetClientRect (窗口句柄, 矩形区域)
    窗口的宽度 ＝ 矩形区域.右边 － 矩形区域.左边
    窗口的高度 ＝ 矩形区域.底边 － 矩形区域.顶边
    返回 (是否成功)

.子程序 窗口_取焦点句柄, 整数型, 公开, 取焦点句柄;获得自身拥有输入焦点的窗口句柄
    .局部变量 局_前台窗口
    .局部变量 局_当前线程
    .局部变量 局_目标线程
    .局部变量 局_返回值

    局_前台窗口 ＝ GetForegroundWindow ()
    局_当前线程 ＝ GetCurrentThreadId ()
    局_目标线程 ＝ GetWindowThreadProcessId (局_前台窗口, 0)
    .如果 (局_当前线程 ＝ 局_目标线程)
        局_返回值 ＝ GetFocus ()
    .否则
        AttachThreadInput (局_目标线程, 局_当前线程, 真)
        局_返回值 ＝ GetFocus ()
        AttachThreadInput (局_目标线程, 局_当前线程, 假)
    .如果结束
    返回 (局_返回值)

.子程序 窗口_取屏幕句柄, 整数型, 公开, 获取屏幕的句柄
    返回 (GetDesktopWindow ())

.子程序 窗口_是否最小化, 逻辑型, 公开, 已最小化返回真；否则返回假
    .参数 窗口句柄, 整数型, , 要判断的窗口句柄

    返回 (IsIconic (窗口句柄))

.子程序 窗口_是否最大化, 逻辑型, 公开, 已最大化返回真；否则返回假
    .参数 窗口句柄, 整数型, , 要判断的窗口句柄

    返回 (IsZoomed (窗口句柄))

.子程序 窗口_取控件内容, 文本型, 公开, 取指定窗口的标题。成功返回窗口标题，失败返回空。
    .参数 控件句柄, 整数型, , 指定的控件句柄
    .局部变量 控件内容, 文本型
    .局部变量 总字符数, 整数型
    .局部变量 临时整数, 整数型

    总字符数 ＝ SendMessageA (控件句柄, 14, 0, 0) ＋ 1
    .如果 (总字符数 ＞ 50000)
        临时整数 ＝ 50000
        控件内容 ＝ 取空白文本 (临时整数)
        SendMessageA (控件句柄, 13, 临时整数 ＋ 1, lstrcpynA_文本 (控件内容, 控件内容, 0))
        .如果真 (取代码 (取文本右边 (控件内容, 1), ) ＜ 0)
            控件内容 ＝ 取文本左边 (控件内容, 取文本长度 (控件内容) － 1)
        .如果真结束
        控件内容 ＝ 控件内容 ＋ “...后面略掉” ＋ 到文本 (总字符数 － 临时整数) ＋ “个字符...”
    .否则
        控件内容 ＝ 取空白文本 (总字符数)
        SendMessageA (控件句柄, 13, 总字符数, lstrcpynA_文本 (控件内容, 控件内容, 0))
    .如果结束
    返回 (控件内容)

.子程序 窗口_置控件内容, , 公开, 往指定的编辑框内置指定的内容。
    .参数 控件句柄, 整数型, , 指定的编辑框控件句柄
    .参数 欲写入的内容, 文本型, , 欲写入目标编辑框的文本

    SendMessageA (控件句柄, 12, 0, 取指针文本_ (欲写入的内容))

.子程序 窗口_置控件状态, 逻辑型, 公开, 隐藏或显示控件；成功返回真；失败返回假
    .参数 窗口句柄, 整数型, , 欲操作的控件句柄
    .参数 显示隐藏, 逻辑型, , 真 = 显示；假 = 隐藏

    返回 (ShowScrollBar (窗口句柄, 2, 显示隐藏))

.子程序 窗口_置控件焦点, 逻辑型, 公开, 该函数对指定的窗口设置键盘焦点。 成功返回真，失败返回假；
    .参数 控件句柄, 整数型, , 目标控件句柄
    .局部变量 局_当前线程ID
    .局部变量 局_目标线程ID
    .局部变量 局_返回值, 逻辑型

    局_当前线程ID ＝ GetCurrentThreadId ()
    局_目标线程ID ＝ GetWindowThreadProcessId (控件句柄, 0)
    AttachThreadInput (局_目标线程ID, 局_当前线程ID, 真)
    局_返回值 ＝ SetFocus (控件句柄)
    AttachThreadInput (局_目标线程ID, 局_当前线程ID, 假)
    返回 (局_返回值)

.子程序 窗口_更换鼠标指针, , 公开, 修改窗口的鼠标指针
    .参数 参_窗口句柄, 整数型, , 窗口句柄
    .参数 参_光标路径, 文本型, 可空, 后缀名为:ani\cur的鼠标指针文件路径
    .参数 参_光标指针, 整数型, 可空, #鼠标指针_
    .局部变量 局_子窗口数组, 整数型, , "0"
    .局部变量 局_计次, 整数型
    .局部变量 局_指针句柄, 整数型

    ' https://bbs.125.la/thread-14501745-1-1.html
    
    .如果 (是否为空 (参_光标路径) ＝ 假 且 参_光标路径 ≠ “”)
        局_指针句柄 ＝ LoadCursorFromFileA (参_光标路径)
    .否则
        局_指针句柄 ＝ LoadCursorW (0, 参_光标指针)
    .如果结束
    窗口_枚举所有子窗口 (参_窗口句柄, 局_子窗口数组, )
    .计次循环首 (取数组成员数 (局_子窗口数组), 局_计次)
        SetClassLongA (局_子窗口数组 [局_计次], -12, 局_指针句柄)
    .计次循环尾 ()
    SetClassLongA (参_窗口句柄, -12, 局_指针句柄)

.子程序 窗口_枚举, 整数型, 公开, 枚举所有窗口,返回窗口句柄数目,失败返回0 
    .参数 窗口信息, 精易_窗口信息, 参考 可空 数组, 返回的窗口信息数组

    清除数组 (窗口信息)
    EnumWindows (&枚举窗口过程, 取指针_通用型_数组 (窗口信息))
    返回 (取数组成员数 (窗口信息))

.子程序 窗口_枚举接口, , 公开, 枚举全部窗口的接口
    .参数 回调函数, 子程序指针, , 回调子程序，返回值：整数型，直接返回1即可，共1个参数：窗口句柄[整数型]

    EnumWindows (回调函数, 0)

.子程序 枚举窗口过程
    .参数 窗口句柄, 整数型
    .参数 lParam, 整数型
    .局部变量 局_进程信息, 精易_窗口信息, , "0"
    .局部变量 dwLen, 整数型
    .局部变量 pAddr, 整数型

    pAddr ＝ 指针转移 (lParam, 取指针_通用型_数组 (局_进程信息))
    dwLen ＝ 取数组成员数 (局_进程信息) ＋ 1
    重定义数组 (局_进程信息, 真, dwLen)
    
    局_进程信息 [dwLen].窗口句柄 ＝ 窗口句柄
    局_进程信息 [dwLen].进程ID ＝ 窗口_句柄取进程ID (窗口句柄)
    局_进程信息 [dwLen].线程ID ＝ 窗口_句柄取线程ID (窗口句柄)
    局_进程信息 [dwLen].窗口标题 ＝ 窗口_取标题 (窗口句柄)
    局_进程信息 [dwLen].窗口类名 ＝ 窗口_取类名 (窗口句柄)
    指针还原 (lParam, 取指针_通用型_数组 (局_进程信息), pAddr)
    

.子程序 窗口_枚举子窗口, 整数型, 公开, 枚举指定句柄的下一级子窗口,返回子窗口句柄数目,失败或无子返回0
    .参数 父窗口句柄, 整数型, 可空, 指定父窗口句柄  可空:为桌面.找顶级窗口
    .参数 子窗口数组, 整数型, 参考 数组, 返回的所有符合条件的子窗口句柄
    .参数 类名, 文本型, 可空, 指定子窗口类名
    .局部变量 临时, 整数型

    清除数组 (子窗口数组)
    临时 ＝ FindWindowExA (父窗口句柄, 0, 取指针文本_ (类名), 0)
    .判断循环首 (临时 ≠ 0)
        加入成员 (子窗口数组, 临时)
        临时 ＝ FindWindowExA (父窗口句柄, 临时, 取指针文本_ (类名), 0)
    .判断循环尾 ()
    返回 (取数组成员数 (子窗口数组))

.子程序 窗口_模糊遍历窗口, 整数型, 公开, 返回满足条件的第一个窗口的句柄
    .参数 父窗口句柄, 整数型, 可空, 为空，则为桌面句柄
    .参数 要找的窗口类名, 文本型, 可空
    .参数 要找的窗口标题, 文本型, 可空
    .参数 结果句柄数组, 整数型, 参考 可空 数组, 如果指定数组，则遍历所有满足条件的子窗口，并将所有句柄写入该数组中。
    .局部变量 窗口句柄, 整数型
    .局部变量 是否合法, 逻辑型
    .局部变量 ClassName, 文本型
    .局部变量 TitleName, 文本型

    清除数组 (结果句柄数组)
    .如果真 (是否为空 (父窗口句柄))
        父窗口句柄 ＝ GetDesktopWindow ()
    .如果真结束
    窗口句柄 ＝ GetWindow (父窗口句柄, 5)
    .判断循环首 (窗口句柄 ≠ 0)
        是否合法 ＝ 真
        .如果真 (要找的窗口类名 ≠ “”)
            ClassName ＝ 窗口_取类名 (窗口句柄)
            .如果真 (寻找文本 (到小写 (ClassName), 到小写 (要找的窗口类名), , 假) ＝ -1)
                是否合法 ＝ 假
            .如果真结束
            处理事件 ()
        .如果真结束
        .如果真 (要找的窗口标题 ≠ “”)
            TitleName ＝ 窗口_取标题 (窗口句柄)
            .如果真 (寻找文本 (到小写 (TitleName), 到小写 (要找的窗口标题), 1, 假) ＝ -1)
                是否合法 ＝ 假
            .如果真结束
            处理事件 ()
        .如果真结束
        .如果真 (是否合法)
            .如果真 (是否为空 (结果句柄数组))
                返回 (窗口句柄)
            .如果真结束
            加入成员 (结果句柄数组, 窗口句柄)
        .如果真结束
        窗口句柄 ＝ GetWindow (窗口句柄, 2)
    .判断循环尾 ()
    .如果真 (取数组成员数 (结果句柄数组) ＞ 0)
        返回 (结果句柄数组 [1])
    .如果真结束
    返回 (0)

.子程序 窗口_枚举所有子窗口, 整数型, 公开, 枚举指定句柄下的所有子窗口句柄,返回子窗口句柄数目,失败或无子返回0
    .参数 父窗口句柄, 整数型, 可空, 当为空时相当于EnumWindows
    .参数 子窗口数组, 整数型, 数组, 变量储存返回值。
    .参数 类名, 文本型, 可空, 要过滤的窗口类名。
    .局部变量 pMem, 整数型
    .局部变量 dwLen, 整数型
    .局部变量 数组成员数, 整数型
    .局部变量 i, 整数型
    .局部变量 数组指针, 整数型

    清除数组 (子窗口数组)
    类名 ＝ 选择 (取文本长度 (删首尾空 (类名)) ＞ 0, 类名, “”)
    pMem ＝ LocalAlloc (#LMEM_ZEROINIT, 20) ' 申请8自己内存,记录两个参数
    __set (pMem, 0, 0) ' 直接把参数的数组指针写进去
    __set (pMem, 4, 取指针_文本型 (类名)) ' 把类名写进去
    __set (pMem, 8, LocalAlloc (#LMEM_ZEROINIT, 400))
    __set (pMem, 12, 400)
    EnumChildWindows (父窗口句柄, &EnumChildProc, pMem) ' 把内存地址传递进去
    
    
    数组成员数 ＝ __get (pMem, 0)
    数组指针 ＝ __get (pMem, 8)
    
    重定义数组 (子窗口数组, 假, 数组成员数)
    
    .计次循环首 (数组成员数, i)
        子窗口数组 [i] ＝ __get (数组指针, (i － 1) × 4)
    .计次循环尾 ()
    LocalFree (数组指针)
    LocalFree (pMem) ' 有申请就要有释放,不然就内存泄漏了
    返回 (数组成员数)

.子程序 EnumChildProc, 逻辑型
    .参数 hWnd, 整数型
    .参数 lParam, 整数型, , +0 数组栈地址,+4类名指针
    .局部变量 className, 文本型
    .局部变量 szStr, 文本型
    .局部变量 成员数, 整数型
    .局部变量 pTmp, 整数型
    .局部变量 结果数组, 整数型
    .局部变量 缓冲区长度, 整数型
    .局部变量 临时_内存, 整数型

    .如果真 (hWnd ≠ 0)
        className ＝ 窗口_取类名 (hWnd)
        ' 0 = 数组的成员数
        ' 4 = 类名
        ' 8 = 存放结果的数组
        ' 12 = 数组的长度
        .如果真 (LocalSize (lParam) ＝ 20) ' 上面申请的是8个字节
            成员数 ＝ __get (lParam, 0) ' 数组栈地址
            pTmp ＝ __get (lParam, 4)
            .如果真 (pTmp ≠ 0)
                szStr ＝ 指针到文本 (pTmp)
            .如果真结束
            
            结果数组 ＝ __get (lParam, 8)
            缓冲区长度 ＝ __get (lParam, 12)
            
            .如果真 (取文本长度 (szStr) ＞ 0 且 到小写 (szStr) ≠ 到小写 (className))
                返回 (真)
            .如果真结束
            
            .如果真 (成员数 × 4 ＋ 4 ＞ 缓冲区长度)
                缓冲区长度 ＝ 缓冲区长度 × 2
                临时_内存 ＝ LocalAlloc (#LMEM_ZEROINIT, 缓冲区长度)
                RtlMoveMemory (临时_内存, 结果数组, 缓冲区长度 ÷ 2)
                LocalFree (结果数组)
                __set (lParam, 8, 临时_内存)
                __set (lParam, 12, 缓冲区长度)
                结果数组 ＝ 临时_内存
            .如果真结束
            
            __set (lParam, 0, 成员数 ＋ 1)
            __set (结果数组, 成员数 × 4, hWnd)
            
            返回 (真)
        .如果真结束
        
    .如果真结束
    返回 (假)

.子程序 窗口_是否子窗口, 逻辑型, 公开, 判断一个窗口和另一窗口是否为父子关系
    .参数 父窗口的句柄, 整数型, , 父窗口的句柄
    .参数 欲判断的窗口句柄, 整数型, , 欲判断的窗口句柄

    返回 (IsChild (父窗口的句柄, 欲判断的窗口句柄))

.子程序 窗口_句柄是否有效, 逻辑型, 公开, 有效返回真；不存在返回假；
    .参数 窗口句柄, 整数型, , 目标窗口句柄

    返回 (IsWindow (窗口句柄) ≠ 0)

.子程序 窗口_是否在最顶端, 逻辑型, 公开, 判断指定窗口是否在最前面；如果是返回真,否则返回假；
    .参数 进程名, 文本型, 可空, 欲判断窗口的程序进程名(注意区分大小写)
    .参数 窗口类名, 文本型, 可空, 欲判断窗口的类名(注意区分大小写)
    .参数 窗口标题, 文本型, 可空, 欲判断窗口的标题关键字
    .局部变量 当前窗口, 整数型

    当前窗口 ＝ GetForegroundWindow ()
    .如果真 (进程名 ＝ “” 且 窗口类名 ＝ “” 且 窗口标题 ＝ “”)
        输出调试文本 (“真想把你拉出去切了,一个条件都不给让我取什么?”)
        返回 (假)
    .如果真结束
    .如果真 (进程名 ≠ “”)
        .如果真 (窗口_句柄取进程名 (当前窗口) ≠ 进程名)
            返回 (假)
        .如果真结束
        
    .如果真结束
    .如果真 (窗口类名 ≠ “”)
        .如果真 (窗口_取类名 (当前窗口) ≠ 窗口类名)
            返回 (假)
        .如果真结束
        
    .如果真结束
    .如果真 (窗口标题 ≠ “”)
        .如果真 (寻找文本 (窗口_取标题 (当前窗口), 窗口标题, , 假) ＝ -1)
            返回 (假)
        .如果真结束
        
    .如果真结束
    返回 (真)
    

.子程序 窗口_是否置顶, 逻辑型, 公开, 判断指定窗口的是否在最前面；如果是返回真,否则返回假；
    .参数 句柄, 整数型, , 欲判断窗口句柄
    .局部变量 信息, 整数型

    信息 ＝ GetWindowLongA (句柄, #GWL_EXSTYLE)
    返回 (位与 (信息, #WS_EX_TOPMOST) ＝ #WS_EX_TOPMOST)

.子程序 窗口_是否禁止, 逻辑型, 公开, 判断指定窗口的是否被禁止；如果是返回真,否则返回假；
    .参数 窗口句柄, 整数型, , 欲判断窗口句柄

    返回 (IsWindowEnabled (窗口句柄) ＝ 0) ' 此API判断禁止了就返回假，没有禁止返回真，所以取反，方便理解
    

.子程序 窗口_取位置和大小, 精易_位置和大小, 公开, 取指定窗口的左边、顶边、宽度、高度
    .参数 窗口句柄, 整数型, , 欲取大小的窗口句柄
    .参数 检索恢复时的位置, 逻辑型, 可空
    .局部变量 rcWindow, 精易_矩形
    .局部变量 rcPos, 精易_位置和大小
    .局部变量 lpwndpl, 整数型

    .如果 (检索恢复时的位置)
        lpwndpl ＝ LocalAlloc (#LMEM_ZEROINIT, 44) ' sizeof(WINDOWPLACEMENT)
        .如果真 (lpwndpl ≠ #NULL)
            .如果真 (GetWindowPlacement (窗口句柄, lpwndpl))
                rcPos.左边 ＝ __get (lpwndpl, 28)
                rcPos.顶边 ＝ __get (lpwndpl, 32)
                rcPos.宽度 ＝ __get (lpwndpl, 36) － rcPos.左边
                rcPos.高度 ＝ __get (lpwndpl, 40) － rcPos.顶边
            .如果真结束
            LocalFree (lpwndpl)
        .如果真结束
        
    .否则
        GetWindowRect (窗口句柄, rcWindow)
        rcPos.左边 ＝ rcWindow.左边
        rcPos.顶边 ＝ rcWindow.顶边
        rcPos.宽度 ＝ rcWindow.右边 － rcWindow.左边
        rcPos.高度 ＝ rcWindow.底边 － rcWindow.顶边
    .如果结束
    返回 (rcPos)

.子程序 窗口_置位置和大小, 逻辑型, 公开, 修改窗口的位置和大小
    .参数 窗口句柄, 整数型, , 欲改变位置和大小的窗口句柄
    .参数 左边位置, 整数型, 可空, 窗口新的左边位置，留空不变；
    .参数 顶边位置, 整数型, 可空, 窗口新的顶边位置，留空不变；
    .参数 新宽度, 整数型, 可空, 窗口的新宽度，留空不变；
    .参数 新高度, 整数型, 可空, 窗口的新高度，留空不变；
    .局部变量 位置大小, 精易_矩形

    GetWindowRect (窗口句柄, 位置大小)
    .如果真 (是否为空 (左边位置))
        左边位置 ＝ 位置大小.左边
    .如果真结束
    .如果真 (是否为空 (顶边位置))
        顶边位置 ＝ 位置大小.顶边
    .如果真结束
    .如果真 (是否为空 (新宽度))
        新宽度 ＝ 位置大小.右边 － 位置大小.左边
    .如果真结束
    .如果真 (是否为空 (新高度))
        新高度 ＝ 位置大小.底边 － 位置大小.顶边
    .如果真结束
    返回 (MoveWindow (窗口句柄, 左边位置, 顶边位置, 新宽度, 新高度, 真))

.子程序 窗口_取坐标子句柄, 整数型, 公开, 取父窗口中包含了指定坐标的第一个子窗口句柄(与其它取窗口句柄不同的是:可取出不可视或透明的窗口)
    .参数 父窗口句柄, 整数型, , 欲取坐标句柄所在的父窗口句柄
    .参数 横坐标, 整数型, , 指定横坐标
    .参数 纵坐标, 整数型, , 指定纵坐标

    返回 (ChildWindowFromPoint (父窗口句柄, 横坐标, 纵坐标))

.子程序 窗口_句柄取进程名, 文本型, 公开, 用指定的窗口句柄取回对应的进程名；成功返回进程名,失败返回空文本；
    .参数 窗口句柄, 整数型, , 要取进程名的窗口句柄；
    .局部变量 窗口进程ID, 整数型

    GetWindowThreadProcessId (窗口句柄, 窗口进程ID)
    返回 (进程_ID取进程名 (窗口进程ID))

.子程序 窗口_句柄取线程ID, 整数型, 公开, 成功返回指定窗口的线程ID
    .参数 窗口句柄, 整数型, , 指定窗口句柄
    .局部变量 进程ID, 整数型, , , 用于装载进程ID的变量

    返回 (GetWindowThreadProcessId (窗口句柄, 进程ID))

.子程序 窗口_句柄取进程ID, 整数型, 公开, 返回进程ID；
    .参数 窗口句柄, 整数型, , 目标窗口句柄
    .局部变量 dwProcessId, 整数型, , , 用于装载进程ID的变量

    GetWindowThreadProcessId (窗口句柄, dwProcessId)
    返回 (dwProcessId)

.子程序 窗口_取任务栏句柄, 整数型, 公开, 取任务栏句柄
    返回 (FindWindowA (“Shell_TrayWnd”, 字符 (0)))

.子程序 窗口_取IE浏览框句柄, 整数型, 公开, 取IE浏览器中某个浏览框的句柄
    .参数 IEFrame句柄, 整数型, , IE浏览器中,类名为“IEFrame”的窗口句柄
    .局部变量 窗口类名, 文本型
    .局部变量 局_窗口句柄, 整数型
    .局部变量 x

    局_窗口句柄 ＝ FindWindowExA (IEFrame句柄, 0, 0, 0)
    .判断循环首 (局_窗口句柄 ≠ 0)
        窗口类名 ＝ 窗口_取类名 (局_窗口句柄)
        .如果真 (窗口类名 ＝ “Internet Explorer_Server”)
            返回 (局_窗口句柄)
        .如果真结束
        x ＝ 窗口_取IE浏览框句柄 (局_窗口句柄)
        .如果真 (x ≠ 0)
            返回 (x)
        .如果真结束
        局_窗口句柄 ＝ FindWindowExA (IEFrame句柄, 局_窗口句柄, 0, 0)
        系统_处理事件 ()
    .判断循环尾 ()
    返回 (0)

.子程序 窗口_取坐标处颜色, 整数型, 公开, 返回指定窗口指定坐标处颜色值；十进制
    .参数 窗口句柄, 整数型, 可空, 留空则取屏幕句柄；
    .参数 横坐标, 整数型, 可空, 留空则取鼠标处所在横坐标；
    .参数 纵坐标, 整数型, 可空, 留空则取鼠标处所在纵坐标；
    .局部变量 屏幕坐标, 精易_坐标
    .局部变量 矩形, 精易_位置和大小
    .局部变量 局_设备句柄
    .局部变量 局_像素值

    .如果 (窗口句柄 ＞ 0)
        .如果 (横坐标 ＝ 0 且 纵坐标 ＝ 0)
            屏幕坐标 ＝ 鼠标_取位置 ()
            矩形 ＝ 窗口_取位置和大小 (窗口句柄)
            横坐标 ＝ 屏幕坐标.横 － 矩形.左边
            纵坐标 ＝ 屏幕坐标.纵 － 矩形.顶边
        .否则
            矩形 ＝ 窗口_取位置和大小 (窗口句柄)
            横坐标 ＝ 横坐标 ＋ 矩形.左边
            纵坐标 ＝ 纵坐标 ＋ 矩形.顶边
        .如果结束
        局_设备句柄 ＝ GetDC (0)
        局_像素值 ＝ GetPixel (局_设备句柄, 横坐标, 纵坐标)
        ReleaseDC (0, 局_设备句柄)
        返回 (局_像素值)
    .否则
        .如果 (横坐标 ＝ 0 且 纵坐标 ＝ 0)
            屏幕坐标 ＝ 鼠标_取位置 ()
            局_设备句柄 ＝ GetDC (0)
            局_像素值 ＝ GetPixel (局_设备句柄, 屏幕坐标.横, 屏幕坐标.纵)
            ReleaseDC (0, 局_设备句柄)
            返回 (局_像素值)
        .否则
            局_设备句柄 ＝ GetDC (0)
            局_像素值 ＝ GetPixel (局_设备句柄, 横坐标, 纵坐标)
            ReleaseDC (0, 局_设备句柄)
            返回 (局_像素值)
        .如果结束
        
    .如果结束
    
    返回 (0)

.子程序 窗口_屏蔽浏览器右键, 逻辑型, 公开, 注：只能屏蔽自身程序的浏览器；外部无效；请把该命令放在浏览器"已就绪"事件下；
    .参数 浏览器句柄, 整数型, , 浏览器句柄
    .参数 菜单回调子程序, 子程序指针, 可空, 留空为不弹菜单；
    .局部变量 hWnd, 整数型
    .局部变量 WndProc, 整数型

    hWnd ＝ 窗口_取IE浏览框句柄 (浏览器句柄)
    .如果真 (hWnd ＝ 0)
        输出调试文本 (“浏览器句柄无效！”)
        返回 (假)
    .如果真结束
    
    WndProc ＝ GetPropA (hWnd, “GWL_WNDPROC”)
    .如果真 (WndProc ≠ 0)
        SetWindowLongA (hWnd, #GWL_WNDPROC, WndProc)
        RemovePropA (hWnd, “GWL_WNDPROC”)
        RemovePropA (hWnd, “lProc”)
    .如果真结束
    
    SetPropA (hWnd, “lProc”, 到整数 (菜单回调子程序))
    WndProc ＝ SetWindowLongA (hWnd, #GWL_WNDPROC, 到整数 (&浏览器屏蔽右键消息处理))
    SetPropA (hWnd, “GWL_WNDPROC”, WndProc)
    返回 (真)

.子程序 浏览器屏蔽右键消息处理, 整数型
    .参数 hWnd, 整数型
    .参数 Msg, 整数型
    .参数 wParam, 整数型
    .参数 lParam, 整数型
    .局部变量 WndProc, 整数型

    .如果真 (Msg ＝ #WM_DESTROY)
        RemovePropA (hWnd, “GWL_WNDPROC”)
        RemovePropA (hWnd, “lProc”)
    .如果真结束
    .判断开始 (Msg ＝ #WM_RBUTTONDOWN 或 Msg ＝ #WM_RBUTTONUP 或 Msg ＝ #WM_RBUTTONDBLCLK)
        WndProc ＝ GetPropA (hWnd, “lProc”)
        返回 (CallWindowProcA (WndProc, 0, 0, 0, 0))
    .默认
        WndProc ＝ GetPropA (hWnd, “GWL_WNDPROC”)
        返回 (CallWindowProcA (WndProc, hWnd, Msg, wParam, lParam))
    .判断结束
    

.子程序 窗口_屏蔽编辑框右键, 逻辑型, 公开, 注：只能屏蔽自身程序的编辑框；外部无效；
    .参数 编辑框句柄, 整数型, , 编辑框句柄
    .参数 菜单回调子程序, 子程序指针, 可空, 留空为不弹菜单；
    .局部变量 WndProc, 整数型

    .如果真 (IsWindow (编辑框句柄) ≠ 1)
        输出调试文本 (“编辑框句柄无效！”)
        返回 (假)
    .如果真结束
    
    WndProc ＝ GetPropA (编辑框句柄, “GWL_WNDPROC”)
    .如果真 (WndProc ≠ 0)
        SetWindowLongA (编辑框句柄, #GWL_WNDPROC, WndProc)
        RemovePropA (编辑框句柄, “GWL_WNDPROC”)
        RemovePropA (编辑框句柄, “lProc”)
    .如果真结束
    
    SetPropA (编辑框句柄, “lProc”, 到整数 (菜单回调子程序))
    WndProc ＝ SetWindowLongA (编辑框句柄, #GWL_WNDPROC, 到整数 (&编辑框屏蔽右键消息处理))
    SetPropA (编辑框句柄, “GWL_WNDPROC”, WndProc)
    返回 (真)

.子程序 编辑框屏蔽右键消息处理, 整数型
    .参数 hWnd, 整数型
    .参数 Msg, 整数型
    .参数 wParam, 整数型
    .参数 lParam, 整数型
    .局部变量 WndProc, 整数型

    .如果真 (Msg ＝ #WM_DESTROY)
        RemovePropA (hWnd, “GWL_WNDPROC”)
        RemovePropA (hWnd, “lProc”)
    .如果真结束
    .判断开始 (Msg ＝ #WM_RBUTTONDOWN 或 Msg ＝ #WM_RBUTTONUP 或 Msg ＝ #WM_RBUTTONDBLCLK)
        WndProc ＝ GetPropA (hWnd, “lProc”)
        返回 (CallWindowProcA (WndProc, 0, 0, 0, 0))
    .默认
        WndProc ＝ GetPropA (hWnd, “GWL_WNDPROC”)
        返回 (CallWindowProcA (WndProc, hWnd, Msg, wParam, lParam))
    .判断结束
    

.子程序 窗口_屏蔽控件右键, 逻辑型, 公开, 屏蔽指定窗口的鼠标右键操作
    .参数 窗口句柄, 整数型, , 指定窗口句柄
    .局部变量 WndProc, 整数型

    .如果真 (IsWindow (窗口句柄) ≠ 1)
        输出调试文本 (“窗口句柄无效！”)
        返回 (假)
    .如果真结束
    
    WndProc ＝ GetPropA (窗口句柄, “GWL_WNDPROC”)
    .如果真 (WndProc ≠ 0)
        SetWindowLongA (窗口句柄, #GWL_WNDPROC, WndProc)
        RemovePropA (窗口句柄, “GWL_WNDPROC”)
    .如果真结束
    
    WndProc ＝ SetWindowLongA (窗口句柄, #GWL_WNDPROC, 到整数 (&屏蔽控件右键_消息处理))
    SetPropA (窗口句柄, “GWL_WNDPROC”, WndProc)
    返回 (真)

.子程序 屏蔽控件右键_消息处理, 整数型
    .参数 hWnd, 整数型
    .参数 Msg, 整数型
    .参数 wParam, 整数型
    .参数 lParam, 整数型
    .局部变量 WndProc, 整数型

    .如果真 (Msg ＝ #WM_DESTROY)
        RemovePropA (hWnd, “GWL_WNDPROC”)
    .如果真结束
    .判断开始 (Msg ＝ #WM_RBUTTONDOWN 或 Msg ＝ #WM_RBUTTONUP 或 Msg ＝ #WM_RBUTTONDBLCLK)
        返回 (0)
    .默认
        WndProc ＝ GetPropA (hWnd, “GWL_WNDPROC”)
        返回 (CallWindowProcA (WndProc, hWnd, Msg, wParam, lParam))
    .判断结束
    

.子程序 窗口_按钮解除禁止, 逻辑型, 公开, 可以激活一些被禁止的按钮；成功返回真；失败返回假；
    .参数 控件句柄, 整数型, , 指定的按钮等控件句柄
    .参数 类型, 逻辑型, 可空, 真=解除禁止,假=禁止

    返回 (EnableWindow (控件句柄, 类型))

.子程序 窗口_取顶端窗口句柄, 整数型, 公开, 成功返回一个最顶端窗口的句柄
    返回 (GetForegroundWindow ())

.子程序 窗口_限制运行次数, 逻辑型, 公开, 真为超出次数，假为相反
    .参数 标题, 文本型
    .参数 类名, 文本型
    .参数 限制次数, 整数型, 可空, 限制多开的窗口数量，可空，默认为1
    .局部变量 实际次数, 整数型
    .局部变量 句柄, 整数型

    .如果真 (限制次数 ≤ 0)
        限制次数 ＝ 1
    .如果真结束
    句柄 ＝ FindWindowExA (0, 0, 取指针文本_ (类名), 0)
    .判断循环首 (句柄 ≠ 0)
        .如果真 (窗口_取标题 (句柄) ＝ 标题)
            实际次数 ＝ 实际次数 ＋ 1
        .如果真结束
        句柄 ＝ FindWindowExA (0, 句柄, 取指针文本_ (类名), 0)
    .判断循环尾 ()
    .判断开始 (实际次数 ＞ 限制次数)
        返回 (真)
    .默认
        返回 (假)
    .判断结束
    

.子程序 窗口_句柄取进程路径, 文本型, 公开, 根据指定窗口句柄获取程序的文件路径
    .参数 窗口句柄, 整数型, 可空
    .局部变量 dwProcessId, 整数型
    .局部变量 hProcess, 整数型
    .局部变量 dwSize, 整数型
    .局部变量 szFile, 文本型

    .如果 (窗口句柄 ≠ 0)
        GetWindowThreadProcessId (窗口句柄, dwProcessId)
        hProcess ＝ OpenProcess (位或 (#PROCESS_QUERY_INFORMATION, #PROCESS_VM_READ), 0, dwProcessId)
    .否则
        hProcess ＝ GetCurrentProcess ()
    .如果结束
    .如果真 (hProcess ≠ #NULL)
        szFile ＝ 取空白文本 (#MAX_PATH)
        dwSize ＝ GetModuleFileNameExA (hProcess, #NULL, szFile, #MAX_PATH)
        CloseHandle (hProcess)
    .如果真结束
    返回 (szFile)

.子程序 窗口_取鼠标处控件标题, 文本型, 公开, 取出指定点的组件上的文字内容或标题(返回文字内容)
    .参数 水平位置, 整数型, 可空, (可空为鼠标当前坐标x)   文字所在的x坐标“X轴光标”
    .参数 垂直位置, 整数型, 可空, (可空为鼠标当前坐标y)   文字所以的y坐标“Y轴光标”
    .局部变量 文本内容, 文本型
    .局部变量 坐标变量, 精易_坐标

    .如果真 (是否为空 (水平位置) 或 是否为空 (垂直位置))
        GetCursorPos (坐标变量)
        水平位置 ＝ 坐标变量.横
        垂直位置 ＝ 坐标变量.纵
    .如果真结束
    文本内容 ＝ 取空白文本 (256)
    SendMessageA (WindowFromPoint (水平位置, 垂直位置), 13, 256, 取指针文本_ (文本内容))
    返回 (文本内容)

.子程序 窗口_取鼠标处窗口句柄, 整数型, 公开, 取鼠标处窗口句柄,成功返回句柄，失败返回0
    .局部变量 坐标, 精易_坐标
    .局部变量 横坐标, 整数型
    .局部变量 纵坐标, 整数型

    坐标 ＝ 鼠标_取位置 ()
    返回 (WindowFromPoint (坐标.横, 坐标.纵))

.子程序 窗口_取指定坐标处句柄, 整数型, 公开, 取指定坐标处句柄,成功返回句柄，失败返回0
    .参数 横坐标, 整数型, , 桌面横坐标
    .参数 纵坐标, 整数型, , 桌面纵坐标

    返回 (WindowFromPoint (横坐标, 纵坐标))

.子程序 窗口_句柄枚举进程信息, 精易_进程信息, 公开, 返回进程ID，进程名，进程名全路径；
    .参数 窗口句柄, 整数型
    .局部变量 进程ID, 整数型
    .局部变量 进程信息1, 精易_进程信息
    .局部变量 进程文件名, 文本型
    .局部变量 结果, 整数型
    .局部变量 进程快照, 整数型
    .局部变量 是否存在, 整数型
    .局部变量 进程信息, 精易_进程信息列表

    .如果真 (GetWindowThreadProcessId (窗口句柄, 进程ID) ≠ 0)
        进程信息1.进程ID ＝ 进程ID
        进程文件名 ＝ 取空白文本 (1024)
        结果 ＝ GetModuleFileNameExA (OpenProcess (1040, 0, 进程ID), 0, 进程文件名, 1024)
        .如果真 (结果 ≠ 0)
            进程信息1.进程全路径名 ＝ 到文本 (删首尾空 (进程文件名))
        .如果真结束
        进程快照 ＝ CreateToolhelp32Snapshot (#TH32CS_SNAPALL, 0)
        .如果真 (进程快照 ≠ #INVALID_HANDLE_VALUE)
            进程信息.dwSize ＝ 296
            是否存在 ＝ Process32First (进程快照, 进程信息)
            .判断循环首 (是否存在 ≠ 0)
                .如果真 (进程信息.进程ID ＝ 进程ID)
                    进程信息1.进程名 ＝ 到文本 (进程信息.进程名称)
                    跳出循环 ()
                .如果真结束
                是否存在 ＝ Process32Next (进程快照, 进程信息)
            .判断循环尾 ()
            CloseHandle (进程快照)
        .如果真结束
        
    .如果真结束
    返回 (进程信息1)

.子程序 窗口_是否激活, 逻辑型, 公开, 判断指定窗口是否激活状态，是则返回真，否则返回假。
    .参数 窗口句柄, 整数型
    .局部变量 pwi, WINDOWINFO

    pwi.cbSize ＝ 60
    GetWindowInfo (窗口句柄, pwi)
    返回 (pwi.dwWindowStatus ＝ 1)

.子程序 窗口_取矩形, 精易_矩形, 公开, 返回指定窗口的矩形信息
    .参数 窗口句柄
    .局部变量 pwi, WINDOWINFO

    pwi.cbSize ＝ 60
    GetWindowInfo (窗口句柄, pwi)
    返回 (pwi.rcWindow)

.子程序 窗口_取客户区矩形, 精易_矩形, 公开, 返回指定窗口的矩形信息
    .参数 窗口句柄, 整数型
    .局部变量 pwi, WINDOWINFO

    pwi.cbSize ＝ 60
    GetWindowInfo (窗口句柄, pwi)
    返回 (pwi.rcClient)

.子程序 窗口_取样式, 整数型, 公开, 返回指定窗口的窗口样式
    .参数 窗口句柄, 整数型
    .局部变量 pwi, WINDOWINFO

    pwi.cbSize ＝ 60
    GetWindowInfo (窗口句柄, pwi)
    返回 (pwi.dwStyle)

.子程序 窗口_取扩展样式, 整数型, 公开, 返回指定窗口的扩展样式
    .参数 窗口句柄, 整数型
    .局部变量 pwi, WINDOWINFO

    pwi.cbSize ＝ 60
    GetWindowInfo (窗口句柄, pwi)
    返回 (pwi.dwExStyle)

.子程序 窗口_取边框宽度, 整数型, 公开, 返回指定窗口的宽度
    .参数 窗口句柄, 整数型
    .局部变量 pwi, WINDOWINFO

    pwi.cbSize ＝ 60
    GetWindowInfo (窗口句柄, pwi)
    返回 (pwi.cxWindowBorders)

.子程序 窗口_取边框高度, 整数型, 公开, 返回指定窗口的高度
    .参数 窗口句柄, 整数型
    .局部变量 pwi, WINDOWINFO

    pwi.cbSize ＝ 60
    GetWindowInfo (窗口句柄, pwi)
    返回 (pwi.cyWindowBorders)

.子程序 窗口_取激活句柄, 整数型, 公开, 取激活的窗口句柄。
    返回 (GetActiveWindow ())

.子程序 窗口_限制尺寸, 逻辑型, 公开, 限制窗口拉伸最小尺寸与最大尺寸，超出则无法拉伸。注意：不支持外部窗口。
    .参数 窗口句柄, 整数型
    .参数 最小宽度, 整数型, 可空
    .参数 最小高度, 整数型, 可空
    .参数 最大宽度, 整数型, 可空
    .参数 最大高度, 整数型, 可空

    SetPropA (窗口句柄, “minimum width”, 选择 (是否为空 (最小宽度), -1, 最小宽度))
    SetPropA (窗口句柄, “minimum height”, 选择 (是否为空 (最小高度), -1, 最小高度))
    SetPropA (窗口句柄, “maximum width”, 选择 (是否为空 (最大宽度), -1, 最大宽度))
    SetPropA (窗口句柄, “maximum height”, 选择 (是否为空 (最大高度), -1, 最大高度))
    返回 (SetPropA (窗口句柄, “Limit size”, SetWindowLongA (窗口句柄, -4, 到整数 (&限制尺寸回调))))

.子程序 限制尺寸回调, 整数型
    .参数 hwnd, 整数型
    .参数 uMsg, 整数型
    .参数 wParam, 整数型
    .参数 lParam, 整数型
    .局部变量 subproc, 整数型
    .局部变量 maxwin, MINMAXINFO
    .局部变量 val, 整数型

    subproc ＝ GetPropA (hwnd, “Limit size”)
    .如果真 (GetPropA (hwnd, “Cancel the limit”) ＝ 1)
        RemovePropA (hwnd, “Limit size”)
        RemovePropA (hwnd, “Cancel the limit”)
        RemovePropA (hwnd, “minimum width”)
        RemovePropA (hwnd, “minimum height”)
        RemovePropA (hwnd, “maximum width”)
        RemovePropA (hwnd, “maximum height”)
        SetWindowLongA (hwnd, #GWL_WNDPROC, subproc)
        返回 (0)
    .如果真结束
    .如果真 (uMsg ＝ 36) ' WM_GETMINMAXINFO
        CopyMemory_int2minmaxinfo (maxwin, lParam, 40)
        val ＝ GetPropA (hwnd, “minimum width”)
        .如果真 (val ＞ -1)
            maxwin.ptMinTrackSize.横 ＝ val
        .如果真结束
        val ＝ GetPropA (hwnd, “minimum height”)
        .如果真 (val ＞ -1)
            maxwin.ptMinTrackSize.纵 ＝ val
        .如果真结束
        val ＝ GetPropA (hwnd, “maximum width”)
        .如果真 (val ＞ -1)
            maxwin.ptMaxTrackSize.横 ＝ val
        .如果真结束
        val ＝ GetPropA (hwnd, “maximum height”)
        .如果真 (val ＞ -1)
            maxwin.ptMaxTrackSize.纵 ＝ val
        .如果真结束
        CopyMemory_minmaxinfo2int (lParam, maxwin, 40)
    .如果真结束
    返回 (CallWindowProcA (subproc, hwnd, uMsg, wParam, lParam))

.子程序 窗口_取消尺寸限制, 逻辑型, 公开, 取消 [窗口_限制尺寸] 的限制
    .参数 窗口句柄, 整数型
    .参数 是否取消限制, 逻辑型

    返回 (SetPropA (窗口句柄, “Cancel the limit”, 选择 (是否取消限制, 1, 0)))

.子程序 窗口_是否被遮挡, 逻辑型, 公开, 判断一个窗口是否被置顶窗口遮挡，是否返回真，否则返回假。
    .参数 窗口句柄, 整数型
    .局部变量 局_窗口信息, WINDOWINFO
    .局部变量 局_旧矩形, 精易_矩形
    .局部变量 局_是否子, 逻辑型
    .局部变量 局_新矩形, 精易_矩形
    .局部变量 局_旧句柄, 整数型

    局_窗口信息.cbSize ＝ 60
    .如果真 (GetWindowInfo (窗口句柄, 局_窗口信息))
        局_旧矩形 ＝ 局_窗口信息.rcWindow
        局_是否子 ＝ #WS_CHILD ＝ 位与 (局_窗口信息.dwStyle, #WS_CHILD)
        .如果真 (窗口句柄 ＝ GetDesktopWindow ())
            窗口句柄 ＝ GetWindow (GetTopWindow (窗口句柄), #GW_HWNDLAST)
        .如果真结束
        .循环判断首 ()
            局_旧句柄 ＝ 窗口句柄
            窗口句柄 ＝ GetNextWindow (窗口句柄, #GW_HWNDPREV)
            .判断循环首 (窗口句柄 ≠ 0)
                .如果真 (IsWindowVisible (窗口句柄))
                    GetWindowRect (窗口句柄, 局_新矩形)
                    .如果真 (取反 (局_新矩形.右边 ＜ 局_旧矩形.左边 或 局_新矩形.左边 ＞ 局_旧矩形.右边 或 局_新矩形.底边 ＜ 局_旧矩形.顶边 或 局_新矩形.顶边 ＞ 局_旧矩形.底边))
                        返回 (真)
                    .如果真结束
                    处理事件 ()
                .如果真结束
                .如果 (局_是否子)
                    窗口句柄 ＝ GetParent (局_旧句柄)
                    局_是否子 ＝ #WS_CHILD ＝ 位与 (GetWindowLongA (窗口句柄, #GWL_STYLE), #WS_CHILD)
                .否则
                    跳出循环 ()
                .如果结束
                处理事件 ()
            .判断循环尾 ()
        .循环判断尾 (窗口句柄 ≠ 0)
    .如果真结束
    返回 (假)

.子程序 窗口_是否存在, 整数型, 公开, 根据指定窗口句柄或窗口标题，查询一个窗口是否存在，成功返回窗口句柄，否则返回0。
    .参数 参_句柄或标题, 文本型, , 支持窗口句柄与模糊标题
    .局部变量 局_窗口信息, 精易_窗口信息, , "0"
    .局部变量 局_数据结构, WINDOWINFO
    .局部变量 局_数量, 整数型
    .局部变量 局_计次, 整数型
    .局部变量 局_临时, 文本型

    局_数据结构.cbSize ＝ 60
    .如果 (GetWindowInfo (到整数 (参_句柄或标题), 局_数据结构))
        返回 (到整数 (参_句柄或标题))
    .否则
        局_数量 ＝ 窗口_枚举 (局_窗口信息)
        .计次循环首 (局_数量, 局_计次)
            .如果真 (寻找文本 (局_窗口信息 [局_计次].窗口标题, 参_句柄或标题, , 假) ≠ -1)
                返回 (局_窗口信息 [局_计次].窗口句柄)
            .如果真结束
            处理事件 ()
        .计次循环尾 ()
    .如果结束
    返回 (0)

.子程序 窗口_等待出现, 整数型, 公开, 等待指定窗口出现，成功返回窗口句柄，失败返回0，本命令类似于AU3脚本中WinWait命令。
    .参数 参_标题, 文本型, , 支持模糊标题
    .参数 参_内容, 文本型, 可空, 如果窗口标题相同，可以比较窗口内文本，支持模糊内容。
    .参数 参_超时, 整数型, 可空, 单位为毫秒,超过此时间等待还没结果则返回0,留空则一直等待
    .局部变量 局_窗口句柄
    .局部变量 局_启动时间, 整数型
    .局部变量 局_延时
    .局部变量 局_子数量
    .局部变量 局_子句柄, , , "0"
    .局部变量 局_子计次
    .局部变量 局_子文本, 文本型

    局_延时 ＝ 选择 (参_超时 ＞ 0, 参_超时, 100000000 × 1000)
    局_启动时间 ＝ 取启动时间 ()
    .判断循环首 (取启动时间 () － 局_启动时间 ＜ 局_延时)
        局_窗口句柄 ＝ 窗口_是否存在 (参_标题)
        .如果真 (局_窗口句柄 ≠ 0)
            .如果 (取文本长度 (参_内容) ＞ 0)
                局_子数量 ＝ 窗口_枚举子窗口 (局_窗口句柄, 局_子句柄)
                .计次循环首 (局_子数量, 局_子计次)
                    局_子文本 ＝ 窗口_取标题 (局_子句柄 [局_子计次])
                    .如果真 (寻找文本 (局_子文本, 参_内容, , 假) ≠ -1)
                        返回 (局_窗口句柄)
                    .如果真结束
                    处理事件 ()
                .计次循环尾 ()
            .否则
                返回 (局_窗口句柄)
            .如果结束
            处理事件 ()
        .如果真结束
        程序_延时 (250) ' 延时250毫秒，等待系统响应
    .判断循环尾 ()
    返回 (0)

.子程序 窗口_挂起, 整数型, 公开, 成功返回挂起计数，失败返回-1
    .参数 参_窗口句柄, 整数型
    .参数 参_是否挂起, 逻辑型, 可空
    .局部变量 Tid
    .局部变量 hThread, 整数型
    .局部变量 bresult

    Tid ＝ GetWindowThreadProcessId (参_窗口句柄, 0)
    .如果真 (Tid ≠ 0)
        hThread ＝ OpenThread (2032639, 0, Tid)
        .如果真 (hThread ≠ 0)
            参_是否挂起 ＝ 选择 (是否为空 (参_是否挂起), 真, 参_是否挂起)
            .如果 (参_是否挂起)
                bresult ＝ SuspendThread (hThread)
            .否则
                bresult ＝ ResumeThread (hThread)
            .如果结束
            CloseHandle (hThread)
        .如果真结束
        返回 (bresult)
    .如果真结束
    返回 (-1)

.子程序 窗口_取窗口属性, 整数型, 公开, 如果函数成功，返回值是所需的32位值；如果函数失败，返回值是0。若想获得更多错误信息请调用 GetLastError函数。
    .参数 窗口句柄, 整数型, , 获取指定的窗口风格属性
    .参数 类型, 整数型, , 参考常量GWL相关

    返回 (GetWindowLongA (窗口句柄, 类型))

.子程序 窗口_置窗口属性, 整数型, 公开, 如果函数成功，返回值是指定的32位整数的原来的值。如果函数失败，返回值为0。若想获得更多错误信息，请调用GetLastError函数。
    .参数 窗口句柄, 整数型, , 设置指定的窗口风格属性，如将有边框窗口设置为无边框窗口
    .参数 属性, 整数型, , 参考常量GWL相关
    .参数 新样式, 整数型, , 调用 窗口_取窗口属性 获取对应属性值并设置对应属性值

    返回 (SetWindowLongA (窗口句柄, 属性, 新样式))

.子程序 窗口_剔除风格, 整数型, 公开, 返回值是指定的32位整数的原来的值。如果函数失败，返回值为0。若想获得更多错误信息，请调用GetLastError函数。
    .参数 参_句柄, 整数型
    .参数 参_待剔除风格, 整数型, , 参考常量值 #窗口风格_  
    .局部变量 局_风格

    局_风格 ＝ GetWindowLongA (参_句柄, #GWL_STYLE)
    局_风格 ＝ 位与 (局_风格, 位取反 (参_待剔除风格))
    返回 (SetWindowLongA (参_句柄, #GWL_STYLE, 局_风格))

.子程序 窗口_剔除扩展风格, 整数型, 公开, 返回值是指定的32位整数的原来的值。如果函数失败，返回值为0。若想获得更多错误信息，请调用GetLastError函数。
    .参数 参_句柄, 整数型
    .参数 参_待剔除扩展风格, 整数型, , 参考常量值 #窗口扩展_  
    .局部变量 局_风格

    局_风格 ＝ GetWindowLongA (参_句柄, #GWL_EXSTYLE)
    局_风格 ＝ 位与 (局_风格, 位取反 (参_待剔除扩展风格))
    返回 (SetWindowLongA (参_句柄, #GWL_EXSTYLE, 局_风格))

.子程序 窗口_更新窗口, 整数型, 公开, 强制立即更新窗口，窗口中以前屏蔽的所有区域都会重画
    .参数 窗口句柄, 整数型

    返回 (UpdateWindow (窗口句柄))

.子程序 窗口_隐藏小图标, , 公开, 隐藏标题左上角的小图标
    .参数 窗口句柄, 整数型

    SetWindowLongA (窗口句柄, #GWL_EXSTYLE, 65793)
    SendMessageA (窗口句柄, #WM_SETICON, 1, 0)
    SendMessageA (窗口句柄, #WM_SETICON, 0, 0)

.子程序 窗口_设为无焦点, 整数型, 公开, 设置窗口为无焦点窗口（类似输入法窗口不会获取焦点）
    .参数 窗口句柄, 整数型

    ' https://bbs.125.la/thread-14426649-1-1.html
    返回 (SetWindowLongA (窗口句柄, #GWL_EXSTYLE, #WS_EX_NOACTIVATE))

.子程序 窗口_复制到剪贴板, 整数型, 公开, 程序发送此消息给一个编辑框或combobox来复制当前选择的文本到剪贴板
    .参数 窗口句柄, 整数型

    ' https://bbs.125.la/thread-14426649-1-1.html
    返回 (SendMessageA (窗口句柄, #WM_COPY, 0, 0))

.子程序 窗口_取句柄_递归, 整数型, 公开, 成功返回控件的句柄，失败返回0
    .参数 句柄, 整数型
    .参数 指定类名, 文本型
    .局部变量 Class, 文本型
    .局部变量 hWnd, 整数型
    .局部变量 phWnd, 整数型

    hWnd ＝ FindWindowExA (句柄, 0, 0, 0)
    .判断循环首 (hWnd ＞ 0)
        Class ＝ 窗口_取类名 (hWnd)
        .如果真 (Class ＝ 指定类名)
            返回 (hWnd)
        .如果真结束
        phWnd ＝ 窗口_取句柄_递归 (hWnd, 指定类名)
        .如果真 (phWnd ≠ 0)
            返回 (phWnd)
        .如果真结束
        hWnd ＝ FindWindowExA (句柄, hWnd, 0, 0)
        系统_处理事件1 ()
    .判断循环尾 ()
    返回 (0)

.子程序 窗口_取顶端文件夹路径, 文本型, 公开, 成功返回路径，失败返回空文本
    .局部变量 hWnd, 整数型
    .局部变量 path, 文本型

    hWnd ＝ FindWindowA (“CabinetWClass”, 字符 (0))
    .如果真 (hWnd ≠ 0)
        hWnd ＝ 窗口_取句柄_递归 (hWnd, “Breadcrumb Parent”)
        hWnd ＝ FindWindowExA (hWnd, 0, 取指针文本_ (“ToolbarWindow32”), 0)
        path ＝ 窗口_取标题 (hWnd)
        path ＝ 文本_取右边 (path, “地址: ”)
    .如果真结束
    返回 (path)

.子程序 窗口_注册窗口热键, 逻辑型, 公开, 注册窗口级热键,只有在窗口被激活时才有效
    .参数 窗口句柄, 整数型, , 要注册热键那个窗口的句柄
    .参数 功能键状态, 整数型, 可空, 请使用常量 #MOD_ALT、#MOD_CONTROL、#MOD_SHIFT 若要两个或以上的状态键按则把它们的值相加
    .参数 键代码, 整数型, , 请使用 #A键、#B键、#F1键、#F2键... 等常量
    .参数 热键响应类型, 整数型, 可空, 请使用常量:1.热键类型_键盘按下 2.热键类型_键盘松开;留空或传递0默认为键盘按下
    .参数 子程序指针, 子程序指针, , 热键事件调用的子程序
    .参数 允许继续输入, 逻辑型, 可空, 热键响应之后,是否允许继续输入该热键的文字(WM_CHAR),默认为假.不允许.
    .局部变量 hWnd, 整数型
    .局部变量 hProc, 整数型
    .局部变量 PropName, 文本型
    .局部变量 HotkeyMsg, 整数型

    hWnd ＝ 窗口句柄
    .如果真 (IsWindow (窗口句柄) ＝ 0)
        返回 (假)
    .如果真结束
    hProc ＝ 到整数 (子程序指针)
    HotkeyMsg ＝ RegisterWindowMessageA (“Comet_HotKeyMessage”)
    .如果真 (HotkeyMsg ＝ 0)
        返回 (假)
    .如果真结束
    SetPropA (hWnd, “Comet_HotKeyMessage”, HotkeyMsg)
    .如果真 (键代码 ＜ 1 或 键代码 ＞ 254)
        返回 (假)
    .如果真结束
    .如果真 (功能键状态 ＜ 0 或 功能键状态 ＞ 7)
        功能键状态 ＝ 0
    .如果真结束
    .如果真 (热键响应类型 ≤ 0 或 热键响应类型 ＞ 2)
        热键响应类型 ＝ 1
    .如果真结束
    SetHotKeyProp (hWnd, 功能键状态, 键代码, hProc, 热键响应类型, 允许继续输入)
    HotKey_SubClassWindow (GetAncestor (hWnd, #GA_ROOT))
    返回 (真)

.子程序 窗口_撤销窗口热键, 逻辑型, 公开, 撤销窗口级热键
    .参数 窗口句柄, 整数型, , 要撤销热键那个窗口的句柄
    .参数 键代码, 整数型, , 请使用 #A键、#B键、#F1键、#F2键... 等常量
    .局部变量 hWnd, 整数型
    .局部变量 hProc, 整数型
    .局部变量 VirtKey, 整数型
    .局部变量 PropName, 文本型

    hWnd ＝ 窗口句柄
    .如果真 (IsWindow (hWnd) ＝ 0)
        返回 (假)
    .如果真结束
    VirtKey ＝ 键代码
    .如果真 (VirtKey ＜ 1 或 VirtKey ＞ 254)
        返回 (假)
    .如果真结束
    hProc ＝ GetPropA (hWnd, “Comet_HotKeyProc”)
    .如果真 (hProc ＝ 0)
        返回 (假)
    .如果真结束
    SetWindowLongA (hWnd, #GWL_WNDPROC, hProc)
    PropName ＝ “HotKey” ＋ 到文本 (VirtKey)
    RemovePropA (hWnd, PropName ＋ “_Mod”)
    RemovePropA (hWnd, PropName ＋ “_VirtKey”)
    RemovePropA (hWnd, PropName ＋ “_Proc”)
    RemovePropA (hWnd, PropName ＋ “_Type”)
    RemovePropA (hWnd, PropName ＋ “_Char”)
    .如果真 (EnumPropsA (hWnd, 到整数 (&HotkeysEnumFunc)) ＝ 1)
        RemovePropA (hWnd, “Comet_HotKeyProc”)
        RemovePropA (hWnd, “Comet_HotKeyMessage”)
    .如果真结束
    返回 (真)

.子程序 HotkeysEnumFunc, 逻辑型
    .参数 hWnd, 整数型
    .参数 lpString, 整数型
    .参数 hData, 整数型
    .局部变量 szString, 文本型

    .如果真 (lpString ≠ #NULL)
        szString ＝ 指针到文本 (lpString)
        .如果真 (取文本右边 (szString, 8) ＝ “_VirtKey”)
            返回 (假)
        .如果真结束
        
    .如果真结束
    返回 (真)

.子程序 SetHotKeyProp
    .参数 hWnd, 整数型
    .参数 Modifiers, 整数型, , #MOD_CONTROL #MOD_SHIFT #MOD_ALT
    .参数 VirtKey, 整数型
    .参数 Proc, 整数型
    .参数 Type, 整数型
    .参数 bChar, 逻辑型
    .局部变量 PropName, 文本型

    PropName ＝ “HotKey” ＋ 到文本 (VirtKey)
    SetPropA (hWnd, PropName ＋ “_Mod”, Modifiers)
    SetPropA (hWnd, PropName ＋ “_VirtKey”, VirtKey)
    SetPropA (hWnd, PropName ＋ “_Proc”, Proc)
    SetPropA (hWnd, PropName ＋ “_Type”, Type)
    SetPropA (hWnd, PropName ＋ “_Char”, 到整数 (bChar))

.子程序 HotKey_SubClassWindow
    .参数 hWndParent, 整数型
    .局部变量 hProc, 整数型
    .局部变量 hWnd, 整数型

    hProc ＝ GetPropA (hWndParent, “Comet_HotKeyProc”)
    .如果真 (hProc ＝ 0)
        hProc ＝ SetWindowLongA (hWndParent, #GWL_WNDPROC, 到整数 (&HotKey_OnMessage))
        SetPropA (hWndParent, “Comet_HotKeyProc”, hProc)
    .如果真结束
    hWnd ＝ GetWindow (hWndParent, #GW_CHILD)
    .判断循环首 (hWnd ≠ 0)
        HotKey_SubClassWindow (hWnd)
        hWnd ＝ GetWindow (hWnd, #GW_HWNDNEXT)
    .判断循环尾 ()

.子程序 HotKey_OnMessage, 整数型
    .参数 hWnd, 整数型, , 要接收消息的那个窗口的句柄
    .参数 wMsg, 整数型, , 消息的标识符
    .参数 wParam, 整数型, , 具体取决于消息
    .参数 lParam, 整数型, , 具体取决于消息;

    .判断开始 (wMsg ＝ #WM_KEYDOWN 或 wMsg ＝ #WM_SYSKEYDOWN)
        返回 (HotKey_OnKeyDown (hWnd, wMsg, wParam, lParam))
    .判断 (wMsg ＝ #WM_KEYUP 或 wMsg ＝ #WM_SYSKEYUP)
        返回 (HotKey_OnKeyUP (hWnd, wMsg, wParam, lParam))
    .判断 (wMsg ＝ #WM_CHAR)
        返回 (HotKey_OnChar (hWnd, wMsg, wParam, lParam))
    .判断 (wMsg ＝ GetPropA (hWnd, “Comet_HotKeyMessage”))
        返回 (HotKey_OnHotkeyMsg (hWnd, wMsg, wParam, lParam))
    .默认
        
    .判断结束
    返回 (HotKey_CallWindowProc (hWnd, wMsg, wParam, lParam))

.子程序 HotKey_OnKeyDown, 整数型
    .参数 hWnd, 整数型, , 要接收消息的那个窗口的句柄
    .参数 wMsg, 整数型, , 消息的标识符
    .参数 wParam, 整数型, , 具体取决于消息
    .参数 lParam, 整数型, , 具体取决于消息;
    .局部变量 nVirtKey, 整数型
    .局部变量 HotKeyData, HotKeyData

    nVirtKey ＝ wParam
    .如果真 (IsHotKey (hWnd, nVirtKey, HotKeyData))
        .如果真 (HotKeyData.nType ＝ 1) ' 热键类型_键盘按下
            PostMessageA (hWnd, GetPropA (hWnd, “Comet_HotKeyMessage”), HotKeyData.hProc, 0)
        .如果真结束
        返回 (0)
    .如果真结束
    返回 (HotKey_CallWindowProc (hWnd, wMsg, wParam, lParam))

.子程序 GetHotKeyProp, HotKeyData
    .参数 hWnd, 整数型
    .参数 VirtKey, 整数型
    .局部变量 HotKeyData, HotKeyData
    .局部变量 PropName, 文本型

    HotKeyData.hWnd ＝ hWnd
    PropName ＝ “HotKey” ＋ 到文本 (VirtKey)
    HotKeyData.nModifiers ＝ GetPropA (hWnd, PropName ＋ “_Mod”)
    HotKeyData.nVirtKey ＝ GetPropA (hWnd, PropName ＋ “_VirtKey”)
    HotKeyData.hProc ＝ GetPropA (hWnd, PropName ＋ “_Proc”)
    HotKeyData.nType ＝ GetPropA (hWnd, PropName ＋ “_Type”)
    HotKeyData.bChar ＝ GetPropA (hWnd, PropName ＋ “_Char”) ≠ 0
    返回 (HotKeyData)

.子程序 IsHotKey, 逻辑型, , 判断热键是否已注册
    .参数 hWnd, 整数型
    .参数 VirtKey, 整数型
    .参数 HotKeyData, HotKeyData, 参考
    .局部变量 hWndRoot, 整数型
    .局部变量 StatusModKey, 整数型

    HotKeyData ＝ GetHotKeyProp (hWnd, VirtKey)
    .如果真 (HotKeyData.hProc ＝ 0)
        hWndRoot ＝ GetAncestor (hWnd, #GA_ROOT)
        .如果真 (hWndRoot ＝ hWnd)
            返回 (假)
        .如果真结束
        HotKeyData ＝ GetHotKeyProp (hWndRoot, VirtKey)
        .如果真 (HotKeyData.hProc ＝ 0)
            返回 (假)
        .如果真结束
        
    .如果真结束
    .如果真 (HotKeyData.nModifiers ＝ 0)
        返回 (真)
    .如果真结束
    StatusModKey ＝ 位或 (选择 (IsKeyDown (#VK_CONTROL), #MOD_CONTROL, 0), 选择 (IsKeyDown (#VK_SHIFT), #MOD_SHIFT, 0), 选择 (IsKeyDown (#VK_MENU), #MOD_ALT, 0))
    .如果真 (StatusModKey ＝ HotKeyData.nModifiers)
        返回 (真)
    .如果真结束
    返回 (假)

.子程序 IsKeyDown, 逻辑型, 公开, 键是否按下
    .参数 KeyCode, 整数型

    返回 (位与 (GetAsyncKeyState (KeyCode), 32768) ≠ 0)

.子程序 HotKey_OnKeyUP, 整数型
    .参数 hWnd, 整数型, , 要接收消息的那个窗口的句柄
    .参数 wMsg, 整数型, , 消息的标识符
    .参数 wParam, 整数型, , 具体取决于消息
    .参数 lParam, 整数型, , 具体取决于消息;
    .局部变量 nVirtKey, 整数型
    .局部变量 HotKeyData, HotKeyData

    nVirtKey ＝ wParam
    .如果真 (IsHotKey (hWnd, nVirtKey, HotKeyData))
        .如果真 (HotKeyData.nType ＝ 2) ' 热键类型_键盘松开
            PostMessageA (hWnd, GetPropA (hWnd, “Comet_HotKeyMessage”), HotKeyData.hProc, 0)
        .如果真结束
        返回 (0)
    .如果真结束
    返回 (HotKey_CallWindowProc (hWnd, wMsg, wParam, lParam))

.子程序 HotKey_OnChar, 整数型
    .参数 hWnd, 整数型, , 要接收消息的那个窗口的句柄
    .参数 wMsg, 整数型, , 消息的标识符
    .参数 wParam, 整数型, , 具体取决于消息
    .参数 lParam, 整数型, , 具体取决于消息;
    .局部变量 CharCode, 整数型
    .局部变量 nVirtKey, 整数型
    .局部变量 HotKeyData, HotKeyData

    CharCode ＝ wParam
    .如果真 (CharCode ≥ 97 且 CharCode ≤ 122)
        nVirtKey ＝ CharCode － 32
    .如果真结束
    .如果真 (IsHotKey (hWnd, nVirtKey, HotKeyData))
        .如果真 (HotKeyData.bChar ＝ 假)
            返回 (0)
        .如果真结束
        
    .如果真结束
    返回 (HotKey_CallWindowProc (hWnd, wMsg, wParam, lParam))

.子程序 HotKey_OnHotkeyMsg, 整数型
    .参数 hWnd, 整数型, , 要接收消息的那个窗口的句柄
    .参数 wMsg, 整数型, , 消息的标识符
    .参数 wParam, 整数型, , 具体取决于消息
    .参数 lParam, 整数型, , 具体取决于消息;

    CallProc (wParam, hWnd, , )
    返回 (0)

.子程序 HotKey_CallWindowProc, 整数型
    .参数 hWnd, 整数型, , 要接收消息的那个窗口的句柄
    .参数 wMsg, 整数型, , 消息的标识符
    .参数 wParam, 整数型, , 具体取决于消息
    .参数 lParam, 整数型, , 具体取决于消息;
    .局部变量 hProc, 整数型

    hProc ＝ GetPropA (hWnd, “Comet_HotKeyProc”)
    .如果真 (hProc ＝ 0)
        返回 (DefWindowProc (hWnd, wMsg, wParam, lParam))
    .如果真结束
    返回 (CallWindowProcA (hProc, hWnd, wMsg, wParam, lParam))

.子程序 CallProc, 整数型
    .参数 hProc, 整数型
    .参数 Param1, 整数型, 可空
    .参数 Param2, 整数型, 可空
    .参数 Param3, 整数型, 可空

    .如果真 (hProc ＝ 0)
        返回 (0)
    .如果真结束
    返回 (CallWindowProcA (取指针字节集_ ({ 85, 139, 236, 255, 117, 20, 255, 117, 16, 255, 117, 12, 255, 85, 8, 201, 194, 16, 0 }), hProc, Param1, Param2, Param3))

.子程序 窗口_毛玻璃特效, 逻辑型, 公开, 仅Win10有效，成功返回真，失败返回假。
    .参数 窗口句柄, 整数型
    .局部变量 accent, ACCENT_POLICY
    .局部变量 data, WINDOWCOMPOSITIONATTRIBDATA

    .如果真 (_WIN32_WINNT ＜ #_WIN32_WINNT_WIN10)
        输出调试文本 (#ERROR_NOTVERSION)
        返回 (假)
    .如果真结束
    ' https://bbs.125.la/thread-14532209-1-1.html
    accent.AccentState ＝ 3 ' ACCENT_ENABLE_BLURBEHIND
    data.Attrib ＝ 19 ' WCA_ACCENT_POLICY
    data.pvData ＝ accent
    data.cbData ＝ 16 ' sizeof(accent)
    返回 (SetWindowCompositionAttribute (窗口句柄, data))

.子程序 窗口_监视锁屏_注册, 逻辑型, 公开, 注册指定的窗口以接收会话更改通知。
    .参数 窗口句柄, 整数型
    .参数 响应监视事件, 子程序指针, , 1个整数型参数，1=锁屏，2=取消锁屏
    .局部变量 result, 逻辑型

    result ＝ WTSRegisterSessionNotification (窗口句柄, #NOTIFY_FOR_THIS_SESSION)
    .如果 (result ＝ 假)
        输出调试文本 (“安装通知失败”)
    .否则
        m_HandleMsgProc ＝ 到整数 (响应监视事件)
        m_oldMsgProc ＝ SetWindowLongA (窗口句柄, #GWL_WNDPROC, 到整数 (&HandleMsgProc))
    .如果结束
    返回 (result)

.子程序 HandleMsgProc, 整数型
    .参数 hwnd, 整数型
    .参数 uMsg, 整数型
    .参数 wParam, 整数型
    .参数 lParam, 整数型

    .如果真 (uMsg ＝ #WM_WTSSESSION_CHANGE)
        .如果真 (m_HandleMsgProc ≠ 0)
            .判断开始 (wParam ＝ #WTS_SESSION_LOCK) ' 锁屏
                调用子程序_ (m_HandleMsgProc, 1, , , , , , , , , , , , , , )
            .判断 (wParam ＝ #WTS_SESSION_UNLOCK) ' 取消锁屏
                调用子程序_ (m_HandleMsgProc, 2, , , , , , , , , , , , , , )
            .默认
                
            .判断结束
            
        .如果真结束
        
    .如果真结束
    返回 (CallWindowProcA (m_oldMsgProc, hwnd, uMsg, wParam, lParam))

.子程序 窗口_监视锁屏_卸载, 逻辑型, 公开, 取消注册指定的窗口，以便不接收其他会话更改通知。
    .参数 窗口句柄, 整数型

    SetWindowLongA (窗口句柄, #GWL_WNDPROC, m_oldMsgProc)
    m_HandleMsgProc ＝ 0
    返回 (WTSUnRegisterSessionNotification (窗口句柄))

.子程序 窗口_禁止截图, 逻辑型, 公开, 保护自己的屏幕窗口内容不被捕获或复制
    .参数 窗口句柄, 整数型
    .参数 是否禁止, 逻辑型, 可空, 默认为真; 真为禁止, 假为取消
    .局部变量 dwAffinity, 整数型

    ' https://bbs.125.la/forum.php?mod=viewthread&tid=14654308
    .如果真 (_WIN32_WINNT ＜ #_WIN32_WINNT_WIN7)
        输出调试文本 (#ERROR_NOTVERSION)
        返回 (假)
    .如果真结束
    dwAffinity ＝ #WDA_NONE
    .如果真 (是否为空 (是否禁止) 或 是否禁止)
        dwAffinity ＝ #WDA_MONITOR
    .如果真结束
    返回 (SetWindowDisplayAffinity (窗口句柄, dwAffinity))

.子程序 窗口_取滚动条位置, 精易_坐标, 公开, 取滚动条当前位置
    .参数 控件句柄, 整数型
    .局部变量 pt, 精易_坐标

    ' https://bbs.125.la/forum.php?mod=viewthread&tid=14658077
    
    pt.横 ＝ GetScrollPos (控件句柄, #SB_HORZ)
    pt.纵 ＝ GetScrollPos (控件句柄, #SB_VERT)
    返回 (pt)

.子程序 窗口_置滚动条位置, , 公开, 置滚动条到指定位置
    .参数 控件句柄, 整数型
    .参数 坐标, 精易_坐标

    ' https://bbs.125.la/forum.php?mod=viewthread&tid=14658077
    
    SetScrollPos (控件句柄, #SB_HORZ, 坐标.横, 真)
    SetScrollPos (控件句柄, #SB_VERT, 坐标.纵, 真)
    
    SendMessageA (控件句柄, #WM_HSCROLL, 合并整数 (#SB_THUMBPOSITION, 坐标.横), 0)
    SendMessageA (控件句柄, #WM_VSCROLL, 合并整数 (#SB_THUMBPOSITION, 坐标.纵), 0)

.子程序 窗口_将焦点切换到指定的窗口, , 公开, 将焦点切换到指定的窗口
    .参数 要激活的窗口句柄, 整数型
    .参数 是否使最小化的窗口还原, 逻辑型, 可空

    SwitchToThisWindow (要激活的窗口句柄, 是否使最小化的窗口还原)

.子程序 CBTMessageBoxProc, 整数型
    .参数 nCode, 整数型
    .参数 wParam, 整数型
    .参数 lParam, 整数型
    .局部变量 pcs, 整数型
    .局部变量 hwndParent, 整数型
    .局部变量 hHook, 整数型
    .局部变量 cx, 整数型
    .局部变量 cy, 整数型
    .局部变量 rc, 精易_位置和大小
    .局部变量 x, 整数型
    .局部变量 y, 整数型

    .如果真 (nCode ＝ #HCBT_CREATEWND 且 lParam ≠ #NULL)
        pcs ＝ __get (lParam, 0) ' CREATESTRUCT
        hwndParent ＝ __get (pcs, 12)
        .如果真 (hwndParent ＝ #NULL)
            hwndParent ＝ 进程_ID取窗口句柄EX (进程_取自进程ID ())
        .如果真结束
        .如果真 (hwndParent ≠ #NULL)
            hHook ＝ GetPropA (hwndParent, “SetMessageBoxHook_hHook”)
            .如果真 (hHook ≠ #NULL)
                RemovePropA (hwndParent, “SetMessageBoxHook_hHook”)
                cx ＝ __get (pcs, 20)
                cy ＝ __get (pcs, 16)
                rc ＝ 窗口_取位置和大小 (hwndParent)
                x ＝ rc.左边 ＋ 四舍五入 ((rc.宽度 － cx) ÷ 2, 0)
                y ＝ rc.顶边 ＋ 四舍五入 ((rc.高度 － cy) ÷ 2, 0)
                __set (pcs, 28, x)
                __set (pcs, 24, y)
                UnhookWindowsHookEx (hHook)
            .如果真结束
            
        .如果真结束
        
    .如果真结束
    ' 返回 (CallNextHookEx (hHook, nCode, wParam, lParam))
    返回 (#S_OK)

.子程序 SetMessageBoxHook, 逻辑型, 公开, 让信息框居中在父窗口
    .参数 hwndParent, 整数型
    .参数 dwThreadId, 整数型, 可空, 线程的标识符
    .局部变量 hHook, 整数型

    RemoveMessageBoxHook (hwndParent)
    .如果真 (dwThreadId ＝ 0)
        dwThreadId ＝ GetWindowThreadProcessId (hwndParent, #NULL)
    .如果真结束
    .如果真 (dwThreadId ≠ 0)
        hHook ＝ SetWindowsHookExA (#WH_CBT, &CBTMessageBoxProc, GetWindowLongA (hwndParent, #GWL_HINSTANCE), dwThreadId)
        .如果真 (hHook ≠ #NULL)
            SetPropA (hwndParent, “SetMessageBoxHook_hHook”, hHook)
        .如果真结束
        
    .如果真结束
    返回 (hHook ≠ #NULL)

.子程序 RemoveMessageBoxHook, 逻辑型, 公开, 卸载钩子
    .参数 hwndParent, 整数型
    .局部变量 hHook, 整数型

    hHook ＝ GetPropA (hwndParent, “SetMessageBoxHook_hHook”)
    .如果真 (hHook ≠ #NULL)
        .如果真 (UnhookWindowsHookEx (hHook))
            RemovePropA (hwndParent, “SetMessageBoxHook_hHook”)
            返回 (真)
        .如果真结束
        
    .如果真结束
    返回 (假)

.子程序 窗口_清除视觉样式, 逻辑型, 公开, 清除通用组件库6.0的视觉样式
    .参数 窗口句柄, 整数型

    返回 (SetWindowTheme (窗口句柄, { 0, 0 }, { 0, 0 }) ＝ #S_OK)

.子程序 窗口_禁用控制按钮, 逻辑型, 公开, 禁用指定的控制按钮
    .参数 窗口句柄, 整数型
    .参数 控制按钮, 整数型, , 1、关闭按钮 2、最小化 3、最大化
    .局部变量 hMenu, 整数型
    .局部变量 uPosition, 整数型

    hMenu ＝ GetSystemMenu (窗口句柄, 0) ' FALSE
    .如果真 (hMenu ≠ #NULL 且 控制按钮 ≥ 1 且 控制按钮 ≤ 3)
        uPosition ＝ 多项选择 (控制按钮, #SC_CLOSE, #SC_MINIMIZE, #SC_MAXIMIZE)
        返回 (RemoveMenu (hMenu, uPosition, 0)) ' MF_BYCOMMAND
    .如果真结束
    返回 (假)

.子程序 窗口_深色模式, 逻辑型, 公开, 设置窗口深色模式
    .参数 窗口句柄, 整数型
    .参数 浅色模式, 逻辑型, 可空
    .局部变量 Build, 短整数型
    .局部变量 fEnable, 逻辑型
    .局部变量 hr, 整数型

    ' https://bbs.125.la/thread-14806112-1-1.html
    .如果 (_WIN32_WINNT ≥ #_WIN32_WINNT_WIN10 且 m_Build ≥ 22000)
        fEnable ＝ 取反 (浅色模式)
        hr ＝ DwmSetWindowAttribute (窗口句柄, #DWMWA_USE_IMMERSIVE_DARK_MODE, 取指针_通用型 (fEnable), 4)
        .如果真 (hr ≠ #S_OK)
            输出调试文本 (取错误信息文本_API (hr, “Dwmapi.dll”))
        .如果真结束
        返回 (hr ＝ #S_OK)
    .否则
        输出调试文本 (#ERROR_NOTVERSION)
    .如果结束
    返回 (假)

.版本 2

.程序集 集_自绘解析, , , 感谢会员【酷宝贝】提供Accessible接口
.子程序 自绘窗口_鼠标点击, , 公开, 对指定窗口指定坐标进行鼠标操作
    .参数 主窗口句柄, 整数型, 可空, 可空:为桌面超级列表框句柄 接收鼠标消息窗口句柄
    .参数 横坐标, 整数型, 可空, 可空:为原水平坐标不变 移动目标鼠标水平坐标 (注:坐标为参数一窗口句柄中的坐标)
    .参数 纵坐标, 整数型, 可空, 可空:为原垂直坐标不变 移动目标鼠标垂直坐标
    .参数 鼠标键, 整数型, 可空, 可空:为左键 1 #左键 2 #右键 3 #中键 4 #中键上滚动 5 #中键下滚动(滚动前后请按下放开中键)
    .参数 键状态, 整数型, 可空, 可空:为单击 1 #单击 2 #双击 3 #按下 4 #放开

    鼠标_消息 (主窗口句柄, 横坐标, 纵坐标, 鼠标键, 键状态)

.子程序 自绘窗口_投递文本, , 公开, 往指定的自绘投递文本
    .参数 主窗口句柄, 整数型
    .参数 投递内容, 文本型

    文本_投递 (主窗口句柄, 投递内容)

.子程序 自绘窗口_取信息, 文本型, 公开, 通过名称，状态，类型来获取相关的元素信息，如果需要更多信息请使用【自绘窗口_解析】 线程中调用请在线程头部加上  线程_初始化com库
    .参数 窗口句柄, 整数型, , 自绘窗口句柄
    .参数 控件名称, 文本型, , 自绘控件的名称
    .参数 控件状态, 文本型, , 自绘控件的状态
    .参数 控件类型, 文本型, , 自绘控件的类型
    .参数 获取类型, 整数型, 可空, 默认：0  0=控件描述，1=控件值，2控件大小，3控件相对主窗口位置，4=状态标识，5=类型标识
    .参数 返回索引, 整数型, 可空, 如果返回多个相同信息的，按传入索引返回信息，默认为1
    .局部变量 局_详细, 精易_详细信息
    .局部变量 局_对象, 类_Accessible, , "0"
    .局部变量 局_主对象, 类_Accessible
    .局部变量 局_索引对象, 类_Accessible
    .局部变量 局_位置, 精易_位置和大小
    .局部变量 句柄, 整数型
    .局部变量 局_左, 整数型
    .局部变量 局_顶, 整数型
    .局部变量 局_宽, 整数型
    .局部变量 局_高, 整数型
    .局部变量 局_左边, 整数型
    .局部变量 局_顶边, 整数型
    .局部变量 局_总数, 整数型

    .如果真 (是否为空 (返回索引))
        返回索引 ＝ 1
    .如果真结束
    
    .如果真 (返回索引 ＝ 0)
        返回索引 ＝ 1
    .如果真结束
    
    .如果真 (是否为空 (获取类型))
        获取类型 ＝ 0
    .如果真结束
    
    局_主对象.创建自窗口句柄 (窗口句柄)
    内部_查找指定元素 (局_主对象, 控件名称, 控件类型, 控件状态, 局_对象)
    局_总数 ＝ 取数组成员数 (局_对象)
    输出调试文本 (“共计取到” ＋ 到文本 (局_总数) ＋ “个信息”)
    .如果真 (局_总数 ＝ 0)
        返回 (“”)
    .如果真结束
    
    .如果真 (返回索引 ＞ 局_总数)
        返回索引 ＝ 1
    .如果真结束
    
    .如果 (局_总数 ＝ 1)
        局_索引对象 ＝ 局_对象 [1]
    .否则
        局_索引对象 ＝ 局_对象 [返回索引]
    .如果结束
    
    局_详细 ＝ 自绘窗口_格式化信息 (局_索引对象)
    .如果真 (获取类型 ＝ 0)
        返回 (局_详细.控件描述)
    .如果真结束
    .如果真 (获取类型 ＝ 1)
        返回 (局_详细.控件值)
    .如果真结束
    .如果真 (获取类型 ＝ 2)
        返回 (局_详细.窗口大小)
    .如果真结束
    .如果真 (获取类型 ＝ 3)
        局_索引对象.取位置 (局_左, 局_顶, 局_宽, 局_高)
        局_位置 ＝ 窗口_取位置和大小 (窗口句柄)
        局_左边 ＝ 局_左 － 局_位置.左边
        局_顶边 ＝ 局_顶 － 局_位置.顶边
        返回 (“左：” ＋ 到文本 (局_左边) ＋ “ 顶：” ＋ 到文本 (局_顶边))
    .如果真结束
    .如果真 (获取类型 ＝ 4)
        返回 (局_详细.状态标识)
    .如果真结束
    .如果真 (获取类型 ＝ 5)
        返回 (局_详细.类型标识)
    .如果真结束
    返回 (“”)

.子程序 内部_查找指定元素, 逻辑型, , 根据指定名称与角色文本在指定父元素中查找子元素对象  线程中调用请在线程头部加上  线程_初始化com库
    .参数 参数_根元素, 类_Accessible
    .参数 参数_名称, 文本型
    .参数 参数_角色文本, 文本型
    .参数 参数_状态文本, 文本型
    .参数 参数_返回的元素, 类_Accessible, 参考 数组
    .局部变量 count, 整数型
    .局部变量 child, 类_Accessible, , "0"
    .局部变量 局_对象, 类_Accessible
    .局部变量 i, 整数型
    .局部变量 左, 整数型
    .局部变量 顶, 整数型
    .局部变量 宽, 整数型
    .局部变量 高, 整数型
    .局部变量 局_状态, 文本型

    count ＝ 参数_根元素.枚举子元素 (child)
    .计次循环首 (count, i)
        局_对象 ＝ child [i]
        .如果真 (局_对象.取名称 () ＝ “昵称”)
            局_对象.取位置 (左, 顶, 宽, 高)
            
        .如果真结束
        
        .如果真 (局_对象.取名称 () ＝ 参数_名称)
            .如果真 (局_对象.取角色文本 () ＝ 参数_角色文本)
                局_状态 ＝ 文本_取左边 (局_对象.取状态文本 (), “,”)
                .如果真 (局_状态 ＝ 参数_状态文本)
                    加入成员 (参数_返回的元素, 局_对象)
                    返回 (真)
                .如果真结束
                
            .如果真结束
            
        .如果真结束
        
        .如果真 (局_对象.取子元素总数 () ≠ 0)
            内部_查找指定元素 (局_对象, 参数_名称, 参数_角色文本, 参数_状态文本, 参数_返回的元素)
        .如果真结束
        
    .计次循环尾 ()
    返回 (假)

.子程序 自绘窗口_格式化信息, 精易_详细信息, 公开, 获取指定对象下的相关元素信息  线程中调用请在线程头部加上  线程_初始化com库
    .参数 参_对象, 类_Accessible, , 指定自绘窗口的元素对象
    .局部变量 左, 整数型
    .局部变量 顶, 整数型
    .局部变量 宽, 整数型
    .局部变量 高, 整数型
    .局部变量 局_矩形, 矩形信息
    .局部变量 局_详细, 精易_详细信息
    .局部变量 rcWindow, 精易_位置和大小
    .局部变量 数量, 整数型
    .局部变量 局_标题, 文本型

    数量 ＝ 参_对象.取子元素总数 ()
    rcWindow ＝ 窗口_取位置和大小 (参_对象.取窗口句柄 ())
    参_对象.取位置 (左, 顶, 宽, 高)
    局_矩形.左边 ＝ 左
    局_矩形.顶边 ＝ 顶
    局_矩形.宽度 ＝ 宽
    局_矩形.高度 ＝ 高
    局_详细.控件ID ＝ 到文本 (参_对象.取ID ())
    局_详细.控件值 ＝ 参_对象.取值 ()
    局_详细.子窗口数 ＝ 到文本 (数量)
    局_详细.控件描述 ＝ 参_对象.取描述 ()
    .如果 (参_对象.取名称 () ＝ “”)
        局_标题 ＝ “NAMELESS”
    .否则
        局_标题 ＝ 参_对象.取名称 ()
    .如果结束
    
    局_详细.控件名称 ＝ 局_标题
    局_详细.控件状态 ＝ 参_对象.取状态文本 ()
    局_详细.控件类型 ＝ 参_对象.取角色文本 ()
    局_详细.屏幕位置 ＝ “左：” ＋ 到文本 (左) ＋ “ 顶：” ＋ 到文本 (顶)
    局_详细.窗口位置 ＝ “左：” ＋ 到文本 (左 － rcWindow.左边) ＋ “ 顶：” ＋ 到文本 (顶 － rcWindow.顶边)
    局_详细.窗口大小 ＝ “宽：” ＋ 到文本 (宽) ＋ “ 高：” ＋ 到文本 (高)
    局_详细.矩形信息 ＝ 局_矩形
    局_详细.默认动作 ＝ 参_对象.取默认动作 ()
    局_详细.状态标识 ＝ 到文本 (参_对象.取状态 ())
    局_详细.类型标识 ＝ 到文本 (参_对象.取角色 ())
    返回 (局_详细)

.子程序 自绘窗口_解析, 逻辑型, 公开, 枚举指定自绘窗口元素信息  线程中调用请在线程头部加上  线程_初始化com库
    .参数 窗口句柄, 整数型
    .参数 类型标识, 文本型, 可空, 指定自绘窗口的类型标识  支持多类型 | 间隔与结尾 如：“42|16|”   单个标识“42|”
    .参数 状态标识, 文本型, 可空, 指定自绘窗口的状态标识  支持多类型 | 间隔与结尾 如：“0|32768|” 单个标识“32768|”
    .参数 是否可见, 逻辑型, 可空, 如果传入的状态标识包含 32768 与 32769 此参数请留空
    .参数 元素信息, 精易_详细信息, 参考 数组, 返回解析的元素控件所有信息数组
    .局部变量 局_对象, 类_Accessible, , , 当前窗口元素
    .局部变量 局_对象数组, 类_Accessible, , "0", 枚举子元素
    .局部变量 局_详细, 精易_详细信息

    清除数组 (元素信息)
    .如果真 (局_对象.创建自窗口句柄 (窗口句柄) ＝ 假)
        返回 (假)
    .如果真结束
    
    .如果 (是否为空 (类型标识))
        类型标识 ＝ “-1”
    .否则
        类型标识 ＝ “|” ＋ 类型标识
    .如果结束
    
    .如果 (是否为空 (状态标识))
        状态标识 ＝ “-1”
    .否则
        状态标识 ＝ “|” ＋ 状态标识
    .如果结束
    
    局_对象.枚举子元素 (局_对象数组)
    内部_递归解析元素 (类型标识, 状态标识, 是否可见, 元素信息, 局_对象数组)
    返回 (真)

.子程序 内部_递归解析元素, , , 递归条件解析窗口
    .参数 参_类型标识, 文本型, 可空
    .参数 参_状态标识, 文本型, 可空
    .参数 是否可见, 逻辑型, 可空
    .参数 参_详细数组, 精易_详细信息, 参考 数组
    .参数 参_对象, 类_Accessible, 数组
    .局部变量 局_数组, 类_Accessible, , "0"
    .局部变量 局_计次, 整数型
    .局部变量 局_对象, 类_Accessible
    .局部变量 局_总数, 整数型
    .局部变量 局_数量, 整数型
    .局部变量 局_详细, 精易_详细信息
    .局部变量 局_状态, 整数型
    .局部变量 局_类型, 整数型
    .局部变量 局_是否符合类型, 整数型
    .局部变量 局_是否符合状态, 整数型
    .局部变量 局_可见, 逻辑型

    局_总数 ＝ 取数组成员数 (参_对象)
    .计次循环首 (局_总数, 局_计次)
        局_对象 ＝ 参_对象 [局_计次]
        ' ————————————————————————————————————————’
        局_状态 ＝ 局_对象.取状态 ()
        局_类型 ＝ 局_对象.取角色 ()
        .如果真 (是否可见)
            .如果真 (局_状态 ＝ 32768 或 局_状态 ＝ 32769) ' 不可见 与  不可见不可用
                到循环尾 ()
            .如果真结束
            
        .如果真结束
        
        .如果真 (参_类型标识 ≠ “-1”) ' 传了类型
            局_是否符合类型 ＝ 寻找文本 (参_类型标识, “|” ＋ 到文本 (局_类型) ＋ “|”, , 假)
        .如果真结束
        
        .如果真 (参_状态标识 ≠ “-1”) ' 传了状态
            局_是否符合状态 ＝ 寻找文本 (参_状态标识, “|” ＋ 到文本 (局_状态) ＋ “|”, , 假)
        .如果真结束
        
        
        .判断开始 (参_类型标识 ≠ “-1” 且 参_状态标识 ≠ “-1” 且 局_是否符合类型 ≠ -1 且 局_是否符合状态 ≠ -1) ' 都传了值且都找到了
            局_详细 ＝ 自绘窗口_格式化信息 (局_对象)
            加入成员 (参_详细数组, 局_详细)
        .判断 (参_类型标识 ≠ “-1” 且 参_状态标识 ＝ “-1” 且 局_是否符合类型 ≠ -1) ' 只传了类型 没状态 且找到了对应的类型
            局_详细 ＝ 自绘窗口_格式化信息 (局_对象)
            加入成员 (参_详细数组, 局_详细)
        .判断 (参_状态标识 ≠ “-1” 且 参_类型标识 ＝ “-1” 且 局_是否符合状态 ≠ -1) ' 只传了状态 没类型 且找到了对应的状态
            局_详细 ＝ 自绘窗口_格式化信息 (局_对象)
            加入成员 (参_详细数组, 局_详细)
        .判断 (参_类型标识 ＝ “-1” 且 参_状态标识 ＝ “-1”) ' 都没传 直接加入
            局_详细 ＝ 自绘窗口_格式化信息 (局_对象)
            加入成员 (参_详细数组, 局_详细)
        .默认
            ' 都没找到
        .判断结束
        
        局_数量 ＝ 局_对象.取子元素总数 ()
        .如果真 (局_数量 ≠ 0)
            局_对象.枚举子元素 (局_数组)
            内部_递归解析元素 (参_类型标识, 参_状态标识, 是否可见, 参_详细数组, 局_数组)
        .如果真结束
        
    .计次循环尾 ()
    

.子程序 _取对象指针, 整数型
    .参数 参数_对象, 对象, 参考

    置入代码 ({ 139, 69, 8, 139, 0, 139, 0, 201, 194, 4, 0 })
    ' mov eax,[ebp+08]
    ' mov eax,[eax]
    ' mov eax,[eax]
    ' leave
    ' retn 04
    返回 (0)

.子程序 _取对象指针的地址, 整数型
    .参数 参数_对象, 对象, 参考

    置入代码 ({ 139, 69, 8, 139, 0, 201, 194, 4, 0 })
    ' mov eax,[ebp+08]
    ' mov eax,[eax]
    ' leave
    ' retn 04
    
    返回 (0)
    

.版本 2

.程序集 ADSL拨号类, , 公开
.程序集变量 集_链接句柄, 整数型

.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
    

.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
    

.子程序 _取本机IP, 整数型, 公开, 返回IP的个数，如2:本地IP和外网IP
    .参数 IP数组, 文本型, 数组, 用于装载IP的文本数组
    .局部变量 ulOutBufLen
    .局部变量 AdapterInfo, IP_ADAPTER_INFO
    .局部变量 pAdapterInfo
    .局部变量 addr, 整数型
    .局部变量 buf_ip, IP_ADDR_STRING
    .局部变量 Success
    .局部变量 pAdapter, 整数型

    GetAdaptersInfo (0, ulOutBufLen)
    pAdapterInfo ＝ GlobalAlloc (64, ulOutBufLen)
    Success ＝ GetAdaptersInfo (pAdapterInfo, ulOutBufLen)
    pAdapter ＝ pAdapterInfo
    .如果真 (Success ＝ 0)
        .循环判断首 ()
            CopyMemory_ip_adapter_info (AdapterInfo, pAdapter, 640)
            加入成员 (IP数组, 到文本 (AdapterInfo.IpAddressList.IpAddress))
            pAdapter ＝ AdapterInfo.Next
        .循环判断尾 (pAdapter ≠ 0)
    .如果真结束
    GlobalFree (pAdapterInfo)
    返回 (取数组成员数 (IP数组))

.子程序 取外网IP, 文本型, 公开, 获取本机的外网IP
    返回 (系统_取外网IP ())

.子程序 重拨, 文本型, 公开, 重拨成功返回外网IP，失败返回空文本
    .参数 连接名称, 文本型, 可空, 可空,默认为 宽带连接  已建立的拨号连接的名称
    .参数 用户名, 文本型, , 用于拨号的用户名
    .参数 密码, 文本型, , 用于拨号的密码
    .局部变量 局_数组, 文本型, , "0"

    .如果真 (是否为空 (连接名称))
        连接名称 ＝ “宽带连接”
    .如果真结束
    .如果真 (取连接状态 (连接名称))
        .如果真 (断开 () ＝ 假)
            断开_cmd (连接名称)
        .如果真结束
        
    .如果真结束
    .如果真 (拨号 (连接名称, 用户名, 密码) ＝ 0)
        返回 (“”)
    .如果真结束
    _取本机IP (局_数组)
    .如果真 (取数组成员数 (局_数组) ≥ 2)
        返回 (局_数组 [2])
    .如果真结束
    返回 (“”)

.子程序 拨号, 整数型, 公开, 通过拨号建立网络连接，成功返回连接句柄，失败返回0
    .参数 连接名称, 文本型, , 已建立的拨号连接的名称,一般为 宽带连接
    .参数 用户名, 文本型, , 用于拨号的用户名
    .参数 密码, 文本型, , 用于拨号的密码
    .局部变量 ras, ADSL拨号0

    集_链接句柄 ＝ 0
    ras.结构的大小 ＝ 1052
    RtlMoveMemory (取数据_通用型_数组 (ras.访问的入口名), 取指针_文本型 (连接名称), 取文本长度 (连接名称))
    RtlMoveMemory (取数据_通用型_数组 (ras.指定用户名称), 取指针_文本型 (用户名), 取文本长度 (用户名))
    RtlMoveMemory (取数据_通用型_数组 (ras.指定用户密码), 取指针_文本型 (密码), 取文本长度 (密码))
    RasDialA (0, 0, ras, 0, 0, 集_链接句柄)
    .如果真 (集_链接句柄 ＝ 0)
        RasDialA (0, 0, ras, 0, 0, 集_链接句柄)
    .如果真结束
    返回 (集_链接句柄)

.子程序 断开, 逻辑型, 公开, 断开当前拨号网络连接
    返回 (RasHangUpA (集_链接句柄) ＝ 0)

.子程序 重拨_cmd, , 公开, 宽带重拨，cmd方式
    .参数 宽带名称, 文本型, 可空, 可空。默认为“宽带连接”
    .参数 用户名称, 文本型
    .参数 用户密码, 文本型

    .如果真 (是否为空 (宽带名称))
        宽带名称 ＝ “宽带连接”
    .如果真结束
    断开_cmd (宽带名称)
    拨号_cmd (宽带名称, 用户名称, 用户密码)

.子程序 拨号_cmd, , 公开, CMD方式拨号
    .参数 宽带名称, 文本型, 可空, 可空。默认为“宽带连接”
    .参数 用户名称, 文本型
    .参数 用户密码, 文本型

    .如果真 (是否为空 (宽带名称))
        宽带名称 ＝ “宽带连接”
    .如果真结束
    运行 (“rasdial ” ＋ #引号 ＋ 宽带名称 ＋ #引号 ＋ “ ” ＋ #引号 ＋ 用户名称 ＋ #引号 ＋ “ ” ＋ #引号 ＋ 用户密码 ＋ #引号, 真, 1)

.子程序 断开_cmd, 逻辑型, 公开, 断开宽带连接，cmd方式。
    .参数 连接名称, 文本型, 可空, 可空,默认为“宽带连接”。已建立的拨号连接的名称

    .如果真 (删首尾空 (连接名称) ＝ “”)
        连接名称 ＝ “宽带连接”
    .如果真结束
    返回 (运行 (“rasphone -h ” ＋ #引号 ＋ 连接名称 ＋ #引号, 真, #隐藏窗口)) ' cmd断开连接方式

.子程序 取连接名称, 文本型, 公开, 利用索引取出电脑中拨号的连接名称，成功返回连接名称，失败返回空文本
    .参数 连接索引, 整数型, , 欲取名称的连接索引 索引从1开始 最大到10 
    .参数 所有名称数组, 文本型, 参考 可空 数组, 存放所有连接名称的文本数组
    .局部变量 连接信息, 取连接信息用结构, , "99"
    .局部变量 lpcb, 整数型
    .局部变量 连接数, 整数型
    .局部变量 i, 整数型

    .如果真 (连接索引 ＞ 10 或 连接索引 ＜ 1)
        返回 (“”)
    .如果真结束
    连接信息 [1].内存大小 ＝ GlobalSize_取连接信息用结构 (连接信息 [1])
    lpcb ＝ 连接信息 [1].内存大小 × 256
    RasEnumEntries (0, 0, 连接信息, lpcb, 连接数)
    .如果真 (是否为空 (所有名称数组))
        返回 (到文本 (连接信息 [连接索引].拨号连接名称))
    .如果真结束
    .计次循环首 (连接数, i)
        加入成员 (所有名称数组, 到文本 (连接信息 [i].拨号连接名称))
    .计次循环尾 ()
    .如果真 (连接索引 ＞ 0 且 连接索引 ≤ 取数组成员数 (所有名称数组))
        返回 (所有名称数组 [连接索引])
    .如果真结束
    返回 (“”)

.子程序 取连接数量, 整数型, 公开, 取系统中已经建立的连接数量
    .局部变量 连接信息, 取连接信息用结构, , "99", 假设最多99个连接
    .局部变量 lpcb, 整数型, , , 电话本名称,0
    .局部变量 连接数, 整数型

    连接信息 [1].内存大小 ＝ GlobalSize_取连接信息用结构 (连接信息 [1])
    lpcb ＝ 连接信息 [1].内存大小 × 256
    RasEnumEntries (0, 0, 连接信息, lpcb, 连接数)
    返回 (连接数)

.子程序 取连接状态, 逻辑型, 公开, 判断指定的连接是否已连接，如果已连接返回真，否则返回假;
    .参数 连接名称, 文本型, , 欲判断的连接名称
    .局部变量 连接信息, 文本型
    .局部变量 dwFlags, 整数型
    .局部变量 sNameBuf, 文本型
    .局部变量 lR, 整数型

    sNameBuf ＝ 取空白文本 (513)
    lR ＝ InternetGetConnectedStateEx (dwFlags, sNameBuf, 512, 0)
    .如果真 (lR ≠ 1) ' 无连接 (这个连接并不一定是通外网，可能是连接路由器等设备)
        返回 (假)
    .如果真结束
    .如果真 (连接名称 ≠ 删首尾空 (sNameBuf))
        返回 (假)
    .如果真结束
    返回 (真)

.子程序 连接是否存在, 逻辑型, 公开, 如果指定的连接名称存在返回真，否则返回假;
    .参数 连接名称, 文本型, , 欲判断的连接名称
    .局部变量 连接信息, 取连接信息用结构, , "99"
    .局部变量 lpcb, 整数型
    .局部变量 连接数, 整数型
    .局部变量 局_计次, 整数型

    连接信息 [1].内存大小 ＝ GlobalSize_取连接信息用结构 (连接信息 [1])
    lpcb ＝ 连接信息 [1].内存大小 × 256
    RasEnumEntries (0, 0, 连接信息, lpcb, 连接数)
    .计次循环首 (连接数, 局_计次)
        .如果真 (到文本 (连接信息 [局_计次].拨号连接名称) ＝ 连接名称)
            返回 (真)
        .如果真结束
        
    .计次循环尾 ()
    返回 (假)

.子程序 断开所有连接, , 公开
    .局部变量 tmp, 文本型, , "0"
    .局部变量 局_计次, 整数型

    取连接名称 (1, tmp)
    .计次循环首 (取数组成员数 (tmp), 局_计次)
        运行 (“rasphone -h ” ＋ tmp [局_计次], 假, #隐藏窗口)
    .计次循环尾 ()

.子程序 创建新拨号连接, 逻辑型, 公开, 建立一个ADS拨号连接，成功反回真，失败返回假;
    .参数 连接名称, 文本型, , 拨号连接的名称,可自定义,如"我的ADSL连接"
    .参数 用户名, 文本型, 可空, 用于拨号的用户名
    .参数 密码, 文本型, 可空, 用于拨号的密码
    .参数 拨号类型, 整数型, 可空, 可空,默认为1  1=PPPoE虚拟拨号  2=电话拨号
    .局部变量 re, 创建连接所用结构
    .局部变量 sDeviceName, 文本型
    .局部变量 sDeviceType, 文本型

    .如果真 (是否为空 (拨号类型))
        拨号类型 ＝ 1
    .如果真结束
    sDeviceName ＝ “WAN 微型端口 (PPPOE)” ' 设备名称  内容和系统盘下的 rasphone.pbk 文件相同
    sDeviceType ＝ “PPPoE” ' 设备类型
    re.dwSize ＝ 2884
    re.dwCountryCode ＝ 86
    re.dwCountryID ＝ 86
    re.dwDialExtraPercent ＝ 75
    re.dbh5uy ＝ 120
    re.dwDialMode ＝ 1
    re.sdr5uyhbd ＝ 3
    re.hr57hfb ＝ 4
    re.dwfOptions ＝ 1024262928 － 256 ' 去掉托盘显示  RASEO_ModemLights As Long = &H100
    re.dwfOptions2 ＝ 367
    re.dwFramingProtocol ＝ 1
    re.dwHangUpExtraPercent ＝ 10
    re.dwHangUpExtraSampleSeconds ＝ 120
    re.dwRedialCount ＝ 3 ' 重拨次数
    re.dwRedialPause ＝ 5 ' 重拨间隔 5ms
    re.dwType ＝ 选择 (拨号类型 ＝ 1, 5, 1) ' 1为拨号连接,5为宽带虚拟拨号,4为连接管理器
    RtlMoveMemory (取数据_通用型_数组 (re.szDeviceType), 取指针_文本型 (sDeviceType), 取文本长度 (sDeviceType))
    RtlMoveMemory (取数据_通用型_数组 (re.szDeviceName), 取指针_文本型 (sDeviceName), 取文本长度 (sDeviceName))
    .如果真 (RasSetEntryPropertiesA (0, 连接名称, re, re.dwSize, 0, 0) ＝ 0)
        .如果真 (是否为空 (用户名)) ' 如果没有提供用户名,即创建完成
            返回 (真)
        .如果真结束
        .如果真 (设置拨号连接 (连接名称, 用户名, 密码)) ' 提供了用户名,即用rc类型设置连接,rc中包含用户名密码结构
            返回 (真)
        .如果真结束
        
    .如果真结束
    返回 (假)

.子程序 设置拨号连接, 逻辑型, 公开, 设置已经存在的连接的用户名或密码
    .参数 连接名称, 文本型, , 已建立的拨号连接的名称
    .参数 用户名, 文本型, , 用于拨号的用户名,留空将不写入连接中
    .参数 密码, 文本型, 可空, 用于拨号的密码
    .局部变量 rc, 设置拨号所以结构

    rc.dsubr ＝ 540
    rc.dwMask ＝ 11
    RtlMoveMemory (取数据_通用型_数组 (rc.szUserName), 取指针_文本型 (用户名), 取文本长度 (用户名))
    RtlMoveMemory (取数据_通用型_数组 (rc.szPassword), 取指针_文本型 (密码), 取文本长度 (密码))
    .如果 (RasSetCredentialsA (0, 连接名称, rc, 0) ＝ 0)
        返回 (真)
    .否则
        返回 (假)
    .如果结束
    

.子程序 删除拨号连接, , 公开
    .参数 连接名称, 文本型

    运行 (“rasphone -h ” ＋ 连接名称, 假, #隐藏窗口) ' 先挂断连接
    运行 (“rasphone -r ” ＋ 连接名称, 假, #隐藏窗口) ' 删除连接

.子程序 取宽带用户名密码, 逻辑型, 公开, 成功返回真，失败返回假  注：只有ADSL拨号上网的才能取
    .参数 连接名称, 文本型, 可空, 请提供一个文本变量,用于存放 连接名称
    .参数 宽带用户名, 文本型, 可空, 请提供一个文本变量,用于存放 宽带用户名
    .参数 宽带密码, 文本型, 可空, 请提供一个文本变量,用于存放 宽带密码

    返回 (系统_取宽带用户名密码 (连接名称, 宽带用户名, 宽带密码))

.版本 2

.程序集 注册表操作, , 公开
.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
    

.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
    

.子程序 _打开项, 整数型
    .参数 项名称, 文本型
    .参数 是否创建, 逻辑型, 可空, 默认为假:打开 真:如果项不存在则创建项
    .局部变量 局_根句柄, 整数型
    .局部变量 局_项句柄, 整数型
    .局部变量 局_项文本, 文本型
    .局部变量 局_位置, 整数型
    .局部变量 b, 整数型

    局_位置 ＝ 寻找文本 (项名称, “\”, , 假)
    局_项文本 ＝ 取文本左边 (项名称, 局_位置 － 1)
    局_项文本 ＝ 到大写 (局_项文本)
    .判断开始 (局_项文本 ＝ “HKEY_CLASSES_ROOT”)
        局_根句柄 ＝ 2147483648
    .判断 (局_项文本 ＝ “HKEY_CURRENT_USER”)
        局_根句柄 ＝ 2147483649
    .判断 (局_项文本 ＝ “HKEY_LOCAL_MACHINE”)
        局_根句柄 ＝ 2147483650
    .判断 (局_项文本 ＝ “HKEY_USERS”)
        局_根句柄 ＝ 2147483651
    .判断 (文本比较 (局_项文本, “HKEY_CURRENT_CONFIG”, 假) ＝ 0)
        局_根句柄 ＝ 2147483653
    .默认
        返回 (0)
    .判断结束
    .如果 (是否创建)
        b ＝ RegCreateKeyA (局_根句柄, 取文本右边 (项名称, 取文本长度 (项名称) － 局_位置), 局_项句柄)
    .否则
        b ＝ RegOpenKeyA (局_根句柄, 取文本右边 (项名称, 取文本长度 (项名称) － 局_位置), 局_项句柄)
    .如果结束
    .如果真 (b ＝ 0)
        返回 (局_项句柄)
    .如果真结束
    返回 (0)

.子程序 枚举子项, 整数型, 公开, 枚举指定项名称下的子项(成功返回子项目数,失败返回-1)
    .参数 项名称, 文本型
    .参数 子项, 文本型, 可空 数组, 获取的子项数组
    .局部变量 局_a, 整数型
    .局部变量 局_计次, 整数型
    .局部变量 局_项名, 文本型

    清除数组 (子项)
    局_a ＝ _打开项 (项名称)
    .如果真 (局_a ＝ 0)
        返回 (-1)
    .如果真结束
    局_项名 ＝ 取空白文本 (256)
    .判断循环首 (RegEnumKeyA (局_a, 局_计次, 局_项名, 256) ＝ 0)
        加入成员 (子项, 局_项名)
        局_计次 ＝ 局_计次 ＋ 1
        处理事件 ()
    .判断循环尾 ()
    RegCloseKey (局_a)
    返回 (取数组成员数 (子项))

.子程序 枚举键名, 整数型, 公开, 枚举指定项名称下的键名(成功返回键名数,失败返回-1)
    .参数 项名称, 文本型
    .参数 键名, 文本型, 可空 数组, 获取的键名数组
    .参数 键值, 字节集, 可空 数组, 对应键名的键值
    .参数 类型, 整数型, 可空 数组, 对应键值的类型
    .局部变量 局_项句柄, 整数型
    .局部变量 局_计次, 整数型
    .局部变量 缓存键名, 文本型
    .局部变量 缓存键值, 字节集
    .局部变量 局_键值缓寸, 整数型
    .局部变量 局_类型, 整数型
    .局部变量 ftime, FILETIME
    .局部变量 局_子键数量, 整数型
    .局部变量 局_返回值

    清除数组 (键名)
    清除数组 (键值)
    清除数组 (类型)
    局_项句柄 ＝ _打开项 (项名称)
    .如果真 (局_项句柄 ＝ 0)
        返回 (-1)
    .如果真结束
    局_返回值 ＝ RegQueryInfoKey (局_项句柄, 字符 (0), 字符 (0), 0, 0, 0, 0, 局_子键数量, 0, 0, 0, ftime)
    .如果真 (局_返回值 ＝ 0)
        缓存键名 ＝ 取空白文本 (256)
        .变量循环首 (0, 局_子键数量 － 1, 1, 局_计次)
            RegEnumValueA (局_项句柄, 局_计次, 缓存键名, 256, 0, 局_类型, 缓存键值, 局_键值缓寸)
            缓存键值 ＝ 取空白字节集 (局_键值缓寸 ＋ 1)
            局_返回值 ＝ RegEnumValueA (局_项句柄, 局_计次, 缓存键名, 256, 0, 局_类型, 缓存键值, 局_键值缓寸)
            .如果真 (局_返回值 ＝ 0)
                加入成员 (键名, 缓存键名)
                加入成员 (键值, 缓存键值)
                加入成员 (类型, 局_类型)
            .如果真结束
            
        .变量循环尾 ()
    .如果真结束
    RegCloseKey (局_项句柄)
    返回 (取数组成员数 (键名))

.子程序 取键名类型, 文本型, 公开, 失败返回空文本
    .参数 项名称, 文本型, , 如：HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\NetBT\Parameters
    .参数 键名, 文本型, 可空, 如：3600，留空将取第一个，(默认)
    .局部变量 局_项句柄, 整数型
    .局部变量 局_类型, 整数型
    .局部变量 缓存键值, 字节集
    .局部变量 局_键值缓寸, 整数型
    .局部变量 局_计次, 整数型
    .局部变量 缓存键名, 文本型

    局_项句柄 ＝ _打开项 (项名称)
    缓存键名 ＝ 取空白文本 (256)
    .判断循环首 (RegEnumValueA (局_项句柄, 局_计次, 缓存键名, 256, 0, 局_类型, 缓存键值, 局_键值缓寸) ＝ 0)
        .如果真 (缓存键名 ＝ 键名)
            跳出循环 ()
        .如果真结束
        局_计次 ＝ 局_计次 ＋ 1
        局_类型 ＝ -1
    .判断循环尾 ()
    .判断开始 (局_类型 ＝ 0)
        返回 (“REG_NONE - 字节集，值为：” ＋ 到文本 (局_类型))
    .判断 (局_类型 ＝ 1)
        返回 (“REG_SZ - 字符串值，值为：” ＋ 到文本 (局_类型))
    .判断 (局_类型 ＝ 2)
        返回 (“REG_REG_EXPAND_SZ - 可扩充字符串值，值为：” ＋ 到文本 (局_类型))
    .判断 (局_类型 ＝ 3)
        返回 (“REG_BINARY - 二进制，值为：” ＋ 到文本 (局_类型))
    .判断 (局_类型 ＝ 4)
        返回 (“REG_DWORD - DWORD，值为：” ＋ 到文本 (局_类型))
    .判断 (局_类型 ＝ 7)
        返回 (“REG_MULTI_SZ - 多字符串值，值为：” ＋ 到文本 (局_类型))
    .默认
        
    .判断结束
    RegCloseKey (局_项句柄)
    返回 (“”)

.子程序 是否存在, 逻辑型, 公开, 判断指定注册项名称(键名)是否存在(存在返回真,否则返回假)
    .参数 项名称, 文本型, , 欲判断的项名称
    .参数 键名, 文本型, 可空, 欲判断的键名.如果为空则只判断项名称是否存在
    .局部变量 a, 整数型
    .局部变量 b, 整数型
    .局部变量 值, 字节集

    a ＝ _打开项 (项名称)
    .如果真 (是否为空 (键名))
        RegCloseKey (a)
        返回 (a ≠ 0)
    .如果真结束
    值 ＝ 取空白字节集 (256)
    b ＝ RegQueryValueExA (a, 键名, 0, 0, 值, 256)
    RegCloseKey (a)
    返回 (b ＝ 0)

.子程序 刷新项, 逻辑型, 公开, 将对项和它的子项作出的改动实际写入磁盘
    .参数 项名称, 文本型
    .局部变量 a, 整数型
    .局部变量 b, 整数型
    .局部变量 值, 字节集

    a ＝ _打开项 (项名称)
    .如果真 (a ＝ 0)
        返回 (假)
    .如果真结束
    b ＝ RegFlushKey (a)
    RegCloseKey (a)
    返回 (b ＝ 0)

.子程序 写字节集, 逻辑型, 公开, [REG_NONE]
    .参数 项名称, 文本型
    .参数 键名, 文本型
    .参数 欲写入值, 字节集
    .参数 类型, 整数型, 可空, 可空：写入的类型
    .局部变量 项句柄, 整数型
    .局部变量 b, 整数型
    .局部变量 值, 字节集

    项句柄 ＝ _打开项 (项名称, 真)
    .如果真 (项句柄 ＝ 0)
        返回 (假)
    .如果真结束
    b ＝ RegSetValueExA (项句柄, 键名, 0, 类型, 欲写入值, 取字节集长度 (欲写入值))
    RegCloseKey (项句柄)
    返回 (b ＝ 0)

.子程序 取字节集, 字节集, 公开, [REG_NONE]
    .参数 项名称, 文本型
    .参数 键名, 文本型
    .参数 类型, 整数型, 参考 可空, 可空：取出数据的类型
    .局部变量 项句柄, 整数型
    .局部变量 项值, 整数型
    .局部变量 值, 字节集
    .局部变量 长, 整数型

    项句柄 ＝ _打开项 (项名称)
    .如果真 (项句柄 ＝ 0)
        返回 ({ })
    .如果真结束
    项值 ＝ RegQueryValueExA (项句柄, 键名, 0, 类型, 值, 长)
    值 ＝ 取空白字节集 (长)
    项值 ＝ RegQueryValueExA (项句柄, 键名, 0, 类型, 值, 长)
    RegCloseKey (项句柄)
    .如果真 (项值 ＝ 0)
        返回 (值)
    .如果真结束
    返回 ({ })

.子程序 写注册项Ex, 逻辑型, 公开, 用于写入带有斜杠的注册项
    .参数 根目录, 整数型, , 可以为以下常量值之一：1、#根类；2、#现行设置；3、#现行用户；4、#本地机器；5、#所有用户。
    .参数 注册表路径, 文本型
    .参数 注册表子项名, 文本型
    .参数 欲写入值, 字节集
    .参数 写入类型, 整数型, 可空, #REG_
    .局部变量 root, 整数型
    .局部变量 hkey, 整数型
    .局部变量 hsubkey, 整数型
    .局部变量 ret, 逻辑型

    .如果真 (是否为空 (写入类型))
        写入类型 ＝ 1
    .如果真结束
    .如果真 (根目录 ＞ 0 且 根目录 ≤ 5)
        root ＝ 多项选择 (根目录, #HKEY_CLASSES_ROOT, #HKEY_CURRENT_CONFIG, #HKEY_CURRENT_USER, #HKEY_LOCAL_MACHINE, #HKEY_USERS)
        .如果真 (RegOpenKeyExA (root, “”, 0, 位或 (131097, 131078), hkey) ＝ 0)
            .如果真 (RegCreateKeyExA (hkey, 注册表路径, 0, 0, 0, 位或 (131097, 131078), 0, hsubkey, 0) ＝ 0)
                .如果真 (RegSetValueExA (hsubkey, 注册表子项名, 0, 写入类型, 欲写入值, 取字节集长度 (欲写入值)) ＝ 0)
                    ret ＝ 真
                .如果真结束
                RegCloseKey (hsubkey)
            .如果真结束
            RegCloseKey (hkey)
        .如果真结束
        
    .如果真结束
    返回 (ret)

.子程序 写DWORD值, 逻辑型, 公开, [REG_DWORD]成功返回真,失败返回假
    .参数 项名称, 文本型, , 如：HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\NetBT\Parameters
    .参数 键名, 文本型, , 如：3600
    .参数 欲写入值, 整数型, , 如：0

    返回 (写字节集 (项名称, 键名, 到字节集 (欲写入值), 4))

.子程序 取DWORD值, 整数型, 公开, [REG_DWORD]
    .参数 项名称, 文本型, , 如：HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\NetBT\Parameters
    .参数 键名, 文本型, , 如：3600

    返回 (取字节集数据 (取字节集 (项名称, 键名, 4), #整数型, ))

.子程序 写二进制值, 逻辑型, 公开, [REG_BINARY]成功返回真,失败返回假
    .参数 项名称, 文本型, , 如：HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\NetBT\Parameters
    .参数 键名, 文本型, , 如：3600
    .参数 欲写入值, 字节集

    返回 (写字节集 (项名称, 键名, 欲写入值, 3))

.子程序 取二进制值, 字节集, 公开, [REG_BINARY]
    .参数 项名称, 文本型, , 如：HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\NetBT\Parameters
    .参数 键名, 文本型, , 如：3600

    返回 (取字节集 (项名称, 键名, 3))

.子程序 写字符串值, 逻辑型, 公开, [REG_SZ]成功返回真,失败返回假
    .参数 项名称, 文本型, , 如：HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\NetBT\Parameters
    .参数 键名, 文本型, , 如：3600
    .参数 欲写入值, 文本型

    返回 (写字节集 (项名称, 键名, 到字节集 (欲写入值) ＋ { 0 }, 1))

.子程序 取字符串值, 文本型, 公开, [REG_SZ]
    .参数 项名称, 文本型, , 如：HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\NetBT\Parameters
    .参数 键名, 文本型, , 如：3600

    返回 (到文本 (取字节集 (项名称, 键名, 1)))

.子程序 写多字符串值, 逻辑型, 公开, [REG_MULTI_SZ]成功返回真,失败返回假
    .参数 项名称, 文本型, , 如：HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\NetBT\Parameters
    .参数 键名, 文本型, , 如：3600
    .参数 欲写入值, 文本型

    返回 (写字节集 (项名称, 键名, 子字节集替换 (到字节集 (欲写入值), { 13, 10 }, { 0 }, , ) ＋ { 0, 0 }, 7))

.子程序 取多字符串值, 文本型, 公开, [REG_MULTI_SZ]
    .参数 项名称, 文本型, , 如：HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\NetBT\Parameters
    .参数 键名, 文本型, , 如：3600

    返回 (到文本 (子字节集替换 (取字节集 (项名称, 键名, 7), { 0 }, { 13, 10 }, , )))

.子程序 写可扩充字符串值, 逻辑型, 公开, [REG_EXPAND_SZ]成功返回真,失败返回假
    .参数 项名称, 文本型, , 如：HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\NetBT\Parameters
    .参数 键名, 文本型, , 如：3600
    .参数 欲写入值, 文本型

    返回 (写字节集 (项名称, 键名, 到字节集 (欲写入值) ＋ { 0 }, 2))

.子程序 取可扩充字符串值, 文本型, 公开, [REG_REG_EXPAND_SZ]
    .参数 项名称, 文本型
    .参数 键名, 文本型

    返回 (到文本 (取字节集 (项名称, 键名, 2)))

.子程序 删除项, 逻辑型, 公开, 删除指定项名称以及它的所有子项与键值
    .参数 项名称, 文本型, , 欲删除的项名称,尾部不要加"\"
    .局部变量 a, 整数型
    .局部变量 b, 整数型
    .局部变量 c, 整数型
    .局部变量 子项, 文本型, , "0"
    .局部变量 局_计次, 整数型

    .如果真 (取文本右边 (项名称, 1) ＝ “\”)
        返回 (假)
    .如果真结束
    c ＝ 倒找文本 (项名称, “\”, , 假)
    a ＝ _打开项 (取文本左边 (项名称, c))
    .如果真 (a ＝ 0)
        返回 (假)
    .如果真结束
    .计次循环首 (枚举子项 (项名称, 子项), 局_计次)
        删除项 (项名称 ＋ “\” ＋ 子项 [局_计次])
    .计次循环尾 ()
    b ＝ RegDeleteKeyA (a, 取文本右边 (项名称, 取文本长度 (项名称) － c))
    RegCloseKey (a)
    返回 (b ＝ 0)

.子程序 删除键名, 逻辑型, 公开, 删除指定项下的某个键名
    .参数 项名称, 文本型, , 欲删除键名所在的项名称
    .参数 键名, 文本型, , 欲删除的键名
    .局部变量 a, 整数型
    .局部变量 b, 整数型

    a ＝ _打开项 (项名称)
    .如果真 (a ＝ 0)
        返回 (假)
    .如果真结束
    b ＝ RegDeleteValueA (a, 键名)
    RegCloseKey (a)
    返回 (b ＝ 0)

.子程序 取字符串值_CMD, 文本型, 公开, 用CMD读取方式取指定字符串值
    .参数 项名称, 文本型, , 如：HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\NetBT\Parameters
    .参数 类型, 整数型, 可空, 如：#REG_SZ
    .参数 键名, 文本型, , 如：3600
    .局部变量 命令行, 文本型
    .局部变量 Type, 文本型

    ' https://bbs.125.la/forum.php?mod=redirect&goto=findpost&ptid=14302857&pid=15062805
    命令行 ＝ 系统_取DOS执行结果 (“REG QUERY ” ＋ 项名称 ＋ “ /v ” ＋ 键名 ＋ “ /reg:” ＋ 选择 (系统_是否64位操作系统 (), “64”, “32”))
    .如果真 (类型 ≤ 0 且 类型 ＞ 7)
        类型 ＝ #REG_SZ
    .如果真结束
    Type ＝ 多项选择 (类型, “REG_SZ”, “REG_EXPAND_SZ”, “REG_BINARY”, “REG_DWORD”, “REG_DWORD_BIG_ENDIAN”, “REG_LINK”, “REG_MULTI_SZ”)
    命令行 ＝ 文本_取出中间文本 (命令行, 键名 ＋ “    ” ＋ Type ＋ “    ”, #换行符, , )
    返回 (命令行)

.子程序 项重命名, 逻辑型, 公开, 成功返回真
    .参数 项名称, 文本型, , 如：HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\NetBT\Parameters
    .参数 新项名, 文本型, , 如：3600
    .局部变量 hKey, 整数型
    .局部变量 Unicode, 字节集
    .局部变量 NewName, UNICODE_STRING
    .局部变量 bRes, 整数型

    hKey ＝ _打开项 (项名称, 假)
    .如果真 (hKey ＝ 0)
        返回 (假)
    .如果真结束
    Unicode ＝ 编码_Ansi到Unicode (新项名, )
    RtlInitUnicodeString (NewName, Unicode)
    bRes ＝ NtRenameKey (hKey, NewName)
    RegCloseKey (hKey)
    返回 (bRes ＝ 0)

.版本 2

.程序集 注册表操作Ex, , 公开, 注册表操作,包括注册表的读,写.支持64位
.程序集变量 IsWow64, 逻辑型, , , 判断是否为64位系统,如果是则进行64位的读写操作
.程序集变量 m_Error, 整数型
.程序集变量 m_键句柄, 整数型, , , 记录句柄,在类销毁时释放
.程序集变量 m_是否已打开, 逻辑型
.程序集变量 m_当前键目录, 整数型
.程序集变量 m_当前键, 文本型

.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
    m_当前键 ＝ “”
    IsWow64Process (-1, IsWow64)

.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
    关闭键Ex ()

.子程序 方法_置为64位Ex_作废, , , 该方法只能在64位系统中调用,调用之后,将读取64位的注册表,否则默认为32位注册表
    m_当前键 ＝ “”
    IsWow64 ＝ 真

.子程序 方法_置为32位Ex_作废, , , 置为读写32位的注册表
    m_当前键 ＝ “”
    IsWow64 ＝ 假

.子程序 关闭键Ex, 整数型, 公开, 关闭一个已经打开的键句柄,关闭之后需要重新调用打开键Ex才能进行其他操作,如果已经关闭则返回-1
    .如果真 (m_是否已打开)
        m_Error ＝ RegCloseKey (m_键句柄)
        m_是否已打开 ＝ 假
        m_当前键 ＝ “”
        m_当前键目录 ＝ -1
        返回 (m_Error)
    .如果真结束
    返回 (-1)

.子程序 打开键Ex, 整数型, 公开, 如果键不存在,则失败.成功键的句柄,失败返回-1,通过取最后错误查看错误码;注意,使用该命令时,如果键已打开,则自动关闭键后在执行本操作
    .参数 键根目录, 整数型, , #HKEY_*开头的常量
    .参数 全路径注册项名, 文本型, , 完整的键路径,不包括"HKEY_*" 例如:SOFTWARE\Test
    .局部变量 局部_标志位, 整数型
    .局部变量 临时_句柄, 整数型
    .局部变量 重定向键, 文本型

    .如果真 (m_当前键目录 ＝ 键根目录 且 m_当前键 ＝ 全路径注册项名 且 m_是否已打开)
        返回 (m_键句柄)
    .如果真结束
    
    关闭键Ex ()
    .如果 (IsWow64) ' ; 64位注册表
        局部_标志位 ＝ #KEY_WOW64_64KEY
    .否则
        局部_标志位 ＝ #KEY_WOW64_32KEY
    .如果结束
    局部_标志位 ＝ 位或 (局部_标志位, #KEY_ALL_ACCESS)
    ' 注意:这里的samDesired 采用的是  #KEY_ALL_ACCESS  全部权限
    
    .判断开始 (键根目录 ＝ #HKEY_CURRENT_USER)
        m_Error ＝ RegOpenCurrentUser (局部_标志位, 临时_句柄)
        .如果真 (m_Error ＝ #ERROR_SUCCESS)
            m_Error ＝ RegOpenKeyExA (临时_句柄, 全路径注册项名, 0, 局部_标志位, m_键句柄)
            RegCloseKey (临时_句柄)
        .如果真结束
        
        
    .判断 (键根目录 ＝ #HKEY_CURRENT_CONFIG)
        m_Error ＝ RegOpenKeyExA (#HKEY_LOCAL_MACHINE, “SYSTEM\CurrentControlSet\Hardware Profiles\Current”, 0, 局部_标志位, 临时_句柄)
        .如果真 (m_Error ＝ #ERROR_SUCCESS)
            m_Error ＝ RegOpenKeyExA (临时_句柄, 全路径注册项名, 0, 局部_标志位, m_键句柄)
            RegCloseKey (临时_句柄)
        .如果真结束
        
        
    .默认
        m_Error ＝ RegOpenKeyExA (键根目录, 全路径注册项名, 0, 局部_标志位, m_键句柄)
    .判断结束
    
    .如果真 (m_Error ＝ #ERROR_SUCCESS)
        m_是否已打开 ＝ 真
        m_当前键目录 ＝ 键根目录
        m_当前键 ＝ 全路径注册项名
        返回 (m_键句柄)
    .如果真结束
    返回 (-1)
    

.子程序 创建并打开键Ex, 整数型, 公开, 如果键不存在,则创建一个键之后打开,如果键存在则直接打开;返回键的句柄,失败返回-1,通过取最后错误查看错误码;
    .参数 键根目录, 整数型, , #HKEY_*开头的常量
    .参数 全路径注册项名, 文本型, , 完整的键路径,不包括"HKEY_*" 例如:SOFTWARE\Test
    .局部变量 局部_标志位, 整数型
    .局部变量 临时_句柄, 整数型

    ' REG_NONE                    ( 0 )   // No value type
    ' REG_SZ                      ( 1 )   // Unicode nul terminated string
    ' REG_EXPAND_SZ               ( 2 )   // Unicode nul terminated string
    ' // (with environment variable references)
    ' REG_BINARY                  ( 3 )   // Free form binary
    ' REG_DWORD                   ( 4 )   // 32-bit number
    ' REG_DWORD_LITTLE_ENDIAN     ( 4 )   // 32-bit number (same as REG_DWORD)
    ' REG_DWORD_BIG_ENDIAN        ( 5 )   // 32-bit number
    ' REG_LINK                    ( 6 )   // Symbolic Link (unicode)
    ' REG_MULTI_SZ                ( 7 )   // Multiple Unicode strings
    ' REG_RESOURCE_LIST           ( 8 )   // Resource list in the resource map
    ' REG_FULL_RESOURCE_DESCRIPTOR ( 9 )  // Resource list in the hardware description
    ' REG_RESOURCE_REQUIREMENTS_LIST ( 10 )
    ' 上面这些信息是键的类型,暂时先留着备用.
    .如果真 (m_当前键目录 ＝ 键根目录 且 m_当前键 ＝ 全路径注册项名)
        返回 (m_键句柄)
    .如果真结束
    
    关闭键Ex ()
    局部_标志位 ＝ #KEY_ALL_ACCESS
    .如果 (IsWow64) ' ; 64位注册表
        局部_标志位 ＝ 位或 (局部_标志位, #KEY_WOW64_64KEY)
    .否则
        局部_标志位 ＝ 位或 (局部_标志位, #KEY_WOW64_32KEY)
    .如果结束
    
    ' 注意:这里的samDesired 采用的是  #KEY_ALL_ACCESS  全部权限
    .判断开始 (键根目录 ＝ #HKEY_CURRENT_USER)
        m_Error ＝ RegOpenCurrentUser (局部_标志位, 临时_句柄)
        .如果真 (m_Error ＝ #ERROR_SUCCESS)
            m_Error ＝ RegCreateKeyExA (临时_句柄, 全路径注册项名, 0, 0, 1, 局部_标志位, #REG_OPTION_NON_VOLATILE, m_键句柄, 0) ' 忽略最后一项
            RegCloseKey (临时_句柄)
        .如果真结束
        
    .判断 (键根目录 ＝ #HKEY_CURRENT_CONFIG)
        m_Error ＝ RegOpenKeyExA (#HKEY_LOCAL_MACHINE, “SYSTEM\CurrentControlSet\Hardware Profiles\Current”, 0, 局部_标志位, 临时_句柄)
        
        .如果真 (m_Error ＝ #ERROR_SUCCESS)
            m_Error ＝ RegCreateKeyExA (临时_句柄, 全路径注册项名, 0, 0, #REG_OPTION_NON_VOLATILE, 局部_标志位, 0, m_键句柄, 0) ' 忽略最后一项
            RegCloseKey (临时_句柄)
        .如果真结束
        
    .默认
        
        m_Error ＝ RegCreateKeyExA (键根目录, 全路径注册项名, 0, 0, #REG_OPTION_NON_VOLATILE, 局部_标志位, 0, m_键句柄, 0) ' 忽略最后一项
    .判断结束
    
    
    .如果真 (m_Error ＝ #ERROR_SUCCESS)
        m_是否已打开 ＝ 真
        m_当前键目录 ＝ 键根目录
        m_当前键 ＝ 全路径注册项名
        
        返回 (m_键句柄)
    .如果真结束
    
    返回 (-1)

.子程序 枚举子项Ex, 整数型, 公开, 枚举指定项名称下的子项(成功返回子项目数,失败返回-1);
    .参数 键根目录, 整数型, , #HKEY_*开头的常量
    .参数 全路径注册项名, 文本型, , 完整的键路径,不包括"HKEY_*" 例如:SOFTWARE\Test
    .参数 子项, 文本型, 参考 可空 数组, 获取的子项数组
    .局部变量 局_计次, 整数型
    .局部变量 局_项名, 文本型

    .如果真 (m_当前键目录 ≠ 键根目录 或 m_当前键 ≠ 全路径注册项名)
        .如果真 (打开键Ex (键根目录, 全路径注册项名) ＝ -1)
            返回 (m_Error)
        .如果真结束
        
    .如果真结束
    
    清除数组 (子项)
    
    局_项名 ＝ 取空白文本 (256)
    m_Error ＝ RegEnumKeyA (m_键句柄, 局_计次, 局_项名, 256)
    .如果真 (m_Error ≠ 0 且 m_Error ≠ #ERROR_NO_MORE_ITEMS)
        返回 (m_Error)
    .如果真结束
    
    .判断循环首 (m_Error ＝ 0)
        加入成员 (子项, 局_项名)
        局_计次 ＝ 局_计次 ＋ 1
        m_Error ＝ RegEnumKeyA (m_键句柄, 局_计次, 局_项名, 256)
    .判断循环尾 ()
    .如果真 (m_Error ＝ #ERROR_NO_MORE_ITEMS)
        m_Error ＝ 0
    .如果真结束
    返回 (取数组成员数 (子项))

.子程序 方法_取最后错误代码Ex, 整数型, 公开, 取出这个值后,可以根据GetlastError获取错误信息
    返回 (m_Error)

.子程序 枚举键信息Ex, 整数型, 公开, 枚举指定项名称下的键信息(成功返回键名数,失败返回-1),需要先调用打开键Ex或打开键Ex2
    .参数 键根目录, 整数型, , #HKEY_*开头的常量
    .参数 全路径注册项名, 文本型, , 完整的键路径,不包括"HKEY_*" 例如:SOFTWARE\Test
    .参数 注册表键信息, 注册表_键, 参考 数组, 作为返回值返回
    .局部变量 局_计次, 整数型
    .局部变量 局_键值缓冲区, 整数型
    .局部变量 临时_注册表键信息, 注册表_键

    .如果真 (m_当前键目录 ≠ 键根目录 或 m_当前键 ≠ 全路径注册项名)
        m_键句柄 ＝ 打开键Ex (键根目录, 全路径注册项名)
        .如果真 (m_键句柄 ＝ -1)
            返回 (m_Error)
        .如果真结束
        清除数组 (注册表键信息)
    .如果真结束
    临时_注册表键信息.键名称 ＝ 取空白文本 (256)
    .判断循环首 (m_键句柄 ≠ 0)
        RegEnumValueA (m_键句柄, 局_计次, 临时_注册表键信息.键名称, 256, 0, 临时_注册表键信息.类型, 临时_注册表键信息.键值, 局_键值缓冲区)
        临时_注册表键信息.键值 ＝ 取空白字节集 (局_键值缓冲区)
        m_Error ＝ RegEnumValueA (m_键句柄, 局_计次, 临时_注册表键信息.键名称, 256, 0, 临时_注册表键信息.类型, 临时_注册表键信息.键值, 局_键值缓冲区)
        .如果 (m_Error ＝ 0)
            加入成员 (注册表键信息, 临时_注册表键信息)
        .否则
            跳出循环 ()
        .如果结束
        局_计次 ＝ 局_计次 ＋ 1
    .判断循环尾 ()
    .如果真 (m_Error ＝ #ERROR_NO_MORE_ITEMS)
        m_Error ＝ 0
    .如果真结束
    返回 (取数组成员数 (注册表键信息))

.子程序 键是否存在Ex, 逻辑型, 公开, 判断键是否存在,亦可可以直接使用"打开键Ex"进行判断
    .参数 键根目录, 整数型, , #HKEY_*开头的常量
    .参数 全路径注册项名, 文本型, , 完整的键路径,不包括"HKEY_*" 例如:SOFTWARE\Test
    .局部变量 局部_标志位, 整数型
    .局部变量 临时_句柄, 整数型
    .局部变量 状态, 整数型

    局部_标志位 ＝ #KEY_READ
    .如果 (IsWow64) ' ; 64位注册表
        局部_标志位 ＝ 位或 (局部_标志位, #KEY_WOW64_64KEY)
    .否则
        局部_标志位 ＝ 位或 (局部_标志位, #KEY_WOW64_32KEY)
    .如果结束
    
    ' 注意:这里的samDesired 采用的是  #KEY_READ  读取权限
    
    状态 ＝ RegOpenKeyExA (键根目录, 全路径注册项名, 0, 局部_标志位, 临时_句柄)
    RegCloseKey (临时_句柄)
    
    .如果真 (状态 ＝ #ERROR_SUCCESS)
        返回 (真)
    .如果真结束
    返回 (假)
    

.子程序 读取键值Ex, 整数型, 公开, 成功返回0,失败返回错误码.需要先调用打开键Ex或打开键Ex2
    .参数 键根目录, 整数型, , #HKEY_*开头的常量
    .参数 全路径注册项名, 文本型, , 完整的键路径,不包括"HKEY_*" 例如:SOFTWARE\Test
    .参数 键名称, 文本型, , 键的名称
    .参数 项目信息_out, 注册表_键, 参考, 用于返回的
    .局部变量 局_所需长度, 整数型

    .如果真 (m_当前键目录 ≠ 键根目录 或 m_当前键 ≠ 全路径注册项名)
        .如果真 (打开键Ex (键根目录, 全路径注册项名) ＝ -1)
            返回 (m_Error)
        .如果真结束
        
    .如果真结束
    
    项目信息_out.键名称 ＝ 全路径注册项名
    m_Error ＝ RegQueryValueExA (m_键句柄, 键名称, 0, 项目信息_out.类型, { }, 局_所需长度)
    .如果真 (m_Error ＝ #ERROR_MORE_DATA)
        项目信息_out.键值 ＝ 取空白字节集 (局_所需长度)
        m_Error ＝ RegQueryValueExA (m_键句柄, 键名称, 0, 项目信息_out.类型, 项目信息_out.键值, 局_所需长度)
        .如果真 (m_Error ＝ #ERROR_SUCCESS)
            项目信息_out.键值 ＝ 取字节集左边 (项目信息_out.键值, 取字节集长度 (项目信息_out.键值) － 1)
        .如果真结束
        
    .如果真结束
    返回 (m_Error)

.子程序 写入键值Ex_文本, 整数型, 公开, 成功返回0,失败返回错误码；注意，该函数只能写入文本型的值
    .参数 键根目录, 整数型, , #HKEY_*开头的常量
    .参数 全路径注册项名, 文本型, , 完整的键路径,不包括"HKEY_*" 例如:SOFTWARE\Test
    .参数 键名称, 文本型, , 键的名称
    .参数 欲写入值, 字节集, , 使用 到字节集()
    .参数 写入类型, 整数型, , 只适用于：REG_SZ;REG_EXPAND_SZ;REG_MULTI_SZ;#REG_BINARY
    .参数 是否自动创建, 逻辑型, 可空, 如果不存在的话，是否创建该键
    .局部变量 bRet, 整数型
    .局部变量 nMaxCount, 整数型

    .如果真 (写入类型 ≠ #REG_SZ 且 写入类型 ≠ #REG_EXPAND_SZ 且 写入类型 ≠ #REG_MULTI_SZ 且 写入类型 ≠ #REG_BINARY)
        输出调试文本 (“写入的类型不正确，如果需要写入数值型，请调用【写入键值Ex_数值】”)
        返回 (-1)
    .如果真结束
    .如果真 (是否自动创建)
        m_当前键 ＝ “1”
    .如果真结束
    .如果真 (m_当前键目录 ≠ 键根目录 或 m_当前键 ≠ 全路径注册项名)
        .判断开始 (是否自动创建)
            bRet ＝ 创建并打开键Ex (键根目录, 全路径注册项名) ' 自动创建这个键
        .默认
            bRet ＝ 打开键Ex (键根目录, 全路径注册项名)
        .判断结束
        
        .如果真 (bRet ＝ -1)
            返回 (m_Error)
        .如果真结束
        
    .如果真结束
    
    nMaxCount ＝ 取字节集长度 (欲写入值)
    欲写入值 ＝ 欲写入值 ＋ { 0 }
    m_Error ＝ RegSetValueExA (m_键句柄, 键名称, 0, 写入类型, 欲写入值, nMaxCount)
    返回 (m_Error)

.子程序 写入键值Ex_数值, 整数型, 公开
    .参数 键根目录, 整数型, , #HKEY_*开头的常量
    .参数 全路径注册项名, 文本型, , 完整的键路径,不包括"HKEY_*" 例如:SOFTWARE\Test
    .参数 键名称, 文本型, , 键的名称
    .参数 欲写入值, 长整数型, , 注意。理论上：DWORD最大值为：4294967295  QWORD最大值为：18446744073709551615，但是QWORD最大值超过了整数型的最大长度，请谨慎使用
    .参数 写入类型, 整数型, , 只适用于：#REG_DWORD;#REG_DWORD_BIG_ENDIAN;
    .参数 是否自动创建, 逻辑型, 可空, 如果不存在的话，是否创建该键
    .局部变量 bRet, 整数型
    .局部变量 临时_写入数据, 字节集
    .局部变量 临时_数据长度, 整数型

    .如果真 (写入类型 ≠ #REG_DWORD 且 写入类型 ≠ #REG_DWORD_BIG_ENDIAN 且 写入类型 ≠ #REG_QWORD)
        输出调试文本 (“写入的类型不正确，如果需要写入文本值，请调用【写入键值Ex_文本】”)
        返回 (-1)
    .如果真结束
    
    .如果真 (是否自动创建)
        m_当前键 ＝ “1”
    .如果真结束
    .如果真 (m_当前键目录 ≠ 键根目录 或 m_当前键 ≠ 全路径注册项名)
        .判断开始 (是否自动创建)
            bRet ＝ 创建并打开键Ex (键根目录, 全路径注册项名) ' 自动创建这个键
        .默认
            bRet ＝ 打开键Ex (键根目录, 全路径注册项名)
        .判断结束
        
        .如果真 (bRet ＝ -1)
            返回 (m_Error)
        .如果真结束
        
    .如果真结束
    
    临时_写入数据 ＝ 到字节集 (欲写入值)
    临时_数据长度 ＝ 4
    .如果真 (写入类型 ＝ #REG_QWORD)
        补充字节集长度 (临时_写入数据, 8)
        临时_数据长度 ＝ 8
    .如果真结束
    
    m_Error ＝ RegSetValueExA_数值 (m_键句柄, 键名称, 0, 写入类型, 临时_写入数据, 临时_数据长度)
    返回 (m_Error)

.子程序 写QWORD_64值, 逻辑型, 公开, 写入64位长整数值,成功返回真,失败返回假.源码由@pp25729391提供。
    .参数 键根目录, 整数型, , #HKEY_*开头的常量
    .参数 全路径注册项名, 文本型, , 完整的键路径,不包括"HKEY_*" 例如:SOFTWARE\Test
    .参数 键名称, 文本型, , 键的名称
    .参数 值_十六进制文本, 文本型
    .局部变量 欲写入值, 字节集
    .局部变量 i, 整数型

    .如果真 (打开键Ex (键根目录, 全路径注册项名) ＝ -1)
        创建并打开键Ex (键根目录, 全路径注册项名) ' 自动创建这个键
    .如果真结束
    .变量循环首 (取文本长度 (值_十六进制文本), 1, -2, i)
        .如果真 (i ≠ 1)
            欲写入值 ＝ 欲写入值 ＋ 取字节集左边 (到字节集 (进制_十六到十 (取文本中间 (值_十六进制文本, i － 1, 2))), 1)
        .如果真结束
        .如果真 (i ＝ 1)
            欲写入值 ＝ 欲写入值 ＋ 取字节集左边 (到字节集 (进制_十六到十 (取文本中间 (值_十六进制文本, i, 1))), 1)
        .如果真结束
        
    .变量循环尾 ()
    补充字节集长度 (欲写入值, 8)
    m_Error ＝ RegSetValueExA_数值 (m_键句柄, 键名称, 0, #REG_QWORD, 欲写入值, 8)
    返回 (m_Error ＝ 0)

.子程序 补充字节集长度
    .参数 数据, 字节集
    .参数 字节集的总长, 整数型
    .局部变量 循环的次数, 整数型
    .局部变量 计次, 整数型

    .如果真 (字节集的总长 ＞ 取字节集长度 (数据))
        循环的次数 ＝ 字节集的总长 － 取字节集长度 (数据)
        .计次循环首 (循环的次数, 计次)
            数据 ＝ 数据 ＋ { 0 }
        .计次循环尾 ()
    .如果真结束
    返回 ()

.子程序 删除键值Ex, 整数型, 公开, 删除一个键值.
    .参数 键根目录, 整数型, , #HKEY_*开头的常量
    .参数 全路径注册项名, 文本型, , 完整的键路径,不包括"HKEY_*" 例如:SOFTWARE\Test
    .参数 键名, 文本型

    .如果真 (m_当前键目录 ≠ 键根目录 或 m_当前键 ≠ 全路径注册项名)
        .如果真 (打开键Ex (键根目录, 全路径注册项名) ＝ -1)
            返回 (m_Error)
        .如果真结束
        
    .如果真结束
    
    m_Error ＝ RegDeleteValueA (m_键句柄, 键名)
    返回 (m_Error)

.子程序 删除注册表项, 整数型, 公开, 删除整个项,项下面所有的键值将会被自动删除.
    .参数 键根目录, 整数型, , #HKEY_*开头的常量
    .参数 全路径注册项名, 文本型, , 完整的键路径,不包括"HKEY_*" 例如:SOFTWARE\Test
    .局部变量 bRet, 整数型
    .局部变量 临时_项目, 文本型

    bRet ＝ 倒找文本 (全路径注册项名, “\”, , 假)
    临时_项目 ＝ 取文本左边 (全路径注册项名, bRet － 1)
    .如果真 (打开键Ex (键根目录, 临时_项目) ＝ -1)
        返回 (m_Error)
    .如果真结束
    
    临时_项目 ＝ 取文本右边 (全路径注册项名, 取文本长度 (全路径注册项名) － bRet)
    m_Error ＝ RegDeleteKeyA (m_键句柄, 临时_项目)
    返回 (m_Error)
    

.子程序 格式化键值类型, 文本型, 公开, 说明键值
    .参数 键值, 整数型, , REG_*

    .如果真 (键值 ＞ 11 或 键值 ≤ 0)
        返回 (“键值非法”)
    .如果真结束
    返回 (多项选择 (键值, “REG_SZ”, “REG_EXPAND_SZ”, “REG_BINARY”, “REG_DWORD”, “REG_DWORD_BIG_ENDIAN”, “REG_LINK”, “REG_MULTI_SZ”, “REG_RESOURCE_LIST”, “NULL”, “NULL”, “REG_QWORD”))
    

.子程序 是否有子项Ex, 整数型, 公开, -1=失败 0=无 1=有
    .参数 键根目录, 整数型, , #HKEY_*开头的常量
    .参数 全路径注册项名, 文本型, , 完整的键路径,不包括"HKEY_*" 例如:SOFTWARE\Test
    .局部变量 szName, 文本型

    .如果真 (m_当前键目录 ≠ 键根目录 或 m_当前键 ≠ 全路径注册项名)
        .如果真 (打开键Ex (键根目录, 全路径注册项名) ＝ -1)
            返回 (-1)
        .如果真结束
        
    .如果真结束
    szName ＝ 取空白文本 (256)
    m_Error ＝ RegEnumKeyA (m_键句柄, 0, szName, 256)
    .如果真 (m_Error ＝ #ERROR_NO_MORE_ITEMS)
        返回 (0)
    .如果真结束
    .如果真 (m_Error ≠ 0)
        返回 (-1)
    .如果真结束
    返回 (1)

.版本 2

.程序集 类_CPU信息, , 公开
.程序集变量 InitializeSecurity, 逻辑型
.程序集变量 WbemLocator
.程序集变量 ppNamespace
.程序集变量 pEnumerator

.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
    

.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
    

.子程序 Init, 逻辑型
    .参数 Server, 文本型
    .参数 WQL, 文本型
    .局部变量 CLSID_WbemLocator, GUID
    .局部变量 IID_IWbemLocator, GUID
    .局部变量 hres, 整数型

    CoUninitialize ()
    CoInitializeEx (0, 0)
    .如果真 (InitializeSecurity ＝ 假)
        CoInitializeSecurity (0, -1, 0, 0, 0, 3, 0, 0, 0)
        InitializeSecurity ＝ 真
    .如果真结束
    CLSID_WbemLocator ＝ COM_StringToCLSID (“{4590f811-1d3a-11d0-891f-00aa004b2e24}”)
    IID_IWbemLocator ＝ COM_StringtoIID (“{dc12a687-737f-11cf-884d-00aa004b2e24}”)
    hres ＝ CoCreateInstance (CLSID_WbemLocator, 0, 1, IID_IWbemLocator, WbemLocator)
    .如果真 (hres ≠ 0)
        CoUninitialize ()
        返回 (假)
    .如果真结束
    hres ＝ CallObject (WbemLocator, 3, COM_bstr_t (Server), 0, 0, 0, 0, 0, 0, 取指针_通用型 (ppNamespace), ) ' ConnectServer
    .如果真 (hres ≠ 0)
        CoUninitialize ()
        返回 (假)
    .如果真结束
    hres ＝ CoSetProxyBlanket (ppNamespace, 10, 0, 0, 3, 3, 0, 0)
    .如果真 (hres ≠ 0)
        CoUninitialize ()
        返回 (假)
    .如果真结束
    hres ＝ CallObject (ppNamespace, 20, COM_bstr_t (“WQL”), COM_bstr_t (WQL), 位或 (32, 16), 0, 取指针_通用型 (pEnumerator), , , , ) ' ExecQuery
    .如果真 (hres ≠ 0)
        CoUninitialize ()
        返回 (假)
    .如果真结束
    返回 (真)

.子程序 Uninit
    COM_Release (WbemLocator)
    COM_Release (pEnumerator)
    COM_Release (ppNamespace)
    CoUninitialize ()

.子程序 取地址宽度, 整数型, 公开, 失败返回-1。
    .参数 CPU索引, , 可空, 可为空，如有多个CPU默认取第1个。
    .局部变量 Variant
    .局部变量 pclsObj, 整数型
    .局部变量 uReturn, 整数型
    .局部变量 i, 整数型
    .局部变量 AddressWidth
    .局部变量 hres, 整数型

    .如果真 (Init (“root\CIMV2”, “Select * From Win32_Processor”) ＝ 假)
        返回 (-1)
    .如果真结束
    Variant ＝ COM_bstr_t (取空白文本 (16))
    CPU索引 ＝ 选择 (是否为空 (CPU索引), 1, CPU索引)
    .计次循环首 (10, i)
        hres ＝ CallObject (pEnumerator, 4, 4294967295, 1, 取指针_通用型 (pclsObj), 取指针_通用型 (uReturn), , , , , )
        .如果 (uReturn ＝ 1)
            .如果真 (i ＝ CPU索引)
                CallObject (pclsObj, 4, COM_bstr_t (“AddressWidth”), 0, Variant, 0, 0, , , , )
                AddressWidth ＝ 取字节集数据 (指针到字节集 (Variant ＋ 8, 4), #整数型, )
            .如果真结束
            SafeRelease (pclsObj)
        .否则
            跳出循环 ()
        .如果结束
        处理事件 ()
    .计次循环尾 ()
    Uninit ()
    返回 (AddressWidth)

.子程序 取架构, 整数型, 公开, 失败返回-1。返回值：0=x86；1=MiPs；2=Alpha；3=PowerPC；5=ARM；6=Itanium-based systems；9=x64
    .参数 CPU索引, , 可空, 可为空，如有多个CPU默认取第1个。
    .局部变量 Variant
    .局部变量 pclsObj, 整数型
    .局部变量 uReturn, 整数型
    .局部变量 i, 整数型
    .局部变量 Architecture
    .局部变量 hres, 整数型

    .如果真 (Init (“root\CIMV2”, “Select * From Win32_Processor”) ＝ 假)
        返回 (-1)
    .如果真结束
    Variant ＝ COM_bstr_t (取空白文本 (16))
    CPU索引 ＝ 选择 (是否为空 (CPU索引), 1, CPU索引)
    .计次循环首 (10, i)
        hres ＝ CallObject (pEnumerator, 4, 4294967295, 1, 取指针_通用型 (pclsObj), 取指针_通用型 (uReturn), , , , , )
        .如果 (uReturn ＝ 1)
            .如果真 (i ＝ CPU索引)
                CallObject (pclsObj, 4, COM_bstr_t (“Architecture”), 0, Variant, 0, 0, , , , )
                Architecture ＝ 取字节集数据 (指针到字节集 (Variant ＋ 8, 4), #整数型, )
            .如果真结束
            SafeRelease (pclsObj)
        .否则
            跳出循环 ()
        .如果结束
        处理事件 ()
    .计次循环尾 ()
    Uninit ()
    返回 (Architecture)

.子程序 取状态, 整数型, 公开, 失败返回-1。返回值；0=未知；1=启用；2=用户通过CPU禁用BIOS设置；3=CPU禁用BIOS(POST错误)；4=CPU空闲。
    .参数 CPU索引, , 可空, 可为空，如有多个CPU默认取第1个。
    .局部变量 Variant
    .局部变量 pclsObj, 整数型
    .局部变量 uReturn, 整数型
    .局部变量 i, 整数型
    .局部变量 Architecture
    .局部变量 hres, 整数型

    .如果真 (Init (“root\CIMV2”, “Select * From Win32_Processor”) ＝ 假)
        返回 (-1)
    .如果真结束
    Variant ＝ COM_bstr_t (取空白文本 (16))
    CPU索引 ＝ 选择 (是否为空 (CPU索引), 1, CPU索引)
    .计次循环首 (10, i)
        hres ＝ CallObject (pEnumerator, 4, 4294967295, 1, 取指针_通用型 (pclsObj), 取指针_通用型 (uReturn), , , , , )
        .如果 (uReturn ＝ 1)
            .如果真 (i ＝ CPU索引)
                CallObject (pclsObj, 4, COM_bstr_t (“CpuStatus”), 0, Variant, 0, 0, , , , )
                Architecture ＝ 取字节集数据 (指针到字节集 (Variant ＋ 8, 4), #整数型, )
            .如果真结束
            SafeRelease (pclsObj)
        .否则
            跳出循环 ()
        .如果结束
        处理事件 ()
    .计次循环尾 ()
    Uninit ()
    返回 (Architecture)

.子程序 取当前时钟速度, 整数型, 公开, 失败返回-1。
    .参数 CPU索引, , 可空
    .局部变量 Variant
    .局部变量 pclsObj, 整数型
    .局部变量 uReturn, 整数型
    .局部变量 i, 整数型
    .局部变量 CurrentClockSpeed
    .局部变量 hres, 整数型

    .如果真 (Init (“root\CIMV2”, “Select * From Win32_Processor”) ＝ 假)
        返回 (-1)
    .如果真结束
    Variant ＝ COM_bstr_t (取空白文本 (16))
    CPU索引 ＝ 选择 (是否为空 (CPU索引), 1, CPU索引)
    .计次循环首 (10, i)
        hres ＝ CallObject (pEnumerator, 4, 4294967295, 1, 取指针_通用型 (pclsObj), 取指针_通用型 (uReturn), , , , , )
        .如果 (uReturn ＝ 1)
            .如果真 (i ＝ CPU索引)
                CallObject (pclsObj, 4, COM_bstr_t (“CurrentClockSpeed”), 0, Variant, 0, 0, , , , )
                CurrentClockSpeed ＝ 取字节集数据 (指针到字节集 (Variant ＋ 8, 4), #整数型, )
            .如果真结束
            SafeRelease (pclsObj)
        .否则
            跳出循环 ()
        .如果结束
        处理事件 ()
    .计次循环尾 ()
    Uninit ()
    返回 (CurrentClockSpeed)

.子程序 取当前电压, 整数型, 公开, 失败返回-1。
    .参数 CPU索引, , 可空, 可为空，如有多个CPU默认取第1个。
    .局部变量 Variant
    .局部变量 pclsObj, 整数型
    .局部变量 uReturn, 整数型
    .局部变量 i, 整数型
    .局部变量 CurrentVoltage
    .局部变量 hres, 整数型

    .如果真 (Init (“root\CIMV2”, “Select * From Win32_Processor”) ＝ 假)
        返回 (-1)
    .如果真结束
    Variant ＝ COM_bstr_t (取空白文本 (16))
    CPU索引 ＝ 选择 (是否为空 (CPU索引), 1, CPU索引)
    .计次循环首 (10, i)
        hres ＝ CallObject (pEnumerator, 4, 4294967295, 1, 取指针_通用型 (pclsObj), 取指针_通用型 (uReturn), , , , , )
        .如果 (uReturn ＝ 1)
            .如果真 (i ＝ CPU索引)
                CallObject (pclsObj, 4, COM_bstr_t (“CurrentVoltage”), 0, Variant, 0, 0, , , , )
                CurrentVoltage ＝ 取字节集数据 (指针到字节集 (Variant ＋ 8, 4), #整数型, )
            .如果真结束
            SafeRelease (pclsObj)
        .否则
            跳出循环 ()
        .如果结束
        处理事件 ()
    .计次循环尾 ()
    Uninit ()
    返回 (CurrentVoltage)
    

.子程序 取数据宽度, 整数型, 公开, 失败返回-1。
    .参数 CPU索引, , 可空, 可为空，如有多个CPU默认取第1个。
    .局部变量 Variant
    .局部变量 pclsObj, 整数型
    .局部变量 uReturn, 整数型
    .局部变量 i, 整数型
    .局部变量 DataWidth
    .局部变量 hres, 整数型

    .如果真 (Init (“root\CIMV2”, “Select * From Win32_Processor”) ＝ 假)
        返回 (-1)
    .如果真结束
    Variant ＝ COM_bstr_t (取空白文本 (16))
    CPU索引 ＝ 选择 (是否为空 (CPU索引), 1, CPU索引)
    .计次循环首 (10, i)
        hres ＝ CallObject (pEnumerator, 4, 4294967295, 1, 取指针_通用型 (pclsObj), 取指针_通用型 (uReturn), , , , , )
        .如果 (uReturn ＝ 1)
            .如果真 (i ＝ CPU索引)
                CallObject (pclsObj, 4, COM_bstr_t (“DataWidth”), 0, Variant, 0, 0, , , , )
                DataWidth ＝ 取字节集数据 (指针到字节集 (Variant ＋ 8, 4), #整数型, )
            .如果真结束
            SafeRelease (pclsObj)
        .否则
            跳出循环 ()
        .如果结束
        处理事件 ()
    .计次循环尾 ()
    Uninit ()
    返回 (DataWidth)

.子程序 取描述, 文本型, 公开
    .参数 CPU索引, , 可空, 可为空，如有多个CPU默认取第1个。
    .局部变量 Variant
    .局部变量 pclsObj, 整数型
    .局部变量 uReturn, 整数型
    .局部变量 i, 整数型
    .局部变量 Description
    .局部变量 sbuffer, 文本型
    .局部变量 hres, 整数型

    .如果真 (Init (“root\CIMV2”, “Select * From Win32_Processor”) ＝ 假)
        返回 (“”)
    .如果真结束
    Variant ＝ COM_bstr_t (取空白文本 (16))
    CPU索引 ＝ 选择 (是否为空 (CPU索引), 1, CPU索引)
    .计次循环首 (10, i)
        hres ＝ CallObject (pEnumerator, 4, 4294967295, 1, 取指针_通用型 (pclsObj), 取指针_通用型 (uReturn), , , , , )
        .如果 (uReturn ＝ 1)
            .如果真 (i ＝ CPU索引)
                CallObject (pclsObj, 4, COM_bstr_t (“Description”), 0, Variant, 0, 0, , , , )
                Description ＝ 取字节集数据 (指针到字节集 (Variant ＋ 8, 4), #整数型, )
                sbuffer ＝ 编码_Unicode到Ansi (指针到字节集 (Description, lstrlen (Description) × 3))
            .如果真结束
            SafeRelease (pclsObj)
        .否则
            跳出循环 ()
        .如果结束
        处理事件 ()
    .计次循环尾 ()
    Uninit ()
    返回 (sbuffer)

.子程序 取设备编号, 文本型, 公开
    .参数 CPU索引, , 可空, 可为空，如有多个CPU默认取第1个。
    .局部变量 Variant
    .局部变量 pclsObj, 整数型
    .局部变量 uReturn, 整数型
    .局部变量 i, 整数型
    .局部变量 DeviceID
    .局部变量 sbuffer, 文本型
    .局部变量 hres, 整数型

    .如果真 (Init (“root\CIMV2”, “Select * From Win32_Processor”) ＝ 假)
        返回 (“”)
    .如果真结束
    Variant ＝ COM_bstr_t (取空白文本 (16))
    CPU索引 ＝ 选择 (是否为空 (CPU索引), 1, CPU索引)
    .计次循环首 (10, i)
        hres ＝ CallObject (pEnumerator, 4, 4294967295, 1, 取指针_通用型 (pclsObj), 取指针_通用型 (uReturn), , , , , )
        .如果 (uReturn ＝ 1)
            .如果真 (i ＝ CPU索引)
                CallObject (pclsObj, 4, COM_bstr_t (“DeviceID”), 0, Variant, 0, 0, , , , )
                DeviceID ＝ 取字节集数据 (指针到字节集 (Variant ＋ 8, 4), #整数型, )
                sbuffer ＝ 编码_Unicode到Ansi (指针到字节集 (DeviceID, lstrlen (DeviceID) × 3))
            .如果真结束
            SafeRelease (pclsObj)
        .否则
            跳出循环 ()
        .如果结束
        处理事件 ()
    .计次循环尾 ()
    Uninit ()
    返回 (sbuffer)

.子程序 取二级缓存, 整数型, 公开
    .参数 CPU索引, , 可空, 可为空，如有多个CPU默认取第1个。
    .局部变量 Variant
    .局部变量 pclsObj, 整数型
    .局部变量 uReturn, 整数型
    .局部变量 i, 整数型
    .局部变量 L2CacheSize
    .局部变量 hres, 整数型

    .如果真 (Init (“root\CIMV2”, “Select * From Win32_Processor”) ＝ 假)
        返回 (-1)
    .如果真结束
    Variant ＝ COM_bstr_t (取空白文本 (16))
    CPU索引 ＝ 选择 (是否为空 (CPU索引), 1, CPU索引)
    .计次循环首 (10, i)
        hres ＝ CallObject (pEnumerator, 4, 4294967295, 1, 取指针_通用型 (pclsObj), 取指针_通用型 (uReturn), , , , , )
        .如果 (uReturn ＝ 1)
            .如果真 (i ＝ CPU索引)
                CallObject (pclsObj, 4, COM_bstr_t (“L2CacheSize”), 0, Variant, 0, 0, , , , )
                L2CacheSize ＝ 取字节集数据 (指针到字节集 (Variant ＋ 8, 4), #整数型, )
            .如果真结束
            SafeRelease (pclsObj)
        .否则
            跳出循环 ()
        .如果结束
        处理事件 ()
    .计次循环尾 ()
    Uninit ()
    返回 (L2CacheSize)

.子程序 取三级缓存, 整数型, 公开
    .参数 CPU索引, , 可空, 可为空，如有多个CPU默认取第1个。
    .局部变量 Variant
    .局部变量 pclsObj, 整数型
    .局部变量 uReturn, 整数型
    .局部变量 i, 整数型
    .局部变量 L3CacheSize
    .局部变量 hres, 整数型

    .如果真 (Init (“root\CIMV2”, “Select * From Win32_Processor”) ＝ 假)
        返回 (-1)
    .如果真结束
    Variant ＝ COM_bstr_t (取空白文本 (16))
    CPU索引 ＝ 选择 (是否为空 (CPU索引), 1, CPU索引)
    .计次循环首 (10, i)
        hres ＝ CallObject (pEnumerator, 4, 4294967295, 1, 取指针_通用型 (pclsObj), 取指针_通用型 (uReturn), , , , , )
        .如果 (uReturn ＝ 1)
            .如果真 (i ＝ CPU索引)
                CallObject (pclsObj, 4, COM_bstr_t (“L3CacheSize”), 0, Variant, 0, 0, , , , )
                L3CacheSize ＝ 取字节集数据 (指针到字节集 (Variant ＋ 8, 4), #整数型, )
            .如果真结束
            SafeRelease (pclsObj)
        .否则
            跳出循环 ()
        .如果结束
        处理事件 ()
    .计次循环尾 ()
    Uninit ()
    返回 (L3CacheSize)

.子程序 取占用率, 整数型, 公开
    .参数 CPU索引, , 可空, 可为空，如有多个CPU默认取第1个。
    .局部变量 Variant
    .局部变量 pclsObj, 整数型
    .局部变量 uReturn, 整数型
    .局部变量 i, 整数型
    .局部变量 LoadPercentage
    .局部变量 hres, 整数型

    .如果真 (Init (“root\CIMV2”, “Select * From Win32_Processor”) ＝ 假)
        返回 (-1)
    .如果真结束
    Variant ＝ COM_bstr_t (取空白文本 (16))
    CPU索引 ＝ 选择 (是否为空 (CPU索引), 1, CPU索引)
    .计次循环首 (10, i)
        hres ＝ CallObject (pEnumerator, 4, 4294967295, 1, 取指针_通用型 (pclsObj), 取指针_通用型 (uReturn), , , , , )
        .如果 (uReturn ＝ 1)
            .如果真 (i ＝ CPU索引)
                CallObject (pclsObj, 4, COM_bstr_t (“LoadPercentage”), 0, Variant, 0, 0, , , , )
                LoadPercentage ＝ 取字节集数据 (指针到字节集 (Variant ＋ 8, 4), #整数型, )
            .如果真结束
            SafeRelease (pclsObj)
        .否则
            跳出循环 ()
        .如果结束
        处理事件 ()
    .计次循环尾 ()
    Uninit ()
    返回 (LoadPercentage)

.子程序 取制造商, 文本型, 公开
    .参数 CPU索引, , 可空, 可为空，如有多个CPU默认取第1个。
    .局部变量 Variant
    .局部变量 pclsObj, 整数型
    .局部变量 uReturn, 整数型
    .局部变量 i, 整数型
    .局部变量 Manufacturer
    .局部变量 sbuffer, 文本型
    .局部变量 hres, 整数型

    .如果真 (Init (“root\CIMV2”, “Select * From Win32_Processor”) ＝ 假)
        返回 (“”)
    .如果真结束
    Variant ＝ COM_bstr_t (取空白文本 (16))
    CPU索引 ＝ 选择 (是否为空 (CPU索引), 1, CPU索引)
    .计次循环首 (10, i)
        hres ＝ CallObject (pEnumerator, 4, 4294967295, 1, 取指针_通用型 (pclsObj), 取指针_通用型 (uReturn), , , , , )
        .如果 (uReturn ＝ 1)
            .如果真 (i ＝ CPU索引)
                CallObject (pclsObj, 4, COM_bstr_t (“Manufacturer”), 0, Variant, 0, 0, , , , )
                Manufacturer ＝ 取字节集数据 (指针到字节集 (Variant ＋ 8, 4), #整数型, )
                sbuffer ＝ 编码_Unicode到Ansi (指针到字节集 (Manufacturer, lstrlen (Manufacturer) × 3))
            .如果真结束
            SafeRelease (pclsObj)
        .否则
            跳出循环 ()
        .如果结束
        处理事件 ()
    .计次循环尾 ()
    Uninit ()
    返回 (sbuffer)

.子程序 最大时钟速度, 整数型, 公开
    .参数 CPU索引, , 可空, 可为空，如有多个CPU默认取第1个。
    .局部变量 Variant
    .局部变量 pclsObj, 整数型
    .局部变量 uReturn, 整数型
    .局部变量 i, 整数型
    .局部变量 MaxClockSpeed
    .局部变量 hres, 整数型

    .如果真 (Init (“root\CIMV2”, “Select * From Win32_Processor”) ＝ 假)
        返回 (-1)
    .如果真结束
    Variant ＝ COM_bstr_t (取空白文本 (16))
    CPU索引 ＝ 选择 (是否为空 (CPU索引), 1, CPU索引)
    .计次循环首 (10, i)
        hres ＝ CallObject (pEnumerator, 4, 4294967295, 1, 取指针_通用型 (pclsObj), 取指针_通用型 (uReturn), , , , , )
        .如果 (uReturn ＝ 1)
            .如果真 (i ＝ CPU索引)
                CallObject (pclsObj, 4, COM_bstr_t (“MaxClockSpeed”), 0, Variant, 0, 0, , , , )
                MaxClockSpeed ＝ 取字节集数据 (指针到字节集 (Variant ＋ 8, 4), #整数型, )
            .如果真结束
            SafeRelease (pclsObj)
        .否则
            跳出循环 ()
        .如果结束
        处理事件 ()
    .计次循环尾 ()
    Uninit ()
    返回 (MaxClockSpeed)

.子程序 取名称, 文本型, 公开
    .参数 CPU索引, , 可空, 可为空，如有多个CPU默认取第1个。
    .局部变量 Variant
    .局部变量 pclsObj, 整数型
    .局部变量 uReturn, 整数型
    .局部变量 i, 整数型
    .局部变量 Name
    .局部变量 sbuffer, 文本型
    .局部变量 hres, 整数型

    .如果真 (Init (“root\CIMV2”, “Select * From Win32_Processor”) ＝ 假)
        返回 (“”)
    .如果真结束
    Variant ＝ COM_bstr_t (取空白文本 (16))
    CPU索引 ＝ 选择 (是否为空 (CPU索引), 1, CPU索引)
    .计次循环首 (10, i)
        hres ＝ CallObject (pEnumerator, 4, 4294967295, 1, 取指针_通用型 (pclsObj), 取指针_通用型 (uReturn), , , , , )
        .如果 (uReturn ＝ 1)
            .如果真 (i ＝ CPU索引)
                CallObject (pclsObj, 4, COM_bstr_t (“Name”), 0, Variant, 0, 0, , , , )
                Name ＝ 取字节集数据 (指针到字节集 (Variant ＋ 8, 4), #整数型, )
                sbuffer ＝ 编码_Unicode到Ansi (指针到字节集 (Name, lstrlen (Name) × 3))
            .如果真结束
            SafeRelease (pclsObj)
        .否则
            跳出循环 ()
        .如果结束
        处理事件 ()
    .计次循环尾 ()
    Uninit ()
    返回 (sbuffer)

.子程序 取型号, 文本型, 公开
    .参数 CPU索引, , 可空, 可为空，如有多个CPU默认取第1个。
    .局部变量 Variant
    .局部变量 pclsObj, 整数型
    .局部变量 uReturn, 整数型
    .局部变量 i, 整数型
    .局部变量 Name
    .局部变量 sbuffer, 文本型
    .局部变量 hres, 整数型

    .如果真 (Init (“root\CIMV2”, “Select * From Win32_Processor”) ＝ 假)
        返回 (“”)
    .如果真结束
    Variant ＝ COM_bstr_t (取空白文本 (16))
    CPU索引 ＝ 选择 (是否为空 (CPU索引), 1, CPU索引)
    .计次循环首 (10, i)
        hres ＝ CallObject (pEnumerator, 4, 4294967295, 1, 取指针_通用型 (pclsObj), 取指针_通用型 (uReturn), , , , , )
        .如果 (uReturn ＝ 1)
            .如果真 (i ＝ CPU索引)
                CallObject (pclsObj, 4, COM_bstr_t (“Name”), 0, Variant, 0, 0, , , , )
                Name ＝ 取字节集数据 (指针到字节集 (Variant ＋ 8, 4), #整数型, )
                sbuffer ＝ 编码_Unicode到Ansi (指针到字节集 (Name, lstrlen (Name) × 3))
            .如果真结束
            SafeRelease (pclsObj)
        .否则
            跳出循环 ()
        .如果结束
        处理事件 ()
    .计次循环尾 ()
    Uninit ()
    返回 (sbuffer)

.子程序 取核心数, 整数型, 公开
    .参数 CPU索引, , 可空, 可为空，如有多个CPU默认取第1个。
    .局部变量 Variant
    .局部变量 pclsObj, 整数型
    .局部变量 uReturn, 整数型
    .局部变量 i, 整数型
    .局部变量 NumberOfCores
    .局部变量 hres, 整数型

    .如果真 (Init (“root\CIMV2”, “Select * From Win32_Processor”) ＝ 假)
        返回 (-1)
    .如果真结束
    Variant ＝ COM_bstr_t (取空白文本 (16))
    CPU索引 ＝ 选择 (是否为空 (CPU索引), 1, CPU索引)
    .计次循环首 (10, i)
        hres ＝ CallObject (pEnumerator, 4, 4294967295, 1, 取指针_通用型 (pclsObj), 取指针_通用型 (uReturn), , , , , )
        .如果 (uReturn ＝ 1)
            .如果真 (i ＝ CPU索引)
                CallObject (pclsObj, 4, COM_bstr_t (“NumberOfCores”), 0, Variant, 0, 0, , , , )
                NumberOfCores ＝ 取字节集数据 (指针到字节集 (Variant ＋ 8, 4), #整数型, )
            .如果真结束
            SafeRelease (pclsObj)
        .否则
            跳出循环 ()
        .如果结束
        处理事件 ()
    .计次循环尾 ()
    Uninit ()
    返回 (NumberOfCores)

.子程序 取线程数, 整数型, 公开
    .参数 CPU索引, , 可空, 可为空，如有多个CPU默认取第1个。
    .局部变量 Variant
    .局部变量 pclsObj, 整数型
    .局部变量 uReturn, 整数型
    .局部变量 i, 整数型
    .局部变量 NumberOfLogicalProcessors
    .局部变量 hres, 整数型

    .如果真 (Init (“root\CIMV2”, “Select * From Win32_Processor”) ＝ 假)
        返回 (-1)
    .如果真结束
    Variant ＝ COM_bstr_t (取空白文本 (16))
    CPU索引 ＝ 选择 (是否为空 (CPU索引), 1, CPU索引)
    .计次循环首 (10, i)
        hres ＝ CallObject (pEnumerator, 4, 4294967295, 1, 取指针_通用型 (pclsObj), 取指针_通用型 (uReturn), , , , , )
        .如果 (uReturn ＝ 1)
            .如果真 (i ＝ CPU索引)
                CallObject (pclsObj, 4, COM_bstr_t (“NumberOfLogicalProcessors”), 0, Variant, 0, 0, , , , )
                NumberOfLogicalProcessors ＝ 取字节集数据 (指针到字节集 (Variant ＋ 8, 4), #整数型, )
            .如果真结束
            SafeRelease (pclsObj)
        .否则
            跳出循环 ()
        .如果结束
        处理事件 ()
    .计次循环尾 ()
    Uninit ()
    返回 (NumberOfLogicalProcessors)

.子程序 取序列号, 文本型, 公开
    .参数 CPU索引, , 可空, 可为空，如有多个CPU默认取第1个。
    .局部变量 Variant
    .局部变量 pclsObj, 整数型
    .局部变量 uReturn, 整数型
    .局部变量 i, 整数型
    .局部变量 ProcessorId
    .局部变量 sbuffer, 文本型
    .局部变量 hres, 整数型

    .如果真 (Init (“root\CIMV2”, “Select * From Win32_Processor”) ＝ 假)
        返回 (“”)
    .如果真结束
    Variant ＝ COM_bstr_t (取空白文本 (16))
    CPU索引 ＝ 选择 (是否为空 (CPU索引), 1, CPU索引)
    .计次循环首 (10, i)
        hres ＝ CallObject (pEnumerator, 4, 4294967295, 1, 取指针_通用型 (pclsObj), 取指针_通用型 (uReturn), , , , , )
        .如果 (uReturn ＝ 1)
            .如果真 (i ＝ CPU索引)
                CallObject (pclsObj, 4, COM_bstr_t (“ProcessorId”), 0, Variant, 0, 0, , , , )
                ProcessorId ＝ 取字节集数据 (指针到字节集 (Variant ＋ 8, 4), #整数型, )
                sbuffer ＝ 编码_Unicode到Ansi (指针到字节集 (ProcessorId, lstrlen (ProcessorId) × 3))
            .如果真结束
            SafeRelease (pclsObj)
        .否则
            跳出循环 ()
        .如果结束
        处理事件 ()
    .计次循环尾 ()
    Uninit ()
    返回 (sbuffer)

.子程序 取处理器类型, 整数型, 公开, 失败返回-1。返回值；1=其它；2=未知；3=中央处理器；4=数学处理器；5=DSP处理器；6=视频处理器
    .参数 CPU索引, , 可空, 可为空，如有多个CPU默认取第1个。
    .局部变量 Variant
    .局部变量 pclsObj, 整数型
    .局部变量 uReturn, 整数型
    .局部变量 i, 整数型
    .局部变量 ProcessorType
    .局部变量 hres, 整数型

    .如果真 (Init (“root\CIMV2”, “Select * From Win32_Processor”) ＝ 假)
        返回 (-1)
    .如果真结束
    Variant ＝ COM_bstr_t (取空白文本 (16))
    CPU索引 ＝ 选择 (是否为空 (CPU索引), 1, CPU索引)
    .计次循环首 (10, i)
        hres ＝ CallObject (pEnumerator, 4, 4294967295, 1, 取指针_通用型 (pclsObj), 取指针_通用型 (uReturn), , , , , )
        .如果 (uReturn ＝ 1)
            .如果真 (i ＝ CPU索引)
                CallObject (pclsObj, 4, COM_bstr_t (“ProcessorType”), 0, Variant, 0, 0, , , , )
                ProcessorType ＝ 取字节集数据 (指针到字节集 (Variant ＋ 8, 4), #整数型, )
            .如果真结束
            SafeRelease (pclsObj)
        .否则
            跳出循环 ()
        .如果结束
        处理事件 ()
    .计次循环尾 ()
    Uninit ()
    返回 (ProcessorType)

.子程序 取修订号, 整数型, 公开
    .参数 CPU索引, , 可空, 可为空，如有多个CPU默认取第1个。
    .局部变量 Variant
    .局部变量 pclsObj, 整数型
    .局部变量 uReturn, 整数型
    .局部变量 i, 整数型
    .局部变量 Revision
    .局部变量 hres, 整数型

    .如果真 (Init (“root\CIMV2”, “Select * From Win32_Processor”) ＝ 假)
        返回 (-1)
    .如果真结束
    Variant ＝ COM_bstr_t (取空白文本 (16))
    CPU索引 ＝ 选择 (是否为空 (CPU索引), 1, CPU索引)
    .计次循环首 (10, i)
        hres ＝ CallObject (pEnumerator, 4, 4294967295, 1, 取指针_通用型 (pclsObj), 取指针_通用型 (uReturn), , , , , )
        .如果 (uReturn ＝ 1)
            .如果真 (i ＝ CPU索引)
                CallObject (pclsObj, 4, COM_bstr_t (“Revision”), 0, Variant, 0, 0, , , , )
                Revision ＝ 取字节集数据 (指针到字节集 (Variant ＋ 8, 4), #整数型, )
            .如果真结束
            SafeRelease (pclsObj)
        .否则
            跳出循环 ()
        .如果结束
        处理事件 ()
    .计次循环尾 ()
    Uninit ()
    返回 (Revision)

.版本 2

.程序集 类_任务栏, , 公开, http://msdn.microsoft.com/en-us/library/windows/desktop/bb774652(v=vs.85).aspx
.程序集变量 ppv
.程序集变量 objShell
.程序集变量 HotKeyStatus, 逻辑型

.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
    .局部变量 CLSID_TaskbarList, GUID
    .局部变量 IID_ITaskbarList, GUID
    .局部变量 CLSID_Shell, GUID
    .局部变量 IID_IShellDispatch5, GUID

    CLSID_TaskbarList ＝ COM_StringToCLSID (“{56FDF344-FD6D-11d0-958A-006097C9A090}”)
    IID_ITaskbarList ＝ COM_StringtoIID (“{56FDF342-FD6D-11d0-958A-006097C9A090}”)
    .如果真 (CoCreateInstance (CLSID_TaskbarList, 0, 1, IID_ITaskbarList, ppv) ＝ 0)
        CallObject (ppv, 3, , , , , , , , , ) ' HrInit
    .如果真结束
    CLSID_Shell ＝ COM_StringToCLSID (“{13709620-C279-11CE-A49E-444553540000}”)
    IID_IShellDispatch5 ＝ COM_StringtoIID (“{866738b9-6cf2-4de8-8767-f794ebe74f4e}”)
    CoCreateInstance (CLSID_Shell, 0, 1, IID_IShellDispatch5, objShell)

.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
    .如果真 (ppv ≠ 0)
        COM_Release (ppv)
    .如果真结束
    .如果真 (objShell ≠ 0)
        COM_Release (objShell)
    .如果真结束
    

.子程序 显示图标, 逻辑型, 公开
    .参数 窗口句柄

    返回 (CallObject (ppv, 4, 窗口句柄, , , , , , , , ) ＝ 0) ' AddTab

.子程序 隐藏图标, 逻辑型, 公开
    .参数 窗口句柄

    返回 (CallObject (ppv, 5, 窗口句柄, , , , , , , , ) ＝ 0) ' DeleteTab

.子程序 激活图标, 逻辑型, 公开, 激活任务栏指定图标，并非激活窗口。
    .参数 窗口句柄

    返回 (CallObject (ppv, 6, 窗口句柄, , , , , , , , ) ＝ 0) ' ActivateTab

.子程序 取消激活, 逻辑型, 公开, 取消指定激活指定图标。
    .参数 窗口句柄

    返回 (CallObject (ppv, 7, 窗口句柄, , , , , , , , ) ＝ 0) ' SetActiveAlt

.子程序 注册热键, , 公开
    .参数 功能键, 整数型, , 1=Alt键；2=Ctrl键；4=Shift键；8=Win键，组合则相加。
    .参数 主热键, , , 键代码，可以使用易语言中的键代码常量。
    .参数 执行事件, 子程序指针
    .局部变量 bool, 逻辑型
    .局部变量 msg, MSG

    HotKeyStatus ＝ 假
    .如果真 (RegisterHotKey (0, 1268, 功能键, 主热键))
        .判断循环首 (GetMessageA (msg, 0, 0, 0))
            .判断开始 (msg.message ＝ 786) ' #WM_HOTKEY
                程序_Call (到整数 (执行事件))
            .判断 (HotKeyStatus)
                跳出循环 ()
            .默认
                
            .判断结束
            TranslateMessage (msg)
            DispatchMessage (msg)
        .判断循环尾 ()
    .如果真结束
    

.子程序 取消热键, 逻辑型, 公开
    .如果真 (UnregisterHotKey (0, 1268))
        HotKeyStatus ＝ 真
        返回 (真)
    .如果真结束
    返回 (假)

.子程序 取句柄, 整数型, 公开
    返回 (FindWindowA (“Shell_TrayWnd”, 字符 (0)))

.子程序 隐藏, 逻辑型, 公开
    返回 (ShowWindow (取句柄 (), 0))

.子程序 显示, 逻辑型, 公开
    返回 (ShowWindow (取句柄 (), 1))

.子程序 取高度, 整数型, 公开
    .局部变量 ABD, 精易_任务相关
    .局部变量 Ret, 整数型
    .局部变量 屏幕高度, 整数型

    SHAppBarMessage (5, ABD)
    Ret ＝ SHAppBarMessage (4, ABD)
    系统_取屏幕分辨率 (, , , 屏幕高度, )
    返回 (屏幕高度 － ABD.rc.顶边)

.子程序 监视全屏, , 公开
    .参数 窗口句柄, , , 第三方窗口无效，易中用 取窗口句柄()
    .参数 处理程序, 子程序指针, , 参数1；事件类型【整数型】输出值：1全屏；0退出全屏
    .局部变量 abd, 精易_任务相关
    .局部变量 Subclass

    abd.cbSize ＝ 36
    abd.hwnd ＝ 窗口句柄
    abd.uCallbackMessage ＝ 11286
    SetPropA (abd.hwnd, “Callback AppBar”, 到整数 (处理程序))
    SHAppBarMessage (0, abd) ' #ABM_NEW
    Subclass ＝ 类回调_取类地址 (14, 4, , )
    SetPropA (abd.hwnd, “Callback Proc”, SetWindowLongA (abd.hwnd, -4, Subclass))

.子程序 WindowProc, 整数型
    .参数 hwnd
    .参数 wMsg
    .参数 wParam
    .参数 lParam
    .局部变量 SubAddress
    .局部变量 SubProc

    .判断开始 (wMsg ＝ 11286)
        .如果真 (wParam ＝ 2) ' #ABN_FULLSCREENAPP
            SubAddress ＝ GetPropA (hwnd, “Callback AppBar”)
            程序_Call (SubAddress, lParam)
        .如果真结束
        
    .默认
        
    .判断结束
    SubProc ＝ GetPropA (hwnd, “Callback Proc”)
    返回 (CallWindowProcA (SubProc, hwnd, wMsg, wParam, lParam))

.子程序 是否隐藏, 逻辑型, 公开, 判断任务栏是否隐藏状态。
    .局部变量 ABD, 精易_任务相关
    .局部变量 uState

    uState ＝ SHAppBarMessage (4, ABD) ' ABM_GETSTATE
    返回 (选择 (uState ＝ 0 或 uState ＝ 2, 假, 真))

.子程序 自动隐藏, 逻辑型, 公开, 设置任务栏自动隐藏，成功返回真，失败返回假。
    .参数 启用, 逻辑型
    .局部变量 ABD, 精易_任务相关
    .局部变量 code

    ABD.lParam ＝ 选择 (启用, 1, 0) ' #ABS_AUTOHIDE
    code ＝ SHAppBarMessage (10, ABD) ' ABM_SETSTATE
    返回 (code ＝ 1)

.子程序 取矩形, 整数型, 公开, 成功返回1，失败返回错误代码。
    .参数 矩形, 精易_矩形, , 变量储存返回值。
    .局部变量 ABD, 精易_任务相关
    .局部变量 code

    code ＝ SHAppBarMessage (5, ABD) ' ABM_GETTASKBARPOS
    矩形 ＝ ABD.rc
    返回 (code)

.子程序 取位置, 整数型, 公开, 返回任务栏位置，返回值：0=左部；1=顶部；2=右部；3=底部
    .局部变量 pabd, 精易_任务相关

    SHAppBarMessage (5, pabd) ' ABM_GETTASKBARPOS
    返回 (pabd.uEdge)

.子程序 全部最小化, 逻辑型, 公开
    .如果真 (objShell ≠ 0)
        返回 (CallObject (objShell, 14, , , , , , , , , ) ＝ 0) ' MinimizeAll
    .如果真结束
    返回 (假)

.子程序 撤销全部最小化, 逻辑型, 公开
    .如果真 (objShell ≠ 0)
        返回 (CallObject (objShell, 15, , , , , , , , , ) ＝ 0) ' UndoMinimizeALL
    .如果真结束
    返回 (假)

.子程序 层叠窗口, 逻辑型, 公开
    .如果真 (objShell ≠ 0)
        返回 (CallObject (objShell, 17, , , , , , , , , ) ＝ 0) ' CascadeWindows
    .如果真结束
    返回 (假)

.子程序 堆叠显示窗口, 逻辑型, 公开
    .如果真 (objShell ≠ 0)
        返回 (CallObject (objShell, 19, , , , , , , , , ) ＝ 0) ' TileHorizontally
    .如果真结束
    返回 (假)

.子程序 并排显示窗口, 逻辑型, 公开
    .如果真 (objShell ≠ 0)
        返回 (CallObject (objShell, 18, , , , , , , , , ) ＝ 0) ' TileVertically
    .如果真结束
    返回 (假)

.子程序 显示桌面, 逻辑型, 公开
    .如果真 (objShell ≠ 0)
        返回 (CallObject (objShell, 41, , , , , , , , , ) ＝ 0) ' ToggleDesktop
    .如果真结束
    返回 (假)

.子程序 属性, 逻辑型, 公开
    .如果真 (objShell ≠ 0)
        返回 (CallObject (objShell, 24, , , , , , , , , ) ＝ 0) ' TrayProperties
    .如果真结束
    返回 (假)

.子程序 切换窗口, 逻辑型, 公开, 最底平台Vista，类似于按下键盘alt+Tab
    .如果真 (objShell ≠ 0)
        返回 (CallObject (objShell, 44, , , , , , , , , ) ＝ 0) ' WindowSwitcher
    .如果真结束
    返回 (假)
    

.子程序 锁定, 逻辑型, 公开, 锁定任务栏禁止更改任务大小与移动。重启explorer或重启后生效。
    .参数 开启, 逻辑型
    .局部变量 hKey
    .局部变量 Status
    .局部变量 bool, 逻辑型
    .局部变量 flag, 整数型

    IsWow64Process (GetCurrentProcess (), bool)
    flag ＝ 选择 (bool, #KEY_WOW64_64KEY, #KEY_WOW64_32KEY)
    Status ＝ RegOpenKeyExA (2147483649, “Software\Microsoft\Windows\CurrentVersion\Explorer\Advanced”, 0, 位或 (flag, #KEY_ALL_ACCESS), hKey)
    .如果真 (Status ＝ 0)
        Status ＝ RegSetValueExA (hKey, “TaskbarSizeMove”, 0, 4, 到字节集 (选择 (开启, 1, 0)), 4) ' #REG_DWORD
        RegFlushKey (hKey)
        RegCloseKey (hKey)
        返回 (Status ＝ 0)
    .如果真结束
    返回 (假)

.版本 2

.程序集 类_托盘, , 公开
.程序集变量 集_重建句柄, 整数型
.程序集变量 集_通知结构, NOTIFYICONDATA
.程序集变量 集_回调指针, 整数型
.程序集变量 集_窗口句柄, 整数型
.程序集变量 集_托盘句柄, 整数型

.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
    集_托盘句柄 ＝ 功能_取托盘区句柄 ()
    集_重建句柄 ＝ RegisterWindowMessageA (“TaskbarCreated”) ' 注册一个消息，任务栏重建时发送此消息，拦截此消息重新添加托盘图标。

.子程序 FindTrayWnd, 整数型
    .局部变量 hWnd, 整数型

    hWnd ＝ FindWindowA (“Shell_TrayWnd”, 字符 (0))
    hWnd ＝ FindWindowExA (hWnd, 0, 取指针文本_ (“TrayNotifyWnd”), 0)
    hWnd ＝ FindWindowExA (hWnd, 0, 取指针文本_ (“SysPager”), 0)
    hWnd ＝ FindWindowExA (hWnd, 0, 取指针文本_ (“ToolbarWindow32”), 0)
    返回 (hWnd)

.子程序 FindNotifyIconOverflowWindow, 整数型, , win7特有
    .局部变量 hWnd, 整数型

    hWnd ＝ FindWindowA (“NotifyIconOverflowWindow”, 字符 (0))
    hWnd ＝ FindWindowExA (hWnd, 0, 取指针文本_ (“ToolbarWindow32”), 0)
    返回 (hWnd)

.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
    集_托盘句柄 ＝ 0
    销毁 ()

.子程序 创建, 逻辑型, 公开, 创建一个托盘图标，成功返回真，失败返回假。
    .参数 窗口句柄, , , 不能设为第三方窗口
    .参数 图标数据, 字节集, 可空, 可为空，默认为自身图标。
    .参数 提示信息, 文本型, 可空, 本参数指定当鼠标移动到图标上后显示的提示信息。如果省略本参数，默认为空文本。

    .如果真 (IsWindow (窗口句柄) ＝ 1)
        集_窗口句柄 ＝ 窗口句柄
        .如果 (是否为空 (图标数据))
            集_通知结构.hIcon ＝ SendMessageA (窗口句柄, 127, 0, 0)
        .否则
            集_通知结构.hIcon ＝ 取图标句柄 (图标数据)
        .如果结束
        集_通知结构.cbSize ＝ 488
        集_通知结构.hWnd ＝ 窗口句柄
        集_通知结构.uID ＝ 1
        集_通知结构.uFlags ＝ 位或 (#NIF_ICON, #NIF_TIP, #NIF_MESSAGE)
        集_通知结构.uCallbackMessage ＝ RegisterWindowMessage (“CallbackMessage”)
        lstrcpy_bytes (集_通知结构.szTip, 提示信息)
        返回 (Shell_NotifyIcon (#NIM_ADD, 集_通知结构))
    .如果真结束
    返回 (假)

.子程序 销毁, 逻辑型, 公开
    .如果真 (集_回调指针 ≠ 0)
        SetWindowLongA (集_窗口句柄, -4, 集_回调指针)
    .如果真结束
    连续赋值 (0, 集_窗口句柄, 集_回调指针)
    集_通知结构.szInfo ＝ { 0 }
    集_通知结构.szInfoTitle ＝ { 0 }
    返回 (Shell_NotifyIcon (#NIM_DELETE, 集_通知结构))

.子程序 置提示信息, 逻辑型, 公开
    .参数 提示信息, 文本型, , 限定128字符以内，超出默认被截断
    .局部变量 m_szTip, 文本型

    m_szTip ＝ 选择 (取文本长度 (提示信息) ＜ 128, 提示信息, 取文本左边 (提示信息, 128))
    lstrcpy_bytes (集_通知结构.szTip, m_szTip)
    集_通知结构.uFlags ＝ 位或 (#NIF_ICON, #NIF_TIP, #NIF_MESSAGE)
    返回 (Shell_NotifyIcon (#NIM_MODIFY, 集_通知结构))

.子程序 气泡提示, 逻辑型, 公开
    .参数 提示标题, 文本型, , 限定64字符以内，超出默认被截断
    .参数 提示内容, 文本型, , 限定256字符以内，超出默认被截断
    .参数 提示图标, 整数型, 可空, 0.托盘图标_无图标,1.托盘图标_信息图标,2.托盘图标_警告图标,3.托盘图标_错误图标
    .参数 显示时间, 整数型, 可空, 设置气泡提示的时间，单位：毫秒 可空 默认3秒
    .局部变量 m_szInfo, 文本型
    .局部变量 m_szInfoTitle, 文本型

    集_通知结构.dwInfoFlags ＝ 提示图标
    m_szInfoTitle ＝ 选择 (取文本长度 (提示标题) ≤ 64, 提示标题, 取文本左边 (提示标题, 64))
    m_szInfo ＝ 选择 (取文本长度 (提示内容) ＜ 256, 提示内容, 取文本左边 (提示内容, 256))
    lstrcpy_bytes (集_通知结构.szInfoTitle, m_szInfoTitle)
    lstrcpy_bytes (集_通知结构.szInfo, m_szInfo)
    .判断开始 (显示时间 ＝ 0)
        集_通知结构.uTimeoutAndVersion ＝ 3000
    .默认
        集_通知结构.uTimeoutAndVersion ＝ 显示时间
    .判断结束
    集_通知结构.uFlags ＝ 位或 (#NIF_ICON, #NIF_TIP, #NIF_INFO, #NIF_MESSAGE)
    返回 (Shell_NotifyIcon (#NIM_MODIFY, 集_通知结构))

.子程序 置图标数据, 逻辑型, 公开
    .参数 图标数据, 字节集
    .局部变量 hIcon, 整数型

    hIcon ＝ 取图标句柄 (图标数据, 0)
    .如果真 (hIcon ＝ 0)
        返回 (假)
    .如果真结束
    集_通知结构.uFlags ＝ 位或 (#NIF_ICON, #NIF_TIP, #NIF_MESSAGE)
    集_通知结构.hIcon ＝ hIcon
    返回 (Shell_NotifyIcon (#NIM_MODIFY, 集_通知结构))

.子程序 取图标句柄, 整数型, , 凌晨孤星提供
    .参数 图标数据, 字节集, , 图标文件信息
    .参数 图标索引, 整数型, 可空, 从0开始
    .参数 图标宽度, 整数型, 参考 可空
    .参数 图标高度, 整数型, 参考 可空
    .局部变量 IconDirEntry, IconDirEntry
    .局部变量 图标句柄, 整数型

    CopyMemory_IconDirEntry (IconDirEntry, 取字节集中间 (图标数据, 6 ＋ 图标索引 × 16 ＋ 1, 16), 16)
    图标宽度 ＝ IconDirEntry.bWidth
    图标高度 ＝ IconDirEntry.bHeight
    图标句柄 ＝ CreateIconFromResource (取字节集中间 (图标数据, IconDirEntry.dwImageOffset ＋ 1, IconDirEntry.dwBytesInRes), IconDirEntry.dwBytesInRes, 真, 196608)
    返回 (图标句柄)

.子程序 挂接事件, , 公开, 当托盘图标创建成功后可建立挂接事件。
    .参数 执行事件, 子程序指针, 可空, 当用户用鼠标单击或双击本“托盘图标”后调用的子程序，该子程序应该有一个参数，传递事件类型，请参考“托盘事件_”开头的常量

    .如果真 (IsWindow (集_窗口句柄) ＝ 1)
        集_回调指针 ＝ SetWindowLongA (集_窗口句柄, -4, 到整数 (&托盘消息回调))
        SetPropA (集_窗口句柄, “WinProc”, 集_回调指针)
        SetPropA (集_窗口句柄, “CallbackMessage”, 集_通知结构.uCallbackMessage)
        SetPropA (集_窗口句柄, “TaskbarCreatedMessage”, 集_重建句柄)
        .如果真 (是否为空 (执行事件) ＝ 假)
            SetPropA (集_窗口句柄, “Exec Event”, 到整数 (执行事件))
        .如果真结束
        
    .如果真结束
    返回 ()

.子程序 刷新托盘, , 公开, 刷新系统托盘(清除死掉的图标)
    .参数 隐藏区域, 逻辑型, 可空, 针对Win7以上系统有托盘隐藏区域，为真则刷新隐藏区域
    .局部变量 Rect, 精易_矩形
    .局部变量 i, 整数型
    .局部变量 n, 整数型
    .局部变量 TrayWnd, 整数型

    TrayWnd ＝ 选择 (隐藏区域, FindNotifyIconOverflowWindow (), FindTrayWnd ())
    GetClientRect (TrayWnd, Rect)
    .计次循环首 (Rect.底边 ÷ 2, n)
        .计次循环首 (Rect.右边 ÷ 2, i)
            SendMessageA (TrayWnd, 512, n × 2, i × 2)
        .计次循环尾 ()
    .计次循环尾 ()

.子程序 取图标ID, 整数型, 公开, 根据图标索引取图标的ID
    .参数 图标索引, 整数型, , 索引从0开始。0 为图标一，1 为图标二，如此类推。
    .局部变量 hProcess, 整数型
    .局部变量 Address, 字节集
    .局部变量 Buffer, 整数型
    .局部变量 TB, TBBUTTON

    hProcess ＝ 进程_打开 (集_托盘句柄)
    Address ＝ 取空白字节集 (24)
    Buffer ＝ 内存_远程创建内存_字节集 (hProcess, Address)
    SendMessageA (集_托盘句柄, #TB_GETBUTTON, 图标索引, Buffer)
    ReadProcessMemory_BButton (hProcess, Buffer, TB, 24, 0)
    内存_释放远程内存 (hProcess, Buffer)
    进程_关闭 (hProcess)
    返回 (TB.idCommand)

.子程序 取图标数, 整数型, 公开, 取托盘图标总数
    .参数 隐藏区域, 逻辑型, 可空, 为真即枚举Win7上箭头内图标，XP系统下无效
    .局部变量 hTrayWnd, 整数型

    hTrayWnd ＝ 选择 (隐藏区域, FindNotifyIconOverflowWindow (), FindTrayWnd ())
    返回 (SendMessageA (hTrayWnd, #TB_BUTTONCOUNT, 0, 0))

.子程序 删除图标, 逻辑型, 公开, 删除托盘上的一个图标
    .参数 图标索引, 整数型, , 索引从0开始。0 为图标一，1 为图标二，如此类推。

    返回 (SendMessageA (集_托盘句柄, #TB_DELETEBUTTON, 图标索引, 0) ≠ 0)

.子程序 隐藏图标, 逻辑型, 公开, 隐藏托盘图标
    .参数 图标索引, 整数型, , 索引从0开始。0 为图标一，1 为图标二，如此类推。
    .局部变量 局_状态, 整数型
    .局部变量 局_标识, 整数型

    局_标识 ＝ 取图标ID (图标索引)
    局_状态 ＝ SendMessageA (集_托盘句柄, #TB_GETSTATE, 局_标识, 0)
    局_状态 ＝ 位或 (局_状态, #TBSTATE_HIDDEN)
    返回 (SendMessageA (集_托盘句柄, #TB_SETSTATE, 局_标识, 局_状态) ≠ 0)

.子程序 显示图标, 逻辑型, 公开, 显示托盘图标
    .参数 图标索引, 整数型, , 索引从0开始。0 为图标一，1 为图标二，如此类推。
    .局部变量 局_状态, 整数型
    .局部变量 局_标识, 整数型

    局_标识 ＝ 取图标ID (图标索引)
    局_状态 ＝ SendMessageA (集_托盘句柄, #TB_GETSTATE, 局_标识, 0)
    .如果真 (位与 (局_状态, #TBSTATE_HIDDEN) ≠ 0)
        局_状态 ＝ 位异或 (局_状态, #TBSTATE_HIDDEN)
    .如果真结束
    返回 (SendMessageA (集_托盘句柄, #TB_SETSTATE, 局_标识, 局_状态) ≠ 0)

.子程序 禁用图标, 逻辑型, 公开, 禁用指定图标
    .参数 图标索引, 整数型
    .局部变量 局_标识, 整数型

    局_标识 ＝ 取图标ID (图标索引)
    返回 (SendMessageA (集_托盘句柄, #TB_ENABLEBUTTON, 局_标识, 0) ≠ 0)

.子程序 启用图标, 逻辑型, 公开, 启用指定图标
    .参数 图标索引, 整数型
    .局部变量 局_标识, 整数型

    局_标识 ＝ 取图标ID (图标索引)
    返回 (SendMessageA (集_托盘句柄, #TB_ENABLEBUTTON, 局_标识, 1) ≠ 0)

.子程序 取图标标题, 文本型, 公开, 取回指定图标的标题文本
    .参数 图标索引, 整数型, , 索引从0开始。0 为图标一，1 为图标二，如此类推。
    .局部变量 局_标识, 整数型
    .局部变量 len, 整数型
    .局部变量 Address, 字节集
    .局部变量 Buffer, 整数型
    .局部变量 hProcess, 整数型

    局_标识 ＝ 取图标ID (图标索引)
    len ＝ SendMessageA (集_托盘句柄, #TB_GETBUTTONTEXTA, 局_标识, 0)
    hProcess ＝ 进程_打开 (集_托盘句柄)
    Address ＝ 取空白字节集 (len)
    Buffer ＝ 内存_远程创建内存_字节集 (hProcess, Address)
    SendMessageA (集_托盘句柄, #TB_GETBUTTONTEXTA, 局_标识, Buffer)
    ReadProcessMemory_字节集 (hProcess, Buffer, Address, len, 0)
    内存_释放远程内存 (hProcess, Buffer)
    进程_关闭 (hProcess)
    返回 (到文本 (Address))

.版本 2

.程序集 类_时钟, , 公开, http://msdn.microsoft.com/en-us/library/windows/desktop/ms682485(v=vs.85).aspx
.程序集变量 hTimerQueue, 整数型
.程序集变量 hTimer, 整数型
.程序集变量 集_程序指针, 子程序指针
.程序集变量 集_时钟周期, 整数型

.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
    

.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
    

.子程序 创建, 逻辑型, 公开
    .参数 子程序, 子程序指针, , 周期执行事件。周期事件格式：无返回值，参数1：整数型(参数)，参数2逻辑型
    .参数 时钟周期, 整数型, 可空, 默认为1000毫秒，即1秒。
    .参数 时钟参数, 整数型, 可空, 传递给时钟周期事件的参数，该参数是周期事件的第一个参数

    .如果真 (hTimerQueue ≠ 0 或 hTimer ≠ 0)
        销毁 ()
    .如果真结束
    .如果真 (集_程序指针 ≠ 子程序)
        集_程序指针 ＝ 子程序
    .如果真结束
    时钟周期 ＝ 选择 (是否为空 (时钟周期), 1000, 时钟周期)
    集_时钟周期 ＝ 时钟周期
    hTimerQueue ＝ CreateTimerQueue ()
    返回 (CreateTimerQueueTimer (hTimer, hTimerQueue, 到整数 (集_程序指针), 时钟参数, 0, 时钟周期, 0)) ' #WT_EXECUTEDEFAULT

.子程序 销毁, 逻辑型, 公开
    .局部变量 bool, 逻辑型

    .如果真 (hTimerQueue ＝ 0 或 hTimer ＝ 0)
        返回 (真)
    .如果真结束
    bool ＝ DeleteTimerQueueTimer (hTimerQueue, hTimer, 0)
    DeleteTimerQueue (hTimerQueue)
    连续赋值 (0, hTimer, 集_时钟周期)
    返回 (bool)

.子程序 置周期, 逻辑型, 公开
    .参数 时钟周期, 整数型

    .判断开始 (集_时钟周期 ＝ 0 且 时钟周期 ＞ 0 且 到整数 (集_程序指针) ≠ 0)
        返回 (创建 (集_程序指针, 时钟周期))
    .判断 (集_时钟周期 ＝ 时钟周期)
        返回 (真)
    .判断 (时钟周期 ＝ 0)
        返回 (销毁 ())
    .默认
        
    .判断结束
    集_时钟周期 ＝ 时钟周期
    返回 (ChangeTimerQueueTimer (hTimerQueue, hTimer, 0, 时钟周期))

.子程序 取周期, 整数型, 公开
    返回 (集_时钟周期)

.版本 2

.程序集 类_桌面窗口管理, , 公开, 桌面窗口管理器（DWM）
.程序集变量 集_缩略图ID, 整数型

.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
    ' 本类原始文档：https://docs.microsoft.com/zh-cn/windows/desktop/api/_dwm/

.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
    

.子程序 缩略图_创建, 整数型, 公开, 创建一个窗口略缩图，成功返回0，失败返回错误HRESULT代码。非零为失败
    .参数 参_目标窗口句柄, 整数型, , 呈现缩略图的窗口，必须为顶层窗口，否则参数无效
    .参数 参_源窗口句柄, 整数型, , 被缩略图的窗口，必须为顶层窗口，否则参数无效
    .局部变量 局_返回值, 整数型

    局_返回值 ＝ DwmRegisterThumbnail (参_目标窗口句柄, 参_源窗口句柄, 集_缩略图ID)
    返回 (局_返回值)
    ' 错误代码 ＝ 取十六进制文本 (局_返回值)
    ' .判断开始 (错误代码 ＝ “80263001”)
        ' 调试输出 (“略缩图”, 源窗口句柄, “由于桌面组合被禁用，操作无法完成。”)
    ' .判断 (错误代码 ＝ “80263002”)
        ' 调试输出 (“略缩图”, 源窗口句柄, “在远程会话中运行时不支持该操作。”)
    ' .判断 (错误代码 ＝ “80263003”)
        ' 调试输出 (“略缩图”, 源窗口句柄, “桌面窗口管理器(DWM)无法提供重定向面以完成DirectX当前。”)
    ' .判断 (错误代码 ＝ “80263004”)
        ' 调试输出 (“略缩图”, 源窗口句柄, “队列错误！”)
    ' .判断 (错误代码 ＝ “80280003”)
        ' 调试输出 (“略缩图”, 源窗口句柄, “参数错误！”)
    ' .判断 (错误代码 ＝ “80070057”)
        ' 调试输出 (“略缩图”, 源窗口句柄, “参数无效！”)
    ' .默认
        ' 调试输出 (“略缩图”, 源窗口句柄, “未知错误！HRESULT代码：” ＋ 错误代码)
        ' ' 更多错误查询页面：https://msdn.microsoft.com/en-us/library/cc704587.aspx
    ' .判断结束
    

.子程序 缩略图_更新, 整数型, 公开, 更新桌面窗口管理器（DWM）缩略图的属性。 非零为失败。目标窗口最小化时，缩略图不会更新
    .参数 左边, 整数型, 可空, 可空 默认0
    .参数 顶边, 整数型, 可空, 可空 默认0
    .参数 右边, 整数型, 可空, 可空 默认50
    .参数 底边, 整数型, 可空, 可空 默认50
    .参数 透明度, 整数型, 可空, 可空  默认255
    .参数 是否可视, 逻辑型, 可空, 可空  默认真
    .局部变量 局_属性, 缩略图属性
    .局部变量 局_矩形, 精易_矩形
    .局部变量 局_返回值, 整数型

    .如果真 (集_缩略图ID ＜ 0)
        返回 (-1)
    .如果真结束
    
    .如果真 (是否为空 (左边))
        左边 ＝ 0
    .如果真结束
    .如果真 (是否为空 (顶边))
        顶边 ＝ 0
    .如果真结束
    .如果真 (是否为空 (右边))
        右边 ＝ 50
    .如果真结束
    .如果真 (是否为空 (底边))
        底边 ＝ 50
    .如果真结束
    .如果真 (是否为空 (透明度))
        透明度 ＝ 255
    .如果真结束
    .如果真 (是否为空 (是否可视))
        是否可视 ＝ 真
    .如果真结束
    局_矩形.左边 ＝ 左边
    局_矩形.顶边 ＝ 顶边
    局_矩形.右边 ＝ 右边
    局_矩形.底边 ＝ 底边
    
    局_属性.目标矩形 ＝ 局_矩形
    局_属性.透明度 ＝ 透明度
    局_属性.可视 ＝ 是否可视
    局_属性.dwFlags ＝ 位或 (1, 4, 8)
    局_返回值 ＝ DwmUpdateThumbnailProperties (集_缩略图ID, 局_属性)
    返回 (局_返回值)

.子程序 缩略图_销毁, 整数型, 公开, 删除由DwmRegisterThumbnail函数创建的桌面窗口管理器（DWM）缩略图关系。 非零为失败
    .局部变量 局_返回值, 整数型

    .如果真 (集_缩略图ID ＜ 0)
        返回 (-1)
    .如果真结束
    局_返回值 ＝ DwmUnregisterThumbnail (集_缩略图ID)
    返回 (局_返回值)
    

.子程序 Aero_是否开启, 逻辑型, 公开, 是否启用了桌面窗口管理器（DWM）组合
    .局部变量 局_结果, 逻辑型

    ' 获取一个值，该值指示是否启用了桌面窗口管理器（DWM）组合。运行Windows 7或更早版本的计算机上的应用程序可以通过处理WM_DWMCOMPOSITIONCHANGED通知来侦听组合状态更改。
    DwmIsCompositionEnabled (局_结果)
    返回 (局_结果)

.子程序 Aero_禁用, 整数型, 公开, 非零为失败   注意：从win8开始此函数无效
    .局部变量 局_返回值, 整数型

    ' 注意   从Windows 8开始，使用DWM_EC_DISABLECOMPOSITION调用此函数无效。但是，该函数仍将返回成功代码。
    局_返回值 ＝ DwmEnableComposition (#DWM_EC_DISABLECOMPOSITION)
    返回 (局_返回值)

.子程序 Aero_启用, 整数型, 公开, 非零为失败   注意：从win8开始此函数无效
    .局部变量 局_返回值, 整数型

    局_返回值 ＝ DwmEnableComposition (#DWM_EC_ENABLECOMPOSITION)
    返回 (局_返回值)

.子程序 Aero_边框透明, 整数型, 公开, 非零为失败 注意：从win8开始此函数无效
    .参数 参_目标窗口句柄, 整数型
    .局部变量 sRT, 精易_位置和大小
    .局部变量 局_返回值, 整数型

    sRT.宽度 ＝ -1
    局_返回值 ＝ DwmExtendFrameIntoClientArea (参_目标窗口句柄, sRT)
    返回 (局_返回值)

.子程序 Aero_客户区透明, 整数型, 公开, 非零为失败 注意：从win8开始此函数无效
    .参数 参_窗口句柄, 整数型
    .局部变量 sBlur, 模糊属性
    .局部变量 sRT, 精易_位置和大小
    .局部变量 局_返回值, 整数型

    sRT.左边 ＝ 0
    sRT.顶边 ＝ 0
    sRT.宽度 ＝ 0
    sRT.高度 ＝ 0
    局_返回值 ＝ DwmExtendFrameIntoClientArea (参_窗口句柄, sRT)
    .如果真 (局_返回值 ≠ 0)
        返回 (局_返回值)
    .如果真结束
    sBlur.dwFlags ＝ #DWMWA_TRANSITIONS_FORCEDISABLED
    sBlur.fEnable ＝ 真
    局_返回值 ＝ DwmEnableBlurBehindWindow (参_窗口句柄, sBlur)
    返回 (局_返回值)

.子程序 Aero_非客户区特效范围, 整数型, 公开, 非零为失败 注意：从win8开始此函数无效
    .参数 参_窗口句柄, 整数型
    .参数 参_绘制左, 整数型, 可空, 可空 默认0
    .参数 参_绘制顶, 整数型, 可空, 可空 默认0
    .参数 参_绘制宽, 整数型, 可空, 可空 默认50
    .参数 参_绘制高, 整数型, 可空, 可空 默认50
    .局部变量 局_位置和大小, 精易_位置和大小
    .局部变量 局_返回值, 整数型

    局_位置和大小.左边 ＝ 参_绘制左
    局_位置和大小.顶边 ＝ 参_绘制顶
    局_位置和大小.宽度 ＝ 参_绘制宽
    局_位置和大小.高度 ＝ 参_绘制高
    局_返回值 ＝ DwmExtendFrameIntoClientArea (参_窗口句柄, 局_位置和大小)
    返回 (局_返回值)
    

.版本 2

.程序集 类_模块枚举, , 公开
.程序集变量 Is64, 逻辑型
.程序集变量 集_错误信息, 文本型

.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
    是否位64位进程 ()

.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
    

.子程序 是否位64位进程, 逻辑型, 公开
    Is64 ＝ Is64System ()
    返回 (Is64)

.子程序 Is64System, 逻辑型
    返回 (读环境变量 (“CommonProgramW6432”) ≠ “”)

.子程序 Unicode转Ansi, 文本型
    .参数 Unicode, 字节集
    .参数 目标编码, 整数型, 可空
    .局部变量 ll, 整数型
    .局部变量 len, 整数型
    .局部变量 ansi, 文本型

    .如果真 (Unicode ＝ { })
        返回 (“”)
    .如果真结束
    .如果真 (是否为空 (目标编码))
        目标编码 ＝ 936
    .如果真结束
    ll ＝ 取字节集长度 (Unicode) ÷ 2
    len ＝ WideCharToMultiByte (目标编码, 0, 取指针_字节集型 (Unicode), ll, 取指针_文本型 (ansi), 0, 0, 0)
    ansi ＝ 取空白文本 (len)
    WideCharToMultiByte (目标编码, 0, 取指针_字节集型 (Unicode), ll, 取指针_文本型 (ansi), len, 0, 0)
    返回 (ansi)

.子程序 十到十六, 文本型
    .参数 十进制数, 长整数型
    .局部变量 HexText, 文本型

    HexText ＝ 取空白文本 (255)
    wvsprintf (HexText, “0x%016I64X”, 十进制数)
    返回 (HexText)
    

.子程序 枚举64位进程模块, 逻辑型, 公开, 返回假可调用  取最后错误 来获取错误信息
    .参数 进程ID, 整数型
    .参数 模块, 模块信息, 参考 数组
    .局部变量 pbi, PROCESS_BASIC_INFORMATION64
    .局部变量 Ldr, PEB_LDR_DATA
    .局部变量 局_缓冲区, 字节集
    .局部变量 局_临时地址, 长整数型
    .局部变量 局_Flink地址, 长整数型
    .局部变量 局_结构信息, LDR_DATA_TABLE_ENTRY64
    .局部变量 局_模块路径, 文本型
    .局部变量 局_32位进程, 逻辑型
    .局部变量 hSnapShot, 整数型
    .局部变量 End, 整数型
    .局部变量 Process, 整数型
    .局部变量 局_临时模块, 模块信息

    Process ＝ OpenProcess (1040, 0, 进程ID)
    .如果真 (Process ＝ 0)
        集_错误信息 ＝ “打开目标进程失败,无法枚举进程模块!”
        返回 (假)
    .如果真结束
    .如果真 (Is64)
        ' ==============枚举64位进程模块=========================
        .如果真 (NtWow64QueryInformationProcess64_Basic (Process, 0, pbi, 48, 0) ≠ 0)
            集_错误信息 ＝ “查询进程信息失败,无法枚举进程64位模块!”
            CloseHandle (Process)
            返回 (假)
        .如果真结束
        ' 得到PEB64结构的地址
        .如果真 (pbi.PebBaseAddress ＝ 0)
            集_错误信息 ＝ “获取PEB64结构地址失败,无法枚举进程64位模块!”
            CloseHandle (Process)
            返回 (假)
        .如果真结束
        ' 获取Ldr64结构地址
        .如果真 (NtWow64ReadVirtualMemory64_LDR (Process, pbi.PebBaseAddress, Ldr, 40, 0) ≠ 0)
            集_错误信息 ＝ “获取Ldr64结构地址失败,无法枚举进程64位模块!”
            CloseHandle (Process)
            返回 (假)
        .如果真结束
        ' 获取Ldr64.InLoadOrderModuleList.Flink地址
        局_缓冲区 ＝ 取空白字节集 (8)
        .如果真 (NtWow64ReadVirtualMemory64_bin (Process, Ldr.Ldr ＋ 16, 局_缓冲区, 8, 0) ≠ 0)
            集_错误信息 ＝ “获取Ldr64.InLoadOrderModuleList.Flink地址失败,无法枚举进程64位模块!”
            CloseHandle (Process)
            返回 (假)
        .如果真结束
        局_临时地址 ＝ 取字节集数据 (局_缓冲区, #长整数型, 1) ' 得到Ldr64.InLoadOrderModuleList.Flink地址
        局_Flink地址 ＝ 局_临时地址
        ' 开始遍历链表
        .循环判断首 ()
            局_缓冲区 ＝ 取空白字节集 (104) ' LDR_DATA_TABLE_ENTRY64 结构的大小是 104
            .如果真 (NtWow64ReadVirtualMemory64_bin (Process, 局_临时地址, 局_缓冲区, 104, 0) ＝ 0)
                RtlMoveMemory_LDR_DATA_TABLE_ENTRY64 (局_结构信息, 局_缓冲区, 104)
                .如果真 (局_结构信息.DllBase ＝ 0)
                    跳出循环 ()
                .如果真结束
                ' 链表中第一个模块地址是程序本身 把它过滤掉
                .如果真 (局_Flink地址 ＝ 局_临时地址)
                    局_临时地址 ＝ 局_结构信息.InLoadOrderLinks.Flink
                    ' 跳出循环 ()
                .如果真结束
                ' 读取64位的模块路径
                局_缓冲区 ＝ 取空白字节集 (局_结构信息.FullDllName.Length)
                .如果真 (NtWow64ReadVirtualMemory64_bin (Process, 局_结构信息.FullDllName.Buffer, 局_缓冲区, 局_结构信息.FullDllName.Length, 0) ＝ 0)
                    局_模块路径 ＝ Unicode转Ansi (局_缓冲区)
                    局_临时模块.模块句柄 ＝ 十到十六 (局_结构信息.DllBase)
                    局_临时模块.模块路径 ＝ 局_模块路径
                    加入成员 (模块, 局_临时模块)
                    
                .如果真结束
                局_临时地址 ＝ 局_结构信息.InLoadOrderLinks.Flink
            .如果真结束
            
        .循环判断尾 (局_结构信息.DllBase ≠ 0)
        返回 (真)
    .如果真结束
    CloseHandle (Process)
    返回 (假)

.子程序 枚举32位进程模块, 逻辑型, 公开, 返回假可调用  取最后错误 来获取错误信息
    .参数 进程ID, 整数型
    .参数 模块, 模块信息, 参考 数组
    .局部变量 pbi, PROCESS_BASIC_INFORMATION64
    .局部变量 Ldr, PEB_LDR_DATA
    .局部变量 局_缓冲区, 字节集
    .局部变量 局_临时地址, 长整数型
    .局部变量 局_Flink地址, 长整数型
    .局部变量 局_结构信息, LDR_DATA_TABLE_ENTRY64
    .局部变量 局_模块路径, 文本型
    .局部变量 局_32位进程, 逻辑型
    .局部变量 hSnapShot, 整数型
    .局部变量 Mod, 精易_模块信息
    .局部变量 End, 整数型
    .局部变量 Process, 整数型
    .局部变量 局_临时模块, 模块信息

    Process ＝ OpenProcess (1040, 0, 进程ID)
    .如果真 (Process ＝ 0)
        集_错误信息 ＝ “打开目标进程失败,无法枚举进程模块!”
        返回 (假)
    .如果真结束
    IsWow64Process (Process, 局_32位进程)
    
    .如果真 (Is64 ＝ 假 或 局_32位进程)
        hSnapShot ＝ CreateToolhelp32Snapshot (8, 进程ID)
        .如果真 (hSnapShot ＞ 0)
            ' 编辑框.加入文本 (#换行符 ＋ “--------------------以下是32位模块信息---------------------------------” ＋ #换行符 ＋ #换行符)
            Mod.size ＝ 1024
            End ＝ Module32First (hSnapShot, Mod)
            .判断循环首 (End ≠ 0)
                ' 由于32位进程在64位系统中运行 存在系统目录的重定向问题 所以要修正一下路径
                ' 比如 C:\Windows\System32 其实指向的路径是 C:\Windows\SysWOW64
                局_模块路径 ＝ 到文本 (Mod.模块完整路径)
                .如果真 (Is64)
                    局_模块路径 ＝ 子文本替换 (局_模块路径, “C:\Windows\System32”, “C:\Windows\SysWOW64”, , 1, 假)
                .如果真结束
                局_临时模块.模块句柄 ＝ 取十六进制文本 (Mod.模块句柄)
                局_临时模块.模块路径 ＝ 局_模块路径
                加入成员 (模块, 局_临时模块)
                End ＝ Module32Next (hSnapShot, Mod)
            .判断循环尾 ()
            返回 (真)
        .如果真结束
        CloseHandle (hSnapShot)
    .如果真结束
    CloseHandle (Process)
    返回 (假)

.子程序 枚举进程模块, , 公开, 自动判断64或32
    .参数 进程ID, 整数型
    .参数 模块, 模块信息, 参考 数组
    .局部变量 pbi, PROCESS_BASIC_INFORMATION64
    .局部变量 Ldr, PEB_LDR_DATA
    .局部变量 局_缓冲区, 字节集
    .局部变量 局_临时地址, 长整数型
    .局部变量 局_Flink地址, 长整数型
    .局部变量 局_结构信息, LDR_DATA_TABLE_ENTRY64
    .局部变量 局_模块路径, 文本型
    .局部变量 局_32位进程, 逻辑型
    .局部变量 hSnapShot, 整数型
    .局部变量 Mod, 精易_模块信息
    .局部变量 End, 整数型
    .局部变量 Process, 整数型
    .局部变量 局_临时模块, 模块信息

    Process ＝ OpenProcess (1040, 0, 进程ID)
    .如果真 (Process ＝ 0)
        集_错误信息 ＝ “打开目标进程失败,无法枚举进程模块!”
        返回 ()
    .如果真结束
    .如果真 (Is64)
        ' ==============枚举64位进程模块=========================
        .如果真 (NtWow64QueryInformationProcess64_Basic (Process, 0, pbi, 48, 0) ≠ 0)
            集_错误信息 ＝ “查询进程信息失败,无法枚举进程64位模块!”
            CloseHandle (Process)
            返回 ()
        .如果真结束
        ' 得到PEB64结构的地址
        .如果真 (pbi.PebBaseAddress ＝ 0)
            集_错误信息 ＝ “获取PEB64结构地址失败,无法枚举进程64位模块!”
            CloseHandle (Process)
            返回 ()
        .如果真结束
        ' 获取Ldr64结构地址
        .如果真 (NtWow64ReadVirtualMemory64_LDR (Process, pbi.PebBaseAddress, Ldr, 40, 0) ≠ 0)
            集_错误信息 ＝ “获取Ldr64结构地址失败,无法枚举进程64位模块!”
            CloseHandle (Process)
            返回 ()
        .如果真结束
        ' 获取Ldr64.InLoadOrderModuleList.Flink地址
        局_缓冲区 ＝ 取空白字节集 (8)
        .如果真 (NtWow64ReadVirtualMemory64_bin (Process, Ldr.Ldr ＋ 16, 局_缓冲区, 8, 0) ≠ 0)
            集_错误信息 ＝ “获取Ldr64.InLoadOrderModuleList.Flink地址失败,无法枚举进程64位模块!”
            CloseHandle (Process)
            返回 ()
        .如果真结束
        局_临时地址 ＝ 取字节集数据 (局_缓冲区, #长整数型, 1) ' 得到Ldr64.InLoadOrderModuleList.Flink地址
        局_Flink地址 ＝ 局_临时地址
        ' 开始遍历链表
        .循环判断首 ()
            局_缓冲区 ＝ 取空白字节集 (104) ' LDR_DATA_TABLE_ENTRY64 结构的大小是 104
            .如果真 (NtWow64ReadVirtualMemory64_bin (Process, 局_临时地址, 局_缓冲区, 104, 0) ＝ 0)
                RtlMoveMemory_LDR_DATA_TABLE_ENTRY64 (局_结构信息, 局_缓冲区, 104)
                .如果真 (局_结构信息.DllBase ＝ 0)
                    跳出循环 ()
                .如果真结束
                ' 链表中第一个模块地址是程序本身 把它过滤掉
                .如果真 (局_Flink地址 ＝ 局_临时地址)
                    局_临时地址 ＝ 局_结构信息.InLoadOrderLinks.Flink
                    ' 跳出循环 ()
                .如果真结束
                ' 读取64位的模块路径
                局_缓冲区 ＝ 取空白字节集 (局_结构信息.FullDllName.Length)
                .如果真 (NtWow64ReadVirtualMemory64_bin (Process, 局_结构信息.FullDllName.Buffer, 局_缓冲区, 局_结构信息.FullDllName.Length, 0) ＝ 0)
                    局_模块路径 ＝ Unicode转Ansi (局_缓冲区)
                    局_临时模块.模块句柄 ＝ 十到十六 (局_结构信息.DllBase)
                    局_临时模块.模块路径 ＝ 局_模块路径
                    加入成员 (模块, 局_临时模块)
                    
                .如果真结束
                局_临时地址 ＝ 局_结构信息.InLoadOrderLinks.Flink
            .如果真结束
            
        .循环判断尾 (局_结构信息.DllBase ≠ 0)
        IsWow64Process (Process, 局_32位进程)
    .如果真结束
    .如果真 (Is64 ＝ 假 或 局_32位进程)
        hSnapShot ＝ CreateToolhelp32Snapshot (8, 进程ID)
        .如果真 (hSnapShot ＞ 0)
            
            Mod.size ＝ 1024
            End ＝ Module32First (hSnapShot, Mod)
            .判断循环首 (End ≠ 0)
                ' 由于32位进程在64位系统中运行 存在系统目录的重定向问题 所以要修正一下路径
                ' 比如 C:\Windows\System32 其实指向的路径是 C:\Windows\SysWOW64
                局_模块路径 ＝ 到文本 (Mod.模块完整路径)
                .如果真 (Is64)
                    局_模块路径 ＝ 子文本替换 (局_模块路径, “C:\Windows\System32”, “C:\Windows\SysWOW64”, , 1, 假)
                .如果真结束
                局_临时模块.模块句柄 ＝ 取十六进制文本 (Mod.base)
                局_临时模块.模块路径 ＝ 局_模块路径
                加入成员 (模块, 局_临时模块)
                End ＝ Module32Next (hSnapShot, Mod)
            .判断循环尾 ()
            
        .如果真结束
        CloseHandle (hSnapShot)
    .如果真结束
    CloseHandle (Process)

.子程序 取最后错误, 文本型, 公开
    返回 (集_错误信息)

.子程序 取文件名, 文本型, 公开
    .参数 文件路径, 文本型
    .局部变量 文本, 文本型

    文本 ＝ 文件路径
    .判断循环首 (真)
        .如果真 (寻找文本 (文本, “\”, , 假) ＝ -1)
            跳出循环 ()
        .如果真结束
        文本 ＝ 取文本右边 (文本, 取文本长度 (文本) － 寻找文本 (文本, “\”, , 假))
    .判断循环尾 ()
    返回 (文本)

.子程序 模块名取句柄, 文本型, 公开, 枚举64位进程模块，返回指定模块名的十六进制句柄。
    .参数 进程ID, 整数型
    .参数 模块名, 文本型
    .局部变量 模块, 模块信息, , "0"
    .局部变量 i, 整数型

    枚举64位进程模块 (进程ID, 模块)
    .计次循环首 (取数组成员数 (模块), i)
        .如果真 (取文件名 (模块 [i].模块路径) ＝ 模块名)
            返回 (模块 [i].模块句柄)
        .如果真结束
        
    .计次循环尾 ()
    返回 (“”)

.版本 2

.程序集 类_环境存取, , 公开
.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
    

.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
    CoUninitialize ()

.子程序 读环境变量, 文本型, 公开, 返回文本，它关连于一个操作系统环境变量。成功时返回所取得的值，失败则返回空文本。
    .参数 用户环境变量, 逻辑型, 可空, 真为当前用户环境变量，假为系统环境变量。
    .参数 环境变量名称, 文本型
    .局部变量 objcet, 对象
    .局部变量 sysenv, 对象
    .局部变量 text, 文本型
    .局部变量 Length, 整数型

    CoInitialize (0)
    .如果真 (objcet.创建 (“WScript.Shell”, ))
        sysenv ＝ objcet.对象型方法 (“Environment”, 选择 (用户环境变量, “user”, “system”))
        text ＝ sysenv.读文本属性 (“Item”, 环境变量名称)
        objcet.清除 ()
        .如果真 (text ＝ “”)
            text ＝ 取空白文本 (256)
            Length ＝ GetEnvironmentVariable (环境变量名称, text, 256)
            返回 (选择 (Length ＞ 0, text, “”))
        .如果真结束
        返回 (text)
    .如果真结束
    返回 (“”)

.子程序 写环境变量, 逻辑型, 公开, 修改或建立指定的操作系统环境变量。成功返回真，失败返回假。
    .参数 用户环境变量, 逻辑型, 可空, 真为当前用户环境变量，假为系统环境变量。
    .参数 环境变量名称, 文本型
    .参数 欲写入内容, 文本型
    .局部变量 objcet, 对象
    .局部变量 sysenv, 对象
    .局部变量 bool, 逻辑型

    CoInitialize (0)
    .如果真 (objcet.创建 (“WScript.Shell”, ))
        sysenv ＝ objcet.对象型方法 (“Environment”, 选择 (用户环境变量, “user”, “system”))
        bool ＝ sysenv.写属性 (“Item”, 环境变量名称, 欲写入内容)
        objcet.清除 ()
        返回 (bool)
    .如果真结束
    返回 (假)

.子程序 删除环境变量, 逻辑型, 公开, 删除系统环境变量，成功返回真，失败返回假。
    .参数 用户环境变量, 逻辑型, 可空, 真为当前用户环境变量，假为系统环境变量。
    .参数 环境变量名称, 文本型
    .局部变量 objcet, 对象
    .局部变量 sysenv, 对象
    .局部变量 bool, 逻辑型

    CoInitialize (0)
    .如果真 (objcet.创建 (“WScript.Shell”, ))
        sysenv ＝ objcet.对象型方法 (“Environment”, 选择 (用户环境变量, “user”, “system”))
        bool ＝ sysenv.数值方法 (“Remove”, 环境变量名称) ＝ 0
        sysenv.清除 ()
        objcet.清除 ()
        返回 (bool)
    .如果真结束
    返回 (假)

.子程序 取环境变量数, 整数型, 公开, 返回当前用户环境变量数量，失败返回-1。
    .参数 用户环境变量, 逻辑型, 可空, 真为当前用户环境变量，假为系统环境变量。
    .局部变量 objcet, 对象
    .局部变量 sysenv, 对象
    .局部变量 length

    CoInitialize (0)
    .如果真 (objcet.创建 (“WScript.Shell”, ))
        sysenv ＝ objcet.对象型方法 (“Environment”, 选择 (用户环境变量, “user”, “system”))
        length ＝ sysenv.读数值属性 (“length”, )
        sysenv.清除 ()
        objcet.清除 ()
        返回 (length)
    .如果真结束
    返回 (-1)

.子程序 枚举环境变量, 整数型, 公开, 成功返回环境系统或当前用户环境变量数量失败返回-1。
    .参数 用户环境变量, 逻辑型, 可空, 真为当前用户环境变量，假为系统环境变量。
    .参数 环境变量列表, 文本型, 数组, 变量储存返回值。
    .局部变量 objcet, 对象
    .局部变量 sysenv, 对象
    .局部变量 NewEnum, 对象
    .局部变量 Success
    .局部变量 Variant, 变体型
    .局部变量 pcFetched, 整数型

    CoInitialize (0)
    .如果真 (objcet.创建 (“WScript.Shell”, ))
        sysenv ＝ objcet.对象型方法 (“Environment”, 选择 (用户环境变量, “user”, “system”))
        NewEnum ＝ sysenv.对象型方法 (“_NewEnum”, )
        .循环判断首 ()
            Success ＝ CallObject (取对象指针 (NewEnum), 3, 1, 取变体型指针 (Variant), 取指针整数_ (pcFetched), , , , , , )
            .如果真 (pcFetched ＝ 1)
                加入成员 (环境变量列表, Variant.取文本 ())
            .如果真结束
            处理事件 ()
        .循环判断尾 (Success ＝ 0)
        sysenv.清除 ()
        objcet.清除 ()
        返回 (取数组成员数 (环境变量列表))
    .如果真结束
    返回 (-1)

.子程序 取命令行, 整数型, 公开, 本命令可以取出在启动易程序时附加在其可执行文件名后面的所有以空格分隔的命令行文本段
    .参数 命令行数组, 文本型, 数组, 存放被取回命令行文本的数组变量,本变量数组内被顺序填入在启动易程序时附加在其可执行文件名后面的以空格分隔的命令行文本段
    .局部变量 szArglist, 整数型
    .局部变量 nArgs, 整数型
    .局部变量 Command, 整数型, , "0"
    .局部变量 Length, 整数型
    .局部变量 i, 整数型

    清除数组 (命令行数组)
    szArglist ＝ CommandLineToArgvW (GetCommandLineW (), nArgs)
    .如果真 (nArgs ＝ 1)
        返回 (0)
    .如果真结束
    重定义数组 (Command, 假, nArgs)
    Length ＝ lstrlen (szArglist) × 2
    RtlMoveMemory (取数据_通用型_数组 (Command), szArglist, Length)
    .变量循环首 (2, nArgs, 1, i)
        加入成员 (命令行数组, 编码_Unicode到Ansi (指针到字节集 (Command [i], lstrlen (Command [i]) × 2)))
    .变量循环尾 ()
    LocalFree (szArglist)
    返回 (取数组成员数 (命令行数组))
    

.子程序 取运行目录, 文本型, 公开, 取当前被执行的易程序文件所处的目录。
    .局部变量 path, 文本型
    .局部变量 Length

    path ＝ 取空白文本 (255)
    Length ＝ GetCurrentDirectory (255, path)
    返回 (选择 (Length ＞ 0, path, “”))

.子程序 取执行文件名, 文本型, 公开, 取当前被执行的易程序文件的名称。
    .参数 是否带路径, 逻辑型, 可空
    .局部变量 sbuffer, 文本型
    .局部变量 Length

    sbuffer ＝ 取空白文本 (256)
    Length ＝ GetModuleFileNameExA (GetCurrentProcess (), GetModuleHandleA (字符 (0)), sbuffer, 256)
    .如果真 (Length ＞ 0)
        .如果 (是否带路径)
            返回 (sbuffer)
        .否则
            返回 (文件_取文件名 (sbuffer, 真))
        .如果结束
        
    .如果真结束
    返回 (“”)

.子程序 取CMD路径, 文本型, 公开
    .局部变量 sbuffer, 文本型
    .局部变量 Length

    sbuffer ＝ 取空白文本 (256)
    Length ＝ GetEnvironmentVariable (“COMSPEC”, sbuffer, 256)
    返回 (选择 (Length ＞ 0, sbuffer, “”))

.版本 2

.程序集 类_磁盘信息, , 公开, MSDN:https://msdn.microsoft.com/en-us/library/aa394132(v=vs.85).aspx
.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
    

.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
    

.子程序 _格式化文本, 文本型
    .参数 文本1, 文本型
    .局部变量 局_临时文本, 文本型

    局_临时文本 ＝ 子文本替换 (文本1, “\”, “\\”, , , 真)
    返回 (子文本替换 (“Select * From Win32_DiskDrive WHERE Name='{0}'”, “{0}”, 局_临时文本, , , 真))

.子程序 枚举硬盘, 整数型, 公开
    .参数 磁盘名称, 文本型, 可空 数组, 变量储存返回值。
    .局部变量 局_句柄, 整数型
    .局部变量 局_返回值
    .局部变量 局_下一对象
    .局部变量 局_枚举对象
    .局部变量 局_变体型, 变体型
    .局部变量 pcFetched, 整数型

    局_句柄 ＝ COM_连接命名空间 (“root\CIMV2”)
    .如果真 (局_句柄 ＞ 0)
        局_返回值 ＝ IWbemServices_ExecQuery (局_句柄, COM_bstr_t (“WQL”), COM_bstr_t (“Select Name From Win32_DiskDrive”), 位或 (32, 16), 0, 局_枚举对象)
        .如果真 (局_返回值 ＝ 0)
            .循环判断首 ()
                局_返回值 ＝ IEnumWbemClassObject_Next (局_枚举对象, 2000, 1, 局_下一对象, pcFetched)
                .如果真 (局_返回值 ＝ 0)
                    局_返回值 ＝ IWbemClassObject_Get (局_下一对象, COM_bstr_t (“Name”), 0, 取变体型指针 (局_变体型), 0, 0)
                    .如果真 (局_返回值 ＝ 0)
                        加入成员 (磁盘名称, 局_变体型.取文本 ())
                        COM_Release (局_下一对象)
                    .如果真结束
                    
                .如果真结束
                
            .循环判断尾 (pcFetched ＝ 1)
        .如果真结束
        COM_Release (局_句柄)
    .如果真结束
    返回 (取数组成员数 (磁盘名称))
    

.子程序 取描述, 文本型, 公开
    .参数 硬盘名称, 文本型, , 由 枚举硬盘 命令返回。

    返回 (查询类属性 (_格式化文本 (硬盘名称), “Description”).取文本 ())

.子程序 取固件版本, 文本型, 公开, 这个属性不支持Server 2003系统。
    .参数 硬盘名称, 文本型, , 由 枚举硬盘 命令返回。

    返回 (查询类属性 (_格式化文本 (硬盘名称), “FirmwareRevision”).取文本 ())

.子程序 取索引, 整数型, 公开
    .参数 硬盘名称, 文本型, , 由 枚举硬盘 命令返回。

    返回 (查询类属性 (_格式化文本 (硬盘名称), “index”).取数值 ())

.子程序 取接口类型, 文本型, 公开
    .参数 硬盘名称, 文本型, , 由 枚举硬盘 命令返回。

    返回 (查询类属性 (_格式化文本 (硬盘名称), “InterfaceType”).取文本 ())

.子程序 取制造商, 文本型, 公开
    .参数 硬盘名称, 文本型, , 由 枚举硬盘 命令返回。

    返回 (查询类属性 (_格式化文本 (硬盘名称), “Manufacturer”).取文本 ())

.子程序 是否加载媒体, 逻辑型, 公开
    .参数 硬盘名称, 文本型, , 由 枚举硬盘 命令返回。

    返回 (查询类属性 (_格式化文本 (硬盘名称), “MediaLoaded”).取逻辑值 ())

.子程序 取媒体类型, 文本型, 公开
    .参数 硬盘名称, 文本型, , 由 枚举硬盘 命令返回。

    返回 (查询类属性 (_格式化文本 (硬盘名称), “MediaType”).取文本 ())

.子程序 取型号, 文本型, 公开
    .参数 硬盘名称, 文本型, , 由 枚举硬盘 命令返回。

    返回 (查询类属性 (_格式化文本 (硬盘名称), “Model”).取文本 ())

.子程序 取分区数, 整数型, 公开
    .参数 硬盘名称, 文本型, , 由 枚举硬盘 命令返回。

    返回 (查询类属性 (_格式化文本 (硬盘名称), “Partitions”).取数值 ())

.子程序 取PNP设备ID, 文本型, 公开, Windows逻辑设备的即插即用设备标识符。
    .参数 硬盘名称, 文本型, , 由 枚举硬盘 命令返回。

    返回 (查询类属性 (_格式化文本 (硬盘名称), “PNPDeviceID”).取文本 ())

.子程序 取SCSI总线, 文本型, 公开
    .参数 硬盘名称, 文本型, , 由 枚举硬盘 命令返回。

    返回 (查询类属性 (_格式化文本 (硬盘名称), “SCSIBus”).取文本 ())

.子程序 取SCSI逻辑单元, 文本型, 公开
    .参数 硬盘名称, 文本型, , 由 枚举硬盘 命令返回。

    返回 (查询类属性 (_格式化文本 (硬盘名称), “SCSILogicalUnit”).取文本 ())

.子程序 取SCSI端口, 文本型, 公开
    .参数 硬盘名称, 文本型, , 由 枚举硬盘 命令返回。

    返回 (查询类属性 (_格式化文本 (硬盘名称), “scsiport”).取文本 ())

.子程序 取SCSI目标ID, 文本型, 公开
    .参数 硬盘名称, 文本型, , 由 枚举硬盘 命令返回。

    返回 (查询类属性 (_格式化文本 (硬盘名称), “SCSITargetId”).取文本 ())

.子程序 取磁道扇区, 整数型, 公开
    .参数 硬盘名称, 文本型, , 由 枚举硬盘 命令返回。

    返回 (查询类属性 (_格式化文本 (硬盘名称), “SectorsPerTrack”).取数值 ())

.子程序 取序列号, 文本型, 公开, 这个属性不支持Server 2003系统。
    .参数 硬盘名称, 文本型, , 由 枚举硬盘 命令返回。

    返回 (删首尾空 (查询类属性 (_格式化文本 (硬盘名称), “SerialNumber”).取文本 ()))

.子程序 取特征字, 整数型, 公开
    .参数 硬盘名称, 文本型, , 由 枚举硬盘 命令返回。

    返回 (查询类属性 (_格式化文本 (硬盘名称), “Signature”).取数值 ())

.子程序 取总大小, 长整数型, 公开
    .参数 硬盘名称, 文本型, , 由 枚举硬盘 命令返回。

    返回 (查询类属性 (_格式化文本 (硬盘名称), “Size”).取数值 ())

.子程序 取总的柱面数, 长整数型, 公开
    .参数 硬盘名称, 文本型, , 由 枚举硬盘 命令返回。

    返回 (查询类属性 (_格式化文本 (硬盘名称), “TotalCylinders”).取数值 ())

.子程序 取柱面磁道, 整数型, 公开
    .参数 硬盘名称, 文本型, , 由 枚举硬盘 命令返回。

    返回 (查询类属性 (_格式化文本 (硬盘名称), “TotalHeads”).取数值 ())

.子程序 取总的扇区数, 长整数型, 公开
    .参数 硬盘名称, 文本型, , 由 枚举硬盘 命令返回。

    返回 (查询类属性 (_格式化文本 (硬盘名称), “TotalSectors”).取数值 ())

.子程序 取总的磁道数, 长整数型, 公开
    .参数 硬盘名称, 文本型, , 由 枚举硬盘 命令返回。

    返回 (查询类属性 (_格式化文本 (硬盘名称), “TotalTracks”).取数值 ())

.子程序 取扇区字节, 整数型, 公开
    .参数 硬盘名称, 文本型, , 由 枚举硬盘 命令返回。

    返回 (查询类属性 (_格式化文本 (硬盘名称), “BytesPerSector”).取数值 ())

.版本 2

.程序集 类_系统信息, , 公开, http://msdn.microsoft.com/en-us/library/aa394239(v=vs.85).aspx
.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
    

.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
    

.子程序 取建立号码, 整数型, 公开
    返回 (查询类属性 (“Select BuildNumber From Win32_OperatingSystem”, “BuildNumber”).取数值 ())

.子程序 取引导设备, 文本型, 公开
    返回 (删首尾空 (查询类属性 (“Select BootDevice From Win32_OperatingSystem”, “BootDevice”).取文本 ()))

.子程序 取内部版本类型, 文本型, 公开
    返回 (删首尾空 (查询类属性 (“Select BuildType From Win32_OperatingSystem”, “BuildType”).取文本 ()))

.子程序 取标题, 文本型, 公开
    返回 (删首尾空 (查询类属性 (“Select Caption From Win32_OperatingSystem”, “Caption”).取文本 ()))

.子程序 取代码集, 文本型, 公开
    返回 (删首尾空 (查询类属性 (“Select CodeSet From Win32_OperatingSystem”, “CodeSet”).取文本 ()))

.子程序 取国家代码, 文本型, 公开
    返回 (删首尾空 (查询类属性 (“Select CountryCode From Win32_OperatingSystem”, “CountryCode”).取文本 ()))

.子程序 取最后服务包, 文本型, 公开
    返回 (删首尾空 (查询类属性 (“Select CSDVersion From Win32_OperatingSystem”, “CSDVersion”).取文本 ()))

.子程序 取域名称, 文本型, 公开
    返回 (删首尾空 (查询类属性 (“Select CSName From Win32_OperatingSystem”, “CSName”).取文本 ()))

.子程序 取当前时区, 整数型, 公开
    返回 (查询类属性 (“Select CurrentTimeZone From Win32_OperatingSystem”, “CurrentTimeZone”).取数值 ())

.子程序 数据执行保护_是否有效, 逻辑型, 公开, 不支持2003系统。
    返回 (查询类属性 (“Select DataExecutionPrevention_Available From Win32_OperatingSystem”, “DataExecutionPrevention_Available”).取逻辑值 ())

.子程序 数据执行保护_支持32位程序, 逻辑型, 公开, 不支持2003系统。
    返回 (查询类属性 (“Select DataExecutionPrevention_32BitApplications From Win32_OperatingSystem”, “DataExecutionPrevention_32BitApplications”).取逻辑值 ())

.子程序 数据执行保护_设备正常, 逻辑型, 公开, 不支持2003系统。
    返回 (查询类属性 (“Select DataExecutionPrevention_Drivers From Win32_OperatingSystem”, “DataExecutionPrevention_Drivers”).取逻辑值 ())

.子程序 数据执行保护_支持方式, 整数型, 公开, 不支持2003系统。
    返回 (查询类属性 (“Select DataExecutionPrevention_SupportPolicy From Win32_OperatingSystem”, “DataExecutionPrevention_SupportPolicy”).取数值 ())

.子程序 是否支持调试, 逻辑型, 公开
    返回 (查询类属性 (“Select Debug From Win32_OperatingSystem”, “Debug”).取逻辑值 ())

.子程序 取描述, 文本型, 公开
    返回 (删首尾空 (查询类属性 (“Select Description From Win32_OperatingSystem”, “Description”).取文本 ()))

.子程序 是否分布式系统, 逻辑型, 公开
    返回 (查询类属性 (“Select Distributed From Win32_OperatingSystem”, “Distributed”).取逻辑值 ())

.子程序 取加密位数, 整数型, 公开
    返回 (查询类属性 (“Select EncryptionLevel From Win32_OperatingSystem”, “EncryptionLevel”).取数值 ())

.子程序 前台程序加速, 整数型, 公开, 0表示无，1最小，2最大(默认)
    返回 (查询类属性 (“Select ForegroundApplicationBoost From Win32_OperatingSystem”, “ForegroundApplicationBoost”).取数值 ())

.子程序 取剩余物理内存, 长整数型, 公开
    返回 (查询类属性 (“Select FreePhysicalMemory From Win32_OperatingSystem”, “FreePhysicalMemory”).取数值 ())

.子程序 取可用页面文件, 长整数型, 公开
    返回 (查询类属性 (“Select FreeSpaceInPagingFiles From Win32_OperatingSystem”, “FreeSpaceInPagingFiles”).取数值 ())

.子程序 取操作系统名称, 文本型, 公开
    返回 (删首尾空 (查询类属性 (“Select Caption From Win32_OperatingSystem”, “Caption”).取文本 ()))

.子程序 取可用虚拟内存, 长整数型, 公开
    返回 (查询类属性 (“Select FreeVirtualMemory From Win32_OperatingSystem”, “FreeVirtualMemory”).取数值 ())

.子程序 取安装日期, 日期时间型, 公开
    返回 (时间_WMI时间转日期 (删首尾空 (查询类属性 (“Select InstallDate From Win32_OperatingSystem”, “InstallDate”).取文本 ())))

.子程序 取最后关机时间, 日期时间型, 公开
    返回 (时间_WMI时间转日期 (删首尾空 (查询类属性 (“Select LastBootUpTime From Win32_OperatingSystem”, “LastBootUpTime”).取文本 ())))

.子程序 取现行时间, 日期时间型, 公开
    返回 (时间_WMI时间转日期 (删首尾空 (查询类属性 (“Select LocalDateTime From Win32_OperatingSystem”, “LocalDateTime”).取文本 ())))

.子程序 取语言环境, 文本型, 公开
    返回 (删首尾空 (查询类属性 (“Select Locale From Win32_OperatingSystem”, “Locale”).取文本 ()))

.子程序 取制造商, 文本型, 公开
    返回 (删首尾空 (查询类属性 (“Select Manufacturer From Win32_OperatingSystem”, “Manufacturer”).取文本 ()))

.子程序 取最大进程数, 整数型, 公开
    返回 (查询类属性 (“Select MaxNumberOfProcesses From Win32_OperatingSystem”, “MaxNumberOfProcesses”).取数值 ())

.子程序 取最大进程内存, 长整数型, 公开
    返回 (查询类属性 (“Select MaxProcessMemorySize From Win32_OperatingSystem”, “MaxProcessMemorySize”).取数值 ())

.子程序 取多国语言包, 整数型, 公开
    .参数 返回语言包, 文本型, 数组, 变量储存返回值。
    .局部变量 局_数量
    .局部变量 局_变量, 变体型
    .局部变量 局_计次

    局_变量 ＝ 查询类属性 (“Select MUILanguages From Win32_OperatingSystem”, “MUILanguages”)
    局_数量 ＝ 局_变量.取数组成员数 ()
    .变量循环首 (1, 局_数量, 1, 局_计次)
        加入成员 (返回语言包, 局_变量.取变体型 (局_计次).取文本 ())
    .变量循环尾 ()
    返回 (局_数量)

.子程序 取授权用户数, 整数型
    返回 (查询类属性 (“Select NumberOfLicensedUsers From Win32_OperatingSystem”, “NumberOfLicensedUsers”).取数值 ())

.子程序 取进程数, 整数型, 公开
    返回 (查询类属性 (“Select NumberOfProcesses From Win32_OperatingSystem”, “NumberOfProcesses”).取数值 ())

.子程序 取用户会话数, 整数型, 公开
    返回 (查询类属性 (“Select NumberOfUsers From Win32_OperatingSystem”, “NumberOfUsers”).取数值 ())

.子程序 取系统SKU, 整数型, 公开, 不支持，Windows Server 2003:返回值；0=未定；1=终极版；2=家庭基础版；3=家庭高级版；4=企业版；5=家庭基本版N版;6=商业版;7=标准服务器版;8=数据中心服务器版;9=小型企业服务器版;10=企业服务器版;11=入门版;12=数据中心服务器核心版;13=标准的服务器核心版;14=企业服务器核心版;15=企业服务器版itanium系统;16=企业版N版;17=Web服务器版;18=集群服务器版;19=家庭服务器版;20=存储Express服务器版;21=存储标准服务器版;22=存储工作组服务器版;23=存储企业服务器版;24=服务器为小型企业版;25=Small Business Server Premium Edition;29=Web Server, Server Core;39=Datacenter Edition without Hyper-V, Server Core;40=Standard Edition without Hyper-V, Server Core;41=Enterprise Edition without Hyper-V, Server Core;42=Hyper-V服务器。
    返回 (查询类属性 (“Select OperatingSystemSKU From Win32_OperatingSystem”, “OperatingSystemSKU”).取数值 ())

.子程序 取国家, 文本型, 公开
    返回 (删首尾空 (查询类属性 (“Select Organization From Win32_OperatingSystem”, “Organization”).取文本 ()))

.子程序 取系统位数, 文本型, 公开, 不支持，Windows Server 2003:
    返回 (删首尾空 (查询类属性 (“Select OSArchitecture From Win32_OperatingSystem”, “OSArchitecture”).取文本 ()))

.子程序 取系统语言, 整数型, 公开, 如2052表示，中文(简体)-中华人民共和国
    返回 (查询类属性 (“Select OSLanguage From Win32_OperatingSystem”, “OSLanguage”).取数值 ())

.子程序 取系统套件, 整数型, 公开
    返回 (查询类属性 (“Select OSProductSuite From Win32_OperatingSystem”, “OSProductSuite”).取数值 ())

.子程序 取系统类型, 整数型, 公开, 0=未知；1=其它；2=宏命令；3=ATTUNIX；4=DGUX；5=DECNT；
    返回 (查询类属性 (“Select OSType From Win32_OperatingSystem”, “OSType”).取数值 ())

.子程序 是否为NT系统, 逻辑型, 公开
    .局部变量 OSType

    OSType ＝ 查询类属性 (“Select OSType From Win32_OperatingSystem”, “OSType”).取数值 ()
    返回 (OSType ＝ 18)

.子程序 取其它类型描述, 文本型, 公开
    返回 (删首尾空 (查询类属性 (“Select OtherTypeDescription From Win32_OperatingSystem”, “OtherTypeDescription”).取文本 ()))

.子程序 PAE是否启用, 逻辑型, 公开
    返回 (查询类属性 (“Select PAEEnabled From Win32_OperatingSystem”, “PAEEnabled”).取逻辑值 ())

.子程序 取附加产品ID, 文本型, 公开
    返回 (删首尾空 (查询类属性 (“Select PlusProductID From Win32_OperatingSystem”, “PlusProductID”).取文本 ()))

.子程序 取附加版本号, 整数型, 公开
    返回 (查询类属性 (“Select PlusVersionNumber From Win32_OperatingSystem”, “PlusVersionNumber”).取数值 ())

.子程序 是否便携式系统, 逻辑型, 公开
    返回 (查询类属性 (“Select PortableOperatingSystem From Win32_OperatingSystem”, “PortableOperatingSystem”).取逻辑值 ())

.子程序 是否主系统, 逻辑型, 公开
    返回 (查询类属性 (“Select Primary From Win32_OperatingSystem”, “Primary”).取逻辑值 ())

.子程序 是否为服务器, 逻辑型, 公开
    .局部变量 Producttype

    Producttype ＝ 查询类属性 (“Select Producttype From Win32_OperatingSystem”, “Producttype”).取数值 ()
    返回 (Producttype ＝ 3)

.子程序 取注册用户名, 文本型, 公开
    返回 (删首尾空 (查询类属性 (“Select RegisteredUser From Win32_OperatingSystem”, “RegisteredUser”).取文本 ()))

.子程序 取序列号, 文本型, 公开
    返回 (删首尾空 (查询类属性 (“Select SerialNumber From Win32_OperatingSystem”, “SerialNumber”).取文本 ()))

.子程序 取服务包主版本号, 整数型, 公开
    返回 (查询类属性 (“Select ServicePackMajorVersion From Win32_OperatingSystem”, “ServicePackMajorVersion”).取数值 ())

.子程序 取服务包次版本号, 整数型, 公开
    返回 (查询类属性 (“Select ServicePackMinorVersion From Win32_OperatingSystem”, “ServicePackMinorVersion”).取数值 ())

.子程序 取存储的分页大小, 长整数型, 公开
    返回 (查询类属性 (“Select SizeStoredInPagingFiles From Win32_OperatingSystem”, “SizeStoredInPagingFiles”).取数值 ())

.子程序 取状态, 文本型, 公开
    返回 (删首尾空 (查询类属性 (“Select Status From Win32_OperatingSystem”, “Status”).取文本 ()))

.子程序 取嵌套掩码, 整数型, 公开
    返回 (查询类属性 (“Select SuiteMask From Win32_OperatingSystem”, “SuiteMask”).取数值 ())

.子程序 取系统设备, 文本型, 公开
    返回 (删首尾空 (查询类属性 (“Select SystemDevice From Win32_OperatingSystem”, “SystemDevice”).取文本 ()))

.子程序 取系统目录, 文本型, 公开
    返回 (删首尾空 (查询类属性 (“Select SystemDirectory From Win32_OperatingSystem”, “SystemDirectory”).取文本 ()))

.子程序 取系统盘, 文本型, 公开
    返回 (删首尾空 (查询类属性 (“Select SystemDrive From Win32_OperatingSystem”, “SystemDrive”).取文本 ()))

.子程序 取总交换空间, 长整数型, 公开
    返回 (查询类属性 (“Select TotalSwapSpaceSize From Win32_OperatingSystem”, “TotalSwapSpaceSize”).取数值 ())

.子程序 取总虚拟内存, 长整数型, 公开
    返回 (查询类属性 (“Select TotalVirtualMemorySize From Win32_OperatingSystem”, “TotalVirtualMemorySize”).取数值 ())

.子程序 取总物理内存, 长整数型, 公开
    返回 (查询类属性 (“Select TotalVisibleMemorySize From Win32_OperatingSystem”, “TotalVisibleMemorySize”).取数值 ())

.子程序 取版本, 文本型, 公开
    返回 (删首尾空 (查询类属性 (“Select Version From Win32_OperatingSystem”, “Version”).取文本 ()))

.子程序 取系统安装目录, 文本型, 公开
    返回 (删首尾空 (查询类属性 (“Select WindowsDirectory From Win32_OperatingSystem”, “WindowsDirectory”).取文本 ()))

.子程序 是否为域控制器, 逻辑型, 公开
    .局部变量 Producttype

    Producttype ＝ 查询类属性 (“Select Producttype From Win32_OperatingSystem”, “Producttype”).取数值 ()
    返回 (Producttype ＝ 2)

.子程序 是否为工作站, 逻辑型, 公开
    .局部变量 Producttype

    Producttype ＝ 查询类属性 (“Select Producttype From Win32_OperatingSystem”, “Producttype”).取数值 ()
    返回 (Producttype ＝ 1)

.子程序 取当前用户, 文本型, 公开
    .局部变量 Length
    .局部变量 sbuffer, 文本型

    sbuffer ＝ 取空白文本 (256)
    .如果真 (GetUserNameA (sbuffer, 256) ＝ 1)
        返回 (sbuffer)
    .如果真结束
    返回 (“”)

.子程序 取时区, 文本型, 公开
    .局部变量 szTimeZone, 文本型
    .局部变量 m_timezone, 时区信息_
    .局部变量 lRetVal1, 整数型

    lRetVal1 ＝ GetTimeZoneInformation (m_timezone)
    szTimeZone ＝ 编码_Unicode到Ansi (到字节集 (m_timezone.StandardName))
    返回 (szTimeZone)

.子程序 取货币符号, 文本型, 公开
    .局部变量 sbuffer, 文本型

    sbuffer ＝ 取空白文本 (256)
    GetLocaleInfo (0, 20, sbuffer, 256)
    返回 (sbuffer)

.子程序 取日期格式, 文本型, 公开
    .局部变量 sbuffer, 文本型

    sbuffer ＝ 取空白文本 (256)
    GetLocaleInfo (0, 32, sbuffer, 256)
    返回 (sbuffer)
    

.子程序 取时间格式, 文本型, 公开
    .局部变量 sbuffer, 文本型

    sbuffer ＝ 取空白文本 (256)
    GetLocaleInfo (0, 4099, sbuffer, 256)
    返回 (sbuffer)
    

.版本 2

.程序集 类_系统服务, , 公开, 使用例程 - http://bbs.125.la/thread-102354-1-1.html
.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
    

.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
    

.子程序 取服务状态, 整数型, 公开, 返回值如下:1=已停止;2=开始;3=停止;4=正在运行;5=继续挂起;6=暂停挂起;7暂停.
    .参数 服务名, 文本型
    .局部变量 hSCManager, 整数型
    .局部变量 hService, 整数型
    .局部变量 Status, SERVICE_STATUS
    .局部变量 CurrentState

    hSCManager ＝ OpenSCManagerA (0, 0, #GENERIC_READ)
    .如果真 (hSCManager ≠ 0)
        hService ＝ OpenService (hSCManager, 服务名, #GENERIC_READ)
        .如果真 (hService ≠ 0)
            .如果真 (QueryServiceStatus (hService, Status))
                CurrentState ＝ Status.dwCurrentState
            .如果真结束
            CloseServiceHandle (hService)
        .如果真结束
        CloseServiceHandle (hSCManager)
    .如果真结束
    返回 (CurrentState)

.子程序 取服务类型, 整数型, 公开, 返回值如下:1=设备驱动;2=文件系统驱动;16=进程;32=自己进程或其它服务;256=交互服务.
    .参数 服务名, 文本型
    .局部变量 hSCManager, 整数型
    .局部变量 hService, 整数型
    .局部变量 Status, SERVICE_STATUS
    .局部变量 dwServiceType
    .局部变量 pcbBytesNeeded, 整数型
    .局部变量 lpServiceConfig
    .局部变量 bresult, 逻辑型

    hSCManager ＝ OpenSCManagerA (0, 0, #GENERIC_READ)
    .如果真 (hSCManager ≠ 0)
        hService ＝ OpenService (hSCManager, 服务名, #GENERIC_READ)
        .如果真 (hService ≠ 0)
            QueryServiceConfig (hService, 0, 0, pcbBytesNeeded)
            lpServiceConfig ＝ GlobalAlloc (64, pcbBytesNeeded)
            bresult ＝ QueryServiceConfig (hService, lpServiceConfig, pcbBytesNeeded, pcbBytesNeeded)
            .如果真 (bresult)
                dwServiceType ＝ 取字节集数据 (指针到字节集 (lpServiceConfig, 4), #整数型, )
            .如果真结束
            GlobalFree (lpServiceConfig)
            CloseServiceHandle (hService)
        .如果真结束
        CloseServiceHandle (hSCManager)
    .如果真结束
    返回 (dwServiceType)

.子程序 取服务描述, 文本型, 公开, 成功返回服务描述文本，失败返回空！
    .参数 服务名, 文本型
    .局部变量 hSCManager, 整数型
    .局部变量 hService, 整数型
    .局部变量 cbBufSize, 整数型
    .局部变量 hMem
    .局部变量 Return, 文本型
    .局部变量 lpBuffer, SERVICE_DESCRIPTION

    hSCManager ＝ OpenSCManagerA (0, 0, #GENERIC_READ)
    .如果真 (hSCManager ≠ 0)
        hService ＝ OpenService (hSCManager, 服务名, #SC_MANAGER_CONNECT)
        .如果真 (hService ≠ 0)
            QueryServiceConfig2 (hService, 1, 0, 0, cbBufSize)
            hMem ＝ HeapAlloc (GetProcessHeap (), 8, cbBufSize) ' GlobalAlloc (64, cbBufSize)
            .如果真 (QueryServiceConfig2 (hService, 1, hMem, cbBufSize, cbBufSize))
                CopyMemory_SERVICE_DESCRIPTION (lpBuffer, hMem, 4)
                Return ＝ lpBuffer.lpDescription
            .如果真结束
            CloseServiceHandle (hService)
            HeapFree (GetProcessHeap (), 1, hMem)
        .如果真结束
        CloseServiceHandle (hSCManager)
    .如果真结束
    返回 (Return)

.子程序 置服务描述, 逻辑型, 公开, 修改指定系统服务描述，成功返回真，失败返回假。
    .参数 服务名, 文本型, , 非显示名称。
    .参数 新描述, 文本型
    .局部变量 hSCManager
    .局部变量 hService
    .局部变量 sd
    .局部变量 szDesc
    .局部变量 bresult, 逻辑型

    hSCManager ＝ OpenSCManagerA (0, 0, #GENERIC_EXECUTE)
    .如果真 (hSCManager ≠ 0)
        hService ＝ OpenService (hSCManager, 服务名, #SERVICE_CHANGE_CONFIG)
        .如果真 (hService ≠ 0)
            szDesc ＝ lstrcpyn_文本型 (新描述, 新描述, 0)
            bresult ＝ ChangeServiceConfig2A (hService, 1, szDesc)
            CloseServiceHandle (hService)
        .如果真结束
        CloseServiceHandle (hSCManager)
    .如果真结束
    返回 (bresult)

.子程序 取显示名称, 文本型, 公开, 根据系统服务数据库名称，获取显示名称。
    .参数 服务名, 文本型
    .局部变量 hSCManager, 整数型
    .局部变量 sbuffer, 文本型
    .局部变量 bresult, 逻辑型

    hSCManager ＝ OpenSCManagerA (0, 0, #GENERIC_READ)
    .如果真 (hSCManager ≠ 0)
        sbuffer ＝ 取空白文本 (255)
        bresult ＝ GetServiceDisplayName (hSCManager, 服务名, sbuffer, 255)
        CloseServiceHandle (hSCManager)
    .如果真结束
    返回 (选择 (bresult, sbuffer, “”))

.子程序 取服务名称, 文本型, 公开, 根据系统服务数据库名称，获取显示名称。
    .参数 显示名称, 文本型
    .局部变量 hSCManager, 整数型
    .局部变量 sbuffer, 文本型
    .局部变量 Length, 整数型
    .局部变量 bresult, 逻辑型

    hSCManager ＝ OpenSCManagerA (0, 0, #GENERIC_READ)
    .如果真 (hSCManager ≠ 0)
        GetServiceKeyName (hSCManager, 显示名称, sbuffer, Length)
        sbuffer ＝ 取空白文本 (Length)
        bresult ＝ GetServiceKeyName (hSCManager, 显示名称, sbuffer, Length)
        CloseServiceHandle (hSCManager)
    .如果真结束
    返回 (选择 (bresult, sbuffer, “”))

.子程序 安装服务, 逻辑型, 公开, 创建一个系统服务项，成功返回真，失败返回假。
    .参数 服务名称, 文本型, , 系统服务数据库中ID名称，不能为中文！
    .参数 显示名称, 文本型
    .参数 执行文件, 文本型, , 文件绝对路径
    .参数 服务描述, 文本型, 可空
    .参数 允许桌面交互, 逻辑型, 可空, 可为空,默认不允许与桌面进行交互.
    .参数 服务类型, , 可空, 可为空,默认即进程.1=内核驱动;2=文件系统驱动;16=进程;32=其它服务.
    .参数 启动类型, , 可空, 可为空,默认即手动,参数;2=自动;3=手动;4=禁用.
    .参数 依存关系, 文本型, 可空, 某些服务依赖于其它服务,系统驱动程序或加载顺序组.
    .参数 登录用户, 文本型, 可空, 非本地系统,登陆用户名.
    .参数 登录密码, 文本型, 可空
    .局部变量 hSCManager, 整数型
    .局部变量 hService, 整数型

    服务类型 ＝ 选择 (是否为空 (服务类型), 16, 服务类型)
    启动类型 ＝ 选择 (是否为空 (启动类型), 3, 启动类型)
    hSCManager ＝ OpenSCManagerA (0, 0, 983103)
    .如果真 (hSCManager ≠ 0)
        .如果真 (允许桌面交互)
            服务类型 ＝ 位或 (服务类型, #SERVICE_INTERACTIVE_PROCESS)
        .如果真结束
        hService ＝ CreateService (hSCManager, 服务名称, 显示名称, #SERVICE_ALL_ACCESS, 服务类型, 启动类型, #SERVICE_ERROR_NORMAL, 执行文件, 字符 (0), 0, 依存关系, 登录用户, 登录密码)
        .如果真 (hService ≠ 0)
            置服务描述 (服务名称, 服务描述)
        .如果真结束
        CloseServiceHandle (hService)
        CloseServiceHandle (hSCManager)
    .如果真结束
    返回 (hService ≠ 0)

.子程序 卸载服务, 逻辑型, 公开, 如果服务正在运动会先停止服务然后再删除。成功返回真，失败返回假。
    .参数 服务名称, 文本型
    .局部变量 hSCManager, 整数型
    .局部变量 hService, 整数型
    .局部变量 Status, SERVICE_STATUS
    .局部变量 bresult, 逻辑型

    hSCManager ＝ OpenSCManagerA (0, 0, 983103)
    .如果真 (hSCManager ≠ 0)
        hService ＝ OpenService (hSCManager, 服务名称, 位或 (16, 32, 65536)) ' DELETE
        .如果真 (hService ≠ 0)
            bresult ＝ DeleteService (hService)
            CloseServiceHandle (hService)
        .如果真结束
        CloseServiceHandle (hSCManager)
    .如果真结束
    返回 (bresult)

.子程序 开始服务, 逻辑型, 公开, 开启一个系统服务，成功返回真，如果系统服务被禁用则返回假。
    .参数 服务名, 文本型, , 需提供系统服务数据库名非显示名称
    .局部变量 hSCManager, 整数型
    .局部变量 hService, 整数型
    .局部变量 bresult, 逻辑型

    hSCManager ＝ OpenSCManagerA (0, 0, 983103)
    .如果真 (hSCManager ≠ 0)
        hService ＝ OpenService (hSCManager, 服务名, #SERVICE_START)
        .如果真 (hService ≠ 0)
            bresult ＝ StartService (hService, 0, 0)
            CloseServiceHandle (hService)
        .如果真结束
        CloseServiceHandle (hSCManager)
    .如果真结束
    返回 (bresult)

.子程序 停止服务, 逻辑型, 公开, 停止一个存在运行的系统服务，成功返回真，失败返回假。
    .参数 服务名, 文本型, , 需提供服务名称非显示名称。
    .局部变量 hSCManager, 整数型
    .局部变量 hService, 整数型
    .局部变量 Status, SERVICE_STATUS
    .局部变量 bresult, 逻辑型

    hSCManager ＝ OpenSCManagerA (0, 0, 1) ' 1
    .如果真 (hSCManager ≠ 0)
        hService ＝ OpenService (hSCManager, 服务名, 32) ' 32
        .如果真 (hSCManager ≠ 0) ' 判断打开的服务句柄，如果为0 返回假
            bresult ＝ ControlService (hService, 1, Status)
            CloseServiceHandle (hService)
        .如果真结束
        CloseServiceHandle (hSCManager)
    .如果真结束
    返回 (bresult)

.子程序 暂停服务, 逻辑型, 公开, 暂停一个存在运行的系统服务，成功返回真，失败返回假。
    .参数 服务名称, 文本型, , 需提供服务名称非显示名称。
    .局部变量 hSCManager, 整数型
    .局部变量 hService, 整数型
    .局部变量 Status, SERVICE_STATUS
    .局部变量 bresult, 逻辑型

    hSCManager ＝ OpenSCManagerA (0, 0, 983103)
    .如果真 (hSCManager ≠ 0)
        hService ＝ OpenService (hSCManager, 服务名称, 983551)
        .如果真 (hService ≠ 0)
            bresult ＝ ControlService (hService, 2, Status)
            CloseServiceHandle (hService)
        .如果真结束
        CloseServiceHandle (hSCManager)
    .如果真结束
    返回 (bresult)

.子程序 恢复服务, 逻辑型, 公开, 恢复被暂停的系统服务，成功返回真，失败返回假。
    .参数 服务名称, 文本型, , 需提供服务名称非显示名称。
    .局部变量 hSCManager, 整数型
    .局部变量 hService, 整数型
    .局部变量 Status, SERVICE_STATUS
    .局部变量 bresult, 逻辑型

    hSCManager ＝ OpenSCManagerA (0, 0, 983103)
    .如果真 (hSCManager ≠ 0)
        hService ＝ OpenService (hSCManager, 服务名称, 983551)
        .如果真 (hService ≠ 0)
            bresult ＝ ControlService (hService, 3, Status) ' SERVICE_CONTROL_CONTINUE
            CloseServiceHandle (hService)
        .如果真结束
        CloseServiceHandle (hSCManager)
    .如果真结束
    返回 (bresult)

.子程序 是否存在, 逻辑型, 公开, 判断一个系统服务是否存在,存在返回真,否则返回假.
    .参数 服务名称, 文本型, , 需提供服务名称非显示名称。
    .局部变量 hSCManager, 整数型
    .局部变量 hService, 整数型

    hSCManager ＝ OpenSCManagerA (0, 0, #GENERIC_READ)
    .如果真 (hSCManager ≠ 0)
        hService ＝ OpenService (hSCManager, 服务名称, #GENERIC_READ)
        CloseServiceHandle (hService)
        CloseServiceHandle (hSCManager)
    .如果真结束
    返回 (hService ≠ 0)

.子程序 置启动类型, 逻辑型, 公开, 修改一个已有的系统服务启动类型，有些服务有权限是否允许操作，成功返回真，失败返回假。
    .参数 服务名称, 文本型, , 提供服务名称非服务显示名称
    .参数 启动类型, 整数型, , 启动类型以下选项：2=自动(延迟启动);3=手动;4=禁用
    .局部变量 hSCManager, 整数型
    .局部变量 hService, 整数型
    .局部变量 bresult, 逻辑型

    hSCManager ＝ OpenSCManagerA (0, 0, 983103) ' 983103
    .如果真 (hSCManager ≠ 0)
        hService ＝ OpenService (hSCManager, 服务名称, 983551) ' 983551
        .如果真 (hService ≠ 0)
            bresult ＝ ChangeServiceConfig (hService, 4294967295, 启动类型, 4294967295, 字符 (0), 字符 (0), 0, 字符 (0), 字符 (0), 字符 (0), 字符 (0))
            CloseServiceHandle (hService)
        .如果真结束
        CloseServiceHandle (hSCManager)
    .如果真结束
    返回 (bresult)

.子程序 取启动类型, 整数型, 公开, 获取指定系统服务启动类型，成功返回启动类型值;1=自动;2=自动(延迟启动);3=手动;4=禁用，失败返回-1。
    .参数 服务名称, 文本型
    .局部变量 hSCManager, 整数型
    .局部变量 hService, 整数型
    .局部变量 bresult, 逻辑型
    .局部变量 dwBytesNeeded
    .局部变量 lpsc, QUERY_SERVICE_CONFIG
    .局部变量 hMem
    .局部变量 dwStartType

    hSCManager ＝ OpenSCManagerA (0, 0, #GENERIC_READ)
    .如果真 (hSCManager ≠ 0)
        hService ＝ OpenService (hSCManager, 服务名称, 1)
        .如果真 (hService ≠ 0)
            QueryServiceConfig (hService, 0, 0, dwBytesNeeded)
            hMem ＝ GlobalAlloc (64, dwBytesNeeded)
            bresult ＝ QueryServiceConfig (hService, hMem, dwBytesNeeded, dwBytesNeeded)
            .如果真 (bresult)
                CopyMemory_QUERY_SERVICE_CONFIG (lpsc, hMem, 36)
                .判断开始 (lpsc.dwStartType ＝ 2 且 lpsc.dwServiceType ＝ 32)
                    dwStartType ＝ 1 ' 返回 (“自动”)
                .判断 (lpsc.dwStartType ＝ 2 且 lpsc.dwServiceType ＝ 16)
                    dwStartType ＝ 2 ' 返回 (“自动(延迟启动)”)
                .判断 (lpsc.dwStartType ＝ 3)
                    dwStartType ＝ 3 ' 返回 (“手动”)
                .判断 (lpsc.dwStartType ＝ 4)
                    dwStartType ＝ 4 ' 返回 (“禁用”)
                .默认
                    dwStartType ＝ -1
                .判断结束
                处理事件 ()
            .如果真结束
            CloseServiceHandle (hService)
        .如果真结束
        CloseServiceHandle (hSCManager)
        GlobalFree (hMem)
    .如果真结束
    返回 (dwStartType)

.子程序 取文件路径, 文本型, 公开, 获取指定系统服务可执行文件的路径，失败返回空文本。
    .参数 服务名称, 文本型
    .局部变量 hSCManager, 整数型
    .局部变量 hService, 整数型
    .局部变量 bresult, 逻辑型
    .局部变量 dwBytesNeeded
    .局部变量 lpsc, QUERY_SERVICE_CONFIG
    .局部变量 hMem
    .局部变量 dwStartType
    .局部变量 lpBinaryPathName, 文本型

    hSCManager ＝ OpenSCManagerA (0, 0, #GENERIC_READ)
    .如果真 (hSCManager ≠ 0)
        hService ＝ OpenService (hSCManager, 服务名称, #SC_MANAGER_CONNECT)
        .如果真 (hService ≠ 0)
            QueryServiceConfig (hService, 0, 0, dwBytesNeeded)
            hMem ＝ GlobalAlloc (64, dwBytesNeeded)
            bresult ＝ QueryServiceConfig (hService, hMem, dwBytesNeeded, dwBytesNeeded)
            .如果真 (bresult)
                CopyMemory_QUERY_SERVICE_CONFIG (lpsc, hMem, 36)
                lpBinaryPathName ＝ 指针到文本 (lpsc.lpBinaryPathName)
            .如果真结束
            GlobalFree (hMem)
            CloseServiceHandle (hService)
        .如果真结束
        CloseServiceHandle (hSCManager)
    .如果真结束
    返回 (选择 (bresult, lpBinaryPathName, “”))

.子程序 置文件路径, 逻辑型, 公开, 修改一个已有的系统服务可执行文件的路径，有些服务有权限是否允许操作，成功返回真，失败返回假。
    .参数 服务名称, 文本型, , 提供服务名称非服务显示名称
    .参数 文件路径, 文本型
    .局部变量 hSCManager, 整数型
    .局部变量 hService, 整数型
    .局部变量 bresult, 逻辑型

    hSCManager ＝ OpenSCManagerA (0, 0, 983103)
    .如果真 (hSCManager ≠ 0)
        hService ＝ OpenService (hSCManager, 服务名称, 983551)
        .如果真 (hService ≠ 0)
            bresult ＝ ChangeServiceConfig (hService, 4294967295, 4294967295, 4294967295, 文件路径, 字符 (0), 0, 字符 (0), 字符 (0), 字符 (0), 字符 (0))
            CloseServiceHandle (hService)
        .如果真结束
        CloseServiceHandle (hSCManager)
    .如果真结束
    返回 (bresult)

.子程序 取登录类型, 文本型, 公开, 获取指定服务登录类型,如,本地系统,本地服务或网络服务.
    .参数 服务名称, 文本型
    .局部变量 hSCManager, 整数型
    .局部变量 hService, 整数型
    .局部变量 bresult, 逻辑型
    .局部变量 dwBytesNeeded
    .局部变量 lpsc, QUERY_SERVICE_CONFIG
    .局部变量 hMem
    .局部变量 StartName, 文本型
    .局部变量 Service, 文本型

    hSCManager ＝ OpenSCManagerA (0, 0, #GENERIC_READ)
    .如果真 (hSCManager ≠ 0)
        hService ＝ OpenService (hSCManager, 服务名称, 1)
        .如果真 (hService ≠ 0)
            QueryServiceConfig (hService, 0, 0, dwBytesNeeded)
            hMem ＝ GlobalAlloc (64, dwBytesNeeded)
            bresult ＝ QueryServiceConfig (hService, hMem, dwBytesNeeded, dwBytesNeeded)
            .如果真 (bresult)
                CopyMemory_QUERY_SERVICE_CONFIG (lpsc, hMem, 36)
                StartName ＝ 到大写 (指针到文本 (lpsc.lpServiceStartName))
                .判断开始 (寻找文本 (StartName, 到大写 (“localservice”), , 假) ≠ -1)
                    Service ＝ “本地服务”
                .判断 (寻找文本 (StartName, 到大写 (“Networkservice”), , 假) ≠ -1)
                    Service ＝ “网络服务”
                .判断 (寻找文本 (StartName, 到大写 (“localsystem”), , 假) ≠ -1)
                    Service ＝ “本地系统”
                .默认
                    
                .判断结束
                处理事件 ()
            .如果真结束
            GlobalFree (hMem)
            CloseServiceHandle (hService)
        .如果真结束
        CloseServiceHandle (hSCManager)
        
    .如果真结束
    返回 (Service)

.子程序 枚举服务, 整数型, 公开, 枚举本机安装的系统服务，成功返回系统服务数量，失败返回0.
    .参数 服务类型, , , 1、正在运行服务 2、未运行的服务  3、所有的服务
    .参数 服务列表, 精易_系统服务列表, 数组, 储存返回值。
    .局部变量 success, 逻辑型
    .局部变量 hSCManager, 整数型
    .局部变量 buffer, 整数型
    .局部变量 cbRequired, 整数型
    .局部变量 dwReturned, 整数型
    .局部变量 hEnumResume, 整数型
    .局部变量 hMem
    .局部变量 i, 整数型
    .局部变量 lpsc, ENUM_SERVICE_STATUS
    .局部变量 lpServices, 字节集
    .局部变量 lpServiceName, 字节集
    .局部变量 hService, 整数型
    .局部变量 dwBytesNeeded, 整数型
    .局部变量 Bytes
    .局部变量 Config, QUERY_SERVICE_CONFIG
    .局部变量 StartName, 文本型

    数组清零 (服务列表)
    hSCManager ＝ OpenSCManagerA (0, 0, 983103)
    .如果真 (hSCManager ≠ 0)
        success ＝ EnumServicesStatus (hSCManager, 48, 服务类型, 0, 0, cbRequired, dwReturned, hEnumResume)
        hMem ＝ HeapAlloc (GetProcessHeap (), 8, cbRequired) ' GlobalAlloc (64, cbRequired)
        success ＝ EnumServicesStatus (hSCManager, 48, 服务类型, hMem, cbRequired, cbRequired, dwReturned, hEnumResume)
        .如果真 (success ＝ 假)
            返回 (0)
        .如果真结束
        重定义数组 (服务列表, 假, dwReturned)
        .变量循环首 (0, dwReturned － 1, 1, i)
            lpServices ＝ 指针到字节集 (hMem ＋ 36 × i, 36)
            CopyMemory_ENUM_SERVICE_STATUS (lpsc, lpServices, 36)
            服务列表 [i ＋ 1].服务名称 ＝ 指针到文本 (lpsc.lpServiceName)
            服务列表 [i ＋ 1].显示名称 ＝ 指针到文本 (lpsc.lpDisplayName)
            ' ' -----------------
            hService ＝ OpenService (hSCManager, 服务列表 [i ＋ 1].服务名称, 983551)
            .如果真 (hService ≠ 0)
                QueryServiceConfig (hService, 0, 0, dwBytesNeeded)
                Bytes ＝ HeapAlloc (GetProcessHeap (), 8, dwBytesNeeded) ' GlobalAlloc (64, dwBytesNeeded)
                success ＝ QueryServiceConfig (hService, Bytes, dwBytesNeeded, dwBytesNeeded)
                .如果真 (success)
                    CopyMemory_QUERY_SERVICE_CONFIG (Config, Bytes, 36)
                    服务列表 [i ＋ 1].描述 ＝ 取服务描述 (服务列表 [i ＋ 1].服务名称)
                    服务列表 [i ＋ 1].服务状态 ＝ GetServiceState (lpsc.ServiceStatus.dwCurrentState)
                    服务列表 [i ＋ 1].文件路径 ＝ 文本_指针到文本A (Config.lpBinaryPathName)
                    .判断开始 (Config.dwStartType ＝ 2 且 lpsc.ServiceStatus.dwServiceType ＝ 32)
                        服务列表 [i ＋ 1].启动类型 ＝ “自动”
                    .判断 (Config.dwStartType ＝ 2 且 lpsc.ServiceStatus.dwServiceType ＝ 16)
                        服务列表 [i ＋ 1].启动类型 ＝ “自动(延迟启动)”
                    .判断 (Config.dwStartType ＝ 3)
                        服务列表 [i ＋ 1].启动类型 ＝ “手动”
                    .判断 (Config.dwStartType ＝ 4)
                        服务列表 [i ＋ 1].启动类型 ＝ “禁用”
                    .默认
                        
                    .判断结束
                    StartName ＝ 到大写 (文本_指针到文本A (Config.lpServiceStartName))
                    .判断开始 (寻找文本 (StartName, 到大写 (“LocalService”), , 假) ≠ -1)
                        服务列表 [i ＋ 1].登陆为 ＝ “本地服务”
                    .判断 (寻找文本 (StartName, 到大写 (“NetworkService”), , 假) ≠ -1)
                        服务列表 [i ＋ 1].登陆为 ＝ “网络服务”
                    .判断 (寻找文本 (StartName, 到大写 (“LocalSystem”), , 假) ≠ -1)
                        服务列表 [i ＋ 1].登陆为 ＝ “本地系统”
                    .默认
                        服务列表 [i ＋ 1].登陆为 ＝ StartName
                    .判断结束
                    
                .如果真结束
                HeapFree (GetProcessHeap (), 1, Bytes)
                CloseServiceHandle (hService)
            .如果真结束
            处理事件 ()
        .变量循环尾 ()
        ' GlobalFree (cbRequired)
        HeapFree (GetProcessHeap (), 1, hMem)
        CloseServiceHandle (hSCManager)
    .如果真结束
    返回 (dwReturned)

.子程序 取服务数, 整数型, 公开, 枚举本机安装的系统服务，成功返回系统服务数量，失败返回0.
    .参数 服务状态, , 可空, 1、正在运行服务 2、未运行的服务  3、所有的服务
    .局部变量 bresult, 逻辑型
    .局部变量 hSCManager, 整数型
    .局部变量 buffer, 整数型
    .局部变量 cbRequired, 整数型
    .局部变量 dwReturned, 整数型
    .局部变量 hEnumResume, 整数型
    .局部变量 hMem
    .局部变量 i, 整数型
    .局部变量 lpsc, ENUM_SERVICE_STATUS
    .局部变量 lpServices, 字节集
    .局部变量 lpServiceName, 字节集

    服务状态 ＝ 选择 (是否为空 (服务状态), 3, 服务状态)
    hSCManager ＝ OpenSCManagerA (0, 0, #GENERIC_READ)
    .如果真 (hSCManager ≠ 0)
        EnumServicesStatus (hSCManager, 48, 服务状态, 0, 0, cbRequired, dwReturned, hEnumResume)
        hMem ＝ GlobalAlloc (64, cbRequired)
        bresult ＝ EnumServicesStatus (hSCManager, 48, 服务状态, hMem, cbRequired, cbRequired, dwReturned, hEnumResume)
        GlobalFree (hMem)
        CloseServiceHandle (hSCManager)
    .如果真结束
    返回 (dwReturned)
    

.子程序 取指定服务信息, , 公开
    .参数 参_服务名称, 文本型
    .参数 参_服务状态, 整数型, , 1、正在运行服务 2、未运行的服务  3、所有的服务
    .参数 参_服务信息, 精易_系统服务列表Ex, 参考
    .局部变量 数组, 精易_系统服务列表Ex, , "0"
    .局部变量 枚举, 类_系统服务
    .局部变量 i, 整数型

    清除数组 (数组)
    枚举.枚举服务Ex (参_服务状态, 数组)
    .计次循环首 (取数组成员数 (数组), i)
        .如果真 (数组 [i].服务名称 ＝ 参_服务名称)
            参_服务信息 ＝ 数组 [i]
        .如果真结束
        系统_处理事件 ()
    .计次循环尾 ()
    

.子程序 枚举服务Ex, 整数型, 公开, 枚举本机安装的系统服务，成功返回系统服务数量，失败返回0.
    .参数 服务状态, , , 1、正在运行服务 2、未运行的服务  3、所有的服务
    .参数 服务列表, 精易_系统服务列表Ex, 数组, 储存返回值。
    .局部变量 hSCManager, 整数型
    .局部变量 bresult, 逻辑型
    .局部变量 cbBufSize, 整数型
    .局部变量 cbRequired, 整数型
    .局部变量 dwReturned, 整数型
    .局部变量 hEnumResume, 整数型
    .局部变量 lpServices
    .局部变量 i, 整数型
    .局部变量 ServiceProcess, ENUM_SERVICE_STATUS_PROCESS
    .局部变量 sbuffer, 字节集
    .局部变量 hService, 整数型
    .局部变量 Bytes
    .局部变量 Config, QUERY_SERVICE_CONFIG
    .局部变量 dwBytesNeeded, 整数型
    .局部变量 StartName, 文本型

    数组清零 (服务列表)
    hSCManager ＝ OpenSCManagerA (0, 0, #GENERIC_READ)
    .如果真 (hSCManager ≠ 0)
        EnumServicesStatusEx (hSCManager, 0, 48, 服务状态, 0, 0, cbRequired, dwReturned, hEnumResume, 字符 (0))
        lpServices ＝ GlobalAlloc (64, cbRequired)
        bresult ＝ EnumServicesStatusEx (hSCManager, 0, 48, 服务状态, lpServices, cbRequired, cbRequired, dwReturned, hEnumResume, 字符 (0))
        .如果真 (bresult)
            重定义数组 (服务列表, 假, dwReturned)
            .变量循环首 (0, dwReturned － 1, 1, i)
                sbuffer ＝ 指针到字节集 (lpServices ＋ 44 × i, 44)
                CopyMemory_enum_service_status_process (ServiceProcess, sbuffer, 44)
                服务列表 [i ＋ 1].服务名称 ＝ 指针到文本 (ServiceProcess.lpServiceName)
                服务列表 [i ＋ 1].显示名称 ＝ 指针到文本 (ServiceProcess.lpDisplayName)
                服务列表 [i ＋ 1].进程ID ＝ ServiceProcess.ServiceStatusProcess.dwProcessId
                ' ------------------
                hService ＝ OpenService (hSCManager, 指针到文本 (ServiceProcess.lpServiceName), 983551)
                bresult ＝ QueryServiceConfig (hService, 0, 0, dwBytesNeeded)
                Bytes ＝ GlobalAlloc (64, dwBytesNeeded)
                bresult ＝ QueryServiceConfig (hService, Bytes, dwBytesNeeded, dwBytesNeeded)
                .如果真 (bresult)
                    CopyMemory_QUERY_SERVICE_CONFIG (Config, Bytes, 36)
                    服务列表 [i ＋ 1].描述 ＝ 取服务描述 (指针到文本 (ServiceProcess.lpServiceName))
                    服务列表 [i ＋ 1].服务状态 ＝ GetServiceState (ServiceProcess.ServiceStatusProcess.dwCurrentState)
                    服务列表 [i ＋ 1].文件路径 ＝ 指针到文本 (Config.lpBinaryPathName)
                    .判断开始 (Config.dwStartType ＝ 2 且 ServiceProcess.ServiceStatusProcess.dwServiceType ＝ 32)
                        服务列表 [i ＋ 1].启动类型 ＝ “自动”
                    .判断 (Config.dwStartType ＝ 2 且 ServiceProcess.ServiceStatusProcess.dwServiceType ＝ 16)
                        服务列表 [i ＋ 1].启动类型 ＝ “自动(延迟启动)”
                    .判断 (Config.dwStartType ＝ 3)
                        服务列表 [i ＋ 1].启动类型 ＝ “手动”
                    .判断 (Config.dwStartType ＝ 4)
                        服务列表 [i ＋ 1].启动类型 ＝ “禁用”
                    .默认
                        
                    .判断结束
                    StartName ＝ 到大写 (指针到文本 (Config.lpServiceStartName))
                    .判断开始 (寻找文本 (StartName, 到大写 (“LocalService”), , 假) ≠ -1)
                        服务列表 [i ＋ 1].登陆为 ＝ “本地服务”
                    .判断 (寻找文本 (StartName, 到大写 (“NetworkService”), , 假) ≠ -1)
                        服务列表 [i ＋ 1].登陆为 ＝ “网络服务”
                    .判断 (寻找文本 (StartName, 到大写 (“LocalSystem”), , 假) ≠ -1)
                        服务列表 [i ＋ 1].登陆为 ＝ “本地系统”
                    .默认
                        服务列表 [i ＋ 1].登陆为 ＝ StartName
                    .判断结束
                    GlobalFree (Bytes)
                .如果真结束
                CloseServiceHandle (hService)
            .变量循环尾 ()
        .如果真结束
        GlobalFree (lpServices)
        CloseServiceHandle (hSCManager)
    .如果真结束
    返回 (dwReturned)

.子程序 枚举依赖服务, 整数型, , 有问题暂时不公开 
    .参数 服务名称, 文本型
    .参数 服务列表, 精易_系统服务列表, 数组, 变量储存返回值.
    .局部变量 hSCManager, 整数型
    .局部变量 schService, 整数型
    .局部变量 lpDependencies, 整数型
    .局部变量 dwBytesNeeded, 整数型
    .局部变量 dwCount, 整数型
    .局部变量 bresult, 逻辑型
    .局部变量 i, 整数型
    .局部变量 ess, ENUM_SERVICE_STATUS
    .局部变量 Bytes, 字节集
    .局部变量 hService, 整数型
    .局部变量 Config, QUERY_SERVICE_CONFIG
    .局部变量 StartName, 文本型
    .局部变量 hMem

    数组清零 (服务列表)
    hSCManager ＝ OpenSCManagerA (0, 0, #SC_MANAGER_ALL_ACCESS)
    .如果真 (hSCManager ≠ 0)
        schService ＝ OpenService (hSCManager, 服务名称, 4 ＋ 8 ＋ 32) ' #SERVICE_STOP ＋ #SERVICE_QUERY_STATUS ＋ #SERVICE_ENUMERATE_DEPENDENTS
        .如果真 (schService ≠ 0)
            EnumDependentServices (schService, 3, lpDependencies, 0, dwBytesNeeded, dwCount) ' #SERVICE_ACTIVE
            lpDependencies ＝ GlobalAlloc (64, dwBytesNeeded)
            bresult ＝ EnumDependentServices (schService, 3, lpDependencies, dwBytesNeeded, dwBytesNeeded, dwCount)
            .如果真 (bresult)
                重定义数组 (服务列表, 假, dwCount)
                .变量循环首 (0, dwCount － 1, 1, i)
                    Bytes ＝ 指针到字节集 (lpDependencies ＋ 36 × i, 36)
                    CopyMemory_ENUM_SERVICE_STATUS (ess, Bytes, 36)
                    服务列表 [i ＋ 1].服务名称 ＝ 指针到文本 (ess.lpServiceName)
                    服务列表 [i ＋ 1].显示名称 ＝ 指针到文本 (ess.lpDisplayName)
                    ' -------------------
                    hService ＝ OpenService (hSCManager, 指针到文本 (ess.lpServiceName), #GENERIC_READ)
                    bresult ＝ QueryServiceConfig (hService, 0, 0, dwBytesNeeded)
                    hMem ＝ GlobalAlloc (64, dwBytesNeeded)
                    bresult ＝ QueryServiceConfig (hService, hMem, dwBytesNeeded, dwBytesNeeded)
                    .如果真 (bresult)
                        CopyMemory_QUERY_SERVICE_CONFIG (Config, hMem, 36)
                        服务列表 [i ＋ 1].描述 ＝ 取服务描述 (指针到文本 (ess.lpServiceName))
                        服务列表 [i ＋ 1].服务状态 ＝ GetServiceState (ess.ServiceStatus.dwCurrentState)
                        服务列表 [i ＋ 1].文件路径 ＝ 指针到文本 (Config.lpBinaryPathName)
                        .判断开始 (Config.dwStartType ＝ 2 且 ess.ServiceStatus.dwServiceType ＝ 32)
                            服务列表 [i ＋ 1].启动类型 ＝ “自动”
                        .判断 (Config.dwStartType ＝ 2 且 ess.ServiceStatus.dwServiceType ＝ 16)
                            服务列表 [i ＋ 1].启动类型 ＝ “自动(延迟启动)”
                        .判断 (Config.dwStartType ＝ 3)
                            服务列表 [i ＋ 1].启动类型 ＝ “手动”
                        .判断 (Config.dwStartType ＝ 4)
                            服务列表 [i ＋ 1].启动类型 ＝ “禁用”
                        .默认
                            
                        .判断结束
                        StartName ＝ 到大写 (指针到文本 (Config.lpServiceStartName))
                        .判断开始 (寻找文本 (StartName, 到大写 (“LocalService”), , 假) ≠ -1)
                            服务列表 [i ＋ 1].登陆为 ＝ “本地服务”
                        .判断 (寻找文本 (StartName, 到大写 (“NetworkService”), , 假) ≠ -1)
                            服务列表 [i ＋ 1].登陆为 ＝ “网络服务”
                        .判断 (寻找文本 (StartName, 到大写 (“LocalSystem”), , 假) ≠ -1)
                            服务列表 [i ＋ 1].登陆为 ＝ “本地系统”
                        .默认
                            服务列表 [i ＋ 1].登陆为 ＝ StartName
                        .判断结束
                        处理事件 ()
                    .如果真结束
                    CloseServiceHandle (hService)
                    GlobalFree (hMem)
                .变量循环尾 ()
            .如果真结束
            CloseServiceHandle (schService)
        .如果真结束
        CloseServiceHandle (hSCManager)
    .如果真结束
    返回 (dwCount)

.子程序 停止所有依赖服务, , , 有问题暂时不公开
    .参数 服务名称, 文本型
    .局部变量 hSCManager, 整数型
    .局部变量 schService, 整数型
    .局部变量 lpDependencies, 整数型
    .局部变量 dwBytesNeeded, 整数型
    .局部变量 dwCount, 整数型
    .局部变量 bresult, 逻辑型
    .局部变量 i, 整数型
    .局部变量 ess, ENUM_SERVICE_STATUS
    .局部变量 Bytes, 字节集
    .局部变量 hDepService, 整数型
    .局部变量 ssp, SERVICE_STATUS
    .局部变量 dwStartTime, 整数型
    .局部变量 dwTimeout, 整数型

    dwStartTime ＝ 取启动时间 ()
    dwTimeout ＝ 30000
    hSCManager ＝ OpenSCManagerA (0, 0, #GENERIC_READ)
    .如果真 (hSCManager ≠ 0)
        schService ＝ OpenService (hSCManager, 服务名称, 32 ＋ 4 ＋ 8)
        .如果真 (schService ≠ 0)
            EnumDependentServices (schService, 1, lpDependencies, 0, dwBytesNeeded, dwCount)
            lpDependencies ＝ GlobalAlloc (64, dwBytesNeeded)
            bresult ＝ EnumDependentServices (schService, 1, lpDependencies, dwBytesNeeded, dwBytesNeeded, dwCount)
            .如果真 (bresult)
                .变量循环首 (0, dwCount － 1, 1, i)
                    Bytes ＝ 指针到字节集 (lpDependencies ＋ 36 × i, 36)
                    CopyMemory_ENUM_SERVICE_STATUS (ess, Bytes, 36)
                    hDepService ＝ OpenService (hSCManager, 指针到文本 (ess.lpServiceName), 位或 (32, 4)) ' SERVICE_STOP | SERVICE_QUERY_STATUS
                    .如果真 (ControlService (hDepService, 1, ssp))
                        .判断循环首 (ssp.dwCurrentState ≠ 1) ' SERVICE_STOPPED
                            延时 (ssp.dwWaitHint)
                            QueryServiceStatus (hDepService, ssp)
                            .判断开始 (ssp.dwCurrentState ＝ 1)
                                跳出循环 ()
                            .判断 (取启动时间 () － dwStartTime ＞ dwTimeout)
                                输出调试文本 (“停止服务失败，原因：超时！”)
                                跳出循环 ()
                            .默认
                                
                            .判断结束
                            处理事件 ()
                        .判断循环尾 ()
                    .如果真结束
                    CloseServiceHandle (hDepService)
                .变量循环尾 ()
                GlobalFree (lpDependencies)
            .如果真结束
            CloseServiceHandle (schService)
        .如果真结束
        CloseServiceHandle (hSCManager)
    .如果真结束
    

.子程序 GetServiceState, 文本型, , 系统服务_枚举系统服务
    .参数 dwState

    .判断开始 (dwState ＝ 1)
        返回 (“已停止”)
    .判断 (dwState ＝ 2)
        返回 (“启动期间”)
    .判断 (dwState ＝ 3)
        返回 (“停止期间”)
    .判断 (dwState ＝ 4)
        返回 (“正运行”)
    .判断 (dwState ＝ 5)
        返回 (“继续”)
    .判断 (dwState ＝ 6)
        返回 (“暂停期间”)
    .判断 (dwState ＝ 7)
        返回 (“已暂停”)
    .默认
        返回 (“”)
    .判断结束
    

.子程序 重启服务, 逻辑型, 公开, 重新启动系统服务，成功返回真，失败返回假
    .参数 参_服务名, 文本型

    .如果真 (停止服务 (参_服务名))
        返回 (开始服务 (参_服务名))
    .如果真结束
    返回 (假)

.版本 2

.程序集 类_系统音量, , 公开
.程序集变量 endpointVolume, 整数型

.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
    

.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
    .如果真 (endpointVolume ≠ 0)
        COM_Release (endpointVolume)
        endpointVolume ＝ 0
    .如果真结束
    CoUninitialize ()

.子程序 初始化, 整数型
    .局部变量 CLSID_MMDeviceEnumerator, GUID
    .局部变量 IID_IMMDeviceEnumerator, GUID
    .局部变量 hr, 整数型
    .局部变量 IMMDeviceEnumerator, 整数型
    .局部变量 defaultDevice, 整数型
    .局部变量 CLSID_IAudioEndpointVolume, 字节集

    .如果真 (endpointVolume ≠ 0)
        返回 (0)
    .如果真结束
    
    CoInitialize (#NULL)
    CLSID_MMDeviceEnumerator ＝ COM_StringToCLSID (“{BCDE0395-E52F-467C-8E3D-C4579291692E}”)
    IID_IMMDeviceEnumerator ＝ COM_StringToCLSID (“{A95664D2-9614-4F35-A746-DE8DB63617E6}”)
    
    hr ＝ CoCreateInstance (CLSID_MMDeviceEnumerator, #NULL, #CLSCTX_INPROC_SERVER, IID_IMMDeviceEnumerator, IMMDeviceEnumerator)
    .如果真 (hr ≠ #S_OK)
        输出调试文本 (“CoCreateInstance失败！”)
        返回 (hr)
    .如果真结束
    
    hr ＝ CallObject (IMMDeviceEnumerator, #IMMDeviceEnumerator_GetDefaultAudioEndpoint, 0, 0, 取指针_通用型 (defaultDevice), , , , , , )
    SafeRelease (IMMDeviceEnumerator)
    IMMDeviceEnumerator ＝ 0
    
    .如果真 (defaultDevice ＝ 0)
        输出调试文本 (“调用COM方法，IMMDeviceEnumerator失败！”)
        返回 (hr)
    .如果真结束
    
    CLSID_IAudioEndpointVolume ＝ 取空白字节集 (16)
    CLSIDFromString_字节集传址2 (编码_Ansi到Unicode (“{5CDF2C82-841E-4546-9722-0CF74078229A}”, ), CLSID_IAudioEndpointVolume)
    
    hr ＝ CallObject (defaultDevice, #IMMDevice_Activate, 取指针字节集_ (CLSID_IAudioEndpointVolume), #CLSCTX_INPROC_SERVER, #NULL, 取指针_通用型 (endpointVolume), , , , , )
    SafeRelease (defaultDevice)
    defaultDevice ＝ 0
    
    .如果真 (endpointVolume ＝ 0)
        输出调试文本 (“调用COM方法，defaultDevice失败！”)
        返回 (hr)
    .如果真结束
    
    返回 (0)

.子程序 获取音量, 整数型, 公开, 返回-1表示获取音量失败，返回0-100表示成功。
    .局部变量 返回音量值, 小数型
    .局部变量 真实音量值, 整数型

    .如果真 (初始化 () ≠ 0)
        返回 (-1)
    .如果真结束
    
    CallObject (endpointVolume, #IAudioEndpointVolume_GetMasterVolumeLevelScalar, 取指针地址_小数型 (返回音量值), , , , , , , , )
    真实音量值 ＝ 到整数 (四舍五入 (返回音量值 × 100, 0))
    返回 (真实音量值)

.子程序 设置音量, 整数型, 公开, 返回0表示成功，返回非零为错误代码。
    .参数 音量大小, 整数型, , 0-100
    .参数 声道, 整数型, 可空, 1为左声道，2为右声道
    .局部变量 真实音量值, 小数型
    .局部变量 hr, 整数型

    .如果真 (初始化 () ≠ 0)
        返回 (-1)
    .如果真结束
    
    .判断开始 (音量大小 ＜ 0)
        音量大小 ＝ 0
    .判断 (音量大小 ＞ 100)
        音量大小 ＝ 100
    .默认
        
    .判断结束
    
    真实音量值 ＝ 音量大小 ÷ 100
    .如果 (是否为空 (声道))
        hr ＝ CallObject (endpointVolume, #IAudioEndpointVolume_SetMasterVolumeLevelScalar, 指针_到整数 (取指针地址_小数型 (真实音量值)), #NULL, , , , , , , )
    .否则
        hr ＝ CallObject (endpointVolume, #IAudioEndpointVolume_SetChannelVolumeLevelScalar, 声道 － 1, 指针_到整数 (取指针地址_小数型 (真实音量值)), #NULL, , , , , , )
    .如果结束
    返回 (hr)

.子程序 静音, 整数型, 公开, 返回0表示成功，返回非零为错误代码。
    .参数 是否静音, 逻辑型, , 真为静音，假为关闭静音。
    .局部变量 hr, 整数型

    .如果真 (初始化 () ≠ 0)
        返回 (-1)
    .如果真结束
    
    hr ＝ CallObject (endpointVolume, #IAudioEndpointVolume_SetMute, 到整数 (是否静音), #NULL, , , , , , , )
    返回 (hr)

.子程序 是否静音, 逻辑型, 公开, 返回真为静音
    .局部变量 hr, 整数型
    .局部变量 bMute, 逻辑型

    .如果真 (初始化 () ≠ 0)
        返回 (假)
    .如果真结束
    
    hr ＝ CallObject (endpointVolume, #IAudioEndpointVolume_GetMute, 取指针_通用型 (bMute), , , , , , , , )
    返回 (bMute)

.版本 2

.程序集 类_邮槽客户端, , 公开
.程序集变量 hFile, , , , 本类源码来自于SoftApiModule模块

.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
    

.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
    CloseHandle (hFile)

.子程序 创建, 逻辑型, 公开, 邮槽客户机只能向邮槽中写入数据，不能从中读出数据。创建成功返回真，否则返回假。
    .参数 服务器名称, 文本型, , 欲连接的邮槽服务器名称，也可以是局域网的域名，这时表示客户机要连接这个局域网域内的所有计算机上名称为参数2的邮槽。该参数也可以是“.”，表示连接本机上的名称为参数2的邮槽。该参数也可以是“*”，表示连接系统主域内的所有计算机上的名称为参数2的邮槽。
    .参数 邮槽名称, 文本型, , 欲连接服务器上邮槽的名称。
    .局部变量 SlotName, 文本型

    .判断开始 (服务器名称 ＝ “.”)
        SlotName ＝ “\\.\mailslot\” ＋ 邮槽名称
    .判断 (服务器名称 ＝ “*”)
        SlotName ＝ “\\*\mailslot\” ＋ 邮槽名称
    .默认
        SlotName ＝ “\\” ＋ 服务器名称 ＋ “\mailslot\” ＋ 邮槽名称
    .判断结束
    hFile ＝ CreateFileA (SlotName, 1073741824, 1, 0, 3, 128, 0)
    返回 (hFile ≠ -1)

.子程序 关闭, 逻辑型, 公开, 关闭已经创建的邮槽客户机。
    返回 (CloseHandle (hFile))

.子程序 写数据, 逻辑型, 公开, 只能在客户机端向邮槽中写入数据。注意写入的数据长度有限制，最大的长度为424字节，如果通讯数据的长度太大，最好选用“命名管道”。写入成功返回真，否则返回假。
    .参数 数据, 字节集, , 欲向邮槽中写入的数据，数据长度必须小于424字节，否则出错。
    .局部变量 cbWritten, 整数型

    返回 (WriteFile (hFile, 数据, 取字节集长度 (数据), cbWritten, 0))

.版本 2

.程序集 类_邮槽服务端, , 公开, http://msdn.microsoft.com/en-us/library/windows/desktop/aa365147(v=vs.85).aspx
.程序集变量 hSlot, , , , 本类源码来自于SoftApiModule模块

.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
    

.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
    CloseHandle (hSlot)

.子程序 创建, 逻辑型, 公开, 创建成功返回真，否则返回假。
    .参数 邮槽名称, 文本型

    hSlot ＝ CreateMailslot (“\\.\mailslot\” ＋ 邮槽名称, 0, -1, 0) ' MAILSLOT_WAIT_FOREVER
    返回 (hSlot ≠ 0)

.子程序 关闭, 逻辑型, 公开, 关闭邮槽服务器。
    返回 (CloseHandle (hSlot))

.子程序 读数据, 逻辑型, 公开, 只能在服务器端从邮槽中取出数据。读取成功返回真，否则返回假。
    .参数 数据, 字节集, 参考, 提供参数数据时只能提供变量。从向邮槽中读出的数据。
    .局部变量 Status
    .局部变量 cbMessage, 整数型
    .局部变量 cMessage, 整数型
    .局部变量 lpszBuffer
    .局部变量 cbRead, 整数型
    .局部变量 bool, 逻辑型

    .如果真 (GetMailslotInfo (hSlot, 0, cbMessage, cMessage, 0))
        .如果真 (cbMessage ≠ -1)
            lpszBuffer ＝ HeapAlloc (GetProcessHeap (), 8, 1000)
            bool ＝ ReadFile_整数型 (hSlot, lpszBuffer, cbMessage, cbRead, 0)
            数据 ＝ 指针到字节集 (lpszBuffer, cbRead)
            HeapFree (GetProcessHeap (), 8, lpszBuffer)
        .如果真结束
        返回 (bool)
    .如果真结束
    返回 (假)
    

.版本 2

.程序集 输入法类, , 公开, 感谢坛友【xuweixxf21】提供
.程序集变量 缓存_输入法标识, 文本型, , "0"
.程序集变量 缓存_输入法名称, 文本型, , "0"
.程序集变量 缓存_输入法路径, 文本型, , "0"
.程序集变量 缓存_输入法句柄, 整数型, , "0"
.程序集变量 SystemPath, 文本型

.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
    清除缓存数据 ()
    SystemPath ＝ 读环境变量 (“systemroot”) ＋ “\System32\”

.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
    

.子程序 安装, 整数型, 公开, 安装指定输入法(成功返回输入法句柄,失败返回0)
    .参数 输入法文件, 文本型, , 输入法文件的完整路径  没有注入文件的可以来这里下载：http://115.com/file/dizk13dt
    .参数 输入法名称, 文本型, 可空, 输入法的名称,默认为“精易输入法”

    .如果真 (是否为空 (输入法名称))
        输入法名称 ＝ “精易输入法”
    .如果真结束
    文件_复制 (输入法文件, SystemPath ＋ “imedllhost09.ime”)
    返回 (ImmInstallIMEA (SystemPath ＋ “imedllhost09.ime”, 输入法名称))

.子程序 清除缓存数据
    清除数组 (缓存_输入法标识)
    清除数组 (缓存_输入法名称)
    清除数组 (缓存_输入法路径)

.子程序 卸载, 逻辑型, 公开, 卸载已经安装的输入法(成功返回真,失败返回假)
    .参数 输入法句柄, 整数型, , 欲卸载的输入法的句柄
    .局部变量 注册表路径, 文本型, , "3"
    .局部变量 输入法序号, 整数型

    输入法序号 ＝ 取序号 (输入法句柄)
    .如果真 (输入法序号 ＝ -1)
        返回 (假)
    .如果真结束
    注册表路径 [1] ＝ “Keyboard Layout\Preload\”
    注册表路径 [2] ＝ “SYSTEM\CurrentControlSet\Control\Keyboard Layouts\”
    注册表路径 [3] ＝ “S-1-5-21-1060284298-606747145-682003330-500\Keyboard Layout\Preload”
    删除注册项 (#现行用户, 注册表路径 [1] ＋ 到文本 (输入法序号))
    删除注册项 (#本地机器, 注册表路径 [2] ＋ 缓存_输入法标识 [输入法序号])
    删除注册项 (#所有用户, 注册表路径 [3] ＋ 到文本 (输入法序号))
    UnloadKeyboardLayout (输入法句柄)
    删除文件 (SystemPath ＋ 缓存_输入法路径 [输入法序号])
    文件_删除 (SystemPath ＋ “imedllhost09.ime”)
    清除缓存数据 ()
    返回 (真)

.子程序 取序号, 整数型, 公开, 取输入法序号
    .参数 输入法句柄, 整数型
    .局部变量 临时整数, 整数型
    .局部变量 是否取得, 逻辑型
    .局部变量 输入法总数, 整数型
    .局部变量 局部_输入法, 整数型, , "0"

    输入法总数 ＝ 取输入法个数2 ()
    取全部输入法句柄 (局部_输入法)
    .变量循环首 (1, 输入法总数, 1, 临时整数)
        .如果 (输入法句柄 ＝ 局部_输入法 [临时整数])
            是否取得 ＝ 真
            跳出循环 ()
        .否则
            
        .如果结束
        
    .变量循环尾 ()
    .如果 (是否取得 ＝ 假)
        临时整数 ＝ -1
    .否则
        
    .如果结束
    返回 (临时整数)

.子程序 取输入法个数2, 整数型, , 取全部输入法，成功则返回结果数量，失败返回0。
    .局部变量 注册表路径, 文本型, , "2"
    .局部变量 输入法总数, 整数型
    .局部变量 临时整数, 整数型
    .局部变量 标识, 文本型
    .局部变量 名称, 文本型
    .局部变量 路径, 文本型

    注册表路径 [1] ＝ “Keyboard Layout\Preload\”
    注册表路径 [2] ＝ “SYSTEM\CurrentControlSet\Control\Keyboard Layouts\”
    清除缓存数据 ()
    输入法总数 ＝ 取输入法个数 () ' GetKeyboardLayoutList (0, 0)
    .变量循环首 (1, 输入法总数, 1, 临时整数)
        标识 ＝ 取文本注册项 (#现行用户, 注册表路径 [1] ＋ 到文本 (临时整数), )
        名称 ＝ 取文本注册项 (#本地机器, 注册表路径 [2] ＋ 标识 ＋ “\Layout Text”, )
        路径 ＝ 取文本注册项 (#本地机器, 注册表路径 [2] ＋ 标识 ＋ “\Ime File”, )
        加入成员 (缓存_输入法标识, 标识)
        加入成员 (缓存_输入法名称, 名称)
        加入成员 (缓存_输入法路径, 路径)
    .变量循环尾 ()
    返回 (输入法总数)

.子程序 取全部输入法句柄, 整数型, 公开, 取全部输入法句柄，返回取得的数量。
    .参数 输入法句柄, 整数型, 数组
    .局部变量 输入法总数, 整数型
    .局部变量 临时整数, 整数型
    .局部变量 句柄, 整数型

    输入法总数 ＝ 取输入法个数2 ()
    .变量循环首 (1, 输入法总数, 1, 临时整数)
        句柄 ＝ LoadKeyboardLayoutA (缓存_输入法标识 [临时整数], 0)
        加入成员 (输入法句柄, 句柄)
    .变量循环尾 ()
    返回 (输入法总数)

.子程序 注入, 整数型, 公开, 通过输入法注入文件(成功返回输入法句柄,失败返回0)
    .参数 欲注入的文件, 文本型, , 欲注入文件的完整路径
    .参数 输入法注入文件, 文本型, , 没有注入文件的可以来这里下载：http://pan.baidu.com/s/1eRDCRVO
    .参数 输入法名称, 文本型, 可空, 输入法的名称,默认为“精易输入法”
    .局部变量 句柄, 整数型
    .局部变量 Address, 整数型

    .如果真 (是否为空 (输入法名称))
        输入法名称 ＝ “精易输入法”
    .如果真结束
    句柄 ＝ 安装 (输入法注入文件, 输入法名称)
    程序_延时 (25)
    IMESetPubString (欲注入的文件, 0, 0, 0, 0, 0)
    返回 (句柄)

.子程序 停止注入, 逻辑型, 公开, 停止注入(成功返回真,失败返回假)
    返回 (IMEClearPubString ())

.子程序 激活, , 公开, 激活指定输入法(无返回值)
    .参数 窗口句柄, 整数型, , 在指定的窗口激活输入法
    .参数 输入法句柄, 整数型, , 欲激活的输入法的句柄

    ' ActivateKeyboardLayout (输入法句柄, 0)
    SendMessageA (窗口句柄, 80, 1, 输入法句柄)
    返回 ()

.子程序 取名称, 文本型, 公开, 成功返回输入法名称
    .参数 序号, 整数型
    .局部变量 i, 整数型

    取输入法个数2 ()
    返回 (缓存_输入法名称 [序号])

.子程序 取句柄, 整数型, 公开, 成功返回句柄
    .参数 序号, 整数型
    .局部变量 句柄数组, 整数型, , "0"
    .局部变量 数量, 整数型
    .局部变量 n, 整数型

    取输入法个数2 ()
    取全部输入法句柄 (句柄数组)
    返回 (句柄数组 [序号])

.子程序 取输入法个数, 整数型, 公开
    .局部变量 输入法总数, 整数型
    .局部变量 pList, , , "20"

    输入法总数 ＝ GetKeyboardLayoutList (20, pList)
    返回 (输入法总数)

.子程序 显示属性, 逻辑型, 公开, 显示输入法属性窗口,成功返回真，失败返回假
    .参数 输入法句柄

    返回 (ImmConfigureIME (输入法句柄, GetActiveWindow (), 1, 0)) ' #IME_CONFIG_GENERAL
    

.版本 2

.程序集 集_DLL
.子程序 投递消息整数, , 公开
    .参数 窗口句柄, 整数型
    .参数 消息号, 整数型
    .参数 消息参数1, 整数型
    .参数 消息参数2, 整数型

    PostMessageA (窗口句柄, 消息号, 消息参数1, 消息参数2)

.子程序 发送消息整数, 整数型, 公开, 发送特定的消息到一个或多个窗口。该命令不会立即返回，只有在消息被处理完毕后才返回结果。返回值的具体含义随消息的不同而不同
    .参数 窗口句柄, 整数型, , 本参数指定接收消息的窗口的句柄
    .参数 消息号, 整数型, , 本参数指定欲发送的消息
    .参数 消息参数1, 整数型, , 本参数指定消息的第一个参数。具体含义随消息的不同而不同
    .参数 消息参数2, 整数型, , 本参数指定消息的第二个参数。具体含义随消息的不同而不同

    返回 (SendMessageA (窗口句柄, 消息号, 消息参数1, 消息参数2))

.子程序 发送消息文本, 整数型, 公开, 发送特定的消息到一个或多个窗口。该命令不会立即返回，只有在消息被处理完毕后才返回结果。返回值的具体含义随消息的不同而不同
    .参数 窗口句柄, 整数型, , 本参数指定接收消息的窗口的句柄
    .参数 消息号, 整数型, , 本参数指定欲发送的消息
    .参数 消息参数1, 整数型, , 本参数指定消息的第一个参数。具体含义随消息的不同而不同
    .参数 消息参数2, 文本型, , 本参数指定消息的第二个参数。具体含义随消息的不同而不同

    返回 (SendMessageA (窗口句柄, 消息号, 消息参数1, 取指针文本_ (消息参数2)))

.子程序 发送消息逻辑, 整数型, 公开, 发送特定的消息到一个或多个窗口。该命令不会立即返回，只有在消息被处理完毕后才返回结果。返回值的具体含义随消息的不同而不同
    .参数 窗口句柄, 整数型, , 本参数指定接收消息的窗口的句柄
    .参数 消息号, 整数型, , 本参数指定欲发送的消息
    .参数 消息参数1, 逻辑型, , 本参数指定消息的第一个参数。具体含义随消息的不同而不同
    .参数 消息参数2, 整数型, , 本参数指定消息的第二个参数。具体含义随消息的不同而不同

    返回 (SendMessageA (窗口句柄, 消息号, 到整数 (消息参数1), 消息参数2))

.子程序 API_取空白文本, 文本型, 公开, 返回具有指定数目半角空格的文本。
    .参数 重复次数, 整数型
    .局部变量 文本指针, 整数型

    ' 注：以下的代码仿效了易核心库命令“取空白文本”，只是填充空白字符0x20部分使用了API函数来实现。
    .如果真 (重复次数 ≤ 0)
        ' 这里嵌入汇编代码取代  返回 (“”)
        置入代码 ({ 51, 192, 139, 229, 93, 194, 4, 0 })
        ' XOR EAX,EAX
        ' MOV ESP,EBP
        ' POP EBP
        ' RETN 04
    .如果真结束
    
    ' 分配可用内存空间，+1是为了填充文本终止符“0”。
    文本指针 ＝ HeapAlloc (GetProcessHeap (), 0, 重复次数 ＋ 1)
    
    .如果真 (文本指针 ＝ 0)
        ' 这里嵌入汇编代码取代  返回 (“”)
        置入代码 ({ 139, 229, 93, 194, 4, 0 })
        ' MOV ESP,EBP
        ' POP EBP
        ' RETN 04
    .如果真结束
    ' 以空白字符0x20填充分配的内存块字节数据，这里使用了API函数，当然也可以用嵌入汇编来实现。
    RtlFillMemory_字节 (文本指针, 重复次数, 32)
    ' 嵌入汇编代码以替换掉原来的返回代码，并添加文本终止符标志“0”。
    ' 如用“指针到文本”命令会使效率大大减低，不推荐使用。
    置入代码 ({ 139, 69, 8, 3, 69, 252, 198, 0, 0, 139, 69, 252, 139, 229, 93, 194, 4, 0 })
    ' 至于释放内存就交给易IDE了，使用HeapAlloc申请内存的目的就在这里，因为易IDE也是使用HeapAlloc
    ' 申请内存的，最终易IDE会帮我们使用HeapFree释放内存。哈哈！是不是有点欺骗易IDE的味道。
    返回 (“”)

.子程序 API_取空白字节集, 字节集, 公开, 返回具有特定数目 0 字节的字节集
    .参数 零字节数目, 整数型
    .局部变量 字节集指针, 整数型

    .如果真 (零字节数目 ≤ 0)
        ' 这里嵌入汇编代码取代  返回 ({ })
        置入代码 ({ 51, 192, 139, 229, 93, 194, 4, 0 })
        ' XOR EAX,EAX
        ' MOV ESP,EBP
        ' POP EBP
        ' RETN 04
    .如果真结束
    ' 分配可用内存空间，+8是为了填充字节集类型标志
    字节集指针 ＝ HeapAlloc (GetProcessHeap (), 8, 零字节数目 ＋ 8) ' #HEAP_ZERO_MEMORY=8
    .如果真 (字节集指针 ＝ 0)
        ' 这里嵌入汇编代码取代  返回 ({ })
        置入代码 ({ 139, 229, 93, 194, 4, 0 })
        ' MOV ESP,EBP
        ' POP EBP
        ' RETN 04
    .如果真结束
    
    ' 嵌入汇编代码以替换掉原来的返回代码，并添加字节集类型标志。
    置入代码 ({ 254, 0, 255, 117, 8, 143, 64, 4, 139, 229, 93, 194, 4, 0 })
    返回 ({ })

.版本 2

.程序集 集_rar解压缩
.程序集变量 集_rar所在路径, 文本型

.子程序 rar_初始化, 逻辑型, 公开, 使用解压缩前先调用一次该命令初始化获取rar.exe所在路径，成功初始化返回真，失败返回假。
    .参数 rar所在路径, 文本型, 可空, 请传入完整路径，如果传入为空，则检测当前目录是否存在rar.exe文件，若不存在，则返回假。该文件可以在此地址下载：http://ec.125.la/source/plugin/plugin1/upload/rar.exe
    .参数 rar主程序文件名, 文本型, 可空, 默认文件名为“rar.exe”，如果你想自定义文件名可以传入内容，比如传入“myrar.exe”，同时修改主程序的文件名，否则留空即可。
    .局部变量 局_WinRAR目录, 文本型

    rar主程序文件名 ＝ 删首尾空 (rar主程序文件名)
    .如果真 (是否为空 (rar主程序文件名) 或 rar主程序文件名 ＝ “”)
        rar主程序文件名 ＝ “rar.exe”
    .如果真结束
    
    rar所在路径 ＝ 删首尾空 (rar所在路径)
    .如果 (是否为空 (rar所在路径) 或 rar所在路径 ＝ “”) ' 优先判断运行目录
        .如果 (文件是否存在 (取运行目录 () ＋ “\” ＋ rar主程序文件名))
            集_rar所在路径 ＝ 取运行目录 () ＋ “\” ＋ rar主程序文件名
            返回 (真)
        .否则
            局_WinRAR目录 ＝ 程序_取安装目录 (“WinRAR.exe”) ' 其次判断注册表
            .如果真 (局_WinRAR目录 ≠ “” 且 文件是否存在 (局_WinRAR目录 ＋ rar主程序文件名))
                集_rar所在路径 ＝ 局_WinRAR目录 ＋ rar主程序文件名
                返回 (真)
            .如果真结束
            
        .如果结束
        
    .否则
        集_rar所在路径 ＝ rar所在路径
        .如果真 (文件是否存在 (集_rar所在路径))
            返回 (真)
        .如果真结束
        
    .如果结束
    
    ' 如果文件不存在，返回假
    集_rar所在路径 ＝ “”
    返回 (假)

.子程序 rar_压缩, 文本型, 公开, 压缩文件或文件夹，若成功返回空文本，失败则返回错误提示。
    .参数 被压缩的文件, 文本型, , 文件或文件夹都可以
    .参数 压缩到的路径, 文本型, , 全路径和rar/zip文件名，填入完整的路径，该路径所在文件夹必须存在，否则会失败
    .参数 压缩密码, 文本型, 可空, 设置压缩密码
    .参数 注释地址, 文本型, 可空, 注释文本文件的完整路径，以txt结尾
    .参数 是否等待, 逻辑型, 可空, 默认为假，不等待，为真则为等待压缩完毕
    .参数 是否显示压缩过程, 逻辑型, 可空, 默认为假，不显示
    .参数 压缩程度, 整数型, 可空, 范围为1-5,1的压缩程度最小，5压缩程度最大，但时间最久。默认为3，如果传值不正确也为3
    .局部变量 压缩过程, 整数型
    .局部变量 程度数组, 整数型, , "5"
    .局部变量 循环次数, 整数型

    .如果真 (集_rar所在路径 ＝ “”)
        返回 (“rar路径不存在，请确认是否初始化成功”)
    .如果真结束
    
    .如果真 (是否为空 (压缩程度))
        压缩程度 ＝ 3
    .如果真结束
    
    .如果真 (压缩程度 ＜ 1 或 压缩程度 ＞ 5)
        压缩程度 ＝ 3
    .如果真结束
    
    .如果真 (是否为空 (是否显示压缩过程))
        是否显示压缩过程 ＝ 假
    .如果真结束
    
    .判断开始 (是否显示压缩过程 ＝ 真)
        压缩过程 ＝ #显示rar窗口
    .默认
        压缩过程 ＝ #隐藏rar窗口
    .判断结束
    
    .判断开始 (压缩密码 ＝ “”)
        .判断开始 (注释地址 ＝ “”)
            ' 无密码无注释的情况
            运行 (#引号 ＋ 集_rar所在路径 ＋ #引号 ＋ “ a -m” ＋ 到文本 (压缩程度) ＋ “ -ep1 -scul -r0 -iext -o+ ” ＋ #引号 ＋ 压缩到的路径 ＋ #引号 ＋ “ ” ＋ #引号 ＋ 被压缩的文件 ＋ #引号, 是否等待, 压缩过程)
        .默认
            ' 无密码有注释的情况
            运行 (#引号 ＋ 集_rar所在路径 ＋ #引号 ＋ “ a -m” ＋ 到文本 (压缩程度) ＋ “ -ep1 -scul -r0 -iext -o+ -z” ＋ #引号 ＋ 注释地址 ＋ #引号 ＋ “ ” ＋ #引号 ＋ 压缩到的路径 ＋ #引号 ＋ “ ” ＋ #引号 ＋ 被压缩的文件 ＋ #引号, 是否等待, 压缩过程)
        .判断结束
        
        
    .判断 (注释地址 ＝ “”)
        ' 有密码无注释的情况
        运行 (#引号 ＋ 集_rar所在路径 ＋ #引号 ＋ “ a -m” ＋ 到文本 (压缩程度) ＋ “ -ep1 -scul -r0 -iext -o+ ” ＋ #引号 ＋ 压缩到的路径 ＋ #引号 ＋ “ ” ＋ #引号 ＋ 被压缩的文件 ＋ #引号 ＋ “ -p” ＋ 压缩密码, 是否等待, 压缩过程)
    .默认
        
        ' 有密码有注释的情况
        运行 (#引号 ＋ 集_rar所在路径 ＋ #引号 ＋ “ a -m” ＋ 到文本 (压缩程度) ＋ “ -ep1 -scul -r0 -iext -o+ -z” ＋ #引号 ＋ 注释地址 ＋ #引号 ＋ “ ” ＋ #引号 ＋ 压缩到的路径 ＋ #引号 ＋ “ ” ＋ #引号 ＋ 被压缩的文件 ＋ #引号 ＋ “ -p” ＋ 压缩密码, 是否等待, 压缩过程)
        
    .判断结束
    返回 (“”)
    
    

.子程序 rar_解压, 文本型, 公开, 解压压缩包，成功返回空文本，失败返回错误提示。
    .参数 压缩文件完整路径, 文本型, , 全路径带上rar/zip文件名
    .参数 解压到的文件夹, 文本型, , 文件夹全路径
    .参数 解压密码, 文本型, 可空, 压缩时设定的解压密码
    .参数 是否覆盖已存在的文件, 逻辑型, 可空, 默认为假
    .参数 是否等待, 逻辑型, 可空, 是否等待解压完毕，默认为假，为真则解压完成后才运行后面的代码
    .参数 是否显示解压过程, 逻辑型, 可空, 默认为假，不显示
    .局部变量 解压过程, 整数型

    .如果真 (集_rar所在路径 ＝ “”)
        返回 (“rar路径不存在，请确认是否初始化成功”)
    .如果真结束
    
    .如果真 (是否为空 (是否覆盖已存在的文件))
        是否覆盖已存在的文件 ＝ 假
    .如果真结束
    .如果真 (是否为空 (是否显示解压过程))
        是否显示解压过程 ＝ 假
    .如果真结束
    
    .判断开始 (是否显示解压过程 ＝ 真)
        解压过程 ＝ #显示rar窗口
    .默认
        解压过程 ＝ #隐藏rar窗口
    .判断结束
    
    
    .判断开始 (解压密码 ＝ “”)
        .判断开始 (是否覆盖已存在的文件 ＝ 假)
            ' 密码为空不覆盖原有文件
            运行 (#引号 ＋ 集_rar所在路径 ＋ #引号 ＋ “ x -iext -ow -o- ” ＋ #引号 ＋ 压缩文件完整路径 ＋ #引号 ＋ “ ” ＋ #引号 ＋ 解压到的文件夹 ＋ #引号, 是否等待, 解压过程)
        .默认
            ' 密码为空覆盖原有文件
            运行 (#引号 ＋ 集_rar所在路径 ＋ #引号 ＋ “ x -iext -ow -o+ ” ＋ #引号 ＋ 压缩文件完整路径 ＋ #引号 ＋ “ ” ＋ #引号 ＋ 解压到的文件夹 ＋ #引号, 是否等待, 解压过程)
        .判断结束
        
    .判断 (是否覆盖已存在的文件 ＝ 假)
        ' 有密码不覆盖原有文件
        运行 (#引号 ＋ 集_rar所在路径 ＋ #引号 ＋ “ x -iext -ow -o- ” ＋ #引号 ＋ 压缩文件完整路径 ＋ #引号 ＋ “ ” ＋ #引号 ＋ 解压到的文件夹 ＋ #引号 ＋ “ -p” ＋ 解压密码, 是否等待, 解压过程)
    .默认
        ' 有密码覆盖原有文件
        运行 (#引号 ＋ 集_rar所在路径 ＋ #引号 ＋ “ x -iext -ow -o+ ” ＋ #引号 ＋ 压缩文件完整路径 ＋ #引号 ＋ “ ” ＋ #引号 ＋ 解压到的文件夹 ＋ #引号 ＋ “ -p” ＋ 解压密码, 是否等待, 解压过程)
    .判断结束
    
    返回 (“”)

.子程序 rar_添加文件注释, 文本型, 公开, 给已经压缩好的压缩文件添加注释 成功返回空文本，失败返回错误提示。
    .参数 压缩文件完整路径, 文本型, , 压缩文件全路径，rar/zip
    .参数 注释文件地址, 文本型, , 以txt结尾的完整路径
    .参数 是否等待, 逻辑型, 可空, 默认为假，不等待
    .参数 是否显示过程, 逻辑型, 可空, 默认为假，不显示
    .局部变量 过程, 整数型

    .如果真 (集_rar所在路径 ＝ “”)
        返回 (“rar路径不存在，请确认是否初始化成功”)
    .如果真结束
    
    .如果真 (是否为空 (是否显示过程))
        是否显示过程 ＝ 假
    .如果真结束
    
    .判断开始 (是否显示过程 ＝ 真)
        过程 ＝ #显示rar窗口
    .默认
        过程 ＝ #隐藏rar窗口
    .判断结束
    
    运行 (#引号 ＋ 集_rar所在路径 ＋ #引号 ＋ “ c ” ＋ #引号 ＋ 压缩文件完整路径 ＋ #引号 ＋ “ -z” ＋ #引号 ＋ 注释文件地址 ＋ #引号, 是否等待, 过程)
    返回 (“”)

.子程序 rar_删除压缩包内的文件, 文本型, 公开, 删除压缩包里面的文件，成功返回空文本，失败返回错误提示。
    .参数 压缩文件, 文本型, , 压缩文件全路径 rar/zip
    .参数 要删除的文件名, 文本型, , 文件名不能带路径，但是要带后缀，如果是最后一个文件，那么整个压缩包会被删除
    .参数 是否等待, 逻辑型, 可空, 默认为假，不等待
    .参数 是否显示过程, 逻辑型, 可空, 默认为假，不显示
    .局部变量 过程, 整数型

    .如果真 (集_rar所在路径 ＝ “”)
        返回 (“rar路径不存在，请确认是否初始化成功”)
    .如果真结束
    
    .如果真 (是否为空 (是否显示过程))
        是否显示过程 ＝ 假
    .如果真结束
    
    .判断开始 (是否显示过程 ＝ 真)
        过程 ＝ #显示rar窗口
    .默认
        过程 ＝ #隐藏rar窗口
    .判断结束
    
    运行 (#引号 ＋ 集_rar所在路径 ＋ #引号 ＋ “ d ” ＋ #引号 ＋ 压缩文件 ＋ #引号 ＋ “ ” ＋ #引号 ＋ 要删除的文件名 ＋ #引号, 是否等待, 过程)
    返回 (“”)

.子程序 rar_测试文件, 逻辑型, 公开, 测试压缩包密码是否正确
    .参数 压缩文件, 文本型
    .参数 密码, 文本型, 可空
    .局部变量 局_目录, 文本型
    .局部变量 局_密码, 文本型
    .局部变量 局_结果, 文本型

    局_目录 ＝ 文件_取目录 (集_rar所在路径)
    .如果真 (密码 ≠ “”)
        局_密码 ＝ “ -p” ＋ 密码
    .如果真结束
    局_结果 ＝ 系统_取DOS执行结果 (“cd ” ＋ #引号 ＋ 局_目录 ＋ #引号 ＋ “&” ＋ #引号 ＋ 集_rar所在路径 ＋ #引号 ＋ “ t ” ＋ #引号 ＋ 压缩文件 ＋ #引号 ＋ 局_密码)
    返回 (倒找文本 (局_结果, “全部成功”, , 真) ＞ -1)

.子程序 rar_取压缩包内的文件数量, 整数型, 公开
    .参数 压缩文件, 文本型
    .参数 密码, 文本型, 可空
    .局部变量 局_目录, 文本型
    .局部变量 局_密码, 文本型
    .局部变量 局_结果, 文本型

    局_目录 ＝ 文件_取目录 (集_rar所在路径)
    .如果真 (密码 ≠ “”)
        局_密码 ＝ “ -p” ＋ 密码
    .如果真结束
    局_结果 ＝ 系统_取DOS执行结果 (“cd ” ＋ #引号 ＋ 局_目录 ＋ #引号 ＋ “&” ＋ #引号 ＋ 集_rar所在路径 ＋ #引号 ＋ “ v ” ＋ #引号 ＋ 压缩文件 ＋ #引号 ＋ 局_密码)
    局_结果 ＝ 文本_取右边 (局_结果, “-” ＋ #换行符, , )
    返回 (到整数 (局_结果))

.版本 2

.程序集 集_剪辑板
.子程序 剪辑板_置文本, , 公开, 设置指定文本到系统剪辑板
    .参数 要置的文本, 文本型
    .局部变量 dwLength, 整数型
    .局部变量 hGlobalMemory, 整数型
    .局部变量 GHND, 整数型
    .局部变量 lpGlobalMemory, 整数型
    .局部变量 hWnd, 整数型
    .局部变量 i, 整数型

    dwLength ＝ 取文本长度 (要置的文本)
    GHND ＝ 2
    hGlobalMemory ＝ GlobalAlloc (GHND, dwLength ＋ 1)
    lpGlobalMemory ＝ GlobalLock (hGlobalMemory)
    RtlMoveMemory_文本型 (lpGlobalMemory, 要置的文本, dwLength)
    GlobalUnlock (hGlobalMemory)
    hWnd ＝ 窗口_取顶端窗口句柄 ()
    OpenClipboard (hWnd)
    EmptyClipboard ()
    SetClipboardData (1, hGlobalMemory) ' #CF_TEXT=1
    CloseClipboard ()

.子程序 剪辑板_置字节集, , 公开, 设置指定宽字符到系统剪辑板
    .参数 欲置剪辑版的数据, 字节集, , Unicode文本格式
    .参数 uFormat, 整数型, 可空, #CF_*
    .局部变量 aryBin, 整数型
    .局部变量 nMaxCount, 整数型
    .局部变量 hMem, 整数型

    .如果真 (uFormat ≤ 0)
        uFormat ＝ #CF_UNICODETEXT
    .如果真结束
    aryBin ＝ 取指针_字节集型 (欲置剪辑版的数据)
    nMaxCount ＝ 选择 (uFormat ＝ #CF_UNICODETEXT, lstrlenW (aryBin), 取字节集长度 (欲置剪辑版的数据))
    .如果真 (nMaxCount ＞ 0)
        hMem ＝ GlobalAlloc (位或 (#GMEM_MOVEABLE, #GMEM_ZEROINIT), 选择 (uFormat ＝ #CF_UNICODETEXT, incShl (nMaxCount, ), nMaxCount ＋ 1))
        .如果真 (hMem ≠ #NULL)
            memcpy (GlobalLock (hMem), aryBin, 选择 (uFormat ＝ #CF_UNICODETEXT, incShl (nMaxCount, 真), nMaxCount))
            GlobalUnlock (hMem)
            .如果真 (OpenClipboard (#NULL) ＝ 1)
                EmptyClipboard ()
                SetClipboardData (uFormat, hMem)
                CloseClipboard ()
            .如果真结束
            GlobalFree (hMem)
        .如果真结束
        
    .如果真结束
    

.子程序 剪辑板_取文本, 文本型, 公开, 取出系统剪辑板中存放的文本
    返回 (编码_Unicode到Ansi (剪辑板_取文本W ()))

.子程序 剪辑板_取文本W, 字节集, 公开, 取出系统剪辑板中存放的Unicode编码的文本
    .局部变量 hClip, 整数型
    .局部变量 pchData, 整数型
    .局部变量 dwBinLen, 整数型
    .局部变量 szAryBin, 字节集

    .如果真 (OpenClipboard (#NULL) ＝ 1)
        .如果真 (IsClipboardFormatAvailable (#CF_UNICODETEXT) ≠ 0)
            hClip ＝ GetClipboardData (#CF_UNICODETEXT)
            .如果真 (hClip ≠ #NULL)
                pchData ＝ GlobalLock (hClip)
                dwBinLen ＝ GlobalSize (hClip)
                .如果真 (dwBinLen ＞ 0)
                    szAryBin ＝ 取空白字节集 (dwBinLen)
                    memcpy (取指针字节集_ (szAryBin), pchData, dwBinLen)
                .如果真结束
                GlobalUnlock (hClip)
            .如果真结束
            
        .如果真结束
        CloseClipboard ()
    .如果真结束
    返回 (szAryBin)

.子程序 剪辑板_置图片, , 公开, 设置指定图片到系统剪辑板
    .参数 图片数据, 字节集, , 要置入剪辑板的图片数据
    .局部变量 hBitmap, 整数型
    .局部变量 CPicture, 对象

    CoInitialize (0)
    hBitmap ＝ GetImageToBitmap (图片数据)
    .如果真 (hBitmap ＝ #NULL)
        CPicture.创建图片对象 (图片数据)
        hBitmap ＝ CPicture.读数值属性 (“Handle”, )
    .如果真结束
    .如果真 (hBitmap ≠ #NULL 且 OpenClipboard (#NULL) ＝ 1)
        EmptyClipboard ()
        SetClipboardData (#CF_BITMAP, hBitmap)
        CloseClipboard ()
    .如果真结束
    CoUninitialize ()

.子程序 剪辑板_取图片, 字节集, 公开, 获取系统剪辑板中的图片
    .参数 窗口句柄, 整数型
    .局部变量 剪辑板数据句柄, 整数型
    .局部变量 全局内存块大小, 整数型
    .局部变量 全局内存块, 整数型
    .局部变量 大小, 整数型
    .局部变量 图片, 字节集
    .局部变量 文件头, 字节集

    OpenClipboard (窗口句柄)
    剪辑板数据句柄 ＝ GetClipboardData (8)
    .如果真 (剪辑板数据句柄 ≠ 0)
        全局内存块大小 ＝ GlobalSize (剪辑板数据句柄)
        全局内存块 ＝ GlobalLock (剪辑板数据句柄)
        .如果真 (全局内存块大小 ≠ 0 且 全局内存块 ≠ 0)
            图片 ＝ 指针到字节集 (全局内存块, 全局内存块大小)
        .如果真结束
        GlobalUnlock (剪辑板数据句柄)
    .如果真结束
    CloseClipboard ()
    .如果真 (取字节集长度 (图片) ＝ 0)
        返回 ({ })
    .如果真结束
    文件头 ＝ 到字节集 (“BM”) ＋ 整数_到字节集 (取字节集长度 (图片) ＋ 2) ＋ 取空白字节集 (4) ＋ 整数_到字节集 (54) ＋ 取字节集左边 (图片, 16) ＋ 取空白字节集 (4) ＋ 整数_到字节集 (取字节集长度 (图片) － 52) ＋ 取空白字节集 (16)
    返回 (文件头 ＋ 取字节集右边 (图片, 取字节集长度 (图片) － 52))

.子程序 剪辑板_取位图数据A, 字节集, 公开, 获取系统剪辑板中的图片，支持QQ截图
    .参数 窗口句柄, 整数型, , 当前程序的窗口句柄
    .局部变量 图片句柄, 整数型
    .局部变量 信息, BITMAPINFOHEADER
    .局部变量 文件, BITMAPFILEHEADER
    .局部变量 hMem, 整数型
    .局部变量 lpData, 整数型
    .局部变量 hBitmap, 整数型
    .局部变量 指针, 整数型
    .局部变量 位图, 字节集
    .局部变量 bmp, 位图结构_
    .局部变量 hdc, 整数型
    .局部变量 私画布句柄, 整数型

    OpenClipboard (窗口句柄)
    图片句柄 ＝ GetClipboardData (2)
    CloseClipboard ()
    .如果真 (图片句柄 ＝ 0)
        返回 ({ })
    .如果真结束
    .如果真 (取对象属性_ (图片句柄, 28, bmp) ＝ 0)
        返回 ({ })
    .如果真结束
    信息.biSize ＝ 40
    信息.biWidth ＝ bmp.位图宽度
    信息.biHeight ＝ bmp.位图高度
    信息.biPlanes ＝ 1
    信息.biBitCount ＝ 24
    信息.biCompression ＝ 0
    信息.biSizeImage ＝ (bmp.位图宽度 × 24 ＋ 31) ÷ 8 × bmp.位图高度
    信息.biXPelsPerMeter ＝ 0
    信息.biYPelsPerMeter ＝ 0
    信息.biClrUsed ＝ 0
    信息.biClrImportant ＝ 0
    hdc ＝ GetDC (0)
    私画布句柄 ＝ CreateCompatibleDC (hdc)
    hMem ＝ GlobalAlloc (位或 (0, 64), 信息.biSizeImage)
    lpData ＝ GlobalLock (hMem)
    GetDIBits_x (私画布句柄, 图片句柄, 0, 信息.biHeight, lpData, 信息, 0)
    文件.bfType ＝ 19778
    文件.bfReserved1 ＝ 0
    文件.bfReserved2 ＝ 0
    文件.bfSize ＝ 14 ＋ 40 ＋ 信息.biSizeImage
    文件.bfOffBits ＝ 14 ＋ 40
    指针 ＝ VirtualAlloc (0, 54 ＋ 信息.biSizeImage, 4096, 4)
    RtlMoveMemory_BITMAPFILEHEADER_整数1 (指针, 文件, 14)
    RtlMoveMemory_BITMAPINFOHEADER_整数 (指针 ＋ 14, 信息, 40)
    RtlMoveMemory (指针 ＋ 54, lpData, 信息.biSizeImage)
    位图 ＝ 指针到字节集 (指针, 54 ＋ 信息.biSizeImage)
    VirtualFree (指针, 0, 32768)
    GlobalFree (hMem)
    DeleteDC (私画布句柄)
    返回 (位图)

.子程序 剪辑板_取位图数据B, 字节集, 公开, 获取系统剪辑板中的图片，支持QQ截图
    .参数 窗口句柄, 整数型, , 当前程序的窗口句柄
    .局部变量 图片句柄, 整数型
    .局部变量 信息, BITMAPINFOHEADER
    .局部变量 lpData, 整数型
    .局部变量 指针, 整数型
    .局部变量 位图, 字节集
    .局部变量 bmp, 位图结构_
    .局部变量 私画布句柄, 整数型
    .局部变量 文件头, 字节集

    OpenClipboard (窗口句柄)
    图片句柄 ＝ GetClipboardData (2)
    CloseClipboard ()
    .如果真 (图片句柄 ＝ 0)
        返回 ({ })
    .如果真结束
    .如果真 (取对象属性_ (图片句柄, 28, bmp) ＝ 0)
        返回 ({ })
    .如果真结束
    信息.biSize ＝ 40
    信息.biWidth ＝ bmp.位图宽度
    信息.biHeight ＝ bmp.位图高度
    信息.biPlanes ＝ 1
    信息.biBitCount ＝ 24
    信息.biCompression ＝ 0
    信息.biSizeImage ＝ (bmp.位图宽度 × 24 ＋ 31) ÷ 8 × bmp.位图高度
    信息.biXPelsPerMeter ＝ 0
    信息.biYPelsPerMeter ＝ 0
    信息.biClrUsed ＝ 0
    信息.biClrImportant ＝ 0
    私画布句柄 ＝ CreateCompatibleDC (0)
    位图 ＝ 取空白字节集 (信息.biSizeImage)
    lpData ＝ lstrcpyn_字节集 (位图, 位图, 0)
    GetDIBits_x (私画布句柄, 图片句柄, 0, 信息.biHeight, lpData, 信息, 0)
    文件头 ＝ 到字节集 (“BM”) ＋ 整数_到字节集 (信息.biSizeImage ＋ 54) ＋ 取空白字节集 (4) ＋ { 54, 0, 0, 0, 40, 0, 0, 0 } ＋ 整数_到字节集 (bmp.位图宽度) ＋ 整数_到字节集 (bmp.位图高度) ＋ { 1, 0, 24, 0 } ＋ 取空白字节集 (4) ＋ 整数_到字节集 (信息.biSizeImage) ＋ 取空白字节集 (16)
    位图 ＝ 文件头 ＋ 指针到字节集 (lpData, 信息.biSizeImage)
    DeleteDC (私画布句柄)
    返回 (位图)

.子程序 剪辑板_置文件, 逻辑型, 公开, 将指定文件复制到剪贴板，成功返回真，失败返回假。
    .参数 文件数组, 文本型, 数组, 欲复制到剪贴板的文件数组路径;
    .参数 状态, 逻辑型, 可空, 默认为假。真=对文件执行了剪切操作；假=对文件执行了复制操作
    .局部变量 sTmp, 字节集
    .局部变量 dfs, 剪贴板_置文件
    .局部变量 hGlobal, 整数型
    .局部变量 i, 整数型
    .局部变量 ret, 整数型
    .局部变量 lngFormat, 整数型
    .局部变量 lpGlobal, 整数型

    .如果真 (OpenClipboard (0) ＝ 0)
        返回 (假)
    .如果真结束
    EmptyClipboard ()
    .计次循环首 (取数组成员数 (文件数组), i)
        sTmp ＝ sTmp ＋ 到字节集 (文件数组 [i]) ＋ { 0 }
    .计次循环尾 ()
    sTmp ＝ sTmp ＋ { 0 }
    hGlobal ＝ GlobalAlloc (66, 20 ＋ 字节集_取长度 (sTmp))
    .如果真 (hGlobal ＝ 0)
        CloseClipboard ()
        返回 (假)
    .如果真结束
    lpGlobal ＝ GlobalLock (hGlobal)
    dfs.pFiles ＝ 20
    RtlMoveMemory_剪贴板_置文件 (lpGlobal, dfs, 20)
    RtlMoveMemory_字节集 (lpGlobal ＋ 20, sTmp, 字节集_取长度 (sTmp))
    GlobalUnlock (hGlobal)
    ret ＝ SetClipboardData (#CF_HDROP, hGlobal)
    GlobalFree (hGlobal)
    .如果真 (状态 且 ret ＞ 0)
        lngFormat ＝ RegisterClipboardFormatA (“Preferred DropEffect”)
        hGlobal ＝ GlobalAlloc (66, 4)
        RtlMoveMemory (GlobalLock (hGlobal), 取指针_通用型 (2), 4)
        GlobalUnlock (hGlobal)
        SetClipboardData (lngFormat, hGlobal)
        GlobalFree (hGlobal)
    .如果真结束
    CloseClipboard ()
    返回 (ret ＞ 0)

.子程序 剪辑板_取文件, 整数型, 公开, 取已经复制到剪贴板的文件名，返回文件个数。
    .参数 文件数组, 文本型, 可空 数组, 用于存放文件路径的数组,留空则只返回文件数量。
    .参数 状态, 逻辑型, 参考 可空, 返回=真,对文件执行了剪切操作；返回=假,对文件执行了复制操作
    .局部变量 hDrop, 整数型
    .局部变量 sTmp, 文本型
    .局部变量 lngFormat, 整数型
    .局部变量 lngEffect, 整数型
    .局部变量 lcount, 整数型
    .局部变量 i, 整数型

    清除数组 (文件数组)
    .如果真 (IsClipboardFormatAvailable (#CF_HDROP) ＝ 0 或 OpenClipboard (0) ＝ 0)
        返回 (0)
    .如果真结束
    hDrop ＝ GetClipboardData (#CF_HDROP)
    lcount ＝ DragQueryFileA (hDrop, -1, #NULL, 0)
    sTmp ＝ 取空白文本 (260)
    .计次循环首 (lcount, i)
        DragQueryFileA (hDrop, i － 1, 取指针文本_ (sTmp), 260)
        加入成员 (文件数组, sTmp)
    .计次循环尾 ()
    .如果真 (是否为空 (状态) ＝ 假)
        lngFormat ＝ RegisterClipboardFormatA (“Preferred DropEffect”)
        hDrop ＝ GetClipboardData (lngFormat)
        .如果真 (hDrop ≠ 0)
            RtlMoveMemory_整数传址1 (lngEffect, hDrop, 4)
        .如果真结束
        状态 ＝ lngEffect ＝ 2
        GlobalFree (hDrop)
    .如果真结束
    CloseClipboard ()
    返回 (lcount)

.子程序 剪辑板_取数据权窗口句柄, 整数型, 公开, 返回复制该数据的窗口句柄；如：一段文字是在记事本复制的，则返回记事本的窗口句柄
    返回 (GetClipboardOwner ())

.子程序 整数_到字节集, 字节集
    .参数 整数, 整数型
    .局部变量 字节集, 字节集

    字节集 ＝ 取空白字节集 (4)
    写到内存 (整数, lstrcpyn_字节集 (字节集, 字节集, 0), 4)
    返回 (字节集)

.子程序 剪辑板_取所有内容, 逻辑型, 公开
    .参数 参_剪辑版数据, 剪辑版数据, 参考 数组
    .局部变量 数据格式, 整数型
    .局部变量 剪辑版数据, 剪辑版数据
    .局部变量 缓冲区, 文本型
    .局部变量 数据句柄, 整数型
    .局部变量 内存指针, 整数型

    ' 源码采纳地址：https://bbs.125.la/forum.php?mod=viewthread&tid=14221328
    .如果真 (OpenClipboard (0) ＝ 0) ' 打开剪辑版
        返回 (假)
    .如果真结束
    清除数组 (参_剪辑版数据) ' 清除数据
    .判断循环首 (真)
        数据格式 ＝ EnumClipboardFormats (数据格式) ' 取出剪切板内容的数据格式
        .如果真 (数据格式 ＝ 0) ' 没有格式……
            跳出循环 ()
        .如果真结束
        剪辑版数据.剪辑版数据格式 ＝ 数据格式
        缓冲区 ＝ 取空白文本 (255) ' 生成缓冲区
        .判断开始 (数据格式 ≤ 14)
            剪辑版数据.文本型数据 ＝ “”
        .判断 (GetClipboardFormatNameA (数据格式, 缓冲区, 255) ＝ 0) ' 获取剪贴板内数据格式的名称，判断是否有文本
            剪辑版数据.文本型数据 ＝ “” ' 没有文本……
        .默认
            剪辑版数据.文本型数据 ＝ 缓冲区
        .判断结束
        数据句柄 ＝ GetClipboardData (数据格式) ' 取剪辑板数据句柄
        .如果真 (数据句柄 ＝ 0) ' 没有数据……
            到循环尾 () ' 开启下一个循环
        .如果真结束
        剪辑版数据.字节集长度 ＝ GlobalSize (数据句柄) ' 返回全局内存块大小，就是取出字节集长度
        内存指针 ＝ GlobalLock (数据句柄) ' 锁定内存对象并返回剪辑板数据指针
        剪辑版数据.字节集数据 ＝ 取空白字节集 (剪辑版数据.字节集长度) ' 生成缓冲区
        RtlMoveMemory (取数据_通用型 (剪辑版数据.字节集数据) ＋ 8, 内存指针, 剪辑版数据.字节集长度) ' 复制出来
        加入成员 (参_剪辑版数据, 剪辑版数据) ' OK，收工
        .如果真 (取数组成员数 (参_剪辑版数据) ＞ 100) ' 这么多……，估计是复制文件，但是再多估计进程会废了（内存严重怀疑溢出）
            跳出循环 ()
        .如果真结束
        
    .判断循环尾 ()
    CloseClipboard () ' 关闭剪辑版
    返回 (真)

.子程序 剪辑板_置内容, 逻辑型, 公开
    .参数 参_剪辑版数据, 剪辑版数据, 参考 数组
    .局部变量 局_计次, 整数型
    .局部变量 剪辑版数据格式, 整数型
    .局部变量 剪辑版格式, 整数型
    .局部变量 内存地址, 整数型
    .局部变量 内存指针, 整数型

    .如果真 (OpenClipboard (0) ＝ 0) ' 打开剪辑版
        返回 (假)
    .如果真结束
    EmptyClipboard () ' 清空剪切板并释放剪切板内数据的句柄，但是数据仿佛没有什么用了，2333
    .计次循环首 (取数组成员数 (参_剪辑版数据), 局_计次) ' 开始计次……
        剪辑版数据格式 ＝ 参_剪辑版数据 [局_计次].剪辑版数据格式
        .如果真 (参_剪辑版数据 [局_计次].文本型数据 ≠ “”)
            剪辑版格式 ＝ RegisterClipboardFormatA (参_剪辑版数据 [局_计次].文本型数据) ' 它注册一个新的剪贴板格式，此后这个格式可作为有效的剪贴板格式。
            .如果真 (剪辑版格式 ＞ 0) ' 注册成功！
                剪辑版数据格式 ＝ 剪辑版格式
            .如果真结束
            
        .如果真结束
        内存地址 ＝ GlobalAlloc (位或 (#CF_BITMAP, #CF_LIMITSIZE), 参_剪辑版数据 [局_计次].字节集长度) ' 在剪辑版中分配内存
        内存指针 ＝ GlobalLock (内存地址) ' 锁定内存对象并返回剪辑版指针
        RtlMoveMemory (内存指针, 取数据_通用型 (参_剪辑版数据 [局_计次].字节集数据) ＋ 8, 参_剪辑版数据 [局_计次].字节集长度) ' 倒着写回去
        GlobalUnlock (内存地址) ' 开锁全局内存块
        SetClipboardData (剪辑版数据格式, 内存地址) ' 剪辑板置数据，写回去
    .计次循环尾 ()
    CloseClipboard () ' 关闭剪辑版
    返回 (真)

.子程序 剪贴板_监听, , 公开, 把指定的窗口句柄加入到剪贴板查看器链中
    .参数 窗口句柄, 整数型
    .参数 回调函数, 子程序指针, , WndProc(整数型 hwnd, 整数型 uMsg, 整数型 wParam, 整数型 lParam)，返回1拦截。

    SetPropA (窗口句柄, “Clipboard_Monitor”, SetWindowLongA (窗口句柄, #GWL_WNDPROC, 到整数 (&WndProc_Clipboard_Monitor)))
    SetPropA (窗口句柄, “Clipboard_Callback”, 到整数 (回调函数))
    SetPropA (窗口句柄, “Clipboard_Viewer”, SetClipboardViewer (窗口句柄))

.子程序 WndProc_Clipboard_Monitor, 整数型
    .参数 hWnd, 整数型
    .参数 uMsg, 整数型
    .参数 wParam, 整数型
    .参数 lParam, 整数型
    .局部变量 this, 整数型
    .局部变量 call, 整数型
    .局部变量 viewer, 整数型

    this ＝ GetPropA (hWnd, “Clipboard_Monitor”)
    call ＝ GetPropA (hWnd, “Clipboard_Callback”)
    viewer ＝ GetPropA (hWnd, “Clipboard_Viewer”)
    .如果真 (uMsg ＝ #WM_DRAWCLIPBOARD 或 uMsg ＝ #WM_CHANGECBCHAIN 或 uMsg ＝ #WM_DESTROY)
        .如果真 (CallWindowProcA (call, hWnd, uMsg, wParam, lParam) ＝ 1) ' 拦截
            返回 (1)
        .如果真结束
        
        .如果真 (uMsg ＝ #WM_CHANGECBCHAIN 且 wParam ≠ viewer)
            SendMessageA (viewer, uMsg, wParam, lParam)
        .如果真结束
        
    .如果真结束
    返回 (CallWindowProcA (this, hWnd, uMsg, wParam, lParam))

.子程序 剪贴板_停止监听, , 公开, 从剪贴板查看器链中删除指定的窗口句柄
    .参数 窗口句柄, 整数型
    .局部变量 this, 整数型

    this ＝ GetPropA (窗口句柄, “Clipboard_Monitor”)
    ChangeClipboardChain (窗口句柄, GetPropA (窗口句柄, “Clipboard_Viewer”))
    SetWindowLongA (窗口句柄, #GWL_WNDPROC, this)
    RemovePropA (窗口句柄, “Clipboard_Monitor”)
    RemovePropA (窗口句柄, “Clipboard_Callback”)
    RemovePropA (窗口句柄, “Clipboard_Viewer”)

.版本 2

.程序集 集_取硬盘特征字
.子程序 系统_取硬盘特征字, 整数型, 公开, 获取系统硬盘特征字
    .参数 iDrive, 整数型, 可空
    .参数 硬盘序列号, 文本型, 参考 可空
    .参数 硬盘模型号, 文本型, 参考 可空
    .局部变量 sFilePath, 文本型
    .局部变量 hDevice, 整数型
    .局部变量 InBufferIDE, 取硬盘特征号0
    .局部变量 OutBufferIDE, 取硬盘特征号1
    .局部变量 InBufferSCSI, 取硬盘特征号2
    .局部变量 OutBuffer, 字节集
    .局部变量 BytesRet, 整数型
    .局部变量 IDEData, 取硬盘特征号3
    .局部变量 硬盘特征码, 整数型

    硬盘特征码 ＝ 取硬盘特征字 ()
    .如果真 (硬盘特征码 ≠ 0)
        返回 (硬盘特征码)
    .如果真结束
    .如果 (系统_取操作系统类别 () ≥ 4)
        sFilePath ＝ “\\.\PHYSICALDRIVE” ＋ 整数型_到文本 (iDrive)
        hDevice ＝ CreateFileA (sFilePath, 位或 (2147483648, 1073741824), 位或 (1, 2), 0, 3, 0, 0)
        .判断开始 (hDevice ≠ -1)
            .如果真 (_设备操作0 (hDevice, 475264, 0, 0, OutBufferIDE, 24, BytesRet, 0) ≠ 0)
                OutBuffer ＝ 字节集_取空白 (544)
                InBufferIDE.cBufferSize ＝ 512
                InBufferIDE.bSectorCountReg ＝ 1
                InBufferIDE.bSectorNumberReg ＝ 1
                .如果 (位与 (iDrive, 1) ≠ 0)
                    InBufferIDE.bDriveHeadReg ＝ 176
                .否则
                    InBufferIDE.bDriveHeadReg ＝ 160
                .如果结束
                .如果 (iDrive ≠ 0)
                    InBufferIDE.bCommandReg ＝ OutBufferIDE.bIDEDeviceMap ÷ 位与 (iDrive, 16)
                .否则
                    InBufferIDE.bCommandReg ＝ OutBufferIDE.bIDEDeviceMap
                .如果结束
                .如果 (InBufferIDE.bCommandReg ＝ 0)
                    InBufferIDE.bCommandReg ＝ 161
                .否则
                    InBufferIDE.bCommandReg ＝ 236
                .如果结束
                .如果真 (DeviceIoControl (hDevice, 508040, InBufferIDE, 32, OutBuffer, 544, BytesRet, 0) ＝ 0)
                    InBufferIDE.bCommandReg ＝ 236
                    DeviceIoControl (hDevice, 508040, InBufferIDE, 32, OutBuffer, 544, BytesRet, 0)
                .如果真结束
                RtlMoveMemory_取硬盘特征号3 (IDEData, 字节集_取指定位置字节集 (OutBuffer, 17, 256), 256)
            .如果真结束
            
        .默认
            CloseHandle (hDevice)
            sFilePath ＝ “\\.\SCSI” ＋ 整数型_到文本 (iDrive) ＋ “:”
            hDevice ＝ CreateFileA (sFilePath, 位或 (2147483648, 1073741824), 位或 (1, 2), 0, 3, 0, 0)
            .如果真 (hDevice ≠ -1)
                InBufferSCSI.HeaderLength ＝ 28
                RtlMoveMemory (取数据_通用型_数组 (InBufferSCSI.Signature), 取指针_文本型 (“SCSIDISK”), 8)
                InBufferSCSI.Timeout ＝ 2
                InBufferSCSI.Length ＝ 544
                InBufferSCSI.ControlCode ＝ 1770753
                InBufferSCSI.cBufferSize ＝ 512
                InBufferSCSI.bSectorCountReg ＝ 1
                InBufferSCSI.bSectorNumberReg ＝ 1
                .如果 (位与 (iDrive, 1) ≠ 0)
                    InBufferSCSI.bDriveHeadReg ＝ 176
                .否则
                    InBufferSCSI.bDriveHeadReg ＝ 160
                .如果结束
                InBufferSCSI.bCommandReg ＝ 236
                OutBuffer ＝ 字节集_取空白 (572)
                .如果真 (_设备操作2 (hDevice, 315400, InBufferSCSI, 60, OutBuffer, 572, BytesRet, 0) ≠ 0)
                    RtlMoveMemory_取硬盘特征号3 (IDEData, 字节集_取指定位置字节集 (OutBuffer, 45, 256), 256)
                .如果真结束
                
            .如果真结束
            
        .判断结束
        
    .否则
        sFilePath ＝ “\\.\SMARTVSD”
        hDevice ＝ CreateFileA (sFilePath, 0, 0, 0, 1, 0, 0)
        .如果真 (hDevice ≠ -1)
            InBufferIDE.cBufferSize ＝ 512
            InBufferIDE.bSectorCountReg ＝ 1
            InBufferIDE.bSectorNumberReg ＝ 1
            .如果 (位与 (iDrive, 1) ≠ 0)
                InBufferIDE.bDriveHeadReg ＝ 176
            .否则
                InBufferIDE.bDriveHeadReg ＝ 160
            .如果结束
            InBufferIDE.bCommandReg ＝ 236
            OutBuffer ＝ 字节集_取空白 (528)
            .如果真 (DeviceIoControl (hDevice, 508040, InBufferIDE, 32, OutBuffer, 528, BytesRet, 0) ≠ 0)
                RtlMoveMemory_取硬盘特征号3 (IDEData, 字节集_取指定位置字节集 (OutBuffer, 17, 256), 256)
            .如果真结束
            
        .如果真结束
        
    .如果结束
    CloseHandle (hDevice)
    .如果真 (是否为空 (硬盘序列号) ＝ 假)
        硬盘序列号 ＝ FixString (IDEData.sSerialNumber)
    .如果真结束
    .如果真 (是否为空 (硬盘模型号) ＝ 假)
        硬盘模型号 ＝ FixString (IDEData.sModelNumber)
    .如果真结束
    硬盘特征码 ＝ 特征字计算 (IDEData)
    .如果真 (取文本长度 (到文本 (硬盘特征码)) ≤ 2)
        硬盘特征码 ＝ 系统_取硬盘特征字1 ()
    .如果真结束
    返回 (硬盘特征码)

.子程序 系统_取操作系统类别, 整数型, 公开, 返回当前操作系统的版本类别。返回值为以下值之一：0、未知； 1、Win95； 2、Win98； 3、WinME； 4、WinNT； 5、Win2000； 6、WinXP； 7、Win2003； 8、Vista；9、Win7； 10、Win8； 11、Win8.1； 12、Win10
    置入代码 ({ 83, 49, 192, 100, 139, 29, 24, 0, 0, 0, 100, 139, 13, 48, 0, 0, 0, 133, 201, 121, 32, 185, 0, 0, 83, 0, 57, 75, 88, 117, 4, 176, 1, 235, 113, 57, 75, 84, 117, 4, 176, 2, 235, 104, 57, 75, 124, 117, 99, 176, 3, 235, 95, 139, 153, 168, 0, 0, 0, 139, 137, 164, 0, 0, 0, 131, 249, 4, 119, 4, 176, 4, 235, 74, 131, 249, 5, 117, 27, 131, 251, 0, 117, 4, 176, 5, 235, 60, 131, 251, 1, 117, 4, 176, 6, 235, 51, 131, 251, 2, 117, 4, 176, 7, 235, 42, 131, 249, 6, 117, 35, 131, 251, 0, 117, 4, 176, 8, 235, 28, 131, 251, 1, 117, 2, 176, 9, 131, 251, 2, 117, 2, 176, 10, 131, 251, 3, 117, 2, 176, 11, 131, 251, 4, 117, 2, 176, 12, 91, 201, 195 })
    返回 (0)

.子程序 系统_取硬盘特征字1, 整数型, 公开, 返回0说明未取到。这个主要是补充易不能在某些系统或是硬盘上取硬盘特征字。
    .局部变量 driveName, 文本型
    .局部变量 hPhysicalDriveIOCTL, 整数型
    .局部变量 query, 字节集
    .局部变量 cbBytesReturned, 整数型
    .局部变量 buffer, 字节集
    .局部变量 buffersize, 整数型
    .局部变量 st, 逻辑型
    .局部变量 crc1, 整数型

    driveName ＝ “\\.\PhysicalDrive0”
    hPhysicalDriveIOCTL ＝ CreateFileA (driveName, 0, 位或 (1, 2), 0, 3, 0, 0)
    .如果真 (hPhysicalDriveIOCTL ＝ -1)
        返回 (0)
    .如果真结束
    buffersize ＝ 1024
    query ＝ 取空白字节集 (12)
    buffer ＝ 取空白字节集 (buffersize)
    st ＝ DeviceIoControl1 (hPhysicalDriveIOCTL, 2954240, lstrcpynA_字节集 (query, query, 0), 12, lstrcpynA_字节集 (buffer, buffer, 0), buffersize, cbBytesReturned, 0)
    .如果真 (st ＝ 真)
        crc1 ＝ get_crc32 (buffer)
    .如果真结束
    CloseHandle (hPhysicalDriveIOCTL)
    返回 (crc1)

.子程序 get_crc32, 整数型, , 1
    .参数 原文, 字节集, , 主要用来取文本的crc32，取文件的crc32要专门写个取文件的
    .局部变量 crcval, 整数型
    .局部变量 长度, 整数型
    .局部变量 i, 整数型
    .局部变量 结果, 整数型
    .局部变量 位置, 整数型
    .局部变量 crc, 整数型
    .局部变量 table, 整数型, , "256"

    长度 ＝ 取字节集长度 (原文)
    .如果真 (长度 ＜ 1)
        返回 (0)
    .如果真结束
    .变量循环首 (0, 255, 1, i) ' 用来得到码表
        crc ＝ i
        .变量循环首 (1, 8, 1, )
            .如果 (位与 (crc, 1) ≠ 0)
                crc ＝ 位异或 (位与 (右移 (crc, 1), 2147483647), 3988292384) ' crc xor EDB88320
            .否则
                crc ＝ 位与 (右移 (crc, 1), 2147483647)
            .如果结束
            
        .变量循环尾 ()
        table [i ＋ 1] ＝ crc
    .变量循环尾 ()
    crcval ＝ 4294967295
    .计次循环首 (长度, i)
        位置 ＝ 位异或 (原文 [i], 位与 (crcval, 255)) ＋ 1 ' 查表
        crcval ＝ 位异或 (位与 (右移 (crcval, 8), 16777215), table [位置])
    .计次循环尾 ()
    结果 ＝ 位取反 (crcval)
    返回 (结果)

.子程序 FixString, 文本型
    .参数 pwDiskData, 字节型, 数组
    .局部变量 DiskData, 字节集
    .局部变量 i, 整数型

    DiskData ＝ 字节集_取空白 (取数组成员数 (pwDiskData))
    .变量循环首 (1, 取数组成员数 (pwDiskData), 2, i)
        DiskData [i] ＝ pwDiskData [i ＋ 1]
        DiskData [i ＋ 1] ＝ pwDiskData [i]
    .变量循环尾 ()
    DiskData ＝ 子字节集替换 (DiskData, { 32 }, , , )
    返回 (字节集_到文本 (DiskData))

.子程序 特征字计算, 整数型
    .参数 Data, 取硬盘特征号3
    .局部变量 Dword, 字节集
    .局部变量 i, 整数型
    .局部变量 ToData, 整数型
    .局部变量 Total, 整数型
    .局部变量 返回值, 整数型

    Dword ＝ { 0, 0, 0, 0 }
    .计次循环首 (40, i)
        .判断开始 (i ％ 2 ＝ 0)
            Dword [2] ＝ Data.sModelNumber [i]
            Total ＝ Total ＋ 字节集_到整数 (Dword)
        .默认
            Dword [1] ＝ Data.sModelNumber [i]
        .判断结束
        
    .计次循环尾 ()
    .计次循环首 (8, i)
        .判断开始 (i ％ 2 ＝ 0)
            Dword [2] ＝ Data.sFirmwareRev [i]
            Total ＝ Total ＋ 字节集_到整数 (Dword)
        .默认
            Dword [1] ＝ Data.sFirmwareRev [i]
        .判断结束
        
    .计次循环尾 ()
    .计次循环首 (20, i)
        .判断开始 (i ％ 2 ＝ 0)
            Dword [2] ＝ Data.sSerialNumber [i]
            Total ＝ Total ＋ 字节集_到整数 (Dword)
        .默认
            Dword [1] ＝ Data.sSerialNumber [i]
        .判断结束
        
    .计次循环尾 ()
    ToData ＝ Data.wBufferSize ＋ Data.wSectorsPerTrack ＋ Data.wNumHeads ＋ Data.wNumCyls
    .如果 (ToData × 65536 ＋ Total ≤ 4294967295)
        返回值 ＝ ToData × 65536 ＋ Total
    .否则
        返回值 ＝ ((ToData － 1) ％ 65535 ＋ 1) × 65536 ＋ Total ％ 65535
    .如果结束
    返回 (返回值)

.子程序 字节集_子寻找, 整数型, , 分割字节集时用
    .参数 X, 字节集
    .参数 Y, 字节集
    .参数 Z, 整数型, 数组
    .参数 StartOffset, 整数型, 可空
    .局部变量 i, 整数型
    .局部变量 j, 整数型
    .局部变量 Len_Y, 整数型

    清除数组 (Z)
    i ＝ 1
    .如果 (是否为空 (StartOffset))
        j ＝ 1
    .否则
        j ＝ StartOffset
    .如果结束
    Len_Y ＝ 字节集_取长度 (Y)
    .判断循环首 (i ≠ -1)
        i ＝ 字节集_寻找 (X, Y, j)
        .如果真 (i ≠ -1)
            加入成员 (Z, i)
            j ＝ i ＋ Len_Y
        .如果真结束
        程序_延时 (1)
    .判断循环尾 ()
    返回 (取数组成员数 (Z))

.子程序 文本型_取空白, 文本型, , 支持斩月,但速度不是最快,不过简单,哈～～
    .参数 零字节数目, 整数型
    .局部变量 Address, 整数型
    .局部变量 返回值, 文本型

    .如果真 (零字节数目 ＜ 1)
        返回 (“”)
    .如果真结束
    Address ＝ LocalAlloc (64, 零字节数目 ＋ 1)
    .如果真 (Address ＝ 0)
        返回 (“”)
    .如果真结束
    RtlFillMemory_字节 (Address, 零字节数目, 32)
    返回值 ＝ 指针到文本 (Address)
    LocalFree (Address)
    返回 (返回值)

.版本 2

.程序集 集_对话框
.子程序 对话框_打开文件, 文本型, 公开, 成功打开返回文件路径,失败返回空文本
    .参数 窗口句柄, 整数型, , 拥有者窗口句柄,如启动窗口的句柄
    .参数 初始目录, 文本型, 可空, 指定当打开对话框时所自动跳转到的目录,如果留空将跳转到当前目录
    .参数 对话框标题, 文本型, 可空, 对话框的标题，可空:默认为"打开文件"
    .参数 过滤器, 文本型, 可空, 可空，默认为“所有文件(*.*)|*.*”  每对中的第一个字符串是描述过滤器的显示字符串（例如，文本文件），第二个字符串指定过滤器模式（例如，*.TXT）。要为单个显示字符串指定多个过滤器模式，请使用分号分隔模式（例如，*.TXT; *.DOC; *.BAK）。模式字符串可以是有效文件名字和星号（*）通配符的组合。模式字符串中不要包含空格。
    .参数 修改当前目录, 逻辑型, 可空, 可以为空。默认为假，不改变当前目录。真 = 把初始目录改成当前目录。
    .局部变量 局_结构, OPENFILENAME
    .局部变量 局_计次, 整数型
    .局部变量 局_数组, 文本型, , "0"
    .局部变量 局_当前目录, 文本型

    局_当前目录 ＝ 取当前目录 ()
    .如果真 (是否为空 (对话框标题))
        对话框标题 ＝ “打开文件”
    .如果真结束
    .如果真 (是否为空 (过滤器))
        过滤器 ＝ “所有文件(*.*)|*.*”
    .如果真结束
    局_结构.结构大小 ＝ 76
    局_结构.窗口句柄 ＝ 窗口句柄
    局_结构.实例句柄 ＝ 0
    局_数组 ＝ 分割文本 (过滤器, “|”, )
    .计次循环首 (取数组成员数 (局_数组), 局_计次)
        .如果 (取数组成员数 (局_数组) ＝ 局_计次)
            局_结构.过滤器 ＝ 局_结构.过滤器 ＋ 到字节集 (局_数组 [局_计次]) ＋ { 0, 0 }
        .否则
            局_结构.过滤器 ＝ 局_结构.过滤器 ＋ 到字节集 (局_数组 [局_计次]) ＋ { 0 }
        .如果结束
        
    .计次循环尾 ()
    局_结构.自定义过滤器 ＝ 字符 (0)
    局_结构.自定义过滤器最大长度 ＝ 0
    局_结构.过滤器索引 ＝ 1
    局_结构.文件名 ＝ { 0 } ＋ 取空白字节集 (512)
    局_结构.文件名最大长度 ＝ 512
    局_结构.文件标题 ＝ 取空白文本 (512)
    局_结构.文件标题最大长度 ＝ 512
    局_结构.初始目录 ＝ 选择 (是否为空 (初始目录), 局_当前目录, 初始目录)
    局_结构.标题 ＝ 对话框标题
    局_结构.标志 ＝ 0
    局_结构.文件扩展名 ＝ 0
    .如果 (GetOpenFileNameA (局_结构))
        .如果真 (修改当前目录 ＝ 假)
            改变目录 (局_当前目录)
        .如果真结束
        返回 (到文本 (局_结构.文件名))
    .否则
        .如果真 (修改当前目录 ＝ 假)
            改变目录 (局_当前目录)
        .如果真结束
        返回 (“”)
    .如果结束
    

.子程序 对话框_另存文件, 文本型, 公开, 成功打开返回文件路径,失败返回空文本
    .参数 窗口句柄, 整数型, , 拥有者窗口句柄,如启动窗口的句柄
    .参数 初始目录, 文本型, 可空, 指定当打开对话框时所自动跳转到的目录,如果留空将跳转到当前目录
    .参数 对话框标题, 文本型, 可空, 对话框的标题，可空:默认为"保存文件"
    .参数 默认文件名, 文本型, 可空
    .参数 过滤器, 文本型, 可空, 可空，每对中的第一个字符串是描述过滤器的显示字符串（例如，文本文件），第二个字符串指定过滤器模式（例如，*.TXT）。要为单个显示字符串指定多个过滤器模式，请使用分号分隔模式（例如，*.TXT; *.DOC; *.BAK）。模式字符串可以是有效文件名字和星号（*）通配符的组合。模式字符串中不要包含空格。
    .参数 初始过滤器, 整数型, 可空, 可空，默认为1，指定初始的过滤器，1为第一个过滤器
    .参数 修改当前目录, 逻辑型, 可空, 可以为空。默认为假，不改变当前目录。真 = 把初始目录改成当前目录。
    .局部变量 过滤器索引, 整数型
    .局部变量 局_结构, OPENFILENAME
    .局部变量 局_计次, 整数型
    .局部变量 局_数组, 文本型, , "0"
    .局部变量 局_当前目录, 文本型

    局_当前目录 ＝ 取当前目录 ()
    .如果真 (是否为空 (对话框标题))
        对话框标题 ＝ “保存文件”
    .如果真结束
    .如果真 (是否为空 (过滤器))
        过滤器 ＝ “TXT文档(*.txt)|*.txt|所有文件(*.*)|*.*”
    .如果真结束
    .如果真 (初始过滤器 ＝ 0)
        初始过滤器 ＝ 1
    .如果真结束
    .如果真 (是否为空 (默认文件名))
        默认文件名 ＝ 到文本 ({ 0 })
    .如果真结束
    
    局_结构.结构大小 ＝ 76
    局_结构.窗口句柄 ＝ 窗口句柄
    局_结构.实例句柄 ＝ 0
    局_数组 ＝ 分割文本 (过滤器, “|”, )
    .计次循环首 (取数组成员数 (局_数组), 局_计次)
        .如果 (取数组成员数 (局_数组) ＝ 局_计次)
            局_结构.过滤器 ＝ 局_结构.过滤器 ＋ 到字节集 (局_数组 [局_计次]) ＋ { 0, 0 }
        .否则
            局_结构.过滤器 ＝ 局_结构.过滤器 ＋ 到字节集 (局_数组 [局_计次]) ＋ { 0 }
        .如果结束
        
    .计次循环尾 ()
    局_结构.自定义过滤器 ＝ 字符 (0)
    局_结构.自定义过滤器最大长度 ＝ 0
    局_结构.过滤器索引 ＝ 初始过滤器
    ' 局_结构.文件名 ＝ { 0 } ＋ 取空白字节集 (512)
    ' 局_结构.文件名最大长度 ＝ 512
    局_结构.文件名 ＝ 到字节集 (默认文件名) ＋ 取空白字节集 (512 － 取字节集长度 (到字节集 (默认文件名)))
    局_结构.文件名最大长度 ＝ 512 － 取字节集长度 (到字节集 (默认文件名))
    
    局_结构.文件标题 ＝ 取空白文本 (512)
    局_结构.文件标题最大长度 ＝ 512
    局_结构.初始目录 ＝ 选择 (是否为空 (初始目录), 局_当前目录, 初始目录)
    
    局_结构.标题 ＝ 对话框标题
    局_结构.标志 ＝ 0
    局_结构.文件扩展名 ＝ 0
    局_结构.默认扩展名 ＝ “”
    .如果 (GetSaveFileNameA (局_结构))
        .如果真 (修改当前目录 ＝ 假)
            改变目录 (局_当前目录)
        .如果真结束
        返回 (到文本 (局_结构.文件名))
    .否则
        .如果真 (修改当前目录 ＝ 假)
            改变目录 (局_当前目录)
        .如果真结束
        返回 (“”)
    .如果结束
    

.子程序 对话框_打开颜色选择框, 整数型, 公开, 打开颜色选择框,成功返回指定的颜色值,取消或失败返回-1
    .参数 窗口句柄, 整数型, , 拥有者窗口句柄
    .局部变量 颜色对话框, 精易_颜色对话框
    .局部变量 局_成功, 整数型

    颜色对话框.窗口句柄 ＝ 窗口句柄
    颜色对话框.颜色数长度 ＝ 取空白文本 (15)
    颜色对话框.长度 ＝ 36
    局_成功 ＝ ChooseColorA (颜色对话框)
    .如果真 (局_成功 ＝ 1)
        返回 (颜色对话框.rgbResult)
    .如果真结束
    返回 (-1)

.子程序 对话框_打开文件多选框, 文本型, 公开, 打开多选文件对话框,可单个一个文件,将直接返回文件路径,如果选择多个文件,将以换行符分隔
    .参数 窗口句柄, 整数型, 可空, 拥有者窗口句柄
    .参数 窗口标题, 文本型, 可空, 对话框窗口标题
    .参数 过滤器, 文本型, 可空, 可为空,默认即所有文件,过滤器文本由单个或多个成对的文本串组成，每对文本串的第一个描述显示形式，如：“文本文件（*.txt）”；第二个指定实际的过滤匹配符，如：“*.txt”，所有各文本串之间用“|”号隔开
    .参数 初始目录, 文本型, 可空, 可以为空。如果留空将跳转到当前目录
    .参数 修改当前目录, 逻辑型, 可空, 可以为空。默认为假，不改变当前目录。真 = 把初始目录改成当前目录。
    .局部变量 文件列表, OPENFILENAME
    .局部变量 文件名, 字节集
    .局部变量 文件名数组, 文本型, , "0"
    .局部变量 局_计次, 整数型, , , 记录循环的次数
    .局部变量 多选文件, 文本型
    .局部变量 文件缓冲数, 整数型, , , 决定可以打开文件的个数，原为8192，可打开80个文件
    .局部变量 局_当前目录, 文本型

    局_当前目录 ＝ 取当前目录 ()
    文件缓冲数 ＝ 98192 ' 大小决定打开文件的数量，此可以打开200个文件
    文件列表.结构大小 ＝ 76 ' 文件列表.lStructSize ＝ 76
    文件列表.窗口句柄 ＝ 窗口句柄
    文件列表.过滤器 ＝ 子字节集替换 (到字节集 (过滤器), { 124 }, { 0 }, , ) ＋ { 0 } ＋ { 0 }
    文件列表.文件名 ＝ 取空白字节集 (文件缓冲数)
    文件列表.文件名最大长度 ＝ 文件缓冲数
    文件列表.文件标题 ＝ 取空白文本 (文件缓冲数)
    文件列表.文件标题最大长度 ＝ 文件缓冲数
    文件列表.初始目录 ＝ 选择 (是否为空 (初始目录), 局_当前目录, 初始目录)
    文件列表.标题 ＝ 窗口标题
    文件列表.标志 ＝ 524800
    
    .如果 (GetOpenFileNameA (文件列表)) ' 打开文件成功
        文件名 ＝ 文件列表.文件名 ' 文件名 ＝ 文件列表.lpstrFile
        文件名 ＝ 取字节集左边 (文件名, 寻找字节集 (文件名, { 0, 0 }, ) － 1)
        .如果 (寻找字节集 (文件名, { 0 }, ) ≠ -1) ' 是否选择多个文件
            文件名数组 ＝ 分割文本 (到文本 (子字节集替换 (文件名, { 0 }, { 124 }, , )), “|”, )
            .如果真 (取文本右边 (文件名数组 [1], 1) ≠ “\”) ' 选择多个文件时，第一个数组为路径名，后面为不包括路径的文件名
                文件名数组 [1] ＝ 文件名数组 [1] ＋ “\”
            .如果真结束
            .计次循环首 (取数组成员数 (文件名数组) － 1, 局_计次)
                .如果 (取数组成员数 (文件名数组) － 1 ≠ 局_计次) ' 最后一个文件名不用加分隔字符“；”
                    多选文件 ＝ 多选文件 ＋ 文件名数组 [1] ＋ 文件名数组 [局_计次 ＋ 1] ＋ #换行符
                .否则
                    多选文件 ＝ 多选文件 ＋ 文件名数组 [1] ＋ 文件名数组 [局_计次 ＋ 1]
                .如果结束
                
            .计次循环尾 ()
            .如果真 (修改当前目录 ＝ 假)
                改变目录 (局_当前目录)
            .如果真结束
            返回 (多选文件)
        .否则
            .如果真 (修改当前目录 ＝ 假)
                改变目录 (局_当前目录)
            .如果真结束
            返回 (到文本 (文件名))
        .如果结束
        
    .否则
        返回 (“”)
    .如果结束
    

.子程序 对话框_整理收藏夹, , 公开
    .参数 窗口句柄, 整数型, , 直接用 取窗口句柄() 命令即可

    DoOrganizeFavDlg (窗口句柄, 目录_取特定目录 (2))

.子程序 对话框_添加到收藏夹, , 公开
    .参数 窗口句柄, 整数型, , 直接用 取窗口句柄() 命令即可
    .参数 网页标题, 文本型
    .参数 网页地址, 文本型
    .局部变量 局_pid, 整数型
    .局部变量 局_写入路径, 文本型

    局_写入路径 ＝ 目录_取特定目录 (2)
    .如果真 (网页标题 ＝ “” 或 网页地址 ＝ “about:blank”)
        返回 ()
    .如果真结束
    SHGetSpecialFolderLocation (窗口句柄, 6, 局_pid)
    .如果真 (DoAddToFavDlg (窗口句柄, 局_写入路径, 256, 网页标题, 256, 局_pid))
        .如果真 (写配置项 (局_写入路径, “InternetShortcut”, “URL”, 网页地址))
            提示框 (“已经添加到收藏夹”, #信息图标, , 窗口句柄)
        .如果真结束
        
    .如果真结束
    CoTaskMemFree (局_pid)

.子程序 对话框_打开文件夹, 文本型, 公开, 打开选择文件夹对话框，成功返回文件夹路径
    .参数 标题, 文本型, 可空
    .参数 父窗口句柄, 整数型, 可空
    .局部变量 szPath, 字节集

    szPath ＝ 对话框_打开文件夹W (编码_Ansi到Unicode (标题, ), 父窗口句柄)
    返回 (编码_Unicode到Ansi (szPath))

.子程序 对话框_打开文件夹W, 字节集, 公开, 打开选择文件夹对话框，成功返回文件夹路径
    .参数 标题, 字节集, 可空
    .参数 父窗口句柄, 整数型, 可空
    .局部变量 szPath, 字节集, , "0"
    .局部变量 len, 整数型

    len ＝ OpenWindowsDlg (, , 真, , , 标题, 父窗口句柄, szPath)
    .如果真 (len ＞ 0)
        返回 (szPath [1])
    .如果真结束
    返回 ({ })

.子程序 OpenWindowsDlg, 整数型, 公开, 通用对话框W
    .参数 isMultiSelect, 逻辑型, 可空, 多选
    .参数 IsSave, 逻辑型, 可空, 保存
    .参数 IsPickFolder, 逻辑型, 可空, 文件夹
    .参数 FilterSpec, 字节集, 可空, 类型
    .参数 FilterSpecIndex, 整数型, 可空, 类型索引
    .参数 SetTitle, 字节集, 可空, 标题
    .参数 hWnd, 整数型, 可空, 窗口句柄
    .参数 GetDisplayName, 字节集, 参考 数组, 获取显示名称
    .参数 InitialFolder, 字节集, 可空, 初始目录
    .参数 SetCodingOption, 整数型, 可空, 编码选项
    .参数 GetCodingItem, 整数型, 参考 可空, 获取编码选项
    .局部变量 hr, 整数型
    .局部变量 pFileDialog, 整数型
    .局部变量 pIFileDialogCustomize, 整数型
    .局部变量 dwFlags, 整数型
    .局部变量 rgFilterSpec, 字节集
    .局部变量 pFilterSpec, 整数型
    .局部变量 dwSize, 整数型
    .局部变量 cFileTypes, 整数型
    .局部变量 aryAddr, 整数型, , "0"
    .局部变量 pShellItem, 整数型
    .局部变量 dwNumItems, 整数型
    .局部变量 pSelOneItem, 整数型
    .局部变量 pszPath, 整数型
    .局部变量 pidl, 整数型
    .局部变量 psi, 整数型
    .局部变量 aryLabel, 文本型, , "0"
    .局部变量 szLabel, 字节集
    .局部变量 dwCount, 整数型
    .局部变量 i, 整数型

    .如果真 (_WIN32_WINNT ＜ #_WIN32_WINNT_VISTA)
        输出调试文本 (#ERROR_NOTVERSION)
        返回 (0)
    .如果真结束
    清除数组 (GetDisplayName)
    CoInitialize (#NULL)
    .如果 (IsSave)
        hr ＝ CoCreateInstance1 (取指针_字节集型 (#CLSID_FileSaveDialog), #NULL, #CLSCTX_INPROC_SERVER, 取指针_字节集型 (#IID_IFileSaveDialog), pFileDialog)
    .否则
        hr ＝ CoCreateInstance1 (取指针_字节集型 (#CLSID_FileOpenDialog), #NULL, #CLSCTX_INPROC_SERVER, 取指针_字节集型 (#IID_IFileOpenDialog), pFileDialog)
    .如果结束
    .如果真 (hr ＝ #S_OK 且 pFileDialog ≠ #NULL)
        hr ＝ CallObject (pFileDialog, #IFileDialog_GetOptions, 取指针整数_ (dwFlags), , , , , , , , )
        .如果真 (isMultiSelect)
            dwFlags ＝ 位或 (dwFlags, #FOS_ALLOWMULTISELECT)
        .如果真结束
        .如果 (IsPickFolder)
            dwFlags ＝ 位或 (dwFlags, #FOS_PICKFOLDERS)
        .否则
            dwFlags ＝ 位或 (dwFlags, #FOS_FORCEFILESYSTEM)
        .如果结束
        hr ＝ CallObject (pFileDialog, #IFileDialog_SetOptions, dwFlags, , , , , , , , )
        .如果真 (IsPickFolder ＝ 假)
            .如果 (FilterSpec ＝ { })
                rgFilterSpec ＝ 编码_Ansi到Unicode (“所有文件”, ) ＋ 编码_Ansi到Unicode (“*.*”, ) ＋ { 0, 0 }
            .否则
                rgFilterSpec ＝ FilterSpec ＋ { 0, 0 }
            .如果结束
            pFilterSpec ＝ 取指针_字节集型 (rgFilterSpec)
            .循环判断首 ()
                dwSize ＝ lstrlenW (pFilterSpec)
                .如果真 (dwSize ≤ 0)
                    跳出循环 ()
                .如果真结束
                加入成员 (aryAddr, pFilterSpec)
                pFilterSpec ＝ pFilterSpec ＋ dwSize × 2 ＋ 2
            .循环判断尾 (dwSize ＞ 0)
            cFileTypes ＝ 取数组成员数 (aryAddr)
            .如果真 (cFileTypes ％ 2 ≠ 0)
                ' 格式不符合要求
                SafeRelease (pFileDialog)
                CoUninitialize ()
                返回 (0)
            .如果真结束
            cFileTypes ＝ cFileTypes ÷ 2
            hr ＝ CallObject (pFileDialog, #IFileDialog_SetFileTypes, cFileTypes, 取数据_通用型_数组 (aryAddr), , , , , , , )
            hr ＝ CallObject (pFileDialog, #IFileDialog_SetFileTypeIndex, FilterSpecIndex ＋ 1, , , , , , , , )
        .如果真结束
        .如果真 (SetTitle ≠ { })
            hr ＝ CallObject (pFileDialog, #IFileDialog_SetTitle, 取指针_字节集型 (SetTitle), , , , , , , , )
        .如果真结束
        .如果真 (InitialFolder ≠ { })
            pidl ＝ ILCreateFromPathW (InitialFolder)
            hr ＝ SHCreateShellItem (#NULL, #NULL, pidl, psi)
            .如果真 (hr ＝ #S_OK 且 psi ≠ #NULL)
                hr ＝ CallObject (pFileDialog, #IFileDialog_SetFolder, psi, , , , , , , , )
            .如果真结束
            .如果真 (pidl ≠ #NULL)
                ILFree (pidl)
            .如果真结束
            
        .如果真结束
        .如果真 (LOWORD (SetCodingOption) ＝ 1) ' TRUE
            hr ＝ CallObject (pFileDialog, #IUnknown_QueryInterface, 取指针_字节集型 (#IID_IFileDialogCustomize), 取指针整数_ (pIFileDialogCustomize), , , , , , , )
            .如果真 (hr ＝ #S_OK 且 pIFileDialogCustomize ≠ #NULL)
                szLabel ＝ 编码_Ansi到Unicode (“编码(&E):”, )
                hr ＝ CallObject (pIFileDialogCustomize, #IFileDialogCustomize_StartVisualGroup, 2, 取指针字节集_ (szLabel), , , , , , , )
                hr ＝ CallObject (pIFileDialogCustomize, #IFileDialogCustomize_AddComboBox, 1, , , , , , , , )
                aryLabel ＝ { “自动检测”, “ANSI”, “UTF-16 LE”, “UTF-16 BE”, “带有 BOM 的 UTF-8”, “UTF-8” }
                dwCount ＝ 取数组成员数 (aryLabel)
                .计次循环首 (dwCount, i)
                    szLabel ＝ 编码_Ansi到Unicode (aryLabel [i], )
                    hr ＝ CallObject (pIFileDialogCustomize, #IFileDialogCustomize_AddControlItem, 1, i － 1, 取指针字节集_ (szLabel), , , , , , )
                .计次循环尾 ()
                hr ＝ CallObject (pIFileDialogCustomize, #IFileDialogCustomize_EndVisualGroup, , , , , , , , , )
                hr ＝ CallObject (pIFileDialogCustomize, #IFileDialogCustomize_SetSelectedControlItem, 1, HIWORD (SetCodingOption), , , , , , , )
            .如果真结束
            
        .如果真结束
        hr ＝ CallObject (pFileDialog, #IModalWindow_Show, hWnd, , , , , , , , )
        .如果真 (psi ≠ #NULL)
            SafeRelease (psi)
        .如果真结束
        .如果 (isMultiSelect 且 IsSave ＝ 假)
            hr ＝ CallObject (pFileDialog, #IFileOpenDialog_GetResults, 取指针整数_ (pShellItem), , , , , , , , )
            .如果真 (hr ＝ #S_OK 且 pShellItem ≠ #NULL)
                hr ＝ CallObject (pShellItem, #IShellItemArray_GetCount, 取指针整数_ (dwNumItems), , , , , , , , )
                .计次循环首 (dwNumItems, i)
                    hr ＝ CallObject (pShellItem, #IShellItemArray_GetItemAt, i － 1, 取指针整数_ (pSelOneItem), , , , , , , )
                    .如果真 (pSelOneItem ＝ #NULL)
                        到循环尾 ()
                    .如果真结束
                    hr ＝ CallObject (pSelOneItem, #IShellItem_GetDisplayName, #SIGDN_FILESYSPATH, 取指针整数_ (pszPath), , , , , , , )
                    .如果真 (hr ＝ #S_OK 且 pszPath ≠ #NULL)
                        加入成员 (GetDisplayName, 指针_到字节集W (pszPath))
                        CoTaskMemFree (pszPath)
                    .如果真结束
                    SafeRelease (pSelOneItem)
                    pSelOneItem ＝ #NULL
                .计次循环尾 ()
                SafeRelease (pShellItem)
            .如果真结束
            
        .否则
            hr ＝ CallObject (pFileDialog, #IFileDialog_GetResult, 取指针整数_ (pShellItem), , , , , , , , )
            .如果真 (hr ＝ #S_OK 且 pShellItem ≠ #NULL)
                hr ＝ CallObject (pShellItem, #IShellItem_GetDisplayName, #SIGDN_FILESYSPATH, 取指针整数_ (pszPath), , , , , , , )
                .如果真 (hr ＝ #S_OK 且 pszPath ≠ #NULL)
                    加入成员 (GetDisplayName, 指针_到字节集W (pszPath))
                    CoTaskMemFree (pszPath)
                .如果真结束
                SafeRelease (pShellItem)
            .如果真结束
            
        .如果结束
        .如果真 (LOWORD (SetCodingOption) ＝ 1 且 pIFileDialogCustomize ≠ #NULL) ' TRUE
            hr ＝ CallObject (pIFileDialogCustomize, #IFileDialogCustomize_GetSelectedControlItem, 1, 取指针整数_ (GetCodingItem), , , , , , , )
            SafeRelease (pIFileDialogCustomize)
        .如果真结束
        SafeRelease (pFileDialog)
    .如果真结束
    CoUninitialize ()
    返回 (取数组成员数 (GetDisplayName))

.子程序 对话框_打开方式, 逻辑型, 公开, 显示“打开方式”对话框。
    .参数 父窗口的句柄, 整数型, 可空
    .参数 文件路径, 文本型

    返回 (对话框_打开方式W (父窗口的句柄, 编码_Ansi到Unicode (文件路径, )))

.子程序 对话框_打开方式W, 逻辑型, 公开, 显示“打开方式”对话框。
    .参数 父窗口的句柄, 整数型, 可空
    .参数 文件路径, 字节集
    .局部变量 oi, OPENASINFO
    .局部变量 hr, 整数型

    .如果真 (_WIN32_WINNT ＜ #_WIN32_WINNT_VISTA)
        输出调试文本 (#ERROR_NOTVERSION)
        返回 (假)
    .如果真结束
    oi.pcszFile ＝ 文件路径
    oi.oaifInFlags ＝ 位或 (#OAIF_ALLOW_REGISTRATION, #OAIF_EXEC)
    hr ＝ SHOpenWithDialog (父窗口的句柄, oi)
    返回 (hr ＝ #S_OK)

.版本 2

.程序集 集_屏幕亮度
.程序集变量 hDC, 整数型
.程序集变量 old, 短整数型, , "256,3"

.子程序 屏幕亮度_调整, , 公开, 调整屏幕亮度
    .参数 局_亮度, 整数型, , 亮度范围 1-100

    SetBrightness (局_亮度 － 50)

.子程序 SetBrightness
    .参数 intRGB, 整数型
    .局部变量 i, 整数型
    .局部变量 ii, 整数型
    .局部变量 new, 短整数型, , "256,3"

    .计次循环首 (256, i)
        .计次循环首 (3, ii)
            .判断开始 (intRGB ＜ 0)
                new [i] [ii] ＝ ConvToSignedValue (ConvToUnSignedValue (old [i] [ii]) × (100 － 取绝对值 (intRGB)) ÷ 100)
            .判断 (intRGB ＝ 0)
                new [i] [ii] ＝ old [i] [ii]
            .默认
                new [i] [ii] ＝ ConvToSignedValue (65535 － (65535 － ConvToUnSignedValue (old [i] [ii])) × (100 － intRGB) ÷ 100)
            .判断结束
            
        .计次循环尾 ()
    .计次循环尾 ()
    设置设备GammaRamp (hDC, new)

.子程序 ConvToSignedValue, 短整数型
    .参数 lngValue, 短整数型

    返回 (选择 (lngValue ≤ 32767, lngValue, lngValue － 65535))

.子程序 ConvToUnSignedValue, 整数型
    .参数 intValue, 短整数型

    返回 (选择 (intValue ≥ 0, intValue, intValue ＋ 65535))

.子程序 屏幕亮度_销毁, , 公开
    SetBrightness (0)
    ReleaseDC (GetDesktopWindow (), hDC)

.子程序 屏幕亮度_初始化, , 公开
    hDC ＝ GetDC (GetDesktopWindow ())
    获取设备GammaRamp (hDC, old)
    

.版本 2

.程序集 集_算术运算
.子程序 运算_求阶乘, 长整数型, 公开, 返回参数中给定数值的计算阶乘结果。
    .参数 阶乘数, 整数型, , 要求阶乘的数值
    .局部变量 计算结果, 长整数型
    .局部变量 计数, 整数型

    计算结果 ＝ 1
    .计次循环首 (阶乘数, 计数)
        计算结果 ＝ 计算结果 × 计数
    .计次循环尾 ()
    返回 (计算结果) ' 将计算结果返回给调用本程序的命令行
    

.子程序 运算_二分查找, 整数型, 公开
    .参数 数组, 文本型, 数组
    .参数 待查, 文本型
    .参数 类型, 整数型
    .参数 区分大小写, 逻辑型
    .局部变量 位置, 整数型
    .局部变量 数组总数, 整数型
    .局部变量 对分, 整数型
    .局部变量 数值A, 双精度小数型
    .局部变量 数值B, 双精度小数型
    .局部变量 文本, 文本型

    位置 ＝ 1
    数组总数 ＝ 取数组成员数 (数组)
    .如果真 (数组总数 ＝ 0)
        返回 (1)
    .如果真结束
    .判断开始 (类型 ＝ 0)
        数值A ＝ 到数值 (待查)
        .如果真 (数值A ≥ 到数值 (数组 [数组总数]))
            返回 (数组总数 ＋ 1)
        .如果真结束
        .如果真 (数值A ≤ 到数值 (数组 [1]))
            返回 (1)
        .如果真结束
        
        .判断循环首 (位置 ＜ 数组总数 － 1)
            对分 ＝ (位置 ＋ 数组总数) ＼ 2
            数值B ＝ 到数值 (数组 [对分])
            .如果真 (数值A ＝ 数值B)
                位置 ＝ 对分
                跳出循环 ()
            .如果真结束
            
            .如果 (数值A ＜ 数值B)
                数组总数 ＝ 对分
            .否则
                位置 ＝ 对分
            .如果结束
            
        .判断循环尾 ()
    .判断 (类型 ＝ 1)
        .如果真 (文本比较 (待查, 数组 [数组总数], 区分大小写) ≥ 0)
            返回 (数组总数 ＋ 1)
        .如果真结束
        .如果真 (文本比较 (待查, 数组 [1], 区分大小写) ≤ 0)
            返回 (1)
        .如果真结束
        .判断循环首 (位置 ＜ 数组总数 － 1)
            对分 ＝ (位置 ＋ 数组总数) ＼ 2
            .如果真 (文本比较 (待查, 数组 [对分], 区分大小写) ＝ 0)
                位置 ＝ 对分
                跳出循环 ()
            .如果真结束
            .如果 (文本比较 (待查, 数组 [对分], 区分大小写) ＜ 0)
                数组总数 ＝ 对分
            .否则
                位置 ＝ 对分
            .如果结束
            
        .判断循环尾 ()
        
    .判断 (类型 ＝ 2)
        数值A ＝ 取字节集数据 (到字节集 (到时间 (待查)), #双精度小数型)
        .如果真 (数值A ≥ 取字节集数据 (到字节集 (到时间 (数组 [数组总数])), #双精度小数型))
            返回 (数组总数 ＋ 1)
        .如果真结束
        .如果真 (数值A ≤ 取字节集数据 (到字节集 (到时间 (数组 [1])), #双精度小数型))
            返回 (1)
        .如果真结束
        .判断循环首 (位置 ＜ 数组总数 － 1)
            对分 ＝ (位置 ＋ 数组总数) ＼ 2
            数值B ＝ 取字节集数据 (到字节集 (到时间 (数组 [对分])), #双精度小数型)
            .如果真 (数值A ＝ 数值B)
                位置 ＝ 对分
                跳出循环 ()
            .如果真结束
            .如果 (数值A ＜ 数值B)
                数组总数 ＝ 对分
            .否则
                位置 ＝ 对分
            .如果结束
            
        .判断循环尾 ()
    .默认
        
    .判断结束
    返回 (位置 ＋ 1)

.子程序 运算_函数计算, 文本型, 公开, 求正弦、余弦、正切、余切
    .参数 Text, 文本型
    .参数 单位, 逻辑型, , 真为弧度制，假为角度制
    .局部变量 TempText, 文本型
    .局部变量 FText, 文本型, , , 寻找值
    .局部变量 FNum, 整数型, , , 寻找值的长度
    .局部变量 ZText, 文本型, , , 函数括号内文本
    .局部变量 RetText, 文本型, , , 函数括号内计算结果
    .局部变量 i, 整数型
    .局部变量 Find, 整数型, , , 寻找到的位置
    .局部变量 YFind, 整数型, , , 寻找到右括号的位置

    TempText ＝ Text
    .计次循环首 (4, i)
        FText ＝ 多项选择 (i, “sin(”, “cos(”, “tg(”, “ctg(”)
        FNum ＝ 多项选择 (i, 4, 4, 3, 4)
        Find ＝ 寻找文本 (TempText, FText, , 假)
        .判断循环首 (Find ≠ -1)
            YFind ＝ 寻找文本 (TempText, “)”, Find, 假) ' 寻找右括号
            .如果真 (YFind ≠ -1)
                ZText ＝ 取文本中间 (TempText, Find ＋ FNum, YFind － Find － FNum)
                .判断开始 (ZText ＝ “”) ' 括号内无文本
                    TempText ＝ 文本替换 (TempText, Find, FNum ＋ 1, )
                .默认
                    RetText ＝ 运算_括号计算 (ZText)
                    .如果真 (RetText ＝ “”) ' 失败返回空文本
                        返回 (“”)
                    .如果真结束
                    .判断开始 (i ＝ 1) ' 正弦
                        RetText ＝ 到文本 (求正弦 (选择 (单位, 到数值 (RetText), 到数值 (RetText) × #pi ÷ 180)))
                    .判断 (i ＝ 2) ' 余弦
                        RetText ＝ 到文本 (求余弦 (选择 (单位, 到数值 (RetText), 到数值 (RetText) × #pi ÷ 180)))
                    .判断 (i ＝ 3) ' 正切
                        RetText ＝ 到文本 (求正切 (选择 (单位, 到数值 (RetText), 到数值 (RetText) × #pi ÷ 180)))
                    .默认
                        RetText ＝ 到文本 (1 ÷ 求正切 (选择 (单位, 到数值 (RetText), 到数值 (RetText) × #pi ÷ 180))) ' 余切
                    .判断结束
                    .如果真 (是否运算正确 (到数值 (RetText)) ＝ 假)
                        返回 (“”)
                    .如果真结束
                    TempText ＝ 文本替换 (TempText, Find, 取文本长度 (ZText) ＋ FNum ＋ 1, RetText)
                .判断结束
                
            .如果真结束
            Find ＝ 寻找文本 (TempText, FText, , 假)
        .判断循环尾 ()
    .计次循环尾 ()
    返回 (运算_括号计算 (TempText))

.子程序 运算_括号计算, 文本型, 公开
    .参数 Text, 文本型
    .局部变量 i, 整数型
    .局部变量 Zk, 整数型, , "0", 左括号位置数组
    .局部变量 ZkNum, 整数型, , , Zk成员数量
    .局部变量 SigText, 文本型, , , 单个文本
    .局部变量 Asc, 整数型, , , 单个文本的Asc码
    .局部变量 SwText, 文本型, , , 括号内文本
    .局部变量 SwReText, 文本型, , , 括号内计算后文本
    .局部变量 TempText, 文本型, , , 替换后的结果

    TempText ＝ Text
    i ＝ 1
    .判断循环首 (i ≤ 取文本长度 (TempText))
        SigText ＝ 取文本中间 (TempText, i, 1)
        .判断开始 (SigText ＝ “(”)
            加入成员 (Zk, i)
            i ＝ i ＋ 1
        .判断 (SigText ＝ “)”)
            ZkNum ＝ 取数组成员数 (Zk)
            .如果 (ZkNum ＞ 0) ' 是否存在左括号
                SwText ＝ 取文本中间 (TempText, Zk [ZkNum] ＋ 1, i － Zk [ZkNum] － 1) ' 取出括号内文本
                SwReText ＝ 运算_内部计算 (SwText) ' 计算括号内文本
                .如果真 (SwReText ＝ “”) ' 失败返回空文本
                    返回 (“”)
                .如果真结束
                TempText ＝ 文本替换 (TempText, Zk [ZkNum], 取文本长度 (“(” ＋ SwText ＋ “)”), SwReText)
                i ＝ Zk [ZkNum] ＋ 1
                删除成员 (Zk, ZkNum, )
            .否则
                TempText ＝ 文本替换 (TempText, i, 1, ) ' 去掉多余右括号
            .如果结束
            
        .判断 (Asc ＝ 92)
            TempText ＝ 文本替换 (TempText, i, 1, “\”)
            i ＝ i ＋ 1
        .默认
            Asc ＝ 取代码 (SigText, )
            .判断开始 (Asc ＜ 46 或 Asc ＞ 57 且 Asc ≠ 42 且 Asc ≠ 43 且 Asc ≠ 45 且 Asc ≠ 92 且 Asc ≠ 94) ' 去掉非法字符
                TempText ＝ 文本替换 (TempText, i, 1, )
            .默认
                i ＝ i ＋ 1
            .判断结束
            
        .判断结束
        
    .判断循环尾 ()
    ZkNum ＝ 取数组成员数 (Zk)
    .如果真 (ZkNum ＞ 0) ' 去掉多余左括号
        .计次循环首 (ZkNum, i)
            TempText ＝ 文本替换 (TempText, Zk [ZkNum － i ＋ 1], 1, ) ' 从最后一个开始替换
        .计次循环尾 ()
    .如果真结束
    返回 (运算_内部计算 (TempText))

.子程序 运算_内部计算, 文本型, 公开, 加减乘除及乘方运算，失败返回空文本
    .参数 Text, 文本型
    .局部变量 i, 整数型
    .局部变量 Sign, 整数型, , "0", 操作符号位置
    .局部变量 SiNum, 整数型, , , Sign的数组成员数量
    .局部变量 SigText, 文本型, , , 单个文本
    .局部变量 TempText, 文本型
    .局部变量 Js, 文本型, , "2", 计算的左边和右边
    .局部变量 Result, 文本型, , , 单符号计算结果
    .局部变量 len, 整数型

    TempText ＝ Text
    .如果真 (寻找文本 (TempText, “^”, , 假) ≠ -1)
        .判断循环首 (i ≤ 取文本长度 (TempText)) ' 计算乘方
            SigText ＝ 取文本中间 (TempText, i, 1)
            .判断开始 (SigText ＝ “+” 或 (SigText ＝ “-” 且 i ＞ 1) 或 SigText ＝ “*” 或 SigText ＝ “/”)
                加入成员 (Sign, i)
                i ＝ i ＋ 1
            .判断 (SigText ＝ “^”)
                SiNum ＝ 取数组成员数 (Sign)
                .判断开始 (SiNum ＞ 0)
                    Js [1] ＝ 取文本中间 (TempText, Sign [SiNum] ＋ 1, i － Sign [SiNum] － 1)
                    Js [2] ＝ 取文本右边 (TempText, 取文本长度 (TempText) － i)
                    Js [2] ＝ 到文本 (到数值 (Js [2])) ' 去掉后面的操作符
                    Result ＝ 到文本 (求次方 (到数值 (Js [1]), 到数值 (Js [2])))
                    .判断循环首 (取文本中间 (TempText, i ＋ 取文本长度 (Js [2]) ＋ 1 ＋ len, 1) ＝ “0”)
                        len ＝ len ＋ 1
                    .判断循环尾 ()
                    TempText ＝ 文本替换 (TempText, Sign [SiNum] ＋ 1, 取文本长度 (Js [1] ＋ “^” ＋ Js [2]) ＋ len, Result)
                    i ＝ Sign [SiNum] ＋ 1
                .默认
                    Js [1] ＝ 取文本左边 (TempText, i － 1)
                    Js [2] ＝ 取文本右边 (TempText, 取文本长度 (TempText) － i)
                    Js [2] ＝ 到文本 (到数值 (Js [2])) ' 去掉后面的操作符
                    Result ＝ 到文本 (求次方 (到数值 (Js [1]), 到数值 (Js [2])))
                    .判断循环首 (取文本中间 (TempText, i ＋ 取文本长度 (Js [2]) ＋ 1 ＋ len, 1) ＝ “0”)
                        len ＝ len ＋ 1
                    .判断循环尾 ()
                    TempText ＝ 文本替换 (TempText, 1, 取文本长度 (Js [1] ＋ “^” ＋ Js [2]) ＋ len, Result)
                    i ＝ 1
                .判断结束
                
            .默认
                i ＝ i ＋ 1
            .判断结束
            
        .判断循环尾 ()
    .如果真结束
    i ＝ 1
    清除数组 (Sign)
    .如果真 (寻找文本 (TempText, “*”, , 假) ≠ -1 或 寻找文本 (TempText, “/”, , 假) ≠ -1)
        .判断循环首 (i ≤ 取文本长度 (TempText)) ' 计算乘除
            SigText ＝ 取文本中间 (TempText, i, 1)
            .判断开始 (SigText ＝ “+” 或 (SigText ＝ “-” 且 i ＞ 1))
                加入成员 (Sign, i)
                i ＝ i ＋ 1
            .判断 (SigText ＝ “*”)
                SiNum ＝ 取数组成员数 (Sign)
                .判断开始 (SiNum ＞ 0)
                    Js [1] ＝ 取文本中间 (TempText, Sign [SiNum] ＋ 1, i － Sign [SiNum] － 1)
                    Js [2] ＝ 取文本右边 (TempText, 取文本长度 (TempText) － i)
                    Js [2] ＝ 到文本 (到数值 (Js [2])) ' 去掉后面的操作符
                    Result ＝ 到文本 (到数值 (Js [1]) × 到数值 (Js [2]))
                    .判断循环首 (取文本中间 (TempText, i ＋ 取文本长度 (Js [2]) ＋ 1 ＋ len, 1) ＝ “0”)
                        len ＝ len ＋ 1
                    .判断循环尾 ()
                    TempText ＝ 文本替换 (TempText, Sign [SiNum] ＋ 1, 取文本长度 (Js [1] ＋ “*” ＋ Js [2]) ＋ len, Result)
                    i ＝ Sign [SiNum] ＋ 1
                .默认
                    Js [1] ＝ 取文本左边 (TempText, i － 1)
                    Js [2] ＝ 取文本右边 (TempText, 取文本长度 (TempText) － i)
                    Js [2] ＝ 到文本 (到数值 (Js [2])) ' 去掉后面的操作符
                    Result ＝ 到文本 (到数值 (Js [1]) × 到数值 (Js [2]))
                    .判断循环首 (取文本中间 (TempText, i ＋ 取文本长度 (Js [2]) ＋ 1 ＋ len, 1) ＝ “0”)
                        len ＝ len ＋ 1
                    .判断循环尾 ()
                    TempText ＝ 文本替换 (TempText, 1, 取文本长度 (Js [1] ＋ “*” ＋ Js [2]) ＋ len, Result)
                    i ＝ 1
                .判断结束
                
            .判断 (SigText ＝ “/”)
                SiNum ＝ 取数组成员数 (Sign)
                .判断开始 (SiNum ＞ 0)
                    Js [1] ＝ 取文本中间 (TempText, Sign [SiNum] ＋ 1, i － Sign [SiNum] － 1)
                    Js [2] ＝ 取文本右边 (TempText, 取文本长度 (TempText) － i)
                    Js [2] ＝ 到文本 (到数值 (Js [2])) ' 去掉后面的操作符
                    .如果真 (到数值 (Js [2]) ＝ 0) ' 除数不能为0
                        返回 (“”)
                    .如果真结束
                    .如果 (到数值 (Js [1]) ＝ 0) ' 避免出现被除数不能为0
                        Result ＝ “0”
                    .否则
                        Result ＝ 到文本 (到数值 (Js [1]) ÷ 到数值 (Js [2]))
                    .如果结束
                    .判断循环首 (取文本中间 (TempText, i ＋ 取文本长度 (Js [2]) ＋ 1 ＋ len, 1) ＝ “0”)
                        len ＝ len ＋ 1
                    .判断循环尾 ()
                    TempText ＝ 文本替换 (TempText, Sign [SiNum] ＋ 1, 取文本长度 (Js [1] ＋ “/” ＋ Js [2]) ＋ len, Result)
                    i ＝ Sign [SiNum] ＋ 1
                .默认
                    Js [1] ＝ 取文本左边 (TempText, i － 1)
                    Js [2] ＝ 取文本右边 (TempText, 取文本长度 (TempText) － i)
                    Js [2] ＝ 到文本 (到数值 (Js [2])) ' 去掉后面的操作符
                    .如果真 (到数值 (Js [2]) ＝ 0) ' 被除数不能为0
                        返回 (“”)
                    .如果真结束
                    .如果 (到数值 (Js [1]) ＝ 0) ' 避免出现被除数不能为0
                        Result ＝ “0”
                    .否则
                        Result ＝ 到文本 (到数值 (Js [1]) ÷ 到数值 (Js [2]))
                    .如果结束
                    .判断循环首 (取文本中间 (TempText, i ＋ 取文本长度 (Js [2]) ＋ 1 ＋ len, 1) ＝ “0”)
                        len ＝ len ＋ 1
                    .判断循环尾 ()
                    TempText ＝ 文本替换 (TempText, 1, 取文本长度 (Js [1] ＋ “/” ＋ Js [2]) ＋ len, Result)
                    i ＝ 1
                .判断结束
                
            .默认
                i ＝ i ＋ 1
            .判断结束
            
        .判断循环尾 ()
    .如果真结束
    i ＝ 1
    .判断循环首 (i ≤ 取文本长度 (TempText)) ' 计算加减
        SigText ＝ 取文本中间 (TempText, i, 1)
        .判断开始 (SigText ＝ “+”)
            Js [1] ＝ 取文本左边 (TempText, i － 1)
            Js [2] ＝ 取文本右边 (TempText, 取文本长度 (TempText) － i)
            Js [2] ＝ 到文本 (到数值 (Js [2])) ' 去掉后面的操作符
            Result ＝ 到文本 (到数值 (Js [1]) ＋ 到数值 (Js [2]))
            .判断循环首 (取文本中间 (TempText, i ＋ 取文本长度 (Js [2]) ＋ 1 ＋ len, 1) ＝ “0”)
                len ＝ len ＋ 1
            .判断循环尾 ()
            TempText ＝ 文本替换 (TempText, 1, 取文本长度 (Js [1] ＋ “+” ＋ Js [2]) ＋ len, Result)
            i ＝ 1
        .判断 (SigText ＝ “-” 且 i ＞ 1)
            Js [1] ＝ 取文本左边 (TempText, i － 1)
            Js [2] ＝ 取文本右边 (TempText, 取文本长度 (TempText) － i)
            Js [2] ＝ 到文本 (到数值 (Js [2])) ' 去掉后面的操作符
            Result ＝ 到文本 (到数值 (Js [1]) － 到数值 (Js [2]))
            .判断循环首 (取文本中间 (TempText, i ＋ 取文本长度 (Js [2]) ＋ 1 ＋ len, 1) ＝ “0”)
                len ＝ len ＋ 1
            .判断循环尾 ()
            TempText ＝ 文本替换 (TempText, 1, 取文本长度 (Js [1] ＋ “-” ＋ Js [2]) ＋ len, Result)
            i ＝ 1
        .默认
            i ＝ i ＋ 1
        .判断结束
        
    .判断循环尾 ()
    返回 (TempText)

.子程序 运算_取圆周率, 文本型, 公开, 返回小数最大1000位圆周率,实际上有10位计算就已很精确了
    .参数 位数, 整数型, , 返回圆周率小数点后的位数
    .局部变量 行1, 文本型
    .局部变量 行2, 文本型
    .局部变量 行3, 文本型
    .局部变量 行4, 文本型
    .局部变量 行5, 文本型
    .局部变量 行6, 文本型
    .局部变量 行7, 文本型
    .局部变量 行8, 文本型
    .局部变量 行9, 文本型
    .局部变量 行10, 文本型

    行1 ＝ “1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679”
    行2 ＝ “8214808651328230664709384460955058223172535940812848111745028410270193852110555964462294895493038196”
    行3 ＝ “4428810975665933446128475648233786783165271201909145648566923460348610454326648213393607260249141273”
    行4 ＝ “7245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094”
    行5 ＝ “3305727036575959195309218611738193261179310511854807446237996274956735188575272489122793818301194912”
    行6 ＝ “9833673362440656643086021394946395224737190702179860943702770539217176293176752384674818467669405132”
    行7 ＝ “0005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235”
    行8 ＝ “4201995611212902196086403441815981362977477130996051870721134999999837297804995105973173281609631859”
    行9 ＝ “5024459455346908302642522308253344685035261931188171010003137838752886587533208381420617177669147303”
    行10 ＝ “5982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989”
    返回 (取文本左边 (“3.” ＋ 行1 ＋ 行2 ＋ 行3 ＋ 行4 ＋ 行5 ＋ 行6 ＋ 行7 ＋ 行8 ＋ 行9 ＋ 行10, 位数 ＋ 2))

.子程序 运算_求反正弦, 双精度小数型, 公开, 返回弧度值
    .参数 正弦值, 双精度小数型, , -1到1，否则返回0

    .如果真 (正弦值 ＜ -1 或 正弦值 ＞ 1)
        返回 (0)
    .如果真结束
    返回 (求反正切 (正弦值 ÷ 求平方根 (1 － 正弦值 × 正弦值)))

.子程序 运算_求反余弦, 双精度小数型, 公开, 返回弧度值
    .参数 余弦值, 双精度小数型, , -1到1，否则返回0

    .如果真 (余弦值 ＞ 1 或 余弦值 ＜ -1)
        返回 (0)
    .如果真结束
    返回 (#pi ÷ 2 － 运算_求反正弦 (余弦值))

.子程序 运算_颜色转换, 文本型, 公开, 将10进制的颜色值转到16进制的颜色值；   还原调用 网页_取十进制颜色值
    .参数 待转换颜色值, 整数型
    .局部变量 字节集, 字节集
    .局部变量 十六进制颜色, 文本型

    字节集 ＝ 到字节集 (待转换颜色值)
    十六进制颜色 ＝ 取文本右边 (“00” ＋ 取十六进制文本 (字节集 [1]), 2)
    十六进制颜色 ＝ 十六进制颜色 ＋ 取文本右边 (“00” ＋ 取十六进制文本 (字节集 [2]), 2)
    十六进制颜色 ＝ 十六进制颜色 ＋ 取文本右边 (“00” ＋ 取十六进制文本 (字节集 [3]), 2)
    返回 (十六进制颜色)

.子程序 运算_表达式计算, 文本型, 公开, 成功返回计算后的文本结果，失败返回空文本
    .参数 Text, 文本型
    .参数 单位, 逻辑型, , 函数计算时使用，真为弧度制，假为角度制
    .局部变量 TempText, 文本型

    TempText ＝ 运算_函数计算 (Text, 单位)
    返回 (运算_括号计算 (TempText))

.子程序 运算_象素到厘米, 双精度小数型, 公开
    .参数 象素值
    .局部变量 厘米值, 双精度小数型

    厘米值 ＝ 象素值 ÷ 28.346
    返回 (厘米值)

.子程序 运算_厘米到象素, 双精度小数型, 公开
    .参数 厘米值, 双精度小数型
    .局部变量 象素值, 双精度小数型

    象素值 ＝ 厘米值 × 28.346
    返回 (象素值)

.子程序 运算_求直线距离, 双精度小数型, 公开, 返回两个点之间的直线距离,可以返回象素,也可以返回厘米
    .参数 水平象素1, 整数型
    .参数 垂直象素1, 整数型
    .参数 水平象素2, 整数型
    .参数 垂直象素2, 整数型
    .参数 类型, 整数型, 可空, 1为返回象素,2为返回厘米
    .局部变量 距离象素, 整数型
    .局部变量 距离厘米, 小数型

    距离象素 ＝ 求平方根 (求次方 (水平象素2 － 水平象素1, 2) ＋ 求次方 (垂直象素2 － 垂直象素1, 2))
    .如果 (是否为空 (类型) ＝ 真 或 类型 ＝ 1)
        返回 (距离象素)
    .否则
        距离厘米 ＝ 距离象素 ÷ 28
        返回 (距离厘米)
    .如果结束
    返回 (-1)

.子程序 运算_四舍六入五留双, 双精度小数型, 公开
    .参数 欲修约值, 双精度小数型
    .参数 保留位数, 整数型

    .如果真 (欲修约值 × 求次方 (10, 保留位数) － 取整 (欲修约值 × 求次方 (10, 保留位数)) ≠ 0.5)
        返回 (四舍五入 (欲修约值, 保留位数))
    .如果真结束
    .如果真 (欲修约值 × 求次方 (10, 保留位数) － 取整 (欲修约值 × 求次方 (10, 保留位数)) ＝ 0.5)
        .如果真 (取整 (欲修约值 × 求次方 (10, 保留位数)) ％ 2 ＝ 0)
            返回 (四舍五入 (欲修约值 － 求次方 (10, 保留位数 × -1), 保留位数))
        .如果真结束
        .如果真 (取整 (欲修约值 × 求次方 (10, 保留位数)) ％ 2 ＝ 1)
            返回 (四舍五入 (欲修约值, 保留位数))
        .如果真结束
        
    .如果真结束
    返回 (0)

.子程序 运算_大小端转换, 整数型, 公开
    .参数 需要转换的值, 整数型
    .局部变量 a, 整数型
    .局部变量 b, 整数型
    .局部变量 c, 整数型
    .局部变量 d, 整数型

    a ＝ 位与 (需要转换的值, 255)
    a ＝ Int_Shl (a, 24)
    
    b ＝ 位与 (需要转换的值, 65280)
    b ＝ Int_Shl (b, 8)
    
    c ＝ 位与 (需要转换的值, 16711680)
    c ＝ Int_Shr (c, 8)
    
    d ＝ 位与 (需要转换的值, 4278190080)
    d ＝ Int_Shr (d, 24)
    返回 (位或 (a, b, c, d))

.子程序 Int_Shr, 整数型, , 无符号右移
    .参数 int, 整数型
    .参数 shiftCount, 字节型

    置入代码 ({ 139, 69, 8, 138, 77, 12, 131, 225, 31, 211, 232, 201, 194, 8, 0 })
    返回 (0)

.子程序 Int_Shl, 整数型, , 无符号左移
    .参数 int, 整数型
    .参数 shiftCount, 字节型

    置入代码 ({ 139, 69, 8, 138, 77, 12, 131, 225, 31, 211, 224, 201, 194, 8, 0 })
    返回 (0)

.版本 2

.程序集 集_系统
.程序集变量 集_任务管理器文件号, 整数型
.程序集变量 liOldSystemTime, 双精度小数型, , , 系统_取CPU占用率
.程序集变量 liOldIdleTime, 双精度小数型, , , 系统_取CPU占用率
.程序集变量 Status_域, 整数型


.程序集变量 m_OsVersion, 整数型
.程序集变量 m_Isx64, 逻辑型
.程序集变量 m_nDataOffset, 整数型
.程序集变量 m_nStrOffset, 整数型

.程序集变量 hDisplayInf, 整数型, , "0"

.程序集变量 m_dwMinor, 整数型

.子程序 系统_取计算机语言, 文本型, 公开, 返回计算机语言相关信息
    .局部变量 局_标识, 整数型
    .局部变量 局_数组, 文本型, , "0"
    .局部变量 i, 整数型
    .局部变量 局_记录, 文本型, , "0"

    ' 目前处于活动状态的OEM代码页的标识符。针对一种特定的语言，可能存在多个代码页。以下是可用代码页列表
    ' 代码页标识符：https://docs.microsoft.com/zh-cn/windows/desktop/Intl/code-page-identifiers
    局_标识 ＝ GetOEMCP ()
    局_数组 ＝ 分割文本 (#常量_代码页标识符, #换行符, )
    .计次循环首 (取数组成员数 (局_数组), i)
        清除数组 (局_记录)
        局_记录 ＝ 分割文本 (局_数组 [i], “|”, )
        .如果真 (取数组成员数 (局_记录) ＝ 3)
            .如果真 (到整数 (局_记录 [1]) ＝ 局_标识)
                返回 (局_记录 [1] ＋ “：” ＋ 局_记录 [3])
            .如果真结束
            
        .如果真结束
        
    .计次循环尾 ()
    返回 (“失败”)

.子程序 系统_取系统信息, 文本型, 公开
    .局部变量 局_系统信息, 文本型

    局_系统信息 ＝ 系统_取DOS执行结果 (“systeminfo”)
    返回 (局_系统信息)

.子程序 系统_显示器操作, , 公开, -1 打开显示  1低电状态  2关闭显示器
    .参数 参_操作类型, 整数型

    SendMessageA (65535, 274, 61808, 参_操作类型)

.子程序 系统_取系统信息1, 文本型, 公开
    .局部变量 局_对象, 对象
    .局部变量 局_系统信息, 文本型

    CoInitialize (0)
    局_对象.创建 (“Scriptcontrol”, )
    局_对象.写属性 (“Language”, “VBScript”)
    局_对象.通用方法 (“AddCode”, #Code)
    局_系统信息 ＝ 局_对象.文本方法 (“Run”, “GetSysInfo”)
    局_对象.清除 ()
    CoUninitialize ()
    返回 (局_系统信息)

.子程序 系统_磁盘是否支持稀疏文件, 逻辑型, 公开
    .参数 参_盘符, 文本型
    .局部变量 局_文件系统标识, 整数型
    .局部变量 局_卷标名, 文本型
    .局部变量 局_序列号, 整数型
    .局部变量 局_最大文件名长度, 整数型
    .局部变量 局_文件系统名, 文本型
    .局部变量 局_返回值, 逻辑型

    局_返回值 ＝ GetVolumeInformationA (取文本左边 (参_盘符, 3), 局_卷标名, 取文本长度 (局_卷标名), 局_序列号, 局_最大文件名长度, 局_文件系统标识, 局_文件系统名, 取文本长度 (局_文件系统名))
    .如果真 (局_返回值 ＝ 假)
        返回 (假)
    .如果真结束
    .如果 (位与 (局_文件系统标识, #FILE_SUPPORTS_SPARSE_FILES) ＝ 64)
        返回 (真)
    .否则
        返回 (假)
    .如果结束
    

.子程序 系统_取网卡信息_彗星版, 整数型, 公开, 获取网卡的IP地址、MAC等信息。By:邓学彬(泪闯天涯)
    .参数 网卡信息数组, 精易_网卡信息_彗星, 参考 数组
    .局部变量 MapList, NetworkCardMapName, 数组, "0"
    .局部变量 AdapterInfo, IP_ADAPTER_INFO_彗星
    .局部变量 BufBin, 字节集
    .局部变量 pAda, 整数型
    .局部变量 nSize, 整数型
    .局部变量 nBufLen, 整数型
    .局部变量 nResult, 整数型
    .局部变量 pAddr, 整数型
    .局部变量 ipAddr, IP_ADDR_STRING
    .局部变量 strTmp, 文本型
    .局部变量 strMac, 文本型
    .局部变量 Card, 精易_网卡信息_彗星
    .局部变量 i, 整数型
    .局部变量 局_mac, 文本型
    .局部变量 局_总数, 整数型

    清除数组 (网卡信息数组)
    GetAdapterFriendlyName (MapList)
    ' //--------------------------------------------------
    nResult ＝ GetAdaptersInfo (0, nBufLen)
    .如果真 (nResult ＝ #ERROR_BUFFER_OVERFLOW)
        BufBin ＝ 取空白字节集 (nBufLen)
        pAda ＝ GetPtr_Bin (BufBin, BufBin, 0)
        nResult ＝ GetAdaptersInfo (pAda, nBufLen)
        .如果真 (#ERROR_SUCCESS ＝ nResult)
            nSize ＝ LocalSize_IP_ADAPTER_INFO (AdapterInfo)
            .判断循环首 (pAda ≠ 0)
                CopyMemory_P2IP_ADAPTER_INFO (AdapterInfo, pAda, nSize)
                Card.网卡名称 ＝ 到文本 (AdapterInfo.AdapterName) ' //网卡名称
                Card.网卡描述 ＝ 到文本 (AdapterInfo.Description) ' //网卡描述
                Card.网卡类型n ＝ AdapterInfo.Type
                Card.网卡类型 ＝ GetAdapterInfoType (AdapterInfo.Type) ' //网卡类型
                
                ' //取出MAC地址
                Card.MAC地址 ＝ “”
                局_总数 ＝ AdapterInfo.AddressLength
                .计次循环首 (局_总数, i)
                    ' .如果真 (i ＞ 1)
                        ' Card.MAC地址 ＝ Card.MAC地址 ＋ “-”
                    ' .如果真结束
                    ' .如果真 (AdapterInfo.Address [i] ≤ 16)
                        ' Card.MAC地址 ＝ Card.MAC地址 ＋ “0”
                    ' .如果真结束
                    ' Card.MAC地址 ＝ Card.MAC地址 ＋ 取十六进制文本 (AdapterInfo.Address [i])
                    局_mac ＝ 取十六进制文本 (AdapterInfo.Address [i])
                    .如果 (i ≠ 局_总数)
                        Card.MAC地址 ＝ Card.MAC地址 ＋ 选择 (取文本长度 (局_mac) ＝ 1, “0” ＋ 局_mac, 局_mac) ＋ “-”
                    .否则
                        Card.MAC地址 ＝ Card.MAC地址 ＋ 选择 (取文本长度 (局_mac) ＝ 1, “0” ＋ 局_mac, 局_mac)
                    .如果结束
                    
                .计次循环尾 ()
                
                ' //取出IP地址和子网掩码
                ipAddr ＝ AdapterInfo.IpAddressList
                .循环判断首 ()
                    Card.IP地址 ＝ 到文本 (ipAddr.IpAddress)
                    Card.子网掩码 ＝ 到文本 (ipAddr.IpMask)
                    跳出循环 () ' //只取一个
                    
                    pAddr ＝ ipAddr.Next
                    .如果真 (pAddr ≠ 0)
                        CopyMemory_IP_ADDR_STRING (ipAddr, pAddr, LocalSize_IP_ADDR_STRING (ipAddr))
                    .如果真结束
                    
                .循环判断尾 (pAddr ≠ 0)
                
                ' //取出
                ipAddr ＝ AdapterInfo.GatewayList
                .循环判断首 ()
                    Card.网关地址 ＝ 到文本 (ipAddr.IpAddress)
                    跳出循环 () ' //只取一个
                    
                    pAddr ＝ ipAddr.Next
                    .如果真 (pAddr ≠ 0)
                        CopyMemory_IP_ADDR_STRING (ipAddr, pAddr, LocalSize_IP_ADDR_STRING (ipAddr))
                        
                    .如果真结束
                    
                .循环判断尾 (pAddr ≠ 0)
                
                ' //取出DNS服务器
                GetDnsServer (AdapterInfo.Index, Card.首选DNS服务器, Card.备用DNS服务器)
                ' //--------------------------------------------------
                .计次循环首 (取数组成员数 (MapList), i)
                    .如果真 (MapList [i].strGUID ＝ Card.网卡名称)
                        Card.连接名称 ＝ MapList [i].strFriendName
                        跳出循环 ()
                    .如果真结束
                    
                .计次循环尾 ()
                ' //--------------------------------------------------
                Card.是否启用DHCP ＝ AdapterInfo.DhcpEnabled ＝ 1
                加入成员 (网卡信息数组, Card)
                pAda ＝ AdapterInfo.Next
            .判断循环尾 ()
        .如果真结束
        
    .如果真结束
    ' //--------------------------------------------------
    返回 (取数组成员数 (网卡信息数组))

.子程序 GetAdapterFriendlyName, , , 通过mprapi库获取连接名称
    .参数 MapList, NetworkCardMapName, 数组
    .局部变量 hMprConfig
    .局部变量 dwBufferSize
    .局部变量 BufferBin, 字节集
    .局部变量 plfTable, 整数型
    .局部变量 FaceInfo, IP_INTERFACE_INFO
    .局部变量 Adapter, IP_ADAPTER_INDEX_MAP, , "0"

    .局部变量 szMapName, 字节集
    .局部变量 szFriendName, 字节集
    .局部变量 nSize, 整数型
    .局部变量 dwRet
    .局部变量 i, 整数型
    .局部变量 nPos, 整数型

    清除数组 (MapList)
    ' //-----------------------------------------------------------
    dwRet ＝ MprConfigServerConnect (0, hMprConfig) ' //获得句柄
    dwRet ＝ GetInterfaceInfo (0, dwBufferSize) ' //获得接口信息表大小
    
    .如果真 (dwRet ＝ #ERROR_INSUFFICIENT_BUFFER)
        BufferBin ＝ 取空白字节集 (dwBufferSize)
        plfTable ＝ GetPtr_Bin (BufferBin, BufferBin, 0)
        dwRet ＝ GetInterfaceInfo (plfTable, dwBufferSize) ' //获得接口信息
        
        nSize ＝ LocalSize_IP_INTERFACE_INFO (FaceInfo)
        CopyMemory_P2IP_INTERFACE_INFO (FaceInfo, plfTable, nSize)
        .如果真 (FaceInfo.NumAdapters ＞ 0)
            重定义数组 (Adapter, 假, FaceInfo.NumAdapters)
            nSize ＝ FaceInfo.NumAdapters × LocalSize_IP_ADAPTER_INDEX_MAP (Adapter [1])
            .如果真 (nSize ＞ dwBufferSize)
                nSize ＝ dwBufferSize
            .如果真结束
            CopyMemory_P2IP_ADAPTER_INDEX_MAP_Array (Adapter, plfTable ＋ 4, nSize)
            重定义数组 (MapList, 假, FaceInfo.NumAdapters)
            .计次循环首 (FaceInfo.NumAdapters, i)
                szMapName ＝ 到字节集 (Adapter [i].Name)
                szFriendName ＝ 取空白字节集 (256)
                MprConfigGetFriendlyName (hMprConfig, szMapName, szFriendName, 255)
                MapList [i].Index ＝ Adapter [i].Index
                MapList [i].strMapName ＝ 编码_Unicode到Ansi (szMapName)
                MapList [i].strFriendName ＝ 编码_Unicode到Ansi (szFriendName)
                
                ' //\DEVICE\TCPIP_{BC803C3B-B533-4B99-83D5-38E9DCFC51AB}
                MapList [i].strGUID ＝ MapList [i].strMapName
                nPos ＝ 寻找文本 (MapList [i].strGUID, “{”, , 假)
                .如果真 (nPos ≠ -1)
                    MapList [i].strGUID ＝ 取文本右边 (MapList [i].strGUID, 取文本长度 (MapList [i].strGUID) － nPos ＋ 1)
                .如果真结束
                
            .计次循环尾 ()
        .如果真结束
        
    .如果真结束
    
    MprConfigServerDisconnect (hMprConfig) ' 断开连接

.子程序 GetDnsServer, 逻辑型, , 通过GetPerAdapterInfo获取指定网卡的DNS服务器
    .参数 nIndex, 整数型, , IP_ADAPTER_INFO.Index
    .参数 strDNS1, 文本型, 参考, 首选DNS服务器
    .参数 strDNS2, 文本型, 参考, 备用DNS服务器
    .局部变量 PerAdapterInfo, IP_PER_ADAPTER_INFO_彗星
    .局部变量 BufBin, 字节集
    .局部变量 pAda, 整数型
    .局部变量 nSize, 整数型
    .局部变量 nBufLen, 整数型
    .局部变量 nResult, 整数型
    .局部变量 pAddr, 整数型
    .局部变量 ipAddr, IP_ADDR_STRING
    .局部变量 nCount, 整数型

    strDNS1 ＝ “”
    strDNS2 ＝ “”
    ' //--------------------------------------------------
    nResult ＝ GetPerAdapterInfo_Ptr (nIndex, 0, nBufLen)
    .如果真 (nResult ＝ #ERROR_BUFFER_OVERFLOW)
        BufBin ＝ 取空白字节集 (nBufLen)
        pAda ＝ GetPtr_Bin (BufBin, BufBin, 0)
        nResult ＝ GetPerAdapterInfo_Ptr (nIndex, pAda, nBufLen)
        .如果真 (#ERROR_SUCCESS ＝ nResult)
            nSize ＝ LocalSize_IP_PER_ADAPTER_INFO (PerAdapterInfo)
            CopyMemory_P2IP_PER_ADAPTER_INFO (PerAdapterInfo, pAda, nSize)
            ipAddr ＝ PerAdapterInfo.DnsServerList
            .循环判断首 ()
                nCount ＝ nCount ＋ 1
                .判断开始 (nCount ＝ 1)
                    strDNS1 ＝ 到文本 (ipAddr.IpAddress)
                .判断 (nCount ＝ 2)
                    strDNS2 ＝ 到文本 (ipAddr.IpAddress)
                .默认
                    
                .判断结束
                
                pAddr ＝ ipAddr.Next
                .如果真 (pAddr ≠ 0)
                    CopyMemory_IP_ADDR_STRING (ipAddr, pAddr, LocalSize_IP_ADDR_STRING (ipAddr))
                    
                .如果真结束
                
            .循环判断尾 (pAddr ≠ 0)
            
            返回 (真)
        .如果真结束
        
    .如果真结束
    ' //--------------------------------------------------
    返回 (假)

.子程序 GetAdapterInfoType, 文本型
    .参数 nType, 整数型

    .判断开始 (nType ＝ #MIB_IF_TYPE_OTHER)
        返回 (“OTHER”)
    .判断 (nType ＝ #MIB_IF_TYPE_ETHERNET)
        返回 (“ETHERNET”)
    .判断 (nType ＝ #MIB_IF_TYPE_TOKENRING)
        返回 (“TOKENRING”)
    .判断 (nType ＝ #MIB_IF_TYPE_FDDI)
        返回 (“FDDI”)
    .判断 (nType ＝ #MIB_IF_TYPE_PPP)
        返回 (“PPP”)
    .判断 (nType ＝ #MIB_IF_TYPE_LOOPBACK)
        返回 (“LOOPBACK”)
    .判断 (nType ＝ #MIB_IF_TYPE_SLIP)
        返回 (“SLIP”)
    .判断 (nType ＝ #MIB_IF_TYPE_IEEE80211)
        返回 (“IEEE80211”)
    .默认
        返回 (到文本 (nType))
    .判断结束
    

.子程序 系统_取屏幕数量, 整数型, 公开
    清除数组 (hDisplayInf)
    EnumDisplayMonitors (0, 0, 到整数 (&MonitorEnumProc), 0)
    返回 (取数组成员数 (hDisplayInf))

.子程序 MonitorEnumProc, 逻辑型
    .参数 hMonitor, 整数型
    .参数 hdcMonitor, 整数型
    .参数 lprcMonitor, 整数型
    .参数 dwData, 整数型

    加入成员 (hDisplayInf, hMonitor)
    返回 (真)

.子程序 系统_生成随机mac, 文本型, 公开, 随机返回一个MAC地址 如：F8:1F:CC:C2:AF:14
    .局部变量 临时整数, 整数型
    .局部变量 l1, 整数型
    .局部变量 MAC, 文本型

    ' http://bbs.125.la/forum.php?mod=viewthread&tid=14230227
    .计次循环首 (6, l1)
        置随机数种子 ()
        临时整数 ＝ 取随机数 (16, 255) ' 代表16进制的00-FF范围
        .如果真 (l1 ＝ 1)
            .如果真 (临时整数 ％ 2 ＝ 1) ' 取随机数后判断是否为偶数不是就+1
                .判断开始 (临时整数 ＝ 255)
                    临时整数 ＝ 临时整数 － 1
                .默认
                    临时整数 ＝ 临时整数 ＋ 1
                .判断结束
                
            .如果真结束
            
        .如果真结束
        .判断开始 (l1 ＝ 6) ' 判断否是最后一组是就不加分隔符
            MAC ＝ MAC ＋ 取十六进制文本 (临时整数)
        .默认
            MAC ＝ MAC ＋ 取十六进制文本 (临时整数) ＋ “:”
        .判断结束
        
    .计次循环尾 ()
    返回 (MAC)

.子程序 系统_取系统DPI, 整数型, 公开, 成功返回缩放比，失败返回0。
    .局部变量 hDC, 整数型
    .局部变量 DPI_A, 整数型
    .局部变量 DPI_B, 整数型

    ' https://blog.csdn.net/qq_25916469/article/details/86762197
    hDC ＝ GetDC (#NULL)
    DPI_A ＝ GetDeviceCaps (hDC, 118) ÷ GetDeviceCaps (hDC, 8) × 100
    DPI_B ＝ GetDeviceCaps (hDC, 88) ÷ 96 × 100
    ReleaseDC (#NULL, hDC)
    .判断开始 (DPI_A ＝ 100)
        返回 (DPI_B)
    .判断 (DPI_B ＝ 100)
        返回 (DPI_A)
    .判断 (DPI_A ＝ DPI_B)
        返回 (DPI_A)
    .默认
        返回 (0)
    .判断结束
    

.子程序 系统_取系统DPI_注册表版, 整数型, 公开
    .局部变量 局_系统DPI, 整数型

    局_系统DPI ＝ 取数值注册项 (#现行用户, “Control Panel\Desktop\WindowMetrics\AppliedDPI”, )
    局_系统DPI ＝ 局_系统DPI ÷ 96 × 100
    返回 (局_系统DPI)

.子程序 系统_禁用DPI缩放, 逻辑型, 公开
    返回 (SetProcessDPIAware ())

.子程序 系统_主板发声, 逻辑型, 公开, 让主板也疯狂嗨的命令
    .参数 发出的频率, 整数型
    .参数 发音的时长, 整数型

    返回 (Beep (发出的频率, 发音的时长))

.子程序 系统_清除托盘残留, , 公开, 清除因调试或者其他原因进程已退出但托盘未退出的残留图标
    .局部变量 dwBuildNumber, 短整数型

    m_OsVersion ＝ _OsVersion ()
    .如果真 (m_OsVersion ＝ 0)
        RtlGetNtVersionNumbers (m_OsVersion, m_dwMinor, dwBuildNumber)
    .如果真结束
    m_Isx64 ＝ _Isx64 ()
    .判断开始 (m_Isx64)
        m_nDataOffset ＝ 16
        m_nStrOffset ＝ 24
    .默认
        m_nDataOffset ＝ 12
        m_nStrOffset ＝ 18
    .判断结束
    _RefreshTaskbarIcon ()
    

.子程序 系统_清除托盘残留1, , 公开, 清除因调试或者其他原因进程已退出但托盘未退出的残留图标,不支持XP
    .局部变量 hShellTrayWnd, 整数型
    .局部变量 hTrayNotifyWnd, 整数型
    .局部变量 hSysPager, 整数型
    .局部变量 hToolbarWindow32, 整数型
    .局部变量 r, 精易_矩形
    .局部变量 width, 整数型
    .局部变量 height, 整数型
    .局部变量 x, 整数型

    hShellTrayWnd ＝ FindWindowA (“Shell_TrayWnd”, 字符 (#NULL))
    hTrayNotifyWnd ＝ FindWindowExA (hShellTrayWnd, 0, 取指针_文本型 (“TrayNotifyWnd”), #NULL)
    hSysPager ＝ FindWindowExA (hTrayNotifyWnd, 0, 取指针_文本型 (“SysPager”), #NULL)
    .如果 (hSysPager ≠ 0)
        hToolbarWindow32 ＝ FindWindowExA (hSysPager, 0, 取指针_文本型 (“ToolbarWindow32”), #NULL)
    .否则
        hToolbarWindow32 ＝ FindWindowExA (hTrayNotifyWnd, 0, 取指针_文本型 (“ToolbarWindow32”), #NULL)
    .如果结束
    .如果真 (hToolbarWindow32 ≠ 0)
        GetWindowRect (hToolbarWindow32, r)
        width ＝ r.右边 － r.左边
        height ＝ r.底边 － r.顶边
        .变量循环首 (1, width, 1, x)
            SendMessageA (hToolbarWindow32, #WM_MOUSEMOVE, 0, 合并整数 (x, height ÷ 2))
        .变量循环尾 ()
    .如果真结束
    

.子程序 _Isx64, 逻辑型
    .局部变量 p_Address, 整数型
    .局部变量 p_Bool, 整数型

    p_Address ＝ GetProcAddress (GetModuleHandleA (“kernel32”), “IsWow64Process”)
    .如果真 (p_Address ＝ 0)
        返回 (假)
    .如果真结束
    IsWow64Process_a (-1, p_Bool)
    返回 (p_Bool ≠ 0)

.子程序 _RefreshTaskbarIcon
    .局部变量 p_hWnd, 整数型

    .判断开始 (m_OsVersion ＝ 6) ' 因为没有XP，所以没有写
        p_hWnd ＝ _FindTrayWnd ()
        .如果真 (p_hWnd ＞ 0)
            _EnumNotifyWindow (p_hWnd)
        .如果真结束
        
    .判断 (m_OsVersion ＞ 6 或 (m_OsVersion ＝ 10 且 m_dwMinor ＝ 0)) ' 测试支持WIN7,WIN8,WIN10
        p_hWnd ＝ _FindTrayWnd ()
        .如果真 (p_hWnd ＞ 0)
            _EnumNotifyWindow (p_hWnd)
        .如果真结束
        ' 输出调试文本 (“-------------------------------- 我是分割线 -------------------------------”)
        p_hWnd ＝ _FindNotifyIconOverflowWindow ()
        .如果真 (p_hWnd ＞ 0)
            _EnumNotifyWindow (p_hWnd)
        .如果真结束
        
    .默认
        返回 ()
    .判断结束
    

.子程序 _EnumNotifyWindow
    .参数 hWnd, 整数型
    .局部变量 dwProcessId, 整数型
    .局部变量 hProcess, 整数型
    .局部变量 lAddress, 整数型
    .局部变量 iNum, 整数型
    .局部变量 i, 整数型
    .局部变量 BButton, TBBUTTON
    .局部变量 Bin, 字节集
    .局部变量 data, TRAYDATA
    .局部变量 TrayInfo, TRAYDATAEX
    .局部变量 NDATA, NOTIFYICONDATA

    iNum ＝ SendMessageA (hWnd, #TB_BUTTONCOUNT, 0, 0) ' 数量
    .如果真 (iNum ＞ 0)
        GetWindowThreadProcessId (hWnd, dwProcessId)
        .如果真 (dwProcessId ＞ 0)
            hProcess ＝ OpenProcess (#PROCESS_ALL_ACCESS, 0, dwProcessId)
            .如果真 (hProcess ≠ 0)
                lAddress ＝ VirtualAllocEx_a (hProcess, 0, 4096, #MEM_COMMIT, #PAGE_READWRITE)
                Bin ＝ 取空白字节集 (1024)
                .变量循环首 (iNum － 1, 0, -1, i)
                    SendMessageA (hWnd, #TB_GETBUTTON, i, lAddress) ' 获取TBBUTTON数据
                    ReadProcessMemory_BButton (hProcess, lAddress, BButton, 24, 0) ' 获取TBBUTTON结构
                    ' 输出调试文本 (BButton.idBitMap, BButton.idCommand, BButton.fsState, BButton.fsStyle, BButton.dwData, BButton.iString)
                    
                    .如果真 (BButton.dwData ≠ -1)
                        ReadProcessMemory_Bin (hProcess, BButton.dwData, Bin, 1024, 0)
                        ReadProcessMemory_TRAYDATA (hProcess, BButton.dwData, data, 24, 0) ' 对这个结构不是很清楚，网上的版本太多了，然后OD找了下结构，也不明显，但是勉强可以用
                        
                        ' 输出调试文本 (data.hWnd, data.uID, data.uCallbackMessage, data.Reserved, data.hIcon)
                        
                        TrayInfo.hWnd ＝ data.hWnd
                        .如果真 (IsWindow (TrayInfo.hWnd) ＝ 0) ' 判断窗口时候有效
                            ' 删除图标操作
                            SendMessageA (hWnd, #TB_DELETEBUTTON, i, 1)
                        .如果真结束
                        TrayInfo.idCommand ＝ BButton.idCommand
                        TrayInfo.strFilePath ＝ 编码_Unicode到Ansi (取字节集中间 (Bin, 25 ＋ m_nStrOffset, 520)) ' 这因为是unicode,所以长度*2 260*2
                        TrayInfo.strTile ＝ 编码_Unicode到Ansi (取字节集中间 (Bin, 25 ＋ 520 ＋ m_nStrOffset, 260)) ' 这里不是很清除长度是好多，麻烦
                        ' 输出调试文本 (TrayInfo.hWnd, TrayInfo.idCommand, TrayInfo.strFilePath, TrayInfo.strTile)
                    .如果真结束
                    
                .变量循环尾 ()
                
                VirtualFreeEx_a (hProcess, lAddress, 4096, #MEM_RELEASE)
                CloseHandle (hProcess)
                
                NDATA.cbSize ＝ 488
                Shell_NotifyIcon (#NIM_DELETE, NDATA)
            .如果真结束
            
        .如果真结束
        
    .如果真结束
    

.子程序 _FindTrayWnd, 整数型
    .局部变量 p_hWnd, 整数型

    p_hWnd ＝ FindWindowA (“Shell_TrayWnd”, 字符 (0))
    .如果真 (p_hWnd ＝ 0)
        返回 (0)
    .如果真结束
    p_hWnd ＝ FindWindowExA (p_hWnd, 0, 取指针文本_ (“TrayNotifyWnd”), 0)
    .如果真 (p_hWnd ＝ 0)
        返回 (0)
    .如果真结束
    p_hWnd ＝ FindWindowExA (p_hWnd, 0, 取指针文本_ (“SysPager”), 0)
    .如果真 (p_hWnd ＝ 0)
        返回 (0)
    .如果真结束
    p_hWnd ＝ FindWindowExA (p_hWnd, 0, 取指针文本_ (“ToolbarWindow32”), 0)
    .如果真 (p_hWnd ＝ 0)
        返回 (0)
    .如果真结束
    返回 (p_hWnd)

.子程序 _FindNotifyIconOverflowWindow, 整数型
    .局部变量 p_hWnd, 整数型

    p_hWnd ＝ FindWindowA (“NotifyIconOverflowWindow”, 字符 (0))
    .如果真 (p_hWnd ＝ 0)
        返回 (0)
    .如果真结束
    p_hWnd ＝ FindWindowExA (p_hWnd, 0, 取指针文本_ (“ToolbarWindow32”), 0)
    .如果真 (p_hWnd ＝ 0)
        返回 (0)
    .如果真结束
    返回 (p_hWnd)

.子程序 _OsVersion, 整数型, , [0]未知[1]Win95[2]Win98[3]WinME[4]WinNT[5]Win2000[6]WinXP[7]Win2003[8]Vista[9]win7[10]Win8[11]Win8.1[12]Win10
    置入代码 ({ 83, 49, 192, 100, 139, 29, 24, 0, 0, 0, 100, 139, 13, 48, 0, 0, 0, 133, 201, 121, 32, 185, 0, 0, 83, 0, 57, 75, 88, 117, 4, 176, 1, 235, 113, 57, 75, 84, 117, 4, 176, 2, 235, 104, 57, 75, 124, 117, 99, 176, 3, 235, 95, 139, 153, 168, 0, 0, 0, 139, 137, 164, 0, 0, 0, 131, 249, 4, 119, 4, 176, 4, 235, 74, 131, 249, 5, 117, 27, 131, 251, 0, 117, 4, 176, 5, 235, 60, 131, 251, 1, 117, 4, 176, 6, 235, 51, 131, 251, 2, 117, 4, 176, 7, 235, 42, 131, 249, 6, 117, 7, 131, 251, 0, 117, 4, 176, 8, 235, 28, 131, 251, 1, 117, 2, 176, 9, 131, 251, 2, 117, 2, 176, 10, 131, 251, 3, 117, 2, 176, 11, 131, 251, 4, 117, 2, 176, 12, 91, 201, 195 })
    返回 (0)

.子程序 系统_取网卡信息, 整数型, 公开, 本源码由 【剩下我de孩子气】提供
    .参数 网卡信息, 精易_网卡信息, 参考 数组
    .局部变量 size_link, 整数型
    .局部变量 AdapterInfo, IP_ADAPTER_INFO
    .局部变量 buf_link, 字节集
    .局部变量 addr_link, 整数型
    .局部变量 i, 整数型
    .局部变量 mac, 文本型
    .局部变量 tmp, 文本型
    .局部变量 buf_ip, IP_ADDR_STRING
    .局部变量 link, 精易_网卡信息
    .局部变量 size_dns, 整数型
    .局部变量 dns, IP_PER_ADAPTER_INFO
    .局部变量 buf_dns, 字节集
    .局部变量 addr_dns, 整数型

    重定义数组 (网卡信息, 假, 0)
    GetAdaptersInfo_字节集 ({ 0 }, size_link)
    buf_link ＝ 取空白字节集 (size_link)
    addr_link ＝ 取变量地址_字节集 (buf_link, buf_link, 0)
    .如果真 (GetAdaptersInfo_字节集 (buf_link, size_link) ＝ 0)
        .循环判断首 ()
            RtlMoveMemory_IP_ADAPTER_INFO (AdapterInfo, addr_link, 640)
            link.名称 ＝ 到文本 (AdapterInfo.Description)
            mac ＝ “”
            .计次循环首 (AdapterInfo.AddressLength, i)
                tmp ＝ 取十六进制文本 (AdapterInfo.Address [i])
                mac ＝ mac ＋ 选择 (取文本长度 (tmp) ＝ 1, “0” ＋ tmp, tmp) ＋ “-”
                ' mac ＝ mac ＋ 选择 (tmp ＝ “0”, “00”, tmp) ＋ “-”
            .计次循环尾 ()
            mac ＝ 取文本左边 (mac, 取文本长度 (mac) － 1)
            link.Mac ＝ mac
            CopyMemory_ias (buf_ip, AdapterInfo.IpAddressList, 40)
            link.Ip ＝ 到文本 (buf_ip.IpAddress)
            link.掩码 ＝ 到文本 (buf_ip.IpMask)
            CopyMemory_ias (buf_ip, AdapterInfo.GatewayList, 40)
            link.网关 ＝ 到文本 (buf_ip.IpAddress)
            link.连接名称 ＝ 取文本注册项 (4, “SYSTEM\CurrentControlSet\Control\Network\{4D36E972-E325-11CE-BFC1-08002BE10318}\” ＋ 到文本 (AdapterInfo.AdapterName) ＋ “\Connection\Name”, )
            size_dns ＝ GetPerAdapterInfo (AdapterInfo.Index, buf_dns, size_dns)
            buf_dns ＝ 取空白字节集 (size_dns)
            addr_dns ＝ 取变量地址_字节集 (buf_dns, buf_dns, 0)
            GetDnsServer (AdapterInfo.Index, link.DNS1, link.DNS2)
            
            ' .如果 (GetPerAdapterInfo (AdapterInfo.Index, buf_dns, size_dns) ＝ 0)
                ' RtlMoveMemory_IP_PER_ADAPTER_INFO (dns, addr_dns, 92)
                ' link.DNS1 ＝ 到文本 (dns.CurrentDnsServer.IpAddress)
                ' link.DNS2 ＝ 到文本 (dns.DnsServerList.IpAddress)
            ' .否则
                ' link.DNS1 ＝ “”
                ' link.DNS2 ＝ “”
            ' .如果结束
            加入成员 (网卡信息, link)
            addr_link ＝ AdapterInfo.Next
        .循环判断尾 (addr_link ≠ 0)
        返回 (取数组成员数 (网卡信息))
    .如果真结束
    返回 (0)
    

.子程序 系统_添加计划任务, 文本型, 公开, 向系统中增加一个计划任务，该操作在WIN7上面需要管理员权限
    .参数 计划任务名, 文本型, , 用于显示在系统中的计划任务的名称
    .参数 计划任务执行文件路径, 文本型, , 执行文件的路径，可以EXE也可以BAT
    .参数 计划任务执行方式, 整数型, , 方式有以下几种：6=一次，7=在系统启动时，8=在用户登录时，9=在系统空闲时。
    .参数 执行任务的用户名, 文本型, 可空, 需要执行该任务的用户名。如果不需要可以留空
    .参数 执行任务的密码, 文本型, 可空, 用户名对应的密码。如果不需要可以留空。如果是已解锁电脑则无需输入密码
    .参数 任务执行时间, 日期时间型, 可空, 如果执行方式是一次，则必须有该值。该值为日期时间型
    .参数 是否强制创建, 逻辑型, 可空, 如果为真，则忽略任何错误，强制创建任务
    .局部变量 命令行文本, 文本型
    .局部变量 任务执行方式文本, 文本型
    .局部变量 临时_执行任务用户名, 文本型
    .局部变量 临时_执行任务密码, 文本型
    .局部变量 临时_任务执行时间, 文本型

    .局部变量 输出内容, 文本型
    .局部变量 错误输出, 文本型
    .局部变量 执行返回值, 整数型
    .局部变量 局_返回值, 文本型

    ' 示例:
    ' ==> 在远程机器 "ABC" 上创建计划任务 "doc"，
    ' 该机器每小时在 "runasuser" 用户下运行 notepad.exe。
    
    ' SCHTASKS /Create /S ABC /U user /P password /RU runasuser
    ' /RP runaspassword /SC HOURLY /TN doc /TR notepad
    
    ' ==> 在远程机器 "ABC" 上创建计划任务 "accountant"，
    ' 在指定的开始日期和结束日期之间的开始时间和结束时间内，
    ' 每隔五分钟运行 calc.exe。
    
    ' SCHTASKS /Create /S ABC /U domain\user /P password /SC MINUTE
    ' /MO 5 /TN accountant /TR calc.exe /ST 12:00 /ET 14:00
    ' /SD 06/06/2006 /ED 06/06/2006 /RU runasuser /RP userpassword
    
    ' ==> 创建计划任务 "gametime"，在每月的第一个星期天
    ' 运行“空当接龙”。
    
    ' SCHTASKS /Create /SC MONTHLY /MO first /D SUN /TN gametime
    ' /TR c:\windows\system32\freecell
    
    ' ==> 在远程机器 "ABC" 创建计划任务 "report"，
    ' 每个星期运行 notepad.exe。
    
    ' SCHTASKS /Create /S ABC /U user /P password /RU runasuser
    ' /RP runaspassword /SC WEEKLY /TN report /TR notepad.exe
    
    ' ==> 在远程机器 "ABC" 创建计划任务 "logtracker"，
    ' 每隔五分钟从指定的开始时间到无结束时间，
    ' 运行 notepad.exe。将提示输入 /RP
    ' 密码。
    
    ' SCHTASKS /Create /S ABC /U domain\user /P password /SC MINUTE
    ' /MO 5 /TN logtracker
    ' /TR c:\windows\system32\notepad.exe /ST 18:30
    ' /RU runasuser /RP
    
    ' ==> 创建计划任务 "gaming"，每天从 12:00 点开始到
    ' 14:00 点自动结束，运行 freecell.exe。
    
    ' SCHTASKS /Create /SC DAILY /TN gaming /TR c:\freecell /ST 12:00
    ' /ET 14:00 /K
    ' ==> 创建计划任务“EventLog”以开始运行 wevtvwr.msc
    ' 只要在“系统”通道中发布事件 101
    
    ' SCHTASKS /Create /TN EventLog /TR wevtvwr.msc /SC ONEVENT
    ' /EC System /MO *[System/EventID=101]
    ' ==> 文件路径中可以加入空格，但需要加上两组引号，
    ' 一组引号用于 CMD.EXE，另一组用于 SchTasks.exe。用于 CMD
    ' 的外部引号必须是一对双引号；内部引号可以是一对单引号或
    ' 一对转义双引号:
    ' SCHTASKS /Create
    ' /tr "'c:\program files\internet explorer\iexplorer.exe'
    ' \"c:\log data\today.xml\"" ...
    
    .如果真 (计划任务执行方式 ＞ 9 或 计划任务执行方式 ＜ 6)
        返回 (“计划任务执行方式不正确，请重新填写”)
    .如果真结束
    
    任务执行方式文本 ＝ 多项选择 (计划任务执行方式 － 5, “ONCE”, “ONSTART”, “ONLOGON”, “ONIDLE”)
    
    .如果真 (执行任务的用户名 ≠ “”)
        临时_执行任务用户名 ＝ “ /RU ” ＋ #引号 ＋ 执行任务的用户名 ＋ #引号
    .如果真结束
    
    .如果真 (执行任务的密码 ≠ “”)
        临时_执行任务密码 ＝ “ /RP ” ＋ #引号 ＋ 执行任务的密码 ＋ #引号
    .如果真结束
    
    .如果真 (计划任务执行方式 ＝ 6)
        临时_任务执行时间 ＝ “ /SD ” ＋ 时间_到文本 (任务执行时间, 2, 1) ＋ “ /ST ” ＋ 时间_格式化 (任务执行时间, , “hh:mm”, 真)
    .如果真结束
    
    命令行文本 ＝ “SCHTASKS /Create  ” ＋ 临时_执行任务用户名 ＋ 临时_执行任务密码 ＋ “ /SC ” ＋ 任务执行方式文本 ＋ “ /TN ” ＋ #引号 ＋ 计划任务名 ＋ #引号 ＋ “ /TR ” ＋ #引号 ＋ 计划任务执行文件路径 ＋ #引号 ＋ 临时_任务执行时间 ＋ 选择 (是否强制创建, “ /F”, “”)
    局_返回值 ＝ 系统_取DOS执行结果 (“cmd.exe /c ” ＋ 命令行文本)
    ' 运行控制台程序 (“cmd.exe /c ” ＋ 命令行文本, 输出内容, 错误输出, 执行返回值)
    返回 (局_返回值)

.子程序 系统_删除计划任务, 文本型, 公开, 删除指定名计划任务
    .参数 计划任务名, 文本型
    .局部变量 局_命令行文本, 文本型
    .局部变量 局_返回值, 文本型

    局_命令行文本 ＝ “SCHTASKS /Delete ” ＋ “ /TN ” ＋ #引号 ＋ 计划任务名 ＋ #引号 ＋ “ /F”
    局_返回值 ＝ 系统_取DOS执行结果 (“cmd.exe /c ” ＋ 局_命令行文本)
    返回 (局_返回值)

.子程序 系统_修改用户名, 逻辑型, 公开, 修改系统用户名
    .参数 新用户名, 文本型
    .局部变量 局_结果, 逻辑型

    局_结果 ＝ 运行 (“cmd /c reg add ” ＋ #引号 ＋ “ HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\ComputerName\ActiveComputerName” ＋ #引号 ＋ “ /v ComputerName /t reg_sz /d ” ＋ 删首尾空 (新用户名) ＋ “ /f >nul 2>nul”, 真, 1)
    .如果真 (局_结果 ＝ 假)
        返回 (假)
    .如果真结束
    局_结果 ＝ 运行 (“cmd /c reg add ” ＋ #引号 ＋ “HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\Tcpip\Parameters” ＋ #引号 ＋ “ /v ” ＋ #引号 ＋ “NV Hostname” ＋ #引号 ＋ “ /t reg_sz /d ” ＋ 删首尾空 (新用户名) ＋ “ /f >nul 2>nul”, 真, 1)
    .如果真 (局_结果 ＝ 假)
        返回 (假)
    .如果真结束
    
    局_结果 ＝ 运行 (“cmd /c reg add ” ＋ #引号 ＋ “HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\Tcpip\Parameters” ＋ #引号 ＋ “ /v Hostname /t reg_sz /d ” ＋ 删首尾空 (新用户名) ＋ “ /f >nul 2>nul”, 真, 1)
    .如果真 (局_结果 ＝ 假)
        返回 (假)
    .如果真结束
    返回 (真)

.子程序 系统_创建还原点, 整数型, 公开, 创建系统还原点，成功返回还原点ID，失败返回Null，系统还原服务必须开启或还原服务打开，更新信息请参考[控制面板—>系统属性->系统保护页。
    .参数 描述, 文本型
    .参数 类型, , 可空, 可为空，默认即程序安装，参数 1＝程序安装；2＝程序卸载；3＝驱动安装；4＝系统。
    .局部变量 RestorePtInfo, RESTOREPTINFO
    .局部变量 SMgrStatus, SMGRSTATUS
    .局部变量 bool, 逻辑型

    .判断开始 (类型 ＝ 1)
        类型 ＝ 0 ' #APPLICATION_INSTALL
    .判断 (类型 ＝ 2)
        类型 ＝ 1 ' #APPLICATION_UNINSTALL
    .判断 (类型 ＝ 3)
        类型 ＝ 10 ' #DEVICE_DRIVER_INSTALL
    .判断 (类型 ＝ 4)
        类型 ＝ 12 ' #MODIFY_SETTINGS
    .默认
        
    .判断结束
    RestorePtInfo.dwEventType ＝ 100 ' #BEGIN_SYSTEM_CHANGE
    RestorePtInfo.dwRestorePtType ＝ 类型
    
    lstrcpy_bytes (RestorePtInfo.szDescription, 描述)
    bool ＝ SRSetRestorePoint (RestorePtInfo, SMgrStatus)
    .如果真 (bool)
        返回 (SMgrStatus.llSequenceNumber)
    .如果真结束
    返回 (0)

.子程序 系统_删除还原点, 逻辑型, 公开, 删除指定还原点，成功返回真，失败返回假。
    .参数 还原点ID, 长整数型, , 由“创建还原点()”返回。

    返回 (SRRemoveRestorePoint (还原点ID) ＝ 0)

.子程序 系统_加入域, 逻辑型, 公开, 加入指定系统域，成功返回真，失败返回假，重启后生效。
    .参数 域名称, 文本型
    .参数 用户名, 文本型
    .参数 密码, 文本型

    Status_域 ＝ NetJoinDomain (0, 编码_Ansi到Unicode (域名称), 0, 编码_Ansi到Unicode (用户名 ＋ “@” ＋ 域名称), 编码_Ansi到Unicode (密码), 位或 (1, 2, 32))
    返回 (Status_域 ＝ 0)

.子程序 系统_退出域, 逻辑型, 公开, 退出指定系统域，成功返回真，失败返回假，重启后生效。
    .参数 域名称, 文本型
    .参数 用户名, 文本型
    .参数 密码, 文本型

    Status_域 ＝ NetUnjoinDomain (0, 编码_Ansi到Unicode (用户名 ＋ “@” ＋ 域名称), 编码_Ansi到Unicode (密码), 4) ' NETSETUP_ACCT_DELETE
    返回 (Status_域 ＝ 0)

.子程序 系统_是否为默认字体, 逻辑型, 公开, 返回屏幕字体大小，如果字体不是较小默认值，返回假
    .局部变量 hdc, 整数型
    .局部变量 hwnd, 整数型
    .局部变量 PrevMapMode, 整数型
    .局部变量 tm, 物理字体属性信息_
    .局部变量 返回值, 逻辑型

    返回值 ＝ 真 ' 设置默认的返回值,以小字体
    hwnd ＝ 取屏幕句柄_ () ' 得到处理的桌面窗口
    hdc ＝ 取窗口全部设备场景_ (hwnd) ' 获取设备上下文的桌面
    .如果真 (hdc ≠ 0)
        PrevMapMode ＝ SetMapMode (hdc, 1) ' 设置映射模式像素
        取得物理字体信息_ (hdc, tm) ' 得到系统字体的大小
        PrevMapMode ＝ SetMapMode (hdc, PrevMapMode) ' 设置映射模式
        释放设备场景_ (hwnd, hdc)
    .如果真结束
    .如果真 (tm.tmHeight ＞ 16)
        返回值 ＝ 假
    .如果真结束
    返回 (返回值)

.子程序 系统_临时字体_安装, 整数型, 公开, 失败返回0；如果函数调用成功，则返回值为增加的字体数   安装字体后，请勿删除字体文件，否则不能正常显示文字
    .参数 字体路径, 文本型, , 含有效字体的文件名,字体资源文件(.FON)、未加工位图字体(.FNT)、未加工TrueType(.TTF)或TrueType资源(.FON)
    .局部变量 ls, 整数型

    ls ＝ AddFontResourceA (字体路径)
    ' SendMessageA (65535, 29, 0, 0)  ' 消息广播通知所有窗口 字体数量已经更改
    SendMessageTimeoutA (#HWND_BROADCAST, 0, #NULL, #NULL, #SMTO_ABORTIFHUNG, 5000, #NULL)
    返回 (ls)

.子程序 系统_临时字体_卸载, 逻辑型, 公开, 通常情况下，只卸载由“系统_安装字体”安装的字体资源
    .参数 字体路径, 文本型, , 含有效字体资源的文件名
    .局部变量 ls, 逻辑型

    ls ＝ RemoveFontResourceA (字体路径)
    ' SendMessageA (65535, 29, 0, 0)  ' 消息广播通知所有窗口 字体数量已经更改
    SendMessageTimeoutA (#HWND_BROADCAST, 0, #NULL, #NULL, #SMTO_ABORTIFHUNG, 5000, #NULL)
    返回 (ls)

.子程序 系统_取字体名, 文本型, 公开, 获取字体名称，如“simsun.ttc”显示字体名称为“宋体”。
    .参数 字体文件名, 文本型, , 可以输入字体文件名，如“STXINWEI.TTF”,默认在系统字体目录下搜索该文件。
    .局部变量 szPath, 文本型
    .局部变量 FontsPath, 文本型
    .局部变量 fontRes, FONT_RESOURCE
    .局部变量 Length, 整数型
    .局部变量 FontsName, 文本型
    .局部变量 exists, 逻辑型

    szPath ＝ 字体文件名
    exists ＝ 文件是否存在 (szPath)
    .如果 (exists)
        AddFontResourceA (szPath)
    .否则
        FontsPath ＝ 取空白文本 (256)
        SHGetSpecialFolderPathA (0, FontsPath, 20, 假)
        szPath ＝ FontsPath ＋ “\” ＋ szPath
    .如果结束
    GetFontResourceInfoW (编码_Ansi到Unicode (szPath, ), Length, fontRes, 2)
    GetFontResourceInfoW (编码_Ansi到Unicode (szPath, ), Length, fontRes, 2)
    FontsName ＝ 编码_Unicode到Ansi (到字节集 (fontRes.wszFontName))
    .如果真 (exists)
        RemoveFontResourceA (szPath)
    .如果真结束
    返回 (FontsName)

.子程序 系统_取宽带线路, 整数型, 公开, 返回电信或网通,1代表电信,2代表其它(如:网通,铁通等等)
    .参数 IP地址, 文本型, 可空, 可空，为空将查询本机的线路。请填入你要查询的IP地址  如：119.147.106.250
    .参数 线路, 文本型, 可空, 请提供一个文本变量,用于存放宽带的线路，如：电信或网通。
    .参数 所在地址, 文本型, 可空, 请提供一个文本变量,用于存放IP所在地的地址，如：中国广东广州。
    .局部变量 局_源文本, 文本型
    .局部变量 局_文本, 文本型

    局_源文本 ＝ 编码_usc2到ansi (编码_Utf8到Ansi (网页_访问 (“https://api-v3.speedtest.cn/ip?ip=” ＋ IP地址, , , , , , , , , , , , , )))
    .如果真 (是否为空 (线路) ＝ 假)
        线路 ＝ 文本_取出中间文本 (局_源文本, “#引号isp#引号:#引号”, #引号, , )
    .如果真结束
    .如果真 (是否为空 (所在地址) ＝ 假)
        所在地址 ＝ 文本_取出中间文本 (局_源文本, “#引号country#引号:#引号”, #引号, , ) ＋ 文本_取出中间文本 (局_源文本, “#引号province#引号:#引号”, #引号, , ) ＋ 文本_取出中间文本 (局_源文本, “#引号city#引号:#引号”, #引号, , )
    .如果真结束
    .如果真 (寻找文本 (局_源文本, “电信”, , 假) ≠ -1)
        返回 (1)
    .如果真结束
    返回 (2)

.子程序 系统_取空闲时间, 整数型, 公开, 返回单位为毫秒
    .局部变量 dwTime, PLASTINPUTINFO

    dwTime.cbSize ＝ 8
    GetLastInputInfo (dwTime)
    返回 (GetTickCount () － dwTime.dwTime)

.子程序 系统_取空闲时间1, 长整数型, 公开, 返回单位为毫秒
    .局部变量 dwTime, PLASTINPUTINFO

    dwTime.cbSize ＝ 8
    GetLastInputInfo (dwTime)
    返回 (GetTickCount64 () － 合并长整数 (dwTime.dwTime, 0))

.子程序 系统_检测host, 逻辑型, 公开, 返回真则host已经被修改
    .参数 网址1, 文本型
    .参数 网址2, 文本型, 可空
    .参数 网址3, 文本型, 可空
    .局部变量 host, 文本型

    host ＝ 到文本 (读入文件 (目录_取system32目录 () ＋ “Drivers\etc\hosts”))
    .判断开始 (寻找文本 (host, 网址1, , 真) ≠ -1)
        返回 (真)
    .判断 (寻找文本 (host, 网址2, , 真) ≠ -1 且 网址2 ≠ “”)
        返回 (真)
    .判断 (寻找文本 (host, 网址3, , 真) ≠ -1 且 网址3 ≠ “”)
        返回 (真)
    .默认
        返回 (假)
    .判断结束
    

.子程序 系统_取星座, 文本型, 公开, 返回一个日期所处于哪一个星座时段
    .参数 日期, 日期时间型

    ' 1月21日～2月19日水瓶座
    ' 2月20日～3月20日双鱼座
    ' 3月21日～4月20日白羊座
    ' 4月21日～5月21日金牛座
    ' 5月22日～6月21日双子座
    ' 6月22日～7月22日巨蟹座
    ' 7月23日～8月23日狮子座
    ' 8月24日～9月23日仕女座
    ' 9月24日～10月23日天秤座
    ' 10月24日～11月22日天蝎座
    ' 11月23日～12月21日射手座
    ' 12月22日～1月20日魔羯座
    .判断开始 (取月份 (日期) ＝ 1 且 取日 (日期) ≥ 21 或 (取月份 (日期) ＝ 2 且 取日 (日期) ≤ 19))
        返回 (“水瓶座”)
    .判断 (取月份 (日期) ＝ 2 且 取日 (日期) ≥ 20 或 (取月份 (日期) ＝ 3 且 取日 (日期) ≤ 20))
        返回 (“双鱼座”)
    .判断 (取月份 (日期) ＝ 3 且 取日 (日期) ≥ 21 或 (取月份 (日期) ＝ 4 且 取日 (日期) ≤ 20))
        返回 (“白羊座”)
    .判断 (取月份 (日期) ＝ 4 且 取日 (日期) ≥ 21 或 (取月份 (日期) ＝ 5 且 取日 (日期) ≤ 21))
        返回 (“金牛座”)
    .判断 (取月份 (日期) ＝ 5 且 取日 (日期) ≥ 22 或 (取月份 (日期) ＝ 6 且 取日 (日期) ≤ 21))
        返回 (“双子座”)
    .判断 (取月份 (日期) ＝ 6 且 取日 (日期) ≥ 22 或 (取月份 (日期) ＝ 7 且 取日 (日期) ≤ 22))
        返回 (“巨蟹座”)
    .判断 (取月份 (日期) ＝ 7 且 取日 (日期) ≥ 23 或 (取月份 (日期) ＝ 8 且 取日 (日期) ≤ 23))
        返回 (“狮子座”)
    .判断 (取月份 (日期) ＝ 8 且 取日 (日期) ≥ 24 或 (取月份 (日期) ＝ 9 且 取日 (日期) ≤ 23))
        返回 (“处女座”)
    .判断 (取月份 (日期) ＝ 9 且 取日 (日期) ≥ 24 或 (取月份 (日期) ＝ 10 且 取日 (日期) ≤ 23))
        返回 (“天秤座”)
    .判断 (取月份 (日期) ＝ 10 且 取日 (日期) ≥ 24 或 (取月份 (日期) ＝ 11 且 取日 (日期) ≤ 22))
        返回 (“天蝎座”)
    .判断 (取月份 (日期) ＝ 11 且 取日 (日期) ≥ 23 或 (取月份 (日期) ＝ 12 且 取日 (日期) ≤ 21))
        返回 (“射手座”)
    .判断 (取月份 (日期) ＝ 12 且 取日 (日期) ≥ 22 或 (取月份 (日期) ＝ 1 且 取日 (日期) ≤ 20))
        返回 (“魔羯座”)
    .默认
        返回 (“”)
    .判断结束
    

.子程序 系统_重启, , 公开, 重启电脑
    进程_提升权限 (, #关机)
    ExitWindowsEx (#EWX_REBOOT, 0)

.子程序 系统_强制重启, , 公开, 强制重启电脑
    进程_提升权限 (, #关机)
    ExitWindowsEx (位或 (#EWX_REBOOT, #EWX_FORCE), 65535)

.子程序 系统_刷新屏幕, , 公开, 刷新桌面
    运行 (“RunDll32.exe USER32.DLL,UpdatePerUserSystemParameters”, 假, )

.子程序 系统_注销, , 公开, 注销当前用户
    ExitWindowsEx (#EWX_LOGOFF, 65535)

.子程序 系统_强制注销, , 公开, 强制注销当前用户
    ExitWindowsEx (位或 (#EWX_LOGOFF, #EWX_FORCE), 65535)

.子程序 系统_关机, , 公开, 关闭电脑
    进程_提升权限 (, #关机)
    ExitWindowsEx (#EWX_SHUTDOWN, 65535)

.子程序 系统_强制关机, , 公开, 强制关闭电脑
    进程_提升权限 (, #关机)
    ExitWindowsEx (位或 (#EWX_SHUTDOWN, #EWX_FORCE), 65535)

.子程序 系统_关电源, , 公开, 无返回值，实现快速关机。
    .局部变量 lRes, 整数型

    lRes ＝ RtlAdjustPrivilege (#SeShutdownPrivilege, 1, 1, #NULL)
    .如果真 (lRes ＝ -1073741700)
        lRes ＝ RtlAdjustPrivilege (#SeShutdownPrivilege, 1, 0, #NULL)
    .如果真结束
    ZwShutdownSystem (2) ' SH_POWEROFF

.子程序 系统_以管理员模式创建进程, 逻辑型, 公开, 在Vista/Win7及更高系统上,以管理员模式创建进程,成功返回真,失败返回假 警告：请勿放在 窗口创建完毕/首次被激活/死循环中
    .参数 进程路径, 文本型, 可空, 留空默认启动自身进程
    .参数 运行参数, 文本型, 可空, 命令行参数
    .参数 超时间隔, 整数型, 可空, 以毫秒为单位。如果指定了非零值，则函数会等待，直到对象发出信号或间隔结束。
    .参数 指定窗口的显示状态, 整数型, 可空, #SW_*
    .局部变量 nShow, 整数型

    .如果 (是否为空 (指定窗口的显示状态) 或 指定窗口的显示状态 ＜ #SW_HIDE 或 指定窗口的显示状态 ＞ #SW_FORCEMINIMIZE)
        nShow ＝ #SW_SHOWDEFAULT
    .否则
        nShow ＝ 指定窗口的显示状态
    .如果结束
    返回 (系统_以管理员模式创建进程W (编码_Ansi到Unicode (进程路径, ), 编码_Ansi到Unicode (运行参数, ), 超时间隔, nShow))

.子程序 系统_以管理员模式创建进程W, 逻辑型, 公开, 以管理员模式创建进程
    .参数 进程路径, 字节集, 可空, 留空默认启动自身进程
    .参数 命令行, 字节集, 可空, 命令行参数
    .参数 超时间隔, 整数型, 可空, 以毫秒为单位。如果指定了非零值，则函数会等待，直到对象发出信号或间隔结束。
    .参数 指定窗口的显示状态, 整数型, 可空, #SW_*
    .局部变量 ShExecInfo, SHELLEXECUTEINFOW
    .局部变量 wszDir, 字节集

    ShExecInfo.cbSize ＝ 60 ' sizeof(SHELLEXECUTEINFOW)
    .如果 (进程路径 ＝ { })
        wszDir ＝ 删除Unicode结尾空白字节 (目录_取当前目录W (), )
        ShExecInfo.lpFile ＝ wszDir ＋ 编码_Ansi到Unicode (“\” ＋ 取执行文件名 (), )
    .否则
        ShExecInfo.lpFile ＝ 进程路径
    .如果结束
    ShExecInfo.lpParameters ＝ 命令行
    ShExecInfo.lpVerb ＝ 编码_Ansi到Unicode (“runas”, )
    .如果 (超时间隔 ≤ 0)
        ShExecInfo.fMask ＝ 位或 (#SEE_MASK_NOASYNC, #SEE_MASK_UNICODE)
    .否则
        ShExecInfo.fMask ＝ 位或 (#SEE_MASK_NOASYNC, #SEE_MASK_UNICODE, #SEE_MASK_NOCLOSEPROCESS)
    .如果结束
    .如果 (是否为空 (指定窗口的显示状态) 或 指定窗口的显示状态 ＜ #SW_HIDE 或 指定窗口的显示状态 ＞ #SW_FORCEMINIMIZE)
        ShExecInfo.nShow ＝ #SW_SHOWDEFAULT
    .否则
        ShExecInfo.nShow ＝ 指定窗口的显示状态
    .如果结束
    .如果真 (ShellExecuteExW (ShExecInfo) ＝ 假)
        返回 (假)
    .如果真结束
    .如果真 (ShExecInfo.hProcess ≠ #NULL)
        .如果真 (WaitForSingleObject (ShExecInfo.hProcess, 超时间隔) ＝ #WAIT_TIMEOUT)
            TerminateProcess (ShExecInfo.hProcess, 0)
        .如果真结束
        CloseHandle (ShExecInfo.hProcess)
    .如果真结束
    返回 (真)

.子程序 系统_光驱开关过程
    .参数 光驱盘符, 文本型, , 只能提供盘符字母，不要有“:”
    .参数 打开关闭, 逻辑型
    .局部变量 A, 光驱相关1
    .局部变量 B, 光驱相关2
    .局部变量 C, 文本型

    A.lpstrDeviceType ＝ “cdaudio”
    C ＝ 到大写 (取文本左边 (光驱盘符, 1))
    .如果真 (取反 (取代码 (C, ) ≥ 65 且 取代码 (C, ) ≤ 90))
        返回 ()
    .如果真结束
    A.lpstrElementName ＝ C ＋ “:”
    .如果真 (_系统光驱开关1 (0, 2051, 8961, A) ＝ 0)
        .如果 (打开关闭)
            _系统光驱开关2 (A.wDeviceID, 2061, 16640, B)
        .否则
            _系统光驱开关2 (A.wDeviceID, 2061, 16896, B)
        .如果结束
        
    .如果真结束
    mciSendCommandA (A.wDeviceID, 2052, 0, 0)

.子程序 系统_显示关机对话框, , 公开, 调用系统的关机对话框
    .参数 WIN系列系统, 逻辑型, 可空, 是否WIN7以上的系统类型

    .判断开始 (WIN系列系统)
        _关机对话框_WIN (0, 0)
    .默认
        _关机对话框_XP (0)
    .判断结束
    

.子程序 系统_开启屏保, 逻辑型, 公开, 开启系统屏幕保护
    .参数 延时多少秒开始, 整数型, , 延时几秒后开始屏保

    返回 (SystemParametersInfoA (15, 延时多少秒开始, 0, 2))

.子程序 系统_注册组件, 逻辑型, 公开, DllRegisterServer
    .参数 组件路径, 文本型
    .局部变量 szFileName, 文本型
    .局部变量 hDLL, 整数型
    .局部变量 pFunc, 整数型
    .局部变量 nRet, 整数型

    szFileName ＝ 取空白文本 (255)
    GetShortPathNameA (组件路径, szFileName, 255)
    ' 载入DLL、OCX组件，并将它映射到当前进程使用的地址空间
    hDLL ＝ LoadLibraryA (szFileName)
    .如果真 (hDLL ＝ 0)
        返回 (假)
    .如果真结束
    ' 取函数地址
    pFunc ＝ GetProcAddress (hDLL, “DllRegisterServer”)
    .如果真 (pFunc ≤ 0)
        FreeLibrary (hDLL)
        返回 (假)
    .如果真结束
    ' 运行函数
    nRet ＝ CallWindowProcA (pFunc, 0, 0, 0, 0)
    ' 释放指定的动态链接库
    FreeLibrary (hDLL)
    返回 (真)

.子程序 系统_卸载组件, 逻辑型, 公开, DllUnregisterServer
    .参数 组件路径, 文本型
    .局部变量 hDLL, 整数型
    .局部变量 pFunc, 整数型
    .局部变量 nRet, 整数型

    hDLL ＝ LoadLibraryA (组件路径)
    ' 载入DLL、OCX组件，并将它映射到当前进程使用的地址空间
    .如果真 (hDLL ≤ 0)
        返回 (假)
    .如果真结束
    ' 取函数地址
    pFunc ＝ GetProcAddress (hDLL, “DllUnregisterServer”)
    .如果真 (pFunc ≤ 0)
        FreeLibrary (hDLL)
        返回 (假)
    .如果真结束
    ' 运行函数
    nRet ＝ CallWindowProcA (pFunc, 0, 0, 0, 0)
    ' 释放指定的动态链接库
    FreeLibrary (hDLL)
    返回 (真)

.子程序 系统_显示托盘, , 公开, 显示被隐藏的托盘
    .局部变量 局_数组, 整数型, , "0"

    窗口_枚举子窗口 (窗口_取任务栏句柄 (), 局_数组)
    窗口_置控件状态 (局_数组 [2], 真)

.子程序 系统_隐藏托盘, , 公开, 隐藏托盘
    .局部变量 局_数组, 整数型, , "0"

    窗口_枚举子窗口 (窗口_取任务栏句柄 (), 局_数组)
    窗口_置控件状态 (局_数组 [2], 假)

.子程序 系统_修改主页, , 公开, 修改IE主页
    .参数 地址, 文本型

    写注册项 (3, “Software\Microsoft\Internet Explorer\Main\Start Page”, 地址)

.子程序 系统_切换用户, , 公开, 切换系统用户
    LockWorkStation ()

.子程序 系统_取主页地址, 文本型, 公开, 取IE主页地址
    .局部变量 地址, 文本型

    地址 ＝ 取文本注册项 (3, “Software\Microsoft\Internet Explorer\Main\Start Page”, )
    返回 (地址)

.子程序 系统_光驱开关, , 公开, 控制光驱的开与关
    .参数 打开关闭, 逻辑型, , 真为打开光驱，假为关闭光驱；
    .局部变量 光驱成员, 文本型, , "0"
    .局部变量 计次, 整数型

    系统_光驱查询 (光驱成员)
    .计次循环首 (取数组成员数 (光驱成员), 计次)
        系统_光驱开关过程 (光驱成员 [计次], 打开关闭)
    .计次循环尾 ()

.子程序 系统_光驱查询, , 公开, 返回光驱的文本数组，
    .参数 当前光驱, 文本型, 数组, 用来返回光驱的文本数组
    .局部变量 计次, 整数型

    重定义数组 (当前光驱, 假, 0)
    .计次循环首 (26, 计次)
        .如果真 (GetDriveTypeA (字符 (64 ＋ 计次) ＋ “:”) ＝ 5)
            加入成员 (当前光驱, 字符 (64 ＋ 计次))
        .如果真结束
        
    .计次循环尾 ()

.子程序 系统_处理事件, , 公开, 比普通的处理事件速度要快3倍左右；
    .如果真 (GetInputState () ≠ 0)
        处理事件 ()
    .如果真结束
    

.子程序 系统_处理事件1, , 公开, 暂时转让控制权，以便让 Windows 操作系统有机会处理其它的如用户键盘或鼠标输入等事件。直到操作系统处理并发送完程序队列中的所有事件后，命令才会返回。
    .局部变量 CurrMsg, MSG

    .判断循环首 (PeekMessage (CurrMsg, 0, 0, 0, 1)) ' #PM_REMOVE=1接收消息并从队列里除掉。
        TranslateMessage (CurrMsg)
        DispatchMessage (CurrMsg) ' 分发消息
    .判断循环尾 ()

.子程序 系统_是否64位操作系统, 逻辑型, 公开, 是返回真，不是返回假
    .局部变量 hModule, 整数型
    .局部变量 addr, 整数型
    .局部变量 lpBuffer, 文本型
    .局部变量 ret, 整数型

    hModule ＝ GetModuleHandleA (“kernel32.dll”)
    addr ＝ GetProcAddress (hModule, “GetSystemWow64DirectoryA”)
    .如果真 (addr ＝ 0)
        ' 没有这个函数,肯定是32位系统，因为这个函数是xp才加入的，xp之前没有64位操作系统
        返回 (假)
    .如果真结束
    lpBuffer ＝ 取空白文本 (255)
    ret ＝ 程序_Call (addr, lstrcpyn_文本型 (lpBuffer, lpBuffer, 0), 255)
    返回 (ret ＞ 0)

.子程序 系统_建立关联, 逻辑型, 公开, 能用于关联程序打开方式及改关联图标，以及取得程序关联等功能。
    .参数 后缀, 文本型, , 要关联的文件后缀，如"*.txt"
    .参数 关联程序, 文本型, 可空, 此后缀所要关联的程序，如"d:\myflash.exe"，会关联用此程序打开，如果为空则默认为本程序
    .参数 关联图标, 文本型, 可空, 关联后此程序的图标，默认为关联程序的第一个图标
    .参数 关联名称, 文本型, 可空, 此为高级项，为关联注册项的名称，可为空，默认为程序名
    .局部变量 程序, 文本型
    .局部变量 成功, 逻辑型
    .局部变量 图标, 文本型

    .如果真 (是否为空 (关联程序))
        关联程序 ＝ 取运行目录 () ＋ “\” ＋ 取执行文件名 ()
    .如果真结束
    后缀 ＝ 子文本替换 (后缀, “*”, , , , 真)
    后缀 ＝ 子文本替换 (后缀, “.”, , , , 真)
    后缀 ＝ “.” ＋ 后缀 ＋ “\”
    程序 ＝ 文件_取文件名 (关联程序)
    .如果 (是否为空 (关联图标))
        图标 ＝ 关联程序 ＋ “,0”
    .否则
        图标 ＝ 关联图标
    .如果结束
    
    成功 ＝ 写注册项 (#根类, 后缀, 程序)
    .如果真 (取反 (是否为空 (关联名称)))
        成功 ＝ 写注册项 (#根类, 后缀 ＋ “Content Type”, 关联名称)
    .如果真结束
    成功 ＝ 写注册项 (#根类, 程序 ＋ “\BrowserFlags”, 8)
    成功 ＝ 写注册项 (#根类, 程序 ＋ “\EditFlags”, 0)
    成功 ＝ 写注册项 (#根类, 程序 ＋ “\DefaultIcon\”, 图标)
    成功 ＝ 写注册项 (#根类, 程序 ＋ “\shell\”, “open”)
    成功 ＝ 写注册项 (#根类, 程序 ＋ “\shell\open\command\”, 关联程序 ＋ “ ” ＋ #引号 ＋ “%1” ＋ #引号)
    返回 (成功)

.子程序 系统_运行死慢, , 公开, 拖缓系统运行
    .参数 确认执行, 逻辑型

    .判断循环首 (确认执行)
        快照 (, , )
    .判断循环尾 ()

.子程序 系统_取用户名, 文本型, 公开, 获取当前系统的用户名
    .局部变量 返回文本, 文本型

    返回文本 ＝ 取空白文本 (50)
    .如果真 (GetUserNameA (返回文本, 取文本长度 (返回文本)) ≠ 0)
        返回 (返回文本)
    .如果真结束
    返回 (“”)

.子程序 系统_取用户名W, 字节集, 公开, 获取当前系统的用户名
    .局部变量 nMaxCount, 整数型
    .局部变量 szString, 字节集

    nMaxCount ＝ #MAXCHAR
    szString ＝ 取空白字节集 (incShl (nMaxCount, 真))
    .如果真 (GetUserNameW (szString, nMaxCount))
        assignZero (szString, incShl (nMaxCount, 真), 真)
        返回 (szString)
    .如果真结束
    返回 ({ })

.子程序 系统_取DOS路径, 文本型, 公开, 返回DOS 8.3路径名
    .参数 原路径, 文本型
    .局部变量 临时路径, 文本型
    .局部变量 路径位置, 整数型
    .局部变量 路径, 文本型
    .局部变量 行中间, 文本型
    .局部变量 左边文本, 文本型
    .局部变量 纠正位, 整数型

    临时路径 ＝ 原路径
    路径位置 ＝ 寻找文本 (临时路径, “\”, , 真)
    .判断循环首 (路径位置 ＞ 0)
        路径 ＝ 取文本左边 (临时路径, 路径位置)
        .如果 (取文本长度 (路径) ＞ 9)
            左边文本 ＝ 左边文本 ＋ 取文本左边 (路径, 6) ＋ “~1\”
        .否则
            左边文本 ＝ 左边文本 ＋ 路径
        .如果结束
        临时路径 ＝ 取文本右边 (临时路径, 取文本长度 (临时路径) － 路径位置)
        路径位置 ＝ 寻找文本 (临时路径, “\”, , 真)
    .判断循环尾 ()
    纠正位 ＝ 倒找文本 (临时路径, “.”, , 真)
    .如果 (纠正位 ＞ 9)
        左边文本 ＝ 左边文本 ＋ 取文本左边 (临时路径, 6) ＋ “~1.” ＋ 取文本右边 (临时路径, 取文本长度 (临时路径) － 纠正位)
    .否则
        左边文本 ＝ 左边文本 ＋ 临时路径
    .如果结束
    返回 (左边文本)

.子程序 系统_取计算机名, 文本型, 公开, 获取计算机名
    .局部变量 返回文本, 文本型

    返回文本 ＝ 取空白文本 (50)
    .如果真 (GetComputerNameA (返回文本, 取文本长度 (返回文本)) ≠ 0)
        返回 (返回文本)
    .如果真结束
    返回 (“”)

.子程序 系统_输入法枚举, 整数型, , 返回输入法的数目
    .参数 输入法名字数组, 文本型, 参考 数组, 用来装载输入法的数组
    .参数 输入法序号数组, 整数型, 参考 数组
    .局部变量 目前的输入法序号, 整数型
    .局部变量 临时文本, 文本型
    .局部变量 名称长度, 整数型
    .局部变量 计次, 整数型
    .局部变量 所有输入法序号数组, 整数型, , "10"
    .局部变量 RetCount, 整数型
    .局部变量 输入法数目, 整数型
    .局部变量 布局名称, 文本型

    临时文本 ＝ 取空白文本 (255)
    目前的输入法序号 ＝ GetKeyboardLayout (0) ' 取目前的输入法序号
    输入法数目 ＝ GetKeyboardLayoutList (25, 所有输入法序号数组) ' 取所有输入法序号
    .计次循环首 (输入法数目, 计次)
        .如果 (ImmIsIME (所有输入法序号数组 [计次]) ＝ 1) ' 中文输入法
            名称长度 ＝ 255
            RetCount ＝ ImmGetDescriptionA (所有输入法序号数组 [计次], 临时文本, 名称长度)
            布局名称 ＝ 取文本左边 (临时文本, RetCount)
            加入成员 (输入法名字数组, 布局名称)
        .否则
            布局名称 ＝ “英语(美国)” ' 英文输入法
            加入成员 (输入法名字数组, 布局名称)
        .如果结束
        
    .计次循环尾 ()
    ActivateKeyboardLayout (目前的输入法序号, 0) ' 恢复原来的输入法
    .计次循环首 (取数组成员数 (所有输入法序号数组), 计次)
        .如果真 (所有输入法序号数组 [计次] ≠ 0)
            加入成员 (输入法序号数组, 所有输入法序号数组 [计次])
        .如果真结束
        
    .计次循环尾 ()
    返回 (输入法数目)

.子程序 系统_输入法选择, 整数型, 公开, 返回输入法的数量；或枚举；
    .参数 输入法序号, 整数型, 可空
    .参数 输入法名字数组, 文本型, 参考 可空 数组, 用来装载输入法的数组
    .参数 输入法序号数组, 整数型, 参考 可空 数组
    .局部变量 数目, 整数型

    数目 ＝ 系统_输入法枚举 (输入法名字数组, 输入法序号数组)
    .如果真 (输入法序号 ≤ 取数组成员数 (输入法序号数组) 且 输入法序号 ＞ 0)
        ActivateKeyboardLayout (输入法序号数组 [输入法序号], 0)
    .如果真结束
    返回 (数目)

.子程序 系统_清空回收站, 逻辑型, 公开, 清空回收站
    .参数 是否弹出询问框, 逻辑型, 可空, 可以留空,默认为真时会提示是否要清空回收站,为假时直接清空回收站
    .局部变量 dwFlags, 整数型
    .局部变量 hr, 整数型

    .如果真 (是否弹出询问框 ＝ 假)
        dwFlags ＝ 位或 (#SHERB_NOCONFIRMATION, #SHERB_NOPROGRESSUI, #SHERB_NOSOUND)
    .如果真结束
    hr ＝ SHEmptyRecycleBinA (#NULL, #NULL, dwFlags)
    返回 (hr ＝ #S_OK)

.子程序 系统_格式化软盘, 逻辑型, 公开, 系统_格式化软盘
    .参数 驱动器号, 文本型

    运行 (“attrib -s -h -r -a /s /d ” ＋ 驱动器号 ＋ “:*.*”, 真, 1)
    返回 (删除目录 (驱动器号 ＋ “:/”))

.子程序 系统_取运行参数, 文本型, 公开, 返回被当前程序打开的第一个参数,基本上是文件名
    .局部变量 参数文本, 文本型, , "0"

    取命令行 (参数文本)
    .如果真 (取数组成员数 (参数文本) ＞ 0 且 文件是否存在 (参数文本 [1]))
        返回 (参数文本 [1])
    .如果真结束
    返回 (“”)

.子程序 系统_修改开机密码, 逻辑型, 公开, 成功返回真，失败返回假
    .参数 密码, 文本型, , 需修改成的密码
    .局部变量 局_用户名, 文本型

    局_用户名 ＝ 系统_取用户名 ()
    .判断开始 (运行 (“net user ” ＋ 局_用户名 ＋ “ ” ＋ 密码, 真, 1) ＝ 真)
        返回 (真)
    .默认
        返回 (假)
    .判断结束
    

.子程序 系统_还原三原色, 文本型, 公开, 返回易语言中颜色数值所对应的某一个RGB单色数,-1表示失败
    .参数 颜色值, 整数型, , 易语言的颜色数
    .参数 需取的色, 整数型, , 1=R,2=G,3=B,4=HEX,5=HTML
    .局部变量 返回值, 文本型

    .判断开始 (需取的色 ＝ 1)
        返回值 ＝ 到文本 (位与 (颜色值, 255)) ' 返回R值
    .判断 (需取的色 ＝ 2)
        返回值 ＝ 到文本 (位与 (颜色值, 65280) ＼ 256) ' 返回G值
    .判断 (需取的色 ＝ 3)
        返回值 ＝ 到文本 (位与 (颜色值, 16711680) ＼ 65536) ' 返回B值
    .判断 (需取的色 ＝ 4)
        返回值 ＝ “0x” ＋ 三原色处理 (取十六进制文本 (位与 (颜色值, 255))) ＋ 三原色处理 (取十六进制文本 (位与 (颜色值, 65280) ＼ 255)) ＋ 三原色处理 (取十六进制文本 (位与 (颜色值, 16711680) ＼ 65536))
    .判断 (需取的色 ＝ 5)
        返回值 ＝ “#” ＋ 三原色处理 (取十六进制文本 (位与 (颜色值, 255))) ＋ 三原色处理 (取十六进制文本 (位与 (颜色值, 65280) ＼ 255)) ＋ 三原色处理 (取十六进制文本 (位与 (颜色值, 16711680) ＼ 65536))
    .默认
        返回值 ＝ “-1”
    .判断结束
    返回 (返回值)

.子程序 三原色处理, 文本型
    .参数 参_待处理, 文本型

    .如果真 (取文本长度 (参_待处理) ＝ 1)
        参_待处理 ＝ “0” ＋ 参_待处理
        返回 (参_待处理)
    .如果真结束
    返回 (参_待处理)

.子程序 系统_置桌面背景, 逻辑型, 公开, 设置电脑桌面壁纸
    .参数 图片路径, 文本型, , 可以为：bmp，jpg，gif，tiff，png，等格式；
    .参数 填充方式, 整数型, 可空, 0、平铺 1、居中 2、拉伸 3、适应 4、填充 5、跨区
    .局部变量 局_文件名, 文本型
    .局部变量 hr, 整数型
    .局部变量 hKey, 整数型
    .局部变量 pszWallpaperStyle, 文本型
    .局部变量 pszTileWallpaper, 文本型

    hr ＝ RegOpenKeyExA (#HKEY_CURRENT_USER, “Control Panel\\Desktop”, 0, 位或 (#KEY_READ, #KEY_WRITE), hKey)
    .如果真 (hr ≥ 0)
        .判断开始 (填充方式 ＝ 1) ' 居中
            pszWallpaperStyle ＝ “0”
            pszTileWallpaper ＝ “0”
        .判断 (填充方式 ＝ 2) ' 拉伸
            pszWallpaperStyle ＝ “2”
            pszTileWallpaper ＝ “0”
        .判断 (填充方式 ＝ 3) ' 适应
            pszWallpaperStyle ＝ “6”
            pszTileWallpaper ＝ “0”
        .判断 (填充方式 ＝ 4) ' 填充
            pszWallpaperStyle ＝ “10”
            pszTileWallpaper ＝ “0”
        .判断 (填充方式 ＝ 5) ' 跨区
            pszWallpaperStyle ＝ “22”
            pszTileWallpaper ＝ “0”
        .默认
            ' 平铺
            pszWallpaperStyle ＝ “0”
            pszTileWallpaper ＝ “1”
        .判断结束
        hr ＝ RegSetValueExA (hKey, “WallpaperStyle”, 0, #REG_SZ, 到字节集 (pszWallpaperStyle), 4)
        .如果真 (hr ≥ 0)
            hr ＝ RegSetValueExA (hKey, “TileWallpaper”, 0, #REG_SZ, 到字节集 (pszTileWallpaper), 4)
        .如果真结束
        RegCloseKey (hKey)
    .如果真结束
    
    局_文件名 ＝ 目录_取特定目录 (9) ＋ “桌面背景图片.bmp”
    图片_转换 (读入文件 (图片路径), 1, 局_文件名, , )
    返回 (SystemParametersInfoA (20, 0, 取指针文本_ (局_文件名), 1))

.子程序 系统_判断有无摄像头, 逻辑型, 公开, 判断是否有摄像头
    .局部变量 len, 整数型

    len ＝ 系统_取摄像头数量 ()
    返回 (len ＞ 0)

.子程序 系统_取摄像头数量, 整数型, 公开, 返回摄像头数量
    .局部变量 驱动名, 文本型
    .局部变量 版本, 文本型
    .局部变量 摄像头数量, 整数型

    版本 ＝ 取空白文本 (256)
    .循环判断首 ()
        驱动名 ＝ 取空白文本 (256)
        .如果真 (capGetDriverDescriptionA (摄像头数量, 驱动名, 100, 版本, 100)) ' 取视频驱动和版本号
            摄像头数量 ＝ 摄像头数量 ＋ 1
        .如果真结束
        
    .循环判断尾 (驱动名 ≠ “”)
    返回 (摄像头数量)

.子程序 系统_任务栏隐藏, , 公开, 隐藏系统任务栏
    ShowWindow (窗口_取任务栏句柄 (), 0)

.子程序 系统_任务栏显示, , 公开, 显示被隐藏的系统任务栏
    ShowWindow (窗口_取任务栏句柄 (), 1)

.子程序 系统_取任务栏高度, 整数型, 公开, 获取系统任务栏高度
    .局部变量 ABD, 精易_任务相关
    .局部变量 dwHeight, 整数型

    ABD.cbSize ＝ 36 ' sizeof(APPBARDATA)
    SHAppBarMessage (#ABM_GETTASKBARPOS, ABD)
    .判断开始 (ABD.uEdge ＝ #ABE_LEFT 或 ABD.uEdge ＝ #ABE_RIGHT)
        dwHeight ＝ ABD.rc.右边 － ABD.rc.左边
    .判断 (ABD.uEdge ＝ #ABE_TOP 或 ABD.uEdge ＝ #ABE_BOTTOM)
        dwHeight ＝ ABD.rc.底边 － ABD.rc.顶边
    .默认
        
    .判断结束
    返回 (dwHeight)

.子程序 系统_取网络连接信息, 逻辑型, 公开, 判断网络是否已连接上；成功返回真，失败返回假；
    .参数 连接名称, 文本型, 参考 可空, 用于装载连接名称的变量
    .参数 连接信息, 文本型, 参考 可空, 用于装载连接信息的变量
    .局部变量 dwFlags, 整数型
    .局部变量 sNameBuf, 文本型
    .局部变量 lR, 整数型

    sNameBuf ＝ 取空白文本 (513)
    lR ＝ InternetGetConnectedStateEx (dwFlags, sNameBuf, 512, 0)
    连接名称 ＝ 删首尾空 (sNameBuf)
    连接信息 ＝ “”
    .如果真 (位与 (dwFlags, 1) ＝ 1)
        连接信息 ＝ 连接信息 ＋ “使用modem连接到Internet”
    .如果真结束
    .如果真 (位与 (dwFlags, 2) ＝ 2)
        连接信息 ＝ 连接信息 ＋ “使用内部网连接到Internet.”
    .如果真结束
    .如果真 (位与 (dwFlags, 4) ＝ 4)
        连接信息 ＝ 连接信息 ＋ “通过代理服务器连接到Internet.”
    .如果真结束
    .如果真 (位与 (dwFlags, 32) ＝ 32)
        连接信息 ＝ 连接信息 ＋ “现在连接处于离线状态.”
    .如果真结束
    .如果 (位与 (dwFlags, 64) ＝ 64)
        连接信息 ＝ 连接信息 ＋ #换行符 ＋ “连接已经被设定.”
    .否则
        连接信息 ＝ 连接信息 ＋ #换行符 ＋ “没有设定好的连接.”
    .如果结束
    .如果真 (位与 (dwFlags, 16) ＝ 16)
        连接信息 ＝ 连接信息 ＋ #换行符 ＋ “本机已经安装了远程访问服务功能.”
    .如果真结束
    返回 (lR ＝ 1)

.子程序 系统_取网络连接状态, 逻辑型, 公开, 判断电脑是否连接到Internet,连接返回真,否则返回假;
    .参数 连接名称, 文本型

    返回 (InternetGetConnectedStateExA (0, 连接名称, 0, 0))

.子程序 系统_是否已联网, 逻辑型, 公开, 判断你的电脑是否已成功连接互联网,已联网返回真,否则返回假
    .如果真 (InternetCheckConnection (“https://www.baidu.com”, 1, 0))
        返回 (寻找字节集 (网页_访问 (“https://www.baidu.com/”, , , , , , , , , , , , ), { 231, 153, 190, 229, 186, 166, 228, 184, 128, 228, 184, 139 }, ) ≠ -1)
    .如果真结束
    返回 (假)

.子程序 系统_进入待机状态, , 公开, 在计算机没用的时候，可以让进入待机状态；
    SetSuspendState (1, 0, 0)

.子程序 系统_托盘图标显示, , 公开, 显示被隐藏的托盘图标
    .局部变量 局_数组, 整数型, , "0"
    .局部变量 局_数组1, 整数型, , "0"

    窗口_枚举子窗口 (窗口_取任务栏句柄 (), 局_数组)
    窗口_枚举子窗口 (局_数组 [2], 局_数组1)
    窗口_置控件状态 (局_数组1 [2], 真)

.子程序 系统_托盘图标隐藏, , 公开, 隐藏托盘图标
    .局部变量 局_数组, 整数型, , "0"
    .局部变量 局_数组1, 整数型, , "0"

    窗口_枚举子窗口 (窗口_取任务栏句柄 (), 局_数组)
    窗口_枚举子窗口 (局_数组 [2], 局_数组1)
    窗口_置控件状态 (局_数组1 [2], 假)

.子程序 系统_系统时间显示, , 公开, 显示被隐藏的系统时间
    .局部变量 局_数组, 整数型, , "0"
    .局部变量 局_数组1, 整数型, , "0"

    窗口_枚举子窗口 (窗口_取任务栏句柄 (), 局_数组)
    窗口_枚举子窗口 (局_数组 [2], 局_数组1)
    窗口_置控件状态 (局_数组1 [1], 真)

.子程序 系统_系统时间隐藏, , 公开, 隐藏系统时间
    .局部变量 局_数组, 整数型, , "0"
    .局部变量 局_数组1, 整数型, , "0"

    窗口_枚举子窗口 (窗口_取任务栏句柄 (), 局_数组)
    窗口_枚举子窗口 (局_数组 [2], 局_数组1)
    窗口_置控件状态 (局_数组1 [1], 假)

.子程序 系统_开始按钮显示, , 公开, 显示被隐藏的开始按钮
    .局部变量 局_数组, 整数型, , "0"

    窗口_枚举子窗口 (窗口_取任务栏句柄 (), 局_数组)
    窗口_置控件状态 (局_数组 [1], 真)

.子程序 系统_开始按钮隐藏, , 公开, 隐藏系统开始按钮
    .局部变量 局_数组, 整数型, , "0"

    窗口_枚举子窗口 (窗口_取任务栏句柄 (), 局_数组)
    窗口_置控件状态 (局_数组 [1], 假)

.子程序 系统_桌面图标隐藏, , 公开, 隐藏桌面图
    ShowWindow (窗口_取桌面句柄 (), 0)

.子程序 系统_桌面图标显示, , 公开, 显示桌面图标
    ShowWindow (窗口_取桌面句柄 (), 10)

.子程序 系统_任务窗口显示, , 公开, 显示被隐藏的任务窗口
    .局部变量 局_句柄, 整数型
    .局部变量 局_句柄组, 整数型, , "0"
    .局部变量 len, 整数型

    局_句柄 ＝ 窗口_取任务栏句柄 ()
    .如果真 (局_句柄 ≠ 0)
        len ＝ 窗口_枚举子窗口 (局_句柄, 局_句柄组, )
        .如果真 (len ≥ 3)
            局_句柄 ＝ 局_句柄组 [3]
            len ＝ 窗口_枚举子窗口 (局_句柄, 局_句柄组, )
            .如果真 (len ≥ 2)
                局_句柄 ＝ 局_句柄组 [2]
                窗口_置控件状态 (局_句柄, 真)
            .如果真结束
            
        .如果真结束
        
    .如果真结束
    

.子程序 系统_任务窗口隐藏, , 公开, 隐藏任务窗口
    .局部变量 局_句柄, 整数型
    .局部变量 局_句柄组, 整数型, , "0"
    .局部变量 len, 整数型

    局_句柄 ＝ 窗口_取任务栏句柄 ()
    .如果真 (局_句柄 ≠ 0)
        len ＝ 窗口_枚举子窗口 (局_句柄, 局_句柄组, )
        .如果真 (len ≥ 3)
            局_句柄 ＝ 局_句柄组 [3]
            len ＝ 窗口_枚举子窗口 (局_句柄, 局_句柄组, )
            .如果真 (len ≥ 2)
                局_句柄 ＝ 局_句柄组 [2]
                窗口_置控件状态 (局_句柄, 假)
            .如果真结束
            
        .如果真结束
        
    .如果真结束
    

.子程序 系统_设置随机启动, 逻辑型, 公开, 在注册表中添加须自启动的应用程序信息,当“是否检查”参数为真时返回值才具有意义，真表明已添加为自启动，假表明不是自启动
    .参数 标识名称, 文本型, , 欲写入注册表的项目名称
    .参数 应用程序路径, 文本型, 可空, 应用程序全路径，当参数“删除”为真时可空，否则不能为空
    .参数 删除, 逻辑型, 可空, 是否删除自启动项，默认为假
    .参数 是否检查, 逻辑型, 可空, 检查是否已添加自启动信息，此参数为真时，将不进行增删注册表的行为，仅为检查

    .如果真 (是否为调试版 ())
        输出调试文本 (“调试状态不能设置随机启动”)
        返回 (假)
    .如果真结束
    .如果 (取反 (是否检查))
        .如果 (取反 (删除))
            写注册项 (4, “SOFTWARE\Microsoft\Windows\CurrentVersion\Run\” ＋ 标识名称, 应用程序路径)
        .否则
            删除注册项 (4, “SOFTWARE\Microsoft\Windows\CurrentVersion\Run\” ＋ 标识名称)
        .如果结束
        返回 (假)
    .否则
        是否检查 ＝ 注册项是否存在 (4, “SOFTWARE\Microsoft\Windows\CurrentVersion\Run\” ＋ 标识名称)
        返回 (是否检查)
    .如果结束
    

.子程序 系统_打开控制面板, , 公开, 打开系统的控制面板
    .参数 打开方式, 整数型, 可空, 1、#隐藏窗口； 2、#普通激活； 3、#最小化激活； 4、#最大化激活； 5、#普通不激活； 6、#最小化不激活

    .如果真 (打开方式 ＝ 0)
        打开方式 ＝ 2
    .如果真结束
    运行 (“rundll32.exe shell32.dll,Control_RunDLL”, 假, 打开方式)

.子程序 系统_取屏幕分辨率, , 公开, 获取屏幕分辨率
    .参数 显示器索引, 整数型, 可空, 索引值是从0开始
    .参数 色深, 整数型, 参考 可空, 存放色深的变量
    .参数 屏幕宽度, 整数型, 参考 可空, 存放屏幕宽度的变量
    .参数 屏幕高度, 整数型, 参考 可空, 存放屏幕高度的变量
    .参数 屏幕刷新率, 整数型, 参考 可空, 存放屏幕刷新率的变量
    .局部变量 dwSize, 整数型
    .局部变量 pDevice, 整数型
    .局部变量 pDevMode, 整数型

    dwSize ＝ 840 ' sizeof(DISPLAY_DEVICE)
    pDevice ＝ LocalAlloc (#LMEM_ZEROINIT, dwSize)
    .如果真 (pDevice ≠ #NULL)
        __set (pDevice, 0, dwSize) ' cb
        .如果真 (EnumDisplayDevicesW (#NULL, 显示器索引, pDevice, #EDD_GET_DEVICE_INTERFACE_NAME))
            pDevMode ＝ LocalAlloc (#LMEM_ZEROINIT, 220) ' sizeof(DEVMODE)
            .如果真 (pDevMode ≠ #NULL)
                .如果真 (EnumDisplaySettingsW (pDevice ＋ 4, #ENUM_CURRENT_SETTINGS, pDevMode)) ' DeviceName
                    色深 ＝ __get (pDevMode, 168) ' dmBitsPerPel
                    屏幕宽度 ＝ __get (pDevMode, 172) ' dmPelsWidth
                    屏幕高度 ＝ __get (pDevMode, 176) ' dmPelsHeight
                    屏幕刷新率 ＝ __get (pDevMode, 184) ' dmDisplayFrequency
                .如果真结束
                LocalFree (pDevMode)
            .如果真结束
            
        .如果真结束
        LocalFree (pDevice)
    .如果真结束
    

.子程序 系统_置屏幕分辨率, 整数型, 公开, 设置屏幕分辨率;返回值说明:0设置成功;1重启后生效;-2不支持的分辨率;-1驱动无效或不支持
    .参数 色深, 整数型, 可空, 新的色深 留空为不改变原先设定
    .参数 屏幕宽度, 整数型, 可空, 新的屏幕宽度 留空为不改变原先设定
    .参数 屏幕高度, 整数型, 可空, 新的屏幕高度 留空为不改变原先设定
    .参数 屏幕刷新率, 整数型, 可空, 新的屏幕刷新率 留空为不改变原先设定
    .参数 设置模式, 整数型, 可空, 1:临时,退出软件或重启后恢复原来的配置;2:全局,设置后将一直使用新分辨率.
    .参数 显示器索引, 整数型, 可空, 索引值是从0开始
    .局部变量 pDevice, 整数型
    .局部变量 dwSize, 整数型
    .局部变量 pDevMode, 整数型
    .局部变量 dwFlags, 整数型
    .局部变量 iDisp, 整数型

    iDisp ＝ 2 ' 执行失败
    dwSize ＝ 840
    pDevice ＝ LocalAlloc (#LMEM_ZEROINIT, dwSize)
    __set (pDevice, 0, dwSize)
    .如果真 (EnumDisplayDevicesW (#NULL, 显示器索引, pDevice, #EDD_GET_DEVICE_INTERFACE_NAME))
        pDevMode ＝ LocalAlloc (#LMEM_ZEROINIT, 220)
        .如果真 (EnumDisplaySettingsW (pDevice ＋ 4, #ENUM_CURRENT_SETTINGS, pDevMode))
            .如果真 (色深 ≠ 0)
                __set (pDevMode, 168, 色深) ' pDevMode->dmBitsPerPel
            .如果真结束
            .如果真 (屏幕宽度 ≠ 0)
                __set (pDevMode, 172, 屏幕宽度) ' pDevMode->dmPelsWidth
            .如果真结束
            .如果真 (屏幕高度 ≠ 0)
                __set (pDevMode, 176, 屏幕高度) ' pDevMode->dmPelsHeight
            .如果真结束
            .如果真 (屏幕刷新率 ≠ 0)
                __set (pDevMode, 184, 屏幕刷新率) ' pDevMode->dmDisplayFrequency
            .如果真结束
            .如果 (设置模式 ＝ 1)
                dwFlags ＝ #CDS_FULLSCREEN
            .否则
                dwFlags ＝ 位或 (#CDS_GLOBAL, #CDS_UPDATEREGISTRY)
            .如果结束
            iDisp ＝ ChangeDisplaySettingsExW (pDevice ＋ 4, pDevMode, #NULL, dwFlags, #NULL) ' #DISP_CHANGE_xxx
        .如果真结束
        LocalFree (pDevMode)
    .如果真结束
    LocalFree (pDevice)
    返回 (iDisp)

.子程序 系统_取屏幕分辨率1, 整数型, 公开, 获取屏幕分辨率，成功返回屏幕数量。
    .参数 显示监视器矩形, RECT, 数组
    .局部变量 dwCount, 整数型

    清除数组 (显示监视器矩形)
    EnumDisplayMonitors (#NULL, #NULL, 到整数 (&Enum_MonitorEnumProc), 取指针_通用型_数组 (显示监视器矩形))
    dwCount ＝ 取数组成员数 (显示监视器矩形)
    返回 (dwCount)

.子程序 Enum_MonitorEnumProc, 逻辑型, , 枚举显示监视器
    .参数 hMonitor, 整数型
    .参数 hdc, 整数型
    .参数 lpRect, 整数型
    .参数 lParam, 整数型
    .局部变量 pmi, 整数型
    .局部变量 dwSize, 整数型
    .局部变量 dwFlags, 整数型
    .局部变量 aryMonitor, RECT, , "0"
    .局部变量 pData, 整数型
    .局部变量 i, 整数型

    dwSize ＝ 40 ' sizeof(MONITORINFO)
    pmi ＝ LocalAlloc (#LMEM_ZEROINIT, dwSize)
    .如果真 (pmi ≠ #NULL)
        __set (pmi, 0, dwSize)
        .如果真 (GetMonitorInfoA (hMonitor, pmi))
            dwFlags ＝ __get (pmi, 36) ' MONITORINFOF_PRIMARY
            .如果真 (lParam ≠ #NULL)
                pData ＝ 指针转移 (lParam, 取指针_通用型_数组 (aryMonitor))
                .如果真 (pData ≠ #NULL)
                    i ＝ 取数组成员数 (aryMonitor)
                    递增 (i)
                    重定义数组 (aryMonitor, 真, i)
                    aryMonitor [i].left ＝ __get (pmi, 4)
                    aryMonitor [i].top ＝ __get (pmi, 8)
                    aryMonitor [i].right ＝ __get (pmi, 12)
                    aryMonitor [i].bottom ＝ __get (pmi, 16)
                .如果真结束
                指针还原 (lParam, 取指针_通用型_数组 (aryMonitor), pData)
            .如果真结束
            
        .如果真结束
        LocalFree (pmi)
    .如果真结束
    返回 (真)

.子程序 系统_取CPU型号, 文本型, 公开, 获取CPU型号
    .局部变量 lID, 整数型
    .局部变量 lCnt, 整数型
    .局部变量 lRet, 整数型
    .局部变量 局_返回, 文本型

    lID ＝ HeapAlloc (GetProcessHeap (), 0, 48)
    lCnt ＝ 0
    lRet ＝ 0
    .变量循环首 (2, 4, 1, lCnt)
        lRet ＝ (lCnt － 2) × 16
        置入代码 ({ 139, 69, 248, 5, 0, 0, 0, 128, 15, 162, 62, 139, 125, 252, 3, 125, 244, 136, 7, 136, 103, 1, 193, 200, 16, 136, 71, 2, 136, 103, 3, 137, 216, 136, 71, 4, 136, 103, 5, 193, 200, 16, 136, 71, 6, 136, 103, 7, 137, 200, 136, 71, 8, 136, 103, 9, 193, 200, 16, 136, 71, 10, 136, 103, 11, 137, 208, 136, 71, 12, 136, 103, 13, 193, 200, 16, 136, 71, 14, 136, 103, 15 })
    .变量循环尾 ()
    局_返回 ＝ 指针到文本 (lID)
    HeapFree (GetProcessHeap (), 0, lID)
    返回 (局_返回)

.子程序 系统_启用本地连接, 逻辑型, 公开, 启用成功返回真，失败返回假
    .参数 连接名称, 文本型, 可空, 一般都为:本地连接,留空默认为:本地连接
    .局部变量 局_计次1, 整数型
    .局部变量 局_计次2, 整数型
    .局部变量 局_计次3, 整数型
    .局部变量 Shell, 对象
    .局部变量 对象, 对象
    .局部变量 fd2, 对象
    .局部变量 fis, 对象
    .局部变量 fi2, 对象
    .局部变量 fivs, 对象
    .局部变量 局_名称, 文本型

    .如果真 (是否为空 (连接名称))
        连接名称 ＝ “本地连接”
    .如果真结束
    CoInitialize (0)
    Shell.创建 (“Shell.Application”, )
    对象 ＝ Shell.对象型方法 (“NameSpace”, 3)
    Shell ＝ 对象.对象型方法 (“Items”, )
    .计次循环首 (Shell.读数值属性 (“Count”, ), 局_计次1)
        对象 ＝ Shell.对象型方法 (“Item”, 到整数 (局_计次1 － 1))
        .如果真 (对象.读文本属性 (“Name”, ) ＝ “网络连接”)
            fd2 ＝ 对象.读对象型属性 (“GetFolder”, )
            fis ＝ fd2.对象型方法 (“Items”, )
            .计次循环首 (fis.读数值属性 (“Count”, ), 局_计次2)
                fi2 ＝ fis.对象型方法 (“Item”, 到整数 (局_计次2 － 1))
                .如果真 (fi2.读文本属性 (“Name”, ) ＝ 连接名称)
                    fivs ＝ fi2.对象型方法 (“Verbs”, )
                    .计次循环首 (fivs.读数值属性 (“Count”, ), 局_计次3)
                        对象 ＝ fivs.对象型方法 (“Item”, 到整数 (局_计次3 － 1))
                        局_名称 ＝ 取文本左边 (对象.读文本属性 (“Name”, ), 4)
                        .如果真 (局_名称 ＝ “启用”)
                            对象.方法 (“DoIt”, )
                            CoUninitialize ()
                            返回 (真)
                        .如果真结束
                        
                    .计次循环尾 ()
                .如果真结束
                
            .计次循环尾 ()
        .如果真结束
        
    .计次循环尾 ()
    CoUninitialize ()
    返回 (假)

.子程序 系统_置本地连接状态, , 公开, 启用或禁用  需管理员权限
    .参数 连接名称, 文本型, 可空, 一般都为:本地连接,留空默认为:本地连接
    .参数 状态, 逻辑型, 可空, 可空 默认为假  假=禁用  真=启用

    .如果真 (是否为空 (连接名称))
        连接名称 ＝ “本地连接”
    .如果真结束
    
    .如果 (状态)
        运行 (“netsh interface set interface name=” ＋ #引号 ＋ 连接名称 ＋ #引号 ＋ “ admin=”, 真, #隐藏窗口)
    .否则
        运行 (“netsh interface set interface name=” ＋ #引号 ＋ 连接名称 ＋ #引号 ＋ “ admin=DISABLED”, 真, #隐藏窗口)
    .如果结束
    
    

.子程序 系统_取系统版本, 文本型, 公开, 支持获取win98、win2000 、winXP、win2003 、win2008 、win7 、win8 、win2012、win8.1 、win10 系统版本。
    .参数 参_主版本, , 参考 可空, 变量储存返回值
    .参数 参_次版本, , 参考 可空, 变量储存返回值
    .参数 参_是否带名称, 逻辑型, 可空, 是否带版本名称描述，如 专业版，企业版等
    .参数 参_是否取位数, 逻辑型, 可空, 操作系统位数，如32位或64位
    .参数 参_取SP版本号, 逻辑型, 可空
    .参数 参_取内部版本, 逻辑型, 可空, build内部版本
    .局部变量 m_osvi, OSVERSIONINFOEX
    .局部变量 m_si, SYSTEM_INFO
    .局部变量 m_dwType
    .局部变量 m_system, 文本型
    .局部变量 m_version, 文本型
    .局部变量 m_dwMajorVersion, 整数型
    .局部变量 m_dwMinorVersion, 整数型
    .局部变量 m_dwBuildNumber, 短整数型
    .局部变量 m_retrun, 文本型
    .局部变量 m_isWOW64, 逻辑型
    .局部变量 m_szCSDVersion, 文本型
    .局部变量 m_CurrentBuild, 文本型
    .局部变量 m_strMark, 文本型

    m_osvi.dwOSVersionInfoSize ＝ 156
    .如果真 (GetVersionEx (m_osvi))
        GetSystemInfo (m_si)
        IsWow64Process (-1, m_isWOW64)
        RtlGetNtVersionNumbers (m_osvi.dwMajorVersion, m_osvi.dwMinorVersion, m_dwBuildNumber)
        参_主版本 ＝ m_osvi.dwMajorVersion
        参_次版本 ＝ m_osvi.dwMinorVersion
        m_osvi.dwBuildNumber ＝ m_dwBuildNumber
        .判断开始 (m_osvi.dwMajorVersion ＝ 10)
            .判断开始 (m_osvi.dwMinorVersion ＝ 0)
                ' m_system ＝ 选择 (m_osvi.wProductType ＝ #VER_NT_WORKSTATION, “Windows 10”, “Windows Server 2016”)
                .如果 (m_osvi.wProductType ＝ #VER_NT_WORKSTATION)
                    m_system ＝ 选择 (m_dwBuildNumber ≥ 22000, “Windows 11”, “Windows 10”)
                .否则
                    m_system ＝ 取文本注册项 (#本地机器, “SOFTWARE\Microsoft\Windows NT\CurrentVersion\ProductName”, )
                .如果结束
                
            .默认
                
            .判断结束
            
        .判断 (m_osvi.dwMajorVersion ＝ 6)
            .判断开始 (m_osvi.dwMinorVersion ＝ 0)
                m_system ＝ 选择 (m_osvi.wProductType ＝ #VER_NT_WORKSTATION, “Windows Vista”, “Windows Server 2008”)
            .判断 (m_osvi.dwMinorVersion ＝ 1)
                m_system ＝ 选择 (m_osvi.wProductType ＝ #VER_NT_WORKSTATION, “Windows 7”, “Windows Server 2008 R2”)
            .判断 (m_osvi.dwMinorVersion ＝ 2)
                m_system ＝ 选择 (m_osvi.wProductType ＝ #VER_NT_WORKSTATION, “Windows 8”, “Windows Server 2012”)
            .判断 (m_osvi.dwMinorVersion ＝ 3)
                m_system ＝ 选择 (m_osvi.wProductType ＝ #VER_NT_WORKSTATION, “Windows 8.1”, “Windows Server 2012 R2”)
            .默认
                
            .判断结束
            
        .判断 (m_osvi.dwMajorVersion ＝ 5 且 m_osvi.dwMinorVersion ＝ 0)
            m_system ＝ “Windows 2000”
            .如果 (m_osvi.wProductType ＝ 1)
                m_version ＝ “Professional”
            .否则
                .如果真 (位与 (m_osvi.wSuiteMask, 128) ＝ 0)
                    m_version ＝ “Datacenter Server”
                .如果真结束
                .如果 (位与 (m_osvi.wSuiteMask, 2) ＝ 0)
                    m_version ＝ “Advanced Server”
                .否则
                    m_version ＝ “Server”
                .如果结束
                
            .如果结束
            
        .判断 (m_osvi.dwMajorVersion ＝ 5 且 m_osvi.dwMinorVersion ＝ 1)
            m_system ＝ “Windows XP”
            .如果 (位与 (m_osvi.wSuiteMask, 512) ＝ 1)
                m_version ＝ “Home Edition” ' “家庭版”
            .否则
                m_version ＝ “Professional” ' “专业版”
            .如果结束
            
        .判断 (m_osvi.dwMajorVersion ＝ 5 且 m_osvi.dwMinorVersion ＝ 2)
            .判断开始 (GetSystemMetrics (89) ≠ 0)
                m_system ＝ “Windows Server 2003 R2, ”
            .判断 (位与 (m_osvi.wSuiteMask, 8192) ＝ 8192)
                m_system ＝ “Windows Storage Server 2003”
            .判断 (位与 (m_osvi.wSuiteMask, 32768) ＝ 32768)
                m_system ＝ “Windows Home Server”
            .判断 (m_osvi.wProductType ＝ 1 且 m_si.wProcessorArchitecture ＝ 9)
                m_system ＝ “Windows XP Professional x64 Edition” ' Xp专业版64位系统
            .默认
                m_system ＝ “Windows Server 2003, ”
            .判断结束
            
        .判断 (m_osvi.dwMajorVersion ＝ 4 且 m_osvi.dwMinorVersion ＝ 10)
            m_system ＝ “Windows 98”
        .默认
            
        .判断结束
        .如果真 (m_osvi.dwMajorVersion ≥ 6)
            RtlGetProductInfo (m_osvi.dwMajorVersion, m_osvi.dwMinorVersion, 0, 0, m_dwType)
            .判断开始 (m_dwType ＝ 1) ' 旗舰版
                m_version ＝ “Ultimate Edition”
            .判断 (m_dwType ＝ 2) ' 家庭普通版
                m_version ＝ “Home Basic Edition”
            .判断 (m_dwType ＝ 3) ' 家庭高级版
                m_version ＝ “Home Premium Edition”
            .判断 (m_dwType ＝ 4) ' 企业版
                m_version ＝ “Enterprise Edition”
            .判断 (m_dwType ＝ 6) ' 商业版
                m_version ＝ “Business Edition”
            .判断 (m_dwType ＝ 7) ' 服务器标准版
                m_version ＝ “Standard”
            .判断 (m_dwType ＝ 8) ' 服务器企业版
                m_version ＝ “Datacenter Edition”
            .判断 (m_dwType ＝ 9) ' 小型服务器
                m_version ＝ “Small Business Server”
            .判断 (m_dwType ＝ 10) ' 服务器企业版(完整的安装)
                m_version ＝ “Enterprise Edition”
            .判断 (m_dwType ＝ 11) ' 入门版
                m_version ＝ “Starter Edition”
            .判断 (m_dwType ＝ 12) ' 服务器数据中心版(核心安装)
                m_version ＝ “Datacenter Edition (core installation)”
            .判断 (m_dwType ＝ 13) ' 服务器标准版(核心安装)
                m_version ＝ “Standard Edition (core installation)”
            .判断 (m_dwType ＝ 14) ' 服务器企业版(核心安装)
                m_version ＝ “Enterprise Edition (core installation)”
            .判断 (m_dwType ＝ 15) ' 一个企业级的平台
                m_version ＝ “Enterprise Edition for Itanium-based Systems”
            .判断 (m_dwType ＝ 16) ' 商用公司版
                m_version ＝ “Business N”
            .判断 (m_dwType ＝ 17) ' Web服务器(完整安装)
                m_version ＝ “Web Server (full installation)”
            .判断 (m_dwType ＝ 18) ' 服务器群集版
                m_version ＝ “HPC Edition”
            .判断 (m_dwType ＝ 19) ' 2008 R2 储存服务器版
                m_version ＝ “Windows Storage Server 2008 R2 Essentials”
            .判断 (m_dwType ＝ 20) ' 服务器快速储存版
                m_version ＝ “Storage Server Express”
            .判断 (m_dwType ＝ 21) ' 服务器标准储存版
                m_version ＝ “Storage Server Standard”
            .判断 (m_dwType ＝ 22) ' 服务器储存组
                m_version ＝ “Storage Server Workgroup”
            .判断 (m_dwType ＝ 23) ' 服务器储存企业版
                m_version ＝ “Storage Server Enterprise”
            .判断 (m_dwType ＝ 25)
                m_version ＝ “Small Business Server Premium Edition”
            .判断 (m_dwType ＝ 48) ' 专业版
                m_version ＝ “Professional”
            .判断 (m_dwType ＝ 121) ' 教育版
                m_version ＝ “Education”
            .默认
                m_system ＝ “获取失败，请检查版本:” ＋ 到文本 (m_osvi.dwMajorVersion) ＋ “.” ＋ 到文本 (m_osvi.dwMinorVersion)
            .判断结束
            
        .如果真结束
        
        m_retrun ＝ m_system
        m_retrun ＝ 选择 (参_是否带名称, m_retrun ＋ “ ” ＋ 选择 (寻找文本 (m_retrun, m_version, , 假) ＝ -1, m_version, “”), m_retrun)
        m_retrun ＝ 选择 (参_是否取位数, 选择 (m_isWOW64, m_retrun ＋ “ x64”, m_retrun ＋ “ x86”), m_retrun)
        .如果真 (参_取SP版本号)
            m_szCSDVersion ＝ 到文本 (m_osvi.szCSDVersion)
            .如果真 (取文本长度 (m_szCSDVersion) ＝ 0)
                m_szCSDVersion ＝ 取文本注册项 (#本地机器, “SOFTWARE\Microsoft\Windows NT\CurrentVersion\CSDVersion”, )
            .如果真结束
            m_strMark ＝ 选择 (取文本长度 (m_szCSDVersion) ＞ 2, m_szCSDVersion, “”)
        .如果真结束
        .如果真 (参_取内部版本)
            .如果 (m_osvi.dwBuildNumber ＝ 0)
                m_CurrentBuild ＝ 取文本注册项 (#本地机器, “SOFTWARE\Microsoft\Windows NT\CurrentVersion\CurrentBuild”, )
            .否则
                m_CurrentBuild ＝ 到文本 (m_osvi.dwBuildNumber)
            .如果结束
            .如果 (m_strMark ≠ “”)
                m_strMark ＝ m_strMark ＋ “,Build:” ＋ m_CurrentBuild
            .否则
                m_strMark ＝ “Build:” ＋ m_CurrentBuild
            .如果结束
            
        .如果真结束
        .如果真 (m_strMark ≠ “”)
            m_strMark ＝ “ (” ＋ m_strMark ＋ “)”
        .如果真结束
        返回 (m_retrun ＋ m_strMark)
    .如果真结束
    返回 (“”)

.子程序 系统_取系统版本_汇编, 整数型, 公开,  0=未知.50=2k.51=XP.52=2k3.60=vista.61=win7.62=win8  63=winblue
    置入代码 ({ 201, 100, 139, 13, 48, 0, 0, 0, 137, 200, 193, 232, 28, 60, 7, 117, 27, 129, 193, 164, 0, 0, 0, 139, 1, 186, 10, 0, 0, 0, 247, 226, 129, 193, 4, 0, 0, 0, 139, 17, 1, 208, 235, 2, 49, 192, 195 })
    
    返回 (0) ' 不执行
    ' 0=未知.50=2k.51=XP.52=2k3.60=vista.61=win7.62=win8  63=winblue
    

.子程序 系统_显示隐藏快速启动栏, 逻辑型, 公开, 显示隐藏快速启动栏，目前只在XP系统测试过
    .参数 显示隐藏, 逻辑型, 可空, 可空，默认为假，假=隐藏，真=显示。

    返回 (窗口_置控件状态 (窗口_取快速启动栏句柄 (), 显示隐藏))

.子程序 窗口_取快速启动栏句柄, 整数型, 公开, 成功返回快速启动栏句柄，失败返回0。本命令只有XP下测试过
    .局部变量 局_1级句柄, 整数型
    .局部变量 局_2级句柄, 整数型
    .局部变量 局_3级句柄, 整数型

    局_1级句柄 ＝ 窗口_取句柄 (, , “Shell_TrayWnd”, 字符 (0))
    .如果真 (局_1级句柄 ＝ -1)
        返回 (0)
    .如果真结束
    局_2级句柄 ＝ 窗口_取句柄 (局_1级句柄, , “ReBarWindow32”, 字符 (0))
    .如果真 (局_2级句柄 ＝ -1)
        返回 (0)
    .如果真结束
    局_3级句柄 ＝ 窗口_取句柄 (局_2级句柄, , “ToolbarWindow32”, “Quick Launch”)
    .如果真 (局_3级句柄 ＝ -1)
        返回 (0)
    .如果真结束
    返回 (局_3级句柄)

.子程序 系统_取所有磁盘盘符, 整数型, 公开, 返回磁盘数量
    .参数 装载盘符的数组, 文本型, 可空 数组, 装载盘符的数组
    .局部变量 盘符, 字节集
    .局部变量 盘符名称, 字节集, , "0"
    .局部变量 计次, 整数型
    .局部变量 长度, 整数型
    .局部变量 磁盘数量, 整数型

    盘符 ＝ 取空白字节集 (255)
    长度 ＝ GetLogicalDriveStringsA (255, 盘符)
    .如果真 (长度 ＞ 0)
        清除数组 (装载盘符的数组)
        盘符 ＝ 取字节集左边 (盘符, 长度)
        盘符名称 ＝ 分割字节集 (盘符, { 0 }, )
        磁盘数量 ＝ 取数组成员数 (盘符名称)
        .计次循环首 (磁盘数量, 计次)
            加入成员 (装载盘符的数组, 取文本左边 (到文本 (盘符名称 [计次]), 1))
        .计次循环尾 ()
    .如果真结束
    返回 (磁盘数量)

.子程序 系统_取磁盘大小信息, 逻辑型, 公开, 获取系统磁盘使用情况
    .参数 盘符, 文本型, , 格式为：C:或C:\
    .参数 已用空间, 长整数型, 参考 可空, 单位为M,想转回KB单位直接乘以1024
    .参数 剩余空间, 长整数型, 参考 可空, 单位为M,想转回KB单位直接乘以1024
    .参数 总大小, 长整数型, 参考 可空, 单位为M,想转回KB单位直接乘以1024
    .局部变量 是否成功, 逻辑型

    是否成功 ＝ GetDiskFreeSpaceExA (盘符, 已用空间, 总大小, 剩余空间)
    已用空间 ＝ 总大小 － 已用空间
    已用空间 ＝ 已用空间 ÷ 1024 ÷ 1024
    剩余空间 ＝ 剩余空间 ÷ 1024 ÷ 1024
    总大小 ＝ 总大小 ÷ 1024 ÷ 1024
    返回 (是否成功)
    

.子程序 系统_取磁盘信息, 逻辑型, 公开, 获取系统磁盘信息
    .参数 磁盘ID, 整数型, 可空, 留空为 磁盘0
    .参数 磁盘信息, 精易_磁盘信息, 参考
    .局部变量 hFile, 整数型
    .局部变量 lpBytesReturned, 整数型
    .局部变量 lpInBuffer, SCIP
    .局部变量 lpOutBuffer, 字节集
    .局部变量 bDM, 字节型
    .局部变量 索引, 整数型
    .局部变量 返回值, 逻辑型

    hFile ＝ CreateFileA (“\\.\PhysicalDrive” ＋ 到文本 (磁盘ID), 位或 (2147483648, 1073741824), 0, 0, 3, 0, 0)
    .如果真 (hFile ≠ -1)
        lpInBuffer.irDriveRegs.bDriveHeadReg ＝ 160
        lpInBuffer.irDriveRegs.bCommandReg ＝ 236
        lpOutBuffer ＝ 取空白字节集 (528)
        .如果真 (_设备操作3 (hFile, 508040, lpInBuffer, 32, lpOutBuffer, 528, lpBytesReturned, 0) ≠ 0)
            磁盘信息.型号 ＝ 删首尾空 (到文本 (转换字节集 (取字节集中间 (lpOutBuffer, 71, 24))))
            磁盘信息.序列号 ＝ 删首尾空 (到文本 (转换字节集 (取字节集中间 (lpOutBuffer, 37, 16))))
            磁盘信息.固件版本 ＝ 删首尾空 (到文本 (转换字节集 (取字节集中间 (lpOutBuffer, 63, 8))))
            返回值 ＝ 真
        .如果真结束
        CloseHandle (hFile)
    .如果真结束
    返回 (返回值)

.子程序 转换字节集, 字节集
    .参数 字节集, 字节集
    .局部变量 索引, 整数型
    .局部变量 长度, 整数型
    .局部变量 结果, 字节集

    长度 ＝ 取字节集长度 (字节集)
    结果 ＝ 取空白字节集 (长度)
    .变量循环首 (1, 长度, 2, 索引)
        结果 [索引] ＝ 字节集 [索引 ＋ 1]
        结果 [索引 ＋ 1] ＝ 字节集 [索引]
    .变量循环尾 ()
    返回 (结果)

.子程序 系统_打开控制面板项, , 公开, 打开系统控制面板设置
    .参数 控制面板项, 整数型, , 1.辅助选项 2.系统属性 3.增加新的打印机 4.添加/删除程序 5.复制磁盘 6.时间/日期 7.显示器设置 8.操纵杆 9.邮件/传真 10.邮局设置 11.鼠标属性 12.增加Modem 13.声音和音频设备属性 14.网络 15.口令 16.区域设置 17.IE设置 18.扫描仪与数字相机设设置 19.ODBC数据源管理器，ODBC数据源、ODBC驱动程序设置 20.电话拨号属性 21.电源管理设置 22.BDE Adminstrator 
    .参数 打开项页, 整数型, 可空, 可空,默认为第一页
    .局部变量 面板项, 文本型

    .如果真 (控制面板项 ＜ 1 或 控制面板项 ＞ 22)
        控制面板项 ＝ 1
    .如果真结束
    .判断开始 (控制面板项 ＝ 1)
        面板项 ＝ “access.cpl”
    .判断 (控制面板项 ＝ 2)
        面板项 ＝ “sysdm.cpl”
    .判断 (控制面板项 ＝ 3)
        运行 (“rundll32.exe shell32.dll,SHHelpShortcuts_RunDLL AddPrinter”, 假, )
        返回 ()
    .判断 (控制面板项 ＝ 4)
        面板项 ＝ “appwiz.cpl”
    .判断 (控制面板项 ＝ 5)
        运行 (“rundll32.exe diskcopy.dll,DiskCopyRunDll”, 假, )
        返回 ()
    .判断 (控制面板项 ＝ 6)
        面板项 ＝ “timedate.cpl”
    .判断 (控制面板项 ＝ 7)
        面板项 ＝ “desk.cpl”
    .判断 (控制面板项 ＝ 8)
        面板项 ＝ “joy.cpl”
    .判断 (控制面板项 ＝ 9)
        面板项 ＝ “mlcfg32.cpl”
    .判断 (控制面板项 ＝ 10)
        面板项 ＝ “wgpocpl.cpl”
    .判断 (控制面板项 ＝ 11)
        面板项 ＝ “main.cpl”
    .判断 (控制面板项 ＝ 12)
        运行 (“rundll32.exe shell32.dll,Control_RunDLL modem.cpl,,add”, 假, )
        返回 ()
    .判断 (控制面板项 ＝ 13)
        面板项 ＝ “mmsys.cpl”
    .判断 (控制面板项 ＝ 14)
        运行 (“rundll32.exe shell32.dll,Control_RunDLL ncpa.cpl”, 假, )
        返回 ()
    .判断 (控制面板项 ＝ 15)
        运行 (“rundll32.exe shell32.dll,Control_RunDLL password.cpl”, 假, )
        返回 ()
    .判断 (控制面板项 ＝ 16)
        面板项 ＝ “mmsys.cpl”
    .判断 (控制面板项 ＝ 17)
        面板项 ＝ “inetcpl.cpl”
    .判断 (控制面板项 ＝ 18)
        运行 (“RunDLL32.exe Shell32.dll,Control_RunDLL StiCpl.cpl”, 假, )
        返回 ()
    .判断 (控制面板项 ＝ 19)
        面板项 ＝ “ODBCCP32.CPL”
    .判断 (控制面板项 ＝ 20)
        运行 (“RunDLL32.exe Shell32.dll,Control_RunDLL Telephon.cpl”, 假, )
        返回 ()
    .判断 (控制面板项 ＝ 21)
        面板项 ＝ “PowerCfg.cpl”
    .判断 (控制面板项 ＝ 22)
        运行 (“RunDLL32.exe Shell32.dll,Control_RunDLL BdeAdmin.CPL”, 假, )
        返回 ()
    .默认
        
    .判断结束
    .如果真 (打开项页 ＜ 0)
        打开项页 ＝ 0
    .如果真结束
    运行 (“rundll32.exe shell32.dll,Control_RunDLL ” ＋ 面板项 ＋ “,,” ＋ 到文本 (打开项页), 假, #普通激活)

.子程序 系统_屏蔽任务管理器, , 公开, 即:禁止CTRL+ALT+DEL启动任务管理器,不用重启,仅对WINNT系统有效.
    写注册项 (#根类, “Software\Microsoft\Windows\CurrentVersion\Policies\System\DisableTaskMgr”, 1)
    写注册项 (#现行设置, “Software\Microsoft\Windows\CurrentVersion\Policies\System\DisableTaskMgr”, 1)
    写注册项 (#现行用户, “Software\Microsoft\Windows\CurrentVersion\Policies\System\DisableTaskMgr”, 1)

.子程序 系统_打开网络连接属性, , 公开, 打开系统网络连接属性设置
    写注册项 (3, “Software\Policies\Microsoft\Windows\Network Connections\NC_EnableAdminProhibits”, 0)
    运行 (“rundll32.exe shell32.dll,Control_RunDLL ” ＋ 目录_取system32目录 () ＋ “ncpa.cpl”, 假, )

.子程序 系统_恢复任务管理器, , 公开, 即:恢复被禁止的CTRL+ALT+DEL启动任务管理器
    写注册项 (#根类, “Software\Microsoft\Windows\CurrentVersion\Policies\System\DisableTaskMgr”, 0)
    写注册项 (#现行设置, “Software\Microsoft\Windows\CurrentVersion\Policies\System\DisableTaskMgr”, 0)
    写注册项 (#现行用户, “Software\Microsoft\Windows\CurrentVersion\Policies\System\DisableTaskMgr”, 0)

.子程序 系统_屏蔽任务管理器1, , 公开, 通过打开taskmgr.exe方式进行屏蔽
    文件_执行 (“taskmgr.exe”, , #隐藏窗口)
    CreateMutexA (0, 0, “Local\\TASKMGR.879e4d63-6c0e-4544-97f2-1244bd3f6de0”)
    集_任务管理器文件号 ＝ 打开文件 (目录_取特定目录 (10) ＋ “taskmgr.exe”, 1, 4)
    系统_屏蔽任务管理器 ()

.子程序 系统_恢复任务管理器1, , 公开, 关闭“系统_屏蔽任务管理器1”打开的taskmgr.exe
    关闭文件 (集_任务管理器文件号)
    进程_结束1 (“taskmgr.exe”)
    系统_恢复任务管理器 ()

.子程序 系统_显示用户操作区, , 公开, 显示被隐藏的系统用户操作区
    .局部变量 局_数组, 整数型, , "0"

    窗口_枚举子窗口 (窗口_取任务栏句柄 (), 局_数组)
    窗口_置控件状态 (局_数组 [3], 真)

.子程序 系统_隐藏用户操作区, , 公开, 隐藏系统用户操作区
    .局部变量 局_数组, 整数型, , "0"

    窗口_枚举子窗口 (窗口_取任务栏句柄 (), 局_数组)
    窗口_置控件状态 (局_数组 [3], 假)

.子程序 _取连接数量, 整数型, , 取系统中已经建立的连接数量
    .局部变量 连接信息, 取连接信息用结构, , "10", 假设最多10个连接
    .局部变量 lpcb, 整数型, , , 电话本名称,0
    .局部变量 连接数, 整数型

    连接信息 [1].内存大小 ＝ GlobalSize_取连接信息用结构 (连接信息 [1])
    lpcb ＝ 连接信息 [1].内存大小 × 256
    RasEnumEntries (0, 0, 连接信息, lpcb, 连接数)
    返回 (连接数)

.子程序 _取连接名称, 文本型, , 利用索引取出电脑中拨号的连接名称,成功返回连接名称,失败返回空文本;
    .参数 连接索引, 整数型, , 欲取名称的连接索引
    .参数 所有名称数组, 文本型, 参考 可空 数组, 存放所以链接名称的文本数组
    .局部变量 连接信息, 取连接信息用结构, , "10"
    .局部变量 lpcb, 整数型
    .局部变量 连接数, 整数型
    .局部变量 i, 整数型

    .如果真 (连接索引 ＞ 10 或 连接索引 ＜ 1)
        返回 (“”)
    .如果真结束
    连接信息 [1].内存大小 ＝ GlobalSize_取连接信息用结构 (连接信息 [1])
    lpcb ＝ 连接信息 [1].内存大小 × 256
    RasEnumEntries (0, 0, 连接信息, lpcb, 连接数)
    .如果真 (是否为空 (所有名称数组))
        返回 (到文本 (连接信息 [连接索引].拨号连接名称))
    .如果真结束
    .计次循环首 (连接数, i)
        加入成员 (所有名称数组, 到文本 (连接信息 [i].拨号连接名称))
    .计次循环尾 ()
    返回 (到文本 (连接数))

.子程序 系统_设置IE代理地址, 逻辑型, 公开, 成功返回真，失败返回假；
    .参数 上网方式, 字节型, , 0=用路由器上网  1=用ADSL拨号上网
    .参数 代理IP_端口, 文本型, 可空, 可空。留空为取消设置。要代理的IP地址和端口，如：127.0.0.1:8080
    .参数 立即更新设置, 逻辑型, 可空, 默认为真，为假时需要手动重启IE浏览器
    .局部变量 拨号连接数, 整数型
    .局部变量 计次, 整数型
    .局部变量 长度, 整数型

    .如果真 (是否为空 (立即更新设置))
        立即更新设置 ＝ 真
    .如果真结束
    
    .判断开始 (上网方式 ＝ 0)
        写注册项 (3, “Software\Microsoft\Windows\CurrentVersion\Internet Settings\proxyserver”, 代理IP_端口)
        .如果 (删首尾空 (代理IP_端口) ＝ “”)
            写注册项 (3, “Software\Microsoft\Windows\CurrentVersion\Internet Settings\proxyenable”, 0)
        .否则
            写注册项 (3, “Software\Microsoft\Windows\CurrentVersion\Internet Settings\proxyenable”, 1)
        .如果结束
        
    .判断 (上网方式 ＝ 1)
        拨号连接数 ＝ _取连接数量 () ' 先取得你的电脑上有几个ADSL连接
        长度 ＝ 取文本长度 (删全部空 (代理IP_端口)) ' 取得代理IP地址文本的长度，以便写入注册表用，这个长度不正确的话会不能正常设置
        .如果 (长度 ＝ 0) ' 假如代理地址这个参数为空
            .计次循环首 (拨号连接数, 计次)
                删除注册项 (3, “Software\Microsoft\Windows\CurrentVersion\Internet Settings\Connections\” ＋ _取连接名称 (计次)) ' 取消所有ADSL连接的http代理设置
            .计次循环尾 ()
        .否则
            .计次循环首 (拨号连接数, 计次) ' 否则代理地址参数有内容
                写注册项 (3, “Software\Microsoft\Windows\CurrentVersion\Internet Settings\Connections\” ＋ _取连接名称 (计次), { 60, 0, 0, 0, 1, 0, 0, 0, 3, 0, 0, 0 } ＋ 字节集_十六进制到字节集 (取十六进制文本 (长度)) ＋ { 0, 0, 0 } ＋ 到字节集 (代理IP_端口) ＋ { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }) ' 则将所有ADSL连接的http代理设置成该地址
            .计次循环尾 ()
        .如果结束
        
    .默认
        
    .判断结束
    
    .如果真 (立即更新设置)
        InternetSetOptionA_传址 (0, 39, 0, 0)
    .如果真结束
    返回 (InternetSetOptionA_传址 (0, 37, 0, 0))

.子程序 系统_取IE代理, 逻辑型, 公开, 带参返回IE相关代理地址，详细请参考IE属性窗口代理中高级代理属性，成功返回真，失败返回假。
    .参数 参_代理类型, , 参考 可空, 变量储存返回值,返回常量类型 INTERNET_OPEN_TYPE_PRECONFIG=0；INTERNET_OPEN_TYPE_DIRECT=1；INTERNET_OPEN_TYPE_PROXY=2
    .参数 参_HTTP地址, 文本型, 参考 可空, 变量储存返回值
    .参数 参_HTTPS安全地址, 文本型, 参考 可空, 变量储存返回值
    .参数 参_FTP地址, 文本型, 参考 可空, 变量储存返回值
    .参数 参_套接字地址, 文本型, 参考 可空, 变量储存返回值
    .参数 参_例外地址, 文本型, 参考 可空, 变量储存返回值
    .局部变量 局_逻辑返回, 逻辑型
    .局部变量 局_缓冲长度, 整数型
    .局部变量 局_缓冲区, 整数型
    .局部变量 局_列表指针, 整数型
    .局部变量 局_例外指针, 整数型
    .局部变量 局_临时文本, 文本型

    InternetQueryOption (0, 38, 0, 局_缓冲长度) ' #INTERNET_OPTION_PROXY=38
    局_缓冲区 ＝ LocalAlloc (64, 局_缓冲长度)
    局_逻辑返回 ＝ InternetQueryOption (0, 38, 局_缓冲区, 局_缓冲长度)
    .如果真 (局_逻辑返回)
        参_代理类型 ＝ 取字节集数据 (指针到字节集 (局_缓冲区, 4), #整数型, )
        局_列表指针 ＝ 取字节集数据 (指针到字节集 (局_缓冲区 ＋ 4, 4), #整数型, )
        局_例外指针 ＝ 取字节集数据 (指针到字节集 (局_缓冲区 ＋ 8, 4), #整数型, )
        局_临时文本 ＝ 到文本 (指针到字节集 (局_列表指针, lstrlenA (局_列表指针)))
        参_HTTP地址 ＝ 文本_取出中间文本 (局_临时文本, “http=”, “ ”)
        参_HTTPS安全地址 ＝ 文本_取出中间文本 (局_临时文本, “https=”, “ ”)
        参_FTP地址 ＝ 文本_取右边 (局_临时文本, “ftp=”, )
        参_套接字地址 ＝ 文本_取出中间文本 (局_临时文本, “socks=”, “ ”)
        参_例外地址 ＝ 到文本 (指针到字节集 (局_例外指针, lstrlenA (局_例外指针)))
    .如果真结束
    LocalFree (局_缓冲区)
    返回 (局_逻辑返回)

.子程序 系统_创建桌面快捷方式, 逻辑型, 公开, 创建桌面快捷方式 (成功返回真,失败返回假)
    .参数 lnk名称, 文本型, , 如：精易编程助手！注：本参数会传址，不推荐传入变量
    .参数 目标, 文本型, , 指向的文件全路径文件名,如 C:\001.txt，如果是目录就直接为 C:\001
    .参数 参数文本, 文本型, 可空, 执行文件的参数
    .参数 图标文件, 文本型, 可空, 图标文件的路径  可空:为空时用目标的第一个图标
    .参数 运行方式, 整数型, 可空, 1,常规方式，3,最大化，7,最小化
    .参数 备注, 文本型, 可空, 快方式的备注信息
    .参数 快捷键, 文本型, 可空, 启动快捷方式的快捷键  如“Ctrl+Alt+Y”
    .局部变量 工作目录, 文本型
    .局部变量 临时文本, 文本型, , "0"
    .局部变量 对象, 对象
    .局部变量 计次, 整数型
    .局部变量 局_返回值, 逻辑型

    .如果真 (寻找文本 (lnk名称, “\”, , 假) ≠ -1)
        lnk名称 ＝ 文件_取文件名 (lnk名称)
    .如果真结束
    .如果 (寻找文本 (lnk名称, “.lnk”, , 真) ＝ -1)
        lnk名称 ＝ 目录_取特定目录 () ＋ lnk名称 ＋ “.lnk”
    .否则
        lnk名称 ＝ 目录_取特定目录 () ＋ lnk名称
    .如果结束
    .如果真 (文件是否存在 (lnk名称))
        删除文件 (lnk名称)
    .如果真结束
    临时文本 ＝ 分割文本 (目标, “\”, )
    .如果真 (取数组下标 (临时文本, ) ＜ 2)
        返回 (假)
    .如果真结束
    .计次循环首 (取数组下标 (临时文本, ) － 1, 计次)
        工作目录 ＝ 工作目录 ＋ 临时文本 [计次] ＋ “\”
    .计次循环尾 ()
    CoInitialize (0)
    .如果真 (对象.创建 (“WshShell”, “wshom.ocx”))
        对象 ＝ 对象.对象型方法 (“CreateShortcut”, lnk名称)
        局_返回值 ＝ 取反 (对象.是否为空 ())
        .如果真 (局_返回值 且 对象.写属性 (“TargetPath”, 目标))
            对象.写属性 (“WorkingDirectory”, 工作目录)
            .如果 (是否为空 (图标文件))
                .判断开始 (文件_取扩展名 (目标) ＝ “”)
                    对象.写属性 (“IconLocation”, “SHELL32.dll,4”)
                .默认
                    对象.写属性 (“IconLocation”, 目标 ＋ “,0”)
                .判断结束
                
            .否则
                对象.写属性 (“IconLocation”, 图标文件)
            .如果结束
            对象.写属性 (“WindowStyle”, 运行方式)
            对象.写属性 (“Description”, 备注)
            对象.写属性 (“Arguments”, 参数文本)
            对象.写属性 (“Hotkey”, 快捷键)
            对象 ＝ 对象.对象型方法 (“Save”, )
        .如果真结束
        
    .如果真结束
    CoUninitialize ()
    返回 (局_返回值)

.子程序 系统_创建桌面快捷方式W, 逻辑型, 公开, 创建桌面快捷方式
    .参数 lnk路径, 字节集
    .参数 目标, 字节集
    .参数 命令行, 字节集, 可空
    .参数 图标路径, 字节集, 可空, icon
    .参数 起始位置, 字节集, 可空
    .参数 快捷键, 短整数型, 可空, #HOTKEYF_*
    .参数 运行方式, 整数型, 可空, #SW_*
    .参数 备注, 字节集, 可空
    .局部变量 hr, 整数型
    .局部变量 pSL, 整数型
    .局部变量 pPF, 整数型
    .局部变量 szPath, 字节集
    .局部变量 bRet, 逻辑型

    CoInitialize (#NULL)
    hr ＝ CoCreateInstance1 (取指针_字节集型 (#CLSID_ShellLink), #NULL, #CLSCTX_INPROC_SERVER, 取指针_字节集型 (#IID_IShellLinkW), pSL)
    .如果真 (hr ＝ #S_OK 且 pSL ≠ #NULL)
        hr ＝ CallObject (pSL, #IUnknown_QueryInterface, 取指针_字节集型 (#IID_IPersistFile), 取指针整数_ (pPF), , , , , , , )
        .如果真 (hr ＝ #S_OK 且 pPF ≠ #NULL)
            hr ＝ CallObject (pSL, #IShellLinkW_SetPath, 取指针_字节集型 (目标), , , , , , , , )
            .如果 (起始位置 ＝ { })
                szPath ＝ 字节集_寻找取左 (目标, { 92, 0 }, -1) ＋ { 0, 0 }
                hr ＝ CallObject (pSL, #IShellLinkW_SetWorkingDirectory, 取指针_字节集型 (szPath), , , , , , , , )
            .否则
                hr ＝ CallObject (pSL, #IShellLinkW_SetWorkingDirectory, 取指针_字节集型 (起始位置), , , , , , , , )
            .如果结束
            .如果真 (命令行 ≠ { })
                CallObject (pSL, #IShellLinkW_SetArguments, 取指针_字节集型 (命令行), , , , , , , , )
            .如果真结束
            .如果真 (图标路径 ≠ { })
                CallObject (pSL, #IShellLinkW_SetIconLocation, 取指针_字节集型 (图标路径), 0, , , , , , , ) ' 0是图标的索引
            .如果真结束
            .如果真 (快捷键 ≠ 0)
                ' 合并短整数 (#P键, 位或 (#HOTKEYF_CONTROL, #HOTKEYF_ALT)) => Ctrl + Alt + P
                hr ＝ CallObject (pSL, #IShellLinkW_SetHotkey, 快捷键, , , , , , , , )
            .如果真结束
            .如果 (运行方式 ＝ 0)
                hr ＝ CallObject (pSL, #IShellLinkW_SetShowCmd, #SW_SHOWNORMAL, , , , , , , , )
            .否则
                hr ＝ CallObject (pSL, #IShellLinkW_SetShowCmd, 运行方式, , , , , , , , )
            .如果结束
            .如果真 (备注 ≠ { })
                hr ＝ CallObject (pSL, #IShellLinkW_SetDescription, 取指针_字节集型 (备注), , , , , , , , )
            .如果真结束
            hr ＝ CallObject (pPF, #IPersistFile_Save, 取指针_字节集型 (lnk路径), 0, , , , , , , )
            bRet ＝ hr ＝ #S_OK ' 是否成功
            SafeRelease (pPF)
        .如果真结束
        SafeRelease (pSL)
    .如果真结束
    CoUninitialize ()
    返回 (bRet)

.子程序 系统_取桌面快捷方式, 文本型, 公开, 取桌面快捷方式 成功返回文件路径,失败返回空文本
    .参数 快捷方式全路径, 文本型, , 快捷方式全路径
    .局部变量 szPath, 字节集

    szPath ＝ 编码_Ansi到Unicode (快捷方式全路径, )
    szPath ＝ 系统_取桌面快捷方式W (szPath, )
    返回 (编码_Unicode到Ansi (szPath))

.子程序 系统_取桌面快捷方式W, 字节集, 公开, 获取快捷方式的目标路径
    .参数 lnk路径, 字节集
    .参数 文件的信息, WIN32_FIND_DATAW, 可空, 接收
    .参数 命令行, 字节集, 可空, 接收
    .参数 图标路径, 字节集, 可空, 接收
    .参数 起始位置, 字节集, 可空, 接收
    .参数 快捷键, 短整数型, 参考 可空, 接收
    .参数 运行方式, 整数型, 参考 可空, 接收
    .参数 备注, 字节集, 可空, 接收
    .局部变量 hr, 整数型
    .局部变量 pPF, 整数型
    .局部变量 pSL, 整数型
    .局部变量 pszPath, 整数型
    .局部变量 szPath, 字节集
    .局部变量 ptr, 整数型
    .局部变量 piIcon, 整数型

    CoInitialize (#NULL)
    hr ＝ CoCreateInstance1 (取指针_字节集型 (#CLSID_ShellLink), #NULL, #CLSCTX_INPROC_SERVER, 取指针_字节集型 (#IID_IPersistFile), pPF)
    .如果真 (hr ＝ #S_OK 且 pPF ≠ #NULL)
        hr ＝ CallObject (pPF, #IUnknown_QueryInterface, 取指针_字节集型 (#IID_IShellLinkW), 取指针整数_ (pSL), , , , , , , )
        .如果真 (hr ＝ #S_OK 且 pSL ≠ #NULL)
            hr ＝ CallObject (pPF, #IPersistFile_Load, 取指针_字节集型 (lnk路径), #STGM_READ, , , , , , , )
            .如果真 (hr ＝ #S_OK)
                pszPath ＝ LocalAlloc (#LMEM_ZEROINIT, #MAX_PATH × 2)
                .如果真 (是否为空 (命令行) ＝ 假)
                    hr ＝ CallObject (pSL, #IShellLinkW_GetArguments, pszPath, #MAX_PATH, , , , , , , )
                    命令行 ＝ 指针_到字节集W (pszPath)
                .如果真结束
                .如果真 (是否为空 (图标路径) ＝ 假)
                    hr ＝ CallObject (pSL, #IShellLinkW_GetIconLocation, pszPath, #MAX_PATH, 取指针整数_ (piIcon), , , , , , ) ' piIcon => 接收图标索引的值的地址
                    图标路径 ＝ 指针_到字节集W (pszPath)
                .如果真结束
                .如果真 (是否为空 (起始位置) ＝ 假)
                    hr ＝ CallObject (pSL, #IShellLinkW_GetWorkingDirectory, pszPath, #MAX_PATH, , , , , , , )
                    起始位置 ＝ 指针_到字节集W (pszPath)
                .如果真结束
                .如果真 (是否为空 (快捷键) ＝ 假)
                    hr ＝ CallObject (pSL, #IShellLinkW_GetHotkey, 取变量地址_短整数 (快捷键), , , , , , , , )
                .如果真结束
                .如果真 (是否为空 (运行方式) ＝ 假)
                    hr ＝ CallObject (pSL, #IShellLinkW_GetShowCmd, 取指针整数_ (运行方式), , , , , , , , )
                .如果真结束
                .如果真 (是否为空 (备注) ＝ 假)
                    hr ＝ CallObject (pSL, #IShellLinkW_GetDescription, pszPath, #MAX_PATH, , , , , , , )
                    备注 ＝ 指针_到字节集W (pszPath)
                .如果真结束
                ' 存在一个问题！64位系统取真实路径会定位到32位目录里 Program Files (x86)
                .如果 (是否为空 (文件的信息))
                    hr ＝ CallObject (pSL, #IShellLinkW_GetPath, pszPath, #MAX_PATH, #NULL, 0, , , , , )
                .否则
                    ptr ＝ LocalAlloc (#LMEM_ZEROINIT, 592)
                    hr ＝ CallObject (pSL, #IShellLinkW_GetPath, pszPath, #MAX_PATH, ptr, 0, , , , , )
                    RtlMoveMemory_WIN32_FIND_DATAW (文件的信息, ptr, 592)
                    LocalFree (ptr)
                .如果结束
                szPath ＝ 指针_到字节集W (pszPath)
                LocalFree (pszPath)
            .如果真结束
            SafeRelease (pSL)
        .如果真结束
        SafeRelease (pPF)
    .如果真结束
    CoUninitialize ()
    返回 (szPath)

.子程序 系统_清空系统临时目录, 逻辑型, 公开, 清空系统临时目录中的全部文件
    .参数 是否删除只读文件, 逻辑型, 可空
    .参数 是否删除子目录, 逻辑型, 可空
    .局部变量 临时目录名, 文本型
    .局部变量 临时文件名, 文本型

    临时目录名 ＝ 目录_取特定目录 (11)
    .如果真 (删全部空 (临时目录名) ＝ “”)
        返回 (假)
    .如果真结束
    临时文件名 ＝ 寻找文件 (临时目录名 ＋ “*.*”, )
    .判断循环首 (临时文件名 ≠ “”)
        .如果真 (是否删除只读文件 ＝ 真)
            置文件属性 (临时目录名 ＋ 临时文件名, #存档文件)
        .如果真结束
        临时文件名 ＝ 寻找文件 (, )
    .判断循环尾 ()
    .如果真 (是否删除子目录 ＝ 真)
        临时文件名 ＝ 寻找文件 (临时目录名 ＋ “*.*”, #子目录)
        .判断循环首 (临时文件名 ≠ “”)
            目录_删除目录 (临时目录名 ＋ 临时文件名)
            临时文件名 ＝ 寻找文件 (, #子目录)
        .判断循环尾 ()
    .如果真结束
    返回 (真)

.子程序 系统_设置为默认浏览器, , 公开, 如：自己做了个易语言浏览器，可以用这句设置成默认的；
    .参数 文件名绝对路径, 文本型, 可空, 可空:如果留空将设置本程序为默认浏览器;浏览器的可执行文件路径；
    .参数 类型, 整数型, 可空, 可空:默认为0,0=设置指定或本程序为默认浏览器,1=设置IE为默认浏览器;
    .局部变量 局_运行目录, 文本型

    局_运行目录 ＝ 取运行目录 () ＋ “\”
    .如果 (类型 ＝ 0)
        .如果 (是否为空 (文件名绝对路径) ＝ 真)
            写注册项 (1, “htmlfile\shell\”, “e”)
            写注册项 (1, “htmlfile\shell\e\command\”, 局_运行目录 ＋ 取执行文件名 () ＋ “ ” ＋ “%1”)
            写注册项 (1, “HTTP\shell\”, “e”)
            写注册项 (1, “HTTP\shell\e\command\”, 局_运行目录 ＋ 取执行文件名 () ＋ “ ” ＋ “%1”)
            写注册项 (1, “https\shell\”, “e”)
            写注册项 (1, “https\shell\e\command\”, 局_运行目录 ＋ 取执行文件名 () ＋ “ ” ＋ “%1”)
            写注册项 (1, “InternetShortcut\shell\”, “e”)
            写注册项 (1, “InternetShortcut\shell\e\command\”, 局_运行目录 ＋ 取执行文件名 () ＋ “ ” ＋ “%1”)
            写注册项 (1, “mhtmlfile\shell\”, “e”)
            写注册项 (1, “mhtmlfile\shell\e\command\”, 局_运行目录 ＋ 取执行文件名 () ＋ “ ” ＋ “%1”)
            
        .否则
            写注册项 (1, “htmlfile\shell\”, “e”)
            写注册项 (1, “htmlfile\shell\e\command\”, 文件名绝对路径 ＋ “ ” ＋ “%1”)
            写注册项 (1, “HTTP\shell\”, “e”)
            写注册项 (1, “HTTP\shell\e\command\”, 文件名绝对路径 ＋ “ ” ＋ “%1”)
            写注册项 (1, “https\shell\”, “e”)
            写注册项 (1, “https\shell\e\command\”, 文件名绝对路径 ＋ “ ” ＋ “%1”)
            写注册项 (1, “InternetShortcut\shell\”, “e”)
            写注册项 (1, “InternetShortcut\shell\e\command\”, 文件名绝对路径 ＋ “ ” ＋ “%1”)
            写注册项 (1, “mhtmlfile\shell\”, “e”)
            写注册项 (1, “mhtmlfile\shell\e\command\”, 文件名绝对路径 ＋ “ ” ＋ “%1”)
        .如果结束
        
    .否则
        写注册项 (1, “htmlfile\shell\”, “open”)
        写注册项 (1, “HTTP\shell\”, “open”)
        写注册项 (1, “https\shell\”, “open”)
        写注册项 (1, “InternetShortcut\shell\”, “open”)
        写注册项 (1, “mhtmlfile\shell\”, “open”)
    .如果结束
    

.子程序 系统_取DOS执行结果, 文本型, 公开, 注意:该命令会阻塞,一直到cmd中的内容执行完毕后才会返回.
    .参数 命令行文本, 文本型
    .参数 即时回显, 子程序指针, 可空, DOS即时回显信息回调函数 回调DOS函数(回显信息) 返回逻辑值,真:停止,假:继续
    .局部变量 szBuf, 字节集

    .如果 (是否为空 (即时回显))
        szBuf ＝ 系统_取DOS执行结果T (编码_Ansi到Unicode (命令行文本, ), , )
    .否则
        szBuf ＝ 系统_取DOS执行结果T (编码_Ansi到Unicode (命令行文本, ), 即时回显, )
    .如果结束
    返回 (取字节集数据 (szBuf, #文本型, ))

.子程序 系统_取DOS执行结果T, 字节集, 公开, 该命令会阻塞，一直到CMD中的内容执行完毕后才会返回
    .参数 命令行文本, 字节集
    .参数 即时回显, 子程序指针, 可空, DOS即时回显信息回调函数！回调DOS函数(回显信息) 返回逻辑值；真、停止，假、继续
    .参数 UNICODE, 逻辑型, 可空
    .局部变量 hRead, 整数型
    .局部变量 hWrite, 整数型
    .局部变量 sa, SECURITY_ATTRIBUTES
    .局部变量 nMaxCount, 整数型
    .局部变量 szPath, 字节集
    .局部变量 szCmdLine, 字节集
    .局部变量 si, STARTUPINFO
    .局部变量 pi, PROCESS_INFORMATION
    .局部变量 dwBytesInStdOut, 整数型
    .局部变量 lRes, 逻辑型
    .局部变量 dwExitCode, 整数型
    .局部变量 szTemp, 字节集
    .局部变量 szBuf, 字节集

    sa.nLength ＝ 12 ' sizeof(SECURITY_ATTRIBUTES)
    sa.lpSecurityDescriptor ＝ #NULL
    sa.bInheritHandle ＝ 真
    lRes ＝ CreatePipe (hRead, hWrite, sa, 0)
    .如果真 (lRes ＝ 假)
        返回 ({ })
    .如果真结束
    si.cb ＝ 68 ' sizeof(STARTUPINFO)
    si.dwFlags ＝ 位或 (#STARTF_USESTDHANDLES, #STARTF_USESHOWWINDOW)
    si.wShowWindow ＝ #SW_HIDE
    si.hStdInput ＝ hRead
    si.hStdOutput ＝ hWrite
    si.hStdError ＝ hWrite
    szPath ＝ 取空白字节集 (incShl (#MAX_PATH, 真))
    SHGetSpecialFolderPathW (#NULL, 取指针字节集_ (szPath), #CSIDL_SYSTEM, 假)
    写到内存 (编码_Ansi到Unicode (选择 (_WIN32_WINNT ≥ #_WIN32_WINNT_WINXP, “\cmd.exe”, “\command.com”), ), 取指针字节集_ (szPath) ＋ incShl (文本_取长度W (szPath), 真), )
    szCmdLine ＝ 编码_Ansi到Unicode (“ /c ”, 真) ＋ 命令行文本
    nMaxCount ＝ 取字节集长度 (szCmdLine)
    szCmdLine ＝ szCmdLine ＋ 取空白字节集 (incShl (#MAXSHORT, 真) － nMaxCount) ' 填充
    lRes ＝ CreateProcessW (取指针字节集_ (szPath), 取指针_字节集型 (szCmdLine), 取数据_通用型 (sa), #NULL, 真, 0, #NULL, #NULL, si, pi)
    CloseHandle (hWrite)
    .如果真 (lRes ＝ 假)
        CloseHandle (hRead)
        返回 ({ })
    .如果真结束
    CloseHandle (pi.hThread)
    WaitForInputIdle (pi.hProcess, 1000) ' 毫秒
    .判断循环首 (dwBytesInStdOut ≠ -1)
        PeekNamedPipe (hRead, #NULL, 0, #NULL, dwBytesInStdOut, #NULL)
        .如果 (dwBytesInStdOut ＞ 0)
            szTemp ＝ 取空白字节集 (dwBytesInStdOut)
            ReadFile (hRead, szTemp, dwBytesInStdOut, dwBytesInStdOut, #NULL)
            szBuf ＝ szBuf ＋ szTemp
            .如果真 (是否为空 (即时回显) ＝ 假)
                .如果 (UNICODE)
                    szTemp ＝ A2W_CP (szTemp, m_CodePage)
                .否则
                    szTemp ＝ szTemp ＋ { 0 }
                .如果结束
                lRes ＝ 程序_执行整数子程序 (即时回显, 取指针_字节集型 (szTemp), , ) ≠ 0
                .如果真 (lRes)
                    跳出循环 ()
                .如果真结束
                
            .如果真结束
            
        .否则
            GetExitCodeProcess (pi.hProcess, dwExitCode)
            .如果真 (dwExitCode ≠ #STILL_ACTIVE)
                跳出循环 ()
            .如果真结束
            
        .如果结束
        Sleep (1)
    .判断循环尾 ()
    CloseHandle (pi.hProcess)
    CloseHandle (hRead)
    .如果真 (szBuf ＝ { })
        返回 ({ })
    .如果真结束
    .如果 (UNICODE)
        返回 (A2W_CP (szBuf, m_CodePage))
    .否则
        szBuf ＝ szBuf ＋ { 0 }
    .如果结束
    返回 (szBuf)

.子程序 系统_修改IP地址和网关和子网掩码, 逻辑型, 公开, CMD方式修改,警告：该命令可能让你无法联网，使用前请确保你有还原到正常网络的能力！Win10下运行返回值可能有误
    .参数 IP地址, 文本型, , 格式为：192.168.1.152 (点分十进制的IP表示)
    .参数 网关, 文本型, , 格式为：192.168.1.1 (点分十进制的IP表示)
    .参数 子网掩码, 文本型, , 格式为：255.255.255.0 (点分十进制的IP表示)
    .参数 连接名称, 文本型, 可空, 连接的名称,留空则为:本地连接
    .参数 错误原因, 文本型, 参考 可空, 可以提供一个文本变量,接收当修改失败时的错误信息.
    .局部变量 返回文本, 文本型, , , 本代码由落雪 提供

    .如果真 (是否为空 (连接名称))
        连接名称 ＝ “本地连接”
    .如果真结束
    返回文本 ＝ 系统_取DOS执行结果 (“netsh interface ip set address ” ＋ #引号 ＋ 连接名称 ＋ #引号 ＋ “ static ” ＋ IP地址 ＋ “ ” ＋ 子网掩码 ＋ “ ” ＋ 网关 ＋ “ 1”, )
    .如果真 (寻找文本 (返回文本, “确定”, , 假) ＞ 0)
        返回 (真)
    .如果真结束
    错误原因 ＝ 子文本替换 (返回文本, #换行符, “”, 倒找文本 (返回文本, #换行符, , 假) － 2, 1, 真) ' 因为在执行完毕之后,会自动加上一个换行符.这回造成在取错误时候的不便,因此将其去掉
    返回 (假)

.子程序 系统_修改DNS, 逻辑型, 公开, 如果首选DNS跟备用DNS都不填则默认设置成自动获取,成功返回真,失败返回假
    .参数 连接名称, 文本型, 可空, 为空则自动获取单前连接的网络名称
    .参数 首选DNS, 文本型, 可空, 格式：1.1.1.1
    .参数 备用DNS, 文本型, 可空, 格式：1.1.1.1
    .参数 错误原因, 文本型, 参考 可空, 可以提供一个文本变量,接收当修改失败时的错误信息
    .局部变量 DNS命令, 文本型
    .局部变量 名称, 精易_网卡信息, , "0"
    .局部变量 名称2, 精易_网卡信息_彗星, , "0"
    .局部变量 数量, 整数型
    .局部变量 返回文本, 文本型

    ' https://bbs.125.la/thread-14484267-1-1.html
    .如果真 (连接名称 ＝ “”)
        数量 ＝ 系统_取网卡信息 (名称)
        .判断开始 (数量 ＞ 0)
            连接名称 ＝ 名称 [1].连接名称
        .默认
            数量 ＝ 系统_取网卡信息_彗星版 (名称2) ' 怕第一个取不到多加一条,也可以只用一条
            .如果真 (数量 ＞ 0)
                连接名称 ＝ 名称2 [1].连接名称
            .如果真结束
            
        .判断结束
        
    .如果真结束
    
    .判断开始 (首选DNS ＝ “” 且 备用DNS ＝ “”)
        DNS命令 ＝ “cmd /c netsh interface ip set dns name=” ＋ #引号 ＋ 连接名称 ＋ #引号 ＋ “ source=dhcp”
    .判断 (首选DNS ≠ “” 且 备用DNS ≠ “”)
        DNS命令 ＝ “cmd /c netsh interface ip set dns ” ＋ 连接名称 ＋ “ static ” ＋ 首选DNS
        返回文本 ＝ 系统_取DOS执行结果 (DNS命令)
        .如果真 (返回文本 ≈ “确定。” 或 返回文本 ＝ #换行符)
            DNS命令 ＝ “cmd /c netsh interface ip add dns name=” ＋ #引号 ＋ 连接名称 ＋ #引号 ＋ “ addr=” ＋ 备用DNS ＋ “ index=2”
            返回文本 ＝ 系统_取DOS执行结果 (DNS命令)
            .如果真 (返回文本 ≈ “确定。” 或 返回文本 ＝ #换行符)
                返回 (真)
            .如果真结束
            
        .如果真结束
        错误原因 ＝ 子文本替换 (返回文本, #换行符, “”, 倒找文本 (返回文本, #换行符, , 假) － 2, 1, 真) ' 因为在执行完毕之后,会自动加上一个换行符.这回造成在取错误时候的不便,因此将其去掉
        返回 (假)
    .判断 (首选DNS ＝ “” 且 备用DNS ≠ “”)
        DNS命令 ＝ “cmd /c netsh interface ip add dns name=” ＋ #引号 ＋ 连接名称 ＋ #引号 ＋ “ addr=” ＋ 备用DNS ＋ “ index=2”
    .判断 (首选DNS ≠ “” 且 备用DNS ＝ “”)
        DNS命令 ＝ “cmd /c netsh interface ip set dns ” ＋ 连接名称 ＋ “ static ” ＋ 首选DNS
    .默认
        
    .判断结束
    
    返回文本 ＝ 系统_取DOS执行结果 (DNS命令)
    .如果真 (返回文本 ≈ “确定。” 或 返回文本 ＝ #换行符)
        返回 (真)
    .如果真结束
    
    错误原因 ＝ 子文本替换 (返回文本, #换行符, “”, 倒找文本 (返回文本, #换行符, , 假) － 2, 1, 真) ' 因为在执行完毕之后,会自动加上一个换行符.这回造成在取错误时候的不便,因此将其去掉
    返回 (假)

.子程序 系统_删除MAC地址, , 公开, 删除注册表中MAC地址
    .参数 第几块网卡, 整数型, 可空, 默认为1

    .如果真 (是否为空 (第几块网卡))
        第几块网卡 ＝ 1
    .如果真结束
    删除注册项 (#本地机器, “SYSTEM\ControlSet001\Control\Class\{4D36E972-E325-11CE-BFC1-08002bE10318}\000” ＋ 到文本 (第几块网卡) ＋ “\NetworkAddress”)

.子程序 系统_修改MAC地址, , 公开, 重启电脑后生效
    .参数 MAC, 文本型, , 格式为：A2:36:42:04:40:30
    .参数 第几块网卡, 整数型, 可空, 默认为1

    .如果真 (是否为空 (第几块网卡))
        第几块网卡 ＝ 1
    .如果真结束
    写注册项 (#本地机器, “SYSTEM\ControlSet001\Control\Class\{4D36E972-E325-11CE-BFC1-08002bE10318}\000” ＋ 到文本 (第几块网卡) ＋ “\NetworkAddress”, 子文本替换 (MAC, “:”, “”, , , 真))

.子程序 系统_取MAC地址, 文本型, 公开, 获取本机网卡MAC地址(如：A2:36:42:04:40:30)
    .参数 目标IP, 文本型, 可空, 可空：默认为取自己的。也可以取局域网内的其它电脑的。如：192.168.1.100
    .局部变量 局_缓冲, 字节型, , "6"
    .局部变量 局_地址, 字节集
    .局部变量 局_当前IP, 整数型
    .局部变量 局_计次, 整数型
    .局部变量 集_IP段, 字节集
    .局部变量 集_IP, 文本型, , "0"
    .局部变量 集_MAC, 文本型, , "0"
    .局部变量 局_临时, 文本型
    .局部变量 VBScript, 对象

    .如果真 (是否为空 (目标IP))
        局_临时 ＝ 查询类属性 (“Select MACAddress From Win32_NetworkAdapter WHERE PNPDeviceID LIKE ” ＋ #引号 ＋ “%PCI%” ＋ #引号 ＋ “ AND  NetConnectionStatus =2”, “MACAddress”).取文本 ()
        .如果真 (取文本长度 (局_临时) ＝ 0)
            局_临时 ＝ 查询类属性 (“Select MACAddress From Win32_NetworkAdapter WHERE NetConnectionStatus =2”, “MACAddress”).取文本 ()
        .如果真结束
        返回 (局_临时)
    .如果真结束
    集_IP段 ＝ 到字节集 (inet_addr (目标IP))
    重定义数组 (集_IP, 假, 255)
    重定义数组 (集_MAC, 假, 255)
    局_当前IP ＝ 取字节集数据 (集_IP段, #整数型, )
    .如果真 (SendARP (局_当前IP, 0, 局_缓冲, 6) ＝ 0)
        局_地址 ＝ 到字节集 (局_当前IP)
        .计次循环首 (6, 局_计次)
            .如果真 (局_缓冲 [局_计次] ＜ 16)
                集_MAC [局_地址 [4]] ＝ 集_MAC [局_地址 [4]] ＋ “0”
            .如果真结束
            集_MAC [局_地址 [4]] ＝ 集_MAC [局_地址 [4]] ＋ 取十六进制文本 (局_缓冲 [局_计次]) ＋ “:”
        .计次循环尾 ()
        返回 (取文本左边 (集_MAC [局_地址 [4]], 17))
    .如果真结束
    返回 (“”)

.子程序 系统_取CPU名称, 文本型, 公开, 获取CPU的名称
    .局部变量 返回值, 文本型

    返回值 ＝ 取空白文本 (100)
    置入代码 ({ 96, 184, 2, 0, 0, 128, 15, 162, 139, 117, 252, 54, 137, 6, 54, 137, 94, 4, 54, 137, 78, 8, 54, 137, 86, 12, 184, 3, 0, 0, 128, 15, 162, 54, 137, 70, 16, 54, 137, 94, 20, 54, 137, 78, 24, 54, 137, 86, 28, 184, 4, 0, 0, 128, 15, 162, 54, 137, 70, 32, 54, 137, 94, 36, 54, 137, 78, 40, 54, 137, 86, 44, 97 })
    ' PUSHAD
    ' MOV EAX, 80000002
    ' CPUID
    ' MOV ESI, DWORD PTR SS:[EBP-4]
    ' MOV DWORD PTR SS:[ESI], EAX
    ' MOV DWORD PTR SS:[ESI+4], EBX
    ' MOV DWORD PTR SS:[ESI+8], ECX
    ' MOV DWORD PTR SS:[ESI+C], EDX
    ' MOV EAX, 80000003
    ' CPUID
    ' MOV DWORD PTR SS:[ESI+10], EAX
    ' MOV DWORD PTR SS:[ESI+14], EBX
    ' MOV DWORD PTR SS:[ESI+18], ECX
    ' MOV DWORD PTR SS:[ESI+1C], EDX
    ' MOV EAX, 80000004
    ' CPUID
    ' MOV DWORD PTR SS:[ESI+20], EAX
    ' MOV DWORD PTR SS:[ESI+24], EBX
    ' MOV DWORD PTR SS:[ESI+28], ECX
    ' MOV DWORD PTR SS:[ESI+2C], EDX
    ' POPAD
    返回 (返回值)

.子程序 系统_取CPU描述, 文本型, 公开, 获取CPU的描述
    .局部变量 参数, 整数型, , "3"
    .局部变量 返回值, 文本型

    置入代码 ({ 96, 184, 1, 0, 0, 0, 15, 162, 139, 200, 129, 225, 0, 15, 0, 0, 193, 233, 8, 54, 137, 79, 244, 139, 200, 129, 225, 240, 0, 0, 0, 193, 233, 4, 54, 137, 79, 248, 139, 200, 131, 225, 15, 54, 137, 79, 252, 97 })
    ' PUSHAD
    ' MOV EAX, 1
    ' CPUID
    ' MOV ECX, EAX
    ' AND ECX, 0F00
    ' SHR ECX, 8
    ' MOV DWORD PTR SS:[EDI-C], ECX
    ' MOV ECX, EAX
    ' AND ECX, 0F0
    ' SHR ECX, 4
    ' MOV DWORD PTR SS:[EDI-8], ECX
    ' MOV ECX, EAX
    ' AND ECX, 0F
    ' MOV DWORD PTR SS:[EDI-4], ECX
    ' POPAD
    返回值 ＝ 取空白文本 (100)
    wsprintfA (返回值, “x86 Family %d Model %d Stepping %d”, 参数)
    返回 (返回值)

.子程序 系统_取CPU制造商, 文本型, 公开, 获取CPU制造商
    .局部变量 返回值, 文本型

    返回值 ＝ 取空白文本 (12)
    置入代码 ({ 96, 51, 192, 15, 162, 139, 69, 252, 54, 137, 24, 54, 137, 80, 4, 54, 137, 72, 8, 97 })
    ' PUSHAD
    ' XOR EAX, EAX
    ' CPUID
    ' MOV EAX, DWORD PTR SS:[EBP-4]
    ' MOV DWORD PTR SS:[EAX], EBX
    ' MOV DWORD PTR SS:[EAX+4], EDX
    ' MOV DWORD PTR SS:[EAX+8], ECX
    ' POPAD
    .判断开始 (返回值 ＝ “GenuineIntel”)
        返回值 ＝ “Intel Corporation.”
    .判断 (返回值 ＝ “AuthenticAMD”)
        返回值 ＝ “Advanced Micro Devices.”
    .判断 (返回值 ＝ “AMD ISBETTER”)
        返回值 ＝ “Advanced Micro Devices.”
    .判断 (返回值 ＝ “Geode By NSC”)
        返回值 ＝ “National Semiconductor.”
    .判断 (返回值 ＝ “CyrixInstead”)
        返回值 ＝ “Cyrix Corp., VIA Inc.”
    .判断 (返回值 ＝ “NexGenDriven”)
        返回值 ＝ “NexGen Inc., Advanced Micro Devices.”
    .判断 (返回值 ＝ “CentaurHauls”)
        返回值 ＝ “IDT\Centaur, Via Inc.”
    .判断 (返回值 ＝ “UMC UMC UMC ”)
        返回值 ＝ “United Microelectronics Corp.”
    .判断 (返回值 ＝ “RiseRiseRise”)
        返回值 ＝ “Rise.”
    .判断 (返回值 ＝ “GenuineTMx86”)
        返回值 ＝ “Transmeta.”
    .判断 (返回值 ＝ “TransmetaCPU”)
        返回值 ＝ “Transmeta.”
    .默认
        返回值 ＝ “Unknown Manufacturer.”
    .判断结束
    返回 (返回值)

.子程序 系统_取CPU序列号, 文本型, 公开, 获取CPU序列号
    .局部变量 s1, 整数型, , , -4
    .局部变量 s2, 整数型, , , -8

    置入代码 ({ 184, 1, 0, 0, 0 }) ' mov eax,01h
    置入代码 ({ 49, 201 }) ' xor ecx,ecx
    置入代码 ({ 49, 210 }) ' xor edx,edx
    置入代码 ({ 15, 162 }) ' cpuid
    置入代码 ({ 137, 85, 252 }) ' mov dword [ebp-4],edx
    置入代码 ({ 137, 69, 248 }) ' mov dword [ebp-8],eax
    返回 (取八位十六进制 (s1) ＋ 取八位十六进制 (s2))

.子程序 取八位十六进制, 文本型
    .参数 a, 整数型
    .局部变量 s, 文本型

    s ＝ 取十六进制文本 (a)
    s ＝ 取重复文本 (8 － 取文本长度 (s), “0”) ＋ s
    返回 (s)

.子程序 系统_取CPU时钟频率, 整数型, 公开, 获取CPU时钟频率
    .局部变量 cuStart, 长整数型
    .局部变量 cuStop, 长整数型
    .局部变量 nFreq, 长整数型
    .局部变量 nCtrStart, 长整数型
    .局部变量 nCtrStop, 长整数型

    连续赋值 (0, cuStart, cuStop)
    QueryPerformanceFrequency (nFreq)
    置入代码 ({ 15, 49, 137, 69, 248, 137, 85, 252 })
    ' RDTSC
    ' MOV DWORD PTR SS:[cuStart], EAX
    ' MOV DWORD PTR SS:[cuStart+4], EDX
    QueryPerformanceCounter (nCtrStop)
    nCtrStop ＝ nCtrStop ＋ nFreq
    .循环判断首 ()
        QueryPerformanceCounter (nCtrStart)
    .循环判断尾 (nCtrStart ＜ nCtrStop)
    置入代码 ({ 15, 49, 137, 69, 240, 137, 85, 244 })
    ' RDTSC
    ' MOV DWORD PTR SS:[cuStop], EAX
    ' MOV DWORD PTR SS:[cuStop+4], EDX
    返回 ((cuStop － cuStart) ÷ 1000 ÷ 1000)

.子程序 系统_取CPU数据宽度, 整数型, 公开, 获取CPU数据宽度
    .局部变量 返回值, 逻辑型

    IsWow64Process (-1, 返回值)
    
    返回 (选择 (取反 (返回值), 32, 64))

.子程序 系统_取CPU一级缓存, 整数型, 公开, 获取CPU一级缓存
    置入代码 ({ 83, 81, 82, 184, 5, 0, 0, 128, 15, 162, 193, 234, 24, 193, 233, 24, 3, 209, 139, 194, 90, 89, 91, 139, 229, 93, 195 })
    ' PUSH EBX
    ' PUSH ECX
    ' PUSH EDX
    ' MOV EAX, 80000005
    ' CPUID
    ' SHR EDX, 18
    ' SHR ECX, 18
    ' ADD EDX, ECX
    ' MOV EAX, EDX
    ' POP EDX
    ' POP ECX
    ' POP EBX
    ' MOV ESP, EBP
    ' POP EBP
    ' RETN
    返回 (0)

.子程序 系统_取CPU二级缓存, 整数型, 公开, 获取CPU二级缓存
    置入代码 ({ 83, 81, 82, 184, 6, 0, 0, 128, 15, 162, 193, 233, 16, 139, 193, 90, 89, 91, 139, 229, 93, 195 })
    ' PUSH EBX
    ' PUSH ECX
    ' PUSH EDX
    ' MOV EAX, 80000006
    ' CPUID
    ' SHR ECX, 10
    ' MOV EAX, ECX
    ' POP EDX
    ' POP ECX
    ' POP EBX
    ' MOV ESP, EBP
    ' POP EBP
    ' RETN
    返回 (0)

.子程序 wsprintfA, 整数型
    .参数 lpstr, 文本型, 参考
    .参数 lpcstr, 文本型
    .参数 参数, 整数型, 数组
    .局部变量 Address, 整数型

    Address ＝ GetProcAddress (GetModuleHandleA (“user32.dll”), “wsprintfA”)
    置入代码 ({ 139, 69, 16, 139, 0, 139, 88, 4, 131, 251, 1, 124, 7, 255, 116, 152, 4, 75, 235, 244, 139, 69, 12, 255, 48, 139, 69, 8, 255, 48, 255, 85, 252 })
    ' API_GetProcAddress1 ()
    
    
    ' MOV EAX, DWORD PTR SS:[EBP+10]
    ' MOV EAX, DWORD PTR DS:[EAX]
    ' MOV EBX, DWORD PTR DS:[EAX+4]
    ' @Jump1:
    ' CMP EBX, 1
    ' JL SHORT Jump2
    ' PUSH DWORD PTR DS:[EAX+EBX*4+4]
    ' DEC EBX
    ' JMP SHORT Jump1
    ' @Jump2:
    ' MOV EAX, DWORD PTR SS:[EBP+C]
    ' PUSH DWORD PTR DS:[EAX]
    ' MOV EAX, DWORD PTR SS:[EBP+8]
    ' PUSH DWORD PTR DS:[EAX]
    ' CALL DWORD PTR SS:[EBP-4]
    ' MOV ESP, EBP
    ' POP EBP
    ' RETN 0C
    返回 (0)

.子程序 系统_取本机名, 文本型, 公开, 取本机名,成功返回本机名，失败返回空字符串。
    返回 (取主机名 ())

.子程序 系统_取本机IP, 逻辑型, 公开, 本命令可以枚举出网卡绑定的IP地址。成功“真”，失败返回“假”。
    .参数 本地IP组, 文本型, 参考 数组, 提供文本型数组，每个成员对应一个本地的IP。
    .局部变量 本机名, 文本型
    .局部变量 arrIpAddress, 字节集
    .局部变量 strIpAddress, 文本型
    .局部变量 lngRetVal, 整数型
    .局部变量 临时变量, 整数型
    .局部变量 udtHostent, 字节集
    .局部变量 lngPtrToIP, 字节集
    .局部变量 Addresses, 字节集, , "0"
    .局部变量 循环变量, 整数型

    本机名 ＝ 取主机名 ()
    udtHostent ＝ 取空白字节集 (16)
    RtlMoveMemory_int2Bytes (udtHostent, gethostbyname (本机名), 16)
    lngPtrToIP ＝ 取空白字节集 (4)
    RtlMoveMemory_int2Bytes (lngPtrToIP, 取字节集数据 (取字节集右边 (udtHostent, 4), #整数型, ), 4)
    .判断循环首 (取字节集数据 (lngPtrToIP, #整数型, ) ≠ 0)
        arrIpAddress ＝ 取空白字节集 (取字节集数据 (取字节集中间 (udtHostent, 11, 2), #整数型, ))
        RtlMoveMemory_int2Bytes (arrIpAddress, 取字节集数据 (lngPtrToIP, #整数型, ), 取字节集数据 (取字节集中间 (udtHostent, 11, 2), #整数型, ))
        加入成员 (Addresses, arrIpAddress)
        临时变量 ＝ 取字节集数据 (取字节集右边 (udtHostent, 4), #整数型, ) ＋ 4
        udtHostent ＝ 取字节集左边 (udtHostent, 12) ＋ 到字节集 (临时变量)
        RtlMoveMemory_int2Bytes (lngPtrToIP, 取字节集数据 (取字节集右边 (udtHostent, 4), #整数型, ), 4)
    .判断循环尾 ()
    重定义数组 (本地IP组, 假, 取数组成员数 (Addresses))
    .计次循环首 (取数组成员数 (Addresses), 循环变量)
        本地IP组 [循环变量] ＝ 到文本 (取字节集数据 (取字节集左边 (Addresses [循环变量], 1), #字节型, )) ＋ “.” ＋ 到文本 (取字节集数据 (取字节集中间 (Addresses [循环变量], 2, 1), #字节型, )) ＋ “.” ＋ 到文本 (取字节集数据 (取字节集中间 (Addresses [循环变量], 3, 1), #字节型, )) ＋ “.” ＋ 到文本 (取字节集数据 (取字节集右边 (Addresses [循环变量], 1), #字节型, ))
    .计次循环尾 ()
    返回 (真)

.子程序 系统_取磁盘类型, 整数型, 公开, 获取磁盘的类型，失败返回0，成功返回：1=移动U盘，2=系统磁盘，3=网络磁盘，4=CD-ROM,5=RAM 磁盘
    .参数 磁盘盘符, 文本型, , 如：C、D
    .局部变量 文件, 对象
    .局部变量 对象, 对象

    CoInitialize (0)
    .如果真 (文件.创建 (“scripting.FileSystemObject”, ))
        对象 ＝ 文件.读对象型属性 (“GetDrive”, 磁盘盘符 ＋ “:\”)
        CoUninitialize ()
        返回 (对象.读数值属性 (“DriveType”, ))
    .如果真结束
    CoUninitialize ()
    返回 (0)

.子程序 系统_显示桌面, , 公开, 类似按下 Win+D 键
    .局部变量 IShellDispatch, 对象

    CoInitialize (0)
    IShellDispatch.创建 (“Shell.Application”, )
    IShellDispatch.方法 (“ToggleDesktop”, )
    IShellDispatch.清除 ()
    CoUninitialize ()

.子程序 系统_取CPU占用率, 整数型, 公开, 取当前CPU占用率。成功返回CPU占用率；失败返回-1。Win98系统下使用本方法取得的数值可能会有误。
    .局部变量 sbSysBasicInfo, SYSTEM_INFO
    .局部变量 hMemSysPerforfInfo
    .局部变量 hMemSysTimeInfo
    .局部变量 dbIdleTime, 双精度小数型
    .局部变量 dbSystemTime, 双精度小数型
    .局部变量 Status, 整数型
    .局部变量 tCpuUsed, 整数型
    .局部变量 ReturnLength
    .局部变量 liKeSystemTime, 双精度小数型
    .局部变量 liIdleTime, 双精度小数型

    处理事件 ()
    GetNativeSystemInfo (sbSysBasicInfo)
    .如果真 (Status ≠ 0)
        结束 ()
    .如果真结束
    hMemSysTimeInfo ＝ GlobalAlloc (64, 48)
    Status ＝ NtQuerySystemInformation (3, hMemSysTimeInfo, 48, ReturnLength)
    .如果真 (Status ≠ 0)
        返回 (-1)
    .如果真结束
    liKeSystemTime ＝ 取字节集数据 (指针到字节集 (hMemSysTimeInfo ＋ 8, 8), #长整数型, )
    hMemSysPerforfInfo ＝ GlobalAlloc (64, 344)
    Status ＝ NtQuerySystemInformation (2, hMemSysPerforfInfo, 344, ReturnLength)
    .如果真 (Status ≠ 0)
        返回 (-1)
    .如果真结束
    liIdleTime ＝ 取字节集数据 (指针到字节集 (hMemSysPerforfInfo, 8), #长整数型, )
    dbIdleTime ＝ liIdleTime － liOldIdleTime
    dbSystemTime ＝ liKeSystemTime － liOldSystemTime
    dbIdleTime ＝ dbIdleTime ÷ dbSystemTime
    dbIdleTime ＝ 100 － dbIdleTime × 100 ÷ sbSysBasicInfo.dwNumberOrfProcessors ＋ 0.5
    tCpuUsed ＝ dbIdleTime
    liOldIdleTime ＝ liIdleTime
    liOldSystemTime ＝ liKeSystemTime
    .如果 (tCpuUsed ≤ 0)
        tCpuUsed ＝ 1
    .否则
        tCpuUsed ＝ 选择 (tCpuUsed ≥ 100, 100, tCpuUsed)
    .如果结束
    GlobalFree (hMemSysTimeInfo)
    GlobalFree (hMemSysPerforfInfo)
    返回 (tCpuUsed)

.子程序 系统_取时区, 文本型, 公开, 获取系统时区
    .局部变量 szTimeZone, 文本型
    .局部变量 m_timezone, 时区信息_
    .局部变量 lRetVal1, 整数型

    lRetVal1 ＝ GetTimeZoneInformation (m_timezone)
    szTimeZone ＝ 编码_Unicode到Ansi (到字节集 (m_timezone.StandardName))
    返回 (szTimeZone)

.子程序 系统_取货币符号, 文本型, 公开, 获取系统货币符号
    .局部变量 sbuffer, 文本型

    sbuffer ＝ 取空白文本 (256)
    GetLocaleInfo (0, 20, sbuffer, 256)
    返回 (sbuffer)

.子程序 系统_取日期格式, 文本型, 公开, 获取系统日期格式
    .局部变量 sbuffer, 文本型

    sbuffer ＝ 取空白文本 (256)
    GetLocaleInfo (0, 32, sbuffer, 256)
    返回 (sbuffer)
    

.子程序 系统_取时间格式, 文本型, 公开, 获取系统时间格式
    .局部变量 sbuffer, 文本型

    sbuffer ＝ 取空白文本 (256)
    GetLocaleInfo (0, 4099, sbuffer, 256)
    返回 (sbuffer)
    

.子程序 系统_取网络主机名, 文本型, 公开, 取当前网络上登记的主机名，详细请参考CMD命令ipconfig /all 中的Windows IP 配置。
    .局部变量 hMem
    .局部变量 ulOutBufLen
    .局部变量 Status
    .局部变量 HostName, 文本型

    GetNetworkParams (0, ulOutBufLen)
    hMem ＝ LocalAlloc (64, ulOutBufLen)
    Status ＝ GetNetworkParams (hMem, ulOutBufLen)
    .如果真 (Status ＝ 0)
        HostName ＝ 到文本 (指针到字节集 (hMem, 132))
    .如果真结束
    LocalFree (hMem)
    返回 (HostName)

.子程序 系统_取网络主DNS后缀, 文本型, 公开, 取当前网络主DNS后缀，详细请参考CMD命令ipconfig /all 中的Windows IP 配置。
    .局部变量 hMem
    .局部变量 ulOutBufLen
    .局部变量 Status
    .局部变量 DomainName, 文本型

    GetNetworkParams (0, ulOutBufLen)
    hMem ＝ LocalAlloc (64, ulOutBufLen)
    Status ＝ GetNetworkParams (hMem, ulOutBufLen)
    .如果真 (Status ＝ 0)
        DomainName ＝ 到文本 (指针到字节集 (hMem ＋ 132, 132))
    .如果真结束
    LocalFree (hMem)
    返回 (DomainName)

.子程序 系统_取网络节点类型, 整数型, 公开, 返回值：1=广播；2=点对点；4=混杂；8=混合。详细请参考CMD中的ipconfig /all Windows IP 配置。
    .局部变量 hMem
    .局部变量 ulOutBufLen
    .局部变量 Status
    .局部变量 NodeType

    GetNetworkParams (0, ulOutBufLen)
    hMem ＝ LocalAlloc (64, ulOutBufLen)
    Status ＝ GetNetworkParams (hMem, ulOutBufLen)
    .如果真 (Status ＝ 0)
        NodeType ＝ 取字节集数据 (指针到字节集 (hMem ＋ 308, 4), #整数型, )
    .如果真结束
    LocalFree (hMem)
    返回 (NodeType)

.子程序 系统_IP路由是否启用, 逻辑型, 公开, 判断当前网络连接中的IP路由是否启用，详细请参考CMD中的ipconfig /all Windows IP 配置。
    .局部变量 hMem
    .局部变量 ulOutBufLen
    .局部变量 Status
    .局部变量 EnableRouting, 逻辑型

    GetNetworkParams (0, ulOutBufLen)
    hMem ＝ LocalAlloc (64, ulOutBufLen)
    Status ＝ GetNetworkParams (hMem, ulOutBufLen)
    .如果真 (Status ＝ 0)
        EnableRouting ＝ 取字节集数据 (指针到字节集 (hMem ＋ 572, 4), #逻辑型, )
    .如果真结束
    LocalFree (hMem)
    返回 (EnableRouting)

.子程序 系统_WINS代理是否启用, 逻辑型, 公开, 判断当前网络连接中的WINS代理是否启用，详细请参考CMD中的ipconfig /all Windows IP 配置。
    .局部变量 hMem
    .局部变量 ulOutBufLen
    .局部变量 Status
    .局部变量 EnableProxy, 逻辑型

    GetNetworkParams (0, ulOutBufLen)
    hMem ＝ LocalAlloc (64, ulOutBufLen)
    Status ＝ GetNetworkParams (hMem, ulOutBufLen)
    .如果真 (Status ＝ 0)
        EnableProxy ＝ 取字节集数据 (指针到字节集 (hMem ＋ 576, 4), #逻辑型, )
    .如果真结束
    LocalFree (hMem)
    返回 (EnableProxy)

.子程序 系统_取IE版本, 文本型, 公开, 获取IE浏览器的版本
    .局部变量 Status
    .局部变量 hKey
    .局部变量 dwSize
    .局部变量 sbuffer, 字节集
    .局部变量 flag
    .局部变量 bool, 逻辑型

    IsWow64Process (GetCurrentProcess (), bool)
    flag ＝ 选择 (bool, #KEY_WOW64_64KEY, #KEY_WOW64_32KEY)
    Status ＝ RegOpenKeyExA (#HKEY_LOCAL_MACHINE, “SOFTWARE\Microsoft\Internet Explorer”, 0, 位或 (flag, #KEY_ALL_ACCESS), hKey)
    sbuffer ＝ 取空白字节集 (50)
    .如果真 (Status ＝ 0)
        Status ＝ RegQueryValueExA (hKey, “svcVersion”, 0, #REG_SZ, sbuffer, 50)
        .如果真 (Status ≠ 0)
            RegQueryValueExA (hKey, “Version”, 0, #REG_SZ, sbuffer, 50)
        .如果真结束
        
    .如果真结束
    RegCloseKey (hKey)
    返回 (到文本 (sbuffer))

.子程序 系统_调用帮助, 整数型, 公开, 调用系统帮助设置
    .参数 窗口句柄, 整数型, , hwnd
    .参数 帮助文件, 文本型, , lpHelpFile
    .参数 命令编号, 整数型, , wCommand

    返回 (WinHelpA (窗口句柄, 帮助文件, 命令编号, 1))

.子程序 系统_信息框Ex, 整数型, 公开, 消息规定时间内超时自动关闭，成功返回单击按钮ID，失败返回0
    .参数 标题, 文本型
    .参数 内容, 文本型
    .参数 超时时间, , , 1000限1秒
    .参数 按钮类型, , , 1 确定+取消 2 终止+重试+忽略  3 是+否+取消 4 是+否 5 重试+取消 　6 取消+重试+继续  16 红X+确定 17 红X+确定+取消 18 红X+终止+重试+忽略  19 红X+是+否+取消 20 红X+是+否  21 红X+重试+取消  32 蓝问号+确定  33 蓝问号+确定+取消   34 蓝问号+终止+重试+忽略   35 蓝问号+是+否+取消  36 蓝问号+是+否  37 蓝问号+重试+取消  48 黄叹号+确定 49 黄叹号+确定+取消 50 黄叹号+终止+重试+忽略  51 黄叹号+是+否+取消  52 黄叹号+是+否  53 黄叹号+重试+取消    64 蓝叹号+确定  65 蓝叹号+确定+取消  66 蓝叹号+终止+重试+忽略  67 蓝叹号+是+否+取消   68 蓝叹号+是+否   69 蓝叹号+重试+取消 

    返回 (MessageBoxTimeoutA (GetActiveWindow (), 内容, 标题, 按钮类型, 0, 超时时间))

.子程序 系统_转换为主机名, 文本型, 公开, 将指定的 IP 地址转换为其主机名。如果失败返回空文本。
    .参数 欲转换IP地址, 文本型
    .局部变量 局_返回值
    .局部变量 局_套接字, 套接字信息
    .局部变量 局_地址结构, 整数型
    .局部变量 局_IP指针
    .局部变量 局_主机结构, hostent
    .局部变量 局_域名, 文本型

    局_返回值 ＝ WSAStartup (257, 局_套接字)
    .如果真 (0 ＝ 局_返回值)
        局_地址结构 ＝ inet_addr (欲转换IP地址)
        局_IP指针 ＝ gethostbyaddr (局_地址结构, 4, 2)
        .如果真 (0 ≠ 局_IP指针)
            CopyMemory_int2hostent (局_主机结构, 局_IP指针, 16)
            局_域名 ＝ 指针到文本 (局_主机结构.h_name)
        .如果真结束
        WSACleanup ()
    .如果真结束
    返回 (局_域名)

.子程序 系统_转换为IP地址, 文本型, 公开, 将指定的主机名转换为其 IP 地址。如果失败返回空文本。
    .参数 欲转换主机名, 文本型
    .局部变量 局_返回值
    .局部变量 局_套接字, 套接字信息
    .局部变量 局_主机指针
    .局部变量 局_主机结构, hostent
    .局部变量 局_变量, 字节集

    局_返回值 ＝ WSAStartup (257, 局_套接字)
    .如果真 (0 ＝ 局_返回值)
        局_主机指针 ＝ gethostbyname (欲转换主机名)
        .如果真 (0 ≠ 局_主机指针)
            CopyMemory_int2hostent (局_主机结构, 局_主机指针, 16)
            局_变量 ＝ 指针到字节集 (取字节集数据 (指针到字节集 (局_主机结构.h_addr_list, 4), #整数型, ), 4)
            返回 (到文本 (局_变量 [1]) ＋ “.” ＋ 到文本 (局_变量 [2]) ＋ “.” ＋ 到文本 (局_变量 [3]) ＋ “.” ＋ 到文本 (局_变量 [4]))
        .如果真结束
        WSACleanup ()
    .如果真结束
    返回 (“”)

.子程序 系统_通信测试, 整数型, 公开,  测试与指定主机是否能够正常通讯。返回被测试主机的通讯响应时间。如果无法通讯或者测试失败，返回 -1。
    .参数 被测试主机地址, 文本型, , 可以为主机名、IP地址等。
    .参数 最长等待时间, , 可空, 可以被省略。指定最长等待被测试主机响应的时间，单位为毫秒。超过此时间即认为无法与被测试主机通讯。如果省略本参数，则默认为 10 * 1000 毫秒，即 10 秒。
    .局部变量 局_ICMP结构, ICMP_ECHO_REPLY
    .局部变量 局_地址指针, 整数型, , ,   ‘括号内为要Ping的目的地IP地址
    .局部变量 局_超时, 整数型
    .局部变量 局_返回值, 整数型
    .局部变量 局_IP地址, 文本型
    .局部变量 局_ICMP句柄

    局_IP地址 ＝ 系统_转换为IP地址 (被测试主机地址)
    .如果真 (取文本长度 (局_IP地址) ＞ 2)
        局_ICMP句柄 ＝ IcmpCreateFile ()
        .如果真 (-1 ＝ 局_ICMP句柄)
            返回 (-1)
        .如果真结束
        局_地址指针 ＝ inet_addr (局_IP地址)
        局_超时 ＝ 选择 (是否为空 (最长等待时间), 10 × 1000, 最长等待时间) ' 这是超时时间
        局_返回值 ＝ IcmpSendEcho (局_ICMP句柄, 局_地址指针, 局_IP地址, 取文本长度 (局_IP地址) ＋ 1, 0, 局_ICMP结构, 278, 局_超时)
        IcmpCloseHandle (局_ICMP句柄)
    .如果真结束
    返回 (选择 (局_返回值 ≠ 0 且 局_ICMP结构.Status ＝ #IP_SUCCESS, 局_ICMP结构.RoundTripTime, -1))

.子程序 系统_取远程机器名, 文本型, 公开,  根据指定的IP地址取远程机器名称。失败返回空。
    .参数 参_IP地址, 文本型, , 注；指定IP地址必需和本机在同一个域
    .局部变量 局_套按字, 套接字信息
    .局部变量 局_整数IP
    .局部变量 局_域名指针
    .局部变量 局_返回文本, 文本型

    .如果真 (WSAStartup (257, 局_套按字) ＝ 0)
        局_整数IP ＝ inet_addr (参_IP地址)
        局_域名指针 ＝ gethostbyaddr (局_整数IP, 4, 2)
        .如果真 (局_域名指针 ≠ 0)
            局_返回文本 ＝ 指针到文本 (取字节集数据 (指针到字节集 (局_域名指针, 4), #整数型, ))
        .如果真结束
        WSACleanup ()
    .如果真结束
    返回 (局_返回文本)

.子程序 系统_远程关机, 逻辑型, 公开, 可关闭本机或局域网指定计算机系统，成功返回真，失败返回假。
    .参数 参_关闭方式, , 可空, 可为空，默认即关闭系统，0=注销 ，1=关机，2=重启，8=关闭电源(电源支持)
    .参数 参_是否强制执行, 逻辑型, 可空, 默认非强制执行
    .参数 参_计算机名, 文本型, 可空, 必须是局域网内计算机,为空则为本机,可以用 系统_取远程机器名(IP)
    .参数 参_用户名, 文本型, 可空, 当参数 【参_计算机名】 为空时，可以忽略此参数
    .参数 参_密码, 文本型, 可空, 当参数 【参_计算机名】 为空时，可以忽略此参数
    .局部变量 objWbemLocator, 对象
    .局部变量 objWMIService, 对象
    .局部变量 objShare, 对象
    .局部变量 objInParam, 对象
    .局部变量 objOutParams, 对象
    .局部变量 var, 变体型
    .局部变量 Security, 对象
    .局部变量 WMIServiceObject, 对象
    .局部变量 count
    .局部变量 i, 整数型
    .局部变量 NewEnum, 对象
    .局部变量 hresult
    .局部变量 pceltFetched, 整数型
    .局部变量 ReturnValue, 整数型
    .局部变量 strUser, 文本型

    CoInitialize (0)
    .如果真 (objWbemLocator.创建 (“WbemScripting.SWbemLocator”, ))
        参_计算机名 ＝ 选择 (取文本长度 (参_计算机名) ＞ 0, 参_计算机名, “.”)
        参_关闭方式 ＝ 选择 (是否为空 (参_关闭方式), 1, 参_关闭方式)
        objWMIService ＝ objWbemLocator.对象型方法 (“ConnectServer”, 参_计算机名, “\root\CIMV2”, 参_用户名, 参_密码, , , , ) ' 连接服务器
        .如果真 (objWMIService.是否为空 () ＝ 假)
            ' ---------------WMI提取-----------------
            Security ＝ objWMIService.读对象型属性 (“Security_”, )
            Security.写属性 (“ImpersonationLevel”, 3)
            Security.读对象型属性 (“Privileges”, ).对象型方法 (“Add”, 19, 真) ' 19=调试权限
            Security.读对象型属性 (“Privileges”, ).对象型方法 (“Add”, 18, 真) ' 18=关机权限
            ' ---------------WMI提取-----------------
            WMIServiceObject ＝ objWMIService.对象型方法 (“InstancesOf”, “Win32_OperatingSystem”)
            count ＝ WMIServiceObject.读数值属性 (“Count”, )
            NewEnum ＝ WMIServiceObject.对象型方法 (“_NewEnum”, )
            .如果真 (NewEnum.是否为空 () ＝ 假)
                .计次循环首 (count, i)
                    hresult ＝ CallObject (取对象指针 (NewEnum), 3, 1, 取变体型指针 (var), 取指针整数_ (pceltFetched), , , , , , )
                    .如果真 (hresult ＝ 0 且 pceltFetched ＝ 1)
                        objShare ＝ var.取对象 ()
                        .如果真 (objShare.是否为空 () ＝ 假)
                            objInParam ＝ objShare.读对象型属性 (“Methods_”, ).对象型方法 (“Item”, “Win32Shutdown”).读对象型属性 (“InParameters”, ).对象型方法 (“SpawnInstance_”, )
                            ' 添加输入参数
                            objInParam.对象型方法 (“Properties_”, ).对象型方法 (“Item”, “Flags”).写属性 (“value”, 参_关闭方式 ＋ 选择 (参_是否强制执行, 4, 0))
                            ' 运行方法
                            objOutParams ＝ objShare.对象型方法 (“ExecMethod_”, “Win32Shutdown”, objInParam)
                            .如果真 (objOutParams.是否为空 () ＝ 假)
                                var ＝ objOutParams.读对象型属性 (“Properties_”, ).对象型方法 (“Item”, “ReturnValue”).读属性 (“value”, )
                                ReturnValue ＝ var.取数值 ()
                                objOutParams.清除 ()
                                objShare.清除 ()
                                objWMIService.清除 ()
                                objWbemLocator.清除 ()
                                WMIServiceObject.清除 ()
                                CoUninitialize ()
                                返回 (ReturnValue ＝ 0)
                            .如果真结束
                            
                        .如果真结束
                        
                    .如果真结束
                    
                .计次循环尾 ()
                NewEnum.清除 ()
            .如果真结束
            objShare.清除 ()
            objWMIService.清除 ()
            WMIServiceObject.清除 ()
        .如果真结束
        objWbemLocator.清除 ()
        CoUninitialize ()
    .如果真结束
    返回 (假)

.子程序 系统_是否为管理员, 逻辑型, 公开, 判断当前程序是否在管理员模式下运行，是返回真，否返回假。
    返回 (IsNTAdmin (0, 0))

.子程序 系统_重启资源管理器, 逻辑型, 公开, 重启资源管理器
    .局部变量 局_路径, 文本型

    ' 关闭资源管理器
    运行 (“taskkill /im explorer.exe /f”, 假, #隐藏窗口)
    Sleep (600)
    ' 打开资源管理器
    局_路径 ＝ 取空白文本 (255)
    .如果真 (SHGetFolderPathA (#NULL, #CSIDL_WINDOWS, #NULL, #SHGFP_TYPE_DEFAULT, 取指针文本_ (局_路径)) ≠ #S_OK)
        局_路径 ＝ “C:\WINDOWS”
    .如果真结束
    返回 (ShellExecuteA (#NULL, “Open”, “explorer.exe”, 字符 (0), 局_路径, #SW_NORMAL) ≠ #ERROR_FILE_NOT_FOUND)

.子程序 系统_刷新, , 公开, 立即刷新系统，让注册表新的设置立即生效。
    SHChangeNotify (#SHCNE_ASSOCCHANGED, #SHCNF_IDLIST, 0, 0)

.子程序 系统_禁用文件系统重定向, 逻辑型, 公开, 禁用调用线程的文件系统重定向，默认情况下启用文件系统重定向。此功能对于想要访问本机system32目录的32位应用程序很有用。
    .如果真 (_WIN32_WINNT ＜ #_WIN32_WINNT_WIN7)
        输出调试文本 (#ERROR_NOTVERSION)
        返回 (假)
    .如果真结束
    返回 (Wow64DisableWow64FsRedirection (0))

.子程序 系统_恢复文件系统重定向, 逻辑型, 公开, 恢复调用线程的文件系统重定向。
    .如果真 (_WIN32_WINNT ＜ #_WIN32_WINNT_WIN7)
        输出调试文本 (#ERROR_NOTVERSION)
        返回 (假)
    .如果真结束
    返回 (Wow64RevertWow64FsRedirection (0))

.子程序 系统_取消电源管理, 逻辑型, 公开, 避免睡眠、待机
    返回 (SetThreadExecutionState (位或 (#ES_CONTINUOUS, #ES_SYSTEM_REQUIRED, #ES_DISPLAY_REQUIRED)) ≠ #NULL)

.子程序 系统_恢复电源管理, 逻辑型, 公开
    返回 (SetThreadExecutionState (#ES_CONTINUOUS) ≠ #NULL)

.子程序 系统_去掉屏保, 逻辑型, 公开
    .局部变量 bAct, 逻辑型

    SystemParametersInfoA (#SPI_GETSCREENSAVEACTIVE, 0, 取指针_通用型 (bAct), 0)
    .如果真 (bAct)
        返回 (SystemParametersInfoA (#SPI_SETSCREENSAVEACTIVE, 0, 0, 0))
    .如果真结束
    返回 (真) ' 屏幕保护没有被启用

.子程序 系统_恢复屏保, 逻辑型, 公开
    .局部变量 bAct, 逻辑型

    SystemParametersInfoA (#SPI_GETSCREENSAVEACTIVE, 0, 取指针_通用型 (bAct), 0)
    .如果真 (bAct ＝ 假)
        返回 (SystemParametersInfoA (#SPI_SETSCREENSAVEACTIVE, 1, 0, 0))
    .如果真结束
    返回 (真) ' 屏幕保护没有被关闭

.子程序 系统_取所有用户名, 整数型, 公开, 获取Windows系统所有用户名
    .参数 用户名, 文本型, 参考 数组
    .局部变量 l_pUserInfo, 整数型
    .局部变量 l_dwentriesread, 整数型
    .局部变量 l_dwtotalentries, 整数型
    .局部变量 address, 整数型
    .局部变量 usri0_name, 整数型
    .局部变量 i, 整数型

    清除数组 (用户名)
    NetUserEnum (#NULL, 0, 0, 取指针地址_整数型 (l_pUserInfo), #MAX_PREFERRED_LENGTH, l_dwentriesread, l_dwtotalentries, #NULL)
    .计次循环首 (l_dwentriesread, i)
        address ＝ l_pUserInfo ＋ (i － 1) × 4
        address ＝ 指针_到整数 (address)
        usri0_name ＝ W2A_指针 (address, m_CodePage, #CP_ACP, 0)
        加入成员 (用户名, 指针到文本 (usri0_name))
    .计次循环尾 ()
    返回 (取数组成员数 (用户名))

.子程序 系统_注册项是否存在, 逻辑型, 公开, 存在返回真
    .参数 根目录, 整数型, , #HKEY_*
    .参数 全路径注册项名, 文本型
    .参数 项名称, 文本型
    .参数 是否为64位注册表, 逻辑型, 可空

    返回 (系统_注册项是否存在W (根目录, 编码_Ansi到Unicode (全路径注册项名, ), 编码_Ansi到Unicode (项名称, ), 是否为64位注册表))

.子程序 系统_注册项是否存在W, 逻辑型, 公开, 存在返回真
    .参数 根目录, 整数型, , #HKEY_*
    .参数 全路径注册项名, 字节集
    .参数 项名称, 字节集
    .参数 是否为64位注册表, 逻辑型, 可空
    .局部变量 hKey, 整数型
    .局部变量 dwFlags, 整数型
    .局部变量 lRes, 整数型
    .局部变量 Data, 整数型
    .局部变量 cbData, 整数型

    .如果真 (根目录 ＝ 0)
        返回 (假)
    .如果真结束
    dwFlags ＝ 位或 (选择 (是否为64位注册表, #KEY_WOW64_64KEY, #KEY_WOW64_32KEY), #KEY_QUERY_VALUE)
    lRes ＝ RegOpenKeyExW (根目录, 全路径注册项名, 0, dwFlags, hKey)
    .如果真 (lRes ≠ #ERROR_SUCCESS)
        输出调试文本 (取错误信息文本_API (lRes))
        返回 (假)
    .如果真结束
    lRes ＝ RegQueryValueExW (hKey, 项名称, #NULL, Data, #NULL, cbData)
    .如果真 (lRes ≠ #ERROR_SUCCESS)
        输出调试文本 (取错误信息文本_API (lRes, ))
    .如果真结束
    RegCloseKey (hKey)
    返回 (lRes ＝ #ERROR_SUCCESS)

.子程序 系统_取文本注册项, 文本型, 公开, 成功返回数据
    .参数 根目录, 整数型, , #HKEY_*
    .参数 全路径注册项名, 文本型
    .参数 项名称, 文本型
    .参数 是否为64位注册表, 逻辑型, 可空

    返回 (编码_Unicode到Ansi (系统_取文本注册项W (根目录, 编码_Ansi到Unicode (全路径注册项名, ), 编码_Ansi到Unicode (项名称, ), 是否为64位注册表)))

.子程序 系统_取文本注册项W, 字节集, 公开, 成功返回数据
    .参数 根目录, 整数型, , #HKEY_*
    .参数 全路径注册项名, 字节集
    .参数 项名称, 字节集
    .参数 是否为64位注册表, 逻辑型, 可空
    .局部变量 hKey, 整数型
    .局部变量 dwFlags, 整数型
    .局部变量 lRes, 整数型
    .局部变量 Data, 整数型
    .局部变量 cbData, 整数型
    .局部变量 lpData, 字节集

    .如果真 (根目录 ＝ 0)
        返回 ({ })
    .如果真结束
    dwFlags ＝ 位或 (选择 (是否为64位注册表, #KEY_WOW64_64KEY, #KEY_WOW64_32KEY), #KEY_QUERY_VALUE)
    lRes ＝ RegOpenKeyExW (根目录, 全路径注册项名, 0, dwFlags, hKey)
    .如果真 (lRes ≠ #ERROR_SUCCESS)
        输出调试文本 (取错误信息文本_API (lRes))
        返回 ({ })
    .如果真结束
    lRes ＝ RegQueryValueExW (hKey, 项名称, #NULL, Data, #NULL, cbData)
    .如果真 (lRes ＝ #ERROR_SUCCESS)
        lpData ＝ 取空白字节集 (cbData)
        lRes ＝ RegQueryValueExW (hKey, 项名称, #NULL, Data, 取指针_字节集型 (lpData), cbData)
    .如果真结束
    .如果真 (lRes ≠ #ERROR_SUCCESS)
        输出调试文本 (取错误信息文本_API (lRes, ))
    .如果真结束
    RegCloseKey (hKey)
    返回 (lpData)

.子程序 系统_写文本注册项, 逻辑型, 公开, 成功返回真
    .参数 根目录, 整数型, , #HKEY_*
    .参数 全路径注册项名, 文本型
    .参数 注册表值类型, 整数型, , #REG_*
    .参数 项名称, 文本型
    .参数 欲写入值, 文本型
    .参数 是否为64位注册表, 逻辑型, 可空

    返回 (系统_写文本注册项W (根目录, 编码_Ansi到Unicode (全路径注册项名, ), 注册表值类型, 编码_Ansi到Unicode (项名称, ), 编码_Ansi到Unicode (欲写入值, ), 是否为64位注册表))

.子程序 系统_写文本注册项W, 逻辑型, 公开, 成功返回真
    .参数 根目录, 整数型, , #HKEY_*
    .参数 全路径注册项名, 字节集
    .参数 注册表值类型, 整数型, , #REG_*
    .参数 项名称, 字节集
    .参数 欲写入值, 字节集
    .参数 是否为64位注册表, 逻辑型, 可空
    .局部变量 hKey, 整数型
    .局部变量 dwFlags, 整数型
    .局部变量 lRes, 整数型

    .如果真 (根目录 ＝ 0)
        返回 (假)
    .如果真结束
    dwFlags ＝ 位或 (选择 (是否为64位注册表, #KEY_WOW64_64KEY, #KEY_WOW64_32KEY), #KEY_WRITE)
    lRes ＝ RegOpenKeyExW (根目录, 全路径注册项名, 0, dwFlags, hKey)
    .如果真 (lRes ＝ #ERROR_FILE_NOT_FOUND)
        lRes ＝ RegCreateKeyExW (根目录, 全路径注册项名, 0, #NULL, #REG_OPTION_NON_VOLATILE, dwFlags, #NULL, hKey, #NULL)
    .如果真结束
    .如果真 (lRes ≠ #ERROR_SUCCESS)
        输出调试文本 (取错误信息文本_API (lRes))
        返回 (假)
    .如果真结束
    lRes ＝ RegSetValueExW (hKey, 项名称, 0, 注册表值类型, 取指针_字节集型 (欲写入值), 取字节集长度 (欲写入值))
    .如果真 (lRes ≠ #ERROR_SUCCESS)
        输出调试文本 (取错误信息文本_API (lRes, ))
    .如果真结束
    RegCloseKey (hKey)
    返回 (lRes ＝ #ERROR_SUCCESS)

.子程序 系统_取数值注册项, 整数型, 公开, 成功返回数据
    .参数 根目录, 整数型, , #HKEY_*
    .参数 全路径注册项名, 文本型
    .参数 项名称, 文本型
    .参数 是否为64位注册表, 逻辑型, 可空

    返回 (系统_取数值注册项W (根目录, 编码_Ansi到Unicode (全路径注册项名, ), 编码_Ansi到Unicode (项名称, ), 是否为64位注册表))

.子程序 系统_取数值注册项W, 整数型, 公开, 成功返回数据
    .参数 根目录, 整数型, , #HKEY_*
    .参数 全路径注册项名, 字节集
    .参数 项名称, 字节集
    .参数 是否为64位注册表, 逻辑型, 可空
    .局部变量 hKey, 整数型
    .局部变量 dwFlags, 整数型
    .局部变量 lRes, 整数型
    .局部变量 Data, 整数型
    .局部变量 cbData, 整数型
    .局部变量 lpData, 整数型

    .如果真 (根目录 ＝ 0)
        返回 (0)
    .如果真结束
    dwFlags ＝ 位或 (选择 (是否为64位注册表, #KEY_WOW64_64KEY, #KEY_WOW64_32KEY), #KEY_QUERY_VALUE)
    lRes ＝ RegOpenKeyExW (根目录, 全路径注册项名, 0, dwFlags, hKey)
    .如果真 (lRes ≠ #ERROR_SUCCESS)
        输出调试文本 (取错误信息文本_API (lRes))
        返回 (0)
    .如果真结束
    lRes ＝ RegQueryValueExW (hKey, 项名称, #NULL, Data, #NULL, cbData)
    .如果真 (lRes ＝ #ERROR_SUCCESS)
        lRes ＝ RegQueryValueExW (hKey, 项名称, #NULL, Data, 取指针整数_ (lpData), cbData)
    .如果真结束
    .如果真 (lRes ≠ #ERROR_SUCCESS)
        输出调试文本 (取错误信息文本_API (lRes, ))
    .如果真结束
    RegCloseKey (hKey)
    返回 (lpData)

.子程序 系统_写数值注册项, 逻辑型, 公开, 成功返回真
    .参数 根目录, 整数型, , #HKEY_*
    .参数 全路径注册项名, 文本型
    .参数 注册表值类型, 整数型, , #REG_*
    .参数 项名称, 文本型
    .参数 欲写入值, 整数型
    .参数 是否为64位注册表, 逻辑型, 可空

    返回 (系统_写数值注册项W (根目录, 编码_Ansi到Unicode (全路径注册项名, ), 注册表值类型, 编码_Ansi到Unicode (项名称, ), 欲写入值, 是否为64位注册表))

.子程序 系统_写数值注册项W, 逻辑型, 公开, 成功返回真
    .参数 根目录, 整数型, , #HKEY_*
    .参数 全路径注册项名, 字节集
    .参数 注册表值类型, 整数型, , #REG_*
    .参数 项名称, 字节集
    .参数 欲写入值, 整数型
    .参数 是否为64位注册表, 逻辑型, 可空
    .局部变量 hKey, 整数型
    .局部变量 dwFlags, 整数型
    .局部变量 lRes, 整数型

    .如果真 (根目录 ＝ 0)
        返回 (假)
    .如果真结束
    dwFlags ＝ 位或 (选择 (是否为64位注册表, #KEY_WOW64_64KEY, #KEY_WOW64_32KEY), #KEY_WRITE)
    lRes ＝ RegOpenKeyExW (根目录, 全路径注册项名, 0, dwFlags, hKey)
    .如果真 (lRes ＝ #ERROR_FILE_NOT_FOUND)
        lRes ＝ RegCreateKeyExW (根目录, 全路径注册项名, 0, #NULL, #REG_OPTION_NON_VOLATILE, dwFlags, #NULL, hKey, #NULL)
    .如果真结束
    .如果真 (lRes ≠ #ERROR_SUCCESS)
        输出调试文本 (取错误信息文本_API (lRes))
        返回 (假)
    .如果真结束
    lRes ＝ RegSetValueExW (hKey, 项名称, 0, 注册表值类型, 取指针整数_ (欲写入值), 4) ' sizeof(INT)
    .如果真 (lRes ≠ #ERROR_SUCCESS)
        输出调试文本 (取错误信息文本_API (lRes, ))
    .如果真结束
    RegCloseKey (hKey)
    返回 (lRes ＝ #ERROR_SUCCESS)

.子程序 系统_删除注册项, 逻辑型, 公开, 成功返回真
    .参数 根目录, 整数型, , #HKEY_*
    .参数 全路径注册项名, 文本型
    .参数 项名称, 文本型, 可空
    .参数 是否为64位注册表, 逻辑型, 可空
    .参数 以递归方式删除, 逻辑型, 可空, 项名称不为空

    返回 (系统_删除注册项W (根目录, 编码_Ansi到Unicode (全路径注册项名, ), 编码_Ansi到Unicode (项名称, ), 是否为64位注册表, 以递归方式删除))

.子程序 系统_删除注册项W, 逻辑型, 公开, 成功返回真
    .参数 根目录, 整数型, , #HKEY_*
    .参数 全路径注册项名, 字节集
    .参数 项名称, 字节集, 可空
    .参数 是否为64位注册表, 逻辑型, 可空
    .参数 以递归方式删除, 逻辑型, 可空, 项名称不为空
    .局部变量 hKey, 整数型
    .局部变量 dwFlags, 整数型
    .局部变量 lRes, 整数型

    .如果真 (根目录 ＝ 0)
        返回 (假)
    .如果真结束
    dwFlags ＝ 位或 (选择 (是否为64位注册表, #KEY_WOW64_64KEY, #KEY_WOW64_32KEY), #KEY_WRITE)
    .如果 (项名称 ≠ { } 且 项名称 ≠ { 0, 0 })
        lRes ＝ RegOpenKeyExW (根目录, 全路径注册项名, 0, dwFlags, hKey)
    .否则
        lRes ＝ RegOpenKeyExW (根目录, 字节集_寻找取左 (全路径注册项名, { 92, 0 }, -1) ＋ { 0, 0 }, 0, dwFlags, hKey)
    .如果结束
    .如果真 (lRes ≠ #ERROR_SUCCESS)
        输出调试文本 (取错误信息文本_API (lRes, ))
        返回 (假)
    .如果真结束
    .判断开始 (项名称 ＝ { } 或 项名称 ＝ { 0, 0 })
        lRes ＝ RegDeleteKeyW (hKey, 字节集_寻找取右 (全路径注册项名, { 92, 0 }, -1))
    .判断 (以递归方式删除)
        lRes ＝ RegDeleteTreeW (hKey, 项名称)
    .默认
        lRes ＝ RegDeleteValueW (hKey, 项名称)
    .判断结束
    .如果真 (lRes ≠ #ERROR_SUCCESS)
        输出调试文本 (取错误信息文本_API (lRes, ))
    .如果真结束
    RegCloseKey (hKey)
    返回 (lRes ＝ #ERROR_SUCCESS)

.子程序 GetKeyPathFromHKEY, 字节集, 公开, 根据hKey查找当前打开的注册表路径
    .参数 hKey, 整数型
    .局部变量 dwBufLen, 整数型
    .局部变量 lRet, 整数型
    .局部变量 pBuf, 整数型
    .局部变量 dwSize, 整数型
    .局部变量 szBuf, 字节集

    ZwQueryKey (hKey, #KeyNameInformation, #NULL, 0, dwBufLen)
    .如果真 (dwBufLen ≤ 0)
        返回 ({ })
    .如果真结束
    pBuf ＝ LocalAlloc (#LMEM_ZEROINIT, dwBufLen ＋ 2) ' 加上宽字符结尾
    lRet ＝ ZwQueryKey (hKey, #KeyNameInformation, pBuf, dwBufLen, dwBufLen)
    .如果真 (lRet ≠ #STATUS_SUCCESS)
        LocalFree (pBuf)
        输出调试文本 (取错误信息文本_API (lRet, “ntdll.dll”))
        返回 ({ })
    .如果真结束
    dwSize ＝ 指针_到整数 (pBuf)
    szBuf ＝ 指针到字节集 (pBuf ＋ 4, dwSize ＋ 2)
    LocalFree (pBuf)
    返回 (szBuf)

.子程序 系统_取所有时区, 整数型, 公开, 返回时区数量
    .参数 时区信息, 精易_时区信息, 参考 可空 数组, 用于接收时区信息
    .局部变量 局_时区信息, 精易_时区信息
    .局部变量 Str, 文本型
    .局部变量 正则, 正则表达式类
    .局部变量 i, 整数型

    ' https://bbs.125.la/forum.php?mod=viewthread&tid=14654308
    
    重定义数组 (时区信息, 假, 0)
    Str ＝ 系统_取DOS执行结果 (“tzutil /l”, )
    正则.创建 (“\((UTC[+,-]*[\d,:]*)\) (\S*)\s+(.*)(?=\r\n)”, Str, , , , )
    .如果真 (取反 (是否为空 (时区信息)))
        .计次循环首 (正则.取匹配数量 (), i)
            局_时区信息.时区 ＝ 正则.取子匹配文本 (i, 1, )
            局_时区信息.时区名 ＝ 正则.取子匹配文本 (i, 2, )
            局_时区信息.时区代码 ＝ 正则.取子匹配文本 (i, 3, )
            加入成员 (时区信息, 局_时区信息)
        .计次循环尾 ()
    .如果真结束
    返回 (正则.取匹配数量 ())

.子程序 系统_设置时区, 逻辑型, 公开, 成功返回真, 失败返回假
    .参数 时区代码, 文本型, 可空, 如：China Standard Time，为空则自动设为北京时区
    .局部变量 局_时区代码, 文本型
    .局部变量 局_执行结果, 文本型

    ' https://bbs.125.la/forum.php?mod=viewthread&tid=14654308
    
    .如果 (是否为空 (时区代码))
        局_时区代码 ＝ “China Standard Time”
    .否则
        局_时区代码 ＝ 删首尾空 (时区代码)
    .如果结束
    
    局_执行结果 ＝ 系统_取DOS执行结果 (“tzutil /s ” ＋ #引号 ＋ 局_时区代码 ＋ #引号, )
    .如果真 (局_执行结果 ＝ “”)
        返回 (真)
    .如果真结束
    
    输出调试文本 (文本_取出中间文本 (局_执行结果, “TZUTIL: ”, #换行符, , ))
    返回 (假)

.子程序 系统_取输入设备数量, 整数型, 公开, 返回设备数; 返回值为零表示不存在设备或发生错误
    返回 (waveInGetNumDevs ())

.子程序 取磁盘总线, 整数型
    .参数 盘符, 文本型, , C:
    .局部变量 hDevice, 整数型
    .局部变量 result, 逻辑型
    .局部变量 readed, 整数型
    .局部变量 pDevDesc, STORAGE_DEVICE_DESCRIPTOR
    .局部变量 devDescLength, 整数型
    .局部变量 query, STORAGE_PROPERTY_QUERY

    hDevice ＝ CreateFileA (“\\.\” ＋ 盘符, 位或 (2147483648, 1073741824), 位或 (1, 2), 0, 3, 0, 0)
    
    ' .常量 FILE_FLAG_WRITE_THROUGH, "2147483648"
    ' .常量 FILE_FLAG_OVERLAPPED, "1073741824"
    
    .如果真 (hDevice ＝ -1)
        返回 (-1)
    .如果真结束
    
    ' 17 sizeof(STORAGE_PROPERTY_QUERY)
    ' 37 sizeof(STORAGE_DEVICE_DESCRIPTOR)
    
    .如果真 (DeviceIoControl_DESCRIPTOR (hDevice, 2954240, query, 17, pDevDesc, 37, readed, 0) ＝ 假)
        CloseHandle (hDevice)
        返回 (-1)
    .如果真结束
    
    CloseHandle (hDevice)
    返回 (pDevDesc.BusType)

.子程序 磁盘_取驱动器总线类型, 文本型, 公开
    .参数 盘符, 文本型
    .局部变量 ID, 整数型

    ID ＝ 取磁盘总线 (文本_取左边 (盘符, “:”, , ) ＋ “:”)
    .判断开始 (ID ＝ 0)
        返回 (“Unknown”)
    .判断 (ID ＝ 1)
        返回 (“SCSI”)
    .判断 (ID ＝ 2)
        返回 (“ATAPI”)
    .判断 (ID ＝ 3)
        返回 (“ATA”)
    .判断 (ID ＝ 4)
        返回 (“1394”)
    .判断 (ID ＝ 5)
        返回 (“SSA”)
    .判断 (ID ＝ 6)
        返回 (“FIBRE”)
    .判断 (ID ＝ 7)
        返回 (“USB”)
    .判断 (ID ＝ 8)
        返回 (“RAID”)
    .判断 (ID ＝ 9)
        返回 (“ISCSI”)
    .判断 (ID ＝ 10)
        返回 (“SAS”)
    .判断 (ID ＝ 11)
        返回 (“SATA”)
    .判断 (ID ＝ 12)
        返回 (“SD”)
    .判断 (ID ＝ 13)
        返回 (“MMC”)
    .判断 (ID ＝ 14)
        返回 (“Virtual”)
    .判断 (ID ＝ 15)
        返回 (“FileBackedVirtual”)
    .判断 (ID ＝ 16)
        返回 (“Spaces”)
    .判断 (ID ＝ 17)
        返回 (“Nvme”)
    .判断 (ID ＝ 18)
        返回 (“SCM”)
    .判断 (ID ＝ 127)
        返回 (“MaxReserved”)
    .默认
        返回 (“Unknown”)
    .判断结束
    

.子程序 系统_取远程会话身份名称, 文本型, 公开, 检索特定会话的名称
    .参数 会话ID, 整数型
    .局部变量 szName, 字节集
    .局部变量 hServer, 整数型

    szName ＝ 取空白字节集 (32) ' WINSTATIONNAME_LENGTH
    hServer ＝ WinStationOpenServerW (0)
    WinStationNameFromLogonIdW (hServer, 会话ID, szName)
    WinStationCloseServer (hServer)
    返回 (编码_Unicode到Ansi (szName))

.子程序 系统_取显卡信息列表, 整数型, 公开, 返回显卡数量，0为失败
    .参数 显卡信息列表, 精易_显卡信息, 参考 可空 数组, 用于接收显卡信息列表
    .局部变量 objWbemLocator, 对象
    .局部变量 objWMIService, 对象
    .局部变量 objController, 对象
    .局部变量 objNewEnum, 对象
    .局部变量 ptr, 整数型
    .局部变量 hr, 整数型
    .局部变量 Variant, 变体型
    .局部变量 pcFetched, 整数型
    .局部变量 objClass, 对象
    .局部变量 objProperties, 对象
    .局部变量 NvidiaInfo, 精易_显卡信息

    清除数组 (显卡信息列表)
    .如果真 (objWbemLocator.创建 (“WbemScripting.SWbemLocator”, ) ＝ 假)
        返回 (0)
    .如果真结束
    objWMIService ＝ objWbemLocator.对象型方法 (“ConnectServer”, “.”, “root\CIMV2”)
    .如果真 (objWMIService.是否为空 ())
        返回 (0)
    .如果真结束
    objController ＝ objWMIService.对象型方法 (“ExecQuery”, “SELECT * FROM Win32_VideoController”)
    .如果真 (objController.是否为空 ())
        返回 (0)
    .如果真结束
    objNewEnum ＝ objController.对象型方法 (“_NewEnum”, )
    .如果真 (objNewEnum.是否为空 ())
        返回 (0)
    .如果真结束
    ptr ＝ 取对象指针 (objNewEnum)
    .循环判断首 ()
        hr ＝ CallObject (ptr, 3, 1, 取变体型指针 (Variant), 取指针整数_ (pcFetched), , , , , , )
        .如果真 (hr ≠ 0)
            到循环尾 ()
        .如果真结束
        objClass ＝ Variant.取对象 ()
        objProperties ＝ objClass.读对象型属性 (“Properties_”, )
        NvidiaInfo.驱动程序版本号 ＝ objProperties.对象型方法 (“Item”, “DriverVersion”).读文本属性 (“value”, )
        NvidiaInfo.显卡名称 ＝ objProperties.对象型方法 (“Item”, “Name”).读文本属性 (“value”, )
        NvidiaInfo.内存大小 ＝ 整数_有符号转无符号 (objProperties.对象型方法 (“Item”, “AdapterRAM”).读数值属性 (“value”, ))
        NvidiaInfo.描述 ＝ objProperties.对象型方法 (“Item”, “Caption”).读文本属性 (“value”, )
        NvidiaInfo.详细描述 ＝ objProperties.对象型方法 (“Item”, “Description”).读文本属性 (“value”, )
        加入成员 (显卡信息列表, NvidiaInfo)
    .循环判断尾 (pcFetched ＝ 1)
    返回 (取数组成员数 (显卡信息列表))

.子程序 系统_遍历取回收站中的文件, 整数型, 公开, 返回回收站中的文件数量
    .参数 回收站中的文件信息, 精易_回收站中的文件信息, 可空 数组, 接收
    .局部变量 IsEmpty, 逻辑型
    .局部变量 hr, 整数型
    .局部变量 pisfRecBin, 整数型
    .局部变量 pMalloc, 整数型
    .局部变量 pidlBin, 整数型
    .局部变量 pisf, 整数型
    .局部变量 peidl, 整数型
    .局部变量 idlCurrent, 整数型
    .局部变量 szPath, 文本型
    .局部变量 pStr, 整数型
    .局部变量 pOleStr, 整数型
    .局部变量 dwSize, 整数型
    .局部变量 szBuf, 字节集
    .局部变量 SCID_DateDeleted, 字节集
    .局部变量 vt, 变体型
    .局部变量 SystemTime, 精易_时间
    .局部变量 LocalTime, FILETIME
    .局部变量 vTime, 日期时间型
    .局部变量 FileInfo, 精易_回收站中的文件信息
    .局部变量 i, 整数型

    IsEmpty ＝ 是否为空 (回收站中的文件信息)
    .如果真 (IsEmpty ＝ 假)
        清除数组 (回收站中的文件信息)
    .如果真结束
    hr ＝ SHGetDesktopFolder (pisfRecBin)
    hr ＝ SHGetMalloc (pMalloc)
    hr ＝ SHGetFolderLocation (#NULL, #CSIDL_BITBUCKET, #NULL, 0, pidlBin)
    hr ＝ CallObject (pisfRecBin, #IShellFolder_BindToObject, pidlBin, #NULL, 取指针_字节集型 (#IID_IShellFolder2), 取指针整数_ (pisf), , , , , )
    SafeRelease (pisfRecBin)
    CoTaskMemFree (pidlBin)
    hr ＝ CallObject (pisf, #IShellFolder_EnumObjects, #NULL, 位或 (#SHCONTF_FOLDERS, #SHCONTF_NONFOLDERS, #SHCONTF_INCLUDEHIDDEN), 取指针整数_ (peidl), , , , , , )
    szPath ＝ 取空白文本 (#MAX_PATH)
    .判断循环首 (hr ＝ #S_OK)
        hr ＝ CallObject (peidl, #IEnumIDList_Next, 1, 取指针整数_ (idlCurrent), #NULL, , , , , , )
        .如果真 (hr ＝ #S_FALSE)
            跳出循环 ()
        .如果真结束
        SHGetPathFromIDListA (idlCurrent, szPath)
        pStr ＝ LocalAlloc (#LMEM_ZEROINIT, 264)
        hr ＝ CallObject (pisf, #IShellFolder_GetDisplayNameOf, idlCurrent, #SHGDN_NORMAL, pStr, , , , , , )
        pOleStr ＝ 指针_到整数 (pStr ＋ 4)
        dwSize ＝ lstrlenW (pOleStr)
        szBuf ＝ 指针到字节集 (pOleStr, dwSize × 2 ＋ 2)
        LocalFree (pStr)
        SCID_DateDeleted ＝ { 51, 75, 23, 155, 255, 64, 210, 17, 162, 126, 0, 192, 79, 195, 8, 113 } ＋ 到字节集 (#PID_DISPLACED_DATE)
        hr ＝ CallObject (pisf, #IShellFolder2_GetDetailsEx, idlCurrent, 取指针_字节集型 (SCID_DateDeleted), 取变体型指针 (vt), , , , , , )
        VariantTimeToSystemTime (vt.取日期 (), SystemTime)
        SystemTimeToFileTime (SystemTime, LocalTime)
        vTime ＝ FileTimeToVariantTime (LocalTime)
        CoTaskMemFree (idlCurrent)
        .如果真 (IsEmpty ＝ 假)
            FileInfo.当前的路径 ＝ szPath
            FileInfo.原路径 ＝ 编码_Unicode到Ansi (szBuf)
            FileInfo.删除时间 ＝ vTime
            加入成员 (回收站中的文件信息, FileInfo)
        .如果真结束
        i ＝ i ＋ 1
    .判断循环尾 ()
    SafeRelease (peidl)
    SafeRelease (pisf)
    SafeRelease (pMalloc)
    返回 (i)

.子程序 系统_读环境变量, 文本型, 公开, 返回环境变量的展开值
    .参数 环境变量名称, 文本型, , 仅扩展在流程环境空间中定义的环境变量。必须用“%”字符括起来的环境变量名，不区分大小写。
    .局部变量 szPath, 字节集

    szPath ＝ 系统_读环境变量W (编码_Ansi到Unicode (环境变量名称))
    返回 (编码_Unicode到Ansi (szPath))

.子程序 系统_读环境变量W, 字节集, 公开, 返回环境变量的展开值
    .参数 环境变量名称, 字节集, , 仅扩展在流程环境空间中定义的环境变量。必须用“%”字符括起来的环境变量名，不区分大小写。
    .局部变量 dwSize, 整数型
    .局部变量 szPath, 字节集

    dwSize ＝ ExpandEnvironmentStringsW (环境变量名称, #NULL, 0)
    .如果真 (dwSize ＝ 0)
        返回 ({ })
    .如果真结束
    szPath ＝ 取空白字节集 (dwSize × 2)
    ExpandEnvironmentStringsW (环境变量名称, 取指针_字节集型 (szPath), dwSize)
    返回 (szPath)

.子程序 系统_取网络适配器配置, 整数型, 公开, 返回网络适配器配置数量
    .参数 网络适配器配置, 精易_网络适配器配置, 可空 数组
    .局部变量 IsEmpty, 逻辑型
    .局部变量 dwRet, 整数型
    .局部变量 dwBufLen, 整数型
    .局部变量 pAddresses, 整数型
    .局部变量 pCurrAddresses, 整数型
    .局部变量 ptr, 整数型
    .局部变量 dwSize, 整数型
    .局部变量 NetworkConfig, 精易_网络适配器配置
    .局部变量 i, 整数型

    .如果真 (_WIN32_WINNT ＜ #_WIN32_WINNT_VISTA)
        输出调试文本 (#ERROR_NOTVERSION)
        返回 (0)
    .如果真结束
    IsEmpty ＝ 是否为空 (网络适配器配置)
    .如果真 (IsEmpty ＝ 假)
        清除数组 (网络适配器配置)
    .如果真结束
    GetAdaptersAddresses (#AF_UNSPEC, 0, #NULL, #NULL, dwBufLen)
    pAddresses ＝ LocalAlloc (#LMEM_ZEROINIT, dwBufLen)
    dwRet ＝ GetAdaptersAddresses (#AF_UNSPEC, 位或 (#GAA_FLAG_SKIP_ANYCAST, #GAA_FLAG_INCLUDE_GATEWAYS), #NULL, pAddresses, dwBufLen)
    .如果真 (dwRet ＝ #ERROR_BUFFER_OVERFLOW)
        LocalFree (pAddresses)
        dwBufLen ＝ 15000 ' WORKING_BUFFER_SIZE
        pAddresses ＝ LocalAlloc (#LMEM_ZEROINIT, dwBufLen)
        dwRet ＝ GetAdaptersAddresses (#AF_UNSPEC, 位或 (#GAA_FLAG_SKIP_ANYCAST, #GAA_FLAG_INCLUDE_GATEWAYS), #NULL, pAddresses, dwBufLen)
    .如果真结束
    .如果真 (dwRet ≠ #ERROR_SUCCESS)
        LocalFree (pAddresses)
        输出调试文本 (取错误信息文本_API (dwRet, “Iphlpapi.dll”))
        返回 (0)
    .如果真结束
    pCurrAddresses ＝ pAddresses
    .判断循环首 (pCurrAddresses ≠ #NULL)
        NetworkConfig.状态 ＝ 指针_到整数 (pCurrAddresses ＋ 68) ' OperStatus
        ptr ＝ 指针_到整数 (pCurrAddresses ＋ 36) ' Description
        dwSize ＝ lstrlenW (ptr)
        .如果 (dwSize ＞ 0)
            NetworkConfig.描述 ＝ 编码_Unicode到Ansi (指针到字节集 (ptr, dwSize × 2 ＋ 2))
        .否则
            NetworkConfig.描述 ＝ “”
        .如果结束
        ptr ＝ 指针_到整数 (pCurrAddresses ＋ 40) ' FriendlyName
        dwSize ＝ lstrlenW (ptr)
        .如果 (dwSize ＞ 0)
            NetworkConfig.适配器名称 ＝ 编码_Unicode到Ansi (指针到字节集 (ptr, dwSize × 2 ＋ 2))
        .否则
            NetworkConfig.适配器名称 ＝ “”
        .如果结束
        NetworkConfig.物理地址 ＝ GetPhysicalAddress (pCurrAddresses) ' PhysicalAddress
        ptr ＝ 指针_到整数 (pCurrAddresses ＋ 56) ' Flags
        NetworkConfig.启用DHCP ＝ __query_bit (ptr, 2) ' Dhcpv4Enabled
        GetFirstUnicastAddress (pCurrAddresses, NetworkConfig)
        NetworkConfig.DHCP服务器 ＝ GetDhcpv4Server (pCurrAddresses)
        NetworkConfig.IPv6索引 ＝ 指针_到整数 (pCurrAddresses ＋ 72) ' Ipv6IfIndex
        GetFirstDnsServerAddress (pCurrAddresses, NetworkConfig)
        GetFirstGatewayAddress (pCurrAddresses, NetworkConfig)
        pCurrAddresses ＝ 指针_到整数 (pCurrAddresses ＋ 8) ' Next
        .如果真 (IsEmpty ＝ 假)
            加入成员 (网络适配器配置, NetworkConfig)
        .如果真结束
        i ＝ i ＋ 1
    .判断循环尾 ()
    LocalFree (pAddresses)
    返回 (i)

.子程序 GetPhysicalAddress, 文本型
    .参数 pCurrAddresses, 整数型
    .局部变量 dwSize, 整数型
    .局部变量 pBuf, 整数型
    .局部变量 cBuf, 字节型
    .局部变量 szBuf, 字节集
    .局部变量 i, 整数型
    .局部变量 n, 整数型

    pCurrAddresses ＝ pCurrAddresses ＋ 44
    dwSize ＝ 指针_到整数 (pCurrAddresses ＋ #MAX_ADAPTER_ADDRESS_LENGTH)
    .如果真 (dwSize ＞ 0)
        pBuf ＝ LocalAlloc (#LMEM_ZEROINIT, dwSize × 2 ＋ dwSize)
        .变量循环首 (0, dwSize － 1, 1, i)
            cBuf ＝ __get_byte (pCurrAddresses, i)
            n ＝ n ＋ sprintf (pBuf ＋ n, 选择 (i ＜ dwSize － 1, “%02X-”, “%02X”), cBuf)
        .变量循环尾 ()
        szBuf ＝ 指针到字节集 (pBuf, n)
        LocalFree (pBuf)
    .如果真结束
    返回 (取字节集数据 (szBuf, #文本型, ))

.子程序 GetFirstUnicastAddress
    .参数 pCurrAddresses, 整数型
    .参数 NetworkConfig, 精易_网络适配器配置
    .局部变量 pUnicast, 整数型
    .局部变量 addr, 整数型
    .局部变量 sa_family, 整数型
    .局部变量 szBuf, 文本型

    pUnicast ＝ 指针_到整数 (pCurrAddresses ＋ 16) ' FirstUnicastAddress
    .判断循环首 (pUnicast ≠ #NULL)
        addr ＝ 指针_到整数 (pUnicast ＋ 12)
        sa_family ＝ 指针_到整数 (addr)
        .判断开始 (sa_family ＝ #AF_INET)
            szBuf ＝ 取空白文本 (#INET_ADDRSTRLEN)
            inet_ntop (#AF_INET, addr ＋ 4, 取指针_文本型 (szBuf), #INET_ADDRSTRLEN)
            NetworkConfig.IPv4地址 ＝ szBuf
            NetworkConfig.IPv4子网掩码 ＝ GetIpv4Mask (pUnicast)
        .判断 (sa_family ＝ #AF_INET6)
            szBuf ＝ 取空白文本 (#INET6_ADDRSTRLEN)
            inet_ntop (#AF_INET6, addr ＋ 8, 取指针_文本型 (szBuf), #INET6_ADDRSTRLEN)
            NetworkConfig.本地IPv6地址 ＝ szBuf
        .默认
            
        .判断结束
        pUnicast ＝ 指针_到整数 (pUnicast ＋ 8)
    .判断循环尾 ()

.子程序 GetIpv4Mask, 文本型
    .参数 pUnicast, 整数型
    .局部变量 MaskLength, 整数型
    .局部变量 Mask, 整数型
    .局部变量 szBuf, 文本型

    MaskLength ＝ 指针_到整数 (pUnicast ＋ 44)
    ConvertLengthToIpv4Mask (MaskLength, Mask)
    szBuf ＝ 取空白文本 (#INET_ADDRSTRLEN)
    inet_ntop (#AF_INET, 取指针整数_ (Mask), 取指针_文本型 (szBuf), #INET_ADDRSTRLEN)
    返回 (szBuf)

.子程序 GetDhcpv4Server, 文本型
    .参数 pCurrAddresses, 整数型
    .局部变量 addr, 整数型
    .局部变量 sa_family, 整数型
    .局部变量 szBuf, 文本型

    addr ＝ 指针_到整数 (pCurrAddresses ＋ 184)
    .如果真 (addr ≠ #NULL)
        sa_family ＝ 指针_到整数 (addr)
        .如果真 (sa_family ＝ #AF_INET)
            szBuf ＝ 取空白文本 (#INET_ADDRSTRLEN)
            inet_ntop (#AF_INET, addr ＋ 4, 取指针_文本型 (szBuf), #INET_ADDRSTRLEN)
        .如果真结束
        
    .如果真结束
    返回 (szBuf)

.子程序 GetFirstDnsServerAddress
    .参数 pCurrAddresses, 整数型
    .参数 NetworkConfig, 精易_网络适配器配置
    .局部变量 pDnsServer, 整数型
    .局部变量 addr, 整数型
    .局部变量 sa_family, 整数型
    .局部变量 szBuf, 文本型
    .局部变量 ptr, 整数型

    pDnsServer ＝ 指针_到整数 (pCurrAddresses ＋ 28) ' FirstDnsServerAddress
    连续赋值 (“”, NetworkConfig.IPv4DNS服务器, NetworkConfig.IPv6DNS服务器)
    .判断循环首 (pDnsServer ≠ #NULL)
        addr ＝ 指针_到整数 (pDnsServer ＋ 12)
        sa_family ＝ 指针_到整数 (addr)
        .判断开始 (sa_family ＝ #AF_INET)
            szBuf ＝ 取空白文本 (#INET_ADDRSTRLEN)
            ptr ＝ inet_ntop (#AF_INET, addr ＋ 4, 取指针_文本型 (szBuf), #INET_ADDRSTRLEN)
            .如果真 (ptr ≠ #NULL)
                .如果真 (NetworkConfig.IPv4DNS服务器 ≠ “”)
                    NetworkConfig.IPv4DNS服务器 ＝ NetworkConfig.IPv4DNS服务器 ＋ #换行符
                .如果真结束
                NetworkConfig.IPv4DNS服务器 ＝ NetworkConfig.IPv4DNS服务器 ＋ szBuf
            .如果真结束
            
        .判断 (sa_family ＝ #AF_INET6)
            szBuf ＝ 取空白文本 (#INET6_ADDRSTRLEN)
            ptr ＝ inet_ntop (#AF_INET6, addr ＋ 8, 取指针_文本型 (szBuf), #INET6_ADDRSTRLEN)
            .如果真 (ptr ≠ #NULL)
                .如果真 (NetworkConfig.IPv6DNS服务器 ≠ “”)
                    NetworkConfig.IPv6DNS服务器 ＝ NetworkConfig.IPv6DNS服务器 ＋ #换行符
                .如果真结束
                NetworkConfig.IPv6DNS服务器 ＝ NetworkConfig.IPv6DNS服务器 ＋ szBuf
            .如果真结束
            
        .默认
            
        .判断结束
        pDnsServer ＝ 指针_到整数 (pDnsServer ＋ 8)
    .判断循环尾 ()

.子程序 GetFirstGatewayAddress
    .参数 pCurrAddresses, 整数型
    .参数 NetworkConfig, 精易_网络适配器配置
    .局部变量 pGateway, 整数型
    .局部变量 addr, 整数型
    .局部变量 sa_family, 整数型
    .局部变量 szBuf, 文本型
    .局部变量 ptr, 整数型

    pGateway ＝ 指针_到整数 (pCurrAddresses ＋ 164) ' FirstGatewayAddress
    连续赋值 (“”, NetworkConfig.IPv4默认网关, NetworkConfig.IPv6默认网关)
    .判断循环首 (pGateway ≠ #NULL)
        addr ＝ 指针_到整数 (pGateway ＋ 12)
        sa_family ＝ 指针_到整数 (addr)
        .判断开始 (sa_family ＝ #AF_INET)
            szBuf ＝ 取空白文本 (#INET_ADDRSTRLEN)
            ptr ＝ inet_ntop (#AF_INET, addr ＋ 4, 取指针_文本型 (szBuf), #INET_ADDRSTRLEN)
            .如果真 (ptr ≠ #NULL)
                .如果真 (NetworkConfig.IPv4默认网关 ≠ “”)
                    NetworkConfig.IPv4默认网关 ＝ NetworkConfig.IPv4默认网关 ＋ #换行符
                .如果真结束
                NetworkConfig.IPv4默认网关 ＝ NetworkConfig.IPv4默认网关 ＋ szBuf
            .如果真结束
            
        .判断 (sa_family ＝ #AF_INET6)
            szBuf ＝ 取空白文本 (#INET6_ADDRSTRLEN)
            ptr ＝ inet_ntop (#AF_INET6, addr ＋ 8, 取指针_文本型 (szBuf), #INET6_ADDRSTRLEN)
            .如果真 (ptr ≠ #NULL)
                .如果真 (NetworkConfig.IPv6默认网关 ≠ “”)
                    NetworkConfig.IPv6默认网关 ＝ NetworkConfig.IPv6默认网关 ＋ #换行符
                .如果真结束
                NetworkConfig.IPv6默认网关 ＝ NetworkConfig.IPv6默认网关 ＋ szBuf
            .如果真结束
            
        .默认
            
        .判断结束
        pGateway ＝ 指针_到整数 (pGateway ＋ 8)
    .判断循环尾 ()

.子程序 系统_通过逻辑盘符获取物理设备号, 整数型, 公开, 成功返回设备的编号，失败返回 -1
    .参数 盘符, 文本型, , C
    .局部变量 hDevice, 整数型
    .局部变量 dwBufLen, 整数型
    .局部变量 szBuf, 字节集
    .局部变量 bRet, 逻辑型

    hDevice ＝ CreateFileA (“\\.\” ＋ 盘符 ＋ “:”, 位或 (#GENERIC_READ, #GENERIC_WRITE), 位或 (#FILE_SHARE_READ, #FILE_SHARE_WRITE), #NULL, #OPEN_EXISTING, 0, #NULL)
    .如果真 (hDevice ＝ #INVALID_HANDLE_VALUE)
        输出调试文本 (取错误信息文本_API (hDevice, “Kernel32.dll”))
        返回 (#INVALID_HANDLE_VALUE)
    .如果真结束
    dwBufLen ＝ 12 ' sizeof(STORAGE_DEVICE_NUMBER)
    szBuf ＝ 取空白字节集 (dwBufLen)
    bRet ＝ DeviceIoControl1 (hDevice, #IOCTL_STORAGE_GET_DEVICE_NUMBER, #NULL, 0, 取指针_字节集型 (szBuf), dwBufLen, #NULL, #NULL)
    .如果真 (bRet ＝ 假)
        CloseHandle (hDevice)
        返回 (#INVALID_HANDLE_VALUE)
    .如果真结束
    CloseHandle (hDevice)
    返回 (取字节集数据 (szBuf, #整数型, 5)) ' DeviceNumber

.子程序 系统_取磁盘驱动器卷标名称, 文本型, 公开, 通过盘符取磁盘驱动器卷标名称
    .参数 盘符, 文本型, , C:\
    .局部变量 szPath, 字节集

    szPath ＝ 系统_取磁盘驱动器卷标名称W (编码_Ansi到Unicode (盘符, ))
    返回 (编码_Unicode到Ansi (szPath))

.子程序 系统_取磁盘驱动器卷标名称W, 字节集, 公开, 通过盘符取磁盘驱动器卷标名称
    .参数 盘符, 字节集, , C:\
    .局部变量 hr, 整数型
    .局部变量 dwSize, 整数型
    .局部变量 psfi, 整数型
    .局部变量 szDisplayName, 字节集

    dwSize ＝ 692
    psfi ＝ LocalAlloc (#LMEM_ZEROINIT, dwSize)
    CoInitialize (#NULL)
    hr ＝ SHGetFileInfoW (取指针_字节集型 (盘符), 0, psfi, dwSize, #SHGFI_DISPLAYNAME)
    CoUninitialize ()
    .如果真 (hr ≠ 0)
        ' psfi ＋ 12 => szDisplayName[MAX_PATH]
        szDisplayName ＝ 指针_到字节集W (psfi ＋ 12)
    .如果真结束
    LocalFree (psfi)
    返回 (szDisplayName)

.子程序 字体_枚举W, , 公开, 枚举系统中的所有字体名称
    .参数 字体名称, 字节集, 参考 数组, 接收
    .局部变量 hdc, 整数型
    .局部变量 lpLogfont, 整数型

    hdc ＝ GetDC (#NULL)
    lpLogfont ＝ LocalAlloc (#LMEM_ZEROINIT, 92)
    __set_byte (lpLogfont, 24, #DEFAULT_CHARSET) ' LOGFONTW->lfCharSet
    清除数组 (字体名称)
    EnumFontFamiliesExW (hdc, lpLogfont, 到整数 (&EnumFontFamProc), 取指针_通用型_数组 (字体名称), 0)
    LocalFree (lpLogfont)
    ReleaseDC (#NULL, hdc)

.子程序 EnumFontFamProc, 整数型
    .参数 lpelfe, 整数型
    .参数 lpntme, 整数型
    .参数 FontType, 整数型
    .参数 lParam, 整数型
    .局部变量 aryFaceName, 字节集, , "0"
    .局部变量 dwLen, 整数型
    .局部变量 pAddr, 整数型

    pAddr ＝ 指针转移 (lParam, 取指针_通用型_数组 (aryFaceName))
    dwLen ＝ 取数组成员数 (aryFaceName) ＋ 1
    重定义数组 (aryFaceName, 真, dwLen)
    ' 编码_Unicode到Ansi
    aryFaceName [dwLen] ＝ 指针_到字节集W (lpelfe ＋ 28) ' LOGFONTW->lfFaceName
    指针还原 (lParam, 取指针_通用型_数组 (aryFaceName), pAddr)
    返回 (1) ' 返回值必须是非零值才能继续枚举；要停止枚举，它必须返回零。

.子程序 系统_取外网IP, 文本型, 公开, 取本机的外网IP
    .局部变量 WSAData, 套接字信息
    .局部变量 host_addr, 整数型
    .局部变量 sock, 整数型
    .局部变量 dwSize, 整数型
    .局部变量 sin, 整数型
    .局部变量 addr_list, 整数型
    .局部变量 szAgree, 文本型
    .局部变量 dwBufLen, 整数型
    .局部变量 recvbuf, 整数型
    .局部变量 szBuf, 文本型

    .如果真 (WSAStartup (合并短整数 (1, 1), WSAData) ＝ #ERROR_SUCCESS)
        host_addr ＝ gethostbyname (“ns1.dnspod.net”)
        .如果真 (host_addr ≠ #NULL)
            sock ＝ socket (#AF_INET, #SOCK_STREAM, #IPPROTO_TCP)
            dwSize ＝ 16 ' sizeof(sockaddr_in)
            sin ＝ LocalAlloc (#LMEM_ZEROINIT, dwSize)
            __set_short (sin, 0, #AF_INET) ' sin_family
            __set_short (sin, 2, htons (6666)) ' sin_port
            addr_list ＝ 指针_到整数 (指针_到整数 (host_addr ＋ 12)) ' sin_addr->h_addr_list
            __set (sin, 4, 指针_到整数 (addr_list)) ' sin_addr.s_add
            .如果真 (connect (sock, sin, dwSize) ＝ 0)
                szAgree ＝ “GET / HTTP/1.1” ＋ #换行符 ＋ “Accept-Language: zh-CN,zh;q=0.9” ＋ #换行符 ＋ “Host:ns1.dnspod.net” ＋ #换行符 ＋ #换行符
                send (sock, 取指针文本_ (szAgree), 取文本长度 (szAgree), 0)
                dwBufLen ＝ 512
                recvbuf ＝ LocalAlloc (#LMEM_ZEROINIT, dwBufLen)
                dwSize ＝ recv (sock, recvbuf, dwBufLen, 0)
                .如果真 (dwSize ＞ 0)
                    szBuf ＝ 指针到文本 (recvbuf)
                    szBuf ＝ 文本_取右边 (szBuf, #换行符, , )
                .如果真结束
                LocalFree (recvbuf)
            .如果真结束
            LocalFree (sin)
            closesocket (sock)
        .如果真结束
        WSACleanup ()
    .如果真结束
    返回 (szBuf)

.子程序 系统_取系统启动时间, 日期时间型, 公开, 返回系统启动时间
    .局部变量 pSTI, 整数型
    .局部变量 dwSize, 整数型
    .局部变量 LocalTime, FILETIME
    .局部变量 vTime, 日期时间型

    dwSize ＝ 48
    pSTI ＝ LocalAlloc (#LMEM_ZEROINIT, dwSize)
    .如果真 (pSTI ≠ #NULL)
        .如果真 (NtQuerySystemInformation (#SystemTimeOfDayInformation, pSTI, dwSize, #NULL) ＝ #STATUS_SUCCESS)
            LocalTime.dwLowDateTime ＝ __get (pSTI, 0)
            LocalTime.dwHighDateTime ＝ __get (pSTI, 4)
            vTime ＝ FileTimeToVariantTime (LocalTime)
        .如果真结束
        LocalFree (pSTI)
    .如果真结束
    返回 (vTime)

.子程序 系统_取启动时间, 长整数型, 公开, 获取系统从启动到现在所经过的毫秒数
    .局部变量 pSTI, 整数型
    .局部变量 dwSize, 整数型
    .局部变量 BootTime, 长整数型
    .局部变量 CurrentTime, 长整数型

    dwSize ＝ 48
    pSTI ＝ LocalAlloc (#LMEM_ZEROINIT, dwSize)
    .如果真 (pSTI ≠ #NULL)
        .如果真 (NtQuerySystemInformation (#SystemTimeOfDayInformation, pSTI, dwSize, #NULL) ＝ #STATUS_SUCCESS)
            BootTime ＝ 指针_到长整数型_汇编 (pSTI)
            CurrentTime ＝ 指针_到长整数型_汇编 (pSTI ＋ 8)
        .如果真结束
        LocalFree (pSTI)
    .如果真结束
    返回 (Asm_idiv64 (CurrentTime － BootTime, 10000))

.子程序 GetpIWbemServices, 整数型, , IWbemServices*
    .参数 NetworkResource, 字节集, , WMI命名空间
    .局部变量 pIWbemLocator, 整数型
    .局部变量 pIWbemServices, 整数型
    .局部变量 hr, 整数型

    hr ＝ CoCreateInstance1 (取指针_字节集型 (#CLSID_WbemLocator), #NULL, #CLSCTX_INPROC_SERVER, 取指针_字节集型 (#IID_IWbemLocator), pIWbemLocator)
    .如果真 (hr ＝ #S_OK 且 pIWbemLocator ≠ #NULL)
        hr ＝ CallObject (pIWbemLocator, #IWbemLocator_ConnectServer, 取指针_字节集型 (NetworkResource), #NULL, #NULL, 0, 0, 0, 0, 取指针整数_ (pIWbemServices), )
        .如果真 (hr ＝ #S_OK 且 pIWbemServices ≠ #NULL)
            hr ＝ CoSetProxyBlanket (pIWbemServices, #RPC_C_AUTHN_WINNT, #RPC_C_AUTHZ_NONE, #NULL, #RPC_C_AUTHN_LEVEL_CALL, #RPC_C_IMP_LEVEL_IMPERSONATE, #NULL, #EOAC_NONE)
        .如果真结束
        SafeRelease (pIWbemLocator)
    .如果真结束
    返回 (pIWbemServices)

.子程序 GetpIEnumWbemClassObject, 整数型, , IEnumWbemClassObject*
    .参数 NetworkResource, 字节集, , WMI命名空间
    .参数 Query, 字节集, , WMI类别/查询
    .局部变量 pIWbemServices, 整数型
    .局部变量 szQueryLanguage, 字节集
    .局部变量 pIEnumWbemClassObject, 整数型
    .局部变量 hr, 整数型

    pIWbemServices ＝ GetpIWbemServices (NetworkResource)
    .如果真 (pIWbemServices ≠ #NULL)
        szQueryLanguage ＝ 编码_Ansi到Unicode (“WQL”, )
        hr ＝ CallObject (pIWbemServices, #IWbemServices_ExecNotificationQuery, 取指针_字节集型 (szQueryLanguage), 取指针_字节集型 (Query), 位或 (#WBEM_FLAG_FORWARD_ONLY, #WBEM_FLAG_RETURN_IMMEDIATELY), #NULL, 取指针整数_ (pIEnumWbemClassObject), , , , )
        SafeRelease (pIWbemServices)
    .如果真结束
    返回 (pIEnumWbemClassObject)

.子程序 系统_WMI监视进程W, 整数型, 公开, 成功返回线程句柄
    .参数 欲监视的事件, 整数型, 可空, 0、监视进程开启；1、监视进程关闭；
    .参数 进程通知事件, 子程序指针, , int ProcessNotifyEvent(整数型 欲监视的事件, 整数型 进程名, 整数型 进程ID, 整数型 命令行, 整数型 可执行路径);
    .局部变量 pInstance, 整数型
    .局部变量 hThread, 整数型

    pInstance ＝ LocalAlloc (#LMEM_ZEROINIT, 8)
    .如果真 (pInstance ≠ #NULL)
        .如果 (欲监视的事件 ＝ 1)
            __set (pInstance, 0, 1)
        .否则
            __set (pInstance, 0, 0)
        .如果结束
        __set (pInstance, 4, 到整数 (进程通知事件))
        hThread ＝ CreateThread (#NULL, 0, 到整数 (&ProcessNotifyEvent), pInstance, 0, #NULL)
    .如果真结束
    返回 (hThread)

.子程序 ProcessNotifyEvent
    .参数 lpParameter, 整数型
    .局部变量 iInstance, 整数型
    .局部变量 NotifyProc, 整数型
    .局部变量 pIEnumWbemClassObject, 整数型
    .局部变量 hr, 整数型
    .局部变量 pIWbemClassObject, 整数型
    .局部变量 uReturned, 整数型
    .局部变量 dwSize, 整数型
    .局部变量 vtInstanceObject, 整数型
    .局部变量 wszName, 字节集
    .局部变量 pTargetInstance, 整数型
    .局部变量 pszName, 整数型
    .局部变量 dwProcessID, 整数型
    .局部变量 pszCommandLine, 整数型
    .局部变量 pszExecutablePath, 整数型
    .局部变量 iRet, 整数型

    iInstance ＝ __get (lpParameter, 0)
    NotifyProc ＝ __get (lpParameter, 4)
    LocalFree (lpParameter)
    
    CoInitialize (#NULL)
    hr ＝ CoInitializeSecurity (#NULL, -1, #NULL, #NULL, #RPC_C_AUTHN_LEVEL_PKT, #RPC_C_IMP_LEVEL_IMPERSONATE, #NULL, #EOAC_NONE, #NULL)
    pIEnumWbemClassObject ＝ GetpIEnumWbemClassObject (编码_Ansi到Unicode (“ROOT\CIMV2”, ), 编码_Ansi到Unicode (“SELECT * FROM ” ＋ 多项选择 (iInstance ＋ 1, “__InstanceCreationEvent”, “__InstanceDeletionEvent”) ＋ “ WITHIN 1 WHERE TargetInstance ISA 'Win32_Process'”, ))
    .如果真 (pIEnumWbemClassObject ≠ #NULL)
        .判断循环首 (iRet ＝ 0)
            hr ＝ CallObject (pIEnumWbemClassObject, #IEnumWbemClassObject_Next, #WBEM_INFINITE, 1, 取指针整数_ (pIWbemClassObject), 取指针整数_ (uReturned), , , , , )
            .如果真 (hr ＝ #S_OK 且 pIWbemClassObject ≠ #NULL)
                dwSize ＝ 16 ' sizeof(VARIANT)
                vtInstanceObject ＝ LocalAlloc (#LMEM_ZEROINIT, dwSize)
                wszName ＝ 编码_Ansi到Unicode (“TargetInstance”, )
                hr ＝ CallObject (pIWbemClassObject, #IWbemClassObject_Get, 取指针_字节集型 (wszName), 0, vtInstanceObject, #NULL, #NULL, , , , )
                SafeRelease (pIWbemClassObject)
                .如果真 (hr ＝ #S_OK)
                    pTargetInstance ＝ __get (vtInstanceObject, 8) ' punkVal => IWbemClassObject*
                    .如果真 (pTargetInstance ≠ #NULL)
                        ' 属性 => Caption, CommandLine, CreationClassName, CreationDate, CSCreationClassName, CSName, Description, ExecutablePath, Handle, HandleCount, KernelModeTime, MaximumWorkingSetSize, MinimumWorkingSetSize, Name, OSCreationClassName, OSName, OtherOperationCount, OtherTransferCount, PageFaults, PageFileUsage, ParentProcessId, PeakPageFileUsage, PeakVirtualSize, PeakWorkingSetSize, Priority, PrivatePageCount, ProcessId, QuotaNonPagedPoolUsage, QuotaPagedPoolUsage, QuotaPeakNonPagedPoolUsage, QuotaPeakPagedPoolUsage, ReadOperationCount, ReadTransferCount, SessionId, ThreadCount, UserModeTime, VirtualSize, WindowsVersion, WorkingSetSize, WriteOperationCount, WriteTransferCount
                        
                        memset (vtInstanceObject, 0, dwSize)
                        wszName ＝ 编码_Ansi到Unicode (“Name”, ) ' 进程名
                        hr ＝ CallObject (pTargetInstance, #IWbemClassObject_Get, 取指针_字节集型 (wszName), 0, vtInstanceObject, #NULL, #NULL, , , , )
                        pszName ＝ __get (vtInstanceObject, 8)
                        
                        memset (vtInstanceObject, 0, dwSize)
                        wszName ＝ 编码_Ansi到Unicode (“ProcessID”, ) ' 进程ID
                        hr ＝ CallObject (pTargetInstance, #IWbemClassObject_Get, 取指针_字节集型 (wszName), 0, vtInstanceObject, #NULL, #NULL, , , , )
                        dwProcessID ＝ __get (vtInstanceObject, 8)
                        
                        memset (vtInstanceObject, 0, dwSize)
                        wszName ＝ 编码_Ansi到Unicode (“CommandLine”, ) ' 命令行
                        hr ＝ CallObject (pTargetInstance, #IWbemClassObject_Get, 取指针_字节集型 (wszName), 0, vtInstanceObject, #NULL, #NULL, , , , )
                        pszCommandLine ＝ __get (vtInstanceObject, 8)
                        
                        memset (vtInstanceObject, 0, dwSize)
                        wszName ＝ 编码_Ansi到Unicode (“ExecutablePath”, ) ' 可执行路径
                        hr ＝ CallObject (pTargetInstance, #IWbemClassObject_Get, 取指针_字节集型 (wszName), 0, vtInstanceObject, #NULL, #NULL, , , , )
                        pszExecutablePath ＝ __get (vtInstanceObject, 8)
                        
                        .如果真 (NotifyProc ≠ #NULL)
                            iRet ＝ 程序_Call (NotifyProc, iInstance, pszName, dwProcessID, pszCommandLine, pszExecutablePath)
                        .如果真结束
                        
                        .如果真 (pszName ≠ #NULL)
                            SysFreeString (pszName)
                        .如果真结束
                        .如果真 (pszCommandLine ≠ #NULL)
                            SysFreeString (pszCommandLine)
                        .如果真结束
                        .如果真 (pszExecutablePath ≠ #NULL)
                            SysFreeString (pszExecutablePath)
                        .如果真结束
                        
                        SafeRelease (pTargetInstance)
                    .如果真结束
                    
                .如果真结束
                LocalFree (vtInstanceObject)
            .如果真结束
            
        .判断循环尾 ()
        SafeRelease (pIEnumWbemClassObject)
    .如果真结束
    CoUninitialize ()

.子程序 系统_创建符号链接, 逻辑型, 公开, 创建符号链接
    .参数 要创建的符号链接, 文本型
    .参数 要创建的符号链接的目标名称, 文本型

    返回 (系统_创建符号链接W (编码_Ansi到Unicode (要创建的符号链接, ), 编码_Ansi到Unicode (要创建的符号链接的目标名称, )))

.子程序 系统_创建符号链接W, 逻辑型, 公开, 创建符号链接
    .参数 要创建的符号链接, 字节集
    .参数 要创建的符号链接的目标名称, 字节集
    .局部变量 dwFileAttr, 整数型
    .局部变量 dwFlags, 整数型

    dwFileAttr ＝ GetFileAttributesW (要创建的符号链接的目标名称)
    .如果真 (dwFileAttr ＝ #INVALID_FILE_ATTRIBUTES)
        输出调试文本 (“检索指定文件或目录的文件系统属性失败！”)
        返回 (假)
    .如果真结束
    .如果真 (位与 (dwFileAttr, #FILE_ATTRIBUTE_DIRECTORY) ≠ 0)
        dwFlags ＝ #SYMBOLIC_LINK_FLAG_DIRECTORY
    .如果真结束
    返回 (CreateSymbolicLinkW (要创建的符号链接, 要创建的符号链接的目标名称, dwFlags) ≠ 0)

.子程序 系统_取符号链接所在位置, 文本型, 公开, 成功返回符号链接的所在位置
    .参数 符号链接路径, 文本型
    .局部变量 wzPath, 字节集

    wzPath ＝ 编码_Ansi到Unicode (符号链接路径, )
    wzPath ＝ 系统_取符号链接所在位置W (wzPath)
    返回 (编码_Unicode到Ansi (wzPath))

.子程序 系统_取符号链接所在位置W, 字节集, 公开, 成功返回符号链接的所在位置
    .参数 符号链接路径, 字节集
    .局部变量 hFile, 整数型
    .局部变量 pReparse, 整数型
    .局部变量 dwSize, 整数型
    .局部变量 dwBySize, 整数型
    .局部变量 wzPath, 字节集

    hFile ＝ CreateFileW (符号链接路径, 0, 0, #NULL, #OPEN_EXISTING, 位或 (#FILE_FLAG_BACKUP_SEMANTICS, #FILE_FLAG_OPEN_REPARSE_POINT), #NULL)
    .如果真 (hFile ≠ #INVALID_HANDLE_VALUE)
        dwSize ＝ 24 ＋ #MAX_PATH × 2 ' sizeof(REPARSE_DATA_BUFFER) + MAX_PATH * sizeof(wchar_t)
        pReparse ＝ LocalAlloc (#LMEM_ZEROINIT, dwSize)
        .如果真 (pReparse ≠ #NULL)
            .如果真 (DeviceIoControl1 (hFile, #FSCTL_GET_REPARSE_POINT, #NULL, 0, pReparse, dwSize, dwBySize, #NULL))
                dwSize ＝ 指针_到短整数型_汇编 (pReparse ＋ 8) ' pReparse->SymbolicLinkReparseBuffer.SubstituteNameOffset
                .如果真 (dwSize ＞ 0)
                    wzPath ＝ 指针到字节集 (pReparse ＋ 20, dwSize) ＋ { 0, 0 } ' pReparse->SymbolicLinkReparseBuffer.PathBuffer
                .如果真结束
                
            .如果真结束
            LocalFree (pReparse)
        .如果真结束
        CloseHandle (hFile)
    .如果真结束
    返回 (wzPath)

.子程序 系统_创建图标到资源管理器, 逻辑型, 公开, 在资源管理器中创建快捷方式
    .参数 唯一标识码, 文本型, , GUID
    .参数 标题, 文本型
    .参数 提示, 文本型, 可空
    .参数 命令行, 文本型
    .参数 图标路径, 文本型, 可空, icon
    .参数 是否为64位注册表, 逻辑型, 可空
    .局部变量 szAuthor, 字节集
    .局部变量 szPath, 字节集

    .如果真 (是否为空 (提示) ＝ 假)
        szAuthor ＝ 编码_Ansi到Unicode (提示, )
    .如果真结束
    .如果真 (是否为空 (图标路径) ＝ 假)
        szPath ＝ 编码_Ansi到Unicode (图标路径, )
    .如果真结束
    返回 (系统_创建图标到资源管理器W (编码_Ansi到Unicode (唯一标识码, ), 编码_Ansi到Unicode (标题, ), szAuthor, 编码_Ansi到Unicode (命令行, ), szPath, 是否为64位注册表))

.子程序 系统_创建图标到资源管理器W, 逻辑型, 公开, 在资源管理器中创建快捷方式
    .参数 唯一标识码, 字节集, , GUID
    .参数 标题, 字节集
    .参数 提示, 字节集, 可空
    .参数 命令行, 字节集
    .参数 图标路径, 字节集, 可空, icon
    .参数 是否为64位注册表, 逻辑型, 可空
    .局部变量 lRes, 字节集
    .局部变量 hKey, 整数型, , "3"
    .局部变量 dwFlags, 整数型
    .局部变量 szTemp, 字节集

    dwFlags ＝ 位或 (#KEY_WRITE, 选择 (是否为64位注册表, #KEY_WOW64_64KEY, #KEY_WOW64_32KEY))
    lRes ＝ { 0, 0, 0, 0, 0, 0 }
    lRes [1] ＝ RegOpenKeyExW (#HKEY_CLASSES_ROOT, 编码_Ansi到Unicode (“CLSID”, ), 0, dwFlags, hKey [1])
    .如果真 (lRes [1] ＝ #ERROR_SUCCESS 且 hKey [1] ≠ #NULL)
        lRes [2] ＝ RegCreateKeyExW (hKey [1], 唯一标识码, 0, #NULL, 0, dwFlags, #NULL, hKey [2], #NULL)
        .如果真 (lRes [2] ＝ #ERROR_SUCCESS 且 hKey [2] ≠ #NULL)
            RegSetValueExW (hKey [2], { 0, 0 }, 0, #REG_SZ, 取指针_字节集型 (标题), 取字节集长度 (标题))
            RegSetValueExW (hKey [2], 编码_Ansi到Unicode (“LocalizedString”, ), 0, #REG_SZ, 取指针_字节集型 (标题), 取字节集长度 (标题))
            
            .如果真 (提示 ≠ { })
                RegSetValueExW (hKey [2], 编码_Ansi到Unicode (“InfoTip”, ), 0, #REG_SZ, 取指针_字节集型 (提示), 取字节集长度 (提示))
                RegSetValueExW (hKey [2], 编码_Ansi到Unicode (“System.ItemAuthors”, ), 0, #REG_SZ, 取指针_字节集型 (提示), 取字节集长度 (提示))
                szTemp ＝ 编码_Ansi到Unicode (“prop:System.ItemAuthors”, )
                RegSetValueExW (hKey [2], 编码_Ansi到Unicode (“TileInfo”, ), 0, #REG_SZ, 取指针_字节集型 (szTemp), 取字节集长度 (szTemp))
            .如果真结束
            
            .如果真 (图标路径 ≠ { })
                lRes [3] ＝ RegCreateKeyExW (hKey [2], 编码_Ansi到Unicode (“DefaultIcon”, ), 0, #NULL, 0, dwFlags, #NULL, hKey [3], #NULL)
                .如果真 (lRes [3] ＝ #ERROR_SUCCESS 且 hKey [3] ≠ #NULL)
                    RegSetValueExW (hKey [3], { 0, 0 }, 0, #REG_SZ, 取指针_字节集型 (图标路径), 取字节集长度 (图标路径))
                    RegCloseKey (hKey [3])
                .如果真结束
                
            .如果真结束
            
            lRes [4] ＝ RegCreateKeyExW (hKey [2], 编码_Ansi到Unicode (“Shell\Open\Command”, ), 0, #NULL, 0, dwFlags, #NULL, hKey [3], #NULL)
            .如果真 (lRes [4] ＝ #ERROR_SUCCESS 且 hKey [3] ≠ #NULL)
                RegSetValueExW (hKey [3], { 0, 0 }, 0, #REG_SZ, 取指针_字节集型 (命令行), 取字节集长度 (命令行))
                RegCloseKey (hKey [3])
            .如果真结束
            
            RegCloseKey (hKey [2])
            
            lRes [5] ＝ RegCreateKeyExW (#HKEY_CURRENT_USER, 编码_Ansi到Unicode (“Software\Microsoft\Windows\CurrentVersion\Explorer\MyComputer\NameSpace”, ), 0, #NULL, 0, dwFlags, #NULL, hKey [2], #NULL)
            .如果真 (lRes [5] ＝ #ERROR_SUCCESS 且 hKey [2] ≠ #NULL)
                lRes [6] ＝ RegCreateKeyExW (hKey [2], 唯一标识码, 0, #NULL, 0, dwFlags, #NULL, hKey [3], #NULL)
                .如果真 (lRes [6] ＝ #ERROR_SUCCESS 且 hKey [3] ≠ #NULL)
                    RegCloseKey (hKey [3])
                .如果真结束
                RegCloseKey (hKey [2])
            .如果真结束
            
        .如果真结束
        
        RegCloseKey (hKey [1])
    .如果真结束
    返回 (lRes ＝ { 0, 0, 0, 0, 0, 0 })

.子程序 系统_删除资源管理器的图标, 逻辑型, 公开, 删除资源管理器中的快捷方式
    .参数 唯一标识码, 文本型, , GUID
    .参数 是否为64位注册表, 逻辑型, 可空

    返回 (系统_删除资源管理器的图标W (编码_Ansi到Unicode (唯一标识码, ), 是否为64位注册表))

.子程序 系统_删除资源管理器的图标W, 逻辑型, 公开, 删除资源管理器中的快捷方式
    .参数 唯一标识码, 字节集, , GUID
    .参数 是否为64位注册表, 逻辑型, 可空
    .局部变量 dwFlags, 整数型
    .局部变量 lRes, 字节集
    .局部变量 hKey, 整数型

    dwFlags ＝ 位或 (#KEY_QUERY_VALUE, 选择 (是否为64位注册表, #KEY_WOW64_64KEY, #KEY_WOW64_32KEY))
    lRes ＝ { 0, 0 }
    lRes [1] ＝ RegOpenKeyExW (#HKEY_CURRENT_USER, 编码_Ansi到Unicode (“Software\Microsoft\Windows\CurrentVersion\Explorer\MyComputer\NameSpace”, ), 0, dwFlags, hKey)
    .如果真 (lRes [1] ＝ #ERROR_SUCCESS 且 hKey ≠ #NULL)
        RegDeleteTreeW (hKey, 唯一标识码)
        RegCloseKey (hKey)
    .如果真结束
    
    lRes [2] ＝ RegOpenKeyExW (#HKEY_CLASSES_ROOT, 编码_Ansi到Unicode (“CLSID”, ), 0, dwFlags, hKey)
    .如果真 (lRes [2] ＝ #ERROR_SUCCESS 且 hKey ≠ #NULL)
        RegDeleteTreeW (hKey, 唯一标识码)
        RegCloseKey (hKey)
    .如果真结束
    
    返回 (lRes ＝ { 0, 0 })

.子程序 系统_遍历右键菜单并执行, 逻辑型, 公开, 遍历指定文件右键菜单并执行
    .参数 文件路径, 文本型
    .参数 欲执行的菜单, 文本型

    返回 (系统_遍历右键菜单并执行W (编码_Ansi到Unicode (文件路径, ), 编码_Ansi到Unicode (欲执行的菜单, )))

.子程序 系统_遍历右键菜单并执行W, 逻辑型, 公开, 遍历指定文件右键菜单并执行
    .参数 文件路径, 字节集
    .参数 欲执行的菜单, 字节集
    .局部变量 hr, 整数型
    .局部变量 pIShellDispatch, 整数型
    .局部变量 pvtDir, 整数型, , , VARIANT
    .局部变量 szPath, 字节集
    .局部变量 pFolder, 整数型
    .局部变量 pFolderItem, 整数型
    .局部变量 pFolderItemVerbs, 整数型
    .局部变量 nCount, 整数型
    .局部变量 pvtIndex, 整数型, , , VARIANT
    .局部变量 pFolderItemVerb, 整数型
    .局部变量 pv, 整数型
    .局部变量 szMenuTitle, 字节集
    .局部变量 lRes, 逻辑型
    .局部变量 i, 整数型

    CoInitialize (#NULL)
    hr ＝ CoCreateInstance1 (取指针_字节集型 (#CLSID_Shell), #NULL, #CLSCTX_INPROC_SERVER, 取指针_字节集型 (#IID_IShellDispatch), pIShellDispatch)
    .如果真 (hr ＝ #S_OK 且 pIShellDispatch ≠ #NULL)
        pvtDir ＝ LocalAlloc (#LMEM_ZEROINIT, 16) ' sizeof(VARIANT)
        __set_short (pvtDir, 0, 8) ' VT_BSTR
        szPath ＝ 文件_取目录W (文件路径)
        __set (pvtDir, 8, 取指针_字节集型 (szPath))
        hr ＝ CallObject (pIShellDispatch, #IShellDispatch_NameSpace, __get (pvtDir, 0), __get (pvtDir, 4), __get (pvtDir, 8), __get (pvtDir, 12), 取指针整数_ (pFolder), , , , )
        .如果真 (hr ＝ #S_OK 且 pFolder ≠ #NULL)
            szPath ＝ 字节集_寻找取右 (文件路径, { 92, 0 }, -1) ＋ { 0, 0 }
            hr ＝ CallObject (pFolder, #Folder_ParseName, 取指针_字节集型 (szPath), 取指针整数_ (pFolderItem), , , , , , , )
            .如果真 (hr ＝ #S_OK 且 pFolderItem ≠ #NULL)
                hr ＝ CallObject (pFolderItem, #FolderItem_Verbs, 取指针整数_ (pFolderItemVerbs), , , , , , , , )
                .如果真 (hr ＝ #S_OK 且 pFolderItemVerbs ≠ #NULL)
                    hr ＝ CallObject (pFolderItemVerbs, #FolderItemVerbs_get_Count, 取指针整数_ (nCount), , , , , , , , )
                    .如果真 (hr ＝ #S_OK 且 nCount ＞ 0)
                        pvtIndex ＝ LocalAlloc (#LMEM_ZEROINIT, 16) ' sizeof(VARIANT)
                        __set_short (pvtIndex, 0, 3) ' VT_I4
                        .变量循环首 (0, nCount － 1, 1, i)
                            __set (pvtIndex, 8, i)
                            hr ＝ CallObject (pFolderItemVerbs, #FolderItemVerbs_Item, __get (pvtIndex, 0), __get (pvtIndex, 4), __get (pvtIndex, 8), __get (pvtIndex, 12), 取指针整数_ (pFolderItemVerb), , , , )
                            .如果真 (hr ＝ #S_OK 且 pFolderItemVerb ≠ #NULL)
                                hr ＝ CallObject (pFolderItemVerb, #FolderItemVerb_get_Name, 取指针整数_ (pv), , , , , , , , )
                                .如果真 (hr ＝ #S_OK)
                                    szMenuTitle ＝ 指针_到字节集W (pv)
                                    .如果真 (szMenuTitle ＝ 欲执行的菜单)
                                        hr ＝ CallObject (pFolderItemVerb, #FolderItemVerb_DoIt, , , , , , , , , )
                                        lRes ＝ hr ＝ #S_OK
                                        SafeRelease (pFolderItemVerb)
                                        跳出循环 ()
                                    .如果真结束
                                    
                                .如果真结束
                                SafeRelease (pFolderItemVerb)
                            .如果真结束
                            
                        .变量循环尾 ()
                        LocalFree (pvtIndex)
                    .如果真结束
                    SafeRelease (pFolderItemVerbs)
                .如果真结束
                SafeRelease (pFolderItem)
            .如果真结束
            SafeRelease (pFolder)
        .如果真结束
        LocalFree (pvtDir)
        SafeRelease (pIShellDispatch)
    .如果真结束
    CoUninitialize ()
    返回 (lRes)

.子程序 系统_是否为Server版本, 逻辑型, 公开, 判断当前的操作系统是否为Server版本
    .局部变量 osvi, 整数型
    .局部变量 dwlConditionMask, 长整数型
    .局部变量 isRes, 逻辑型

    osvi ＝ LocalAlloc (#LMEM_ZEROINIT, 284) ' sizeof(OSVERSIONINFOEXW)
    __set (osvi, 0, 284) ' OSVERSIONINFOEXW => dwOSVersionInfoSize
    __set_byte (osvi, 282, #VER_NT_WORKSTATION) ' OSVERSIONINFOEXW => wProductType
    dwlConditionMask ＝ VerSetConditionMask (0, #VER_PRODUCT_TYPE, #VER_EQUAL)
    isRes ＝ 取反 (VerifyVersionInfoW (osvi, #VER_PRODUCT_TYPE, dwlConditionMask))
    LocalFree (osvi)
    返回 (isRes)

.子程序 系统_遍历修复补丁ID, 整数型, 公开, 返回修复补丁ID的数组成员数
    .参数 修复补丁ID, 文本型, 参考 数组
    .参数 查询补丁ID, 文本型, 可空
    .局部变量 pIWbemServices, 整数型
    .局部变量 wzQueryLanguage, 字节集
    .局部变量 wzQuery, 字节集
    .局部变量 pIEnumWbemClassObject, 整数型
    .局部变量 pIWbemClassObject, 整数型
    .局部变量 uReturn, 整数型
    .局部变量 wzName, 字节集
    .局部变量 pVal, 整数型
    .局部变量 pbstrVal, 整数型
    .局部变量 hr, 整数型

    清除数组 (修复补丁ID)
    pIWbemServices ＝ GetpIWbemServices (编码_Ansi到Unicode (“root\CIMV2”, ))
    .如果真 (pIWbemServices ≠ #NULL)
        wzQueryLanguage ＝ 编码_Ansi到Unicode (“WQL”, )
        .如果 (是否为空 (查询补丁ID))
            wzQuery ＝ 编码_Ansi到Unicode (“SELECT HotFixID FROM Win32_QuickFixEngineering”, )
        .否则
            wzQuery ＝ 编码_Ansi到Unicode (“SELECT HotFixID FROM Win32_QuickFixEngineering WHERE HotFixID = '” ＋ 查询补丁ID ＋ “'”, )
        .如果结束
        hr ＝ CallObject (pIWbemServices, #IWbemServices_ExecQuery, 取指针字节集_ (wzQueryLanguage), 取指针字节集_ (wzQuery), 位或 (#WBEM_FLAG_FORWARD_ONLY, #WBEM_FLAG_RETURN_IMMEDIATELY), #NULL, 取指针整数_ (pIEnumWbemClassObject), , , , )
        .如果真 (hr ＝ #S_OK 且 pIEnumWbemClassObject ≠ #NULL)
            wzName ＝ 编码_Ansi到Unicode (“HotFixID”, )
            pVal ＝ LocalAlloc (#LMEM_ZEROINIT, 16) ' sizeof(VARIANT)
            .如果真 (pVal ≠ #NULL)
                .循环判断首 ()
                    hr ＝ CallObject (pIEnumWbemClassObject, #IEnumWbemClassObject_Next, #WBEM_INFINITE, 1, 取指针整数_ (pIWbemClassObject), 取指针整数_ (uReturn), , , , , )
                    .如果真 (hr ＝ #S_OK 且 pIWbemClassObject ≠ #NULL)
                        memset (pVal, 0, 16) ' sizeof(VARIANT)
                        hr ＝ CallObject (pIWbemClassObject, #IWbemClassObject_Get, 取指针字节集_ (wzName), 0, pVal, #NULL, #NULL, , , , )
                        .如果真 (hr ＝ #S_OK)
                            pbstrVal ＝ __get (pVal, 8)
                            .如果真 (pbstrVal ≠ #NULL)
                                加入成员 (修复补丁ID, 编码_Unicode到Ansi (指针_到字节集W (pbstrVal)))
                                SysFreeString (pbstrVal)
                            .如果真结束
                            
                        .如果真结束
                        SafeRelease (pIWbemClassObject)
                    .如果真结束
                    
                .循环判断尾 (uReturn ≠ 0)
                LocalFree (pVal)
            .如果真结束
            SafeRelease (pIEnumWbemClassObject)
        .如果真结束
        SafeRelease (pIWbemServices)
    .如果真结束
    返回 (取数组成员数 (修复补丁ID))

.子程序 系统_用户名密码验证, 逻辑型, 公开, 验证输入的用户名和密码是否正确
    .参数 用户名, 文本型
    .参数 密码, 文本型
    .参数 窗口句柄, 整数型, 可空
    .参数 标题, 文本型, 可空, 登陆
    .参数 提示内容, 文本型, 可空, 请输入用户名与密码
    .参数 是否区分大小写, 逻辑型, 可空, 默认不区分

    返回 (系统_用户名密码验证W (编码_Ansi到Unicode (用户名, ), 编码_Ansi到Unicode (密码, ), 窗口句柄, 编码_Ansi到Unicode (标题, ), 编码_Ansi到Unicode (提示内容, ), 是否区分大小写))

.子程序 系统_用户名密码验证W, 逻辑型, 公开, 验证输入的用户名和密码是否正确
    .参数 用户名, 字节集
    .参数 密码, 字节集
    .参数 窗口句柄, 整数型, 可空
    .参数 标题, 字节集, 可空, 登陆
    .参数 提示内容, 字节集, 可空, 请输入用户名与密码
    .参数 是否区分大小写, 逻辑型, 可空, 默认不区分
    .局部变量 UiInfo, CREDUI_INFOW
    .局部变量 lRes, 整数型
    .局部变量 dwAuthError, 整数型
    .局部变量 ulAuthPackage, 整数型
    .局部变量 pAuthBuffer, 整数型
    .局部变量 cbAuthBuffer, 整数型
    .局部变量 fSave, 逻辑型
    .局部变量 dwMaxUserName, 整数型
    .局部变量 dwMaxPassword, 整数型
    .局部变量 szUserName, 字节集
    .局部变量 szPassword, 字节集

    .判断循环首 (真)
        UiInfo.cbSize ＝ 20 ' sizeof(CREDUI_INFOW)
        UiInfo.hwndParent ＝ 窗口句柄
        .如果 (标题 ＝ { })
            UiInfo.pszCaptionText ＝ 编码_Ansi到Unicode (“登陆”, )
        .否则
            UiInfo.pszCaptionText ＝ 标题
        .如果结束
        .如果 (提示内容 ＝ { })
            UiInfo.pszMessageText ＝ 编码_Ansi到Unicode (“请输入用户名与密码”, )
        .否则
            UiInfo.pszMessageText ＝ 提示内容
        .如果结束
        lRes ＝ CredUIPromptForWindowsCredentialsW (UiInfo, dwAuthError, ulAuthPackage, #NULL, 0, pAuthBuffer, cbAuthBuffer, fSave, #CREDUIWIN_GENERIC)
        .如果真 (lRes ≠ #ERROR_SUCCESS)
            返回 (假)
        .如果真结束
        CredUnPackAuthenticationBufferW (0, pAuthBuffer, cbAuthBuffer, #NULL, dwMaxUserName, #NULL, 0, #NULL, dwMaxPassword)
        .如果真 (dwMaxUserName ＝ 0 或 dwMaxPassword ＝ 0)
            返回 (假)
        .如果真结束
        szUserName ＝ 取空白字节集 (dwMaxUserName × 2)
        szPassword ＝ 取空白字节集 (dwMaxPassword × 2)
        lRes ＝ CredUnPackAuthenticationBufferW (0, pAuthBuffer, cbAuthBuffer, 取指针字节集_ (szUserName), dwMaxUserName, #NULL, 0, 取指针字节集_ (szPassword), dwMaxPassword)
        CoTaskMemFree (pAuthBuffer)
        .如果真 (lRes ＝ 1) ' TRUE
            .如果 (是否区分大小写)
                .如果真 (lstrcmpW (取指针字节集_ (szUserName), 用户名) ＝ 0 且 lstrcmpW (取指针字节集_ (szPassword), 密码) ＝ 0)
                    返回 (真)
                .如果真结束
                
            .否则
                
                .如果真 (lstrcmpiW (取指针字节集_ (szUserName), 用户名) ＝ 0 且 lstrcmpiW (取指针字节集_ (szPassword), 密码) ＝ 0)
                    返回 (真)
                .如果真结束
                
            .如果结束
            
        .如果真结束
        dwAuthError ＝ #ERROR_LOGON_FAILURE
        处理事件 ()
    .判断循环尾 ()
    返回 (假)

.子程序 系统_打开属性对话框, 逻辑型, 公开, 显示文件或文件夹的属性
    .参数 文件路径, 文本型

    返回 (系统_打开属性对话框W (编码_Ansi到Unicode (文件路径, )))

.子程序 系统_打开属性对话框W, 逻辑型, 公开, 显示文件或文件夹的属性
    .参数 文件路径, 字节集
    .局部变量 ShExecInfo, SHELLEXECUTEINFOW

    ShExecInfo.cbSize ＝ 60 ' sizeof(SHELLEXECUTEINFOW)
    ShExecInfo.fMask ＝ 位或 (#SEE_MASK_INVOKEIDLIST, #SEE_MASK_NOCLOSEPROCESS, #SEE_MASK_NOASYNC, #SEE_MASK_FLAG_NO_UI, #SEE_MASK_UNICODE)
    ShExecInfo.lpVerb ＝ 编码_Ansi到Unicode (“properties”, )
    ShExecInfo.lpFile ＝ 文件路径
    ShExecInfo.nShow ＝ #SW_SHOWDEFAULT
    ShellExecuteExW (ShExecInfo)
    返回 (ShExecInfo.hInstApp ＞ 32)

.子程序 DosToLogicalDrive, 字节集, 公开, MS-DOS设备名称转逻辑盘符
    .参数 szPath, 字节集, , W
    .局部变量 szDrive, 字节集
    .局部变量 szDevName, 字节集
    .局部变量 dwSize, 整数型
    .局部变量 szTemp, 字节集
    .局部变量 i, 整数型

    szDrive ＝ { 64, 0, 58, 0, 0, 0 } ' 逻辑盘符 A-Z
    szDevName ＝ 取空白字节集 ((#MAX_PATH ＋ 1) × 2)
    .计次循环首 (26, i)
        szDrive [1] ＝ szDrive [1] ＋ 1
        dwSize ＝ QueryDosDeviceW (szDrive, szDevName, #MAX_PATH)
        .如果真 (dwSize ＞ 0)
            szDevName [dwSize × 2 － 3] ＝ 92 ' 结尾加上反斜杆
            dwSize ＝ dwSize × 2 － 2 ' 不以NULL结尾
            szTemp ＝ 取字节集左边 (szDevName, dwSize)
            .如果真 (寻找字节集 (szPath, szTemp, ) ＝ 1)
                szDrive [5] ＝ 92 ' 结尾加上反斜杆
                返回 (字节集替换 (szPath, 1, dwSize, szDrive))
            .如果真结束
            
        .如果真结束
        
    .计次循环尾 ()
    返回 (szPath)

.子程序 字体_取单字宽高, 小数型, 公开, 返回文本的精确尺寸，宽高都为此值，若是半角手动除以2即为宽！（自动适应各个电脑分辨率，若失败则返回0）
    .参数 字号, 小数型
    .参数 是否加粗, 逻辑型, 可空, 默认假，加粗与常规字宽度不同！
    .局部变量 欲转换字号, 小数型

    .判断开始 (字号 ＝ 5)
        欲转换字号 ＝ 5.25
    .判断 (字号 ＝ 7)
        欲转换字号 ＝ 7.78
    .判断 (字号 ＝ 8)
        欲转换字号 ＝ 7.87
    .判断 (字号 ＝ 11)
        欲转换字号 ＝ 10.5
    .判断 (字号 ＝ 14)
        欲转换字号 ＝ 13.75
    .判断 (字号 ＝ 16)
        欲转换字号 ＝ 15.75
    .判断 (字号 ＝ 26)
        欲转换字号 ＝ 27.5
    .默认
        欲转换字号 ＝ 字号
    .判断结束
    返回 (选择 (是否加粗, 取整加一 (毫米转像素 (字号转换毫米 (欲转换字号))), 毫米转像素 (字号转换毫米 (欲转换字号))))

.子程序 字体_取单字宽高的字号, 整数型, 公开, 返回易语言的整数型字号
    .参数 单字宽高, 小数型, , 逆天_取汉字单字宽高 取得的宽高，方块类型
    .参数 是否加粗, 逻辑型, 可空, 默认假

    返回 (选择 (是否加粗, 某舍某入 (毫米转换字号 (像素转毫米 (取整 (单字宽高))), 5, 6), 取整加一 (毫米转换字号 (像素转毫米 (取整 (单字宽高))))))

.版本 2

.程序集 集_菜单类
.子程序 菜单_点击, , 公开, 后台点击指定窗口上的指定菜单；
    .参数 窗口句柄, 整数型, , 要点击菜单的窗口句柄；
    .参数 菜单句柄, 整数型, , 要点击的菜单句柄；
    .参数 菜单索引, 整数型, , 菜单索引从0开始；

    投递消息整数 (窗口句柄, 273, 菜单_取ID (菜单句柄, 菜单索引), 0)

.子程序 菜单_取ID, 整数型, 公开
    .参数 菜单句柄, 整数型
    .参数 菜单索引, 整数型

    返回 (GetMenuItemID (菜单句柄, 菜单索引))

.子程序 菜单_清除, 逻辑型, 公开, 成功返回真，失败返回假；
    .参数 菜单句柄, 整数型

    返回 (DestroyMenu (菜单句柄))

.子程序 菜单_重画, 逻辑型, 公开, 为指定的窗口重画菜单,成功返回真，失败返回假；
    .参数 窗口句柄, 整数型, , 窗口句柄

    返回 (DrawMenuBar (窗口句柄))

.子程序 菜单_删除, 逻辑型, 公开, 成功返回真，失败返回假；
    .参数 菜单句柄, 整数型, , 同级的菜单句柄；
    .参数 菜单索引, 整数型, , 索引从0开始；

    返回 (RemoveMenu (菜单句柄, 菜单索引, 1024))

.子程序 菜单_取数量, 整数型, 公开, 成功返回菜单数量，失败返回0；
    .参数 菜单句柄, 整数型, , 要取数量的菜单句柄；

    返回 (GetMenuItemCount (菜单句柄))

.子程序 菜单_取句柄, 整数型, 公开, 成功返回菜单句柄，失败返回0；
    .参数 窗口句柄, 整数型, , 要取菜单的窗口句柄；

    返回 (GetMenu (窗口句柄))

.子程序 菜单_取标题, 文本型, 公开, 成功返回菜单标题；失败返回空文本；
    .参数 菜单句柄, 整数型, , 菜单句柄
    .参数 菜单索引, 整数型, , 索引从0开始；
    .局部变量 文本, 文本型
    .局部变量 返回, 整数型
    .局部变量 菜单ID, 整数型

    文本 ＝ 取空白文本 (255)
    菜单ID ＝ GetMenuItemID (菜单句柄, 菜单索引)
    GetMenuStringA (菜单句柄, 菜单索引, 文本, 255, 0)
    .如果真 (文本 ＝ “”)
        GetMenuStringA (菜单句柄, 菜单索引, 文本, 255, 3)
    .如果真结束
    .如果真 (文本 ＝ “”)
        GetMenuStringA (菜单句柄, 菜单索引, 文本, 255, 8)
    .如果真结束
    .如果真 (文本 ＝ “”)
        GetMenuStringA (菜单句柄, 菜单索引, 文本, 255, 1024)
    .如果真结束
    .如果真 (文本 ＝ “”)
        GetMenuStringA (菜单句柄, 菜单索引, 文本, 255, 2048)
    .如果真结束
    .如果真 (文本 ＝ “” 且 菜单ID ≠ -1)
        文本 ＝ “分隔符”
    .如果真结束
    返回 (文本)

.子程序 菜单_枚举, 整数型, 公开, 成功返回菜单的数量和标题数组；失败返回0；
    .参数 窗口句柄, 整数型, , 要枚举菜单标题的窗口句柄；
    .参数 菜单标题数组, 文本型, 参考 可空 数组, 用于存放菜单标题的文本数组；
    .参数 菜单ID数组, 整数型, 参考 可空 数组, 用于存放菜单ID的整数数组；
    .局部变量 一级菜单, 整数型
    .局部变量 二级菜单, 整数型
    .局部变量 三级菜单, 整数型
    .局部变量 局_一级计次, 整数型
    .局部变量 局_二级计次, 整数型
    .局部变量 局_三级计次, 整数型
    .局部变量 局_一级数量, 整数型
    .局部变量 局_二级数量, 整数型
    .局部变量 局_三级数量, 整数型
    .局部变量 局_菜单索引, 整数型

    一级菜单 ＝ 菜单_取句柄 (窗口句柄)
    局_菜单索引 ＝ 19999
    .如果真 (一级菜单 ≠ 0)
        局_一级数量 ＝ 菜单_取数量 (一级菜单)
        .计次循环首 (局_一级数量, 局_一级计次)
            加入成员 (菜单标题数组, 菜单_取标题 (一级菜单, 局_一级计次 － 1))
            局_菜单索引 ＝ 局_菜单索引 ＋ 1
            加入成员 (菜单ID数组, 局_菜单索引)
            二级菜单 ＝ 菜单_取子句柄 (一级菜单, 局_一级计次 － 1)
            局_二级数量 ＝ 菜单_取数量 (二级菜单)
            .如果真 (局_二级数量 ＞ 0)
                .计次循环首 (局_二级数量, 局_二级计次)
                    加入成员 (菜单标题数组, 菜单_取标题 (二级菜单, 局_二级计次 － 1))
                    局_菜单索引 ＝ 局_菜单索引 ＋ 1
                    加入成员 (菜单ID数组, 局_菜单索引)
                    三级菜单 ＝ 菜单_取子句柄 (二级菜单, 局_二级计次 － 1)
                    局_三级数量 ＝ 菜单_取数量 (三级菜单)
                    .如果真 (局_三级数量 ＞ 0)
                        .计次循环首 (局_三级数量, 局_三级计次)
                            加入成员 (菜单标题数组, 菜单_取标题 (三级菜单, 局_三级计次 － 1))
                            局_菜单索引 ＝ 局_菜单索引 ＋ 1
                            加入成员 (菜单ID数组, 局_菜单索引)
                            处理事件 ()
                        .计次循环尾 ()
                    .如果真结束
                    处理事件 ()
                .计次循环尾 ()
            .如果真结束
            处理事件 ()
        .计次循环尾 ()
    .如果真结束
    返回 (取数组成员数 (菜单ID数组))

.子程序 菜单_枚举子级菜单, 整数型, 公开, 枚举子级菜单标题，成功返回子菜单数量，失败返回0；
    .参数 窗口句柄, 整数型
    .参数 父菜单标题, 文本型
    .参数 子菜单标题数组, 文本型, 可空 数组, 用于装载子菜单标题的数组变量；
    .局部变量 局_菜单句柄, 整数型
    .局部变量 局_子菜单句柄, 整数型
    .局部变量 局_计次, 整数型
    .局部变量 局_菜单数量, 整数型

    局_菜单句柄 ＝ 菜单_取句柄 (窗口句柄)
    局_菜单数量 ＝ 菜单_取数量 (局_菜单句柄)
    .计次循环首 (局_菜单数量, 局_计次)
        .如果真 (菜单_取标题 (局_菜单句柄, 局_计次 － 1) ＝ 父菜单标题)
            局_子菜单句柄 ＝ 菜单_取子句柄 (局_菜单句柄, 局_计次 － 1)
            跳出循环 ()
        .如果真结束
        处理事件 ()
    .计次循环尾 ()
    局_菜单数量 ＝ 菜单_取数量 (局_子菜单句柄)
    .计次循环首 (局_菜单数量, 局_计次)
        加入成员 (子菜单标题数组, 菜单_取标题 (局_子菜单句柄, 局_计次 － 1))
        处理事件 ()
    .计次循环尾 ()
    返回 (取数组成员数 (子菜单标题数组))

.子程序 菜单_修改标题, 逻辑型, 公开, 成功返回真，失败返回假；只能改子菜单标题；
    .参数 菜单句柄, 整数型, , 要修改标题的菜单句柄；
    .参数 菜单新标题, 文本型, , 菜单新标题
    .参数 菜单索引, 整数型, , 索引从0开始；
    .局部变量 局_菜单ID, 整数型

    局_菜单ID ＝ GetMenuItemID (菜单句柄, 菜单索引)
    .判断开始 (ModifyMenuA (菜单句柄, 局_菜单ID, 0, 局_菜单ID, 菜单新标题))
        返回 (真)
    .判断 (ModifyMenuA (菜单句柄, 局_菜单ID, 0, 3, 菜单新标题))
        返回 (真)
    .判断 (ModifyMenuA (菜单句柄, 局_菜单ID, 0, 8, 菜单新标题))
        返回 (真)
    .判断 (ModifyMenuA (菜单句柄, 局_菜单ID, 0, 1024, 菜单新标题))
        返回 (真)
    .默认
        返回 (ModifyMenuA (菜单句柄, 局_菜单ID, 0, 2048, 菜单新标题))
    .判断结束
    返回 (假)
    

.子程序 菜单_取子句柄, 整数型, 公开, 成功返回子菜单句柄，失败返回0；
    .参数 父菜单句柄, 整数型, , 菜单句柄
    .参数 父菜单索引, 整数型, , 索引从0开始；

    返回 (GetSubMenu (父菜单句柄, 父菜单索引))

.子程序 菜单_添加, 逻辑型, 公开, 成功返回真，失败返回假；
    .参数 菜单句柄, 整数型, , 同级的菜单句柄；
    .参数 菜单标题, 文本型, 可空, 如果 菜单类型 为4时，此参数留空；
    .参数 菜单类型, 整数型, 可空, 0=普通；1=禁止；2=打勾；3=分支菜单；4=菜单分隔条；
    .参数 弹出式菜单句柄, 整数型, 参考 可空, 如果  菜单类型 为3时，引参数用来接收弹出式菜单句柄的；
    .参数 菜单数值, 整数型, 可空, 用于辩认菜单的数值，跟列表框的数值一样；

    .判断开始 (菜单类型 ＝ 0)
        返回 (AppendMenuA (菜单句柄, 0, 菜单数值, 菜单标题))
    .判断 (菜单类型 ＝ 1)
        返回 (AppendMenuA (菜单句柄, 3, 菜单数值, 菜单标题))
    .判断 (菜单类型 ＝ 2)
        返回 (AppendMenuA (菜单句柄, 8, 菜单数值, 菜单标题))
    .判断 (菜单类型 ＝ 3)
        弹出式菜单句柄 ＝ CreatePopupMenu ()
        返回 (AppendMenuA (菜单句柄, 16, 弹出式菜单句柄, 菜单标题))
    .默认
        返回 (AppendMenuA (菜单句柄, 2048, 菜单数值, “”))
    .判断结束
    返回 (假)

.子程序 菜单_点击按标题, , 公开, 如果有的菜单点击不了,请将参数4设置为真试试；
    .参数 窗口句柄, 整数型, , 要点击菜单的窗口；
    .参数 菜单标题, 文本型, , 要点击的菜单标题；
    .参数 模糊点击, 逻辑型, 可空, 可空，默认为假，精确点击；真=模糊点击；
    .参数 备用参数, 逻辑型, 可空, 如果有的菜单点击不了请将些参数设置为真试试；
    .局部变量 临时文本, 文本型
    .局部变量 计次, 整数型
    .局部变量 菜单数量, 整数型
    .局部变量 菜单标题数组, 文本型, , "0"
    .局部变量 菜单ID数组, 整数型, , "0"

    菜单数量 ＝ 菜单_枚举 (窗口句柄, 菜单标题数组, 菜单ID数组)
    .计次循环首 (菜单数量, 计次)
        临时文本 ＝ 菜单标题数组 [计次]
        .如果 (模糊点击)
            .如果真 (寻找文本 (临时文本, 菜单标题, , 假) ≠ -1)
                .如果 (备用参数)
                    投递消息整数 (窗口句柄, 273, 菜单ID数组 [计次] － 20000, 0)
                .否则
                    投递消息整数 (窗口句柄, 273, 菜单ID数组 [计次] － 20001, 0)
                .如果结束
                跳出循环 ()
            .如果真结束
            
        .否则
            .如果真 (临时文本 ＝ 菜单标题)
                .如果 (备用参数)
                    投递消息整数 (窗口句柄, 273, 菜单ID数组 [计次] － 20000, 0)
                .否则
                    投递消息整数 (窗口句柄, 273, 菜单ID数组 [计次] － 20001, 0)
                .如果结束
                跳出循环 ()
            .如果真结束
            
        .如果结束
        处理事件 ()
    .计次循环尾 ()

.子程序 菜单_添加图标, 逻辑型, 公开, 在指定定的菜单处加入图标
    .参数 子菜单索引, 整数型, , 子菜单索引
    .参数 菜单句柄, 整数型, , 欲添加图标的菜单句柄
    .参数 未选图标句柄, 整数型, , 未选中时的图标句柄,可以用 图标_取句柄() 命令取得 图标句柄
    .参数 已选图标句柄, 整数型, , 已选中时的图标句柄,可以用 图标_取句柄() 命令取得 图标句柄

    返回 (SetMenuItemBitmaps (菜单句柄, 子菜单索引, 1024, 未选图标句柄, 已选图标句柄))

.版本 2

.程序集 任务栏扩展命令
.子程序 WndProc, 整数型
    .参数 hWnd, 整数型
    .参数 msg, 整数型
    .参数 wParam, 整数型
    .参数 lParam, 整数型
    .局部变量 oldProc, 整数型
    .局部变量 taskbarBtnCreatedMsg, 整数型
    .局部变量 onTaskbarBtnCreated, 整数型
    .局部变量 onTaskbarBtnClick, 整数型
    .局部变量 code, 整数型
    .局部变量 hImageList, 整数型
    .局部变量 hIcon, 整数型

    oldProc ＝ GetPropA (hWnd, “oldProc”)
    taskbarBtnCreatedMsg ＝ GetPropA (hWnd, “taskbarBtnCreatedMsg”)
    .判断开始 (msg ＝ taskbarBtnCreatedMsg)
        onTaskbarBtnCreated ＝ GetPropA (hWnd, “onTaskbarBtnCreated”)
        .如果真 (onTaskbarBtnCreated ≠ 0)
            call1 (onTaskbarBtnCreated, hWnd)
        .如果真结束
        
    .判断 (msg ＝ #WM_COMMAND)
        code ＝ 右移 (wParam, 16)
        .判断开始 (code ＝ #THBN_CLICKED)
            onTaskbarBtnClick ＝ GetPropA (hWnd, “onTaskbarBtnClick”)
            .如果真 (onTaskbarBtnClick ≠ 0)
                call2 (onTaskbarBtnClick, hWnd, 位与 (wParam, 65535))
            .如果真结束
            
        .默认
            
        .判断结束
        
    .判断 (msg ＝ #WM_DESTROY)
        .如果真 (oldProc ≠ 0)
            SetWindowLongA (hWnd, #GWL_WNDPROC, oldProc)
            SetPropA (hWnd, “oldProc”, 0)
        .如果真结束
        hImageList ＝ GetPropA (hWnd, “hImageList”)
        .如果真 (hImageList ≠ 0)
            ImageList_Destroy (hImageList)
            SetPropA (hWnd, “hImageList”, 0)
        .如果真结束
        hIcon ＝ GetPropA (hWnd, “OverlayIcon”)
        .如果真 (hIcon ≠ 0)
            DestroyIcon (hIcon)
            SetPropA (hWnd, “OverlayIcon”, 0)
        .如果真结束
        
    .默认
        
    .判断结束
    
    .如果真 (oldProc ≠ 0)
        返回 (CallWindowProcA (oldProc, hWnd, msg, wParam, lParam))
    .如果真结束
    返回 (DefWindowProc (hWnd, msg, wParam, lParam))

.子程序 call1, 整数型
    .参数 函数地址, 整数型
    .参数 参数1, 整数型

    置入代码 ({ 139, 69, 8, 139, 93, 4, 137, 93, 8, 93, 91, 255, 224 })
    返回 (0)

.子程序 call2, 整数型
    .参数 函数地址, 整数型
    .参数 参数1, 整数型
    .参数 参数2, 整数型

    置入代码 ({ 139, 69, 8, 139, 93, 4, 137, 93, 8, 93, 91, 255, 224 })
    返回 (0)

.子程序 _Alloc, 整数型
    .参数 Size, 整数型

    返回 (HeapAlloc (GetProcessHeap (), #HEAP_ZERO_MEMORY, Size))

.子程序 _Free
    .参数 addr, 整数型

    HeapFree (GetProcessHeap (), 0, addr)

.子程序 _CreateIStream, 整数型
    .参数 参数_字节集, 字节集, 可空, 字节集数据。
    .参数 参数_大小, 整数型, 可空, 默认为 参数_字节集 的长度
    .局部变量 hMem, 整数型
    .局部变量 IStream, 整数型
    .局部变量 ptr, 整数型

    .如果真 (是否为空 (参数_大小))
        参数_大小 ＝ 取字节集长度 (参数_字节集)
    .如果真结束
    hMem ＝ GlobalAlloc (位或 (#GMEM_ZEROINIT, #GMEM_MOVEABLE), 参数_大小)
    CreateStreamOnHGlobal_整数型 (hMem, 1, IStream)
    .如果真 (是否为空 (参数_字节集) ＝ 假)
        ptr ＝ GlobalLock (hMem)
        写到内存 (参数_字节集, ptr, 参数_大小)
        GlobalUnlock (hMem)
    .如果真结束
    返回 (IStream)
    

.子程序 创建图标自字节集, 整数型, 公开, 创建自图标文件字节集，格式必须是ICON。成功返回图标句柄
    .参数 参数_字节集, 字节集
    .参数 参数_索引, 整数型, 可空, 索引从0开始
    .参数 参数_宽度, 整数型, 可空, 指定图标的宽度，空表示不改变
    .参数 参数_高度, 整数型, 可空, 指定图标的高度，空表示不改变
    .局部变量 hIcon, 整数型
    .局部变量 局部_指针, 整数型
    .局部变量 局部_idType, 整数型
    .局部变量 局部_IconDirEntry, IconDirEntry

    局部_指针 ＝ _取指针字节集 (参数_字节集)
    局部_idType ＝ _指针到短整数 (局部_指针 ＋ 2)
    RtlMoveMemory_IconDirEntry (局部_IconDirEntry, 局部_指针 ＋ 6 ＋ 参数_索引 × 16, 16)
    hIcon ＝ CreateIconFromResourceEx (局部_指针 ＋ 局部_IconDirEntry.dwImageOffset, 局部_IconDirEntry.dwBytesInRes, 局部_idType, 196608, 参数_宽度, 参数_高度, 0)
    返回 (hIcon)

.子程序 _取指针字节集, 整数型
    .参数 参数_字节集, 字节集, 参考

    置入代码 ({ 139, 69, 8, 139, 0, 133, 192, 116, 5, 5, 8, 0, 0, 0, 201, 194, 4, 0 })
    返回 (0)

.子程序 _指针到短整数, 短整数型
    .参数 参数_指针, 整数型

    置入代码 ({ 139, 93, 8, 49, 192, 139, 3, 201, 194, 4, 0 })
    ' mov ebx,[ebp+08]
    ' xor eax,eax
    ' mov word eax,[ebx]
    ' leave
    ' retn 04
    返回 (0)

.子程序 文本到CLSID, 字节集
    .参数 参数_文本, 文本型
    .局部变量 局部_clsid, 字节集
    .局部变量 wzText, 字节集

    局部_clsid ＝ 取空白字节集 (16)
    wzText ＝ 编码_Ansi到Unicode (参数_文本, )
    CLSIDFromString (取指针_字节集型 (wzText), 局部_clsid)
    返回 (局部_clsid)

.子程序 GUID到文本, 文本型
    .参数 参数_GUID, 字节集
    .局部变量 局部_String, 字节集

    局部_String ＝ 取空白字节集 (78)
    StringFromGUID2 (参数_GUID, 局部_String, 78)
    返回 (编码_Unicode到Ansi (局部_String))

.子程序 _取指针对象, 整数型
    .参数 参数_对象, 对象, 参考

    置入代码 ({ 139, 69, 8, 139, 0, 139, 0, 201, 194, 4, 0 })
    ' mov eax,[ebp+08]
    ' mov eax,[eax]
    ' mov eax,[eax]
    ' leave
    ' retn 04
    返回 (0)

.子程序 分割线, , , ——————————————————————————————————————————————————————————
    

.子程序 ITaskbarList_QueryInterface, 整数型
    .参数 This, 整数型
    .参数 riid, 整数型
    .参数 ppvObject, 整数型, , __RPC__deref_out  void **
    .局部变量 index, 整数型

    index ＝ 0
    置入代码 ({ 139, 69, 8, 133, 192, 116, 9, 139, 77, 252, 139, 0, 201, 255, 36, 136 })
    返回 (1)
    

.子程序 ITaskbarList_AddRef, 整数型
    .参数 This, 整数型
    .局部变量 index, 整数型

    index ＝ 1
    置入代码 ({ 139, 69, 8, 133, 192, 116, 9, 139, 77, 252, 139, 0, 201, 255, 36, 136 })
    返回 (0)
    

.子程序 ITaskbarList_Release, 整数型
    .参数 This, 整数型
    .局部变量 index, 整数型

    index ＝ 2
    置入代码 ({ 139, 69, 8, 133, 192, 116, 9, 139, 77, 252, 139, 0, 201, 255, 36, 136 })
    返回 (0)

.子程序 ITaskbarList_HrInit, 整数型, , HRESULT
    .参数 This, 整数型
    .局部变量 index, 整数型

    index ＝ 3
    置入代码 ({ 139, 69, 8, 133, 192, 116, 9, 139, 77, 252, 139, 0, 201, 255, 36, 136 })
    返回 (1)

.子程序 ITaskbarList_AddTab, 整数型, , HRESULT
    .参数 This, 整数型
    .参数 hwnd, 整数型, , /* [in] */ __RPC__in HWND
    .局部变量 index, 整数型

    index ＝ 4
    置入代码 ({ 139, 69, 8, 133, 192, 116, 9, 139, 77, 252, 139, 0, 201, 255, 36, 136 })
    返回 (1)

.子程序 ITaskbarList_DeleteTab, 整数型, , HRESULT
    .参数 This, 整数型
    .参数 hwnd, 整数型, , /* [in] */ __RPC__in HWND
    .局部变量 index, 整数型

    index ＝ 5
    置入代码 ({ 139, 69, 8, 133, 192, 116, 9, 139, 77, 252, 139, 0, 201, 255, 36, 136 })
    返回 (1)

.子程序 ITaskbarList_ActivateTab, 整数型, , HRESULT
    .参数 This, 整数型
    .参数 hwnd, 整数型, , /* [in] */ __RPC__in HWND
    .局部变量 index, 整数型

    index ＝ 6
    置入代码 ({ 139, 69, 8, 133, 192, 116, 9, 139, 77, 252, 139, 0, 201, 255, 36, 136 })
    返回 (1)

.子程序 ITaskbarList_SetActiveAlt, 整数型, , HRESULT
    .参数 This, 整数型
    .参数 hwnd, 整数型, , /* [in] */ __RPC__in HWND
    .局部变量 index, 整数型

    index ＝ 7
    置入代码 ({ 139, 69, 8, 133, 192, 116, 9, 139, 77, 252, 139, 0, 201, 255, 36, 136 })
    返回 (1)

.子程序 ITaskbarList_MarkFullscreenWindow, 整数型, , ITaskbarList2 =====================================
    .参数 This, 整数型
    .参数 hwnd, 整数型, , /* [in] */ __RPC__in HWND
    .参数 fFullscreen, 整数型, , /* [in] */ BOOL
    .局部变量 index, 整数型

    index ＝ 8
    置入代码 ({ 139, 69, 8, 133, 192, 116, 9, 139, 77, 252, 139, 0, 201, 255, 36, 136 })
    返回 (1)
    
    

.子程序 ITaskbarList_SetProgressValue, 整数型, , ITaskbarList3 =====================================
    .参数 This, 整数型
    .参数 hwnd, 整数型, , /* [in] */ __RPC__in HWND
    .参数 ullCompleted, 长整数型, , /* [in] */ ULONGLONG
    .参数 ullTotal, 长整数型, , /* [in] */ ULONGLONG
    .局部变量 index, 整数型

    index ＝ 9
    置入代码 ({ 139, 69, 8, 133, 192, 116, 9, 139, 77, 252, 139, 0, 201, 255, 36, 136 })
    返回 (1)

.子程序 ITaskbarList_SetProgressState, 整数型, , HRESULT
    .参数 This, 整数型
    .参数 hwnd, 整数型, , /* [in] */ __RPC__in HWND
    .参数 tbpFlags, 整数型, , /* [in] */ TBPFLAG
    .局部变量 index, 整数型

    index ＝ 10
    置入代码 ({ 139, 69, 8, 133, 192, 116, 9, 139, 77, 252, 139, 0, 201, 255, 36, 136 })
    返回 (1)

.子程序 ITaskbarList_RegisterTab, 整数型, , HRESULT
    .参数 This, 整数型
    .参数 hwndTab, 整数型, , /* [in] */ __RPC__in HWND
    .参数 hwndMDI, 整数型, , /* [in] */ __RPC__in HWND
    .局部变量 index, 整数型

    index ＝ 11
    置入代码 ({ 139, 69, 8, 133, 192, 116, 9, 139, 77, 252, 139, 0, 201, 255, 36, 136 })
    返回 (1)

.子程序 ITaskbarList_UnregisterTab, 整数型, , HRESULT
    .参数 This, 整数型
    .参数 hwndTab, 整数型, , /* [in] */ __RPC__in HWND
    .局部变量 index, 整数型

    index ＝ 12
    置入代码 ({ 139, 69, 8, 133, 192, 116, 9, 139, 77, 252, 139, 0, 201, 255, 36, 136 })
    返回 (1)

.子程序 ITaskbarList_SetTabOrder, 整数型, , HRESULT
    .参数 This, 整数型
    .参数 hwndTab, 整数型, , /* [in] */ __RPC__in HWND
    .参数 hwndInsertBefore, 整数型, , /* [in] */ __RPC__in HWND
    .局部变量 index, 整数型

    index ＝ 13
    置入代码 ({ 139, 69, 8, 133, 192, 116, 9, 139, 77, 252, 139, 0, 201, 255, 36, 136 })
    返回 (1)

.子程序 ITaskbarList_SetTabActive, 整数型, , HRESULT
    .参数 This, 整数型
    .参数 hwndTab, 整数型, , /* [in] */ __RPC__in HWND
    .参数 hwndMDI, 整数型, , /* [in] */ __RPC__in HWND
    .参数 dwReserved, 整数型, , /* [in] */ DWORD
    .局部变量 index, 整数型

    index ＝ 14
    置入代码 ({ 139, 69, 8, 133, 192, 116, 9, 139, 77, 252, 139, 0, 201, 255, 36, 136 })
    返回 (1)

.子程序 ITaskbarList_ThumbBarAddButtons, 整数型, , HRESULT
    .参数 This, 整数型
    .参数 hwnd, 整数型, , /* [in] */ __RPC__in HWND
    .参数 cButtons, 整数型, , /* [in] */ UINT
    .参数 pButton, 整数型, , /* [size_is][in] */ __RPC__in_ecount_full(cButtons) LPTHUMBBUTTON
    .局部变量 index, 整数型

    index ＝ 15
    置入代码 ({ 139, 69, 8, 133, 192, 116, 9, 139, 77, 252, 139, 0, 201, 255, 36, 136 })
    返回 (1)

.子程序 ITaskbarList_ThumbBarUpdateButtons, 整数型, , HRESULT
    .参数 This, 整数型
    .参数 hwnd, 整数型, , /* [in] */ __RPC__in HWND
    .参数 cButtons, 整数型, , /* [in] */ UINT
    .参数 pButton, 整数型, , /* [size_is][in] */ __RPC__in_ecount_full(cButtons) LPTHUMBBUTTON
    .局部变量 index, 整数型

    index ＝ 16
    置入代码 ({ 139, 69, 8, 133, 192, 116, 9, 139, 77, 252, 139, 0, 201, 255, 36, 136 })
    返回 (1)

.子程序 ITaskbarList_ThumbBarSetImageList, 整数型, , HRESULT
    .参数 This, 整数型
    .参数 hwnd, 整数型, , /* [in] */ __RPC__in HWND
    .参数 himl, 整数型, , /* [in] */ __RPC__in_opt HIMAGELIST
    .局部变量 index, 整数型

    index ＝ 17
    置入代码 ({ 139, 69, 8, 133, 192, 116, 9, 139, 77, 252, 139, 0, 201, 255, 36, 136 })
    返回 (1)

.子程序 ITaskbarList_SetOverlayIcon, 整数型, , HRESULT
    .参数 This, 整数型
    .参数 hwnd, 整数型, , /* [in] */ __RPC__in HWND
    .参数 hIcon, 整数型, , /* [in] */ __RPC__in HICON
    .参数 pszDescription, 整数型, , /* [string][unique][in] */ __RPC__in_opt_string LPCWSTR
    .局部变量 index, 整数型

    index ＝ 18
    置入代码 ({ 139, 69, 8, 133, 192, 116, 9, 139, 77, 252, 139, 0, 201, 255, 36, 136 })
    返回 (1)

.子程序 ITaskbarList_SetThumbnailTooltip, 整数型, , HRESULT
    .参数 This, 整数型
    .参数 hwnd, 整数型, , /* [in] */ __RPC__in HWND
    .参数 pszTip, 整数型, , /* [string][unique][in] */ __RPC__in_opt_string LPCWSTR
    .局部变量 index, 整数型

    index ＝ 19
    置入代码 ({ 139, 69, 8, 133, 192, 116, 9, 139, 77, 252, 139, 0, 201, 255, 36, 136 })
    返回 (1)

.子程序 ITaskbarList_SetThumbnailClip, 整数型, , HRESULT
    .参数 This, 整数型
    .参数 hwnd, 整数型, , /* [in] */ __RPC__in HWND
    .参数 prcClip, 整数型, , /* [in] */ __RPC__in RECT*
    .局部变量 index, 整数型

    index ＝ 20
    置入代码 ({ 139, 69, 8, 133, 192, 116, 9, 139, 77, 252, 139, 0, 201, 255, 36, 136 })
    返回 (1)

.版本 2

.程序集 外部控件操作, , 公开
.程序集变量 映射文件, 内存映射数据9X, , "0"

.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
    

.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
    

.子程序 结束操作, , 公开
    .参数 进程句柄, 整数型, 参考

    .如果真 (进程句柄 ≠ 0)
        CloseHandle (进程句柄)
        清除数组 (映射文件)
        进程句柄 ＝ #NULL
    .如果真结束
    

.子程序 打开进程, 整数型, 公开, 成功就返回进程句柄
    .参数 对象句柄, 整数型
    .局部变量 dwProcessId, 整数型
    .局部变量 hProcess, 整数型

    .如果 (IsWindow (对象句柄) ≠ 0)
        GetWindowThreadProcessId (对象句柄, dwProcessId)
    .否则
        dwProcessId ＝ 对象句柄
    .如果结束
    hProcess ＝ OpenProcess (位或 (#PROCESS_CREATE_THREAD, #PROCESS_VM_OPERATION, #PROCESS_VM_READ, #PROCESS_VM_WRITE, #PROCESS_QUERY_LIMITED_INFORMATION), 0, dwProcessId)
    .如果真 (hProcess ＝ #NULL)
        输出调试文本 (取错误信息文本_API (, ))
    .如果真结束
    返回 (hProcess)

.子程序 写进程内存, 逻辑型, 公开
    .参数 进程句柄, 整数型
    .参数 数据指针, 整数型
    .参数 数据地址, 整数型
    .参数 数据长度, 整数型
    .局部变量 lRes, 逻辑型

    lRes ＝ WriteProcessMemory_整数型 (进程句柄, 数据指针, 数据地址, 数据长度, #NULL) ≠ 0
    .如果真 (lRes ＝ 假)
        输出调试文本 (取错误信息文本_API (, ))
    .如果真结束
    返回 (lRes)

.子程序 分配外部指针, 整数型, 公开
    .参数 进程句柄, 整数型
    .参数 数据长度, 整数型, , 分配的数据长度
    .局部变量 pMem, 整数型
    .局部变量 TEMP, 内存映射数据9X

    .判断开始 (_WIN32_WINNT ≥ #_WIN32_WINNT_WINXP)
        pMem ＝ VirtualAllocEx (进程句柄, 0, 数据长度, #MEM_COMMIT, #PAGE_READWRITE)
        .如果真 (pMem ＝ #NULL)
            输出调试文本 (取错误信息文本_API (, ))
        .如果真结束
        返回 (pMem)
    .默认
        TEMP.映射文件号 ＝ CreateFileMappingA (#INVALID_HANDLE_VALUE, #NULL, #PAGE_READWRITE, 0, 数据长度, 字符 (#NULL))
        TEMP.指针 ＝ MapViewOfFile (TEMP.映射文件号, #FILE_MAP_ALL_ACCESS, 0, 0, 0)
        重定义数组 (映射文件, 真, 取数组成员数 (映射文件) ＋ 1)
        映射文件 [取数组成员数 (映射文件)] ＝ TEMP
        返回 (TEMP.指针)
    .判断结束
    

.子程序 销毁外部指针, , 公开
    .参数 进程句柄, 整数型
    .参数 外部指针, 整数型
    .局部变量 lRes, 整数型
    .局部变量 dwCount, 整数型
    .局部变量 i, 整数型

    .判断开始 (_WIN32_WINNT ≥ #_WIN32_WINNT_WINXP)
        lRes ＝ VirtualFreeEx (进程句柄, 外部指针, 0, #MEM_RELEASE)
        .如果真 (lRes ＝ 0)
            输出调试文本 (取错误信息文本_API (, ))
        .如果真结束
        
    .默认
        dwCount ＝ 取数组成员数 (映射文件)
        .变量循环首 (dwCount, 1, -1, i)
            .如果真 (映射文件 [i].指针 ＝ 外部指针)
                UnmapViewOfFile (外部指针)
                CloseHandle (映射文件 [i].映射文件号)
                删除成员 (映射文件, i, )
            .如果真结束
            
        .变量循环尾 ()
    .判断结束
    

.子程序 读外部指针数据, 字节集, 公开
    .参数 进程句柄, 整数型
    .参数 外部程序指针, 整数型
    .参数 读取数据大小, 整数型
    .局部变量 pMem, 字节集
    .局部变量 lRes, 逻辑型

    pMem ＝ 取空白字节集 (读取数据大小)
    lRes ＝ ReadProcessMemory_字节集 (进程句柄, 外部程序指针, pMem, 读取数据大小, #NULL)
    .如果真 (lRes ＝ 假)
        输出调试文本 (取错误信息文本_API (, ))
    .如果真结束
    返回 (pMem)

.版本 2

.程序集 外部树型框, , 公开
.程序集变量 m_hItemParent, 长整数型, , "0", 有父项目的句柄组
.程序集变量 集_单一项目, TVITEMEX
.程序集变量 集_树型框项目, TVITEMEX2
.程序集变量 集_外部数据地址1, 整数型
.程序集变量 集_外部数据地址2, 整数型
.程序集变量 集_项目地址, 整数型
.程序集变量 m_hWnd, 整数型
.程序集变量 _数据地址, 整数型, , , 加入项目1 使用，可避免重复使用一些API函数
.程序集变量 _项目, TVINSERTSTRUCT, , , 加入项目1 使用
.程序集变量 _搜索回调Call, 整数型
.程序集变量 m_hProc, 整数型, , , 树型框所在进程的进程句柄, 此值作为判断是否操作外部进程, 操作内部进程此值为0
.程序集变量 m_hItems, 长整数型, , "0", 树型框所有项目句柄
.程序集变量 m_isWow64, 逻辑型, , , 是否运行在Wow64环境下, 为真则进程是32位程序
.程序集变量 m_item, 整数型, , , 项目缓冲区, 所有发送TVITEMEXW结构的都使用这个地址, 包含文本缓冲区
.程序集变量 m_itemSize, 整数型, , , m_item 当前的尺寸, 缓冲区变大时需要重新分配

.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
    集_单一项目.cchTextMax ＝ 260
    集_树型框项目.cchTextMax ＝ 260

.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
    .如果 (m_hProc ≠ 0) ' 原本是外部操作
        .如果真 (m_item ≠ 0) ' 释放旧数据
            VirtualFreeEx (m_hProc, m_item, 0, #MEM_RELEASE)
        .如果真结束
        CloseProc (m_hProc)
    .否则
        
        .如果真 (m_item ≠ 0)
            LocalFree (m_item)
        .如果真结束
        
    .如果结束
    
    m_item ＝ 0
    m_itemSize ＝ 0
    
    清除数组 (m_hItems)

.子程序 初始化, 逻辑型, 公开
    .参数 树型框句柄, 整数型
    .参数 树型框类名, 文本型, 可空
    .参数 是否操作外部控件, 逻辑型, 可空
    .局部变量 项目数, 整数型, 静态
    .局部变量 ret, 逻辑型
    .局部变量 isWow64, 逻辑型
    .局部变量 isTem32, 逻辑型
    .局部变量 currentPid, 整数型
    .局部变量 treePid

    x64Init ()
    
    isTem32 ＝ 系统_是否64位操作系统 () ＝ 假
    m_isWow64 ＝ isTem32
    
    .如果真 (窗口_句柄是否有效 (树型框句柄) ＝ 假)
        返回 (假)
    .如果真结束
    _数据地址 ＝ 0
    
    ' 相同的不再初始化
    .如果真 (m_hWnd ＝ 树型框句柄 且 项目数 ＝ 取项目数 ())
        返回 (真)
    .如果真结束
    
    currentPid ＝ 进程_取自进程ID ()
    treePid ＝ 窗口_句柄取进程ID (树型框句柄)
    是否操作外部控件 ＝ currentPid ≠ treePid
    
    .如果 (是否操作外部控件)
        m_hProc ＝ OpenProc (树型框句柄)
        .如果真 (m_hProc ＝ 0)
            返回 (假)
        .如果真结束
        .如果真 (isTem32 ＝ 假 且 IsWow64Process (m_hProc, m_isWow64) ＝ 假)
            m_isWow64 ＝ 真
        .如果真结束
        
    .否则
        m_isWow64 ＝ 真
    .如果结束
    
    m_hWnd ＝ 树型框句柄
    .如果真 (m_isWow64 ＝ 假)
        输出调试文本 (“不支持x64”)
        返回 (假)
    .如果真结束
    
    内部_遍历句柄 ()
    返回 (真)

.子程序 OpenProc, 整数型, , 打开进程
    .参数 hwnd_or_pid, 整数型
    .局部变量 pid, 整数型

    .判断开始 (IsWindow (hwnd_or_pid) ≠ 0)
        GetWindowThreadProcessId (hwnd_or_pid, pid)
    .默认
        pid ＝ hwnd_or_pid
    .判断结束
    返回 (OpenProcess (#PROCESS_ALL_ACCESS, 0, pid))

.子程序 CloseProc
    .参数 hProc, 整数型, 参考

    .如果真 (hProc ＞ 0)
        CloseHandle (hProc)
    .如果真结束
    hProc ＝ 0

.子程序 make_TVITEMW, 整数型, , TVITEMEXW x64 是80个字节, x86是60个字节, 这里只设置TVITEM结构, 返回文本缓冲区地址
    .参数 mask, 整数型, , +0  +0
    .参数 hItem, 长整数型, , +4  +8
    .参数 state, 整数型, 可空, +8  +16
    .参数 stateMask, 整数型, 可空, +12 +20
    .参数 cchTextMax, 整数型, 可空, +20 +32  缓冲区设置大小就有, 为0表示不使用缓冲区
    .参数 iImage, 整数型, 可空, +24 +36
    .参数 iSelectedImage, 整数型, 可空, +28 +40
    .参数 cChildren, 整数型, 可空, +32 +44
    .参数 lParam, 长整数型, 可空, +36 +48
    .参数 iIntegral, 整数型, 可空, +40 +56
    .参数 uStateEx, 整数型, 可空, +44 +60
    .参数 hwnd, 长整数型, 可空, +48 +64  必须为NULL
    .参数 iExpandedImage, 整数型, 可空, +52 +72  当项目处于展开状态时要显示的控件图像列表中图像的索引
    .参数 hParent, 长整数型, 可空, -8 -16
    .参数 hInsertAfter, 长整数型, 可空, -4 -8
    .局部变量 pszText, 整数型, , , +16 +24
    .局部变量 len, 整数型
    .局部变量 iReserved, 整数型, , , +56 +76

    len ＝ 4096
    .判断开始 (m_hProc ≠ 0) ' 外部进程
        .如果真 (cchTextMax ＋ 80 ＞ len)
            len ＝ cchTextMax ＋ 80
            len ＝ len ＼ (4096 × 4096) ＋ 选择 (len ％ 4096 ≠ 0, 4096, 0) ' 4k对齐
        .如果真结束
        
        .如果真 (len ＞ m_itemSize) ' 新的缓冲区比旧的大, 重新分配内存
            .如果真 (m_itemSize ≠ 0 且 m_item ≠ 0)
                VirtualFreeEx (m_hProc, m_item, 0, #MEM_RELEASE)
            .如果真结束
            m_itemSize ＝ len
            m_item ＝ VirtualAllocEx (m_hProc, 0, m_itemSize, #MEM_COMMIT, #PAGE_READWRITE)
            .如果真 (m_item ＝ 0)
                m_itemSize ＝ 0
                返回 (0)
            .如果真结束
            
            m_item ＝ m_item ＋ 16
        .如果真结束
        
        pszText ＝ m_item ＋ 80
        .判断开始 (m_isWow64)
            WriteProcessMemory_整数3 (m_hProc, m_item ＋ 0, mask, 4, 0)
            WriteProcessMemory_整数3 (m_hProc, m_item ＋ 4, hItem, 4, 0)
            
            .如果真 (取反 (是否为空 (hParent)))
                WriteProcessMemory_整数3 (m_hProc, m_item － 8, mask, 4, 0)
            .如果真结束
            .如果真 (取反 (是否为空 (hInsertAfter)))
                WriteProcessMemory_整数3 (m_hProc, m_item － 4, mask, 4, 0)
            .如果真结束
            .如果真 (取反 (是否为空 (state)))
                WriteProcessMemory_整数3 (m_hProc, m_item ＋ 8, state, 4, 0)
            .如果真结束
            .如果真 (取反 (是否为空 (stateMask)))
                WriteProcessMemory_整数3 (m_hProc, m_item ＋ 12, stateMask, 4, 0)
            .如果真结束
            .如果真 (取反 (是否为空 (cchTextMax)))
                WriteProcessMemory_整数3 (m_hProc, m_item ＋ 16, pszText, 4, 0)
                WriteProcessMemory_整数3 (m_hProc, m_item ＋ 20, cchTextMax, 4, 0)
            .如果真结束
            .如果真 (取反 (是否为空 (iImage)))
                WriteProcessMemory_整数3 (m_hProc, m_item ＋ 24, iImage, 4, 0)
            .如果真结束
            .如果真 (取反 (是否为空 (iSelectedImage)))
                WriteProcessMemory_整数3 (m_hProc, m_item ＋ 28, iSelectedImage, 4, 0)
            .如果真结束
            .如果真 (取反 (是否为空 (cChildren)))
                WriteProcessMemory_整数3 (m_hProc, m_item ＋ 32, cChildren, 4, 0)
            .如果真结束
            .如果真 (取反 (是否为空 (lParam)))
                WriteProcessMemory_整数3 (m_hProc, m_item ＋ 36, lParam, 4, 0)
            .如果真结束
            .如果真 (取反 (是否为空 (iIntegral)))
                WriteProcessMemory_整数3 (m_hProc, m_item ＋ 40, iIntegral, 4, 0)
            .如果真结束
            .如果真 (取反 (是否为空 (uStateEx)))
                WriteProcessMemory_整数3 (m_hProc, m_item ＋ 44, uStateEx, 4, 0)
            .如果真结束
            .如果真 (取反 (是否为空 (hwnd)))
                WriteProcessMemory_整数3 (m_hProc, m_item ＋ 48, hwnd, 4, 0)
            .如果真结束
            .如果真 (取反 (是否为空 (iExpandedImage)))
                WriteProcessMemory_整数3 (m_hProc, m_item ＋ 52, iExpandedImage, 4, 0)
            .如果真结束
            
        .默认
            
            WriteProcessMemory_整数3 (m_hProc, m_item ＋ 0, mask, 4, 0)
            WriteProcessMemory_整数型 (m_hProc, m_item ＋ 8, 取指针_通用型 (hItem), 8, 0)
            .如果真 (取反 (是否为空 (hParent)))
                WriteProcessMemory_整数型 (m_hProc, m_item － 16, 取指针_通用型 (hParent), 8, 0)
            .如果真结束
            .如果真 (取反 (是否为空 (hInsertAfter)))
                WriteProcessMemory_整数型 (m_hProc, m_item － 8, 取指针_通用型 (hInsertAfter), 8, 0)
            .如果真结束
            .如果真 (取反 (是否为空 (state)))
                WriteProcessMemory_整数3 (m_hProc, m_item ＋ 16, state, 4, 0)
            .如果真结束
            .如果真 (取反 (是否为空 (stateMask)))
                WriteProcessMemory_整数3 (m_hProc, m_item ＋ 20, stateMask, 4, 0)
            .如果真结束
            .如果真 (取反 (是否为空 (cchTextMax)))
                WriteProcessMemory_整数3 (m_hProc, m_item ＋ 24, pszText, 4, 0) ' 这里申请的是32位的内存, 所以不需要拷贝8个字节
                WriteProcessMemory_整数3 (m_hProc, m_item ＋ 32, cchTextMax, 4, 0)
            .如果真结束
            .如果真 (取反 (是否为空 (iImage)))
                WriteProcessMemory_整数3 (m_hProc, m_item ＋ 36, iImage, 4, 0)
            .如果真结束
            .如果真 (取反 (是否为空 (iSelectedImage)))
                WriteProcessMemory_整数3 (m_hProc, m_item ＋ 40, iSelectedImage, 4, 0)
            .如果真结束
            .如果真 (取反 (是否为空 (cChildren)))
                WriteProcessMemory_整数3 (m_hProc, m_item ＋ 44, cChildren, 4, 0)
            .如果真结束
            .如果真 (取反 (是否为空 (lParam)))
                WriteProcessMemory_整数型 (m_hProc, m_item ＋ 48, 取指针_通用型 (lParam), 8, 0)
            .如果真结束
            .如果真 (取反 (是否为空 (iIntegral)))
                WriteProcessMemory_整数3 (m_hProc, m_item ＋ 56, iIntegral, 4, 0)
            .如果真结束
            .如果真 (取反 (是否为空 (uStateEx)))
                WriteProcessMemory_整数3 (m_hProc, m_item ＋ 60, uStateEx, 4, 0)
            .如果真结束
            .如果真 (取反 (是否为空 (hwnd)))
                WriteProcessMemory_整数3 (m_hProc, m_item ＋ 64, hwnd, 4, 0)
            .如果真结束
            .如果真 (取反 (是否为空 (iExpandedImage)))
                WriteProcessMemory_整数3 (m_hProc, m_item ＋ 72, iExpandedImage, 4, 0)
            .如果真结束
            
            
        .判断结束
        
    .默认
        ' 内部进程直接申请内存, 内部进程只有32位, 所以没必要处理64位的
        .如果真 (len ＞ m_itemSize) ' 新的缓冲区比旧的大, 重新分配内存
            .如果真 (m_itemSize ≠ 0 且 m_item ≠ 0)
                LocalFree (m_item)
            .如果真结束
            m_itemSize ＝ len
            m_item ＝ LocalAlloc (#LMEM_ZEROINIT, m_itemSize)
            .如果真 (m_item ＝ 0)
                m_itemSize ＝ 0
                返回 (0)
            .如果真结束
            m_item ＝ m_item ＋ 16
        .如果真结束
        
        pszText ＝ m_item ＋ 80
        __set (m_item, 0, mask)
        __set (m_item, 4, hItem)
        
        .如果真 (取反 (是否为空 (hParent)))
            __set (m_item － 8, 0, hParent)
        .如果真结束
        .如果真 (取反 (是否为空 (hInsertAfter)))
            __set (m_item － 4, 8, hInsertAfter)
        .如果真结束
        .如果真 (取反 (是否为空 (state)))
            __set (m_item, 8, state)
        .如果真结束
        .如果真 (取反 (是否为空 (stateMask)))
            __set (m_item, 12, stateMask)
        .如果真结束
        .如果真 (取反 (是否为空 (cchTextMax)))
            __set (m_item, 16, pszText)
            __set (m_item, 20, cchTextMax)
        .如果真结束
        .如果真 (取反 (是否为空 (iImage)))
            __set (m_item, 24, iImage)
        .如果真结束
        .如果真 (取反 (是否为空 (iSelectedImage)))
            __set (m_item, 28, iSelectedImage)
        .如果真结束
        .如果真 (取反 (是否为空 (cChildren)))
            __set (m_item, 32, cChildren)
        .如果真结束
        .如果真 (取反 (是否为空 (lParam)))
            __set (m_item, 36, lParam)
        .如果真结束
        .如果真 (取反 (是否为空 (iIntegral)))
            __set (m_item, 40, iIntegral)
        .如果真结束
        .如果真 (取反 (是否为空 (uStateEx)))
            __set (m_item, 44, uStateEx)
        .如果真结束
        .如果真 (取反 (是否为空 (hwnd)))
            __set (m_item, 48, hwnd)
        .如果真结束
        .如果真 (取反 (是否为空 (iExpandedImage)))
            __set (m_item, 52, iExpandedImage)
        .如果真结束
        
    .判断结束
    返回 (m_item)

.子程序 __SendMsgW, 长整数型
    .参数 message, 整数型
    .参数 wParam, 长整数型
    .参数 lParam, 长整数型

    返回 (SendMessageW (m_hWnd, message, wParam, lParam))
    ' .如果真 (m_isWow64)
        ' 返回 (SendMessageW (m_hWnd, message, wParam, lParam))
    ' .如果真结束
    ' 返回 (SendMsgW (m_hWnd, message, wParam, lParam))

.子程序 __SendMsgA, 长整数型
    .参数 message, 整数型
    .参数 wParam, 长整数型
    .参数 lParam, 长整数型

    .如果真 (m_isWow64)
        返回 (SendMessageA (m_hWnd, message, wParam, lParam))
    .如果真结束
    返回 (SendMsgA (m_hWnd, message, wParam, lParam))

.子程序 write_Text, 逻辑型, , Unicode格式
    .参数 text, 字节集
    .局部变量 len, 整数型
    .局部变量 offset, 整数型

    .如果真 (m_item ＝ 0)
        返回 (假)
    .如果真结束
    offset ＝ 80 ' 不管x86或x64文本缓冲区都是指针加80
    len ＝ lstrlenW (取指针_字节集型 (text)) × 2 ＋ 2
    .判断开始 (m_hProc ≠ 0) ' 外部
        返回 (WriteProcessMemory_字节集 (m_hProc, m_item ＋ offset, text, len, 0))
    .默认
        RtlMoveMemory (m_item ＋ offset, 取指针_字节集型 (text), len)
    .判断结束
    返回 (真)

.子程序 read_Text, 字节集, , 从缓冲区里读取文本, Unicode格式
    .参数 size, 整数型, 可空, 读出长度, 为空则读取2000个字节
    .局部变量 ret, 字节集
    .局部变量 len, 整数型
    .局部变量 offset, 整数型

    .如果真 (m_item ＝ 0)
        返回 ({ })
    .如果真结束
    offset ＝ 80 ' 不管x86或x64文本缓冲区都是指针加80
    .如果真 (size ＝ 0)
        size ＝ 2000
    .如果真结束
    
    .判断开始 (m_hProc ≠ 0) ' 外部
        ret ＝ 取空白字节集 (size)
        ReadProcessMemory_字节集 (m_hProc, m_item ＋ offset, ret, size, 0)
    .默认
        ret ＝ 指针到字节集 (m_item ＋ offset, size)
    .判断结束
    len ＝ lstrlenW (取指针_字节集型 (ret)) × 2 ＋ 2
    .如果真 (len ＝ size)
        返回 (ret)
    .如果真结束
    .如果真 (len ＞ size)
        len ＝ size
    .如果真结束
    返回 (取字节集左边 (ret, len))

.子程序 read_State, 整数型, , 从缓冲区里取出当前状态
    .局部变量 offset, 整数型
    .局部变量 ret, 字节集

    .如果真 (m_item ＝ 0)
        返回 (0)
    .如果真结束
    offset ＝ 选择 (m_isWow64, 8, 16) ' 32位和64位偏移不一样
    .判断开始 (m_hProc ≠ 0) ' 外部
        ret ＝ 取空白字节集 (4)
        ReadProcessMemory_字节集 (m_hProc, m_item ＋ offset, ret, 4, 0)
    .默认
        ret ＝ 指针到字节集 (m_item ＋ offset, 4)
    .判断结束
    返回 (取字节集数据 (ret, #整数型, ))

.子程序 read_StateMask, 整数型, , 从缓冲区里取出当前状态
    .局部变量 offset, 整数型
    .局部变量 ret, 字节集

    .如果真 (m_item ＝ 0)
        返回 (0)
    .如果真结束
    offset ＝ 选择 (m_isWow64, 12, 20) ' 32位和64位偏移不一样
    .判断开始 (m_hProc ≠ 0) ' 外部
        ret ＝ 取空白字节集 (4)
        ReadProcessMemory_字节集 (m_hProc, m_item ＋ offset, ret, 4, 0)
    .默认
        ret ＝ 指针到字节集 (m_item ＋ offset, 4)
    .判断结束
    返回 (取字节集数据 (ret, #整数型, ))

.子程序 read_Image, 整数型, , 从缓冲区里取出当前状态
    .局部变量 offset, 整数型
    .局部变量 ret, 字节集

    .如果真 (m_item ＝ 0)
        返回 (0)
    .如果真结束
    offset ＝ 选择 (m_isWow64, 24, 36) ' 32位和64位偏移不一样
    .判断开始 (m_hProc ≠ 0) ' 外部
        ret ＝ 取空白字节集 (4)
        ReadProcessMemory_字节集 (m_hProc, m_item ＋ offset, ret, 4, 0)
    .默认
        ret ＝ 指针到字节集 (m_item ＋ offset, 4)
    .判断结束
    返回 (取字节集数据 (ret, #整数型, ))

.子程序 read_SelectedImage, 整数型, , 从缓冲区里取出当前状态
    .局部变量 offset, 整数型
    .局部变量 ret, 字节集

    .如果真 (m_item ＝ 0)
        返回 (0)
    .如果真结束
    offset ＝ 选择 (m_isWow64, 28, 40) ' 32位和64位偏移不一样
    .判断开始 (m_hProc ≠ 0) ' 外部
        ret ＝ 取空白字节集 (4)
        ReadProcessMemory_字节集 (m_hProc, m_item ＋ offset, ret, 4, 0)
    .默认
        ret ＝ 指针到字节集 (m_item ＋ offset, 4)
    .判断结束
    返回 (取字节集数据 (ret, #整数型, ))

.子程序 read_Children, 整数型, , 从缓冲区里取出当前状态
    .局部变量 offset, 整数型
    .局部变量 ret, 字节集

    .如果真 (m_item ＝ 0)
        返回 (0)
    .如果真结束
    offset ＝ 选择 (m_isWow64, 32, 44) ' 32位和64位偏移不一样
    .判断开始 (m_hProc ≠ 0) ' 外部
        ret ＝ 取空白字节集 (4)
        ReadProcessMemory_字节集 (m_hProc, m_item ＋ offset, ret, 4, 0)
    .默认
        ret ＝ 指针到字节集 (m_item ＋ offset, 4)
    .判断结束
    返回 (取字节集数据 (ret, #整数型, ))

.子程序 read_Param, 长整数型, , 从缓冲区里取出当前状态
    .局部变量 offset, 整数型
    .局部变量 ret, 字节集

    .如果真 (m_item ＝ 0)
        返回 (0)
    .如果真结束
    offset ＝ 选择 (m_isWow64, 36, 48) ' 32位和64位偏移不一样
    .如果真 (m_hProc ≠ 0) ' 外部
        ret ＝ 取空白字节集 (8)
        ReadProcessMemory_字节集 (m_hProc, m_item ＋ offset, ret, 8, 0)
        返回 (取字节集数据 (ret, #长整数型, ))
    .如果真结束
    
    ret ＝ 指针到字节集 (m_item ＋ offset, 4)
    返回 (取字节集数据 (ret, #整数型, ))

.子程序 read_Integral, 整数型, , 项目的高度
    .局部变量 offset, 整数型
    .局部变量 ret, 字节集

    .如果真 (m_item ＝ 0)
        返回 (0)
    .如果真结束
    offset ＝ 选择 (m_isWow64, 40, 56) ' 32位和64位偏移不一样
    .如果真 (m_hProc ≠ 0) ' 外部
        ret ＝ 取空白字节集 (4)
        ReadProcessMemory_字节集 (m_hProc, m_item ＋ offset, ret, 4, 0)
        返回 (取字节集数据 (ret, #整数型, ))
    .如果真结束
    
    ret ＝ 指针到字节集 (m_item ＋ offset, 4)
    返回 (取字节集数据 (ret, #整数型, ))

.子程序 read_StateEx, 整数型, , 扩展状态中的一个或多个（按位组合）
    .局部变量 offset, 整数型
    .局部变量 ret, 字节集

    .如果真 (m_item ＝ 0)
        返回 (0)
    .如果真结束
    offset ＝ 选择 (m_isWow64, 44, 60) ' 32位和64位偏移不一样
    .如果真 (m_hProc ≠ 0) ' 外部
        ret ＝ 取空白字节集 (4)
        ReadProcessMemory_字节集 (m_hProc, m_item ＋ offset, ret, 4, 0)
        返回 (取字节集数据 (ret, #整数型, ))
    .如果真结束
    
    ret ＝ 指针到字节集 (m_item ＋ offset, 4)
    返回 (取字节集数据 (ret, #整数型, ))

.子程序 read_hwnd, 长整数型, , 必须为NULL
    .局部变量 offset, 整数型
    .局部变量 ret, 字节集

    .如果真 (m_item ＝ 0)
        返回 (0)
    .如果真结束
    offset ＝ 选择 (m_isWow64, 48, 64) ' 32位和64位偏移不一样
    .如果真 (m_hProc ≠ 0) ' 外部
        ret ＝ 取空白字节集 (8)
        ReadProcessMemory_字节集 (m_hProc, m_item ＋ offset, ret, 8, 0)
        返回 (取字节集数据 (ret, #长整数型, ))
    .如果真结束
    
    ret ＝ 指针到字节集 (m_item ＋ offset, 4)
    返回 (取字节集数据 (ret, #整数型, ))

.子程序 read_ExpandedImage, 整数型, , 当项目处于展开状态时要显示的控件图像列表中图像的索引
    .局部变量 offset, 整数型
    .局部变量 ret, 字节集

    .如果真 (m_item ＝ 0)
        返回 (0)
    .如果真结束
    offset ＝ 选择 (m_isWow64, 52, 72) ' 32位和64位偏移不一样
    .如果真 (m_hProc ≠ 0) ' 外部
        ret ＝ 取空白字节集 (4)
        ReadProcessMemory_字节集 (m_hProc, m_item ＋ offset, ret, 4, 0)
        返回 (取字节集数据 (ret, #整数型, ))
    .如果真结束
    
    ret ＝ 指针到字节集 (m_item ＋ offset, 4)
    返回 (取字节集数据 (ret, #整数型, ))

.子程序 取项目数, 整数型, 公开, 返回树型框中所有项目的数目。
    返回 (__SendMsgW (#TVM_GETCOUNT, 0, 0))

.子程序 取项目句柄数组, 整数型, 公开
    .参数 句柄组, 长整数型, 参考 数组

    句柄组 ＝ m_hItems
    返回 (取数组成员数 (句柄组))

.子程序 取缩进层次, 整数型, 公开, 返回指定项目所处缩进层次，层次值从1开始。如果未找到指定项目，返回 0 。
    .参数 项目索引, 整数型, , 0 为项目一，1 为项目二，如此类推。

    .如果真 (项目索引 ＋ 1 ＞ 取数组成员数 (m_hItems) 或 项目索引 ＜ 0)
        返回 (0)
    .如果真结束
    返回 (取缩进层次_句柄 (m_hItems [项目索引 ＋ 1]))

.子程序 取缩进层次_句柄, 整数型, 公开
    .参数 项目句柄, 长整数型
    .局部变量 父项目, 长整数型
    .局部变量 层次, 整数型

    层次 ＝ 1
    父项目 ＝ __SendMsgW (#TVM_GETNEXTITEM, 3, 项目句柄)
    .判断循环首 (父项目 ≠ 0)
        父项目 ＝ __SendMsgW (#TVM_GETNEXTITEM, 3, 父项目)
        层次 ＝ 层次 ＋ 1
    .判断循环尾 ()
    返回 (层次)

.子程序 取项目文本, 文本型, 公开, 返回指定项目的文本。如果该项目不存在，将返回空文本。
    .参数 项目索引, 整数型, , 0 为项目一，1 为项目二，如此类推。

    .如果真 (项目索引 ＋ 1 ＞ 取数组成员数 (m_hItems) 或 项目索引 ＜ 0)
        返回 (“”)
    .如果真结束
    返回 (取项目文本_句柄 (m_hItems [项目索引 ＋ 1]))

.子程序 取项目文本W, 字节集, 公开, 返回指定项目的文本。如果该项目不存在，将返回空文本。
    .参数 项目索引, 整数型, , 0 为项目一，1 为项目二，如此类推。

    .如果真 (项目索引 ＋ 1 ＞ 取数组成员数 (m_hItems) 或 项目索引 ＜ 0)
        返回 ({ })
    .如果真结束
    返回 (取项目文本_句柄W (m_hItems [项目索引 ＋ 1]))

.子程序 取项目文本_句柄W, 字节集, 公开
    .参数 项目句柄, 长整数型

    .如果真 (项目句柄 ＝ 0)
        返回 ({ })
    .如果真结束
    make_TVITEMW (#TVIF_TEXT, 项目句柄, , , 2000, , , , , , , , , , )
    __SendMsgW (#TVM_GETITEMW, 0, m_item)
    返回 (read_Text (2000))

.子程序 取项目文本_句柄, 文本型, 公开
    .参数 项目句柄, 长整数型

    返回 (编码_Unicode到Ansi (取项目文本_句柄W (项目句柄)))

.子程序 取图片, 整数型, 公开, 返回指定项目的图片索引。如果该项目不存在，将返回 -1 
    .参数 项目索引, 整数型, , 0 为项目一，1 为项目二，如此类推。

    .如果真 (项目索引 ＋ 1 ＞ 取数组成员数 (m_hItems) 或 项目索引 ＜ 0)
        返回 (-1)
    .如果真结束
    返回 (取图片_句柄 (m_hItems [项目索引 ＋ 1]))

.子程序 取图片_句柄, 整数型, 公开
    .参数 项目句柄, 长整数型

    .如果真 (项目句柄 ＝ 0)
        返回 (0)
    .如果真结束
    make_TVITEMW (#TVIF_IMAGE, 项目句柄, , , , , , , , , , , , , )
    __SendMsgW (#TVM_GETITEMW, 0, m_item)
    返回 (read_Image ())

.子程序 取选中图片, 整数型, 公开, 返回指定项目被选中后的图片索引。如果该项目不存在，将返回 -1 。
    .参数 项目索引, 整数型, , 0 为项目一，1 为项目二，如此类推。

    .如果真 (项目索引 ＋ 1 ＞ 取数组成员数 (m_hItems) 或 项目索引 ＜ 0)
        返回 (-1)
    .如果真结束
    make_TVITEMW (#TVIF_SELECTEDIMAGE, m_hItems [项目索引 ＋ 1], , , , , , , , , , , , , )
    __SendMsgW (#TVM_GETITEMW, 0, m_item)
    返回 (read_SelectedImage ())

.子程序 取项目数值, 整数型, 公开, 返回与指定项目相关联的数值。如果该项目不存在，将返回 0 。
    .参数 项目索引, 整数型, , 0 为项目一，1 为项目二，如此类推。

    .如果真 (项目索引 ＋ 1 ＞ 取数组成员数 (m_hItems) 或 项目索引 ＜ 0)
        返回 (-1)
    .如果真结束
    返回 (取项目数值_句柄 (m_hItems [项目索引 ＋ 1]))

.子程序 取项目数值_句柄, 整数型, 公开, 返回与指定项目相关联的数值。如果该项目不存在，将返回 0 。
    .参数 项目句柄, 长整数型, , 0 为项目一，1 为项目二，如此类推。

    .如果真 (项目句柄 ＝ 0)
        返回 (0)
    .如果真结束
    make_TVITEMW (#TVIF_PARAM, 项目句柄, , , , , , , , , , , , , )
    __SendMsgW (#TVM_GETITEMW, 0, m_item)
    返回 (read_Param ())

.子程序 置图片, 逻辑型, 公开, 设置在指定项目首部所显示图片的索引。成功返回真，失败返回假。
    .参数 项目索引, 整数型, , 0 为项目一，1 为项目二，如此类推。
    .参数 图片索引, 整数型, , 图片索引用于指定图片组属性中的某张图片，从 0 开始。

    .如果真 (项目索引 ＋ 1 ＞ 取数组成员数 (m_hItems) 或 项目索引 ＜ 0)
        返回 (假)
    .如果真结束
    make_TVITEMW (#TVIF_IMAGE, m_hItems [项目索引 ＋ 1], , , , 图片索引, , , , , , , , , )
    返回 (__SendMsgW (#TVM_SETITEMW, 0, m_item) ≠ 0)

.子程序 置选中图片, 逻辑型, 公开, 设置指定项目被选中后所显示图片的索引。成功返回真，失败返回假。
    .参数 项目索引, 整数型, , 0 为项目一，1 为项目二，如此类推。
    .参数 图片索引, 整数型, , 图片索引用于指定图片组属性中的某张图片，从 0 开始。

    .如果真 (项目索引 ＋ 1 ＞ 取数组成员数 (m_hItems) 或 项目索引 ＜ 0)
        返回 (假)
    .如果真结束
    make_TVITEMW (#TVIF_SELECTEDIMAGE, m_hItems [项目索引 ＋ 1], , , , , 图片索引, , , , , , , , )
    返回 (__SendMsgW (#TVM_SETITEMW, 0, m_item) ≠ 0)

.子程序 置项目数值, 逻辑型, 公开, 设置与指定项目相关联的数值。成功返回真，失败返回假。
    .参数 项目索引, 整数型, , 0 为项目一，1 为项目二，如此类推。
    .参数 欲置入的项目数值, 整数型, 可空, 可以被省略。该数值与指定项目相关联。如果本参数被省略，默认值为 0 。

    .如果真 (项目索引 ＋ 1 ＞ 取数组成员数 (m_hItems) 或 项目索引 ＜ 0)
        返回 (假)
    .如果真结束
    make_TVITEMW (#TVIF_PARAM, m_hItems [项目索引 ＋ 1], , , , , , , 欲置入的项目数值, , , , , , )
    返回 (__SendMsgW (#TVM_SETITEMW, 0, m_item) ≠ 0)

.子程序 置项目文本W, 逻辑型, 公开, 设置指定项目的文本。成功返回真，失败返回假。
    .参数 项目索引, 整数型, , 0 为项目一，1 为项目二，如此类推。
    .参数 欲置入的项目文本, 字节集

    .如果真 (项目索引 ＋ 1 ＞ 取数组成员数 (m_hItems) 或 项目索引 ＜ 0)
        返回 (假)
    .如果真结束
    write_Text (欲置入的项目文本)
    make_TVITEMW (#TVIF_TEXT, m_hItems [项目索引 ＋ 1], , , 4000, , , , , , , , , , )
    返回 (__SendMsgW (#TVM_SETITEMW, 0, m_item) ≠ 0)

.子程序 置项目文本, 逻辑型, 公开, 设置指定项目的文本。成功返回真，失败返回假。
    .参数 项目索引, 整数型, , 0 为项目一，1 为项目二，如此类推。
    .参数 欲置入的项目文本, 文本型

    返回 (置项目文本W (项目索引, 编码_Ansi到Unicode (欲置入的项目文本, )))

.子程序 保证显示, , 公开
    .参数 项目索引, 整数型, , 0 为项目一，1 为项目二，如此类推。

    .如果真 (项目索引 ＋ 1 ＞ 取数组成员数 (m_hItems) 或 项目索引 ＜ 0)
        返回 ()
    .如果真结束
    保证显示_句柄 (m_hItems [项目索引 ＋ 1])

.子程序 保证显示_句柄, , 公开
    .参数 项目句柄, 长整数型, , 0 为项目一，1 为项目二，如此类推。

    __SendMsgW (#TVM_ENSUREVISIBLE, 0, 项目句柄)

.子程序 扩展, , 公开, 将指打开指定项目的下属分枝。
    .参数 项目索引, 整数型, , 0 为项目一，1 为项目二，如此类推。

    .判断开始 (项目索引 ＞ 99999) ' 如果大于9w，表示传进来的是句柄
        __SendMsgW (#TVM_EXPAND, #TVE_EXPAND, 项目索引)
    .判断 (项目索引 ＋ 1 ≤ 取数组成员数 (m_hItems) 且 项目索引 ≥ 0)
        __SendMsgW (#TVM_EXPAND, #TVE_EXPAND, m_hItems [项目索引 ＋ 1])
    .默认
        
    .判断结束
    

.子程序 扩展全部, , 公开
    .参数 不扩展第一项, 逻辑型, 可空
    .局部变量 i, 整数型

    .如果真 (取数组成员数 (m_hItemParent) ＝ 0)
        内部_遍历句柄_父项目 ()
    .如果真结束
    .计次循环首 (取数组成员数 (m_hItemParent), i)
        .如果真 (不扩展第一项 且 i ＝ 1)
            到循环尾 ()
        .如果真结束
        __SendMsgW (#TVM_EXPAND, #TVE_EXPAND, m_hItemParent [i])
    .计次循环尾 ()

.子程序 收缩, , 公开, 缩回指定项目的下属分枝。
    .参数 项目索引, 整数型, , 0 为项目一，1 为项目二，如此类推。

    .如果真 (项目索引 ＋ 1 ≤ 取数组成员数 (m_hItems) 且 项目索引 ≥ 0)
        .判断开始 (项目索引 ＞ 99999) ' 如果大于9w，表示传进来的是句柄
            __SendMsgW (#TVM_EXPAND, #TVE_COLLAPSE, 项目索引)
        .默认
            __SendMsgW (#TVM_EXPAND, #TVE_COLLAPSE, m_hItems [项目索引 ＋ 1])
        .判断结束
        
    .如果真结束
    

.子程序 收缩全部, , 公开
    .局部变量 i, 整数型

    .如果真 (取数组成员数 (m_hItemParent) ＝ 0)
        内部_遍历句柄_父项目 ()
    .如果真结束
    .计次循环首 (取数组成员数 (m_hItemParent), i)
        .如果真 (i ＝ 1)
            到循环尾 ()
        .如果真结束
        __SendMsgW (#TVM_EXPAND, #TVE_COLLAPSE, m_hItemParent [i])
    .计次循环尾 ()

.子程序 强制刷新, , 公开
    内部_遍历句柄 ()

.子程序 排序, , 公开
    .参数 排序1级缩进, 逻辑型, 可空, 是否排序缩进层次为1的，可空为不排序。
    .参数 排序指定层次, 整数型, 可空, 可空，0=全部排序(默认)，排序大于为等于此值的缩进层次，如：2，将排序缩进层次≥2的项目，-1=不排序
    .局部变量 i, 整数型

    .如果真 (取数组成员数 (m_hItemParent) ＝ 0)
        内部_遍历句柄_父项目 ()
    .如果真结束
    
    .如果真 (排序1级缩进)
        __SendMsgW (#TVM_SORTCHILDREN, 0, 0)
    .如果真结束
    
    .如果真 (排序指定层次 ＝ -1)
        返回 ()
    .如果真结束
    
    .计次循环首 (取数组成员数 (m_hItemParent), i)
        .如果 (排序指定层次 ＞ 0)
            .如果真 (取缩进层次 (i) ≥ 排序指定层次)
                __SendMsgW (#TVM_SORTCHILDREN, 0, m_hItemParent [i])
            .如果真结束
            
        .否则
            ' 全部排序
            __SendMsgW (#TVM_SORTCHILDREN, 0, m_hItemParent [i])
        .如果结束
        
    .计次循环尾 ()

.子程序 排序_句柄, , 公开
    .参数 项目句柄, 长整数型

    __SendMsgW (#TVM_SORTCHILDREN, 0, 项目句柄)

.子程序 加入项目, 整数型, 公开, 将单个或一批项目加入到树型框中，如果仅加入一个项目，成功返回加入后该项目所处的位置，失败返回 -1 。如果成批加入项目，成功返回 0 ，失败返回 -1 。成批加入项目可以用作一次性快速加入大量项目到树型框中。
    .参数 父项目索引, 整数型, 可空, 可以被省略。指定欲加入项目所处的父项目，0 为项目一，1 为项目二，如此类推。如果没有父项目（即欲加入项目为顶层项目），请提供值 -1 。如果本参数被省略，默认值为 -1 。
    .参数 项目数据1, 项目数据, 可空, 用于只加入一个项目，如欲批量加入，请留空
    .参数 项目数据2, 项目数据, 可空 数组, 用于批量加入项目
    .参数 加入方式, 整数型, 可空, 可以被省略。默认为 3
    .参数 加入完成后是否排序, 逻辑型, 可空
    .局部变量 成员数, 整数型
    .局部变量 计次, 整数型
    .局部变量 数据地址, 整数型
    .局部变量 插入项目, TVINSERTSTRUCT
    .局部变量 插入项目2, TVINSERTSTRUCT2
    .局部变量 当前项目, 整数型
    .局部变量 空白数据, 字节集
    .局部变量 项目句柄, 长整数型
    .局部变量 返回句柄, 长整数型

    .判断开始 (父项目索引 ＞ 99999) ' 如果大于9w，表示传进来的是句柄
        连续赋值 (父项目索引, 插入项目.hParent, 插入项目2.hParent)
        
    .判断 (是否为空 (父项目索引) ＝ 假 且 父项目索引 ＋ 1 ≤ 取数组成员数 (m_hItems) 且 父项目索引 ≥ 0)
        连续赋值 (m_hItems [父项目索引 ＋ 1], 插入项目.hParent, 插入项目2.hParent)
    .默认
        
    .判断结束
    
    .如果真 (是否为空 (加入方式) 或 加入方式 ＞ 4 或 加入方式 ＜ 1)
        加入方式 ＝ 3
    .如果真结束
    
    .判断开始 (是否为空 (项目数据1) ＝ 假)
        插入项目.hInsertAfter ＝ 多项选择 (加入方式, #TVI_ROOT, #TVI_FIRST, #TVI_LAST, #TVI_SORT)
        插入项目.pszText ＝ 项目数据1.项目文本
        插入项目.iImage ＝ 项目数据1.图片索引
        插入项目.iSelectedImage ＝ 项目数据1.选中图片索引
        插入项目.lParam ＝ 项目数据1.项目数值
        插入项目.mask ＝ #TVIF_ALL
        数据地址 ＝ 取内存变量地址_TVINSERTSTRUCT (插入项目, 插入项目, 0)
        返回句柄 ＝ __SendMsgW (#TVM_INSERTITEMA, 0, 数据地址)
        加入成员 (m_hItems, 返回句柄) ' 将返回句柄加入数组
        返回 (返回句柄)
    .判断 (是否为空 (项目数据2) ＝ 假)
        __SendMsgW (#WM_SETREDRAW, 0, 0) ' 是否使用高速插入
        .判断开始 (加入方式 ＝ 2)
            计次 ＝ 成员数
            .判断循环首 (计次 ＞ 0)
                插入项目.hInsertAfter ＝ 多项选择 (加入方式, #TVI_ROOT, #TVI_FIRST, #TVI_LAST, #TVI_SORT)
                插入项目.mask ＝ #TVIF_ALL
                插入项目.pszText ＝ 项目数据2 [计次].项目文本
                插入项目.iImage ＝ 项目数据2 [计次].图片索引
                插入项目.iSelectedImage ＝ 项目数据2 [计次].选中图片索引
                插入项目.lParam ＝ 项目数据2 [计次].项目数值
                数据地址 ＝ 取内存变量地址_TVINSERTSTRUCT (插入项目, 插入项目, 0)
                __SendMsgW (#TVM_INSERTITEMA, 0, 数据地址)
                计次 ＝ 计次 － 1
            .判断循环尾 ()
            
        .默认
            成员数 ＝ 取数组成员数 (项目数据2)
            .判断循环首 (计次 ＜ 成员数)
                计次 ＝ 计次 ＋ 1
                插入项目.hInsertAfter ＝ 多项选择 (加入方式, #TVI_ROOT, #TVI_FIRST, #TVI_LAST, #TVI_SORT)
                插入项目.mask ＝ #TVIF_ALL
                插入项目.pszText ＝ 项目数据2 [计次].项目文本
                插入项目.iImage ＝ 项目数据2 [计次].图片索引
                插入项目.iSelectedImage ＝ 项目数据2 [计次].选中图片索引
                插入项目.lParam ＝ 项目数据2 [计次].项目数值
                数据地址 ＝ 取内存变量地址_TVINSERTSTRUCT (插入项目, 插入项目, 0)
                项目数据2 [计次].项目句柄 ＝ __SendMsgW (#TVM_INSERTITEMA, 0, 数据地址)
                .如果真 (项目数据2 [计次].是否加粗)
                    加粗_句柄 (项目数据2 [计次].项目句柄)
                .如果真结束
                
            .判断循环尾 ()
        .判断结束
        .如果真 (加入完成后是否排序)
            排序 (真, -1)
        .如果真结束
        __SendMsgW (#WM_SETREDRAW, 1, 0) ' 是否使用高速插入
        返回 (0)
    .默认
        返回 (-1)
    .判断结束
    

.子程序 加入项目W, 长整数型, 公开
    .参数 父项目句柄, 长整数型, 可空
    .参数 项目文本, 字节集
    .参数 图片索引, 整数型, 可空
    .参数 选中图片索引, 整数型, 可空
    .参数 项目数值, 整数型, 可空
    .参数 是否加粗, 逻辑型, 可空

    make_TVITEMW (#TVIF_ALL, 0, 选择 (是否加粗, #TVIS_BOLD, 0), 16, 4000, 图片索引, 选中图片索引, , 项目数值, , , , , 父项目句柄, 3)
    write_Text (项目文本)
    .如果真 (m_isWow64)
        返回 (__SendMsgW (#TVM_INSERTITEMW, 0, m_item － 8))
    .如果真结束
    返回 (__SendMsgW (#TVM_INSERTITEMW, 0, m_item － 16))

.子程序 删除项目, 逻辑型, 公开, 删除树型框中的指定项目。成功返回真，失败返回假。
    .参数 项目索引, 整数型, , 0 为项目一，1 为项目二，如此类推。

    .如果真 (项目索引 ＋ 1 ＞ 取数组成员数 (m_hItems) 或 项目索引 ＜ 0)
        返回 (假)
    .如果真结束
    返回 (__SendMsgW (#TVM_DELETEITEM, 0, m_hItems [项目索引 ＋ 1]) ≠ 0)

.子程序 清空, , 公开, 删除树型框中的所有项目。
    ' __SendMsgW (#WM_SETREDRAW, 0, 0)  ' 会导致重绘失败
    __SendMsgW (#TVM_DELETEITEM, 0, 0) ' 删除项目
    ' __SendMsgW (#WM_SETREDRAW, 1, 0)

.子程序 取父项目, 整数型, 公开, 返回指定项目的父项目索引。如果该项目为顶层项目，将返回 -1 。
    .参数 项目索引, 整数型, , 0 为项目一，1 为项目二，如此类推。
    .局部变量 i, 整数型
    .局部变量 count, 整数型
    .局部变量 hParent, 长整数型

    count ＝ 取数组成员数 (m_hItems)
    .如果真 (项目索引 ＋ 1 ＞ count 或 项目索引 ＜ 0)
        返回 (-1)
    .如果真结束
    hParent ＝ __SendMsgW (#TVM_GETNEXTITEM, #TVGN_PARENT, m_hItems [项目索引 ＋ 1])
    .如果真 (hParent ＝ 0)
        返回 (-1)
    .如果真结束
    
    .判断循环首 (i ＜ count)
        i ＝ i ＋ 1
        .如果真 (m_hItems [i] ＝ hParent)
            返回 (i － 1)
        .如果真结束
        
    .判断循环尾 ()
    返回 (-1)

.子程序 取父项目文本, 文本型, 公开
    .参数 项目索引, 整数型, , 0 为项目一，1 为项目二，如此类推。

    返回 (取项目文本 (取父项目 (项目索引)))

.子程序 是否有子项目, 逻辑型, 公开, 如果指定项目存在子项目，返回真，否则返回假。如果本命令返回真，意味着指定项目的下一项即为此项目的第一个子项目。
    .参数 项目索引, 整数型, , 0 为项目一，1 为项目二，如此类推。

    .如果真 (项目索引 ＋ 1 ＞ 取数组成员数 (m_hItems) 或 项目索引 ＜ 0)
        返回 (假)
    .如果真结束
    make_TVITEMW (#TVIF_CHILDREN, m_hItems [项目索引 ＋ 1], , , , , , , , , , , , , )
    __SendMsgW (#TVM_GETITEMW, 0, m_item)
    返回 (read_Children () ≠ 0)

.子程序 是否已扩展, 逻辑型, 公开, 如果树型框中的指定项目具有子项目并已扩展显示，返回真，否则返回假。
    .参数 项目索引, 整数型, , 0 为项目一，1 为项目二，如此类推。
    .参数 是否自动更新数据, 逻辑型, 可空, 可以被省略。选择是否自动进行数据更新。当为真时，每次读取数据时都会对数据进行刷新，可能会因此而减慢速度。默认值为“置自动更新状态”方法所设置的状态。
    .局部变量 成员数, 整数型

    成员数 ＝ 取数组成员数 (m_hItems)
    .如果真 (项目索引 ＋ 1 ≥ 成员数 或 项目索引 ＜ 0)
        ' 如果索引超出范围，或索引是最后一个项目
        返回 (假)
    .如果真结束
    成员数 ＝ __SendMsgW (#TVM_GETITEMSTATE, m_hItems [项目索引 ＋ 1], 0)
    返回 (位与 (成员数, 32) ＝ 32)

.子程序 置背景色, , 公开
    .参数 背景颜色, 整数型

    __SendMsgW (#TVM_SETBKCOLOR, 0, 背景颜色)

.子程序 取背景色, 整数型, 公开
    返回 (__SendMsgW (#TVM_GETBKCOLOR, 0, 0))

.子程序 置项目间隔, , 公开
    .参数 间隔距离, 整数型, 可空, 默认为16

    .如果真 (是否为空 (间隔距离))
        间隔距离 ＝ 16
    .如果真结束
    __SendMsgW (#TVM_SETITEMHEIGHT, 间隔距离, 0)

.子程序 取项目间隔, 整数型, 公开
    返回 (__SendMsgW (#TVM_GETITEMHEIGHT, 0, 0))

.子程序 置文本颜色, , 公开
    .参数 文本颜色, 整数型

    __SendMsgW (#TVM_SETTEXTCOLOR, 0, 文本颜色)

.子程序 取文本颜色, 整数型, 公开
    返回 (__SendMsgW (#TVM_GETTEXTCOLOR, 0, 0))

.子程序 置连线颜色, , 公开
    .参数 连线颜色, 整数型

    __SendMsgW (#TVM_SETLINECOLOR, 0, 连线颜色)

.子程序 取连线颜色, 整数型, 公开
    返回 (__SendMsgW (#TVM_GETLINECOLOR, 0, 0))

.子程序 使用复选框, , 公开
    .如果真 (位与 (GetWindowLongA (m_hWnd, #GWL_STYLE), #TVS_CHECKBOXES) ≠ #TVS_CHECKBOXES)
        SetWindowLongA (m_hWnd, #GWL_STYLE, 位或 (GetWindowLongA (m_hWnd, #GWL_STYLE), #TVS_CHECKBOXES))
    .如果真结束
    

.子程序 使用热点跟踪, , 公开
    .如果真 (位与 (GetWindowLongA (m_hWnd, #GWL_STYLE), #TVS_TRACKSELECT) ≠ #TVS_TRACKSELECT)
        SetWindowLongA (m_hWnd, #GWL_STYLE, 位或 (GetWindowLongA (m_hWnd, #GWL_STYLE), #TVS_TRACKSELECT))
    .如果真结束
    

.子程序 禁止滚动条, 逻辑型, 公开, 返回禁止的状态
    .参数 禁止, 逻辑型, 可空, 真为禁止，假为解除禁止。默认为真

    .判断开始 (位与 (GetWindowLongA (m_hWnd, #GWL_STYLE), #TVS_NOSCROLL) ≠ #TVS_NOSCROLL 且 (禁止 或 是否为空 (禁止)))
        SetWindowLongA (m_hWnd, #GWL_STYLE, 位或 (GetWindowLongA (m_hWnd, #GWL_STYLE), #TVS_NOSCROLL))
        返回 (真)
    .判断 (位与 (GetWindowLongA (m_hWnd, #GWL_STYLE), #TVS_NOSCROLL) ＝ #TVS_NOSCROLL 且 取反 (禁止) 且 取反 (是否为空 (禁止)))
        SetWindowLongA (m_hWnd, #GWL_STYLE, 位异或 (GetWindowLongA (m_hWnd, #GWL_STYLE), #TVS_NOSCROLL))
        返回 (假)
    .默认
        返回 (位与 (GetWindowLongA (m_hWnd, #GWL_STYLE), #TVS_NOSCROLL) ≠ #TVS_NOSCROLL)
    .判断结束
    

.子程序 禁止水平滚动条, 逻辑型, 公开, 返回禁止的状态
    .参数 禁止, 逻辑型, 可空, 真为禁止，假为解除禁止。默认为真

    .判断开始 (位与 (GetWindowLongA (m_hWnd, #GWL_STYLE), #TVS_NOHSCROLL) ≠ #TVS_NOHSCROLL 且 (禁止 或 是否为空 (禁止)))
        SetWindowLongA (m_hWnd, #GWL_STYLE, 位或 (GetWindowLongA (m_hWnd, #GWL_STYLE), #TVS_NOHSCROLL))
        返回 (真)
    .判断 (位与 (GetWindowLongA (m_hWnd, #GWL_STYLE), #TVS_NOHSCROLL) ＝ #TVS_NOHSCROLL 且 取反 (禁止) 且 取反 (是否为空 (禁止)))
        SetWindowLongA (m_hWnd, #GWL_STYLE, 位异或 (GetWindowLongA (m_hWnd, #GWL_STYLE), #TVS_NOHSCROLL))
        返回 (假)
    .默认
        返回 (位与 (GetWindowLongA (m_hWnd, #GWL_STYLE), #TVS_NOHSCROLL) ≠ #TVS_NOHSCROLL)
    .判断结束
    

.子程序 使用整行选择, 逻辑型, 公开, 要使用本功能，就不能使用显示连线。
    .参数 是否使用, 逻辑型, 可空, 真为使用，假为不使用。默认为真。

    .判断开始 (位与 (GetWindowLongA (m_hWnd, #GWL_STYLE), 2) ≠ 2)
        .判断开始 (位与 (GetWindowLongA (m_hWnd, #GWL_STYLE), #TVS_FULLROWSELECT) ≠ #TVS_FULLROWSELECT 且 (是否使用 或 是否为空 (是否使用)))
            SetWindowLongA (m_hWnd, #GWL_STYLE, 位或 (GetWindowLongA (m_hWnd, #GWL_STYLE), #TVS_FULLROWSELECT))
            返回 (真)
        .判断 (位与 (GetWindowLongA (m_hWnd, #GWL_STYLE), #TVS_FULLROWSELECT) ＝ #TVS_FULLROWSELECT 且 取反 (是否使用) 且 取反 (是否为空 (是否使用)))
            SetWindowLongA (m_hWnd, #GWL_STYLE, 位异或 (GetWindowLongA (m_hWnd, #GWL_STYLE), #TVS_FULLROWSELECT))
            返回 (假)
        .默认
            返回 (位与 (GetWindowLongA (m_hWnd, #GWL_STYLE), #TVS_FULLROWSELECT) ≠ #TVS_FULLROWSELECT)
        .判断结束
        
    .默认
        暂停 ()
        返回 (假)
    .判断结束
    

.子程序 是否选中, 逻辑型, 公开
    .参数 项目索引, 整数型, , 0 为项目一，1 为项目二，如此类推。
    .参数 是否自动更新数据, 逻辑型, 可空, 可以被省略。选择是否自动进行数据更新。当为真时，每次读取数据时都会对数据进行刷新，可能会因此而减慢速度。默认值为“置自动更新状态”方法所设置的状态。

    .如果真 (项目索引 ＋ 1 ＞ 取数组成员数 (m_hItems) 或 项目索引 ＜ 0)
        返回 (假)
    .如果真结束
    make_TVITEMW (#TVIF_STATE, m_hItems [项目索引 ＋ 1], , , , , , , , , , , , , )
    __SendMsgW (#TVM_GETITEMW, 0, m_item)
    返回 (位与 (read_State (), 8192) ＝ 8192)

.子程序 选中项目, 逻辑型, 公开, 操作成功返回真
    .参数 项目索引, 整数型, , 0 为项目一，1 为项目二，如此类推。
    .参数 是否选中, 逻辑型, 可空, 可以被省略。设置项目的选中状态，默认为真。

    .如果真 (项目索引 ＋ 1 ＞ 取数组成员数 (m_hItems) 或 项目索引 ＜ 0)
        返回 (假)
    .如果真结束
    make_TVITEMW (位或 (#TVIF_STATE, #TVIS_BOLD), m_hItems [项目索引 ＋ 1], 选择 (是否选中 或 是否为空 (是否选中), 8192, 4096), 61440, , , , , , , , , , , )
    __SendMsgW (#TVM_SETITEMW, 0, m_item)
    返回 (位与 (read_State (), 8192) ＝ 8192)

.子程序 加粗, , 公开
    .参数 项目索引, 整数型, , 0 为项目一，1 为项目二，如此类推。

    .如果真 (项目索引 ＋ 1 ＞ 取数组成员数 (m_hItems) 或 项目索引 ＜ 0)
        返回 ()
    .如果真结束
    make_TVITEMW (#TVIF_STATE, m_hItems [项目索引 ＋ 1], #TVIS_BOLD, 16, , , , , , , , , , , )
    __SendMsgW (#TVM_SETITEMW, 0, m_item)

.子程序 加粗_句柄, , 公开
    .参数 项目索引, 整数型, , 0 为项目一，1 为项目二，如此类推。

    .如果真 (项目索引 ＋ 1 ＞ 取数组成员数 (m_hItems) 或 项目索引 ＜ 0)
        返回 ()
    .如果真结束
    make_TVITEMW (#TVIF_STATE, m_hItems [项目索引 ＋ 1], #TVIS_BOLD, 16, , , , , , , , , , , )
    __SendMsgW (#TVM_SETITEMW, 0, m_item)

.子程序 取消加粗, , 公开, 将指定项目的标题取消加粗显示。
    .参数 项目索引, 整数型, , 0 为项目一，1 为项目二，如此类推。

    .如果真 (项目索引 ＋ 1 ＞ 取数组成员数 (m_hItems) 或 项目索引 ＜ 0)
        返回 ()
    .如果真结束
    make_TVITEMW (#TVIF_STATE, m_hItems [项目索引 ＋ 1], 位取反 (#TVIS_BOLD), 16, , , , , , , , , , , )
    __SendMsgW (#TVM_SETITEMW, 0, m_item)

.子程序 取可显示数量, 整数型, 公开, 取当前在树形框的用户区中大约可以显示的项目数量
    返回 (__SendMsgW (#TVM_GETVISIBLECOUNT, 0, 0))

.子程序 取第一项索引, 整数型, 公开, 取在当前树形框中显示的第一条项目的索引。失败返回-1
    .局部变量 hItem, 长整数型
    .局部变量 count, 整数型
    .局部变量 i, 整数型

    hItem ＝ __SendMsgW (#TVM_GETNEXTITEM, #TVGN_FIRSTVISIBLE, 0)
    count ＝ 取数组成员数 (m_hItems)
    .判断循环首 (i ＜ count)
        i ＝ i ＋ 1
        .如果真 (hItem ＝ m_hItems [i])
            返回 (i － 1)
        .如果真结束
        
    .判断循环尾 ()
    返回 (-1)

.子程序 取现行选中项, 整数型, 公开
    .局部变量 hItem, 长整数型
    .局部变量 count, 整数型
    .局部变量 i, 整数型

    hItem ＝ __SendMsgW (#TVM_GETNEXTITEM, #TVGN_CARET, 0) ' 先取第一个根
    .如果真 (hItem ≠ 0)
        count ＝ 取数组成员数 (m_hItems)
        .判断循环首 (i ＜ count)
            i ＝ i ＋ 1
            .如果真 (m_hItems [i] ＝ hItem)
                返回 (i － 1)
            .如果真结束
            
        .判断循环尾 ()
    .如果真结束
    返回 (-1)

.子程序 置现行选中项, , 公开
    .参数 项目索引, 整数型, , 0 为项目一，1 为项目二，如此类推。

    .如果真 (项目索引 ＋ 1 ＞ 取数组成员数 (m_hItems) 或 项目索引 ＜ 0)
        返回 ()
    .如果真结束
    置现行选中项_句柄 (m_hItems [项目索引 ＋ 1])

.子程序 置现行选中项_句柄, , 公开
    .参数 项目句柄, 整数型, , 0 为项目一，1 为项目二，如此类推。

    __SendMsgW (#TVM_SELECTITEM, #TVGN_CARET, 项目句柄)

.子程序 取全部选中项, 变体型, 公开, 返回选中项索引数组
    .局部变量 选中项索引, 变体型
    .局部变量 选中项索引A, 整数型, , "0"
    .局部变量 成员数, 整数型
    .局部变量 成员数2, 整数型
    .局部变量 i, 整数型

    选中项索引.置类型 (#变体类型.数值型数组)
    成员数 ＝ 取数组成员数 (m_hItems)
    重定义数组 (选中项索引A, 假, 成员数)
    .判断循环首 (i ＜ 成员数)
        i ＝ i ＋ 1
        make_TVITEMW (#TVIF_STATE, m_hItems [i], , , , , , , , , , , , , )
        __SendMsgW (#TVM_GETITEMW, 0, 集_外部数据地址1)
        .如果真 (位与 (read_State (), 8192) ＝ 8192)
            成员数2 ＝ 成员数2 ＋ 1
            选中项索引A [成员数2] ＝ i － 1
        .如果真结束
        
    .判断循环尾 ()
    重定义数组 (选中项索引A, 真, 成员数2)
    选中项索引.赋值 (选中项索引A, )
    返回 (选中项索引)

.子程序 更新缓存, , 公开, 如果项目增加或减少，需要调用此命令进行更新
    内部_遍历句柄 ()

.子程序 置外部操作, , 公开
    .参数 是否操作外部控件, 逻辑型

    .如果真 (m_hProc ＝ 0 且 是否操作外部控件)
        m_hProc ＝ OpenProc (m_hWnd)
    .如果真结束
    

.子程序 内部_遍历句柄
    .局部变量 hParent, 长整数型
    .局部变量 hItem, 长整数型
    .局部变量 hItemTmp, 长整数型
    .局部变量 done, 逻辑型
    .局部变量 i, 整数型

    清除数组 (m_hItemParent)
    重定义数组 (m_hItems, 假, 取项目数 ())
    hItem ＝ __SendMsgW (#TVM_GETNEXTITEM, #TVGN_ROOT, 0) ' 先取第一个根
    
    .判断循环首 (hItem ≠ 0)
        i ＝ i ＋ 1
        m_hItems [i] ＝ hItem
        hItemTmp ＝ hItem
        hItem ＝ __SendMsgW (#TVM_GETNEXTITEM, #TVGN_CHILD, hItem) ' 取第一个子
        .如果真 (hItem ＝ 0) ' 取子取不到，就取兄弟
            hItem ＝ __SendMsgW (#TVM_GETNEXTITEM, #TVGN_NEXT, hItemTmp) ' 取子的兄弟
            ' 找到了兄弟就直接到循环尾，否则进入下面的循环找父项目
            .判断循环首 (hItem ＝ 0)
                hParent ＝ __SendMsgW (#TVM_GETNEXTITEM, #TVGN_PARENT, hItemTmp) ' 退回上一级
                .如果真 (hParent ＝ 0)
                    done ＝ 真
                    跳出循环 ()
                .如果真结束
                hItemTmp ＝ hParent
                hItem ＝ __SendMsgW (#TVM_GETNEXTITEM, #TVGN_NEXT, hParent) ' 取父的兄弟
            .判断循环尾 ()
        .如果真结束
        .如果真 (done)
            跳出循环 ()
        .如果真结束
        
    .判断循环尾 ()

.子程序 内部_遍历句柄_父项目, , , 遍历有子项目的句柄
    .局部变量 i, 整数型
    .局部变量 计次, 整数型

    重定义数组 (m_hItemParent, 假, 取数组成员数 (m_hItems))
    .计次循环首 (取数组成员数 (m_hItems), i)
        .如果真 (是否有子项目 (i － 1))
            计次 ＝ 计次 ＋ 1
            m_hItemParent [计次] ＝ m_hItems [i]
        .如果真结束
        
    .计次循环尾 ()
    重定义数组 (m_hItemParent, 真, 计次)

.子程序 遍历句柄_子项目, 整数型, 公开, 遍历指定父项目下的所有子项目句柄
    .参数 父项目句柄, 整数型
    .参数 项目数据, 项目数据, 参考 可空 数组
    .参数 是否提取项目数值, 逻辑型, 可空
    .局部变量 hItem, 长整数型
    .局部变量 item, 项目数据

    hItem ＝ __SendMsgW (#TVM_GETNEXTITEM, #TVGN_CHILD, 父项目句柄) ' 取第一个子
    .如果真 (hItem ＝ 0)
        返回 (0)
    .如果真结束
    .判断开始 (是否提取项目数值)
        .判断循环首 (hItem ≠ 0)
            ' 局_项目数据.项目数值 ＝ 取项目数值_句柄 (局_子项目)
            item.项目文本 ＝ 取项目文本_句柄 (hItem)
            item.项目句柄 ＝ hItem
            item.项目数值 ＝ 取项目数值_句柄 (hItem)
            加入成员 (项目数据, item)
            hItem ＝ __SendMsgW (#TVM_GETNEXTITEM, #TVGN_NEXT, hItem) ' 取子的兄弟
        .判断循环尾 ()
        
    .默认
        .判断循环首 (hItem ≠ 0)
            ' 局_项目数据.项目数值 ＝ 取项目数值_句柄 (局_子项目)
            item.项目文本 ＝ 取项目文本_句柄 (hItem)
            item.项目句柄 ＝ hItem
            加入成员 (项目数据, item)
            hItem ＝ __SendMsgW (#TVM_GETNEXTITEM, #TVGN_NEXT, hItem) ' 取子的兄弟
        .判断循环尾 ()
    .判断结束
    返回 (取数组成员数 (项目数据))

.子程序 句柄取索引, 整数型, 公开, 用树型框的项目句柄获取他的项目索引
    .参数 欲查找句柄, 整数型
    .局部变量 i, 整数型
    .局部变量 count, 整数型

    i ＝ 1
    count ＝ 取数组成员数 (m_hItems)
    .判断循环首 (i ＜ count) ' 循环直至左右指针相遇
        .如果真 (m_hItems [i] ＝ 欲查找句柄)
            返回 (i － 1)
        .如果真结束
        
        .如果真 (m_hItems [count] ＝ 欲查找句柄)
            返回 (count － 1)
        .如果真结束
        .判断开始 (i ＜ count)
            i ＝ i ＋ 1
            count ＝ count － 1
        .默认
            返回 (0)
        .判断结束
        
    .判断循环尾 ()
    返回 (0)

.子程序 索引取句柄, 整数型, 公开, 失败返回-1
    .参数 项目索引, 整数型, , 从0开始
    .局部变量 i, 整数型

    i ＝ 项目索引 ＋ 1
    .如果真 (取数组成员数 (m_hItems) ＝ 0)
        内部_遍历句柄 ()
    .如果真结束
    .如果真 (i ＞ 0 且 i ≤ 取数组成员数 (m_hItems))
        返回 (m_hItems [i])
    .如果真结束
    返回 (-1)

.子程序 查找项目, 整数型, 公开, 成功返回项目索引
    .参数 项目文本, 文本型
    .参数 精确查找, 逻辑型, 可空, 可空，默认为假，真=精确查找
    .参数 项目句柄, 整数型, 参考 可空
    .局部变量 i, 整数型
    .局部变量 count, 整数型

    内部_遍历句柄 ()
    i ＝ 0
    count ＝ 取数组成员数 (m_hItems)
    .判断开始 (精确查找)
        .判断循环首 (i ＜ count) ' 循环直至左右指针相遇
            .如果真 (取项目文本 (i) ＝ 项目文本)
                .如果真 (是否为空 (项目句柄) ＝ 假)
                    项目句柄 ＝ m_hItems [i ＋ 1]
                .如果真结束
                返回 (i)
            .如果真结束
            
            .如果真 (取项目文本 (count) ＝ 项目文本)
                .如果真 (是否为空 (项目句柄) ＝ 假)
                    项目句柄 ＝ m_hItems [count ＋ 1]
                .如果真结束
                返回 (count)
            .如果真结束
            .判断开始 (i ＜ count)
                i ＝ i ＋ 1
                count ＝ count － 1
            .默认
                返回 (-1)
            .判断结束
            
        .判断循环尾 ()
        
    .默认
        .判断循环首 (i ＜ count) ' 循环直至左右指针相遇
            .如果真 (寻找文本 (取项目文本 (i), 项目文本, , 假) ≠ -1)
                .如果真 (是否为空 (项目句柄) ＝ 假)
                    项目句柄 ＝ m_hItems [i ＋ 1]
                .如果真结束
                返回 (i)
            .如果真结束
            
            .如果真 (寻找文本 (取项目文本 (count), 项目文本, , 假) ≠ -1)
                .如果真 (是否为空 (项目句柄) ＝ 假)
                    项目句柄 ＝ m_hItems [count ＋ 1]
                .如果真结束
                返回 (count)
            .如果真结束
            .判断开始 (i ＜ count)
                i ＝ i ＋ 1
                count ＝ count － 1
            .默认
                返回 (-1)
            .判断结束
            
        .判断循环尾 ()
        
    .判断结束
    返回 (-1)

.子程序 查找项目数值, 整数型, 公开, 成功返回索引
    .参数 项目数值, 整数型
    .局部变量 i, 整数型
    .局部变量 count, 整数型

    i ＝ 0
    count ＝ 取数组成员数 (m_hItems)
    .判断循环首 (i ≤ count) ' 循环直至左右指针相遇
        .如果真 (取项目数值 (i) ＝ 项目数值)
            返回 (i)
        .如果真结束
        
        .如果真 (取项目数值 (count) ＝ 项目数值)
            返回 (count)
            
        .如果真结束
        .判断开始 (i ＜ count)
            i ＝ i ＋ 1
            count ＝ count － 1
        .默认
            返回 (-1)
        .判断结束
        
    .判断循环尾 ()
    返回 (-1)

.子程序 查找项目_外部, 整数型, 公开, 返回结果数量，被查找出来的项目数值，对应目标树型框的项目索引
    .参数 欲查找的文本, 文本型
    .参数 结果树型框句柄, 整数型, , 用于存放结果的树型框句柄
    .参数 查找结果是否扩展, 逻辑型, 可空, 查找后，结果项目是否扩展开
    .参数 是否同步图标, 逻辑型, 可空, 是否同步项目的图标，会影响速度
    .参数 搜索时禁止重绘, 逻辑型, 可空, 禁止重绘，可能会导致未找到时(只有1个项目时，无法重绘)
    .参数 搜索状态回调Call, 整数型, 可空, 共2个参数，参数1:状态文本(文本型)，参数2:备用(整数)
    .局部变量 父项目索引, 长整数型
    .局部变量 树型框, 外部树型框
    .局部变量 项目数据, 项目数据
    .局部变量 一级项目, 长整数型
    .局部变量 图片索引, 整数型
    .局部变量 索引, 整数型
    .局部变量 被查找索引, 整数型
    .局部变量 搜索结果数量, 整数型

    .如果真 (IsWindow (结果树型框句柄) ＝ 0)
        输出调试文本 (“结果树型框句柄 - 无效”)
        返回 (0)
    .如果真结束
    树型框.初始化 (结果树型框句柄, , m_hProc ≠ 0)
    树型框.清空 ()
    树型框.更新缓存 ()
    .如果 (搜索状态回调Call ＞ 0)
        _搜索回调Call ＝ 搜索状态回调Call
    .否则
        _搜索回调Call ＝ 0
    .如果结束
    搜索结果数量 ＝ 0
    图片索引 ＝ 取图片 (0)
    树型框.加入项目W (, 取项目文本W (0), 图片索引, 图片索引, 取项目数值 (0), 真)
    树型框.更新缓存 ()
    .如果真 (搜索时禁止重绘)
        __SendMsgW (#WM_SETREDRAW, 0, 0)
    .如果真结束
    一级项目 ＝ __SendMsgW (#TVM_GETNEXTITEM, #TVGN_ROOT, 0)
    内部_递归子项目 (m_hWnd, 一级项目, 欲查找的文本, 索引, 被查找索引, 父项目索引, 树型框, , 是否同步图标, 搜索结果数量)
    .如果真 (树型框.取子项目数 (0) ＝ 0)
        索引 ＝ 索引 － 1
        被查找索引 ＝ 被查找索引 － 1
        树型框.删除项目 (0)
    .如果真结束
    
    .判断循环首 (一级项目 ＞ 0)
        索引 ＝ 索引 ＋ 1
        被查找索引 ＝ 被查找索引 ＋ 1
        一级项目 ＝ __SendMsgW (#TVM_GETNEXTITEM, #TVGN_NEXT, 一级项目) ' 取兄弟
        .如果真 (一级项目 ＝ 0)
            跳出循环 ()
        .如果真结束
        
        图片索引 ＝ 取图片_句柄 (一级项目)
        树型框.加入项目W (, 取项目文本_句柄W (一级项目), 图片索引, 图片索引, 取项目数值_句柄 (一级项目), 真)
        树型框.更新缓存 ()
        .如果真 (取项目文本_句柄 (一级项目) ＝ “”)
            暂停 ()
        .如果真结束
        
        父项目索引 ＝ 索引
        内部_递归子项目 (m_hWnd, 一级项目, 欲查找的文本, 索引, 被查找索引, 父项目索引, 树型框, , 是否同步图标, 搜索结果数量)
        .如果真 (树型框.取子项目数 (父项目索引) ＝ 0)
            树型框.删除项目 (父项目索引)
            索引 ＝ 索引 － 1
        .如果真结束
        
    .判断循环尾 ()
    .如果真 (搜索时禁止重绘)
        __SendMsgW (#WM_SETREDRAW, 1, 0)
    .如果真结束
    .如果真 (查找结果是否扩展)
        树型框.扩展全部 ()
    .如果真结束
    内部_加入父项目 (, -1, , , , , )
    树型框.置现行选中项 (0)
    返回 (搜索结果数量)

.子程序 内部_递归子项目, 逻辑型, , 【查找项目_外部】
    .参数 树型框句柄, 整数型
    .参数 父项目句柄, 长整数型, 可空
    .参数 欲查找的文本, 文本型
    .参数 索引, 整数型, 参考
    .参数 被查找索引, 整数型, 参考
    .参数 主父项目索引, 整数型, 可空
    .参数 树型框, 外部树型框, 可空
    .参数 有查找到结果, 逻辑型, 参考 可空
    .参数 是否同步图标, 逻辑型, 可空, 是否同步项目的图标，会影响速度
    .参数 搜索结果数量, 整数型, 参考
    .局部变量 局_子项目, 长整数型
    .局部变量 局_文本, 文本型
    .局部变量 内部_父项目索引, 整数型
    .局部变量 图片索引, 整数型
    .局部变量 Temp, 文本型

    局_子项目 ＝ __SendMsgW (#TVM_GETNEXTITEM, #TVGN_CHILD, 父项目句柄) ' 取子项目的句柄
    .如果真 (局_子项目 ＝ 0)
        返回 (假)
    .如果真结束
    .判断循环首 (局_子项目 ＞ 0)
        被查找索引 ＝ 被查找索引 ＋ 1
        局_文本 ＝ 取项目文本_句柄 (局_子项目)
        .判断开始 (__SendMsgW (#TVM_GETNEXTITEM, #TVGN_CHILD, 局_子项目) ＞ 0) ' 取子程序下是否有子
            索引 ＝ 索引 ＋ 1
            有查找到结果 ＝ 假
            .如果真 (是否同步图标)
                图片索引 ＝ 取图片_句柄 (局_子项目)
            .如果真结束
            
            ' 搜索回调
            .如果真 (_搜索回调Call ＞ 0)
                Temp ＝ “正在搜索[” ＋ 局_文本 ＋ “]...”
                程序_Call (_搜索回调Call, 取指针文本_ (Temp), 0, , , )
            .如果真结束
            
            内部_父项目索引 ＝ 内部_加入父项目 (树型框, 主父项目索引, 局_文本, 局_子项目, 索引, 图片索引, 被查找索引)
            内部_递归子项目 (树型框句柄, 局_子项目, 欲查找的文本, 索引, 被查找索引, 内部_父项目索引, 树型框, 有查找到结果, 是否同步图标, 搜索结果数量)
            
            .判断开始 (树型框.取子项目数 (内部_父项目索引) ＝ 0 且 寻找文本 (局_文本, 欲查找的文本, , 真) ＝ -1)
                索引 ＝ 索引 － 1
                树型框.删除项目 (内部_父项目索引)
                
            .默认
                搜索结果数量 ＝ 搜索结果数量 ＋ 1
            .判断结束
            
        .判断 (寻找文本 (局_文本, 欲查找的文本, , 真) ≠ -1)
            搜索结果数量 ＝ 搜索结果数量 ＋ 1
            索引 ＝ 索引 ＋ 1
            有查找到结果 ＝ 真
            .如果真 (是否同步图标)
                图片索引 ＝ 取图片_句柄 (局_子项目)
            .如果真结束
            树型框.加入项目W (主父项目索引, 编码_Ansi到Unicode (局_文本, ), 图片索引, 图片索引, 被查找索引, )
        .默认
            
        .判断结束
        局_子项目 ＝ __SendMsgW (#TVM_GETNEXTITEM, #TVGN_NEXT, 局_子项目) ' 取兄弟
    .判断循环尾 ()
    返回 (真)

.子程序 内部_加入父项目, 整数型, , 【查找项目_外部】
    .参数 树型框, 外部树型框, 可空
    .参数 主父项目索引, 整数型, 可空, -1=初始化
    .参数 项目文本, 文本型, 可空
    .参数 父项目句柄, 整数型, 可空
    .参数 索引, 整数型, 可空
    .参数 图片索引, 整数型, 可空
    .参数 被查找索引, 整数型, 可空
    .局部变量 句项数组, 整数型, 静态, "0"
    .局部变量 索引数组, 整数型, 静态, "0"
    .局部变量 i, 整数型

    .如果真 (主父项目索引 ＝ -1)
        清除数组 (句项数组)
        清除数组 (索引数组)
        返回 (0)
    .如果真结束
    .计次循环首 (取数组成员数 (索引数组), i)
        .如果真 (句项数组 [i] ＝ 父项目句柄)
            返回 (索引数组 [i])
        .如果真结束
        
    .计次循环尾 ()
    树型框.加入项目W (主父项目索引, 编码_Ansi到Unicode (项目文本, ), 图片索引, 图片索引, 被查找索引, 真)
    树型框.更新缓存 ()
    加入成员 (句项数组, 父项目句柄)
    加入成员 (索引数组, 索引)
    返回 (索引)

.子程序 取子项目数, 整数型, 公开, 获取当前选中项目的子项目数量
    .参数 项目索引, 整数型, 可空, 可空，默认取选中项的子项目数
    .局部变量 局_当前项目句柄, 长整数型
    .局部变量 局_数量, 整数型
    .局部变量 局_子项目句柄, 长整数型

    .如果 (是否为空 (项目索引))
        局_当前项目句柄 ＝ __SendMsgW (#TVM_GETNEXTITEM, 9, 0)
        
    .否则
        .如果真 (项目索引 ＋ 1 ＞ 取数组成员数 (m_hItems) 或 项目索引 ＜ 0)
            返回 (0)
        .如果真结束
        局_当前项目句柄 ＝ m_hItems [项目索引 ＋ 1]
    .如果结束
    
    局_子项目句柄 ＝ __SendMsgW (#TVM_GETNEXTITEM, #TVGN_CHILD, 局_当前项目句柄) ' 取第一个子项目的句柄
    局_数量 ＝ 0
    .判断循环首 (局_子项目句柄 ＞ 0)
        局_数量 ＝ 局_数量 ＋ 1
        局_子项目句柄 ＝ __SendMsgW (#TVM_GETNEXTITEM, #TVGN_NEXT, 局_子项目句柄) ' 取同级的下一个项目句柄
    .判断循环尾 ()
    返回 (局_数量)

.子程序 双击项目, , 公开
    .参数 项目句柄, 长整数型
    .局部变量 精易_矩形, 精易_矩形
    .局部变量 p, 整数型

    p ＝ 取指针_通用型 (项目句柄)
    精易_矩形.左边 ＝ __get (p, 0)
    精易_矩形.顶边 ＝ __get (p, 4)
    .计次循环首 (2, )
        __SendMsgW (#TVM_GETITEMRECT, 0, 取数据_通用型 (精易_矩形)) ' 取矩形
        __SendMsgW (#TVM_ENSUREVISIBLE, 0, 项目句柄) ' 保证显示
    .计次循环尾 ()
    鼠标_消息 (m_hWnd, 精易_矩形.左边 ＋ 50, 精易_矩形.顶边 ＋ 10, , 2)
    鼠标_移动 (m_hWnd, 精易_矩形.左边 ＋ 50, 精易_矩形.顶边 ＋ 10)

.子程序 取所有父项目, 整数型, 公开, 获取所有有子项目的项目索引，成功返回获取到的数量
    .参数 项目索引数组, 整数型, 参考 数组, 用于存放父项目索引的数组
    .参数 排除父项目, 文本型, 可空, 如：类，将不获取类下的所有有子项目的父项目索引
    .参数 缩进层次, 整数型, 可空, 可空，默认为所有。获取小于或等于这个层次的父项目，缩进层次从1开始
    .参数 指定缩进层次, 整数型, 可空, 可空，默认为所有。如果有指定，第23参数将无效，只获取指定缩进层次的父项目
    .局部变量 i, 整数型
    .局部变量 局_缩进层次, 整数型
    .局部变量 局_父项目名称, 文本型

    清除数组 (项目索引数组)
    .计次循环首 (取项目数 (), i)
        .如果真 (是否有子项目 (i － 1) ＝ 假)
            到循环尾 ()
        .如果真结束
        
        .判断开始 (是否为空 (指定缩进层次) ＝ 假)
            局_缩进层次 ＝ 取缩进层次 (i － 1)
            .如果真 (局_缩进层次 ≠ 指定缩进层次)
                到循环尾 ()
            .如果真结束
            
        .默认
            .如果真 (缩进层次 ≠ 0)
                局_缩进层次 ＝ 取缩进层次 (i － 1)
                .如果真 (局_缩进层次 ＞ 缩进层次)
                    到循环尾 ()
                .如果真结束
                
            .如果真结束
            .如果真 (是否为空 (排除父项目) ＝ 假)
                局_父项目名称 ＝ 取项目文本 (取父项目 (i － 1))
                .如果真 (局_父项目名称 ＝ 排除父项目)
                    到循环尾 ()
                .如果真结束
                
            .如果真结束
            
        .判断结束
        加入成员 (项目索引数组, i － 1)
    .计次循环尾 ()
    返回 (取数组成员数 (项目索引数组))

.子程序 取上一个同级项目, 整数型, 公开
    .参数 项目索引, 整数型
    .局部变量 局_成员数, 整数型
    .局部变量 局_项目索引, 整数型
    .局部变量 i, 整数型

    局_成员数 ＝ 取数组成员数 (m_hItems)
    .如果真 (项目索引 ＜ 0 或 项目索引 ≥ 局_成员数)
        返回 (-1)
    .如果真结束
    ' .常量 TVM_GETNEXTITEM, "4362", , 获取与树视图控件中的指定项目具有指定关系的项目
    ' .常量 TVGN_PREVIOUS, "2", , 获取指定项目的同一组中的上一个项目
    局_项目索引 ＝ __SendMsgW (#TVM_GETNEXTITEM, 2, m_hItems [项目索引 ＋ 1])
    .如果真 (局_项目索引 ＝ 0)
        返回 (-1)
    .如果真结束
    .计次循环首 (局_成员数, i)
        .如果真 (m_hItems [i] ＝ 局_项目索引)
            返回 (i － 1)
        .如果真结束
        
    .计次循环尾 ()
    返回 (-1)

.子程序 取下一个同级项目, 整数型, 公开
    .参数 项目索引, 整数型
    .局部变量 局_成员数, 整数型
    .局部变量 局_项目索引, 整数型
    .局部变量 i, 整数型

    局_成员数 ＝ 取数组成员数 (m_hItems)
    .如果真 (项目索引 ＜ 0 或 项目索引 ≥ 局_成员数)
        返回 (-1)
    .如果真结束
    ' .常量 TVM_GETNEXTITEM, "4362", , 获取与树视图控件中的指定项目具有指定关系的项目
    ' .常量 TVGN_NEXT, "1", , 获取与指定项目相同的组中的下一个项目
    局_项目索引 ＝ __SendMsgW (#TVM_GETNEXTITEM, 1, m_hItems [项目索引 ＋ 1])
    .如果真 (局_项目索引 ＝ 0)
        返回 (-1)
    .如果真结束
    .计次循环首 (局_成员数, i)
        .如果真 (m_hItems [i] ＝ 局_项目索引)
            返回 (i － 1)
        .如果真结束
        
    .计次循环尾 ()
    返回 (-1)

.版本 2

.程序集 外部超级列表框, , 公开
.程序集变量 集_目标句柄, 整数型
.程序集变量 集_表头句柄, 整数型
.程序集变量 集_外部控件, 逻辑型
.程序集变量 集_外部控件操作, 外部控件操作
.程序集变量 集_进程句柄, 整数型

.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
    
    ' 连续赋值 (250, 临时_项目.项目文本长度, 临时_列.缓冲区长度, 集_外部列.缓冲区长度)

.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
    集_外部控件操作.结束操作 (集_进程句柄)

.子程序 初始化, 逻辑型, 公开, 调用此类必须初始化此命令，否则无法调用后面的命令
    .参数 超级列表框句柄, 整数型
    .参数 是否为外部进程的超级列表框, 逻辑型, 可空, 可以被省略。当为真时，可对这个外部进程一超级列表框进行操作。默认为假。
    .参数 超级列表框类名, 文本型, 可空, 默认为空  SYSLISTVIEW32 

    .如果真 (是否为空 (超级列表框类名))
        超级列表框类名 ＝ “SysListView32”
    .如果真结束
    .判断开始 (文本比较 (窗口_取类名 (超级列表框句柄), 超级列表框类名, 假) ＝ 0) ' SysListView32
        集_外部控件 ＝ 是否为外部进程的超级列表框
        集_目标句柄 ＝ 超级列表框句柄
        集_进程句柄 ＝ 集_外部控件操作.打开进程 (集_目标句柄) ' 全部子程序共用
        返回 (真)
    .默认
        返回 (假)
    .判断结束
    

.子程序 取标题, 文本型, 公开, 取指定表项或子项的标题。
    .参数 表项索引, 整数型, , 用于指定列表框中的某一项目，索引值从 0 开始。
    .参数 列索引, 整数型, 可空, 可以被省略。用作指定报表型列表框中项目所处的列，索引值从 0 开始，如果当前列表框类型不是报表型列表框，提供 0 值即可。如果本参数被省略，默认值为 0 。
    .参数 缓冲尺寸, 整数型, 可空, 可以被省略
    .局部变量 临时_项目地址, 整数型
    .局部变量 临时_数据地址1, 整数型
    .局部变量 临时_数据地址2, 整数型
    .局部变量 局部_外部项目, 超级列表框1
    .局部变量 局_缓冲区, 文本型
    .局部变量 hMem, 整数型
    .局部变量 text, 文本型

    缓冲尺寸 ＝ 选择 (是否为空 (缓冲尺寸), 260, 缓冲尺寸)
    .判断开始 (集_外部控件)
        ' 集_进程句柄 ＝ 外部控件操作.打开进程 (集_目标句柄)
        临时_数据地址1 ＝ 集_外部控件操作.分配外部指针 (集_进程句柄, 40)
        临时_数据地址2 ＝ 集_外部控件操作.分配外部指针 (集_进程句柄, 缓冲尺寸)
        局部_外部项目.项目文本 ＝ 临时_数据地址2
        局部_外部项目.表项索引 ＝ 表项索引
        局部_外部项目.子项目 ＝ 列索引
        局部_外部项目.掩码 ＝ 1
        局部_外部项目.项目文本长度 ＝ 缓冲尺寸
        临时_项目地址 ＝ 取数据_通用型 (局部_外部项目)
        集_外部控件操作.写进程内存 (集_进程句柄, 临时_数据地址1, 临时_项目地址, 40)
        .判断开始 (SendMessageA (集_目标句柄, 4101, 0, 临时_数据地址1) ≠ 0)
            局_缓冲区 ＝ 到文本 (集_外部控件操作.读外部指针数据 (集_进程句柄, 临时_数据地址2, 缓冲尺寸))
            集_外部控件操作.销毁外部指针 (集_进程句柄, 临时_数据地址2)
            集_外部控件操作.销毁外部指针 (集_进程句柄, 临时_数据地址1)
            
            返回 (局_缓冲区)
        .默认
            集_外部控件操作.销毁外部指针 (集_进程句柄, 临时_数据地址2)
            集_外部控件操作.销毁外部指针 (集_进程句柄, 临时_数据地址1)
            
            返回 (“”)
        .判断结束
        
    .默认
        hMem ＝ HeapAlloc (GetProcessHeap (), 8, 缓冲尺寸)
        局部_外部项目.子项目 ＝ 列索引
        局部_外部项目.项目文本长度 ＝ 缓冲尺寸
        局部_外部项目.项目文本 ＝ hMem
        SendMessageA (集_目标句柄, 4141, 表项索引, 取数据_通用型 (局部_外部项目)) ' #LVM_GETITEMTEXT=4141
        text ＝ 指针到文本 (hMem)
        HeapFree (GetProcessHeap (), 8, hMem)
        返回 (text)
    .判断结束
    

.子程序 取图片, 整数型, 公开
    .参数 表项索引, 整数型, , 用于指定列表框中的某一项目，索引值从 0 开始。
    .参数 列索引, 整数型, 可空, 可以被省略。用作指定报表型列表框中项目所处的列，索引值从 0 开始，如果当前列表框类型不是报表型列表框，提供 0 值即可。如果本参数被省略，默认值为 0 。
    .局部变量 临时_数据地址1, 整数型
    .局部变量 临时_项目地址, 整数型
    .局部变量 局_缓冲区, 字节集
    .局部变量 局部_外部项目, 超级列表框1
    .局部变量 临时_项目, 超级列表框0

    .如果真 (集_外部控件)
        临时_数据地址1 ＝ 集_外部控件操作.分配外部指针 (集_进程句柄, 40)
        局部_外部项目.表项索引 ＝ 表项索引
        局部_外部项目.子项目 ＝ 列索引
        局部_外部项目.掩码 ＝ 2
        临时_项目地址 ＝ 取数据_通用型 (局部_外部项目)
        集_外部控件操作.写进程内存 (集_进程句柄, 临时_数据地址1, 临时_项目地址, 40)
        SendMessageA (集_目标句柄, 4101, 0, 临时_数据地址1)
        局_缓冲区 ＝ 集_外部控件操作.读外部指针数据 (集_进程句柄, 临时_数据地址1, 40)
        集_外部控件操作.销毁外部指针 (集_进程句柄, 临时_数据地址1)
        写到内存 (局_缓冲区, 临时_项目地址, 40)
        返回 (局部_外部项目.图片索引)
    .如果真结束
    临时_项目.项目 ＝ 表项索引
    临时_项目.子项目 ＝ 列索引
    临时_项目.掩码 ＝ 2
    临时_项目地址 ＝ 取数据_通用型 (临时_项目)
    SendMessageA (集_目标句柄, 4101, 0, 临时_项目地址)
    返回 (临时_项目.图片索引)

.子程序 取当前状态图片, 整数型, 公开, 取回指定表项的当前状态图片索引，图片索引指向状态图片组属性中的某一图片，从 0 开始，-1 表示无图片。如果“是否有检查框”属性为真，返回值是当前检查框的选中状态，1表示被选中，0表示未选中。
    .参数 表项索引, 整数型, , 用于指定列表框中的某一项目，索引值从 0 开始。

    返回 (SendMessageA (集_目标句柄, #LVM_GETITEMSTATE, 表项索引, -4096) ÷ 4096 － 1)

.子程序 取缩进数目, 整数型, 公开
    .参数 表项索引, 整数型, , 。用于指定列表框中的某一项目，索引值从 0 开始。
    .局部变量 临时_数据地址1, 整数型
    .局部变量 临时_项目地址, 整数型
    .局部变量 局_缓冲区, 字节集
    .局部变量 局部_外部项目, 超级列表框1
    .局部变量 临时_项目, 超级列表框0

    .如果真 (集_外部控件)
        ' 集_进程句柄 ＝ 外部控件操作.打开进程 (集_目标句柄)
        临时_数据地址1 ＝ 集_外部控件操作.分配外部指针 (集_进程句柄, 40)
        局部_外部项目.表项索引 ＝ 表项索引
        局部_外部项目.掩码 ＝ 16
        临时_项目地址 ＝ 取数据_通用型 (局部_外部项目)
        集_外部控件操作.写进程内存 (集_进程句柄, 临时_数据地址1, 临时_项目地址, 40)
        SendMessageA (集_目标句柄, 4101, 0, 临时_数据地址1)
        局_缓冲区 ＝ 集_外部控件操作.读外部指针数据 (集_进程句柄, 临时_数据地址1, 40)
        集_外部控件操作.销毁外部指针 (集_进程句柄, 临时_数据地址1)
        ' 外部控件操作.结束操作 (集_进程句柄)
        写到内存 (局_缓冲区, 临时_项目地址, 40)
        返回 (局部_外部项目.缩进)
    .如果真结束
    临时_项目.项目 ＝ 表项索引
    临时_项目.掩码 ＝ 16
    临时_项目地址 ＝ 取数据_通用型 (临时_项目)
    SendMessageA (集_目标句柄, 4101, 0, 临时_项目地址)
    返回 (临时_项目.缩进)

.子程序 取表项数, 整数型, 公开, 返回列表框中所有表项的数目
    返回 (SendMessageA (集_目标句柄, #LVM_GETITEMCOUNT, 0, 0))

.子程序 取表项数值, 整数型, 公开
    .参数 表项索引, 整数型, , 用于指定列表框中的某一项目，索引值从 0 开始。
    .局部变量 临时_项目地址, 整数型
    .局部变量 临时_数据地址1, 整数型
    .局部变量 局_缓冲区, 字节集
    .局部变量 局部_外部项目, 超级列表框1
    .局部变量 临时_项目, 超级列表框0

    .如果真 (集_外部控件)
        临时_数据地址1 ＝ 集_外部控件操作.分配外部指针 (集_进程句柄, 40)
        局部_外部项目.表项索引 ＝ 表项索引
        局部_外部项目.掩码 ＝ 4
        临时_项目地址 ＝ 取数据_通用型 (局部_外部项目)
        集_外部控件操作.写进程内存 (集_进程句柄, 临时_数据地址1, 临时_项目地址, 40)
        SendMessageA (集_目标句柄, 4101, 0, 临时_数据地址1)
        局_缓冲区 ＝ 集_外部控件操作.读外部指针数据 (集_进程句柄, 临时_数据地址1, 40)
        集_外部控件操作.销毁外部指针 (集_进程句柄, 临时_数据地址1)
        写到内存 (局_缓冲区, 临时_项目地址, 40)
        返回 (局部_外部项目.项目数值)
    .如果真结束
    临时_项目.项目 ＝ 表项索引
    临时_项目.掩码 ＝ 4
    ' 集_单一项目.pszText ＝ 取空白文本 (260)
    临时_项目地址 ＝ 取数据_通用型 (临时_项目)
    SendMessageA (集_目标句柄, 4101, 0, 临时_项目地址)
    返回 (临时_项目.项目数值)

.子程序 置标题, , 公开, 设置指定表项或子项的标题。
    .参数 表项索引, 整数型, , 用于指定列表框中的某一项目，索引值从 0 开始。
    .参数 列索引, 整数型, 可空, 可以被省略。用作指定报表型列表框中项目所处的列，索引值从 0 开始，如果当前列表框类型不是报表型列表框，提供 0 值即可。如果本参数被省略，默认值为 0 。
    .参数 标题, 文本型, 可空, 可以被省略。本参数指定表项或子项的标题文本。如果被省略，默认值为空文本。
    .局部变量 临时_项目地址, 整数型
    .局部变量 临时_数据地址1, 整数型
    .局部变量 临时_数据地址2, 整数型
    .局部变量 局部_外部项目, 超级列表框1
    .局部变量 局_项目文本长度, 整数型
    .局部变量 局_缓冲区, 整数型
    .局部变量 临时_项目, 超级列表框0

    .如果真 (集_外部控件)
        局_项目文本长度 ＝ 取字节集长度 (到字节集 (标题)) ＋ 1
        
        临时_数据地址1 ＝ 集_外部控件操作.分配外部指针 (集_进程句柄, 40)
        临时_数据地址2 ＝ 集_外部控件操作.分配外部指针 (集_进程句柄, 局_项目文本长度)
        局部_外部项目.表项索引 ＝ 表项索引
        局部_外部项目.子项目 ＝ 列索引
        局_缓冲区 ＝ lstrcpyn_文本型 (标题, 标题, 0)
        局部_外部项目.项目文本 ＝ 临时_数据地址2
        局部_外部项目.项目文本长度 ＝ 局_项目文本长度
        局部_外部项目.掩码 ＝ 1
        临时_项目地址 ＝ 取数据_通用型 (局部_外部项目)
        集_外部控件操作.写进程内存 (集_进程句柄, 临时_数据地址1, 临时_项目地址, 40)
        集_外部控件操作.写进程内存 (集_进程句柄, 临时_数据地址2, 局_缓冲区, 局_项目文本长度)
        SendMessageA (集_目标句柄, 4102, 0, 临时_数据地址1)
        集_外部控件操作.销毁外部指针 (集_进程句柄, 临时_数据地址1)
        集_外部控件操作.销毁外部指针 (集_进程句柄, 临时_数据地址2)
        
        返回 ()
    .如果真结束
    临时_项目.项目 ＝ 表项索引
    临时_项目.子项目 ＝ 列索引
    临时_项目.掩码 ＝ 1
    临时_项目.项目文本 ＝ 标题
    临时_项目地址 ＝ 取数据_通用型 (临时_项目)
    SendMessageA (集_目标句柄, 4102, 0, 临时_项目地址)

.子程序 置图片, , 公开
    .参数 表项索引, 整数型, , 用于指定列表框中的某一项目，索引值从 0 开始。
    .参数 列索引, 整数型, 可空, 可以被省略。用作指定报表型列表框中项目所处的列，索引值从 0 开始，如果当前列表框类型不是报表型列表框，提供 0 值即可。如果本参数被省略，默认值为 0 。
    .参数 图片索引, 整数型, 可空, 可以被省略。图片索引用于指定“图片组”属性中的某张图片。索引值从 0 开始，-1 表示无图片。如果本参数被省略，默认值为 -1 。
    .局部变量 临时_数据地址1, 整数型
    .局部变量 临时_项目地址, 整数型
    .局部变量 局部_外部项目, 超级列表框1
    .局部变量 临时_项目, 超级列表框0

    .如果真 (集_外部控件)
        ' 集_进程句柄 ＝ 外部控件操作.打开进程 (集_目标句柄)
        临时_数据地址1 ＝ 集_外部控件操作.分配外部指针 (集_进程句柄, 40)
        局部_外部项目.表项索引 ＝ 表项索引
        局部_外部项目.子项目 ＝ 列索引
        局部_外部项目.掩码 ＝ 2
        局部_外部项目.图片索引 ＝ 图片索引
        临时_项目地址 ＝ 取数据_通用型 (局部_外部项目)
        集_外部控件操作.写进程内存 (集_进程句柄, 临时_数据地址1, 临时_项目地址, 40)
        SendMessageA (集_目标句柄, 4102, 0, 临时_数据地址1)
        集_外部控件操作.销毁外部指针 (集_进程句柄, 临时_数据地址1)
        ' 外部控件操作.结束操作 (集_进程句柄)
        返回 ()
    .如果真结束
    临时_项目.项目 ＝ 表项索引
    临时_项目.子项目 ＝ 列索引
    临时_项目.掩码 ＝ 2
    临时_项目.图片索引 ＝ 图片索引
    临时_项目地址 ＝ 取数据_通用型 (临时_项目)
    SendMessageA (集_目标句柄, 4102, 0, 临时_项目地址)

.子程序 置状态图片, , 公开
    .参数 表项索引, 整数型, , 用于指定列表框中的某一项目，索引值从 0 开始。
    .参数 状态图片索引, 整数型, 可空, 可以被省略。状态图片索引用于指定“状态图片组”属性中的某张图片。索引值从 0 开始，-1 表示无图片。如果本参数被省略，默认值为 -1 。
    .局部变量 临时_数据地址1, 整数型
    .局部变量 临时_项目地址, 整数型
    .局部变量 局部_外部项目, 超级列表框1
    .局部变量 临时_项目, 超级列表框0

    .如果真 (是否为空 (状态图片索引))
        状态图片索引 ＝ -1
    .如果真结束
    .如果真 (集_外部控件)
        ' 集_进程句柄 ＝ 外部控件操作.打开进程 (集_目标句柄)
        临时_数据地址1 ＝ 集_外部控件操作.分配外部指针 (集_进程句柄, 40)
        局部_外部项目.表项索引 ＝ 表项索引
        局部_外部项目.掩码 ＝ 8
        局部_外部项目.状态 ＝ (状态图片索引 ＋ 1) × 4096
        局部_外部项目.状态掩码 ＝ -4096
        临时_项目地址 ＝ 取数据_通用型 (局部_外部项目)
        集_外部控件操作.写进程内存 (集_进程句柄, 临时_数据地址1, 临时_项目地址, 40)
        SendMessageA (集_目标句柄, 4102, 0, 临时_数据地址1)
        集_外部控件操作.销毁外部指针 (集_进程句柄, 临时_数据地址1)
        ' 外部控件操作.结束操作 (集_进程句柄)
        返回 ()
    .如果真结束
    临时_项目.项目 ＝ 表项索引
    临时_项目.掩码 ＝ 8
    临时_项目.状态 ＝ (状态图片索引 ＋ 1) × 4096
    临时_项目.状态掩码 ＝ -4096
    临时_项目地址 ＝ 取数据_通用型 (临时_项目)
    SendMessageA (集_目标句柄, 4139, 表项索引, 临时_项目地址)

.子程序 置缩进数目, , 公开, 设置指定表项的缩进数目。
    .参数 表项索引, 整数型, , 用于指定列表框中的某一项目，索引值从 0 开始。
    .参数 缩进数目, 整数型, 可空, 可以被省略。“缩进数目”仅在报表型列表框才有效，用作指定显示时在表项首部增加的空白数。如果本参数被省略，默认值为 0 。
    .局部变量 临时_数据地址1, 整数型
    .局部变量 临时_项目地址, 整数型
    .局部变量 局部_外部项目, 超级列表框1
    .局部变量 临时_项目, 超级列表框0

    .如果真 (集_外部控件)
        ' 集_进程句柄 ＝ 外部控件操作.打开进程 (集_目标句柄)
        临时_数据地址1 ＝ 集_外部控件操作.分配外部指针 (集_进程句柄, 40)
        局部_外部项目.表项索引 ＝ 表项索引
        局部_外部项目.掩码 ＝ 16
        局部_外部项目.缩进 ＝ 缩进数目
        临时_项目地址 ＝ 取数据_通用型 (局部_外部项目)
        集_外部控件操作.写进程内存 (集_进程句柄, 临时_数据地址1, 临时_项目地址, 40)
        SendMessageA (集_目标句柄, 4102, 0, 临时_数据地址1)
        集_外部控件操作.销毁外部指针 (集_进程句柄, 临时_数据地址1)
        ' 外部控件操作.结束操作 (集_进程句柄)
        返回 ()
    .如果真结束
    临时_项目.项目 ＝ 表项索引
    临时_项目.掩码 ＝ 16
    临时_项目.缩进 ＝ 缩进数目
    临时_项目地址 ＝ 取数据_通用型 (临时_项目)
    SendMessageA (集_目标句柄, 4102, 0, 临时_项目地址)

.子程序 置表项数值, , 公开, 设置与指定表项相关联的数值
    .参数 表项索引, 整数型, , 用于指定列表框中的某一项目，索引值从 0 开始。
    .参数 表项数值, 整数型, 可空, 可以被省略。该数值与指定表项相关联。如果本参数被省略，默认值为 0 。
    .局部变量 临时_数据地址1, 整数型
    .局部变量 临时_项目地址, 整数型
    .局部变量 局部_外部项目, 超级列表框1
    .局部变量 临时_项目, 超级列表框0

    .如果真 (集_外部控件)
        ' 集_进程句柄 ＝ 外部控件操作.打开进程 (集_目标句柄)
        临时_数据地址1 ＝ 集_外部控件操作.分配外部指针 (集_进程句柄, 40)
        局部_外部项目.表项索引 ＝ 表项索引
        局部_外部项目.掩码 ＝ 4
        局部_外部项目.项目数值 ＝ 表项数值
        临时_项目地址 ＝ 取数据_通用型 (局部_外部项目)
        集_外部控件操作.写进程内存 (集_进程句柄, 临时_数据地址1, 临时_项目地址, 40)
        SendMessageA (集_目标句柄, 4102, 0, 临时_数据地址1)
        集_外部控件操作.销毁外部指针 (集_进程句柄, 临时_数据地址1)
        ' 外部控件操作.结束操作 (集_进程句柄)
        返回 ()
    .如果真结束
    临时_项目.项目 ＝ 表项索引
    临时_项目.掩码 ＝ 4
    临时_项目.项目数值 ＝ 表项数值
    临时_项目地址 ＝ 取数据_通用型 (临时_项目)
    SendMessageA (集_目标句柄, 4102, 0, 临时_项目地址)

.子程序 取被选择表项, 变体型, 公开, 返回一个整数数组，內含所有当前被选择表项的位置索引。如果当前没有被选择表项，返回空数组。
    .局部变量 局_选中项索引, 变体型
    .局部变量 局_成员数, 整数型
    .局部变量 局_计次, 整数型
    .局部变量 局_选中项索引A, 整数型, , "0"

    局_选中项索引.置类型 (#变体类型.数值型数组)
    局_成员数 ＝ 取表项数 ()
    .变量循环首 (1, 局_成员数, 1, 局_计次)
        .如果真 (是否被选择 (局_计次 － 1))
            加入成员 (局_选中项索引A, 局_计次 － 1)
        .如果真结束
        
    .变量循环尾 ()
    局_选中项索引.赋值 (局_选中项索引A, )
    返回 (局_选中项索引)

.子程序 取被选中表项, 变体型, 公开, 如果“是否有检查框”属性为真，返回当前所有检查框被选中的表项位置索引
    .局部变量 局_选中项索引, 变体型
    .局部变量 局_成员数, 整数型
    .局部变量 局_计次, 整数型
    .局部变量 局_选中项索引A, 整数型, , "0"

    局_选中项索引.置类型 (#变体类型.数值型数组)
    局_成员数 ＝ 取表项数 ()
    .变量循环首 (1, 局_成员数, 1, 局_计次)
        .如果真 (取当前状态图片 (局_计次 － 1) ≠ 0)
            加入成员 (局_选中项索引A, 局_计次 － 1)
        .如果真结束
        
    .变量循环尾 ()
    局_选中项索引.赋值 (局_选中项索引A, )
    返回 (局_选中项索引)

.子程序 取已选择表项数, 整数型, 公开, 返回当前已被选择表项的数目
    返回 (SendMessageA (集_目标句柄, #LVM_GETSELECTEDCOUNT, 0, 0))

.子程序 是否被选择, 逻辑型, 公开, 判断指定表项是否已经被选择，如已被选择，返回真，否则返回假。
    .参数 表项索引, 整数型, , 用于指定列表框中的某一项目，索引值从 0 开始。

    返回 (SendMessageA (集_目标句柄, #LVM_GETITEMSTATE, 表项索引, 2) ＝ 2)

.子程序 选择表项, , 公开
    .参数 表项索引, 整数型, , 用于指定列表框中的某一项目，索引值从 0 开始。
    .局部变量 临时_数据地址1, 整数型
    .局部变量 临时_项目地址, 整数型
    .局部变量 局部_外部项目, 超级列表框1
    .局部变量 临时_项目, 超级列表框0

    .如果真 (集_外部控件)
        ' '集_进程句柄 ＝ 外部控件操作.打开进程 (集_目标句柄)
        临时_数据地址1 ＝ 集_外部控件操作.分配外部指针 (集_进程句柄, 40)
        局部_外部项目.表项索引 ＝ 表项索引
        局部_外部项目.掩码 ＝ 8
        局部_外部项目.状态 ＝ 2
        局部_外部项目.状态掩码 ＝ 2
        临时_项目地址 ＝ 取数据_通用型 (局部_外部项目)
        集_外部控件操作.写进程内存 (集_进程句柄, 临时_数据地址1, 临时_项目地址, 40)
        SendMessageA (集_目标句柄, 4139, 表项索引, 临时_数据地址1)
        集_外部控件操作.销毁外部指针 (集_进程句柄, 临时_数据地址1)
        ' 外部控件操作.结束操作 (集_进程句柄)
        返回 ()
    .如果真结束
    临时_项目.项目 ＝ 表项索引
    临时_项目.掩码 ＝ 8
    临时_项目.状态 ＝ 2
    临时_项目.状态掩码 ＝ 2
    临时_项目地址 ＝ 取数据_通用型 (临时_项目)
    SendMessageA (集_目标句柄, #LVM_SETITEMSTATE, 表项索引, 临时_项目地址)

.子程序 取消表项选择, , 公开, 取消对指定表项的选择。
    .参数 表项索引, 整数型, , 用于指定列表框中的某一项目，索引值从 0 开始。
    .局部变量 临时_数据地址1, 整数型
    .局部变量 临时_项目地址, 整数型
    .局部变量 局部_外部项目, 超级列表框1
    .局部变量 临时_项目, 超级列表框0

    .如果真 (集_外部控件)
        ' 集_进程句柄 ＝ 外部控件操作.打开进程 (集_目标句柄)
        临时_数据地址1 ＝ 集_外部控件操作.分配外部指针 (集_进程句柄, 40)
        局部_外部项目.表项索引 ＝ 表项索引
        局部_外部项目.掩码 ＝ 8
        局部_外部项目.状态 ＝ 位取反 (2)
        局部_外部项目.状态掩码 ＝ 2
        临时_项目地址 ＝ 取数据_通用型 (局部_外部项目)
        集_外部控件操作.写进程内存 (集_进程句柄, 临时_数据地址1, 临时_项目地址, 40)
        SendMessageA (集_目标句柄, 4102, 表项索引, 临时_数据地址1)
        集_外部控件操作.销毁外部指针 (集_进程句柄, 临时_数据地址1)
        ' 外部控件操作.结束操作 (集_进程句柄)
        返回 ()
    .如果真结束
    临时_项目.项目 ＝ 表项索引
    临时_项目.掩码 ＝ 8
    临时_项目.状态 ＝ 位取反 (2)
    临时_项目.状态掩码 ＝ 2
    临时_项目地址 ＝ 取数据_通用型 (临时_项目)
    SendMessageA (集_目标句柄, #LVM_SETITEMSTATE, 表项索引, 临时_项目地址)

.子程序 插入表项, 整数型, 公开
    .参数 插入位置, 整数型, 可空, 可以被省略。指定新表项插入时的位置索引，索引值从 0 开始。如果提供 -1 ，则插入到列表框的尾部。如果本参数被省略，默认值为 -1 。
    .参数 标题, 文本型, 可空, 可以被省略。本参数指定表项的标题文本。如果被省略，默认值为空文本。
    .参数 图片索引, 整数型, 可空, 可以被省略。图片索引用于指定“图片组”属性中的某张图片。索引值从 0 开始，-1 表示无图片。如果本参数被省略，默认值为 -1 。
    .参数 状态图片索引, 整数型, 可空, 可以被省略。状态图片索引用于指定“状态图片组”属性中的某张图片。索引值从 0 开始，-1 表示无图片。如果本参数被省略，默认值为 -1 。
    .参数 缩进数目, 整数型, 可空, 可以被省略。“缩进数目”仅在报表型列表框才有效，用作指定显示时在表项首部增加的空白数。如果本参数被省略，默认值为 0 。
    .参数 表项数值, 整数型, 可空, 可以被省略。该数值与指定表项相关联。如果本参数被省略，默认值为 0 。
    .局部变量 临时_数据地址1, 整数型
    .局部变量 临时_数据地址2, 整数型
    .局部变量 临时_项目地址, 整数型
    .局部变量 局_数值, 整数型
    .局部变量 局部_外部项目, 超级列表框1
    .局部变量 临时_项目, 超级列表框0

    .如果真 (是否为空 (图片索引))
        图片索引 ＝ -1
    .如果真结束
    .如果真 (是否为空 (状态图片索引))
        状态图片索引 ＝ -1
    .如果真结束
    .判断开始 (集_外部控件)
        .判断开始 (是否为空 (插入位置) 或 插入位置 ＝ -1)
            局部_外部项目.表项索引 ＝ 取表项数 ()
        .默认
            局部_外部项目.表项索引 ＝ 插入位置
        .判断结束
        ' 集_进程句柄 ＝ 外部控件操作.打开进程 (集_目标句柄)
        临时_数据地址1 ＝ 集_外部控件操作.分配外部指针 (集_进程句柄, 40)
        临时_数据地址2 ＝ 集_外部控件操作.分配外部指针 (集_进程句柄, 取字节集长度 (到字节集 (标题)) ＋ 1)
        局部_外部项目.掩码 ＝ 4103 ＋ 8
        局部_外部项目.状态 ＝ 位取反 (2)
        局部_外部项目.项目文本 ＝ 临时_数据地址2
        局部_外部项目.项目文本长度 ＝ 取字节集长度 (到字节集 (标题)) ＋ 1
        
        局部_外部项目.图片索引 ＝ 图片索引
        局部_外部项目.状态 ＝ (状态图片索引 ＋ 1) × 4096
        局部_外部项目.状态掩码 ＝ -4096
        局部_外部项目.缩进 ＝ 缩进数目
        局部_外部项目.项目数值 ＝ 表项数值
        临时_项目地址 ＝ 取数据_通用型 (局部_外部项目)
        局_数值 ＝ lstrcpyn_文本型 (标题, 标题, 0)
        集_外部控件操作.写进程内存 (集_进程句柄, 临时_数据地址1, 临时_项目地址, 40)
        集_外部控件操作.写进程内存 (集_进程句柄, 临时_数据地址2, 局_数值, 取字节集长度 (到字节集 (标题)) ＋ 1)
        局_数值 ＝ SendMessageA (集_目标句柄, 4103, 0, 临时_数据地址1)
        集_外部控件操作.销毁外部指针 (集_进程句柄, 临时_数据地址1)
        集_外部控件操作.销毁外部指针 (集_进程句柄, 临时_数据地址2)
        ' 外部控件操作.结束操作 (集_进程句柄)
        返回 (局_数值)
    .默认
        .判断开始 (是否为空 (插入位置) 或 插入位置 ＝ -1)
            临时_项目.项目 ＝ 取表项数 ()
        .默认
            临时_项目.项目 ＝ 插入位置
        .判断结束
        临时_项目.掩码 ＝ 4103 ＋ 8
        临时_项目.项目文本 ＝ 标题
        临时_项目.项目文本长度 ＝ 取字节集长度 (到字节集 (标题)) ＋ 1
        临时_项目.图片索引 ＝ 图片索引
        临时_项目.状态 ＝ (状态图片索引 ＋ 1) × 4096
        临时_项目.状态掩码 ＝ -4096
        临时_项目.缩进 ＝ 缩进数目
        临时_项目.项目数值 ＝ 表项数值
        临时_项目地址 ＝ 取数据_通用型 (临时_项目)
        返回 (SendMessageA (集_目标句柄, 4103, 0, 临时_项目地址))
    .判断结束
    

.子程序 高速插入表项, , 公开
    .参数 插入位置, 整数型, 可空, 可以被省略。指定新表项插入时的位置索引，索引值从 0 开始。如果提供 -1 ，则插入到列表框的尾部。如果本参数被省略，默认值为 -1 。
    .参数 列表框信息, 列表框信息, 数组
    .参数 排序方式, 整数型, 可空, 可以被省略。指定新新插入数据的排序方式。默认为“#排序方式_不排序”。如要逆向排序，请将常量位取反。如要对指定列排序，请用#排序方式_表项列标题排序+要排序的列索引
    .局部变量 临时_项目地址, 整数型
    .局部变量 临时_数据地址1, 整数型
    .局部变量 临时_数据地址2, 整数型

    .局部变量 局_信息1, 列表框信息
    .局部变量 局_信息2, 列表框信息, , "0"
    .局部变量 局_信息3, 整数型
    .局部变量 局_计次1, 整数型
    .局部变量 局_成员数, 整数型
    .局部变量 局_数据列, 文本型, , "0"
    .局部变量 局_当前索引, 整数型
    .局部变量 局_计次2, 整数型
    .局部变量 局_列图片成员数, 整数型
    .局部变量 局_列标题成员数, 整数型
    .局部变量 局_列成员数, 整数型
    .局部变量 局部_外部项目, 超级列表框1
    .局部变量 临时_列, 超级列表框7
    .局部变量 临时_项目, 超级列表框0

    局_信息2 ＝ 列表框信息
    快速排序 (局_信息2, , , 排序方式)
    局_成员数 ＝ 取数组成员数 (局_信息2)
    SendMessageA (集_目标句柄, 11, 0, 0)
    .判断开始 (集_外部控件)
        .判断开始 (是否为空 (插入位置) 或 插入位置 ＝ -1)
            局部_外部项目.表项索引 ＝ 取表项数 ()
        .默认
            局部_外部项目.表项索引 ＝ 插入位置
        .判断结束
        局部_外部项目.掩码 ＝ 4103 ＋ 8
        局部_外部项目.状态掩码 ＝ -4096
        ' 集_进程句柄 ＝ 外部控件操作.打开进程 (集_目标句柄)
        临时_数据地址1 ＝ 集_外部控件操作.分配外部指针 (集_进程句柄, 40)
        临时_项目地址 ＝ 取数据_通用型 (局部_外部项目)
        .判断循环首 (局_计次1 ＜ 局_成员数)
            局部_外部项目.表项索引 ＝ 插入位置 ＋ 局_计次1
            局_计次1 ＝ 局_计次1 ＋ 1
            局部_外部项目.子项目 ＝ 0
            临时_数据地址2 ＝ 集_外部控件操作.分配外部指针 (集_进程句柄, 取文本长度 (局_信息2 [局_计次1].标题) ＋ 1)
            局部_外部项目.项目文本 ＝ 临时_数据地址2
            局部_外部项目.状态 ＝ (局_信息2 [局_计次1].状态图片索引 ＋ 1) × 4096
            局部_外部项目.图片索引 ＝ 局_信息2 [局_计次1].图片索引
            局部_外部项目.缩进 ＝ 局_信息2 [局_计次1].缩进数目
            局部_外部项目.项目数值 ＝ 局_信息2 [局_计次1].表项数值
            局部_外部项目.项目文本长度 ＝ 取字节集长度 (到字节集 (局_信息2 [局_计次1].标题)) ＋ 1
            局_信息3 ＝ lstrcpyn_文本型 (局_信息2 [局_计次1].标题, 局_信息2 [局_计次1].标题, 0)
            集_外部控件操作.写进程内存 (集_进程句柄, 临时_数据地址1, 临时_项目地址, 40)
            集_外部控件操作.写进程内存 (集_进程句柄, 临时_数据地址2, 局_信息3, 取文本长度 (局_信息2 [局_计次1].标题) ＋ 1)
            局_当前索引 ＝ SendMessageA (集_目标句柄, 4103, 0, 临时_数据地址1)
            集_外部控件操作.销毁外部指针 (集_进程句柄, 临时_数据地址2)
            .如果真 (局_当前索引 ≠ -1)
                局_列图片成员数 ＝ 取数组成员数 (局_信息2 [局_计次1].列图片索引)
                局_列标题成员数 ＝ 取数组成员数 (局_信息2 [局_计次1].列标题)
                局_列成员数 ＝ 选择 (局_列标题成员数 ＞ 局_列图片成员数, 局_列标题成员数, 局_列图片成员数)
                .判断循环首 (局_计次2 ＜ 局_列成员数)
                    局_计次2 ＝ 局_计次2 ＋ 1
                    局部_外部项目.子项目 ＝ 局_计次2 － 1
                    .判断开始 (局_计次2 ≤ 局_列标题成员数)
                        临时_数据地址2 ＝ 集_外部控件操作.分配外部指针 (集_进程句柄, 取文本长度 (局_信息2 [局_计次1].列标题 [局_计次2]) ＋ 1)
                        局_信息3 ＝ lstrcpyn_文本型 (局_信息2 [局_计次1].列标题 [局_计次2], 局_信息2 [局_计次1].列标题 [局_计次2], 0)
                        集_外部控件操作.写进程内存 (集_进程句柄, 临时_数据地址2, 局_信息3, 取文本长度 (局_信息2 [局_计次1].列标题 [局_计次2]) ＋ 1)
                        局部_外部项目.项目文本 ＝ 临时_数据地址2 ' TEMP2 [I].列标题 [I2]
                        局部_外部项目.项目文本长度 ＝ 取文本长度 (局_信息2 [局_计次1].列标题 [局_计次2]) ＋ 1
                        
                        局部_外部项目.掩码 ＝ 1
                    .默认
                        局部_外部项目.项目文本 ＝ 0
                        局部_外部项目.掩码 ＝ 0
                    .判断结束
                    .判断开始 (局_计次2 ≤ 局_列图片成员数)
                        局部_外部项目.图片索引 ＝ 局_信息2 [局_计次1].列图片索引 [局_计次2]
                        局部_外部项目.掩码 ＝ 位或 (局部_外部项目.掩码, 2)
                    .默认
                        局部_外部项目.图片索引 ＝ 0
                    .判断结束
                    集_外部控件操作.写进程内存 (集_进程句柄, 临时_数据地址1, 临时_项目地址, 40)
                    SendMessageA (集_目标句柄, 4102, 0, 临时_数据地址1)
                    .如果真 (局部_外部项目.项目文本 ≠ 0)
                        集_外部控件操作.销毁外部指针 (集_进程句柄, 临时_数据地址2)
                    .如果真结束
                    
                .判断循环尾 ()
                局_计次2 ＝ 0
                局部_外部项目.掩码 ＝ 4103 ＋ 8
                局部_外部项目.状态掩码 ＝ -4096
            .如果真结束
            
        .判断循环尾 ()
        集_外部控件操作.销毁外部指针 (集_进程句柄, 临时_数据地址1)
        ' 外部控件操作.结束操作 (集_进程句柄)
    .默认
        
        .判断开始 (是否为空 (插入位置) 或 插入位置 ＝ -1)
            临时_项目.项目 ＝ 取表项数 ()
        .默认
            临时_项目.项目 ＝ 插入位置
        .判断结束
        临时_项目.掩码 ＝ 4103 ＋ 8
        临时_项目.状态掩码 ＝ -4096
        临时_项目地址 ＝ 取数据_通用型 (临时_项目)
        .判断循环首 (局_计次1 ＜ 局_成员数)
            临时_项目.项目 ＝ 插入位置 ＋ 局_计次1
            局_计次1 ＝ 局_计次1 ＋ 1
            临时_项目.子项目 ＝ 0
            临时_项目.项目文本 ＝ 局_信息2 [局_计次1].标题
            临时_项目.状态 ＝ (局_信息2 [局_计次1].状态图片索引 ＋ 1) × 4096
            临时_项目.图片索引 ＝ 局_信息2 [局_计次1].图片索引
            临时_项目.缩进 ＝ 局_信息2 [局_计次1].缩进数目
            临时_项目.项目数值 ＝ 局_信息2 [局_计次1].表项数值
            局_当前索引 ＝ SendMessageA (集_目标句柄, 4103, 0, 临时_项目地址)
            .如果真 (局_当前索引 ≠ -1)
                局_列图片成员数 ＝ 取数组成员数 (局_信息2 [局_计次1].列图片索引)
                局_列标题成员数 ＝ 取数组成员数 (局_信息2 [局_计次1].列标题)
                局_列成员数 ＝ 选择 (局_列标题成员数 ＞ 局_列图片成员数, 局_列标题成员数, 局_列图片成员数)
                .判断循环首 (局_计次2 ＜ 局_列成员数)
                    局_计次2 ＝ 局_计次2 ＋ 1
                    临时_项目.子项目 ＝ 局_计次2 － 1
                    .判断开始 (局_计次2 ≤ 局_列标题成员数)
                        临时_项目.项目文本 ＝ 局_信息2 [局_计次1].列标题 [局_计次2]
                        临时_项目.掩码 ＝ 1
                    .默认
                        临时_项目.项目文本 ＝ “”
                        临时_项目.掩码 ＝ 0
                    .判断结束
                    .判断开始 (局_计次2 ≤ 局_列图片成员数)
                        临时_项目.图片索引 ＝ 局_信息2 [局_计次1].列图片索引 [局_计次2]
                        临时_项目.掩码 ＝ 位或 (临时_项目.掩码, 2)
                    .默认
                        临时_项目.图片索引 ＝ 0
                    .判断结束
                    SendMessageA (集_目标句柄, 4102, 0, 临时_项目地址)
                .判断循环尾 ()
                局_计次2 ＝ 0
                临时_项目.掩码 ＝ 4103 ＋ 8
                临时_项目.状态掩码 ＝ -4096
            .如果真结束
            
        .判断循环尾 ()
    .判断结束
    SendMessageA (集_目标句柄, 11, 1, 0)

.子程序 快速排序
    .参数 列表框信息, 列表框信息, 数组
    .参数 左边, 整数型, 可空
    .参数 右边, 整数型, 可空
    .参数 排序方式, 整数型
    .局部变量 局_基准点, 整数型
    .局部变量 局_基准值, 列表框信息
    .局部变量 局_计次1, 整数型
    .局部变量 局_计次2, 整数型
    .局部变量 局_列排序, 整数型

    .如果真 (排序方式 ＝ 0 或 排序方式 ＝ -1)
        返回 ()
    .如果真结束
    .如果真 (是否为空 (左边))
        左边 ＝ 1
    .如果真结束
    .如果真 (是否为空 (右边))
        右边 ＝ 取数组成员数 (列表框信息)
    .如果真结束
    .如果真 (左边 ≥ 右边)
        返回 ()
    .如果真结束
    局_计次1 ＝ 左边
    局_计次2 ＝ 右边
    局_基准值 ＝ 列表框信息 [左边]
    .判断开始 (排序方式 ＞ 0)
        .判断开始 (位与 (排序方式, 2048) ≠ 2048 或 位异或 (排序方式, 2048) ＝ 0)
            ' 项目排序
            .判断开始 (排序方式 ＝ 1 或 位异或 (排序方式, 2048) ＝ 0)
                .判断循环首 (局_计次1 ＜ 局_计次2) ' 循环直至左右指针相遇
                    .判断循环首 (局_计次1 ＜ 局_计次2 且 列表框信息 [局_计次2].标题 ≥ 局_基准值.标题) ' 向左侧寻找小于基准值的元素
                        局_计次2 ＝ 局_计次2 － 1
                    .判断循环尾 ()
                    .如果真 (局_计次1 ＜ 局_计次2)
                        列表框信息 [局_计次1] ＝ 列表框信息 [局_计次2] ' 交换i和j的值
                        局_计次1 ＝ 局_计次1 ＋ 1
                    .如果真结束
                    .判断循环首 (局_计次1 ＜ 局_计次2 且 列表框信息 [局_计次1].标题 ≤ 局_基准值.标题) ' 向右侧寻找大于基准值的元素
                        局_计次1 ＝ 局_计次1 ＋ 1
                    .判断循环尾 ()
                    .如果真 (局_计次1 ＜ 局_计次2)
                        列表框信息 [局_计次2] ＝ 列表框信息 [局_计次1] ' 交换i和j的值
                        局_计次2 ＝ 局_计次2 － 1
                    .如果真结束
                    
                .判断循环尾 ()
            .判断 (排序方式 ＝ 2)
                .判断循环首 (局_计次1 ＜ 局_计次2) ' 循环直至左右指针相遇
                    .判断循环首 (局_计次1 ＜ 局_计次2 且 列表框信息 [局_计次2].图片索引 ≥ 局_基准值.图片索引) ' 向左侧寻找小于基准值的元素
                        局_计次2 ＝ 局_计次2 － 1
                    .判断循环尾 ()
                    .如果真 (局_计次1 ＜ 局_计次2)
                        列表框信息 [局_计次1] ＝ 列表框信息 [局_计次2] ' 交换i和j的值
                        局_计次1 ＝ 局_计次1 ＋ 1
                    .如果真结束
                    .判断循环首 (局_计次1 ＜ 局_计次2 且 列表框信息 [局_计次1].图片索引 ≤ 局_基准值.图片索引) ' 向右侧寻找大于基准值的元素
                        局_计次1 ＝ 局_计次1 ＋ 1
                    .判断循环尾 ()
                    .如果真 (局_计次1 ＜ 局_计次2)
                        列表框信息 [局_计次2] ＝ 列表框信息 [局_计次1] ' 交换i和j的值
                        局_计次2 ＝ 局_计次2 － 1
                    .如果真结束
                    
                .判断循环尾 ()
            .判断 (排序方式 ＝ 3)
                .判断循环首 (局_计次1 ＜ 局_计次2) ' 循环直至左右指针相遇
                    .判断循环首 (局_计次1 ＜ 局_计次2 且 列表框信息 [局_计次2].状态图片索引 ≥ 局_基准值.状态图片索引) ' 向左侧寻找小于基准值的元素
                        局_计次2 ＝ 局_计次2 － 1
                    .判断循环尾 ()
                    .如果真 (局_计次1 ＜ 局_计次2)
                        列表框信息 [局_计次1] ＝ 列表框信息 [局_计次2] ' 交换i和j的值
                        局_计次1 ＝ 局_计次1 ＋ 1
                    .如果真结束
                    .判断循环首 (局_计次1 ＜ 局_计次2 且 列表框信息 [局_计次1].状态图片索引 ≤ 局_基准值.状态图片索引) ' 向右侧寻找大于基准值的元素
                        局_计次1 ＝ 局_计次1 ＋ 1
                    .判断循环尾 ()
                    .如果真 (局_计次1 ＜ 局_计次2)
                        列表框信息 [局_计次2] ＝ 列表框信息 [局_计次1] ' 交换i和j的值
                        局_计次2 ＝ 局_计次2 － 1
                    .如果真结束
                    
                .判断循环尾 ()
            .判断 (排序方式 ＝ 4)
                .判断循环首 (局_计次1 ＜ 局_计次2) ' 循环直至左右指针相遇
                    .判断循环首 (局_计次1 ＜ 局_计次2 且 列表框信息 [局_计次2].表项数值 ≥ 局_基准值.表项数值) ' 向左侧寻找小于基准值的元素
                        局_计次2 ＝ 局_计次2 － 1
                    .判断循环尾 ()
                    .如果真 (局_计次1 ＜ 局_计次2)
                        列表框信息 [局_计次1] ＝ 列表框信息 [局_计次2] ' 交换i和j的值
                        局_计次1 ＝ 局_计次1 ＋ 1
                    .如果真结束
                    .判断循环首 (局_计次1 ＜ 局_计次2 且 列表框信息 [局_计次1].表项数值 ≤ 局_基准值.表项数值) ' 向右侧寻找大于基准值的元素
                        局_计次1 ＝ 局_计次1 ＋ 1
                    .判断循环尾 ()
                    .如果真 (局_计次1 ＜ 局_计次2)
                        列表框信息 [局_计次2] ＝ 列表框信息 [局_计次1] ' 交换i和j的值
                        局_计次2 ＝ 局_计次2 － 1
                    .如果真结束
                    
                .判断循环尾 ()
            .默认
                
            .判断结束
            
        .默认
            ' 列排序
            局_列排序 ＝ 位异或 (排序方式, 2048)
            ' 取得要排序的列索引数
            .判断循环首 (局_计次1 ＜ 局_计次2) ' 循环直至左右指针相遇
                .判断循环首 (局_计次1 ＜ 局_计次2 且 列表框信息 [局_计次2].列标题 [局_列排序] ≥ 局_基准值.列标题 [局_列排序]) ' 向左侧寻找小于基准值的元素
                    局_计次2 ＝ 局_计次2 － 1
                .判断循环尾 ()
                .如果真 (局_计次1 ＜ 局_计次2)
                    列表框信息 [局_计次1] ＝ 列表框信息 [局_计次2] ' 交换i和j的值
                    局_计次1 ＝ 局_计次1 ＋ 1
                .如果真结束
                .判断循环首 (局_计次1 ＜ 局_计次2 且 列表框信息 [局_计次1].列标题 [局_列排序] ≤ 局_基准值.列标题 [局_列排序]) ' 向右侧寻找大于基准值的元素
                    局_计次1 ＝ 局_计次1 ＋ 1
                .判断循环尾 ()
                .如果真 (局_计次1 ＜ 局_计次2)
                    列表框信息 [局_计次2] ＝ 列表框信息 [局_计次1] ' 交换i和j的值
                    局_计次2 ＝ 局_计次2 － 1
                .如果真结束
                
            .判断循环尾 ()
            
        .判断结束
        
    .默认
        ' 排序方式 ＝ 位取反(排序方式)
        ' 逆排方式
        .判断开始 (位与 (位取反 (排序方式), 2048) ≠ 2048 或 位异或 (位取反 (排序方式), 2048) ＝ 0)
            ' 项目排序
            .判断开始 (位取反 (排序方式) ＝ 1 或 位异或 (位取反 (排序方式), 2048) ＝ 0)
                .判断循环首 (局_计次1 ＜ 局_计次2) ' 循环直至左右指针相遇
                    .判断循环首 (局_计次1 ＜ 局_计次2 且 列表框信息 [局_计次2].标题 ≤ 局_基准值.标题) ' 向左侧寻找小于基准值的元素
                        局_计次2 ＝ 局_计次2 － 1
                    .判断循环尾 ()
                    .如果真 (局_计次1 ＜ 局_计次2)
                        列表框信息 [局_计次1] ＝ 列表框信息 [局_计次2] ' 交换i和j的值
                        局_计次1 ＝ 局_计次1 ＋ 1
                    .如果真结束
                    .判断循环首 (局_计次1 ＜ 局_计次2 且 列表框信息 [局_计次1].标题 ≥ 局_基准值.标题) ' 向右侧寻找大于基准值的元素
                        局_计次1 ＝ 局_计次1 ＋ 1
                    .判断循环尾 ()
                    .如果真 (局_计次1 ＜ 局_计次2)
                        列表框信息 [局_计次2] ＝ 列表框信息 [局_计次1] ' 交换i和j的值
                        局_计次2 ＝ 局_计次2 － 1
                    .如果真结束
                    
                .判断循环尾 ()
            .判断 (位取反 (排序方式) ＝ 2)
                .判断循环首 (局_计次1 ＜ 局_计次2) ' 循环直至左右指针相遇
                    .判断循环首 (局_计次1 ＜ 局_计次2 且 列表框信息 [局_计次2].图片索引 ≤ 局_基准值.图片索引) ' 向左侧寻找小于基准值的元素
                        局_计次2 ＝ 局_计次2 － 1
                    .判断循环尾 ()
                    .如果真 (局_计次1 ＜ 局_计次2)
                        列表框信息 [局_计次1] ＝ 列表框信息 [局_计次2] ' 交换i和j的值
                        局_计次1 ＝ 局_计次1 ＋ 1
                    .如果真结束
                    .判断循环首 (局_计次1 ＜ 局_计次2 且 列表框信息 [局_计次1].图片索引 ≥ 局_基准值.图片索引) ' 向右侧寻找大于基准值的元素
                        局_计次1 ＝ 局_计次1 ＋ 1
                    .判断循环尾 ()
                    .如果真 (局_计次1 ＜ 局_计次2)
                        列表框信息 [局_计次2] ＝ 列表框信息 [局_计次1] ' 交换i和j的值
                        局_计次2 ＝ 局_计次2 － 1
                    .如果真结束
                    
                .判断循环尾 ()
            .判断 (位取反 (排序方式) ＝ 3)
                .判断循环首 (局_计次1 ＜ 局_计次2) ' 循环直至左右指针相遇
                    .判断循环首 (局_计次1 ＜ 局_计次2 且 列表框信息 [局_计次2].状态图片索引 ≤ 局_基准值.状态图片索引) ' 向左侧寻找小于基准值的元素
                        局_计次2 ＝ 局_计次2 － 1
                    .判断循环尾 ()
                    .如果真 (局_计次1 ＜ 局_计次2)
                        列表框信息 [局_计次1] ＝ 列表框信息 [局_计次2] ' 交换i和j的值
                        局_计次1 ＝ 局_计次1 ＋ 1
                    .如果真结束
                    .判断循环首 (局_计次1 ＜ 局_计次2 且 列表框信息 [局_计次1].状态图片索引 ≥ 局_基准值.状态图片索引) ' 向右侧寻找大于基准值的元素
                        局_计次1 ＝ 局_计次1 ＋ 1
                    .判断循环尾 ()
                    .如果真 (局_计次1 ＜ 局_计次2)
                        列表框信息 [局_计次2] ＝ 列表框信息 [局_计次1] ' 交换i和j的值
                        局_计次2 ＝ 局_计次2 － 1
                    .如果真结束
                    
                .判断循环尾 ()
            .判断 (位取反 (排序方式) ＝ 4)
                .判断循环首 (局_计次1 ＜ 局_计次2) ' 循环直至左右指针相遇
                    .判断循环首 (局_计次1 ＜ 局_计次2 且 列表框信息 [局_计次2].表项数值 ≤ 局_基准值.表项数值) ' 向左侧寻找小于基准值的元素
                        局_计次2 ＝ 局_计次2 － 1
                    .判断循环尾 ()
                    .如果真 (局_计次1 ＜ 局_计次2)
                        列表框信息 [局_计次1] ＝ 列表框信息 [局_计次2] ' 交换i和j的值
                        局_计次1 ＝ 局_计次1 ＋ 1
                    .如果真结束
                    .判断循环首 (局_计次1 ＜ 局_计次2 且 列表框信息 [局_计次1].表项数值 ≥ 局_基准值.表项数值) ' 向右侧寻找大于基准值的元素
                        局_计次1 ＝ 局_计次1 ＋ 1
                    .判断循环尾 ()
                    .如果真 (局_计次1 ＜ 局_计次2)
                        列表框信息 [局_计次2] ＝ 列表框信息 [局_计次1] ' 交换i和j的值
                        局_计次2 ＝ 局_计次2 － 1
                    .如果真结束
                    
                .判断循环尾 ()
            .默认
                
            .判断结束
            
        .默认
            ' 列排序
            局_列排序 ＝ 位异或 (位取反 (排序方式), 2048)
            ' 取得要排序的列索引数
            .如果真 (局_列排序 ＞ 取数组成员数 (列表框信息 [局_计次2].列标题))
                返回 ()
            .如果真结束
            .判断循环首 (局_计次1 ＜ 局_计次2) ' 循环直至左右指针相遇
                .判断循环首 (局_计次1 ＜ 局_计次2 且 列表框信息 [局_计次2].列标题 [局_列排序] ≤ 局_基准值.列标题 [局_列排序]) ' 向左侧寻找小于基准值的元素
                    局_计次2 ＝ 局_计次2 － 1
                .判断循环尾 ()
                .如果真 (局_计次1 ＜ 局_计次2)
                    列表框信息 [局_计次1] ＝ 列表框信息 [局_计次2] ' 交换i和j的值
                    局_计次1 ＝ 局_计次1 ＋ 1
                .如果真结束
                .判断循环首 (局_计次1 ＜ 局_计次2 且 列表框信息 [局_计次1].列标题 [局_列排序] ≥ 局_基准值.列标题 [局_列排序]) ' 向右侧寻找大于基准值的元素
                    局_计次1 ＝ 局_计次1 ＋ 1
                .判断循环尾 ()
                .如果真 (局_计次1 ＜ 局_计次2)
                    列表框信息 [局_计次2] ＝ 列表框信息 [局_计次1] ' 交换i和j的值
                    局_计次2 ＝ 局_计次2 － 1
                .如果真结束
                
            .判断循环尾 ()
            
        .判断结束
        
    .判断结束
    列表框信息 [局_计次1] ＝ 局_基准值 ' 前面把基准值弄丢了，这里补回来。
    快速排序 (列表框信息, 左边, 局_计次1 － 1, 排序方式)
    快速排序 (列表框信息, 局_计次1 ＋ 1, 右边, 排序方式)

.子程序 删除表项, , 公开
    .参数 表项索引, 整数型, , 用于指定列表框中的某一项目，索引值从 0 开始。

    SendMessageA (集_目标句柄, #LVM_DELETEITEM, 表项索引, 0)

.子程序 全部删除, , 公开
    SendMessageA (集_目标句柄, #LVM_DELETEALLITEMS, 0, 0)

.子程序 查找表项, 整数型, 公开
    .参数 标题, 文本型, , 本参数指定欲查找表项的标题文本。
    .参数 起始查找位置, 整数型, 可空, 可以被省略。本参数指定查找表项的起始位置。如果本参数被省略，默认值为 0  ，即从首项开始查找。
    .参数 是否精确匹配, 逻辑型, 可空, 可以被省略。本参数指定匹配标题文本时是否为精确匹配，如果本参数为假，则只要表项标题首部包含指定文本即认为匹配成功。如果本参数被省略，默认值为真。
    .参数 如果查找不到是否从头开始, 逻辑型, 可空, 可以被省略。本参数指定在查找标题文本时，如果从“起始查找位置”查找不到，是否从头开始查找。默认值为假。
    .局部变量 临时_项目地址, 整数型
    .局部变量 临时_数据地址1, 整数型
    .局部变量 临时_数据地址2, 整数型
    .局部变量 局_结构1, 超级列表框3
    .局部变量 局_结构2, 超级列表框4
    .局部变量 局_数值, 整数型

    .如果真 (集_外部控件)
        临时_数据地址1 ＝ 集_外部控件操作.分配外部指针 (集_进程句柄, 20)
        临时_数据地址2 ＝ 集_外部控件操作.分配外部指针 (集_进程句柄, 取文本长度 (标题) ＋ 1)
        局_结构2.flags ＝ 位或 (选择 (是否精确匹配, 2, 8), 选择 (如果查找不到是否从头开始 ＝ 真, 32, 0))
        局_结构2.LPCTSTR ＝ 临时_数据地址2
        临时_项目地址 ＝ 取数据_通用型 (局_结构2)
        局_数值 ＝ lstrcpyn_文本型 (标题, 标题, 0)
        集_外部控件操作.写进程内存 (集_进程句柄, 临时_数据地址1, 临时_项目地址, 20)
        集_外部控件操作.写进程内存 (集_进程句柄, 临时_数据地址2, 局_数值, 取文本长度 (标题) ＋ 1)
        局_数值 ＝ SendMessageA (集_目标句柄, 4109, 起始查找位置, 临时_数据地址1)
        集_外部控件操作.销毁外部指针 (集_进程句柄, 临时_数据地址1)
        集_外部控件操作.销毁外部指针 (集_进程句柄, 临时_数据地址2)
        返回 (局_数值)
    .如果真结束
    
    局_结构1.flags ＝ 位或 (选择 (是否精确匹配, 2, 8), 选择 (如果查找不到是否从头开始 ＝ 真, 32, 0))
    局_结构1.LPCTSTR ＝ 标题
    临时_项目地址 ＝ 取数据_通用型 (局_结构1)
    返回 (SendMessageA (集_目标句柄, 4109, 起始查找位置, 临时_项目地址))

.子程序 查找表项数值, 整数型, 公开
    .参数 起始查找位置, 整数型, 可空, 可以被省略。本参数指定查找表项的起始位置。如果本参数被省略，默认值为 0  ，即从首项开始查找。
    .参数 表项数值, 整数型, 可空, 可以被省略。该数值与指定表项相关联。如果本参数被省略，默认值为 0 。
    .参数 如果查找不到是否从头开始, 逻辑型, 可空, 可以被省略。本参数指定在查找标题文本时，如果从“起始查找位置”查找不到，是否从头开始查找。默认值为假。
    .局部变量 临时_项目地址, 整数型
    .局部变量 临时_数据地址1, 整数型
    .局部变量 局_结构1, 超级列表框3
    .局部变量 局_结构2, 超级列表框4
    .局部变量 局_数值, 整数型

    .如果真 (集_外部控件)
        
        临时_数据地址1 ＝ 集_外部控件操作.分配外部指针 (集_进程句柄, 20)
        局_结构2.flags ＝ 位或 (1, 选择 (如果查找不到是否从头开始 ＝ 真, 32, 0))
        局_结构2.lParam ＝ 表项数值
        临时_项目地址 ＝ 取数据_通用型 (局_结构2)
        集_外部控件操作.写进程内存 (集_进程句柄, 临时_数据地址1, 临时_项目地址, 20)
        局_数值 ＝ SendMessageA (集_目标句柄, 4109, 起始查找位置, 临时_数据地址1)
        集_外部控件操作.销毁外部指针 (集_进程句柄, 临时_数据地址1)
        
        返回 (局_数值)
        
    .如果真结束
    局_结构1.flags ＝ 位或 (1, 选择 (如果查找不到是否从头开始 ＝ 真, 32, 0))
    局_结构1.lParam ＝ 表项数值
    临时_项目地址 ＝ 取数据_通用型 (局_结构1)
    返回 (SendMessageA (集_目标句柄, 4109, 起始查找位置, 临时_项目地址))

.子程序 保证显示, , 公开
    .参数 表项索引, 整数型

    SendMessageA (集_目标句柄, #LVM_ENSUREVISIBLE, 表项索引, 1)

.子程序 排列图标, , 公开, 自动排列大图标或小图标列表框中的图标。
    SendMessageA (集_目标句柄, #LVM_ARRANGE, 0, 0)

.子程序 取列标题, 文本型, 公开, 返回报表型列表框中指定列的标题。
    .参数 列索引, 整数型, , 用作指定报表型列表框中项目所处的列，索引值从 0 开始。
    .局部变量 临时_项目地址, 整数型
    .局部变量 临时_数据地址1, 整数型
    .局部变量 临时_数据地址2, 整数型
    .局部变量 临时_外部列, 超级列表框8
    .局部变量 临时_列, 超级列表框7
    .局部变量 局_数据, 字节集


    .如果真 (集_外部控件)
        临时_外部列.mask ＝ 4 ' LVCF_TEXT    表示获取列的信息。
        
        临时_数据地址1 ＝ 集_外部控件操作.分配外部指针 (集_进程句柄, 32)
        临时_数据地址2 ＝ 集_外部控件操作.分配外部指针 (集_进程句柄, 260)
        临时_外部列.列标题 ＝ 临时_数据地址2
        临时_外部列.缓冲区长度 ＝ 260
        临时_项目地址 ＝ 取数据_通用型 (临时_外部列)
        集_外部控件操作.写进程内存 (集_进程句柄, 临时_数据地址1, 临时_项目地址, 32)
        ' LVM_GETCOLUMN=4121    ’表示获取列信息
        .判断开始 (SendMessageA (集_目标句柄, 4121, 列索引, 临时_数据地址1) ≠ 0)
            局_数据 ＝ 集_外部控件操作.读外部指针数据 (集_进程句柄, 临时_数据地址2, 260)
            集_外部控件操作.销毁外部指针 (集_进程句柄, 临时_数据地址1)
            集_外部控件操作.销毁外部指针 (集_进程句柄, 临时_数据地址2)
            
            返回 (到文本 (局_数据))
        .默认
            集_外部控件操作.销毁外部指针 (集_进程句柄, 临时_数据地址1)
            集_外部控件操作.销毁外部指针 (集_进程句柄, 临时_数据地址2)
            返回 (“”)
        .判断结束
        
    .如果真结束
    临时_列.mask ＝ 4
    临时_列.列标题 ＝ 取空白文本 (260)
    临时_列.缓冲区长度 ＝ 260
    临时_项目地址 ＝ 取数据_通用型 (临时_列)
    .判断开始 (SendMessageA (集_目标句柄, 4121, 列索引, 临时_项目地址) ≠ 0)
        返回 (临时_列.列标题)
    .默认
        返回 (“”)
    .判断结束
    

.子程序 取列对齐方式, 整数型, 公开, 取回报表型列表框中指定列的对齐方式。返回值为以下常量之一： 0：0； 1：1； 2：2；失败返回-1。
    .参数 列索引, 整数型, , 用作指定报表型列表框中项目所处的列，索引值从 0 开始。
    .局部变量 临时_项目地址, 整数型
    .局部变量 临时_数据地址1, 整数型
    .局部变量 临时_外部列, 超级列表框8
    .局部变量 局_数据, 字节集
    .局部变量 临时_列, 超级列表框7

    .如果真 (集_外部控件)
        临时_外部列.mask ＝ 1
        ' 集_进程句柄 ＝ 外部控件操作.打开进程 (集_目标句柄)
        临时_数据地址1 ＝ 集_外部控件操作.分配外部指针 (集_进程句柄, 32)
        临时_项目地址 ＝ 取数据_通用型 (临时_外部列)
        集_外部控件操作.写进程内存 (集_进程句柄, 临时_数据地址1, 临时_项目地址, 32)
        .判断开始 (SendMessageA (集_目标句柄, 4121, 列索引, 临时_数据地址1) ≠ 0)
            局_数据 ＝ 集_外部控件操作.读外部指针数据 (集_进程句柄, 临时_数据地址1, 32)
            集_外部控件操作.销毁外部指针 (集_进程句柄, 临时_数据地址1)
            ' 外部控件操作.结束操作 (集_进程句柄)
            写到内存 (局_数据, 临时_项目地址, 32)
            .判断开始 (位与 (临时_外部列.对齐方式, 2) ＝ 2)
                返回 (1)
            .判断 (位与 (临时_外部列.对齐方式, 1) ＝ 1)
                返回 (2)
            .默认
                返回 (0)
            .判断结束
            
        .默认
            返回 (-1)
        .判断结束
        
    .如果真结束
    临时_列.mask ＝ 1
    临时_项目地址 ＝ 取数据_通用型 (临时_列)
    .判断开始 (SendMessageA (集_目标句柄, 4121, 列索引, 临时_项目地址) ≠ 0)
        .判断开始 (位与 (临时_列.对齐方式, 2) ＝ 2)
            返回 (1)
        .判断 (位与 (临时_列.对齐方式, 1) ＝ 1)
            返回 (2)
        .默认
            返回 (0)
        .判断结束
        
    .默认
        返回 (-1)
    .判断结束
    

.子程序 取列宽, 整数型, 公开, 返回报表型列表框中指定列的宽度，如指定列不存在，返回 0 。
    .参数 列索引, 整数型, , 用作指定报表型列表框中项目所处的列，索引值从 0 开始。
    .局部变量 临时_项目地址, 整数型
    .局部变量 临时_数据地址1, 整数型
    .局部变量 临时_外部列, 超级列表框8
    .局部变量 局_数据, 字节集
    .局部变量 临时_列, 超级列表框7

    .如果真 (集_外部控件)
        临时_外部列.mask ＝ 2
        ' 集_进程句柄 ＝ 外部控件操作.打开进程 (集_目标句柄)
        临时_数据地址1 ＝ 集_外部控件操作.分配外部指针 (集_进程句柄, 32)
        临时_项目地址 ＝ 取数据_通用型 (临时_外部列)
        集_外部控件操作.写进程内存 (集_进程句柄, 临时_数据地址1, 临时_项目地址, 32)
        .判断开始 (SendMessageA (集_目标句柄, 4121, 列索引, 临时_数据地址1) ≠ 0)
            局_数据 ＝ 集_外部控件操作.读外部指针数据 (集_进程句柄, 临时_数据地址1, 32)
            集_外部控件操作.销毁外部指针 (集_进程句柄, 临时_数据地址1)
            ' 外部控件操作.结束操作 (集_进程句柄)
            写到内存 (局_数据, 临时_项目地址, 32)
            返回 (临时_外部列.列宽度)
        .默认
            集_外部控件操作.销毁外部指针 (集_进程句柄, 临时_数据地址1)
            ' 外部控件操作.结束操作 (集_进程句柄)
            返回 (0)
        .判断结束
        
    .如果真结束
    临时_列.mask ＝ 2
    临时_项目地址 ＝ 取数据_通用型 (临时_列)
    .判断开始 (SendMessageA (集_目标句柄, 4121, 列索引, 临时_项目地址) ≠ 0)
        返回 (临时_列.列宽度)
    .默认
        返回 (0)
    .判断结束
    

.子程序 取列图片, 整数型, 公开, 返回报表型列表框中指定列的图片索引
    .参数 列索引, 整数型, , 用作指定报表型列表框中项目所处的列，索引值从 0 开始。
    .局部变量 临时_项目地址, 整数型
    .局部变量 临时_数据地址1, 整数型
    .局部变量 临时_外部列, 超级列表框8
    .局部变量 局_数据, 字节集
    .局部变量 临时_列, 超级列表框7

    .如果真 (集_外部控件)
        临时_外部列.mask ＝ 16 ＋ 1
        ' 集_进程句柄 ＝ 外部控件操作.打开进程 (集_目标句柄)
        临时_数据地址1 ＝ 集_外部控件操作.分配外部指针 (集_进程句柄, 32)
        临时_项目地址 ＝ 取数据_通用型 (临时_外部列)
        集_外部控件操作.写进程内存 (集_进程句柄, 临时_数据地址1, 临时_项目地址, 32)
        .判断开始 (SendMessageA (集_目标句柄, 4121, 列索引, 临时_数据地址1) ≠ 0)
            局_数据 ＝ 集_外部控件操作.读外部指针数据 (集_进程句柄, 临时_数据地址1, 32)
            集_外部控件操作.销毁外部指针 (集_进程句柄, 临时_数据地址1)
            ' 外部控件操作.结束操作 (集_进程句柄)
            写到内存 (局_数据, 临时_项目地址, 32)
            返回 (临时_外部列.列图标)
        .默认
            集_外部控件操作.销毁外部指针 (集_进程句柄, 临时_数据地址1)
            ' 外部控件操作.结束操作 (集_进程句柄)
            返回 (-1)
        .判断结束
        
    .如果真结束
    临时_列.mask ＝ 16 ＋ 1
    临时_项目地址 ＝ 取数据_通用型 (临时_列)
    .判断开始 (SendMessageA (集_目标句柄, 4121, 列索引, 临时_项目地址) ≠ 0)
        返回 (临时_列.列图标)
    .默认
        返回 (-1)
    .判断结束
    

.子程序 图片是否居右, 逻辑型, 公开, 如果报表型列表框中指定列的图片居右显示，返回真，否则返回假
    .参数 列索引, 整数型, , 用作指定报表型列表框中项目所处的列，索引值从 0 开始。
    .局部变量 临时_项目地址, 整数型
    .局部变量 临时_数据地址1, 整数型
    .局部变量 临时_外部列, 超级列表框8
    .局部变量 局_结构, 字节集
    .局部变量 临时_列, 超级列表框7

    .如果真 (集_外部控件)
        临时_外部列.mask ＝ 16 ＋ 1
        ' 集_进程句柄 ＝ 外部控件操作.打开进程 (集_目标句柄)
        临时_数据地址1 ＝ 集_外部控件操作.分配外部指针 (集_进程句柄, 32)
        临时_项目地址 ＝ 取数据_通用型 (临时_外部列)
        集_外部控件操作.写进程内存 (集_进程句柄, 临时_数据地址1, 临时_项目地址, 32)
        .判断开始 (SendMessageA (集_目标句柄, 4121, 列索引, 临时_数据地址1) ≠ 0)
            局_结构 ＝ 集_外部控件操作.读外部指针数据 (集_进程句柄, 临时_数据地址1, 32)
            集_外部控件操作.销毁外部指针 (集_进程句柄, 临时_数据地址1)
            ' 外部控件操作.结束操作 (集_进程句柄)
            写到内存 (局_结构, 临时_项目地址, 32)
            返回 (位与 (临时_外部列.对齐方式, 4096) ＝ 4096)
        .默认
            集_外部控件操作.销毁外部指针 (集_进程句柄, 临时_数据地址1)
            ' 外部控件操作.结束操作 (集_进程句柄)
            返回 (假)
        .判断结束
        
    .如果真结束
    临时_列.mask ＝ 16 ＋ 1
    临时_项目地址 ＝ 取数据_通用型 (临时_列)
    .判断开始 (SendMessageA (集_目标句柄, 4121, 列索引, 临时_项目地址) ≠ 0)
        返回 (位与 (临时_列.对齐方式, 4096) ＝ 4096)
    .默认
        返回 (假)
    .判断结束
    

.子程序 置列标题, 逻辑型, 公开, 设置报表型列表框中指定列的标题
    .参数 列索引, 整数型, , 用作指定报表型列表框中项目所处的列，索引值从 0 开始。
    .参数 标题, 文本型, 可空, 可以被省略。本参数指定报表列的标题文本。如果被省略，默认值为空文本。
    .局部变量 临时_项目地址, 整数型
    .局部变量 临时_数据地址1, 整数型
    .局部变量 临时_数据地址2, 整数型
    .局部变量 临时_外部列, 超级列表框8
    .局部变量 局_数值, 整数型
    .局部变量 临时_列, 超级列表框7
    .局部变量 局部_返回值, 整数型

    .判断开始 (集_外部控件)
        临时_外部列.mask ＝ 4
        ' 集_进程句柄 ＝ 外部控件操作.打开进程 (集_目标句柄)
        临时_数据地址1 ＝ 集_外部控件操作.分配外部指针 (集_进程句柄, 32)
        临时_数据地址2 ＝ 集_外部控件操作.分配外部指针 (集_进程句柄, 取文本长度 (标题) ＋ 1)
        临时_外部列.列标题 ＝ 临时_数据地址2
        临时_项目地址 ＝ 取数据_通用型 (临时_外部列)
        局_数值 ＝ lstrcpyn_文本型 (标题, 标题, 0)
        集_外部控件操作.写进程内存 (集_进程句柄, 临时_数据地址1, 临时_项目地址, 32)
        集_外部控件操作.写进程内存 (集_进程句柄, 临时_数据地址2, 局_数值, 取文本长度 (标题) ＋ 1)
        局部_返回值 ＝ SendMessageA (集_目标句柄, 4122, 列索引, 临时_数据地址1)
        集_外部控件操作.销毁外部指针 (集_进程句柄, 临时_数据地址1)
        集_外部控件操作.销毁外部指针 (集_进程句柄, 临时_数据地址2)
        ' 外部控件操作.结束操作 (集_进程句柄)
    .默认
        临时_列.mask ＝ 4
        临时_列.列标题 ＝ 标题
        临时_项目地址 ＝ 取数据_通用型 (临时_列)
        局部_返回值 ＝ SendMessageA (集_目标句柄, 4122, 列索引, 临时_项目地址)
    .判断结束
    返回 (局部_返回值 ≠ 0)

.子程序 置列宽, , 公开, 设置报表型列表框中指定列的宽度
    .参数 列索引, 整数型, , 用作指定报表型列表框中项目所处的列，索引值从 0 开始。
    .参数 列宽, 整数型, 可空, 可以被省略。本参数指定报表列的宽度，单位为像素。如果参数值提供为 -1 ，则根据列数据最大宽度自动调整列尺寸，如果参数值提供为 -2 ，则根据列标题宽度自动调整列尺寸。如果本参数被省略，默认值为 -1 。
    .局部变量 临时_项目地址, 整数型
    .局部变量 临时_数据地址1, 整数型
    .局部变量 临时_外部列, 超级列表框8
    .局部变量 临时_列, 超级列表框7

    .判断开始 (集_外部控件)
        临时_外部列.mask ＝ 2
        ' 集_进程句柄 ＝ 外部控件操作.打开进程 (集_目标句柄)
        临时_数据地址1 ＝ 集_外部控件操作.分配外部指针 (集_进程句柄, 32)
        临时_外部列.列宽度 ＝ 列宽
        临时_项目地址 ＝ 取数据_通用型 (临时_外部列)
        集_外部控件操作.写进程内存 (集_进程句柄, 临时_数据地址1, 临时_项目地址, 32)
        SendMessageA (集_目标句柄, 4122, 列索引, 临时_数据地址1)
        集_外部控件操作.销毁外部指针 (集_进程句柄, 临时_数据地址1)
        ' 外部控件操作.结束操作 (集_进程句柄)
    .默认
        临时_列.mask ＝ 2
        临时_列.列宽度 ＝ 列宽
        临时_项目地址 ＝ 取数据_通用型 (临时_列)
        SendMessageA (集_目标句柄, 4122, 列索引, 临时_项目地址)
    .判断结束
    

.子程序 置列图片, , 公开, 设置报表型列表框中指定列的标志图片。
    .参数 列索引, 整数型, , 用作指定报表型列表框中项目所处的列，索引值从 0 开始。
    .参数 图片索引, 整数型, 可空, 可以被省略。图片索引用于指定“表头图片组”属性中的某张图片。索引值从 0 开始，-1 表示无图片。如果本参数被省略，默认值为 -1 。
    .局部变量 临时_项目地址, 整数型
    .局部变量 临时_数据地址1, 整数型
    .局部变量 临时_外部列, 超级列表框8
    .局部变量 临时_列, 超级列表框7

    .判断开始 (集_外部控件)
        临时_外部列.mask ＝ 16
        ' 集_进程句柄 ＝ 外部控件操作.打开进程 (集_目标句柄)
        临时_数据地址1 ＝ 集_外部控件操作.分配外部指针 (集_进程句柄, 32)
        临时_外部列.列图标 ＝ 图片索引
        临时_项目地址 ＝ 取数据_通用型 (临时_外部列)
        集_外部控件操作.写进程内存 (集_进程句柄, 临时_数据地址1, 临时_项目地址, 32)
        SendMessageA (集_目标句柄, 4122, 列索引, 临时_数据地址1)
        集_外部控件操作.销毁外部指针 (集_进程句柄, 临时_数据地址1)
        ' 外部控件操作.结束操作 (集_进程句柄)
    .默认
        临时_列.mask ＝ 16
        临时_列.列图标 ＝ 图片索引
        临时_项目地址 ＝ 取数据_通用型 (临时_列)
        SendMessageA (集_目标句柄, 4122, 列索引, 临时_项目地址)
    .判断结束
    

.子程序 取列数, 整数型, 公开, 返回报表型列表框中列的总数
    集_表头句柄 ＝ SendMessageA (集_目标句柄, #LVM_GETHEADER, 0, 0)
    返回 (SendMessageA (集_表头句柄, 4608, 0, 0))

.子程序 插入列, 整数型, 公开, 在报表型列表框中指定位置插入新的列，成功返回新列的位置索引，失败返回 -1 。
    .参数 插入位置, 整数型, 可空, 可以被省略。指定新列插入时的位置索引，索引值从 0 开始。如果提供 -1 ，则插入到尾部。如果本参数被省略，默认值为 -1 。
    .参数 标题, 文本型, 可空, 可以被省略。本参数指定报表列的标题文本。如果被省略，默认值为空文本。
    .参数 列宽, 整数型, 可空, 可以被省略。本参数指定报表列的宽度，单位为像素。如果被省略，默认值为 50 。
    .参数 对齐方式, 整数型, 可空, 可以被省略。参数可以为以下常量之一： 0：0； 1：1； 2：2。如果本参数被省略，默认值为“0”。
    .参数 图片索引, 整数型, 可空, 可以被省略。图片索引用于指定“表头图片组”属性中的某张图片。索引值从 0 开始，-1 表示无图片。如果本参数被省略，默认值为 -1 。
    .参数 图片是否居右, 逻辑型, 可空, 可以被省略。指定图片是否显示在右边，如果本参数被省略，默认值为假。
    .局部变量 临时_项目地址, 整数型
    .局部变量 临时_数据地址1, 整数型
    .局部变量 临时_数据地址2, 整数型
    .局部变量 临时_外部列, 超级列表框8
    .局部变量 局_数值, 整数型
    .局部变量 临时_列, 超级列表框7

    .如果真 (是否为空 (插入位置) 或 插入位置 ＝ -1)
        插入位置 ＝ 取列数 ()
    .如果真结束
    .判断开始 (集_外部控件)
        临时_外部列.mask ＝ 16 ＋ 1 ＋ 2 ＋ 4
        ' 集_单一列.pszText ＝ 取空白文本 (256)
        ' 集_进程句柄 ＝ 外部控件操作.打开进程 (集_目标句柄)
        临时_数据地址1 ＝ 集_外部控件操作.分配外部指针 (集_进程句柄, 32)
        临时_数据地址2 ＝ 集_外部控件操作.分配外部指针 (集_进程句柄, 取文本长度 (标题) ＋ 1)
        临时_外部列.列标题 ＝ 临时_数据地址2
        .判断开始 (是否为空 (列宽))
            临时_外部列.列宽度 ＝ 50
        .默认
            临时_外部列.列宽度 ＝ 列宽
        .判断结束
        .判断开始 (是否为空 (对齐方式) 或 对齐方式 ＝ 0)
            临时_外部列.对齐方式 ＝ 0
        .判断 (对齐方式 ＝ 2)
            临时_外部列.对齐方式 ＝ 1
        .判断 (对齐方式 ＝ 1)
            临时_外部列.对齐方式 ＝ 2
        .默认
            
        .判断结束
        .判断开始 (是否为空 (图片索引))
            临时_外部列.列图标 ＝ -1
        .默认
            临时_外部列.列图标 ＝ 图片索引
        .判断结束
        .如果真 (图片是否居右)
            临时_外部列.对齐方式 ＝ 位或 (临时_外部列.对齐方式, 4096)
        .如果真结束
        临时_项目地址 ＝ 取数据_通用型 (临时_外部列)
        局_数值 ＝ lstrcpyn_文本型 (标题, 标题, 0)
        集_外部控件操作.写进程内存 (集_进程句柄, 临时_数据地址1, 临时_项目地址, 32)
        集_外部控件操作.写进程内存 (集_进程句柄, 临时_数据地址2, 局_数值, 取文本长度 (标题) ＋ 1)
        局_数值 ＝ SendMessageA (集_目标句柄, 4123, 插入位置, 临时_数据地址1)
        集_外部控件操作.销毁外部指针 (集_进程句柄, 临时_数据地址1)
        集_外部控件操作.销毁外部指针 (集_进程句柄, 临时_数据地址2)
        ' 外部控件操作.结束操作 (集_进程句柄)
        返回 (局_数值)
    .默认
        临时_列.mask ＝ 16 ＋ 1 ＋ 2 ＋ 4
        临时_列.列标题 ＝ 标题
        .判断开始 (是否为空 (列宽))
            临时_列.列宽度 ＝ 50
        .默认
            临时_列.列宽度 ＝ 列宽
        .判断结束
        .判断开始 (是否为空 (对齐方式) 或 对齐方式 ＝ 0)
            临时_列.对齐方式 ＝ 0
        .判断 (对齐方式 ＝ 2)
            临时_列.对齐方式 ＝ 1
        .判断 (对齐方式 ＝ 1)
            临时_列.对齐方式 ＝ 2
        .默认
            
        .判断结束
        .判断开始 (是否为空 (图片索引))
            临时_列.列图标 ＝ -1
        .默认
            临时_列.列图标 ＝ 图片索引
        .判断结束
        .如果真 (图片是否居右)
            临时_列.对齐方式 ＝ 位或 (临时_列.对齐方式, 4096)
        .如果真结束
        
        临时_项目地址 ＝ 取数据_通用型 (临时_列)
        返回 (SendMessageA (集_目标句柄, 4123, 插入位置, 临时_项目地址))
        
    .判断结束
    
    

.子程序 删除列, , 公开, 删除报表型列表框中指定位置处的列。
    .参数 列索引, 整数型, , 用作指定报表型列表框中项目所处的列，索引值从 0 开始。

    SendMessageA (集_目标句柄, #LVM_DELETECOLUMN, 列索引, 0)

.子程序 进入编辑, , 公开, 让指定表项进入编辑状态，执行本命令成功的前提是“允许编辑”属性为真。
    .参数 表项索引, 整数型, , 用于指定列表框中的某一项目，索引值从 0 开始。

    .判断开始 (集_外部控件)
        SetActiveWindow (GetWindow (集_目标句柄, 4))
        SetFocus (集_目标句柄)
    .默认
        SetFocus (集_目标句柄)
    .判断结束
    SendMessageA (集_目标句柄, 4119, 表项索引, 0)

.子程序 读超级列表框项目数据, , 公开, 取出全部的项目数据
    .参数 列表框信息, 列表框信息, 参考 可空 数组
    .局部变量 局_项目数, 整数型
    .局部变量 局_计次, 整数型

    局_项目数 ＝ 取表项数 ()
    重定义数组 (列表框信息, 假, 局_项目数)
    局_项目数 ＝ 局_项目数 － 1
    .变量循环首 (0, 局_项目数, 1, 局_计次)
        列表框信息 [局_计次 ＋ 1] ＝ 取项目数据 (局_计次)
    .变量循环尾 ()

.子程序 取项目数据, 列表框信息, , 取指定项目的数据
    .参数 项目索引, 整数型
    .局部变量 临时_数据地址1, 整数型
    .局部变量 临时_数据地址2, 整数型
    .局部变量 临时_项目地址, 整数型
    .局部变量 局_结构, 列表框信息
    .局部变量 局_列数, 整数型
    .局部变量 局_数据, 字节集
    .局部变量 局_计次, 整数型
    .局部变量 局部_外部项目, 超级列表框1
    .局部变量 临时_项目, 超级列表框0

    局_列数 ＝ 取列数 () － 1
    重定义数组 (局_结构.列标题, 假, 局_列数)
    重定义数组 (局_结构.列图片索引, 假, 局_列数)
    .判断开始 (集_外部控件)
        局部_外部项目.表项索引 ＝ 项目索引
        局部_外部项目.掩码 ＝ 1 ＋ 2 ＋ 4 ＋ 16 ＋ 8
        局部_外部项目.状态掩码 ＝ -4096
        临时_项目地址 ＝ 取数据_通用型 (局部_外部项目)
        局部_外部项目.子项目 ＝ 0
        ' 集_进程句柄 ＝ 外部控件操作.打开进程 (集_目标句柄)
        临时_数据地址1 ＝ 集_外部控件操作.分配外部指针 (集_进程句柄, 40)
        临时_数据地址2 ＝ 集_外部控件操作.分配外部指针 (集_进程句柄, 260)
        局部_外部项目.项目文本 ＝ 临时_数据地址2
        局部_外部项目.项目文本长度 ＝ 255
        集_外部控件操作.写进程内存 (集_进程句柄, 临时_数据地址1, 临时_项目地址, 40)
        .如果真 (SendMessageA (集_目标句柄, 4101, 0, 临时_数据地址1) ≠ 0)
            局_数据 ＝ 集_外部控件操作.读外部指针数据 (集_进程句柄, 临时_数据地址1, 40)
            写到内存 (局_数据, 临时_项目地址, 40)
            局_结构.标题 ＝ 到文本 (集_外部控件操作.读外部指针数据 (集_进程句柄, 临时_数据地址2, 260))
            集_外部控件操作.销毁外部指针 (集_进程句柄, 临时_数据地址2)
            局_结构.图片索引 ＝ 局部_外部项目.图片索引
            局_结构.表项数值 ＝ 局部_外部项目.项目数值
            局_结构.缩进数目 ＝ 局部_外部项目.缩进
            局_结构.状态图片索引 ＝ 局部_外部项目.状态 ÷ 4096 － 1
            局部_外部项目.掩码 ＝ 1 ＋ 2
            .变量循环首 (1, 局_列数, 1, 局_计次)
                局部_外部项目.子项目 ＝ 局_计次
                临时_数据地址2 ＝ 集_外部控件操作.分配外部指针 (集_进程句柄, 260)
                局部_外部项目.项目文本 ＝ 临时_数据地址2
                局部_外部项目.项目文本长度 ＝ 255
                
                集_外部控件操作.写进程内存 (集_进程句柄, 临时_数据地址1, 临时_项目地址, 40)
                .如果真 (SendMessageA (集_目标句柄, 4101, 0, 临时_数据地址1) ≠ 0)
                    局_数据 ＝ 集_外部控件操作.读外部指针数据 (集_进程句柄, 临时_数据地址1, 40)
                    写到内存 (局_数据, 临时_项目地址, 40)
                    局_结构.列标题 [局_计次] ＝ 到文本 (集_外部控件操作.读外部指针数据 (集_进程句柄, 临时_数据地址2, 260))
                    局_结构.列图片索引 [局_计次] ＝ 局部_外部项目.图片索引
                .如果真结束
                集_外部控件操作.销毁外部指针 (集_进程句柄, 临时_数据地址2)
            .变量循环尾 ()
        .如果真结束
        集_外部控件操作.销毁外部指针 (集_进程句柄, 临时_数据地址1)
        ' 外部控件操作.结束操作 (集_进程句柄)
    .默认
        临时_项目.项目 ＝ 项目索引
        临时_项目.掩码 ＝ 1 ＋ 2 ＋ 4 ＋ 16 ＋ 8
        临时_项目.状态掩码 ＝ -4096
        临时_项目地址 ＝ 取数据_通用型 (临时_项目)
        临时_项目.子项目 ＝ 0
        临时_项目.项目文本 ＝ 取空白文本 (260)
        .如果真 (SendMessageA (集_目标句柄, 4101, 0, 临时_项目地址) ≠ 0)
            局_结构.标题 ＝ 临时_项目.项目文本
            局_结构.图片索引 ＝ 临时_项目.图片索引
            局_结构.表项数值 ＝ 临时_项目.项目数值
            局_结构.缩进数目 ＝ 临时_项目.缩进
            局_结构.状态图片索引 ＝ 临时_项目.状态 ÷ 4096 － 1
            临时_项目.掩码 ＝ 1 ＋ 2
            .变量循环首 (1, 局_列数, 1, 局_计次)
                临时_项目.子项目 ＝ 局_计次
                临时_项目.项目文本 ＝ 取空白文本 (260)
                .如果真 (SendMessageA (集_目标句柄, 4101, 0, 临时_项目地址) ≠ 0)
                    局_结构.列标题 [局_计次] ＝ 临时_项目.项目文本
                    局_结构.列图片索引 [局_计次] ＝ 临时_项目.图片索引
                .如果真结束
                
            .变量循环尾 ()
        .如果真结束
        
    .判断结束
    返回 (局_结构)

.子程序 取文本颜色, 整数型, 公开
    返回 (SendMessageA (集_目标句柄, #LVM_GETTEXTCOLOR, 0, 0))

.子程序 置文本颜色, , 公开
    .参数 文本颜色, 整数型

    SendMessageA (集_目标句柄, #LVM_SETTEXTCOLOR, 0, 文本颜色)
    刷新显示 ()

.子程序 刷新显示, , 公开
    SendMessageA (集_目标句柄, #LVM_REDRAWITEMS, 取第一项索引 (), 取可显示数量 ())

.子程序 取第一项索引, 整数型, 公开, 取在当前超级列表框中显示的第一条项目的索引。失败返回-1
    返回 (SendMessageA (集_目标句柄, #LVM_GETTOPINDEX, 0, 0))

.子程序 取可显示数量, 整数型, 公开, 取当前在超级列表框的用户区中大约可以显示的项目数量
    返回 (SendMessageA (集_目标句柄, #LVM_GETCOUNTPERPAGE, 0, 0))

.子程序 取文本背景颜色, 整数型, 公开
    返回 (SendMessageA (集_目标句柄, #LVM_GETTEXTBKCOLOR, 0, 0))

.子程序 置文本背景颜色, , 公开
    .参数 背景颜色, 整数型

    SendMessageA (集_目标句柄, #LVM_SETTEXTBKCOLOR, 0, 背景颜色)
    刷新显示 ()

.子程序 取背景颜色, 整数型, 公开
    返回 (SendMessageA (集_目标句柄, #LVM_GETBKCOLOR, 0, 0))

.子程序 置背景颜色, , 公开
    .参数 背景颜色, 整数型

    SendMessageA (集_目标句柄, #LVM_SETBKCOLOR, 0, 背景颜色)
    刷新显示 ()

.子程序 取类型, 整数型, 公开
    .局部变量 局_类型, 整数型

    局_类型 ＝ SendMessageA (集_目标句柄, #LVM_GETVIEW, 0, 0)
    .判断开始 (局_类型 ＝ 0) ' 0_大图标列表
        返回 (0)
    .判断 (局_类型 ＝ 1) ' 1_报表列表框
        返回 (3)
    .判断 (局_类型 ＝ 2) ' 2_小图标列表
        返回 (1)
    .判断 (局_类型 ＝ 3) ' 3_普通列表框
        返回 (2)
    .判断 (局_类型 ＝ 4)
        返回 (4)
    .默认
        返回 (-1)
    .判断结束
    

.子程序 置类型, , 公开
    .参数 类型, 整数型
    .局部变量 局_类型, 整数型

    .判断开始 (类型 ＝ 0) ' 0_大图标列表
        局_类型 ＝ 0
    .判断 (类型 ＝ 3) ' 1_报表列表框
        局_类型 ＝ 1
    .判断 (类型 ＝ 1) ' 2_小图标列表
        局_类型 ＝ 2
    .判断 (类型 ＝ 2) ' 3_普通列表框
        局_类型 ＝ 3
    .判断 (类型 ＝ 4)
        局_类型 ＝ 4
    .默认
        
    .判断结束
    SendMessageA (集_目标句柄, #LVM_SETVIEW, 局_类型, 0)

.子程序 取背景图片, 文本型, 公开, 返回图片文件名路径
    .局部变量 临时_数据地址1, 整数型
    .局部变量 临时_数据地址2, 整数型
    .局部变量 临时_项目地址, 整数型
    .局部变量 局_结构1, 超级列表框5
    .局部变量 局_结构2, 超级列表框6
    .局部变量 局_结构3, 字节集

    .判断开始 (集_外部控件)
        局_结构2.ulFlags ＝ 2
        局_结构2.cchImageMax ＝ 256
        临时_项目地址 ＝ 取数据_通用型 (局_结构2)
        ' 集_进程句柄 ＝ 外部控件操作.打开进程 (集_目标句柄)
        临时_数据地址1 ＝ 集_外部控件操作.分配外部指针 (集_进程句柄, 24)
        临时_数据地址2 ＝ 集_外部控件操作.分配外部指针 (集_进程句柄, 256)
        局_结构2.pszImage ＝ 临时_数据地址2
        集_外部控件操作.写进程内存 (集_进程句柄, 临时_数据地址1, 临时_项目地址, 24)
        SendMessageA (集_目标句柄, 4165, 0, 临时_数据地址1)
        局_结构3 ＝ 集_外部控件操作.读外部指针数据 (集_进程句柄, 临时_数据地址2, 256)
        集_外部控件操作.销毁外部指针 (集_进程句柄, 临时_数据地址1)
        集_外部控件操作.销毁外部指针 (集_进程句柄, 临时_数据地址2)
        ' 外部控件操作.结束操作 (集_进程句柄)
        返回 (到文本 (局_结构3))
    .默认
        局_结构1.ulFlags ＝ 2
        局_结构1.图片路径 ＝ 取空白文本 (256)
        局_结构1.最大长度 ＝ 256
        临时_项目地址 ＝ 取数据_通用型 (局_结构1)
        SendMessageA (集_目标句柄, 4165, 0, 临时_项目地址)
        返回 (局_结构1.图片路径)
    .判断结束
    

.子程序 置背景图片, , 公开, 设置背景图片
    .参数 图片文件名, 文本型
    .参数 是否平铺, 逻辑型, 可空, 可以省略。默认为真。
    .局部变量 临时_数据地址1, 整数型
    .局部变量 临时_数据地址2, 整数型
    .局部变量 临时_项目地址, 整数型
    .局部变量 局_结构1, 超级列表框5
    .局部变量 局_结构2, 超级列表框6
    .局部变量 局_结构3, 整数型

    置文本背景颜色 (-1)
    .判断开始 (集_外部控件)
        局_结构2.ulFlags ＝ 2
        局_结构2.cchImageMax ＝ 取文本长度 (图片文件名) ＋ 1
        局_结构2.xOffsetPercent ＝ 100
        局_结构2.yOffsetPercent ＝ 100
        .如果真 (是否平铺 或 是否为空 (是否平铺))
            局_结构2.ulFlags ＝ 位或 (局_结构2.ulFlags, 16)
        .如果真结束
        临时_项目地址 ＝ 取数据_通用型 (局_结构2)
        ' 集_进程句柄 ＝ 外部控件操作.打开进程 (集_目标句柄)
        临时_数据地址1 ＝ 集_外部控件操作.分配外部指针 (集_进程句柄, 24)
        临时_数据地址2 ＝ 集_外部控件操作.分配外部指针 (集_进程句柄, 取文本长度 (图片文件名) ＋ 1)
        局_结构2.pszImage ＝ 临时_数据地址2
        局_结构3 ＝ lstrcpyn_文本型 (图片文件名, 图片文件名, 0)
        集_外部控件操作.写进程内存 (集_进程句柄, 临时_数据地址1, 临时_项目地址, 24)
        集_外部控件操作.写进程内存 (集_进程句柄, 临时_数据地址2, 局_结构3, 取文本长度 (图片文件名) ＋ 1)
        SendMessageA (集_目标句柄, 4164, 0, 临时_数据地址1)
        集_外部控件操作.销毁外部指针 (集_进程句柄, 临时_数据地址1)
        集_外部控件操作.销毁外部指针 (集_进程句柄, 临时_数据地址2)
        ' 外部控件操作.结束操作 (集_进程句柄)
    .默认
        局_结构1.ulFlags ＝ 2
        局_结构1.图片路径 ＝ 图片文件名
        局_结构1.最大长度 ＝ 取文本长度 (图片文件名) ＋ 1
        局_结构1.xOffsetPercent ＝ 100
        局_结构1.yOffsetPercent ＝ 100
        .如果真 (是否平铺 或 是否为空 (是否平铺))
            局_结构1.ulFlags ＝ 位或 (局_结构1.ulFlags, 16)
        .如果真结束
        临时_项目地址 ＝ 取数据_通用型 (局_结构1)
        SendMessageA (集_目标句柄, 4164, 0, 临时_项目地址)
    .判断结束
    

.子程序 取鼠标指针所在的索引, 整数型, 公开, 如果鼠标指针在超级列表框范围内，取当前其指向的项目索引
    .局部变量 pt, POINT

    pt.X ＝ SendMessageA (集_目标句柄, #LVM_GETHOTITEM, 0, 0)
    .如果真 (pt.X ＝ -1)
        外部超级列表框_取鼠标处行列号 (集_目标句柄, pt.X, pt.Y)
    .如果真结束
    返回 (pt.X)

.子程序 取项目行距, 整数型, 公开
    返回 (SendMessageA (集_目标句柄, #LVM_GETITEMSPACING, 0, 0))

.子程序 取编辑框句柄, 整数型, 公开, 当列表框在进行编辑时，返回这个编辑框的句柄
    返回 (SendMessageA (集_目标句柄, #LVM_GETEDITCONTROL, 0, 0))

.子程序 取表项间距, , 公开
    .参数 水平间距, 整数型, 参考, 用于返回表项的水平间距
    .参数 垂直间距, 整数型, 参考, 用于返回表项的垂直间距
    .参数 列表框类型, 逻辑型, 可空, 可以被省略。当为真时取回小图标列表框的项目间距。当为假时取回大图标列表框的项目间距。默认为假。
    .局部变量 局_数据, 字节集

    局_数据 ＝ 到字节集 (SendMessageA (集_目标句柄, 4147, 到数值 (列表框类型), 0))
    水平间距 ＝ 取字节集数据 (局_数据, #短整数型, 1)
    垂直间距 ＝ 取字节集数据 (局_数据, #短整数型, 3)

.子程序 列排序, , 公开, 当超级列表框的类型是报表列表框时才能使用。使用本方法时，请将超级列表框的“排序方式”置为“0.不排序”
    .参数 列索引, 整数型, , 要排序的列索引，从0计起。
    .参数 排序方式, 逻辑型, 可空, 可以被省略。当为真时为正向排序，当为假时为逆向排序。默认为真，正向排序。
    .局部变量 局_列表框信息, 列表框信息, , "0"

    读超级列表框项目数据 (局_列表框信息)
    全部删除 ()
    .判断开始 (是否为空 (排序方式) 或 排序方式 ＝ 真)
        高速插入表项 (0, 局_列表框信息, 2048 ＋ 列索引)
    .默认
        高速插入表项 (0, 局_列表框信息, 位取反 (2048 ＋ 列索引))
    .判断结束
    

.子程序 单一选择, 逻辑型, 公开
    .参数 是否单一选择, 逻辑型, 可空, 可以被省略。当被省略时，只返回当前的单一选择设置状态，而不改变其状态。
    .局部变量 局_数值, 整数型

    局_数值 ＝ GetWindowLongA (集_目标句柄, -16)
    .如果真 (是否为空 (是否单一选择))
        返回 (位与 (局_数值, 4) ＝ 4)
    .如果真结束
    .判断开始 (位与 (局_数值, 4) ＝ 4 且 是否单一选择 ＝ 假)
        局_数值 ＝ 位异或 (局_数值, 4)
        SetWindowLongA (集_目标句柄, -16, 局_数值)
    .默认
        局_数值 ＝ 位或 (局_数值, 4)
        SetWindowLongA (集_目标句柄, -16, 局_数值)
    .判断结束
    局_数值 ＝ GetWindowLongA (集_目标句柄, -16)
    返回 (位与 (局_数值, 4) ＝ 4)

.子程序 取现行选中项, 整数型, 公开
    返回 (SendMessageA (集_目标句柄, #LVM_GETNEXTITEM, -1, 2))
    .判断开始 (单一选择 ())
        返回 (SendMessageA (集_目标句柄, #LVM_GETNEXTITEM, -1, 2))
    .默认
        返回 (-1)
    .判断结束
    

.子程序 置现行选中项, , 公开
    .参数 现行选中项, 整数型

    .如果真 (单一选择 (真))
        选择表项 (现行选中项)
    .如果真结束
    

.子程序 导出Excel, 逻辑型, 公开, 把超级列表框内容导出为Excel表格文件，成功返回真，失败返回假。注：只能导出报表列表框。
    .参数 保存文件, 文本型, , 保存到目标文件，后缀名一般为“xls”。注：如果文件已存在则会重写改文件，如果不能打开文件则返回假。
    .参数 保留表头, 逻辑型, 可空, 是否把超级列表框表头一起导出到表格文件，如果不需要导出表头，请留空此值或者赋值“假”。
    .局部变量 hFile, 整数型
    .局部变量 列数, 整数型
    .局部变量 行数, 整数型
    .局部变量 列索引, 整数型
    .局部变量 表项索引, 整数型
    .局部变量 局_列标题, 文本型
    .局部变量 局_行标题, 文本型

    列数 ＝ 取列数 ()
    行数 ＝ 取表项数 ()
    .如果真 (行数 ＝ 0 或 列数 ＝ 0)
        返回 (假)
    .如果真结束
    hFile ＝ 打开文件 (保存文件, #重写, #无限制)
    .如果真 (hFile ＝ 0)
        返回 (假)
    .如果真结束
    移到文件首 (hFile)
    写文本行 (hFile, “<table border=” ＋ #引号 ＋ “1” ＋ #引号 ＋ “>”)
    .如果真 (保留表头 ＝ 真 且 列数 ＞ 0)
        写文本行 (hFile, “  <tr>”)
        列索引 ＝ 0
        .计次循环首 (列数, )
            局_列标题 ＝ 取列标题 (列索引)
            写文本行 (hFile, “    <th>” ＋ 局_列标题 ＋ “</th>”)
            列索引 ＝ 列索引 ＋ 1
        .计次循环尾 ()
        写文本行 (hFile, “  </tr>”)
    .如果真结束
    .如果真 (行数 ＞ 0)
        表项索引 ＝ 0
        .计次循环首 (行数, )
            写文本行 (hFile, “  <tr>”)
            列索引 ＝ 0
            .计次循环首 (列数, )
                局_行标题 ＝ 取标题 (表项索引, 列索引, 1024)
                写文本行 (hFile, “    <td>” ＋ 局_行标题 ＋ “</td>”)
                列索引 ＝ 列索引 ＋ 1
            .计次循环尾 ()
            写文本行 (hFile, “  </tr>”)
            表项索引 ＝ 表项索引 ＋ 1
        .计次循环尾 ()
    .如果真结束
    写文本行 (hFile, “</table>”)
    关闭文件 (hFile)
    返回 (真)

.子程序 _置外部操作, , 公开, 如果是外部控件，就要用这个方法初始化
    集_外部控件 ＝ 真

.子程序 _销毁外部操作, , 公开, 如果不再需要对外部控件进行初始化，可用这个销毁
    集_外部控件 ＝ 假

.子程序 取表项位置, 整数型, 公开, 取出表项在列表框中的坐标位置
    .参数 索引, 整数型
    .参数 点, POINT, 参考, 用于装载坐标的变量
    .局部变量 _POINT, 整数型
    .局部变量 返回值, 整数型

    .如果 (集_外部控件)
        _POINT ＝ VirtualAllocEx (集_进程句柄, 0, 8, #MEM_COMMIT, #PAGE_READWRITE)
        返回值 ＝ SendMessageA (集_目标句柄, #LVM_GETITEMPOSITION, 索引, _POINT)
        ReadProcessMemory_整数型1 (集_进程句柄, _POINT, 取数据_通用型 (点), 8, 0)
        VirtualFreeEx (集_进程句柄, _POINT, 0, #MEM_RELEASE)
    .否则
        返回值 ＝ SendMessageA (集_目标句柄, #LVM_GETITEMPOSITION, 索引, 取数据_通用型 (点))
    .如果结束
    返回 (返回值)

.版本 2

.程序集 程序集_x64
.程序集变量 m_Mods, 整数型

.子程序 x64Init
    .局部变量 ret, 逻辑型
    .局部变量 isWow64, 逻辑型

    .如果真 (m_Mods ＝ 0)
        ret ＝ IsWow64Process (GetCurrentProcess (), isWow64)
        .如果真 (ret ＝ 假 或 isWow64 ＝ 假)
            返回 ()
        .如果真结束
        m_Mods ＝ eWOW64ExtInit ()
    .如果真结束
    

.子程序 SendMsgA, 长整数型
    .参数 hWnd, 长整数型
    .参数 message, 整数型
    .参数 wParam, 长整数型
    .参数 lParam, 长整数型
    .局部变量 pFun, 长整数型, 静态
    .局部变量 hModule, 长整数型

    .如果真 (pFun ＝ 0)
        hModule ＝ LoadDll (“user32.dll”)
        .如果真 (hModule ＝ 0)
            返回 (0)
        .如果真结束
        pFun ＝ GetProcAddress64 (hModule, “SendMessageA”)
        .如果真 (pFun ＝ 0)
            返回 (0)
        .如果真结束
        
    .如果真结束
    
    返回 (X64Call (pFun, hWnd, message, wParam, lParam, , , , , , ))

.子程序 SendMsgW, 长整数型
    .参数 hWnd, 整数型
    .参数 message, 整数型
    .参数 wParam, 长整数型
    .参数 lParam, 长整数型
    .局部变量 pFun, 长整数型, 静态
    .局部变量 hModule, 长整数型

    .如果真 (pFun ＝ 0)
        hModule ＝ LoadDll (“user32.dll”)
        .如果真 (hModule ＝ 0)
            返回 (0)
        .如果真结束
        pFun ＝ GetProcAddress64 (hModule, “SendMessageW”)
        .如果真 (pFun ＝ 0)
            返回 (0)
        .如果真结束
        
    .如果真结束
    
    返回 (X64Call (pFun, hWnd, message, wParam, lParam, , , , , , ))

.子程序 LoadDll, 长整数型
    .参数 dll, 文本型, , 完整路径
    .局部变量 arg, 整数型
    .局部变量 file, 文本型
    .局部变量 path, 字节集
    .局部变量 pos, 整数型
    .局部变量 pPath, 整数型
    .局部变量 ret, 长整数型
    .局部变量 ulong, 整数型
    .局部变量 hUser, 长整数型
    .局部变量 pFun, 长整数型, 静态
    .局部变量 h, 长整数型

    .如果真 (pFun ＝ 0)
        h ＝ GetNtdll64 ()
        pFun ＝ GetProcAddress64 (h, “LdrLoadDll”)
    .如果真结束
    
    pos ＝ 倒找文本 (dll, “\”, , 假)
    .判断开始 (pos ≠ -1)
        file ＝ 取文本右边 (dll, 取文本长度 (dll) － pos)
        path ＝ 编码_Ansi到Unicode (取文本左边 (dll, pos － 1), )
        pPath ＝ 取指针_字节集型 (path)
    .默认
        file ＝ dll
    .判断结束
    arg ＝ UNICODE_STRING_X64 (file)
    
    ret ＝ X64Call (pFun, pPath, 取指针_通用型 (ulong), arg, 取指针_通用型 (hUser), , , , , , )
    LocalFree (arg)
    返回 (hUser)

.子程序 X64Call, 长整数型, , 调用 64 位函数通用版本（注：返回长整数对于很多函数是必要的，但某些 NTDLL 函数返回值为 NTSTATUS 错误码 时应将返回值转为整数！）
    .参数 func, 长整数型
    .参数 arg1, 长整数型, 可空, 必须按顺序填写 API 所需参数，数值型直接传入，其他类型及传址参数传入 32/64 内存地址均可。不使用参数必须“留空”，不能是写 0
    .参数 arg2, 长整数型, 可空
    .参数 arg3, 长整数型, 可空
    .参数 arg4, 长整数型, 可空
    .参数 arg5, 长整数型, 可空
    .参数 arg6, 长整数型, 可空
    .参数 arg7, 长整数型, 可空
    .参数 arg8, 长整数型, 可空
    .参数 arg9, 长整数型, 可空
    .参数 arg10, 长整数型, 可空, 应该够用了，不弄太多影响效率了
    .局部变量 fs

    fs ＝ 0
    置入代码 (#X64_SaveFs)
    置入代码 (#X64_Start)
    置入代码 ({ 131, 196, 176, 103, 72, 141, 85, 64, 76, 141, 68, 36, 32, 72, 51, 201, 177, 6, 139, 66, 8, 133, 192, 116, 21, 72, 139, 2, 73, 137, 0, 72, 255, 201, 116, 10, 72, 141, 82, 12, 77, 141, 64, 8, 235, 228, 103, 72, 139, 77, 16, 103, 72, 139, 85, 28, 103, 76, 139, 69, 40, 103, 76, 139, 77, 52, 103, 72, 139, 69, 8, 255, 208, 72, 141, 100, 36, 80, 72, 139, 208, 72, 193, 234, 32 })
    置入代码 (#X64_End)
    置入代码 (#X64_RestoreFs)
    置入代码 ({ 139, 229, 93, 194, 128, 0 })
    返回 (0)

.子程序 UNICODE_STRING_X64, 整数型
    .参数 str, 文本型
    .局部变量 wzName, 字节集
    .局部变量 ptr, 整数型
    .局部变量 len, 整数型
    .局部变量 strSize, 整数型

    wzName ＝ 编码_Ansi到Unicode (str, )
    len ＝ lstrlenW (取指针_字节集型 (wzName)) × 2
    strSize ＝ len ＋ 2
    
    ptr ＝ LocalAlloc (#LMEM_ZEROINIT, 16 ＋ strSize)
    __set_short (ptr, 0, len)
    __set_short (ptr, 2, strSize)
    RtlMoveMemory (ptr ＋ 16, 取指针_字节集型 (wzName), strSize)
    __set (ptr, 8, ptr ＋ 16)
    返回 (ptr)

.子程序 __set_short, 整数型, 公开, 请确保指针的合法性,写到内存
    .参数 lpAddr, 整数型, , 内存地址
    .参数 offset, 整数型, , 偏移
    .参数 value, 短整数型, , 写入值

    置入代码 ({ 139, 93, 8, 139, 77, 12, 139, 4, 11, 102, 139, 85, 16, 102, 137, 20, 11, 201, 194, 12, 0 })
    ' mov ebx,[ebp+8]
    ' mov ecx,[ebp+12]
    ' mov eax,[ecx+ebx]
    ' mov dx,[ebp+16]
    ' mov [ecx+ebx],dx
    ' leave
    ' ret 12
    返回 (0)

.子程序 __get_short, 整数型, 公开, 请确保指针的合法性,读取内存
    .参数 lpAddr, 整数型, , 内存地址
    .参数 offset, 整数型, , 偏移

    置入代码 ({ 139, 69, 8, 139, 93, 12, 139, 4, 3, 15, 183, 192, 201, 194, 8, 0 })
    ' mov eax,[ebp+8]
    ' mov ebx,[ebp+12]
    ' mov eax,[eax+ebx]
    ' movzx eax, ax
    ' leave
    ' ret 8
    返回 (0)

.子程序 __get_aryBin2short, 整数型, 公开, 请确保指针的合法性,读取内存
    .参数 lpAddr, 字节集, , 内存地址
    .参数 offset, 整数型, , 偏移

    置入代码 ({ 139, 93, 8, 139, 3, 131, 192, 8, 139, 77, 12, 139, 4, 8, 15, 183, 192, 201, 194, 8, 0 })
    ' mov ebx, dword [ebp+8]
    ' mov eax, dword [ebx]
    ' add eax, 8
    ' mov ecx, dword [ebp+12]
    ' mov eax, dword [eax+ecx]
    ' movzx eax, ax
    ' leave
    ' retn 8
    返回 (0)

.子程序 eWOW64ExtInit, 整数型
    置入代码 (#X86_Init)
    置入代码 (#X64_Init)
    置入代码 ({ 102, 140, 217, 102, 142, 209, 139, 77, 252, 102, 142, 225, 139, 229, 93, 195 })
    返回 (0)

.子程序 GetNtdll64, 长整数型, , ntdll.dll 在 64 位环境下的内存基址，有了它，几乎就无所不能了
    .局部变量 pMods

    pMods ＝ m_Mods
    置入代码 ({ 139, 69, 252, 139, 64, 4, 141, 0, 139, 80, 4, 139, 0, 139, 229, 93, 195 })
    返回 (0)

.子程序 GetProcAddress64, 长整数型, , 取 64 位函数调用地址
    .参数 hModule, 长整数型, , 本模块 GetModuleHandle64* 函数返回值，一般的只能传递 ntdll.dll 的基址
    .参数 lpProcName, 文本型, , 直接调用 64 API 实现而不是取哈希查询，所以区分大小写
    .局部变量 fs
    .局部变量 pMods

    fs ＝ 0
    pMods ＝ m_Mods
    置入代码 (#X64_SaveFs)
    置入代码 (#X64_Start)
    置入代码 ({ 72, 51, 210, 103, 72, 139, 69, 8, 72, 133, 192, 116, 97, 72, 131, 196, 192, 103, 139, 85, 16, 103, 139, 18, 72, 141, 76, 36, 48, 103, 139, 69, 248, 103, 139, 64, 4, 103, 72, 139, 128, 136, 0, 0, 0, 255, 208, 76, 141, 76, 36, 32, 77, 51, 192, 72, 141, 84, 36, 48, 103, 72, 139, 77, 8, 103, 139, 69, 248, 103, 139, 64, 4, 103, 72, 139, 128, 184, 0, 0, 0, 255, 208, 72, 51, 210, 72, 255, 202, 133, 192, 120, 12, 72, 139, 68, 36, 32, 72, 139, 208, 72, 193, 234, 32, 72, 141, 100, 36, 64 })
    置入代码 (#X64_End)
    置入代码 (#X64_RestoreFs)
    置入代码 ({ 133, 210, 121, 19, 139, 200, 139, 85, 248, 139, 2, 139, 128, 164, 1, 0, 0, 255, 208, 51, 192, 51, 210, 139, 229, 93, 194, 12, 0 })
    返回 (0)

.子程序 GetProcAddressEx64, 长整数型, , 取 64 位函数调用地址
    .参数 hModule, 长整数型, , 本模块 GetModuleHandle64* 函数返回值，一般的只能传递 ntdll.dll 的基址
    .参数 dwProcHash, , , 本模块 fn_CalcModOrFuncHash 函数计算值 或者是 函数序号
    .局部变量 pMods

    pMods ＝ m_Mods
    置入代码 (#X64_Start)
    置入代码 ({ 103, 72, 139, 77, 8, 103, 139, 85, 16, 103, 139, 69, 252, 103, 139, 64, 4, 103, 139, 128, 176, 1, 0, 0, 72, 131, 196, 216, 255, 208, 72, 131, 196, 40 })
    置入代码 (#X64_End)
    置入代码 ({ 139, 229, 93, 194, 12, 0 })
    返回 (0)

.版本 2

.程序集 类_任务栏自身, , 公开, 对自身程序任务栏有效
.程序集变量 m_obj, 对象
.程序集变量 m_taskbarBtnCreatedMsg, 整数型

.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
    m_taskbarBtnCreatedMsg ＝ RegisterWindowMessage (“TaskbarButtonCreated”)

.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
    

.子程序 _Create, 整数型
    .参数 ClassId, 字节集
    .参数 iid, 字节集

    m_obj.清除 ()
    返回 (CoCreateInstance_字节集 (ClassId, 0, #CLSCTX_INPROC_SERVER, iid, m_obj))

.子程序 取指针, 整数型, 公开
    返回 (_取指针对象 (m_obj))

.子程序 显示, 逻辑型, 公开, AddTab 将窗口添加到任务栏列表
    .参数 参数_窗口句柄, 整数型, , 建议至少包含 WS_CAPTION 风格
    .局部变量 hr, 整数型

    hr ＝ ITaskbarList_AddTab (_取指针对象 (m_obj), 参数_窗口句柄)
    返回 (hr ＝ 0)
    

.子程序 隐藏, 逻辑型, 公开, DeleteTab 将窗口从任务栏列表删除
    .参数 参数_窗口句柄, 整数型
    .局部变量 hr, 整数型

    hr ＝ ITaskbarList_DeleteTab (_取指针对象 (m_obj), 参数_窗口句柄)
    返回 (hr ＝ 0)

.子程序 销毁, , 公开
    m_obj.清除 ()

.子程序 激活, 逻辑型, 公开, ActivateTab 激活任务栏列表项
    .参数 参数_窗口句柄, 整数型
    .局部变量 hr, 整数型

    hr ＝ ITaskbarList_ActivateTab (_取指针对象 (m_obj), 参数_窗口句柄)
    返回 (hr ＝ 0)

.子程序 标记激活, 逻辑型, 公开, SetActiveAlt 将任务栏列表项标记为激活，但没有视觉效果
    .参数 参数_窗口句柄, 整数型
    .局部变量 hr, 整数型

    hr ＝ ITaskbarList_SetActiveAlt (_取指针对象 (m_obj), 参数_窗口句柄)
    返回 (hr ＝ 0)
    

.子程序 创建, 逻辑型, 公开
    .局部变量 hr, 整数型

    hr ＝ _Create (文本到CLSID (#CLSID_TaskbarList), 文本到CLSID (#IID_ITaskbarList3))
    返回 (hr ＝ 0)
    

.子程序 置进度条值, 逻辑型, 公开, SetProgressValue
    .参数 参数_窗口句柄, 整数型
    .参数 参数_当前位置, 整数型
    .参数 参数_总大小, 整数型
    .局部变量 hr, 整数型

    hr ＝ ITaskbarList_SetProgressValue (取指针 (), 参数_窗口句柄, 参数_当前位置, 参数_总大小)
    返回 (hr ＝ 0)

.子程序 置进度条状态, 逻辑型, 公开, SetProgressState
    .参数 参数_窗口句柄, 整数型
    .参数 参数_进度条状态, 整数型, , “任务栏进度_”开头常量
    .局部变量 hr, 整数型

    hr ＝ ITaskbarList_SetProgressState (取指针 (), 参数_窗口句柄, 参数_进度条状态)
    返回 (hr ＝ 0)
    

.子程序 注册选项卡, 逻辑型, 公开, RegisterTab
    .参数 参数_选项卡窗口, 整数型, , 必须已注册
    .参数 参数_主窗口, 整数型, , 应用程序主窗口
    .局部变量 hr, 整数型

    hr ＝ ITaskbarList_RegisterTab (取指针 (), 参数_选项卡窗口, 参数_主窗口)
    返回 (hr ＝ 0)
    

.子程序 卸载选项卡, 逻辑型, 公开, UnregisterTab
    .参数 参数_选项卡窗口, 整数型, , 必须已注册
    .局部变量 hr, 整数型

    hr ＝ ITaskbarList_UnregisterTab (取指针 (), 参数_选项卡窗口)
    返回 (hr ＝ 0)

.子程序 置选项卡顺序, 逻辑型, 公开, SetTabOrder
    .参数 参数_选项卡窗口, 整数型, , 必须已注册
    .参数 参数_此窗口句柄之前, 整数型, , 可以为0
    .局部变量 hr, 整数型

    hr ＝ ITaskbarList_SetTabOrder (取指针 (), 参数_选项卡窗口, 参数_此窗口句柄之前)
    返回 (hr ＝ 0)
    

.子程序 激活选项卡, 逻辑型, 公开, SetTabActive
    .参数 参数_选项卡窗口, 整数型, , 必须已注册
    .参数 参数_主窗口, 整数型
    .局部变量 hr, 整数型

    hr ＝ ITaskbarList_SetTabActive (取指针 (), 参数_选项卡窗口, 参数_主窗口, 0)
    返回 (hr ＝ 0)

.子程序 添加按钮, 逻辑型, 公开, ThumbBarAddButtons
    .参数 参数_窗口句柄, 整数型
    .参数 参数_缩略图按钮组, 精易_任务栏缩略图按钮, 数组
    .局部变量 thumbBtn, THUMBBUTTON
    .局部变量 wstr, 字节集
    .局部变量 pButton, 整数型
    .局部变量 hr, 整数型
    .局部变量 count, 整数型
    .局部变量 i, 整数型

    count ＝ 取数组成员数 (参数_缩略图按钮组)
    pButton ＝ _Alloc (540 × count)
    .计次循环首 (count, i)
        thumbBtn.dwMask ＝ 参数_缩略图按钮组 [i].掩码
        thumbBtn.iId ＝ 参数_缩略图按钮组 [i].ID
        thumbBtn.hIcon ＝ 参数_缩略图按钮组 [i].图标
        thumbBtn.iBitmap ＝ 参数_缩略图按钮组 [i].图片索引
        wstr ＝ 编码_Ansi到Unicode (参数_缩略图按钮组 [i].提示文本, )
        RtlMoveMemory_bytes (thumbBtn.szTip, wstr, 取字节集长度 (wstr))
        thumbBtn.dwFlags ＝ 参数_缩略图按钮组 [i].按钮风格
        RtlMoveMemory_THUMBBUTTON2ptr (pButton ＋ (i － 1) × 540, thumbBtn, 540)
    .计次循环尾 ()
    hr ＝ ITaskbarList_ThumbBarAddButtons (取指针 (), 参数_窗口句柄, count, pButton)
    _Free (pButton)
    返回 (hr ＝ 0)

.子程序 修改按钮, 逻辑型, 公开, ThumbBarUpdateButtons
    .参数 参数_窗口句柄, 整数型
    .参数 参数_缩略图按钮, 精易_任务栏缩略图按钮
    .局部变量 thumbBtn, THUMBBUTTON
    .局部变量 wstr, 字节集
    .局部变量 pButton, 整数型
    .局部变量 hr, 整数型

    pButton ＝ _Alloc (540)
    thumbBtn.dwMask ＝ 参数_缩略图按钮.掩码
    thumbBtn.iId ＝ 参数_缩略图按钮.ID
    thumbBtn.hIcon ＝ 参数_缩略图按钮.图标
    thumbBtn.iBitmap ＝ 参数_缩略图按钮.图片索引
    wstr ＝ 编码_Ansi到Unicode (参数_缩略图按钮.提示文本, )
    RtlMoveMemory_bytes (thumbBtn.szTip, wstr, 取字节集长度 (wstr))
    thumbBtn.dwFlags ＝ 参数_缩略图按钮.按钮风格
    RtlMoveMemory_THUMBBUTTON2ptr (pButton, thumbBtn, 540)
    hr ＝ ITaskbarList_ThumbBarUpdateButtons (取指针 (), 参数_窗口句柄, 1, pButton)
    _Free (pButton)
    返回 (hr ＝ 0)

.子程序 置按钮图片组, 逻辑型, 公开, ThumbBarSetImageList 设置 添加按钮 时的图片组
    .参数 参数_窗口句柄, 整数型
    .参数 参数_图片组, 字节集, , 图片组必须是32位，宽度高度分别为 GetSystemMetrics(SM_CXICON)  GetSystemMetrics(SM_CYICON)
    .局部变量 hr, 整数型
    .局部变量 istream, 整数型
    .局部变量 bin, 字节集
    .局部变量 len, 整数型
    .局部变量 himg, 整数型
    .局部变量 oldhimg, 整数型

    len ＝ 取字节集长度 (参数_图片组)
    bin ＝ 取字节集中间 (参数_图片组, 9, len － 8)
    istream ＝ _CreateIStream (bin)
    .如果真 (istream ＝ 0)
        返回 (假)
    .如果真结束
    himg ＝ ImageList_Read (istream)
    .如果真 (himg ＝ 0)
        ITaskbarList_Release (istream)
        返回 (假)
    .如果真结束
    oldhimg ＝ GetPropA (参数_窗口句柄, “hImageList”)
    .如果真 (oldhimg ≠ 0)
        ImageList_Destroy (oldhimg)
    .如果真结束
    SetPropA (参数_窗口句柄, “hImageList”, himg)
    hr ＝ ITaskbarList_ThumbBarSetImageList (取指针 (), 参数_窗口句柄, himg)
    ITaskbarList_Release (istream)
    返回 (hr ＝ 0)
    

.子程序 置覆盖图标, 逻辑型, 公开, SetOverlayIcon 任务栏必须是大图标模式
    .参数 参数_窗口句柄, 整数型
    .参数 参数_图标句柄, 整数型, , 应该是一个小图标,16 x16 像素 96 dpi
    .参数 参数_描述文本, 文本型
    .局部变量 hIcon, 整数型
    .局部变量 wStr, 字节集
    .局部变量 hr, 整数型

    hIcon ＝ GetPropA (参数_窗口句柄, “OverlayIcon”)
    .如果真 (hIcon ≠ 0)
        DestroyIcon (hIcon)
    .如果真结束
    hIcon ＝ 参数_图标句柄
    SetPropA (参数_窗口句柄, “OverlayIcon”, hIcon)
    wStr ＝ 编码_Ansi到Unicode (参数_描述文本, )
    hr ＝ ITaskbarList_SetOverlayIcon (取指针 (), 参数_窗口句柄, hIcon, _取指针字节集 (wStr))
    返回 (hr ＝ 0)

.子程序 置缩略图提示文本, 逻辑型, 公开, SetThumbnailTooltip
    .参数 参数_窗口句柄, 整数型
    .参数 参数_提示文本, 文本型
    .局部变量 wStr, 字节集
    .局部变量 hr, 整数型

    wStr ＝ 编码_Ansi到Unicode (参数_提示文本, )
    hr ＝ ITaskbarList_SetThumbnailTooltip (取指针 (), 参数_窗口句柄, _取指针字节集 (wStr))
    返回 (hr ＝ 0)

.子程序 置缩略图区域, 逻辑型, 公开, SetThumbnailClip 将窗口的一部分作为缩略图显示
    .参数 参数_窗口句柄, 整数型
    .参数 参数_左边, 整数型
    .参数 参数_顶边, 整数型
    .参数 参数_宽度, 整数型
    .参数 参数_高度, 整数型
    .局部变量 pRect, 整数型
    .局部变量 hr, 整数型

    pRect ＝ _Alloc (16)
    SetRect (pRect, 参数_左边, 参数_顶边, 参数_左边 ＋ 参数_宽度, 参数_顶边 ＋ 参数_高度)
    hr ＝ ITaskbarList_SetThumbnailClip (取指针 (), 参数_窗口句柄, pRect)
    _Free (pRect)
    返回 (hr ＝ 0)
    

.子程序 事件_任务栏按钮被创建, , 公开, TaskbarButtonCreated
    .参数 参数_窗口句柄, 整数型
    .参数 参数_事件指针, 子程序指针, , 返回值：无 （整数型 窗口句柄）
    .局部变量 oldProc, 整数型
    .局部变量 hLib, 整数型
    .局部变量 ChangeWindowMessageFilter, 整数型

    oldProc ＝ GetWindowLongA (参数_窗口句柄, #GWL_WNDPROC)
    .如果真 (oldProc ≠ 到整数 (&WndProc))
        SetWindowLongA (参数_窗口句柄, #GWL_WNDPROC, 到整数 (&WndProc))
        SetPropA (参数_窗口句柄, “oldProc”, oldProc)
    .如果真结束
    hLib ＝ GetModuleHandleA (“User32.dll”)
    .如果真 (hLib ≠ 0)
        ChangeWindowMessageFilter ＝ GetProcAddress (hLib, “ChangeWindowMessageFilter”)
        .如果真 (ChangeWindowMessageFilter ≠ 0)
            call2 (ChangeWindowMessageFilter, m_taskbarBtnCreatedMsg, #MSGFLT_ADD)
            call2 (ChangeWindowMessageFilter, #WM_COMMAND, #MSGFLT_ADD)
        .如果真结束
        
    .如果真结束
    SetPropA (参数_窗口句柄, “taskbarBtnCreatedMsg”, m_taskbarBtnCreatedMsg)
    SetPropA (参数_窗口句柄, “onTaskbarBtnCreated”, 到整数 (参数_事件指针))
    

.子程序 事件_任务栏按钮被单击, , 公开, OnTaskbarButtonClick
    .参数 参数_窗口句柄, 整数型
    .参数 参数_事件指针, 子程序指针, , 返回值：无 （整数型 窗口句柄，整数型 按钮ID）

    SetPropA (参数_窗口句柄, “onTaskbarBtnClick”, 到整数 (参数_事件指针))
    

.版本 2

.程序集 类_外部状态条, , 公开
.程序集变量 集_状态条句柄, 整数型
.程序集变量 hProcess, 整数型

.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
    

.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
    销毁 ()

.子程序 初始化, 逻辑型, 公开
    .参数 参_状态条句柄, 整数型
    .参数 参_是否为外部进程, 逻辑型, 可空
    .局部变量 dwProcessId, 整数型

    .如果真 (IsWindow (参_状态条句柄) ＝ 0)
        返回 (假)
    .如果真结束
    集_状态条句柄 ＝ 参_状态条句柄
    .如果真 (参_是否为外部进程)
        GetWindowThreadProcessId (集_状态条句柄, dwProcessId)
        hProcess ＝ OpenProcess (位或 (#PROCESS_VM_OPERATION, #PROCESS_VM_READ, #PROCESS_VM_WRITE), 0, dwProcessId)
    .如果真结束
    返回 (真)

.子程序 销毁, , 公开
    .如果真 (hProcess ＞ 0)
        CloseHandle (hProcess)
        hProcess ＝ 0
    .如果真结束
    集_状态条句柄 ＝ 0

.子程序 取文本, 文本型, 公开
    .参数 参_栏目索引, 整数型
    .局部变量 局_文本长度, 整数型
    .局部变量 局_栏目文本, 文本型
    .局部变量 局_内存地址, 整数型

    .如果真 (集_状态条句柄 ＝ 0)
        返回 (“”)
    .如果真结束
    局_文本长度 ＝ SendMessageA (集_状态条句柄, #SB_GETTEXTLENGTHA, 参_栏目索引, 0)
    .如果真 (局_文本长度 ＞ 0)
        局_栏目文本 ＝ 取空白文本 (局_文本长度)
        .如果 (hProcess ＞ 0)
            局_内存地址 ＝ 内存_远程创建内存_文本 (hProcess, 局_栏目文本)
            SendMessageA (集_状态条句柄, #SB_GETTEXTA, 参_栏目索引, 局_内存地址)
            ReadProcessMemory_文本型 (hProcess, 局_内存地址, 局_栏目文本, 局_文本长度, 0)
            内存_释放远程内存 (hProcess, 局_内存地址)
        .否则
            SendMessageA (集_状态条句柄, #SB_GETTEXTA, 参_栏目索引, 取指针_文本型 (局_栏目文本))
        .如果结束
        
    .如果真结束
    返回 (局_栏目文本)

.子程序 置文本, , 公开
    .参数 参_栏目索引, 整数型
    .参数 参_栏目文本, 文本型
    .局部变量 局_内存地址, 整数型

    .如果真 (集_状态条句柄 ＝ 0)
        返回 ()
    .如果真结束
    .如果 (hProcess ＞ 0)
        局_内存地址 ＝ 内存_远程创建内存_文本 (hProcess, 参_栏目文本)
        SendMessageA (集_状态条句柄, #SB_SETTEXTA, 参_栏目索引, 局_内存地址)
        内存_释放远程内存 (hProcess, 局_内存地址)
    .否则
        SendMessageA (集_状态条句柄, #SB_SETTEXTA, 参_栏目索引, 取指针文本_ (参_栏目文本))
    .如果结束
    

.子程序 背景颜色, , 公开
    .参数 参_RGB, 整数型

    .如果真 (集_状态条句柄 ＝ 0)
        返回 ()
    .如果真结束
    SendMessageA (集_状态条句柄, #SB_SETBKCOLOR, 0, 参_RGB)

.版本 2

.程序集 类_外部选择夹, , 公开
.程序集变量 hTabCtrl, 整数型
.程序集变量 dwProcessId, 整数型
.程序集变量 isRemote, 逻辑型
.程序集变量 hProcess, 整数型
.程序集变量 isWow64, 逻辑型

.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
    

.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
    .如果真 (hProcess ≠ #NULL)
        CloseHandle (hProcess)
        hProcess ＝ #NULL
    .如果真结束
    

.子程序 初始化选择夹, 逻辑型, 公开
    .参数 窗口句柄, 整数型
    .局部变量 dwCurrentId, 整数型

    dwCurrentId ＝ GetCurrentProcessId ()
    GetWindowThreadProcessId (窗口句柄, dwProcessId)
    isRemote ＝ dwCurrentId ≠ dwProcessId
    hProcess ＝ OpenProcess (#PROCESS_ALL_ACCESS, 0, dwProcessId)
    .如果真 (hProcess ≠ #NULL)
        .如果真 (IsWow64Process (hProcess, isWow64) 且 isWow64 ＝ 假)
            CloseHandle (hProcess)
            hProcess ＝ #NULL
            返回 (假)
        .如果真结束
        hTabCtrl ＝ 窗口句柄
    .如果真结束
    返回 (hProcess ≠ #NULL)

.子程序 销毁, , 公开
    .如果真 (hProcess ≠ #NULL)
        CloseHandle (hProcess)
        hProcess ＝ #NULL
    .如果真结束
    

.子程序 删除子夹, 逻辑型, 公开, 成功返回真
    .参数 欲删除的子夹索引, 整数型, , 0 代表子夹一，1 代表子夹二，如此类推。-1为最末端子夹。(注意：易语言的子夹索引是从1计起，这个类是按照微软的标准从0计起)。
    .局部变量 dwCount, 整数型
    .局部变量 lRes, 整数型

    .如果真 (欲删除的子夹索引 ＜ 0)
        dwCount ＝ 取子夹数目 ()
        .如果真 (dwCount ＝ 0)
            返回 (假)
        .如果真结束
        欲删除的子夹索引 ＝ dwCount － 1
    .如果真结束
    lRes ＝ SendMessageA (hTabCtrl, #TCM_DELETEITEM, 欲删除的子夹索引, 0)
    返回 (lRes ≠ 0)

.子程序 插入子夹, 整数型, 公开, 成功返回位置索引，失败返回-1
    .参数 插入位置, 整数型, 可空, 默认为-1，加到子夹末尾。0 代表子夹一，1 代表子夹二，如此类推(注意：易语言的子夹索引是从1计起，这个类是按照微软的标准从0计起)。
    .参数 子夹标题, 文本型
    .参数 子夹项目数值, 整数型, 可空, 默认为0
    .参数 图片索引, 整数型, 可空, 默认为-1(无图片)
    .局部变量 dwCount, 整数型
    .局部变量 dwSize, 整数型
    .局部变量 pItem, 整数型
    .局部变量 lRes, 整数型

    .如果真 (是否为空 (图片索引) 或 取图片组句柄 () ＝ 0)
        图片索引 ＝ -1
    .如果真结束
    dwCount ＝ 取子夹数目 ()
    .如果真 (是否为空 (插入位置) 或 插入位置 ＞ dwCount － 1 或 插入位置 ＝ -1)
        插入位置 ＝ dwCount
    .如果真结束
    dwSize ＝ 28 ' sizeof(TCITEMA)
    .如果 (isRemote)
        .如果真 (hProcess ≠ #NULL)
            pItem ＝ VirtualAllocEx (hProcess, #NULL, dwSize ＋ #MAX_PATH, 位或 (#MEM_RESERVE, #MEM_COMMIT), #PAGE_READWRITE)
            .如果真 (pItem ≠ #NULL)
                WriteProcessMemory_整数35 (hProcess, pItem, 位或 (#TCIF_TEXT, #TCIF_IMAGE, #TCIF_PARAM), 4, #NULL) ' mask
                WriteProcessMemory_文本型 (hProcess, pItem ＋ dwSize, 子夹标题 ＋ 字符 (#NULL), 取文本长度 (子夹标题), #NULL)
                WriteProcessMemory_整数35 (hProcess, pItem ＋ 12, pItem ＋ dwSize, 4, #NULL) ' pszText
                WriteProcessMemory_整数35 (hProcess, pItem ＋ 16, 取文本长度 (子夹标题), 4, #NULL) ' cchTextMax
                WriteProcessMemory_整数35 (hProcess, pItem ＋ 20, 图片索引, 4, #NULL) ' iImage
                WriteProcessMemory_整数35 (hProcess, pItem ＋ 24, 子夹项目数值, 4, #NULL) ' lParam
                lRes ＝ SendMessageA (hTabCtrl, #TCM_INSERTITEMA, 插入位置, pItem)
                VirtualFreeEx (hProcess, pItem, 0, #MEM_RELEASE)
            .如果真结束
            
        .如果真结束
        
    .否则
        pItem ＝ HeapAlloc (GetProcessHeap (), #HEAP_ZERO_MEMORY, dwSize)
        .如果真 (pItem ≠ #NULL)
            __set (pItem, 0, 位或 (#TCIF_TEXT, #TCIF_IMAGE, #TCIF_PARAM))
            __set (pItem, 12, 取指针文本_ (子夹标题))
            __set (pItem, 16, 取文本长度 (子夹标题))
            __set (pItem, 20, 图片索引)
            __set (pItem, 24, 子夹项目数值)
            lRes ＝ SendMessageA (hTabCtrl, #TCM_INSERTITEMA, 插入位置, pItem)
            HeapFree (GetProcessHeap (), 0, pItem)
        .如果真结束
        
    .如果结束
    .如果真 (dwCount ＝ 0)
        UpdateWindow (GetParent (hTabCtrl))
    .如果真结束
    返回 (lRes)

.子程序 取子夹数目, 整数型, 公开
    返回 (SendMessageA (hTabCtrl, #TCM_GETITEMCOUNT, 0, 0))

.子程序 取子夹标题, 文本型, 公开
    .参数 子夹索引, 整数型, , 0 代表子夹一，1 代表子夹二，如此类推。-1为最末端子夹。(注意：易语言的子夹索引是从1计起，这个类是按照微软的标准从0计起)。
    .局部变量 dwCount, 整数型
    .局部变量 dwSize, 整数型
    .局部变量 pItem, 整数型
    .局部变量 lRes, 整数型
    .局部变量 szText, 文本型

    .如果真 (子夹索引 ＜ 0)
        dwCount ＝ 取子夹数目 ()
        .如果真 (dwCount ＝ 0)
            返回 (szText)
        .如果真结束
        子夹索引 ＝ dwCount － 1
    .如果真结束
    dwSize ＝ 28 ' sizeof(TCITEMA)
    .如果 (isRemote)
        .如果真 (hProcess ≠ #NULL)
            pItem ＝ VirtualAllocEx (hProcess, #NULL, dwSize ＋ #MAX_PATH, 位或 (#MEM_RESERVE, #MEM_COMMIT), #PAGE_READWRITE)
            .如果真 (pItem ≠ #NULL)
                WriteProcessMemory_整数35 (hProcess, pItem, #TCIF_TEXT, 4, #NULL) ' mask
                WriteProcessMemory_整数35 (hProcess, pItem ＋ 12, pItem ＋ dwSize, 4, #NULL) ' pszText
                WriteProcessMemory_整数35 (hProcess, pItem ＋ 16, #MAX_PATH, 4, #NULL) ' cchTextMax
                lRes ＝ SendMessageA (hTabCtrl, #TCM_GETITEMA, 子夹索引, pItem)
                .如果真 (lRes ≠ 0)
                    szText ＝ 取空白文本 (#MAX_PATH)
                    ReadProcessMemory_文本型 (hProcess, pItem ＋ dwSize, szText, #MAX_PATH, #NULL)
                .如果真结束
                VirtualFreeEx (hProcess, pItem, 0, #MEM_RELEASE)
            .如果真结束
            
        .如果真结束
        
    .否则
        pItem ＝ HeapAlloc (GetProcessHeap (), #HEAP_ZERO_MEMORY, dwSize)
        .如果真 (pItem ≠ #NULL)
            __set (pItem, 0, #TCIF_TEXT)
            szText ＝ 取空白文本 (#MAX_PATH)
            __set (pItem, 12, 取指针文本_ (szText))
            __set (pItem, 16, #MAX_PATH)
            lRes ＝ SendMessageA (hTabCtrl, #TCM_GETITEMA, 子夹索引, pItem)
            HeapFree (GetProcessHeap (), 0, pItem)
        .如果真结束
        
    .如果结束
    返回 (szText)

.子程序 取子夹数值, 整数型, 公开
    .参数 子夹索引, 整数型, , 0 代表子夹一，1 代表子夹二，如此类推。-1为最末端子夹。(注意：易语言的子夹索引是从1计起，这个类是按照微软的标准从0计起)。
    .局部变量 dwCount, 整数型
    .局部变量 dwSize, 整数型
    .局部变量 pItem, 整数型
    .局部变量 lParam, 整数型
    .局部变量 lRes, 整数型

    .如果真 (子夹索引 ＜ 0)
        dwCount ＝ 取子夹数目 ()
        .如果真 (dwCount ＝ 0)
            返回 (0)
        .如果真结束
        子夹索引 ＝ dwCount － 1
    .如果真结束
    dwSize ＝ 28 ' sizeof(TCITEMA)
    .如果 (isRemote)
        .如果真 (hProcess ≠ #NULL)
            pItem ＝ VirtualAllocEx (hProcess, #NULL, dwSize, 位或 (#MEM_RESERVE, #MEM_COMMIT), #PAGE_READWRITE)
            .如果真 (pItem ≠ #NULL)
                WriteProcessMemory_整数35 (hProcess, pItem, #TCIF_PARAM, 4, #NULL) ' mask
                lRes ＝ SendMessageA (hTabCtrl, #TCM_GETITEMA, 子夹索引, pItem)
                .如果真 (lRes ≠ 0)
                    ReadProcessMemory_整数型1 (hProcess, pItem ＋ 24, 取指针整数_ (lParam), 4, #NULL)
                .如果真结束
                VirtualFreeEx (hProcess, pItem, 0, #MEM_RELEASE)
            .如果真结束
            
        .如果真结束
        
    .否则
        pItem ＝ HeapAlloc (GetProcessHeap (), #HEAP_ZERO_MEMORY, dwSize)
        .如果真 (pItem ≠ #NULL)
            __set (pItem, 0, #TCIF_PARAM)
            lRes ＝ SendMessageA (hTabCtrl, #TCM_GETITEMA, 子夹索引, pItem)
            .如果真 (lRes ≠ 0)
                lParam ＝ __get (pItem, 24)
            .如果真结束
            HeapFree (GetProcessHeap (), 0, pItem)
        .如果真结束
        
    .如果结束
    返回 (lParam)

.子程序 置子夹标题, 逻辑型, 公开
    .参数 子夹索引, 整数型, , 0 代表子夹一，1 代表子夹二，如此类推。-1为最末端子夹。(注意：易语言的子夹索引是从1计起，这个类是按照微软的标准从0计起)。
    .参数 欲置入的子夹标题, 文本型
    .局部变量 dwCount, 整数型
    .局部变量 dwSize, 整数型
    .局部变量 pItem, 整数型
    .局部变量 lRes, 整数型

    .如果真 (子夹索引 ＜ 0)
        dwCount ＝ 取子夹数目 ()
        .如果真 (dwCount ＝ 0)
            返回 (假)
        .如果真结束
        子夹索引 ＝ dwCount － 1
    .如果真结束
    dwSize ＝ 28 ' sizeof(TCITEMA)
    .如果 (isRemote)
        .如果真 (hProcess ≠ #NULL)
            pItem ＝ VirtualAllocEx (hProcess, #NULL, dwSize ＋ #MAX_PATH, 位或 (#MEM_RESERVE, #MEM_COMMIT), #PAGE_READWRITE)
            .如果真 (pItem ≠ #NULL)
                WriteProcessMemory_整数35 (hProcess, pItem, #TCIF_TEXT, 4, #NULL) ' mask
                WriteProcessMemory_文本型 (hProcess, pItem ＋ dwSize, 欲置入的子夹标题 ＋ 字符 (#NULL), 取文本长度 (欲置入的子夹标题), #NULL)
                WriteProcessMemory_整数35 (hProcess, pItem ＋ 12, pItem ＋ dwSize, 4, #NULL) ' pszText
                WriteProcessMemory_整数35 (hProcess, pItem ＋ 16, 取文本长度 (欲置入的子夹标题), 4, #NULL) ' cchTextMax
                lRes ＝ SendMessageA (hTabCtrl, #TCM_SETITEMA, 子夹索引, pItem)
                VirtualFreeEx (hProcess, pItem, 0, #MEM_RELEASE)
            .如果真结束
            
        .如果真结束
        
    .否则
        pItem ＝ HeapAlloc (GetProcessHeap (), #HEAP_ZERO_MEMORY, dwSize)
        .如果真 (pItem ≠ #NULL)
            __set (pItem, 0, #TCIF_TEXT)
            __set (pItem, 12, 取指针文本_ (欲置入的子夹标题))
            __set (pItem, 16, 取文本长度 (欲置入的子夹标题))
            lRes ＝ SendMessageA (hTabCtrl, #TCM_SETITEMA, 子夹索引, pItem)
            HeapFree (GetProcessHeap (), 0, pItem)
        .如果真结束
        
    .如果结束
    返回 (lRes ≠ 0)

.子程序 置子夹数值, 逻辑型, 公开
    .参数 子夹索引, 整数型, , 0 代表子夹一，1 代表子夹二，如此类推。-1为最末端子夹。(注意：易语言的子夹索引是从1计起，这个类是按照微软的标准从0计起)。
    .参数 欲置入的子夹数值, 整数型
    .局部变量 dwCount, 整数型
    .局部变量 dwSize, 整数型
    .局部变量 pItem, 整数型
    .局部变量 lParam, 整数型
    .局部变量 lRes, 整数型

    .如果真 (子夹索引 ＜ 0)
        dwCount ＝ 取子夹数目 ()
        .如果真 (dwCount ＝ 0)
            返回 (假)
        .如果真结束
        子夹索引 ＝ dwCount － 1
    .如果真结束
    dwSize ＝ 28 ' sizeof(TCITEMA)
    .如果 (isRemote)
        .如果真 (hProcess ≠ #NULL)
            pItem ＝ VirtualAllocEx (hProcess, #NULL, dwSize, 位或 (#MEM_RESERVE, #MEM_COMMIT), #PAGE_READWRITE)
            .如果真 (pItem ≠ #NULL)
                WriteProcessMemory_整数35 (hProcess, pItem, #TCIF_PARAM, 4, #NULL) ' mask
                WriteProcessMemory_整数35 (hProcess, pItem ＋ 24, 欲置入的子夹数值, 4, #NULL) ' lParam
                lRes ＝ SendMessageA (hTabCtrl, #TCM_SETITEMA, 子夹索引, pItem)
                VirtualFreeEx (hProcess, pItem, 0, #MEM_RELEASE)
            .如果真结束
            
        .如果真结束
        
    .否则
        pItem ＝ HeapAlloc (GetProcessHeap (), #HEAP_ZERO_MEMORY, dwSize)
        .如果真 (pItem ≠ #NULL)
            __set (pItem, 0, #TCIF_PARAM)
            __set (pItem, 24, 欲置入的子夹数值)
            lRes ＝ SendMessageA (hTabCtrl, #TCM_SETITEMA, 子夹索引, pItem)
            HeapFree (GetProcessHeap (), 0, pItem)
        .如果真结束
        
    .如果结束
    返回 (lRes ≠ 0)

.子程序 置现行子夹, , 公开
    .参数 欲选择的子夹索引, 整数型, , 0 代表子夹一，1 代表子夹二，如此类推。-1为最末端子夹。(注意：易语言的子夹索引是从1计起，这个类是按照微软的标准从0计起)。
    .局部变量 dwCount, 整数型

    .如果真 (欲选择的子夹索引 ＜ 0)
        dwCount ＝ 取子夹数目 ()
        .如果真 (dwCount ＝ 0)
            返回 ()
        .如果真结束
        欲选择的子夹索引 ＝ dwCount － 1
    .如果真结束
    SendMessageA (hTabCtrl, #TCM_SETCURFOCUS, 欲选择的子夹索引, 0)

.子程序 取现行子夹, 整数型, 公开, 0 代表子夹一，1 代表子夹二，如此类推(注意：易语言的子夹索引是从1计起，这个类是按照微软的标准从0计起)。
    返回 (SendMessageA (hTabCtrl, #TCM_GETCURFOCUS, 0, 0))

.子程序 删除全部子夹, , 公开
    SendMessageA (hTabCtrl, #TCM_DELETEALLITEMS, 0, 0)

.子程序 取图片组句柄, 整数型, 公开
    返回 (SendMessageA (hTabCtrl, #TCM_GETIMAGELIST, 0, 0))

.子程序 取行数, 整数型, 公开
    返回 (SendMessageA (hTabCtrl, #TCM_GETROWCOUNT, 0, 0))

.子程序 置入图片组, , 公开
    .参数 图片组句柄, 整数型

    SendMessageA (hTabCtrl, #TCM_SETIMAGELIST, 0, 图片组句柄)

.子程序 置子夹图片, 逻辑型, 公开
    .参数 子夹索引, 整数型, , 0 代表子夹一，1 代表子夹二，如此类推。-1为最末端子夹。(注意：易语言的子夹索引是从1计起，这个类是按照微软的标准从0计起)。
    .参数 图片索引, 整数型
    .局部变量 dwCount, 整数型
    .局部变量 dwSize, 整数型
    .局部变量 pItem, 整数型
    .局部变量 lParam, 整数型
    .局部变量 lRes, 整数型

    .如果真 (子夹索引 ＜ 0)
        dwCount ＝ 取子夹数目 ()
        .如果真 (dwCount ＝ 0)
            返回 (假)
        .如果真结束
        子夹索引 ＝ dwCount － 1
    .如果真结束
    dwSize ＝ 28 ' sizeof(TCITEMA)
    .如果 (isRemote)
        .如果真 (hProcess ≠ #NULL)
            pItem ＝ VirtualAllocEx (hProcess, #NULL, dwSize, 位或 (#MEM_RESERVE, #MEM_COMMIT), #PAGE_READWRITE)
            .如果真 (pItem ≠ #NULL)
                WriteProcessMemory_整数35 (hProcess, pItem, #TCIF_IMAGE, 4, #NULL) ' mask
                WriteProcessMemory_整数35 (hProcess, pItem ＋ 20, 图片索引, 4, #NULL) ' iImage
                lRes ＝ SendMessageA (hTabCtrl, #TCM_SETITEMA, 子夹索引, pItem)
                VirtualFreeEx (hProcess, pItem, 0, #MEM_RELEASE)
            .如果真结束
            
        .如果真结束
        
    .否则
        pItem ＝ HeapAlloc (GetProcessHeap (), #HEAP_ZERO_MEMORY, dwSize)
        .如果真 (pItem ≠ #NULL)
            __set (pItem, 0, #TCIF_IMAGE)
            __set (pItem, 20, 图片索引)
            lRes ＝ SendMessageA (hTabCtrl, #TCM_SETITEMA, 子夹索引, pItem)
            HeapFree (GetProcessHeap (), 0, pItem)
        .如果真结束
        
    .如果结束
    返回 (lRes ≠ 0)

.子程序 置子夹栏尺寸, , 公开
    .参数 子夹栏宽度, 整数型
    .参数 子夹栏高度, 整数型

    SendMessageA (hTabCtrl, #TCM_SETITEMSIZE, 0, MAKEWORD (子夹栏宽度, 子夹栏高度))

.子程序 置子夹栏宽度, , 公开
    .参数 子夹栏宽度, 整数型

    SendMessageA (hTabCtrl, #TCM_SETMINTABWIDTH, 0, 子夹栏宽度)

.版本 2

.程序集 类_树型框_字节集操作, , 公开, 仅作为树型框项目数据的操作，并非对外部或自身组件操作
.程序集变量 类_ID, 整数型

.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
    类_ID ＝ 打开内存文件 ()

.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
    清空 ()
    关闭文件 (类_ID)

.子程序 生成项目, 字节集, 公开, 创建一条项目。
    .参数 项目文本, 文本型
    .参数 图片索引, 整数型
    .参数 选中后图片索引, 整数型
    .参数 项目数值, 整数型
    .参数 是否加粗, 逻辑型, 可空, 空 不加粗
    .参数 是否扩展, 逻辑型, 可空, 空 展开
    .参数 缩进层次, 整数型
    .参数 检查框状态索引, 整数型, 可空, 空 = -1 表示无检查框，索引从零开始
    .局部变量 局_长度, 整数型
    .局部变量 局_项目数据, 字节集

    局_长度 ＝ 取文本长度 (项目文本)
    局_项目数据 ＝ 取空白字节集 (局_长度 ＋ 21)
    局_项目数据 ＝ 字节集替换 (局_项目数据, 1, 局_长度, 到字节集 (项目文本)) ' 项目文本
    局_项目数据 ＝ 字节集替换 (局_项目数据, 局_长度 ＋ 2, 4, 到字节集 (图片索引))
    局_项目数据 ＝ 字节集替换 (局_项目数据, 局_长度 ＋ 6, 4, 到字节集 (选中后图片索引))
    局_项目数据 ＝ 字节集替换 (局_项目数据, 局_长度 ＋ 10, 4, 到字节集 (项目数值))
    
    .如果真 (是否为空 (是否加粗))
        是否加粗 ＝ 假
    .如果真结束
    .如果真 (是否为空 (是否扩展))
        是否扩展 ＝ 真
    .如果真结束
    
    .判断开始 (是否加粗 ＝ 假 且 是否扩展 ＝ 假)
        局_项目数据 ＝ 字节集替换 (局_项目数据, 局_长度 ＋ 14, 4, { 0, 0, 0, 0 })
    .判断 (是否加粗 且 是否扩展 ＝ 假)
        局_项目数据 ＝ 字节集替换 (局_项目数据, 局_长度 ＋ 14, 4, { 1, 0, 0, 0 })
    .判断 (是否加粗 ＝ 假 且 是否扩展)
        局_项目数据 ＝ 字节集替换 (局_项目数据, 局_长度 ＋ 14, 4, { 2, 0, 0, 0 })
    .默认
        局_项目数据 ＝ 字节集替换 (局_项目数据, 局_长度 ＋ 14, 4, { 3, 0, 0, 0 })
    .判断结束
    
    .如果 (是否为空 (检查框状态索引) 或 检查框状态索引 ＝ -1)
        
    .否则
        局_项目数据 ＝ 字节集替换 (局_项目数据, 局_长度 ＋ 17, 1, 到字节集 (到字节 ((检查框状态索引 ＋ 1) × 16)))
    .如果结束
    局_项目数据 ＝ 字节集替换 (局_项目数据, 局_长度 ＋ 18, 4, 到字节集 (缩进层次))
    返回 (局_项目数据)

.子程序 初始化自字节集, 逻辑型, 公开, 从字节集创建树项目数据。
    .参数 树项目, 字节集

    .如果真 (类_ID ＝ 0)
        返回 (假)
    .如果真结束
    清空 ()
    
    写出字节集 (类_ID, 树项目)
    移到文件首 (类_ID)
    返回 (真)

.子程序 初始化自文件, 逻辑型, 公开, 从文件创建树项目数据。
    .参数 文件, 文本型

    .如果真 (类_ID ＝ 0)
        返回 (假)
    .如果真结束
    清空 ()
    
    .如果真 (文件是否存在 (文件))
        写出字节集 (类_ID, 读入文件 (文件))
        移到文件首 (类_ID)
        返回 (真)
    .如果真结束
    返回 (假)

.子程序 初始化, 逻辑型, 公开, 创建一个空的树项目数据。
    .如果真 (类_ID ＝ 0)
        返回 (假)
    .如果真结束
    清空 ()
    返回 (真)

.子程序 取项目, 字节集, 公开, 失败返回一个空字节集
    .局部变量 Z, 字节集

    移到文件首 (类_ID)
    Z ＝ 读入字节集 (类_ID, 取文件长度 (类_ID))
    移到文件首 (类_ID)
    返回 (Z)

.子程序 取项目数, 整数型, 公开, 返回树型框中所有项目的数目。
    .局部变量 项目, 字节集
    .局部变量 临位, 整数型
    .局部变量 索引, 整数型

    移到文件首 (类_ID)
    项目 ＝ 读入字节集 (类_ID, 取文件长度 (类_ID))
    移到文件首 (类_ID)
    .判断循环首 (取字节集长度 (项目) － 临位 ＞ 21)
        临位 ＝ 寻找字节集 (项目, { 0 }, 临位)
        索引 ＝ 索引 ＋ 1
        临位 ＝ 临位 ＋ 21
    .判断循环尾 ()
    返回 (索引)

.子程序 取缩进层次, 整数型, 公开, 返回指定项目所处缩进层次，层次值从1开始。如果未找到指定项目，返回 0 。
    .参数 项目索引, 整数型, , 0 为项目一，1 为项目二，如此类推。
    .局部变量 项目, 字节集
    .局部变量 起位置, 整数型
    .局部变量 索引, 整数型

    项目 ＝ 读入字节集 (类_ID, 取文件长度 (类_ID))
    移到文件首 (类_ID)
    .判断循环首 (取字节集长度 (项目) － 起位置 ＞ 21)
        起位置 ＝ 寻找字节集 (项目, { 0 }, 起位置)
        .如果真 (索引 ＝ 项目索引)
            返回 (到数值 (取字节集数据 (项目, #字节型, 起位置 ＋ 17)))
        .如果真结束
        索引 ＝ 索引 ＋ 1
        起位置 ＝ 起位置 ＋ 21
    .判断循环尾 ()
    返回 (0)

.子程序 取项目文本, 文本型, 公开, 返回指定项目的文本。如果该项目不存在，将返回空文本。
    .参数 项目索引, 整数型, , 0 为项目一，1 为项目二，如此类推。
    .局部变量 项目, 字节集
    .局部变量 临位, 整数型
    .局部变量 索引, 整数型

    项目 ＝ 读入字节集 (类_ID, 取文件长度 (类_ID))
    移到文件首 (类_ID)
    临位 ＝ 1
    .判断循环首 (取字节集长度 (项目) － 临位 ＞ 21)
        .如果真 (索引 ＝ 项目索引) ' 与上一项目索引一样时，刚好对应的是目标项目的位置
            返回 (到文本 (取字节集中间 (项目, 临位, 寻找字节集 (项目, { 0 }, 临位) － 临位)))
        .如果真结束
        临位 ＝ 寻找字节集 (项目, { 0 }, 临位)
        索引 ＝ 索引 ＋ 1
        临位 ＝ 临位 ＋ 21
    .判断循环尾 ()
    返回 (“”)

.子程序 取图片, 整数型, 公开, 返回指定项目的图片索引。如果该项目不存在，将返回 -1 。
    .参数 项目索引, 整数型, , 0 为项目一，1 为项目二，如此类推。
    .局部变量 项目, 字节集
    .局部变量 起位置, 整数型
    .局部变量 索引, 整数型

    项目 ＝ 读入字节集 (类_ID, 取文件长度 (类_ID))
    移到文件首 (类_ID)
    .判断循环首 (取字节集长度 (项目) － 起位置 ＞ 21)
        起位置 ＝ 寻找字节集 (项目, { 0 }, 起位置)
        .如果真 (索引 ＝ 项目索引)
            返回 (取字节集数据 (项目, #整数型, 起位置 ＋ 1))
        .如果真结束
        索引 ＝ 索引 ＋ 1
        起位置 ＝ 起位置 ＋ 21
    .判断循环尾 ()
    返回 (0)

.子程序 取选中图片, 整数型, 公开, 返回指定项目被选中后的图片索引。如果该项目不存在，将返回 -1 。
    .参数 项目索引, 整数型, , 0 为项目一，1 为项目二，如此类推。
    .局部变量 项目, 字节集
    .局部变量 起位置, 整数型
    .局部变量 索引, 整数型

    项目 ＝ 读入字节集 (类_ID, 取文件长度 (类_ID))
    移到文件首 (类_ID)
    .判断循环首 (取字节集长度 (项目) － 起位置 ＞ 21)
        起位置 ＝ 寻找字节集 (项目, { 0 }, 起位置)
        .如果真 (索引 ＝ 项目索引)
            返回 (取字节集数据 (项目, #整数型, 起位置 ＋ 5))
        .如果真结束
        索引 ＝ 索引 ＋ 1
        起位置 ＝ 起位置 ＋ 21
    .判断循环尾 ()
    返回 (0)

.子程序 取项目数值, 整数型, 公开, 返回与指定项目相关联的数值。如果该项目不存在，将返回 0 。
    .参数 项目索引, 整数型, , 0 为项目一，1 为项目二，如此类推。
    .局部变量 项目, 字节集
    .局部变量 起位置, 整数型
    .局部变量 索引, 整数型

    项目 ＝ 读入字节集 (类_ID, 取文件长度 (类_ID))
    移到文件首 (类_ID)
    .判断循环首 (取字节集长度 (项目) － 起位置 ＞ 21)
        起位置 ＝ 寻找字节集 (项目, { 0 }, 起位置)
        .如果真 (索引 ＝ 项目索引)
            返回 (取字节集数据 (项目, #整数型, 起位置 ＋ 9))
        .如果真结束
        索引 ＝ 索引 ＋ 1
        起位置 ＝ 起位置 ＋ 21
    .判断循环尾 ()
    返回 (0)

.子程序 置项目文本, 逻辑型, 公开, 设置指定项目的文本。成功返回真，失败返回假。
    .参数 项目索引, 整数型, , 0 为项目一，1 为项目二，如此类推。
    .参数 欲置入的项目文本, 文本型
    .局部变量 项目, 字节集
    .局部变量 临位, 整数型
    .局部变量 索引, 整数型
    .局部变量 起始位置, 整数型
    .局部变量 结束位置, 整数型

    项目 ＝ 读入字节集 (类_ID, 取文件长度 (类_ID))
    移到文件首 (类_ID)
    临位 ＝ 1
    .判断循环首 (取字节集长度 (项目) － 临位 ＞ 21)
        .如果真 (索引 ＝ 项目索引) ' 与上一项目索引一样时，刚好对应的是目标项目的位置
            起始位置 ＝ 临位
            结束位置 ＝ 寻找字节集 (项目, { 0 }, 临位)
            跳出循环 ()
        .如果真结束
        临位 ＝ 寻找字节集 (项目, { 0 }, 临位)
        索引 ＝ 索引 ＋ 1
        临位 ＝ 临位 ＋ 21
    .判断循环尾 ()
    清空 ()
    写出字节集 (类_ID, 字节集替换 (项目, 起始位置, 结束位置 － 起始位置, 到字节集 (欲置入的项目文本)))
    返回 (移到文件首 (类_ID))

.子程序 置图片, 逻辑型, 公开, 设置在指定项目首部所显示图片的索引。成功返回真，失败返回假。
    .参数 项目索引, , , 0 为项目一，1 为项目二，如此类推。
    .参数 图片索引, 整数型, , 图片索引用于指定图片组属性中的某张图片，从 0 开始。
    .局部变量 索引, 整数型
    .局部变量 项目, 字节集
    .局部变量 起位置, 整数型

    项目 ＝ 读入字节集 (类_ID, 取文件长度 (类_ID))
    移到文件首 (类_ID)
    .判断循环首 (取字节集长度 (项目) － 起位置 ＞ 21)
        起位置 ＝ 寻找字节集 (项目, { 0 }, 起位置)
        .如果真 (索引 ＝ 项目索引)
            清空 ()
            写出字节集 (类_ID, 字节集替换 (项目, 起位置 ＋ 1, #整数型, 到字节集 (图片索引)))
            跳出循环 ()
        .如果真结束
        索引 ＝ 索引 ＋ 1
        起位置 ＝ 起位置 ＋ 21
    .判断循环尾 ()
    返回 (移到文件首 (类_ID))

.子程序 置选中图片, 逻辑型, 公开, 设置指定项目被选中后所显示图片的索引。成功返回真，失败返回假。
    .参数 项目索引, , , 0 为项目一，1 为项目二，如此类推。
    .参数 图片索引, 整数型, , 图片索引用于指定图片组属性中的某张图片，从 0 开始。
    .局部变量 索引, 整数型
    .局部变量 项目, 字节集
    .局部变量 起位置, 整数型

    项目 ＝ 读入字节集 (类_ID, 取文件长度 (类_ID))
    移到文件首 (类_ID)
    .判断循环首 (取字节集长度 (项目) － 起位置 ＞ 21)
        起位置 ＝ 寻找字节集 (项目, { 0 }, 起位置)
        .如果真 (索引 ＝ 项目索引)
            清空 ()
            写出字节集 (类_ID, 字节集替换 (项目, 起位置 ＋ 5, #整数型, 到字节集 (图片索引)))
            跳出循环 ()
        .如果真结束
        索引 ＝ 索引 ＋ 1
        起位置 ＝ 起位置 ＋ 21
    .判断循环尾 ()
    返回 (移到文件首 (类_ID))

.子程序 置项目数值, 逻辑型, 公开, 设置与指定项目相关联的数值。成功返回真，失败返回假。
    .参数 项目索引, , , 0 为项目一，1 为项目二，如此类推。
    .参数 欲置入的项目数值, 整数型, 可空, 可以被省略。该数值与指定项目相关联。如果本参数被省略，默认值为 0 。
    .局部变量 索引, 整数型
    .局部变量 项目, 字节集
    .局部变量 起位置, 整数型

    项目 ＝ 读入字节集 (类_ID, 取文件长度 (类_ID))
    移到文件首 (类_ID)
    .判断循环首 (取字节集长度 (项目) － 起位置 ＞ 21)
        起位置 ＝ 寻找字节集 (项目, { 0 }, 起位置)
        .如果真 (索引 ＝ 项目索引)
            清空 ()
            写出字节集 (类_ID, 字节集替换 (项目, 起位置 ＋ 9, #整数型, 到字节集 (欲置入的项目数值)))
            跳出循环 ()
        .如果真结束
        索引 ＝ 索引 ＋ 1
        起位置 ＝ 起位置 ＋ 21
    .判断循环尾 ()
    返回 (移到文件首 (类_ID))

.子程序 加粗, , 公开
    .局部变量 项目索引, 整数型, , , 0 为项目一，1 为项目二，如此类推。
    .局部变量 项目, 字节集
    .局部变量 索引, 整数型
    .局部变量 粗展状态, 字节型
    .局部变量 起位置, 整数型

    项目 ＝ 读入字节集 (类_ID, 取文件长度 (类_ID))
    移到文件首 (类_ID)
    .判断循环首 (取字节集长度 (项目) － 起位置 ＞ 21)
        起位置 ＝ 寻找字节集 (项目, { 0 }, 起位置)
        .如果真 (索引 ＝ 项目索引)
            粗展状态 ＝ 取字节集数据 (项目, #字节型, 起位置 ＋ 13)
            清空 ()
            .判断开始 (粗展状态 ＝ 0)
                写出字节集 (类_ID, 字节集替换 (项目, 起位置 ＋ 13, 1, { 1 }))
            .判断 (粗展状态 ＝ 2)
                写出字节集 (类_ID, 字节集替换 (项目, 起位置 ＋ 13, 1, { 3 }))
            .默认
                
            .判断结束
            跳出循环 ()
        .如果真结束
        
        索引 ＝ 索引 ＋ 1
        起位置 ＝ 起位置 ＋ 21
    .判断循环尾 ()
    移到文件首 (类_ID)

.子程序 取消加粗, , 公开, 将指定项目的标题取消加粗显示。
    .参数 项目索引, 整数型, , 0 为项目一，1 为项目二，如此类推。
    .局部变量 项目, 字节集
    .局部变量 索引, 整数型
    .局部变量 粗展状态, 字节型
    .局部变量 起位置, 整数型

    项目 ＝ 读入字节集 (类_ID, 取文件长度 (类_ID))
    移到文件首 (类_ID)
    .判断循环首 (取字节集长度 (项目) － 起位置 ＞ 21)
        起位置 ＝ 寻找字节集 (项目, { 0 }, 起位置)
        .如果真 (索引 ＝ 项目索引)
            粗展状态 ＝ 取字节集数据 (项目, #字节型, 起位置 ＋ 13)
            清空 ()
            .判断开始 (粗展状态 ＝ 1)
                写出字节集 (类_ID, 字节集替换 (项目, 起位置 ＋ 13, 1, { 0 }))
            .判断 (粗展状态 ＝ 3)
                写出字节集 (类_ID, 字节集替换 (项目, 起位置 ＋ 13, 1, { 2 }))
            .默认
                
            .判断结束
            跳出循环 ()
        .如果真结束
        
        索引 ＝ 索引 ＋ 1
        起位置 ＝ 起位置 ＋ 21
    .判断循环尾 ()
    移到文件首 (类_ID)

.子程序 是否已加粗, 逻辑型, 公开, 如果树型框中的指定项目的标题被加粗显示，返回真，否则返回假。
    .参数 项目索引, 整数型, , 0 为项目一，1 为项目二，如此类推。
    .局部变量 项目, 字节集
    .局部变量 起位置, 整数型
    .局部变量 索引, 整数型
    .局部变量 粗展状态, 字节型

    项目 ＝ 读入字节集 (类_ID, 取文件长度 (类_ID))
    移到文件首 (类_ID)
    .判断循环首 (取字节集长度 (项目) － 起位置 ＞ 21)
        起位置 ＝ 寻找字节集 (项目, { 0 }, 起位置)
        .如果真 (索引 ＝ 项目索引)
            粗展状态 ＝ 取字节集数据 (项目, #字节型, 起位置 ＋ 13)
            .判断开始 (粗展状态 ＝ 1 或 粗展状态 ＝ 3)
                返回 (真)
            .判断 (粗展状态 ＝ 0 或 粗展状态 ＝ 2)
                返回 (假)
            .默认
                
            .判断结束
            
        .如果真结束
        索引 ＝ 索引 ＋ 1
        起位置 ＝ 起位置 ＋ 21
    .判断循环尾 ()
    返回 (假)

.子程序 扩展, , 公开, 打开指定项目的下属分枝。
    .参数 项目索引, 整数型, , 0 为项目一，1 为项目二，如此类推。
    .局部变量 项目, 字节集
    .局部变量 索引, 整数型
    .局部变量 粗展状态, 字节型
    .局部变量 起位置, 整数型

    项目 ＝ 读入字节集 (类_ID, 取文件长度 (类_ID))
    移到文件首 (类_ID)
    .判断循环首 (取字节集长度 (项目) － 起位置 ＞ 21)
        起位置 ＝ 寻找字节集 (项目, { 0 }, 起位置)
        .如果真 (索引 ＝ 项目索引)
            粗展状态 ＝ 取字节集数据 (项目, #字节型, 起位置 ＋ 13)
            清空 ()
            .判断开始 (粗展状态 ＝ 0)
                写出字节集 (类_ID, 字节集替换 (项目, 起位置 ＋ 13, 1, { 2 }))
            .判断 (粗展状态 ＝ 1)
                写出字节集 (类_ID, 字节集替换 (项目, 起位置 ＋ 13, 1, { 3 }))
            .默认
                
            .判断结束
            跳出循环 ()
        .如果真结束
        
        索引 ＝ 索引 ＋ 1
        起位置 ＝ 起位置 ＋ 21
    .判断循环尾 ()
    移到文件首 (类_ID)

.子程序 是否已扩展, 逻辑型, 公开, 指定项目的下属分枝是否已经展开。
    .参数 项目索引, 整数型, , 0 为项目一，1 为项目二，如此类推。
    .局部变量 项目, 字节集
    .局部变量 起位置, 整数型
    .局部变量 索引, 整数型
    .局部变量 粗展状态, 字节型

    项目 ＝ 读入字节集 (类_ID, 取文件长度 (类_ID))
    移到文件首 (类_ID)
    .判断循环首 (取字节集长度 (项目) － 起位置 ＞ 21)
        起位置 ＝ 寻找字节集 (项目, { 0 }, 起位置)
        .如果真 (索引 ＝ 项目索引)
            粗展状态 ＝ 取字节集数据 (项目, #字节型, 起位置 ＋ 13)
            .判断开始 (粗展状态 ＝ 0 或 粗展状态 ＝ 1)
                返回 (假)
            .判断 (粗展状态 ＝ 2 或 粗展状态 ＝ 3)
                返回 (真)
            .默认
                
            .判断结束
            
        .如果真结束
        索引 ＝ 索引 ＋ 1
        起位置 ＝ 起位置 ＋ 21
    .判断循环尾 ()
    返回 (假)

.子程序 收缩, , 公开, 缩回指定项目的下属分枝。
    .参数 项目索引, 整数型, , 0 为项目一，1 为项目二，如此类推。
    .局部变量 项目, 字节集
    .局部变量 索引, 整数型
    .局部变量 粗展状态, 字节型
    .局部变量 起位置, 整数型

    项目 ＝ 读入字节集 (类_ID, 取文件长度 (类_ID))
    移到文件首 (类_ID)
    .判断循环首 (取字节集长度 (项目) － 起位置 ＞ 21)
        起位置 ＝ 寻找字节集 (项目, { 0 }, 起位置)
        .如果真 (索引 ＝ 项目索引)
            粗展状态 ＝ 取字节集数据 (项目, #字节型, 起位置 ＋ 13)
            清空 ()
            .判断开始 (粗展状态 ＝ 2)
                写出字节集 (类_ID, 字节集替换 (项目, 起位置 ＋ 13, 1, { 0 }))
            .判断 (粗展状态 ＝ 3)
                写出字节集 (类_ID, 字节集替换 (项目, 起位置 ＋ 13, 1, { 1 }))
            .默认
                
            .判断结束
            跳出循环 ()
        .如果真结束
        
        索引 ＝ 索引 ＋ 1
        起位置 ＝ 起位置 ＋ 21
    .判断循环尾 ()
    移到文件首 (类_ID)

.子程序 是否已收缩, 逻辑型, 公开, 指定项目的下属分枝是否已经缩回。
    .参数 项目索引, 整数型, , 0 为项目一，1 为项目二，如此类推。
    .局部变量 项目, 字节集
    .局部变量 起位置, 整数型
    .局部变量 索引, 整数型
    .局部变量 粗展状态, 字节型

    项目 ＝ 读入字节集 (类_ID, 取文件长度 (类_ID))
    移到文件首 (类_ID)
    .判断循环首 (取字节集长度 (项目) － 起位置 ＞ 21)
        起位置 ＝ 寻找字节集 (项目, { 0 }, 起位置)
        .如果真 (索引 ＝ 项目索引)
            粗展状态 ＝ 取字节集数据 (项目, #字节型, 起位置 ＋ 13)
            .判断开始 (粗展状态 ＝ 0 或 粗展状态 ＝ 1)
                返回 (真)
            .判断 (粗展状态 ＝ 2 或 粗展状态 ＝ 3)
                返回 (假)
            .默认
                
            .判断结束
            
        .如果真结束
        索引 ＝ 索引 ＋ 1
        起位置 ＝ 起位置 ＋ 21
    .判断循环尾 ()
    返回 (假)

.子程序 加入项目, 整数型, 公开, 将单个项目加入到树型框中，成功返回加入后该项目所处的位置，失败返回 -1 。
    .参数 父项目索引, 整数型, 可空, 可以被省略。指定欲加入项目所处的父项目，0 为项目一，1 为项目二，如此类推。如果没有父项目（即欲加入项目为顶层项目），请提供值 -1 。如果本参数被省略，默认值为 -1 。
    .参数 项目文本, 文本型
    .参数 图片索引, 整数型, 可空, 可以被省略，如果本参数被省略，所加入项目的图片索引默认为 0 。
    .参数 选中图片索引, 整数型, 可空, 选中图片索引用于指定项目被选中后所显示的图片，-1 表示与图片索引一致。如果本参数被省略，所加入项目的选中图片索引默认为 -1 。
    .参数 项目数值, 整数型, 可空, 指定与本项目相关联的数值。如果本参数被省略，所加入项目的项目数值默认为 0 。
    .参数 是否加粗, 逻辑型, 可空, 可以被省略，如果本参数被省略，所加入项目的项目数值默认为假。
    .参数 检查框状态, 整数型, 可空, 可以被省略，如果本参数被省略，所加入项目的项目数值默认为 0 。默认情况下，0：未选中，1：选中，2：半选中。
    .局部变量 项目, 字节集
    .局部变量 起位置, 整数型
    .局部变量 索引, 整数型
    .局部变量 父层次, 整数型
    .局部变量 层次, 整数型
    .局部变量 插入位置, 整数型
    .局部变量 粗展状态, 字节型
    .局部变量 检查状态, 字节型

    项目 ＝ 读入字节集 (类_ID, 取文件长度 (类_ID))
    移到文件首 (类_ID)
    
    .如果真 (是否为空 (图片索引) 或 图片索引 ＜ 0)
        图片索引 ＝ 0
    .如果真结束
    
    .如果真 (是否为空 (选中图片索引) 或 选中图片索引 ＜ 0)
        选中图片索引 ＝ 图片索引
    .如果真结束
    
    .如果真 (是否为空 (项目数值) 或 项目数值 ＜ 0)
        项目数值 ＝ 0
    .如果真结束
    
    .如果真 (是否为空 (是否加粗))
        是否加粗 ＝ 假
    .如果真结束
    
    .如果真 (是否为空 (检查框状态) 或 检查框状态 ＜ 0)
        检查框状态 ＝ 0
    .如果真结束
    
    
    
    .如果真 (是否为空 (父项目索引) 或 父项目索引 ＜ 0)
        移到文件尾 (类_ID)
        写出字节集 (类_ID, 生成项目 (项目文本, 图片索引, 选中图片索引, 项目数值, 是否加粗, , 1, 检查框状态))
        移到文件首 (类_ID)
        返回 (取项目数 () － 1)
    .如果真结束
    
    
    .判断循环首 (取字节集长度 (项目) － 起位置 ＞ 21)
        起位置 ＝ 寻找字节集 (项目, { 0 }, 起位置)
        .如果真 (索引 ＝ 父项目索引)
            父层次 ＝ 取字节集数据 (项目, #整数型, 起位置 ＋ 17)
            粗展状态 ＝ 取字节集数据 (项目, #字节型, 起位置 ＋ 13)
            检查状态 ＝ 取字节集数据 (项目, #字节型, 起位置 ＋ 16) ÷ 16 － 1
            .判断开始 (粗展状态 ＝ 0 或 粗展状态 ＝ 2)
                项目 ＝ 字节集替换 (项目, 起位置 ＋ 13, 1, { 2 })
            .判断 (粗展状态 ＝ 1 或 粗展状态 ＝ 3)
                项目 ＝ 字节集替换 (项目, 起位置 ＋ 13, 1, { 3 })
            .默认
                
            .判断结束
            
            .如果真 (检查状态 ＝ 1)
                .如果真 (选中图片索引 ＝ 0)
                    检查状态 ＝ 2
                .如果真结束
                
            .如果真结束
            项目 ＝ 字节集替换 (项目, 起位置 ＋ 16, 1, 到字节集 (检查状态))
            
            插入位置 ＝ 起位置 ＋ 21
        .如果真结束
        
        .如果真 (索引 ＞ 父项目索引)
            层次 ＝ 取字节集数据 (项目, #整数型, 起位置 ＋ 17)
            .如果 (层次 ≤ 父层次)
                跳出循环 ()
            .否则
                插入位置 ＝ 起位置 ＋ 21
            .如果结束
            
        .如果真结束
        
        索引 ＝ 索引 ＋ 1
        起位置 ＝ 起位置 ＋ 21
    .判断循环尾 ()
    清空 ()
    写出字节集 (类_ID, 字节集替换 (项目, 插入位置, 0, 生成项目 (项目文本, 图片索引, 选中图片索引, 项目数值, 是否加粗, , 父层次 ＋ 1, 检查框状态)))
    移到文件首 (类_ID)
    返回 (索引)

.子程序 删除项目, , 公开, 删除树型框中的指定项目。
    .参数 项目索引, 整数型, , 0 为项目一，1 为项目二，如此类推。
    .局部变量 项目, 字节集
    .局部变量 起位置, 整数型
    .局部变量 索引, 整数型
    .局部变量 层次, 整数型
    .局部变量 目标层次, 整数型
    .局部变量 目标索引, 整数型
    .局部变量 开始位置, 整数型
    .局部变量 结束位置, 整数型

    项目 ＝ 读入字节集 (类_ID, 取文件长度 (类_ID))
    移到文件首 (类_ID)
    
    .判断循环首 (取字节集长度 (项目) － 起位置 ＞ 21)
        起位置 ＝ 寻找字节集 (项目, { 0 }, 起位置)
        .如果真 (索引 ＝ 项目索引)
            目标索引 ＝ 索引
            目标层次 ＝ 取字节集数据 (项目, #整数型, 起位置 ＋ 17)
        .如果真结束
        
        .如果真 (索引 ＞ 项目索引)
            层次 ＝ 取字节集数据 (项目, #整数型, 起位置 ＋ 17)
            .判断开始 (层次 ＞ 目标层次)
                结束位置 ＝ 起位置 ＋ 21
            .判断 (层次 ≤ 目标层次)
                跳出循环 ()
            .默认
                
            .判断结束
            
        .如果真结束
        
        索引 ＝ 索引 ＋ 1
        起位置 ＝ 起位置 ＋ 21
    .判断循环尾 ()
    
    索引 ＝ 0
    起位置 ＝ 0
    .判断循环首 (取字节集长度 (项目) － 起位置 ＞ 21)
        起位置 ＝ 寻找字节集 (项目, { 0 }, 起位置)
        索引 ＝ 索引 ＋ 1
        起位置 ＝ 起位置 ＋ 21
        .如果真 (索引 ＝ 项目索引)
            开始位置 ＝ 起位置
            跳出循环 ()
        .如果真结束
        
    .判断循环尾 ()
    清空 ()
    写出字节集 (类_ID, 字节集替换 (项目, 开始位置, 结束位置 － 开始位置, ))
    移到文件首 (类_ID)

.子程序 清空, , 公开, 删除树型框中的所有项目。
    移到文件首 (类_ID)
    删除数据 (类_ID, 取文件长度 (类_ID))

.子程序 取父项目, 整数型, 公开, 返回指定项目的父项目索引。如果该项目为顶层项目，将返回 -1 。
    .参数 项目索引, 整数型, , 0 为项目一，1 为项目二，如此类推。
    .局部变量 项目, 字节集
    .局部变量 起位置, 整数型
    .局部变量 索引, 整数型
    .局部变量 层次, 整数型
    .局部变量 上层次, 整数型, , "0"
    .局部变量 i, 整数型

    项目 ＝ 读入字节集 (类_ID, 取文件长度 (类_ID))
    移到文件首 (类_ID)
    .判断循环首 (取字节集长度 (项目) － 起位置 ＞ 21)
        起位置 ＝ 寻找字节集 (项目, { 0 }, 起位置)
        .判断开始 (索引 ＜ 项目索引)
            加入成员 (上层次, 取字节集数据 (项目, #整数型, 起位置 ＋ 17))
        .判断 (索引 ＝ 项目索引)
            层次 ＝ 取字节集数据 (项目, #整数型, 起位置 ＋ 17)
            .变量循环首 (取数组成员数 (上层次), 1, -1, i)
                .如果真 (上层次 [i] ＜ 层次)
                    返回 (i － 1)
                .如果真结束
                
            .变量循环尾 ()
            跳出循环 ()
        .默认
            跳出循环 ()
        .判断结束
        索引 ＝ 索引 ＋ 1
        起位置 ＝ 起位置 ＋ 21
    .判断循环尾 ()
    返回 (-1)

.子程序 是否有子项目, 逻辑型, 公开, 如果指定项目存在子项目，返回真，否则返回假。如果本命令返回真，意味着指定项目的下一项即为此项目的第一个子项目。
    .参数 项目索引, 整数型, , 0 为项目一，1 为项目二，如此类推。
    .局部变量 项目, 字节集
    .局部变量 起位置, 整数型
    .局部变量 索引, 整数型
    .局部变量 层次, 整数型

    项目 ＝ 读入字节集 (类_ID, 取文件长度 (类_ID))
    移到文件首 (类_ID)
    .判断循环首 (取字节集长度 (项目) － 起位置 ＞ 21)
        起位置 ＝ 寻找字节集 (项目, { 0 }, 起位置)
        .如果真 (索引 ＝ 项目索引)
            层次 ＝ 取字节集数据 (项目, #整数型, 起位置 ＋ 17)
        .如果真结束
        
        .如果真 (索引 ＞ 项目索引)
            .如果真 (取字节集数据 (项目, #整数型, 起位置 ＋ 17) ＞ 层次)
                返回 (真)
            .如果真结束
            
        .如果真结束
        
        索引 ＝ 索引 ＋ 1
        起位置 ＝ 起位置 ＋ 21
    .判断循环尾 ()
    返回 (假)

.子程序 取检查框状态, 整数型, 公开, 返回值表示检查框中选中状态。默认情况下，0：未选中，1：选中，2：半选中。
    .参数 项目索引, 整数型, , 0 为项目一，1 为项目二，如此类推。
    .局部变量 项目, 字节集
    .局部变量 起位置, 整数型
    .局部变量 索引, 整数型
    .局部变量 状态, 字节型

    项目 ＝ 读入字节集 (类_ID, 取文件长度 (类_ID))
    移到文件首 (类_ID)
    .判断循环首 (取字节集长度 (项目) － 起位置 ＞ 21)
        起位置 ＝ 寻找字节集 (项目, { 0 }, 起位置)
        .如果真 (索引 ＝ 项目索引)
            状态 ＝ 取字节集数据 (项目, #字节型, 起位置 ＋ 16)
            返回 (状态 ÷ 16 － 1)
        .如果真结束
        索引 ＝ 索引 ＋ 1
        起位置 ＝ 起位置 ＋ 21
    .判断循环尾 ()
    返回 (0)

.子程序 置检查框状态, , 公开, 设置项目的检查框状态。
    .参数 项目索引, 整数型, , 0 为项目一，1 为项目二，如此类推。在参数“连同子项目”为真的情况下，此参数可为-1，表示设置所有项目的检查框状态。
    .参数 检查框状态, 整数型, , 默认情况下，0表示未选中，1表示已选中，2表示半选中。
    .参数 连同子项目, 逻辑型, 可空, 可以被省略。如果此参数为真，则参数“项目索引”所指定项目的所有子项目也被一并设置其检查框状态。默认为假。
    .局部变量 项目, 字节集
    .局部变量 临位, 整数型
    .局部变量 索引, 整数型
    .局部变量 层次, 整数型

    .如果真 (项目索引 ＜ 0)
        返回 ()
    .如果真结束
    
    项目 ＝ 读入字节集 (类_ID, 取文件长度 (类_ID))
    移到文件首 (类_ID)
    .判断循环首 (取字节集长度 (项目) － 临位 ＞ 21)
        临位 ＝ 寻找字节集 (项目, { 0 }, 临位)
        .如果真 (索引 ＝ 项目索引)
            项目 ＝ 字节集替换 (项目, 临位 ＋ 16, 1, 到字节集 (到字节 ((检查框状态 ＋ 1) × 16)))
            层次 ＝ 取字节集数据 (项目, #整数型, 临位 ＋ 17)
        .如果真结束
        
        .如果真 (连同子项目 且 索引 ＞ 项目索引)
            .如果真 (取字节集数据 (项目, #整数型, 临位 ＋ 17) ＞ 层次)
                项目 ＝ 字节集替换 (项目, 临位 ＋ 16, 1, 到字节集 (到字节 ((检查框状态 ＋ 1) × 16)))
            .如果真结束
            
        .如果真结束
        
        索引 ＝ 索引 ＋ 1
        临位 ＝ 临位 ＋ 21
    .判断循环尾 ()
    清空 ()
    写出字节集 (类_ID, 项目)
    移到文件首 (类_ID)

.子程序 查找项目_缩进层次, 整数型, 公开, 找到返回首个被找到项目的索引，失败返回-1。
    .参数 项目缩进层次, 整数型, , 默认情况下，0表示未选中，1表示已选中，2表示半选中。
    .参数 查找结果, 整数型, 参考 可空 数组, 提供变量容器，存放找到的项目索引。
    .局部变量 起位置, 整数型
    .局部变量 项目, 字节集
    .局部变量 索引, 整数型

    重定义数组 (查找结果, 假, 0)
    项目 ＝ 读入字节集 (类_ID, 取文件长度 (类_ID))
    移到文件首 (类_ID)
    .判断循环首 (取字节集长度 (项目) － 起位置 ＞ 21)
        起位置 ＝ 寻找字节集 (项目, { 0 }, 起位置)
        .如果真 (取字节集数据 (项目, #整数型, 起位置 ＋ 17) ＝ 项目缩进层次)
            加入成员 (查找结果, 索引)
        .如果真结束
        索引 ＝ 索引 ＋ 1
        起位置 ＝ 起位置 ＋ 21
    .判断循环尾 ()
    .如果 (取数组成员数 (查找结果) ≠ 0)
        返回 (查找结果 [1])
    .否则
        返回 (-1)
    .如果结束
    

.子程序 查找项目_检查框状态, 整数型, 公开, 找到返回首个被找到项目的索引，失败返回-1。
    .参数 项目检查框状态, 整数型, , 默认情况下，0表示未选中，1表示已选中，2表示半选中。
    .参数 查找结果, 整数型, 参考 可空 数组, 提供变量容器，存放找到的项目索引。
    .局部变量 起位置, 整数型
    .局部变量 项目, 字节集
    .局部变量 索引, 整数型
    .局部变量 状态, 字节型

    重定义数组 (查找结果, 假, 0)
    项目 ＝ 读入字节集 (类_ID, 取文件长度 (类_ID))
    移到文件首 (类_ID)
    .判断循环首 (取字节集长度 (项目) － 起位置 ＞ 21)
        起位置 ＝ 寻找字节集 (项目, { 0 }, 起位置)
        状态 ＝ 取字节集数据 (项目, #字节型, 起位置 ＋ 16)
        .如果真 (状态 ÷ 16 － 1 ＝ 项目检查框状态)
            加入成员 (查找结果, 索引)
        .如果真结束
        索引 ＝ 索引 ＋ 1
        起位置 ＝ 起位置 ＋ 21
    .判断循环尾 ()
    .如果 (取数组成员数 (查找结果) ≠ 0)
        返回 (查找结果 [1])
    .否则
        返回 (-1)
    .如果结束
    

.子程序 查找项目_选中图片, 整数型, 公开, 找到返回首个被找到项目的索引，失败返回-1。
    .参数 项目选中图片索引, 整数型
    .参数 查找结果, 整数型, 参考 可空 数组, 提供变量容器，存放找到的项目索引。
    .局部变量 起位置, 整数型
    .局部变量 项目, 字节集
    .局部变量 索引, 整数型

    重定义数组 (查找结果, 假, 0)
    项目 ＝ 读入字节集 (类_ID, 取文件长度 (类_ID))
    移到文件首 (类_ID)
    .判断循环首 (取字节集长度 (项目) － 起位置 ＞ 21)
        起位置 ＝ 寻找字节集 (项目, { 0 }, 起位置)
        .如果真 (取字节集数据 (项目, #整数型, 起位置 ＋ 5) ＝ 项目选中图片索引)
            加入成员 (查找结果, 索引)
        .如果真结束
        索引 ＝ 索引 ＋ 1
        起位置 ＝ 起位置 ＋ 21
    .判断循环尾 ()
    .如果 (取数组成员数 (查找结果) ≠ 0)
        返回 (查找结果 [1])
    .否则
        返回 (-1)
    .如果结束
    

.子程序 查找项目_图片, 整数型, 公开, 找到返回首个被找到项目的索引，失败返回-1。
    .参数 项目图片索引, 整数型
    .参数 查找结果, 整数型, 参考 可空 数组, 提供变量容器，存放找到的项目索引。
    .局部变量 起位置, 整数型
    .局部变量 项目, 字节集
    .局部变量 索引, 整数型

    重定义数组 (查找结果, 假, 0)
    项目 ＝ 读入字节集 (类_ID, 取文件长度 (类_ID))
    移到文件首 (类_ID)
    .判断循环首 (取字节集长度 (项目) － 起位置 ＞ 21)
        起位置 ＝ 寻找字节集 (项目, { 0 }, 起位置)
        .如果真 (取字节集数据 (项目, #整数型, 起位置 ＋ 1) ＝ 项目图片索引)
            加入成员 (查找结果, 索引)
        .如果真结束
        索引 ＝ 索引 ＋ 1
        起位置 ＝ 起位置 ＋ 21
    .判断循环尾 ()
    .如果 (取数组成员数 (查找结果) ≠ 0)
        返回 (查找结果 [1])
    .否则
        返回 (-1)
    .如果结束
    

.子程序 查找项目_数值, 整数型, 公开, 找到返回首个被找到项目的索引，失败返回-1。
    .参数 项目数值, 整数型
    .参数 查找结果, 整数型, 参考 可空 数组, 提供变量容器，存放找到的项目索引。
    .局部变量 起位置, 整数型
    .局部变量 项目, 字节集
    .局部变量 索引, 整数型

    重定义数组 (查找结果, 假, 0)
    项目 ＝ 读入字节集 (类_ID, 取文件长度 (类_ID))
    移到文件首 (类_ID)
    .判断循环首 (取字节集长度 (项目) － 起位置 ＞ 21)
        起位置 ＝ 寻找字节集 (项目, { 0 }, 起位置)
        .如果真 (取字节集数据 (项目, #整数型, 起位置 ＋ 9) ＝ 项目数值)
            加入成员 (查找结果, 索引)
        .如果真结束
        索引 ＝ 索引 ＋ 1
        起位置 ＝ 起位置 ＋ 21
    .判断循环尾 ()
    .如果 (取数组成员数 (查找结果) ≠ 0)
        返回 (查找结果 [1])
    .否则
        返回 (-1)
    .如果结束
    

.子程序 查找项目_文本, 整数型, , 找到返回首个被找到项目的索引，失败返回-1。
    .参数 项目文本, 文本型
    .参数 是否精确匹配, 逻辑型, 可空, 默认为真，为假时所有包含“参数一”的项目。
    .参数 区分大小写, 逻辑型, 可空, 默认不区分，“参数二”为真时将忽略本参数。
    .参数 查找结果, 整数型, 参考 可空 数组, 提供变量容器，存放找到的项目索引。
    .局部变量 目标长度, 整数型
    .局部变量 项目, 字节集
    .局部变量 起位置, 整数型
    .局部变量 下位置, 整数型
    .局部变量 索引, 整数型

    重定义数组 (查找结果, 假, 0)
    项目 ＝ 读入字节集 (类_ID, 取文件长度 (类_ID))
    移到文件首 (类_ID)
    目标长度 ＝ 取文本长度 (项目文本)
    
    .判断开始 (是否精确匹配 或 是否为空 (是否精确匹配))
        .判断循环首 (取字节集长度 (项目) － 起位置 ＞ 21)
            起位置 ＝ 寻找字节集 (项目, { 0 }, 起位置)
            .如果真 (文本比较 (到文本 (取字节集中间 (项目, 起位置 － 目标长度, 目标长度)), 项目文本, 真) ＝ 0)
                加入成员 (查找结果, 索引)
            .如果真结束
            索引 ＝ 索引 ＋ 1
            起位置 ＝ 起位置 ＋ 21
        .判断循环尾 ()
        
    .默认
        
        
        .如果 (取反 (区分大小写) 或 是否为空 (区分大小写))
            .判断循环首 (取字节集长度 (项目) － 起位置 ＞ 21)
                起位置 ＝ 寻找字节集 (项目, { 0 }, 起位置)
                .如果真 (寻找文本 (到文本 (取字节集中间 (项目, 起位置 － 目标长度, 目标长度)), 项目文本, , 真) ≠ -1)
                    加入成员 (查找结果, 索引)
                .如果真结束
                索引 ＝ 索引 ＋ 1
                起位置 ＝ 起位置 ＋ 21
            .判断循环尾 ()
            
        .否则
            
            .判断循环首 (取字节集长度 (项目) － 起位置 ＞ 21)
                起位置 ＝ 寻找字节集 (项目, { 0 }, 起位置)
                .如果真 (寻找文本 (到文本 (取字节集中间 (项目, 起位置 － 目标长度, 目标长度)), 项目文本, , 假) ≠ -1)
                    加入成员 (查找结果, 索引)
                .如果真结束
                索引 ＝ 索引 ＋ 1
                起位置 ＝ 起位置 ＋ 21
            .判断循环尾 ()
        .如果结束
        
    .判断结束
    
    .如果 (取数组成员数 (查找结果) ≠ 0)
        返回 (查找结果 [1])
    .否则
        返回 (-1)
    .如果结束
    

.子程序 取项目开始位置, 整数型, 公开, 查找指定索引的项目在字节集中的位置，失败返回-1。
    .参数 项目索引, 整数型
    .局部变量 项目, 字节集
    .局部变量 临位, 整数型
    .局部变量 索引, 整数型

    .如果真 (项目索引 ＜ 0)
        返回 (-1)
    .如果真结束
    项目 ＝ 读入字节集 (类_ID, 取文件长度 (类_ID))
    移到文件首 (类_ID)
    .判断循环首 (取字节集长度 (项目) － 临位 ＞ 21)
        临位 ＝ 寻找字节集 (项目, { 0 }, 临位)
        索引 ＝ 索引 ＋ 1
        临位 ＝ 临位 ＋ 21
        .如果真 (索引 ＝ 项目索引) ' 与上一项目索引一样时，刚好对应的是目标项目的位置
            返回 (临位 － 1)
        .如果真结束
        
    .判断循环尾 ()
    返回 (-1)

.子程序 取项目长度, 整数型, 公开, 取指定项目的数据长度，失败返回-1。
    .参数 项目索引, 整数型
    .局部变量 项目, 字节集
    .局部变量 临位, 整数型
    .局部变量 索引, 整数型

    .如果真 (项目索引 ＜ 0)
        返回 (-1)
    .如果真结束
    项目 ＝ 读入字节集 (类_ID, 取文件长度 (类_ID))
    移到文件首 (类_ID)
    .判断循环首 (取字节集长度 (项目) － 临位 ＞ 21)
        临位 ＝ 寻找字节集 (项目, { 0 }, 临位)
        索引 ＝ 索引 ＋ 1
        临位 ＝ 临位 ＋ 21
        .如果真 (索引 ＝ 项目索引)
            返回 (寻找字节集 (项目, { 0 }, 临位) － 临位 ＋ 21)
        .如果真结束
        
    .判断循环尾 ()
    返回 (-1)

.子程序 查找子项目_全部, 整数型, 公开, 只查找项目的子项目
    .参数 项目索引, 整数型
    .参数 查找所有子项目, 逻辑型, 可空, 默认只查找项目的下一层级
    .参数 查找结果, 整数型, 参考 可空 数组, 提供变量容器，存放找到的项目索引。
    .局部变量 起位置, 整数型
    .局部变量 项目, 字节集
    .局部变量 索引, 整数型
    .局部变量 子层次, 整数型
    .局部变量 临时层次, 整数型

    ' https://bbs.125.la/forum.php?mod=viewthread&tid=14668343
    重定义数组 (查找结果, 假, 0)
    项目 ＝ 读入字节集 (类_ID, 取文件长度 (类_ID))
    移到文件首 (类_ID)
    
    .判断循环首 (取字节集长度 (项目) － 起位置 ＞ 21)
        起位置 ＝ 寻找字节集 (项目, { 0 }, 起位置)
        
        临时层次 ＝ 取字节集数据 (项目, #整数型, 起位置 ＋ 17)
        
        .如果真 (索引 ＝ 项目索引)
            子层次 ＝ 临时层次 ＋ 1
        .如果真结束
        .如果真 (索引 ＞ 项目索引)
            .判断开始 (临时层次 ＝ 子层次)
                加入成员 (查找结果, 索引)
            .判断 (临时层次 ＞ 子层次)
                .如果真 (查找所有子项目)
                    加入成员 (查找结果, 索引)
                .如果真结束
                
            .判断 (临时层次 ＜ 子层次)
                跳出循环 ()
            .默认
                
            .判断结束
            
        .如果真结束
        
        索引 ＝ 索引 ＋ 1
        起位置 ＝ 起位置 ＋ 21
    .判断循环尾 ()
    .如果 (取数组成员数 (查找结果) ≠ 0)
        返回 (查找结果 [1])
    .否则
        返回 (-1)
    .如果结束
    

.子程序 查找子项目_文本, 整数型, 公开, 只查找项目的子项目
    .参数 项目索引, 整数型, , -1表示顶级项目
    .参数 项目文本, 文本型
    .参数 查找所有子项目, 逻辑型, 可空, 默认只查找项目的下一层级
    .参数 查找结果, 整数型, 参考 可空 数组, 提供变量容器，存放找到的项目索引。
    .局部变量 起位置, 整数型
    .局部变量 项目, 字节集
    .局部变量 索引, 整数型
    .局部变量 子层次, 整数型
    .局部变量 临时层次, 整数型
    .局部变量 目标长度, 整数型

    重定义数组 (查找结果, 假, 0)
    项目 ＝ 读入字节集 (类_ID, 取文件长度 (类_ID))
    移到文件首 (类_ID)
    目标长度 ＝ 取文本长度 (项目文本)
    .判断循环首 ((取字节集长度 (项目) － 起位置) ％ 21 ＝ 0)
        起位置 ＝ 寻找字节集 (项目, { 0 }, 起位置)
        
        临时层次 ＝ 取字节集数据 (项目, #整数型, 起位置 ＋ 17)
        .如果真 (项目索引 ＝ -1)
            子层次 ＝ 1
        .如果真结束
        .如果真 (索引 ＝ 项目索引)
            子层次 ＝ 临时层次 ＋ 1
        .如果真结束
        .如果真 (索引 ＞ 项目索引)
            .判断开始 (临时层次 ＝ 子层次)
                .如果真 (文本比较 (到文本 (取字节集中间 (项目, 起位置 － 目标长度, 目标长度)), 项目文本, 真) ＝ 0)
                    加入成员 (查找结果, 索引)
                .如果真结束
                
            .判断 (临时层次 ＞ 子层次)
                .如果真 (查找所有子项目)
                    .如果真 (文本比较 (到文本 (取字节集中间 (项目, 起位置 － 目标长度, 目标长度)), 项目文本, 真) ＝ 0)
                        加入成员 (查找结果, 索引)
                    .如果真结束
                    
                .如果真结束
                
            .判断 (临时层次 ＜ 子层次)
                跳出循环 ()
            .默认
                
            .判断结束
            
        .如果真结束
        
        索引 ＝ 索引 ＋ 1
        起位置 ＝ 起位置 ＋ 21
    .判断循环尾 ()
    .如果 (取数组成员数 (查找结果) ≠ 0)
        返回 (查找结果 [1])
    .否则
        返回 (-1)
    .如果结束
    

.子程序 加入项目_EX, 整数型, 公开, 成功返回0,失败，则返回失败时加入的索引
    .参数 项目文本, 文本型
    .参数 分隔符, 文本型, 可空, 项目文本中的层级分隔符，默认为“\”
    .参数 图片索引, 整数型, 可空, 可以被省略，如果本参数被省略，所加入项目的图片索引默认为 0 。
    .参数 选中图片索引, 整数型, 可空, 选中图片索引用于指定项目被选中后所显示的图片，-1 表示与图片索引一致。如果本参数被省略，所加入项目的选中图片索引默认为 -1 。
    .参数 项目数值, 整数型, 可空, 指定与本项目相关联的数值。如果本参数被省略，所加入项目的项目数值默认为 0 。
    .参数 是否加粗, 逻辑型, 可空, 可以被省略，如果本参数被省略，所加入项目的项目数值默认为假。
    .参数 检查框状态, 整数型, 可空, 可以被省略，如果本参数被省略，所加入项目的项目数值默认为 0 。默认情况下，0：未选中，1：选中，2：半选中。
    .局部变量 文本组, 文本型, , "0"
    .局部变量 项目组, 整数型, , "0"
    .局部变量 加入索引, 整数型
    .局部变量 前加入索引, 整数型
    .局部变量 i, 整数型

    .如果真 (是否为空 (选中图片索引))
        选中图片索引 ＝ -1
    .如果真结束
    .如果真 (是否为空 (分隔符))
        分隔符 ＝ “\”
    .如果真结束
    
    文本组 ＝ 分割文本 (项目文本, 分隔符, )
    .如果真 (取数组成员数 (文本组) ＞ 0)
        加入索引 ＝ -1
        
        .计次循环首 (取数组成员数 (文本组), i)
            前加入索引 ＝ 加入索引
            加入索引 ＝ 查找子项目_文本 (加入索引, 文本组 [i], , )
            
            .如果真 (加入索引 ＝ -1)
                加入索引 ＝ 加入项目 (前加入索引, 文本组 [i], 图片索引, 选中图片索引, 项目数值, 是否加粗, 检查框状态)
                .如果真 (加入索引 ＝ -1)
                    返回 (前加入索引)
                .如果真结束
                
            .如果真结束
            
        .计次循环尾 ()
    .如果真结束
    返回 (0)

.版本 2

.程序集 类_编辑框菜单, , 公开, 对自身程序编辑框有效
.程序集变量 New_call, 整数型
.程序集变量 程_菜单结构, 菜单结构, , "0"

.子程序 _初始化, , , 1
    

.子程序 _销毁, , , 2
    移除全部 ()

.子程序 NewWndProc, 整数型, , 3
    .参数 hWnd, 整数型
    .参数 uMsg, 整数型
    .参数 wParam, 整数型
    .参数 lParam, 整数型
    .局部变量 局_是否弹出, 逻辑型, 静态
    .局部变量 局_菜单句柄, 整数型, 静态
    .局部变量 局_总数, 整数型
    .局部变量 i, 整数型
    .局部变量 局_标识, 整数型
    .局部变量 局_二级菜单, 整数型
    .局部变量 索引, 整数型

    索引 ＝ 内_取索引 (hWnd)
    .如果真 (索引 ≠ 0)
        局_总数 ＝ 取数组成员数 (程_菜单结构 [索引].菜单数据)
    .如果真结束
    .判断开始 (uMsg ＝ #WM_ENTERIDLE 且 wParam ＝ #MSGF_MENU 且 局_菜单句柄 ＝ 0)
        .如果真 (局_是否弹出)
            局_菜单句柄 ＝ SendMessageA (lParam, #MN_GETHMENU, 0, 0) ' 16=下拉,0无下拉,2048=分割线，256=无位图菜单，64=横宽菜单
            局_二级菜单 ＝ CreatePopupMenu ()
            InsertMenuA (局_菜单句柄, 程_菜单结构 [索引].插入位置, #MF_BYPOSITION ＋ #MF_POPUP ＋ #MF_STRING, 局_二级菜单, 程_菜单结构 [索引].菜单标题)
            .计次循环首 (局_总数, i)
                局_标识 ＝ i ＋ 2018
                .如果 (程_菜单结构 [索引].菜单数据 [i].是否插入)
                    InsertMenuA (局_二级菜单, i － 1, #MF_STRING, 局_标识, 程_菜单结构 [索引].菜单数据 [i].名称)
                .否则
                    AppendMenuA (局_菜单句柄, #MF_STRING, 局_标识, 程_菜单结构 [索引].菜单数据 [i].名称)
                .如果结束
                
                
            .计次循环尾 ()
        .如果真结束
        
    .默认
        .计次循环首 (局_总数, i)
            .如果真 (uMsg ＝ i ＋ 2018) ' 2018
                .如果真 (到整数 (程_菜单结构 [索引].菜单数据 [i].事件) ＞ 0)
                    程序_执行整数子程序 (程_菜单结构 [索引].菜单数据 [i].事件, hWnd)
                .如果真结束
                
            .如果真结束
            
        .计次循环尾 ()
    .判断结束
    .如果真 (uMsg ＝ #WM_CONTEXTMENU)
        局_菜单句柄 ＝ 0
        局_是否弹出 ＝ SendMessageA (hWnd, #WM_NCHITTEST, 0, lParam) ≠ #HTVSCROLL
    .如果真结束
    返回 (CallWindowProcA (程_菜单结构 [索引].原回调地址, hWnd, uMsg, wParam, lParam))

.子程序 添加编辑框, , 公开, 插入一个主菜单
    .参数 参_编辑框句柄, 整数型
    .参数 参_插入位置, 整数型
    .参数 参_菜单标题, 文本型
    .局部变量 局_结构, 菜单结构

    .如果真 (内_取索引 (参_编辑框句柄) ≠ 0)
        返回 ()
    .如果真结束
    .如果真 (New_call ＝ 0)
        New_call ＝ 类_取内部方法地址 (3)
    .如果真结束
    局_结构.窗口句柄 ＝ 参_编辑框句柄
    局_结构.菜单标题 ＝ 参_菜单标题
    局_结构.插入位置 ＝ 参_插入位置
    清除数组 (局_结构.菜单数据)
    局_结构.原回调地址 ＝ SetWindowLongA (参_编辑框句柄, #GWL_WNDPROC, New_call)
    加入成员 (程_菜单结构, 局_结构)

.子程序 内_取索引, 整数型
    .参数 句柄, 整数型
    .局部变量 i, 整数型

    .计次循环首 (取数组成员数 (程_菜单结构), i)
        .如果真 (程_菜单结构 [i].窗口句柄 ＝ 句柄)
            返回 (i)
        .如果真结束
        
    .计次循环尾 ()
    返回 (0)

.子程序 添加子菜单, , 公开, 添加二级菜单
    .参数 参_编辑框句柄, 整数型
    .参数 参_菜单消息, 菜单消息
    .局部变量 索引, 整数型

    索引 ＝ 内_取索引 (参_编辑框句柄)
    .如果真 (索引 ≠ 0)
        加入成员 (程_菜单结构 [索引].菜单数据, 参_菜单消息)
    .如果真结束
    

.子程序 重置菜单, , 公开
    .参数 参_编辑框句柄, 整数型
    .局部变量 索引, 整数型

    索引 ＝ 内_取索引 (参_编辑框句柄)
    .如果真 (索引 ≠ 0)
        清除数组 (程_菜单结构 [索引].菜单数据)
    .如果真结束
    

.子程序 移除编辑框, , 公开
    .参数 参_编辑框句柄, 整数型
    .局部变量 索引, 整数型

    索引 ＝ 内_取索引 (参_编辑框句柄)
    .如果真 (索引 ≠ 0)
        SetWindowLongA (程_菜单结构 [索引].窗口句柄, #GWL_WNDPROC, 程_菜单结构 [索引].原回调地址)
        删除成员 (程_菜单结构, 索引, 1)
    .如果真结束
    

.子程序 移除全部
    .局部变量 i, 整数型
    .局部变量 数量, 整数型

    数量 ＝ 取数组成员数 (程_菜单结构)
    .计次循环首 (数量, i)
        移除编辑框 (数量 － i ＋ 1)
    .计次循环尾 ()

.版本 2

.程序集 类_编辑框透明, , 公开
.程序集变量 集_窗口句柄, 整数型
.程序集变量 集_编辑框, 编辑框
.程序集变量 集_字体颜色, 整数型
.程序集变量 集_子类化_窗口, 整数型
.程序集变量 ImageObject, 对象
.程序集变量 hBkBitmap, 整数型
.程序集变量 集_子类化_编辑框, 整数型

.子程序 _初始化, , , 1
    

.子程序 _销毁, , , 2
    

.子程序 NewProc_Main, 整数型, , 3
    .参数 hWnd, 整数型
    .参数 Msg, 整数型
    .参数 wParam, 整数型
    .参数 lParam, 整数型

    .判断开始 (Msg ＝ #WM_CTLCOLOREDIT)
        .判断开始 (lParam ＝ 集_编辑框.取窗口句柄 ())
            SetTextColor (wParam, 集_字体颜色) ' 50174)
            SetBkMode (wParam, #TRANSPARENT)
            返回 (GetStockObject (#NULL_BRUSH))
        .默认
            
        .判断结束
        
    .判断 (Msg ＝ #WM_COMMAND)
        .判断开始 (lParam ＝ 集_编辑框.取窗口句柄 ())
            .判断开始 (右移 (wParam, 16) ＝ #EN_VSCROLL)
                InvalidateRect_逻辑型 (lParam, 0, 真)
            .判断 (右移 (wParam, 16) ＝ #EN_HSCROLL)
                InvalidateRect_逻辑型 (lParam, 0, 真)
            .判断 (右移 (wParam, 16) ＝ #EN_CHANGE)
                InvalidateRect_逻辑型 (lParam, 0, 真)
            .默认
                
            .判断结束
            
        .默认
            
        .判断结束
        
    .默认
        
    .判断结束
    返回 (CallWindowProcA (集_子类化_窗口, hWnd, Msg, wParam, lParam))

.子程序 NewProc_Edit, 整数型, , 4
    .参数 hWnd, 整数型
    .参数 Msg, 整数型
    .参数 wParam, 整数型
    .参数 lParam, 整数型
    .局部变量 hMemDC_BkPicture, 整数型
    .局部变量 hOldBitmap, 整数型
    .局部变量 矩形, 精易_矩形
    .局部变量 hBrush, 整数型
    .局部变量 hOldBrush, 整数型
    .局部变量 hTempMemBitmap, 整数型
    .局部变量 hScrDC, 整数型
    .局部变量 hOldTempMemBitmap, 整数型
    .局部变量 hMemDC_BkColor, 整数型

    .判断开始 (Msg ＝ #WM_ERASEBKGND)
        .如果真 (hBkBitmap ＝ 0)
            集_编辑框.可视 ＝ 假
            处理事件 ()
            CoInitialize (0)
            .如果真 (ImageObject.创建图片对象 (快照 (集_编辑框.取窗口句柄 (), , )))
                hBkBitmap ＝ ImageObject.读数值属性 (“handle”, )
            .如果真结束
            CoUninitialize ()
            集_编辑框.可视 ＝ 真
        .如果真结束
        GetClientRect (hWnd, 矩形)
        hScrDC ＝ GetDC (0)
        hMemDC_BkColor ＝ CreateCompatibleDC (hScrDC)
        hTempMemBitmap ＝ CreateCompatibleBitmap (hScrDC, 矩形.右边, 矩形.底边)
        hOldTempMemBitmap ＝ SelectObject (hMemDC_BkColor, hTempMemBitmap)
        hBrush ＝ CreateSolidBrush (#白色)
        hOldBrush ＝ SelectObject (hMemDC_BkColor, hBrush)
        FillRect (hMemDC_BkColor, 矩形, hBrush)
        SelectObject (hMemDC_BkColor, hOldBrush)
        DeleteObject (hBrush)
        hMemDC_BkPicture ＝ CreateCompatibleDC (hScrDC)
        hOldBitmap ＝ SelectObject (hMemDC_BkPicture, hBkBitmap)
        BitBlt (hMemDC_BkColor, 矩形.左边, 矩形.顶边, 矩形.右边, 矩形.底边, hMemDC_BkPicture, 0, 0, #SRCCOPY)
        BitBlt (wParam, 矩形.左边, 矩形.顶边, 矩形.右边, 矩形.底边, hMemDC_BkColor, 0, 0, #SRCCOPY)
        SelectObject (hMemDC_BkPicture, hOldBitmap)
        DeleteDC (hMemDC_BkPicture)
        SelectObject (hMemDC_BkColor, hOldTempMemBitmap)
        DeleteObject (hTempMemBitmap)
        DeleteDC (hMemDC_BkColor)
        ReleaseDC (0, hScrDC)
        InvalidateRect_逻辑型 (hWnd, 0, 假)
    .判断 (Msg ＝ #WM_VSCROLL)
        InvalidateRect_逻辑型 (hWnd, 0, 真)
    .判断 (Msg ＝ #WM_HSCROLL)
        InvalidateRect_逻辑型 (hWnd, 0, 真)
    .判断 (Msg ＝ #WM_DESTROY)
        .如果真 (取反 (ImageObject.是否为空 ()))
            ImageObject.清除 ()
        .如果真结束
        
    .默认
        
    .判断结束
    返回 (CallWindowProcA (集_子类化_编辑框, hWnd, Msg, wParam, lParam))

.子程序 初始化, , 公开
    .参数 参_窗口句柄, 整数型
    .参数 参_编辑框, 编辑框
    .参数 参_字体颜色, 整数型

    集_窗口句柄 ＝ 参_窗口句柄
    集_编辑框 ＝ 参_编辑框
    集_字体颜色 ＝ 参_字体颜色
    集_子类化_窗口 ＝ SetWindowLongA (参_窗口句柄, #GWL_WNDPROC, 类_取内部方法地址 (3))
    集_子类化_编辑框 ＝ SetWindowLongA (参_编辑框.取窗口句柄 (), #GWL_WNDPROC, 类_取内部方法地址 (4))
    InvalidateRect (参_编辑框.取窗口句柄 (), 0, 1)

.子程序 销毁, , 公开
    SetWindowLongA (集_窗口句柄, #GWL_WNDPROC, 集_子类化_窗口)
    SetWindowLongA (集_编辑框.取窗口句柄 (), #GWL_WNDPROC, 集_子类化_编辑框)
    InvalidateRect (集_编辑框.取窗口句柄 (), 0, 1)

.版本 2

.程序集 类_超级列表框, , 公开, 仅支持自身窗口的超列表框
.程序集变量 集_结构, LVINFO, , "0"
.程序集变量 集_标识, 整数型
.程序集变量 集_行高, 整数型
.程序集变量 集_超级列表框句柄, 整数型
.程序集变量 集_父窗口句柄, 整数型
.程序集变量 集_call, 整数型
.程序集变量 集_表头高度, 整数型
.程序集变量 集_新样式数组, 精易_表头样式, , "0"
.程序集变量 集_表头句柄, 整数型
.程序集变量 集_指针_超级列表框, 整数型
.程序集变量 集_子类化_超级列表框, 整数型
.程序集变量 集_子类化_表头, 整数型
.程序集变量 集_表头项, HDITEM
.程序集变量 集_指针_表头, 整数型
.程序集变量 集_列数, 整数型
.程序集变量 集_是否去除滚动条, 逻辑型

.子程序 _初始化, , , 1
    ' 使用程序集变量或全局变量声明类

.子程序 _销毁, , , 2
    表项_销毁 ()
    表头_销毁 ()

.子程序 子类化_超级列表框_表项, 整数型, , 3
    .参数 hWnd, 整数型
    .参数 uMsg, 整数型
    .参数 wParam, 整数型
    .参数 lParam, 整数型
    .局部变量 lvcd, NMLVCUSTOMDRAW
    .局部变量 i, 整数型
    .局部变量 局_xmlRoot, 对象
    .局部变量 局_childNode, 对象
    .局部变量 row, 整数型
    .局部变量 Column, 整数型
    .局部变量 clrText, 整数型
    .局部变量 clrTextBk, 整数型

    .判断开始 (uMsg ＝ #WM_NOTIFY)
        RtlMoveMemory_NMLVCUSTOMDRAW (lvcd, lParam, 104)
        .计次循环首 (取数组成员数 (集_结构), i)
            .如果真 (lvcd.nmcd.hdr.code ＝ #NM_CUSTOMDRAW 且 lvcd.nmcd.hdr.hWndFrom ＝ 集_结构 [i].窗口句柄)
                .判断开始 (lvcd.nmcd.dwDrawStage ＝ #CDDS_PREPAINT)
                    返回 (#CDRF_NOTIFYSUBITEMDRAW)
                .判断 (lvcd.nmcd.dwDrawStage ＝ #CDDS_ITEMPREPAINT)
                    返回 (#CDRF_NOTIFYSUBITEMDRAW)
                .判断 (lvcd.nmcd.dwDrawStage ＝ 位或 (#CDDS_ITEMPREPAINT, #CDDS_SUBITEM))
                    局_xmlRoot ＝ 集_结构 [i].对象.对象型方法 (“getElementsByTagName”, “LVINFO”).读对象型属性 (“item”, 0)
                    局_childNode ＝ 局_xmlRoot.对象型方法 (“getElementsByTagName”, “Item” ＋ 到文本 (lvcd.nmcd.dwItemSpec) ＋ “.” ＋ 到文本 (lvcd.iSubItem)).读对象型属性 (“item”, 0)
                    .如果 (局_childNode.是否为空 () ＝ 假)
                        row ＝ 局_childNode.数值方法 (“getAttribute”, “Row”)
                        Column ＝ 局_childNode.数值方法 (“getAttribute”, “Column”)
                        clrText ＝ 局_childNode.数值方法 (“getAttribute”, “clrText”)
                        clrTextBk ＝ 局_childNode.数值方法 (“getAttribute”, “clrTextBk”)
                        lvcd.clrText ＝ clrText
                        lvcd.clrTextBk ＝ clrTextBk
                        RtlMoveMemory_NMLVCUSTOMDRAW2 (lParam, lvcd, 104)
                        返回 (CallWindowProcA (GetPropA (hWnd, #旧窗口过程), hWnd, uMsg, wParam, lParam))
                    .否则
                        lvcd.clrText ＝ SendMessageA (集_结构 [i].窗口句柄, #LVM_GETTEXTCOLOR, 0, 0)
                        lvcd.clrTextBk ＝ SendMessageA (集_结构 [i].窗口句柄, #LVM_GETBKCOLOR, 0, 0)
                        RtlMoveMemory_NMLVCUSTOMDRAW2 (lParam, lvcd, 104)
                    .如果结束
                    
                .默认
                    
                .判断结束
                
            .如果真结束
            
        .计次循环尾 ()
        
    .判断 (uMsg ＝ #WM_MEASUREITEM) ' 超列计算行高时发送这个消息给父窗口，需要指定超列的 LVS_OWNERDRAWFIXED样式
        ' 因为消息是发送到父窗口中的，一个窗口中可能有多个控件，所以在实际应用中还应该判断是否是要指定的控件，可以通过MEASUREITEMSTRUCT结构中的CtlType成员或CtlID成员来进行判断。
        ' lparam=MEASUREITEMSTRUCT 结构
        ' MEASUREITEMSTRUCT中的itemHeight成员偏移长度为16
        ' 直接写内存修改itemHeight成员的高度
        写到内存 (集_行高, lParam ＋ 16, 4)
    .判断 (uMsg ＝ #WM_NCCALCSIZE)
        .判断开始 (集_是否去除滚动条)
            返回 (1)
        .默认
            
        .判断结束
        
    .默认
        
    .判断结束
    返回 (CallWindowProcA (集_标识, hWnd, uMsg, wParam, lParam))
    

.子程序 子类化_超级列表框_表头, 整数型, , 4   子类化超列
    .参数 hwnd, 整数型, , 超列的句柄
    .参数 msg, 整数型
    .参数 wParam, 整数型
    .参数 lParam, 整数型
    .局部变量 hDC, 整数型
    .局部变量 局_列索引, 整数型
    .局部变量 局_矩形, RECT
    .局部变量 局_刷子, 整数型
    .局部变量 局_背景色, 整数型
    .局部变量 局_文本色, 整数型
    .局部变量 局_颜色, 整数型
    .局部变量 drawItemStruct, DRAWITEMSTRUCT
    .局部变量 buf, 字节集
    .局部变量 局_返回, 整数型
    .局部变量 局_新样式, 精易_表头样式

    .判断开始 (msg ＝ #WM_DRAWITEM)
        CopyMemory_DRAWITEMSTRUCT (drawItemStruct, lParam, 48)
        hDC ＝ drawItemStruct.hDC
        局_列索引 ＝ drawItemStruct.itemID
        局_矩形 ＝ drawItemStruct.rcItem
        局_新样式 ＝ 内_索引转样式 (局_列索引)
        .判断开始 (局_新样式.参_列索引 ≠ -1)
            局_背景色 ＝ 局_新样式.参_背景色
            局_文本色 ＝ 局_新样式.参_文本色
        .默认
            局_背景色 ＝ #浅灰
            局_文本色 ＝ #黑色
        .判断结束
        局_刷子 ＝ CreateSolidBrush (局_背景色)
        FillRect_RECT (hDC, 局_矩形, 局_刷子)
        DeleteObject (局_刷子)
        局_颜色 ＝ SetTextColor (hDC, 局_文本色)
        SetBkMode (hDC, #TRANSPARENT)
        集_表头项.mask ＝ #HDI_TEXT
        集_表头项.cchTextMax ＝ 100
        buf ＝ 取空白字节集 (100)
        集_表头项.pszText ＝ 取空白字节集 (256) ' 取变量地址 (buf)
        SendMessage_HDITEM (集_表头句柄, #HDM_GETITEM, 局_列索引, 集_表头项)
        DrawText_RECT (hDC, 到文本 (集_表头项.pszText), -1, 局_矩形, 位或 (#DT_CENTER, #DT_VCENTER, #DT_SINGLELINE))
        SetTextColor (hDC, 局_颜色)
        
    .默认
        
    .判断结束
    局_返回 ＝ CallWindowProcA (集_子类化_超级列表框, hwnd, msg, wParam, lParam)
    返回 (局_返回)
    

.子程序 子类化_表头, 整数型, , 5  子类化超列表头
    .参数 hwnd, 整数型, , 超列表头的句柄
    .参数 msg, 整数型
    .参数 wParam, 整数型
    .参数 lParam, 整数型
    .局部变量 局_返回, 整数型

    局_返回 ＝ CallWindowProcA (集_子类化_表头, hwnd, msg, wParam, lParam)
    .如果真 (msg ＝ #HDM_LAYOUT)
        写到内存 (集_表头高度, 指针_到整数 (lParam) ＋ 4, 4) ' 27为新表头高度
        写到内存 (集_表头高度, 指针_到整数 (lParam ＋ 4) ＋ 20, 4)
        ' SetHDItem ()
    .如果真结束
    返回 (局_返回)

.子程序 初始化, , 公开
    .参数 父窗口句柄, 整数型
    .参数 超级列表框句柄, 整数型

    集_父窗口句柄 ＝ 父窗口句柄
    集_超级列表框句柄 ＝ 超级列表框句柄

.子程序 表项_销毁, , , 清除子类化
    .如果真 (集_标识 ≠ 0)
        SetWindowLongA (集_父窗口句柄, -4, 到整数 (集_标识))
        类_释放内部方法地址 (集_call)
    .如果真结束
    CoUninitialize ()

.子程序 表项_初始化, , 公开
    重定义数组 (集_结构, 假, 0)
    集_call ＝ 类_取内部方法地址 (3)
    集_标识 ＝ SetWindowLongA (集_父窗口句柄, #GWL_WNDPROC, 集_call)

.子程序 表项_置行列颜色, , 公开, 设置超级列表框表项颜色
    .参数 表项行号, 整数型
    .参数 表项列号, 整数型
    .参数 文本颜色, 整数型
    .参数 背景颜色, 整数型
    .局部变量 局_标识, 整数型
    .局部变量 局_结构, LVINFO
    .局部变量 局_是否存在, 逻辑型
    .局部变量 i, 整数型
    .局部变量 局_xmlRoot, 对象
    .局部变量 局_childNode, 对象
    .局部变量 局_NodeName, 文本型

    .计次循环首 (取数组成员数 (集_结构), i)
        .如果真 (集_结构 [i].窗口句柄 ＝ 集_超级列表框句柄)
            局_结构 ＝ 集_结构 [i]
            局_是否存在 ＝ 真
            跳出循环 ()
        .如果真结束
        
    .计次循环尾 ()
    
    .如果 (局_是否存在 ＝ 假)
        局_结构.窗口句柄 ＝ 集_超级列表框句柄
        CoInitialize (0)
        .如果真 (局_结构.对象.创建 (“Microsoft.XMLDOM”, ) ＝ 假)
            局_结构.对象.创建 (“MSXML.DOMDocument”, )
        .如果真结束
        局_xmlRoot ＝ 局_结构.对象.对象型方法 (“createElement”, “LVINFO”)
        局_xmlRoot.方法 (“setAttribute”, “hParent”, 集_父窗口句柄)
        局_xmlRoot.方法 (“setAttribute”, “hWnd”, 集_超级列表框句柄)
    .否则
        局_xmlRoot ＝ 局_结构.对象.对象型方法 (“getElementsByTagName”, “LVINFO”).读对象型属性 (“item”, 0)
    .如果结束
    
    局_NodeName ＝ “Item” ＋ 到文本 (表项行号) ＋ “.” ＋ 到文本 (表项列号)
    局_childNode ＝ 局_结构.对象.对象型方法 (“getElementsByTagName”, 局_NodeName).读对象型属性 (“item”, 0)
    .如果真 (局_childNode.是否为空 ())
        局_childNode ＝ 局_结构.对象.对象型方法 (“createElement”, 局_NodeName)
    .如果真结束
    
    局_childNode.数值方法 (“setAttribute”, “Row”, 表项行号)
    局_childNode.数值方法 (“setAttribute”, “Column”, 表项列号)
    局_childNode.数值方法 (“setAttribute”, “clrText”, 文本颜色)
    局_childNode.数值方法 (“setAttribute”, “clrTextBk”, 背景颜色)
    
    局_xmlRoot.方法 (“appendChild”, 局_childNode)
    局_结构.对象.方法 (“appendChild”, 局_xmlRoot)
    
    .如果 (局_是否存在 ＝ 假)
        加入成员 (集_结构, 局_结构)
    .否则
        集_结构 [i] ＝ 局_结构
    .如果结束
    InvalidateRect (集_超级列表框句柄, 0, 1)

.子程序 表项_删除行列颜色, , 公开
    .参数 表项行号, 整数型
    .参数 表项列号, 整数型
    .局部变量 i, 整数型
    .局部变量 局_xmlRoot, 对象
    .局部变量 局_childNode, 对象

    .计次循环首 (取数组成员数 (集_结构), i)
        .如果真 (集_结构 [i].窗口句柄 ＝ 集_超级列表框句柄)
            局_xmlRoot ＝ 集_结构 [i].对象.对象型方法 (“getElementsByTagName”, “LVINFO”).读对象型属性 (“item”, 0)
            局_childNode ＝ 局_xmlRoot.对象型方法 (“getElementsByTagName”, “Item” ＋ 到文本 (表项行号) ＋ “.” ＋ 到文本 (表项列号)).读对象型属性 (“item”, 0)
            .如果真 (局_childNode.是否为空 () ＝ 假)
                局_xmlRoot.方法 (“removeChild”, 局_childNode)
                InvalidateRect (集_超级列表框句柄, 0, 1)
            .如果真结束
            
        .如果真结束
        
    .计次循环尾 ()
    

.子程序 表项_清空行列颜色, , 公开
    .局部变量 i, 整数型

    .变量循环首 (取数组成员数 (集_结构), 1, -1, i)
        .如果真 (集_结构 [i].窗口句柄 ＝ 集_超级列表框句柄)
            删除成员 (集_结构, i, )
            InvalidateRect (集_超级列表框句柄, 0, 1)
        .如果真结束
        
    .变量循环尾 ()

.子程序 表项_置行高, , 公开, 设置超级列表框行高
    .参数 行高, 整数型
    .局部变量 winpos, WINDOWPOS
    .局部变量 OldStyle, 整数型

    集_行高 ＝ 行高
    winpos.hwnd ＝ 集_超级列表框句柄
    OldStyle ＝ GetWindowLongA (winpos.hwnd, #GWL_STYLE)
    SetWindowLongA (winpos.hwnd, #GWL_STYLE, 位或 (OldStyle, #LVS_OWNERDRAWFIXED))
    SendMessageWINDOWPOS (winpos.hwnd, #WM_WINDOWPOSCHANGED, 0, winpos)
    SetWindowLongA (winpos.hwnd, #GWL_STYLE, OldStyle)
    SendMessageA (winpos.hwnd, #LVM_UPDATE, 0, 0)
    
    

.子程序 表项_去除滚动条, , 公开, 去除超列滚动条
    .参数 参_是否去除, 逻辑型, , 真=去除，假=不去除

    集_是否去除滚动条 ＝ 参_是否去除
    

.子程序 方法1, , , 以上为  表项相关
    

.子程序 表头_设置新样式, , 公开
    .参数 参_表头高度, 整数型
    .参数 参_新样式数组, 精易_表头样式, 数组

    ' 该例程收录自;https://bbs.125.la/thread-14355436-1-1.html
    ' 原作者：http://bbs.eyuyan.com/read.php?tid=410674
    集_表头高度 ＝ 参_表头高度
    集_新样式数组 ＝ 参_新样式数组
    
    集_表头句柄 ＝ SendMessageA (集_超级列表框句柄, #LVM_GETHEADER, 0, 0) ' 取表头句柄
    集_列数 ＝ SendMessageA (集_表头句柄, #HDM_GETITEMCOUNT, 0, 0)
    集_指针_超级列表框 ＝ 类_取内部方法地址 (4)
    集_指针_表头 ＝ 类_取内部方法地址 (5)
    集_子类化_超级列表框 ＝ SetWindowLongA (集_超级列表框句柄, -4, 集_指针_超级列表框) ' 子类化超列
    集_子类化_表头 ＝ SetWindowLongA (集_表头句柄, -4, 集_指针_表头) ' 子类化超列表头
    内_设置表头项 ()
    SendMessageA (集_超级列表框句柄, #LVM_UPDATE, 0, 0)
    

.子程序 表头_销毁, , , 清除子类化，清除样式数组
    清除数组 (集_新样式数组)
    .如果真 (集_子类化_表头 ≠ 0)
        SetWindowLongA (集_表头句柄, -4, 集_指针_表头)
        类_释放内部方法地址 (集_指针_表头)
    .如果真结束
    
    .如果真 (集_子类化_超级列表框 ≠ 0)
        SetWindowLongA (集_超级列表框句柄, -4, 集_指针_超级列表框)
        类_释放内部方法地址 (集_指针_超级列表框)
    .如果真结束
    
    

.子程序 内_索引转样式, 精易_表头样式
    .参数 参_索引, 整数型
    .局部变量 i, 整数型
    .局部变量 局_单数据, 精易_表头样式

    .计次循环首 (取数组成员数 (集_新样式数组), i)
        局_单数据 ＝ 集_新样式数组 [i]
        .如果真 (局_单数据.参_列索引 ＝ 参_索引)
            返回 (局_单数据)
        .如果真结束
        
    .计次循环尾 ()
    局_单数据.参_列索引 ＝ -1
    返回 (局_单数据)

.子程序 内_设置表头项
    .局部变量 i, 整数型

    .如果真 (集_表头句柄 ＝ 0)
        返回 ()
    .如果真结束
    集_表头项.mask ＝ #HDI_FORMAT ' 这句必须有
    ' SendMessage_HDITEM (m_HDHwnd, #HDM_GETITEM, 1, hditem)
    集_表头项.fmt ＝ #HDF_OWNERDRAW ' 默认是 #HDF_STRING
    .计次循环首 (集_列数, i)
        SendMessage_HDITEM (集_表头句柄, #HDM_SETITEM, i － 1, 集_表头项)
    .计次循环尾 ()
    

.子程序 方法2, , , 以上为表头相关
    

.子程序 滚动条_是否在顶端或底端, 逻辑型, 公开
    .参数 参_是否在底端, 逻辑型, 可空, 可空，默认：假=是否在底端，真=是否在顶端
    .局部变量 info, SCROLLINFO

    info.cbSize ＝ 28
    info.fMask ＝ #SIF_ALL
    GetScrollInfo (集_超级列表框句柄, #SB_VERT, info)
    .如果 (参_是否在底端)
        返回 (info.nPos ＝ 0)
    .否则
        返回 (info.nPage ＋ info.nPos ＝ info.nMax ＋ 1)
    .如果结束
    

.版本 2

.程序集 类_通用对话框, , 公开
.程序集变量 hComdlg32, 整数型
.程序集变量 pOFNProc, 整数型
.程序集变量 pflOldProtect, 整数型
.程序集变量 pNewOFNProc, 整数型
.程序集变量 pOFNHookProc, 整数型
.程序集变量 aryOldAddr, 字节集
.程序集变量 aryNewAddr, 字节集
.程序集变量 wszFilePath, 字节集

.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
    

.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
    

.子程序 打开文件, 文本型, 公开, 与支持库通用对话框功能一样，成功返回一个通用对话框文件名，失败返回空。
    .参数 易样式, 逻辑型, 可空, 是否使用易语言样式。可为空，默认不使用。
    .参数 标题, 文本型, 可空, 仅适用于打开文件和保存文件对话框。
    .参数 文件名, 文本型, 可空, 从本属性中读取的文件名包括驱动器符和全路径目录，同时本属性也用作初始对话框中的文件名编辑框。
    .参数 过滤器, 文本型, 可空, 文本型。过滤器文本由单个或多个成对的文本串组成，每对文本串的第一个描述显示形式，如：“文本文件（*.txt）”；第二个指定实际的过滤匹配符，如：“*.txt”，所有各文本串之间用“|”号隔开。
    .参数 初始目录, 文本型, 可空, 指定当打开对话框时所自动跳转到的目录。
    .参数 默认文件后缀, 文本型, 可空, 指定当用户没有输入文件的后缀名称时所自动使用的文件后缀名称。
    .参数 创建时提示, 逻辑型, 可空, 当类型为打开文件对话框时，如果用户指定了一个不存在的文件名称，是否提示用户即将创建它。
    .参数 文件必须存在, 逻辑型, 可空, 当类型为打开文件对话框时，是否允许用户指定一个不存在的文件。
    .参数 目录必须存在, 逻辑型, 可空, 是否允许用户指定一个不存在的目录。
    .参数 不改变目录, 逻辑型, 可空, 在对话框关闭后是否自动返回到进入对话框时的文件目录。
    .局部变量 ofn, OPENFILENAME
    .局部变量 bool, 逻辑型
    .局部变量 mark

    ofn.结构大小 ＝ 76
    ofn.窗口句柄 ＝ GetActiveWindow ()
    ofn.文件标题 ＝ “Open a file”
    ofn.过滤器 ＝ 子字节集替换 (到字节集 (过滤器), { 124 }, { 0 }, , ) ＋ { 0, 0 }
    ofn.文件名 ＝ 取空白字节集 (255)
    lstrcpy_bin (ofn.文件名, 到字节集 (文件名) ＋ { 0, 0 })
    ofn.初始目录 ＝ 初始目录
    ofn.默认扩展名 ＝ 默认文件后缀
    ofn.标题 ＝ 标题
    ofn.文件名最大长度 ＝ 255
    mark ＝ 524288 ' OFN_EXPLORER
    .如果真 (创建时提示)
        mark ＝ 位或 (mark, 8192) ' OFN_CREATEPROMPT
    .如果真结束
    .如果真 (文件必须存在)
        mark ＝ 位或 (mark, 4096) ' OFN_FILEMUSTEXIST
    .如果真结束
    .如果真 (目录必须存在)
        mark ＝ 位或 (mark, 2048) ' OFN_PATHMUSTEXIST
    .如果真结束
    .如果真 (不改变目录)
        mark ＝ 位或 (mark, 8) ' OFN_NOCHANGEDIR
    .如果真结束
    ofn.标志 ＝ mark
    .如果 (是否为空 (易样式) 或 易样式 ＝ 假)
        bool ＝ GetOpenFileNameA (ofn)
    .否则
        bool ＝ GetOpenFileNamePreview (ofn)
    .如果结束
    返回 (选择 (bool, 到文本 (ofn.文件名), “”))

.子程序 保存文件, 文本型, 公开, 与支持库通用对话框功能一样，成功返回一个通用对话框文件名，失败返回空。
    .参数 易样式, 逻辑型, 可空, 是否使用易语言样式。可为空，默认不使用。
    .参数 标题, 文本型, 可空, 仅适用于打开文件和保存文件对话框。
    .参数 文件名, 文本型, 可空, 从本属性中读取的文件名包括驱动器符和全路径目录，同时本属性也用作初始对话框中的文件名编辑框。
    .参数 过滤器, 文本型, 可空, 格式：“MP3文件(*.mp3)|*.mp3|媒体文件(*.mpg)|*.mpg”
    .参数 初始目录, 文本型, 可空, 指定当打开对话框时所自动跳转到的目录。
    .参数 默认文件后缀, 文本型, 可空, 指定当用户没有输入文件的后缀名称时所自动使用的文件后缀名称。
    .参数 文件覆盖提示, 逻辑型, 可空, 当类型为保存文件对话框时，如果用户指定了一个已经存在的文件，是否询问用户确定覆盖此文件。
    .参数 目录必须存在, 逻辑型, 可空, 是否允许用户指定一个不存在的目录。
    .参数 不改变目录, 逻辑型, 可空, 在对话框关闭后是否自动返回到进入对话框时的文件目录。
    .局部变量 ofn, OPENFILENAME
    .局部变量 bool, 逻辑型
    .局部变量 mark

    ofn.结构大小 ＝ 76
    ofn.窗口句柄 ＝ GetActiveWindow ()
    ofn.文件标题 ＝ “Save a file”
    ofn.过滤器 ＝ 子字节集替换 (到字节集 (过滤器), { 124 }, { 0 }, , ) ＋ { 0 } ＋ { 0 }
    ofn.文件名 ＝ 取空白字节集 (255)
    lstrcpy_bin (ofn.文件名, 到字节集 (文件名) ＋ { 0, 0 })
    ofn.初始目录 ＝ 初始目录
    ofn.默认扩展名 ＝ 默认文件后缀
    ofn.标题 ＝ 标题
    ofn.文件名最大长度 ＝ 255
    mark ＝ 524288 ' OFN_EXPLORER
    .如果真 (文件覆盖提示)
        mark ＝ 位或 (mark, 2) ' OFN_OVERWRITEPROMPT
    .如果真结束
    .如果真 (目录必须存在)
        mark ＝ 位或 (mark, 2048) ' OFN_PATHMUSTEXIST
    .如果真结束
    .如果真 (不改变目录)
        mark ＝ 位或 (mark, 8) ' OFN_NOCHANGEDIR
    .如果真结束
    ofn.标志 ＝ mark
    .如果 (是否为空 (易样式) 或 易样式 ＝ 假)
        bool ＝ GetSaveFileNameA (ofn)
    .否则
        bool ＝ GetSaveFileNamePreview (ofn)
    .如果结束
    返回 (选择 (bool, 到文本 (ofn.文件名), “”))

.子程序 多选文件, 文本型, 公开, 显示一个文件打开对话框，允许用户选择或输入多个所需要打开的已存在文件，返回用户所选择或输入后的结果文本型。
    .参数 易样式, 逻辑型, 可空, 是否使用易语言样式。可为空，默认不使用。
    .参数 标题, 文本型, 可空, 可以被省略。指定文件打开对话框的标题，如果被省略，则默认为“请输入欲打开的文件：”。
    .参数 过滤器, 文本型, 可空, 可以被省略。过滤器文本由单个或多个成对的文本串组成，每对文本串的第一个描述显示形式，如：“文本文件（*.txt）”；
    .参数 初始目录, 文本型, 可空, 可以被省略。指定当打开对话框时所自动跳转到的目录，如果被省略，则默认为当前目录。
    .局部变量 文件列表, OPENFILENAME
    .局部变量 文件名, 字节集
    .局部变量 文件名数组, 文本型, , "0"
    .局部变量 Xh, 整数型
    .局部变量 Retrun, 文本型
    .局部变量 bool, 逻辑型

    处理事件 ()
    文件列表.结构大小 ＝ 76
    文件列表.窗口句柄 ＝ GetActiveWindow ()
    文件列表.过滤器 ＝ 子字节集替换 (到字节集 (过滤器), { 124 }, { 0 }, , ) ＋ { 0 } ＋ { 0 }
    文件列表.文件名 ＝ 取空白字节集 (4096)
    文件列表.文件名最大长度 ＝ 4096
    ' 文件列表.文件标题 ＝ 文本_取空白文本 (文件缓冲数)
    文件列表.文件标题最大长度 ＝ 4096
    文件列表.初始目录 ＝ 初始目录
    文件列表.标题 ＝ 标题
    文件列表.标志 ＝ 524800 ＋ 8
    
    .如果 (是否为空 (易样式) 或 易样式 ＝ 假)
        bool ＝ GetOpenFileNameA (文件列表)
    .否则
        bool ＝ GetOpenFileNamePreview (文件列表)
    .如果结束
    
    .如果 (bool)
        文件名 ＝ 文件列表.文件名
        文件名 ＝ 取字节集左边 (文件名, 寻找字节集 (文件名, { 0, 0 }, ) － 1)
        .如果 (寻找字节集 (文件名, { 0 }, ) ≠ -1)
            文件名数组 ＝ 分割文本 (到文本 (子字节集替换 (文件名, { 0 }, { 124 }, , )), “|”, )
            .如果真 (取文本右边 (文件名数组 [1], 1) ≠ “\”)
                文件名数组 [1] ＝ 文件名数组 [1] ＋ “\”
            .如果真结束
            .计次循环首 (取数组成员数 (文件名数组) － 1, Xh)
                .如果 (取数组成员数 (文件名数组) － 1 ≠ Xh)
                    Retrun ＝ Retrun ＋ 文件名数组 [1] ＋ 文件名数组 [Xh ＋ 1] ＋ #换行符
                .否则
                    Retrun ＝ Retrun ＋ 文件名数组 [1] ＋ 文件名数组 [Xh ＋ 1]
                .如果结束
                处理事件 ()
            .计次循环尾 ()
            返回 (Retrun)
        .否则
            返回 (到文本 (文件名))
        .如果结束
        
    .否则
        返回 (“”)
    .如果结束
    

.子程序 选择字体, 字体, 公开, 打开选择字体对话框，成功返回字体相关信息，调用格式如； 编辑框.字体=选择字体()
    .参数 字体名称, 文本型, 可空
    .参数 字体大小, , 可空
    .参数 字体颜色, , 可空
    .参数 加粗, 逻辑型, 可空
    .参数 倾斜, 逻辑型, 可空
    .参数 删除线, 逻辑型, 可空
    .参数 下划线, 逻辑型, 可空
    .参数 lRes, 逻辑型, 参考 可空, 如果用户单击对话框的OK按钮，则返回值为真。
    .局部变量 cf, CHOOSEFONT
    .局部变量 lfont, LOGFONT
    .局部变量 hMem, 整数型
    .局部变量 局部_字体信息, 字体
    .局部变量 hDC, 整数型

    lstrcpy_bytes (lfont.lfFaceName, 字体名称)
    hDC ＝ GetDC (0)
    lfont.lfHeight ＝ －MulDiv (字体大小, GetDeviceCaps (hDC, 90), 72) ' 把字体转换为lfHeight，用到公式
    lfont.lfWeight ＝ 选择 (是否为空 (加粗) 或 加粗 ＝ 假, 400, 700)
    lfont.lfUnderline ＝ 选择 (是否为空 (下划线) 或 下划线 ＝ 假, 0, 1)
    lfont.lfItalic ＝ 选择 (是否为空 (倾斜) 或 倾斜 ＝ 假, 0, 1)
    lfont.lfStrikeOut ＝ 选择 (是否为空 (删除线) 或 删除线 ＝ 假, 0, 1)
    lfont.lfCharSet ＝ 1
    hMem ＝ GlobalAlloc (64, 60)
    CopyMemory_logfont2int (hMem, lfont, 60)
    cf.结构大小 ＝ 60
    cf.窗口句柄 ＝ GetActiveWindow ()
    cf.字体结构指针 ＝ hMem
    cf.标志 ＝ 位或 (3, 256, 65536, 64, 8192)
    cf.颜色值 ＝ 字体颜色
    cf.字体类型 ＝ 1024
    cf.最小尺寸 ＝ 8
    cf.最大尺寸 ＝ 72
    lRes ＝ ChooseFont (cf)
    .如果真 (lRes)
        CopyMemory_int2logfont (lfont, hMem, 60)
        局部_字体信息.字体名称 ＝ 到文本 (lfont.lfFaceName)
        局部_字体信息.字体大小 ＝ cf.点大小 ÷ 10
        局部_字体信息.倾斜 ＝ lfont.lfItalic ≠ 0
        局部_字体信息.下划线 ＝ lfont.lfUnderline ＝ 1
        局部_字体信息.加粗 ＝ lfont.lfWeight ＝ 700
        局部_字体信息.删除线 ＝ lfont.lfStrikeOut ＝ 1
        局部_字体信息.角度 ＝ lfont.lfEscapement
    .如果真结束
    GlobalFree (hMem)
    返回 (局部_字体信息)

.子程序 SetOpenFileNameWHook, 逻辑型, 公开
    hComdlg32 ＝ LoadLibraryA (“Comdlg32.dll”)
    .如果真 (hComdlg32 ≠ #NULL)
        pOFNProc ＝ GetProcAddress (hComdlg32, “GetOpenFileNameW”) ' UNICODE
        ' pOFNProc ＝ GetProcAddress (hComdlg32, “GetOpenFileNameA”)  ' ANSI
        .如果真 (pOFNProc ≠ #NULL)
            .如果真 (VirtualProtectEx (#INVALID_HANDLE_VALUE, pOFNProc, 8, #PAGE_EXECUTE_READWRITE, pflOldProtect) ＝ 1) ' TRUE
                aryOldAddr ＝ 取空白字节集 (8)
                ReadProcessMemory_字节集 (#INVALID_HANDLE_VALUE, pOFNProc, aryOldAddr, 8, #NULL)
                pNewOFNProc ＝ 类回调_取类地址 (9, 1, , ) ' &NewOFNProc
                pOFNHookProc ＝ 类回调_取类地址 (10, 4, , ) ' &OFNHookProc
                aryNewAddr ＝ { 184 } ＋ 到字节集 (pNewOFNProc) ＋ { 255, 224, 0 }
                ' mov eax, pNewOFNProc
                ' jmp eax
                WriteProcessMemory_字节集 (#INVALID_HANDLE_VALUE, pOFNProc, aryNewAddr, 8, #NULL)
                返回 (真)
            .如果真结束
            
        .如果真结束
        .如果真 (pOFNProc ＝ #NULL 或 pflOldProtect ＝ #NULL)
            FreeLibrary (hComdlg32)
            连续赋值 (#NULL, pOFNProc, pflOldProtect, hComdlg32)
        .如果真结束
        
    .如果真结束
    返回 (假)

.子程序 RemoveOpenFileNameWHook, , 公开
    .如果真 (aryOldAddr ≠ { })
        WriteProcessMemory_字节集 (#INVALID_HANDLE_VALUE, pOFNProc, aryOldAddr, 8, #NULL)
        aryOldAddr ＝ { }
    .如果真结束
    .如果真 (pOFNProc ≠ #NULL 且 pflOldProtect ≠ #NULL)
        VirtualProtectEx (#INVALID_HANDLE_VALUE, pOFNProc, 8, #PAGE_EXECUTE_READWRITE, pflOldProtect)
        连续赋值 (#NULL, pOFNProc, pflOldProtect)
    .如果真结束
    .如果真 (pOFNHookProc ≠ #NULL)
        类回调_释放回调 (pOFNHookProc)
        pOFNHookProc ＝ #NULL
    .如果真结束
    .如果真 (hComdlg32 ≠ #NULL)
        FreeLibrary (hComdlg32)
        hComdlg32 ＝ #NULL
    .如果真结束
    

.子程序 NewOFNProc, 整数型
    .参数 lpOFN, 整数型
    .局部变量 dwFlags, 整数型
    .局部变量 lRet, 整数型

    WriteProcessMemory_字节集 (#INVALID_HANDLE_VALUE, pOFNProc, aryOldAddr, 8, #NULL)
    .如果真 (lpOFN ≠ #NULL)
        dwFlags ＝ __get (lpOFN, 52) ' Flags
        .如果真 (位与 (dwFlags, #OFN_EXPLORER) ＝ 0)
            dwFlags ＝ 位或 (dwFlags, #OFN_EXPLORER)
        .如果真结束
        dwFlags ＝ 位或 (dwFlags, #OFN_ENABLEHOOK)
        __set (lpOFN, 52, dwFlags)
        __set (lpOFN, 68, pOFNHookProc) ' lpfnHook
        lRet ＝ 调用子程序_ (pOFNProc, lpOFN, , , , , , , , , , , , , , )
    .如果真结束
    WriteProcessMemory_字节集 (#INVALID_HANDLE_VALUE, pOFNProc, aryNewAddr, 8, #NULL)
    返回 (lRet)

.子程序 OFNHookProc, 整数型
    .参数 hwnd, 整数型
    .参数 uMsg, 整数型
    .参数 wParam, 整数型
    .参数 lParam, 整数型
    .局部变量 dwCode, 整数型
    .局部变量 lpOFN, 整数型
    .局部变量 nMaxFile, 整数型
    .局部变量 lpstrFile, 整数型
    .局部变量 dwSize, 整数型

    .如果真 (uMsg ＝ #WM_NOTIFY)
        dwCode ＝ __get (lParam, 8)
        .如果真 (dwCode ＝ #CDN_INITDONE)
            lpOFN ＝ __get (lParam, 12)
            nMaxFile ＝ __get (lpOFN, 32)
            lpstrFile ＝ __get (lpOFN, 28)
            dwSize ＝ 取字节集长度 (wszFilePath)
            .如果真 (dwSize ＞ 0 且 dwSize ≤ nMaxFile)
                WriteProcessMemory_字节集 (#INVALID_HANDLE_VALUE, lpstrFile, wszFilePath, dwSize, #NULL) ' UNICODE
                ' WriteProcessMemory_字节集 (#INVALID_HANDLE_VALUE, lpstrFile, wszFilePath ＋ { 0 }, dwSize ＋ 1, #NULL)  ' ANSI
            .如果真结束
            EndDialog (GetParent (hwnd), 1)
        .如果真结束
        
    .如果真结束
    返回 (0)

.子程序 置初始化文件名W, , 公开
    .参数 文件路径, 字节集

    wszFilePath ＝ 文件路径

.版本 2

.程序集 集_组件, , , 全部为API和核心支持库
.程序集变量 集_窗口函数, 整数型

.子程序 画板_去背景色, , 公开, 去掉画板的背景，只留图片[精易]
    .参数 画板, 画板, , 要去背景的画板
    .参数 透明色, 整数型, , 透明度为1-100,如果画板上的图片背景为白色时，直接填入 #白色 ，可以连图片的白色背景也去掉
    .局部变量 图片, 字节集
    .局部变量 图片2, 字节集
    .局部变量 长度, 整数型
    .局部变量 I, 整数型
    .局部变量 透明字节集, 字节集
    .局部变量 底色字节集, 字节集
    .局部变量 点色, 字节集

    图片2 ＝ 画板.取图片 (, )
    .如果 (-16777216 ＝ 画板.画板背景色)
        底色字节集 ＝ 取字节集左边 (到字节集 (15526360), 3)
    .否则
        底色字节集 ＝ 取字节集左边 (到字节集 (画板.画板背景色), 3)
    .如果结束
    画板.可视 ＝ 假
    图片 ＝ 快照 (画板.取窗口句柄 (), , )
    长度 ＝ (取字节集长度 (图片2) － 54) ÷ 3
    透明字节集 ＝ 取字节集左边 (到字节集 (透明色), 3)
    .计次循环首 (长度, I)
        点色 ＝ 取字节集中间 (图片2, 55 ＋ I × 3 － 3, 3)
        .如果真 (点色 ＝ 透明字节集 或 点色 ＝ 底色字节集)
            图片2 [55 ＋ I × 3 － 3] ＝ 图片 [55 ＋ I × 3 － 3]
            图片2 [55 ＋ I × 3 － 3 ＋ 1] ＝ 图片 [55 ＋ I × 3 － 3 ＋ 1]
            图片2 [55 ＋ I × 3 － 3 ＋ 2] ＝ 图片 [55 ＋ I × 3 － 3 ＋ 2]
        .如果真结束
        
    .计次循环尾 ()
    画板.底图 ＝ 图片2
    画板.可视 ＝ 真

.子程序 外部滚动条_显示隐藏, 逻辑型, 公开, 成功返回真；失败返回假
    .参数 窗口句柄, 整数型, , 要操作滚动条的控件句柄
    .参数 滚动条标识, 整数型, , 0 = 横向滚动条； 1 = 纵向滚动条； 3 = 横纵向滚动条；
    .参数 显示隐藏, 逻辑型, , 真 = 显示；假 = 隐藏

    返回 (ShowScrollBar (窗口句柄, 滚动条标识, 显示隐藏))

.子程序 时钟_创建, 整数型, 公开, 创建一个计时器; 成功返回非0整数标识符, 可以将此值传递给 时钟_销毁 来销毁计时器
    .参数 窗口句柄, 整数型, 可空, 要与计时器关联的窗口的句柄
    .参数 时钟标识, 整数型, 可空, 非零计时器标识符; 如果窗口句柄无效, 则忽略该参数
    .参数 时钟周期, 整数型, , 时钟周期; 以毫秒为单位
    .参数 时钟_周期事件, 子程序指针, , 周期事件

    返回 (SetTimer (窗口句柄, 时钟标识, 时钟周期, 到整数 (时钟_周期事件)))

.子程序 时钟_销毁, 逻辑型, 公开, 销毁一个时钟；成功返回真，失败返回假；
    .参数 窗口句柄, 整数型, 可空, 要与计时器关联的窗口的句柄
    .参数 时钟标识, 整数型, , 创建时用的时钟标识

    返回 (KillTimer (窗口句柄, 时钟标识))

.子程序 进度条_改颜色, , 公开
    .参数 进度条句柄, 整数型
    .参数 颜色, 整数型

    SendMessageA (进度条句柄, 1033, 1, 颜色)

.子程序 进度条_模拟, , 公开, 画板高度调个20就行了。宽度自己看着调
    .参数 画板, 画板
    .参数 最大位置, 整数型
    .参数 当前位置, 整数型
    .参数 进度条颜色, 整数型, 可空, 可人，默认为红色；比如 生命值 一般都用红色，真气值一般都用蓝色
    .参数 提示文本, 文本型, 可空, 比如 生命值 或者 真气值
    .参数 输出百分比, 整数型, 参考 可空, 用一个变量来接收百分比;不用的话可以留空；
    .参数 是否显示百分比, 逻辑型, 可空, 是否显示百分比；如 80%
    .局部变量 横变量, 双精度小数型
    .局部变量 h变量1, 双精度小数型

    .如果真 (是否为空 (进度条颜色))
        进度条颜色 ＝ #红色
    .如果真结束
    画板.清除 (, , , )
    画板.自动重画 ＝ 真
    画板.刷子颜色 ＝ 进度条颜色
    横变量 ＝ 到数值 (当前位置 ÷ 最大位置) × 画板.宽度
    画板.填充矩形 (画板.画笔粗细, 画板.高度, 横变量, 画板.高度 ÷ 100)
    .如果真 (是否显示百分比)
        画板.定位写出 (画板.宽度 ÷ 2 － 40, 到数值 (4), 提示文本 ＋ 到文本 (当前位置) ＋ “ / ” ＋ 到文本 (最大位置) ＋ “  ” ＋ 到文本 (取整 (当前位置 ÷ 最大位置 × 100)) ＋ “%”)
    .如果真结束
    输出百分比 ＝ 取整 (当前位置 ÷ 最大位置 × 100)

.子程序 进度条_模拟S, , 公开, 画板高度调个20就行了。宽度自己看着调,源码由【yangyitzzg】提供
    .参数 画板, 画板
    .参数 最大位置, 整数型
    .参数 当前位置, 整数型
    .参数 进度条颜色, 整数型, 可空, 可人，默认为红色；比如 生命值 一般都用红色，真气值一般都用蓝色
    .参数 提示文本, 文本型, 可空, 比如 生命值 或者 真气值。留空不显示。和[是否显示百分比]二选一
    .参数 提示文本位置, 整数型, 可空, 默认:画板.宽度 ÷ 2 － 40
    .参数 输出百分比, 整数型, 参考 可空, 用一个变量来接收百分比;不用的话可以留空；
    .参数 是否显示百分比, 逻辑型, 可空, 是否显示百分比；如 80%。。留空不显示。和[提示文本]二选一
    .局部变量 横变量, 双精度小数型
    .局部变量 h变量1, 双精度小数型

    .如果真 (是否为空 (进度条颜色))
        进度条颜色 ＝ #红色
    .如果真结束
    画板.清除 (, , , )
    画板.自动重画 ＝ 真
    画板.刷子颜色 ＝ 进度条颜色
    横变量 ＝ 到数值 (当前位置 ÷ 最大位置) × 画板.宽度
    画板.填充矩形 (画板.画笔粗细, 画板.高度, 横变量, 画板.高度 ÷ 100)
    .如果真 (是否为空 (提示文本位置))
        提示文本位置 ＝ 画板.宽度 ÷ 2 － 40
    .如果真结束
    .判断开始 (取反 (是否为空 (提示文本)))
        画板.定位写出 (提示文本位置, 到数值 (4), 提示文本)
    .判断 (是否显示百分比)
        画板.定位写出 (提示文本位置, 到数值 (4), 到文本 (当前位置) ＋ “ / ” ＋ 到文本 (最大位置) ＋ “  ” ＋ 到文本 (取整 (当前位置 ÷ 最大位置 × 100)) ＋ “%”)
    .默认
        
    .判断结束
    输出百分比 ＝ 取整 (当前位置 ÷ 最大位置 × 100)

.子程序 进度条_滚动, 整数型, 公开, 设置成功返回1，失败返回0。需要使用Windows通用组件库。
    .参数 进度条句柄, 整数型
    .参数 滚动速度, 整数型, 可空, 滚动速度默认为30，0为停止滚动。数值越大速度越慢，称之为滚动延迟应该是比较合适的。
    .局部变量 OldStyle, 整数型
    .局部变量 Speed, 整数型

    ' https://bbs.125.la/thread-14456319-1-1.html
    OldStyle ＝ GetWindowLongA (进度条句柄, #GWL_STYLE)
    .如果真 (位与 (OldStyle, #PBS_MARQUEE) ≠ #PBS_MARQUEE)
        OldStyle ＝ 位异或 (OldStyle, #PBS_MARQUEE)
    .如果真结束
    SetWindowLongA (进度条句柄, #GWL_STYLE, OldStyle)
    
    .判断开始 (是否为空 (滚动速度))
        Speed ＝ 30
    .默认
        Speed ＝ 滚动速度
    .判断结束
    
    .判断开始 (Speed ＞ 0)
        返回 (SendMessageA (进度条句柄, #PBM_SETMARQUEE, 1, Speed)) ' 开始滚动
    .默认
        返回 (SendMessageA (进度条句柄, #PBM_SETMARQUEE, 0, 0)) ' 停止滚动
    .判断结束
    

.子程序 外部列表框_清空, , 公开, 清空列表框
    .参数 句柄, 整数型, , 列表框句柄

    SendMessageA (句柄, 388, 0, 0)

.子程序 外部列表框_取项目数, 整数型, 公开, 取列表框总项目数
    .参数 句柄, 整数型, , 列表框句柄

    返回 (SendMessageA (句柄, 395, 0, 0))

.子程序 外部列表框_加入项目, , 公开, 添加新项目
    .参数 句柄, 整数型, , 列表框句柄
    .参数 项目文本, 文本型, , 要添加的项目文本

    SendMessageA (句柄, 385, -1, 取指针文本_ (项目文本))

.子程序 外部列表框_插入项目, , 公开, 插入新项目
    .参数 句柄, 整数型
    .参数 项目索引, 整数型, , 0表示第一项
    .参数 项目文本, 文本型, , 要插入的项目文本

    SendMessageA (句柄, 385, 项目索引, 取指针文本_ (项目文本))

.子程序 外部列表框_删除项目, , 公开, 删除指定项目
    .参数 句柄, 整数型, , 列表框句柄
    .参数 项目索引, 整数型, , 0表示第一项

    SendMessageA (句柄, 386, 项目索引, 0)

.子程序 外部列表框_取选中项, 整数型, 公开, 取列表框现行选中项
    .参数 句柄, 整数型, , 列表框句柄

    返回 (SendMessageA (句柄, 392, 0, 0))

.子程序 外部列表框_置选中项, , 公开, 置列表框现行选中项
    .参数 句柄, 整数型, , 列表框句柄
    .参数 项目索引, 整数型, , 0表示第一项

    SendMessageA (句柄, 390, 项目索引, 0)

.子程序 外部列表框_取项目文本, 文本型, 公开, 取列表框指定项的项目文本
    .参数 列表框句柄, 整数型, , 列表框句柄
    .参数 项目索引, 整数型, , 0表示第一项
    .局部变量 文本, 文本型

    文本 ＝ 取空白文本 (SendMessageA (列表框句柄, 394, 项目索引, 0))
    SendMessageA (列表框句柄, 393, 项目索引, 取指针文本_ (文本))
    返回 (文本)

.子程序 外部列表框_保存数据, 逻辑型, 公开, 如果要读入的话, 直接 列表框.列表项目 = 读入文件("文件名") 即可
    .参数 列表框句柄, 整数型, , 列表框句柄
    .参数 要保存的位置, 文本型, , 如: C:\001.lbb 即可
    .局部变量 局_计次, 整数型
    .局部变量 局_项目数, 整数型
    .局部变量 局_临时字节集, 字节集, , , 超级列表框列数
    .局部变量 局_文件号, 整数型
    .局部变量 局_文本, 文本型

    局_文件号 ＝ 打开内存文件 ()
    局_项目数 ＝ 外部列表框_取项目数 (列表框句柄)
    插入字节集 (局_文件号, 到字节集 (到字节 (局_项目数)) ＋ { 0 })
    .计次循环首 (局_项目数, 局_计次)
        局_文本 ＝ 外部列表框_取项目文本 (列表框句柄, 局_计次 － 1)
        插入字节集 (局_文件号, 到字节集 (取文本长度 (局_文本)) ＋ 到字节集 (局_文本))
    .计次循环尾 ()
    移动读写位置 (局_文件号, #文件首, 0)
    局_临时字节集 ＝ 读入字节集 (局_文件号, 取文件长度 (局_文件号))
    .如果 (写到文件 (要保存的位置, 局_临时字节集))
        关闭文件 (局_文件号)
        返回 (真)
    .否则
        关闭文件 (局_文件号)
    .如果结束
    返回 (假)

.子程序 外部列表框_取项目数值, 整数型, 公开, 取得指定项目数值
    .参数 句柄, 整数型, , 列表框句柄
    .参数 项目索引, 整数型, , 0表示第一项

    返回 (SendMessageA (句柄, 409, 项目索引, 0))

.子程序 外部列表框_鼠标坐标取项目索引, 整数型, 公开, 鼠标坐标位置的项目索引,一般放在列表框 鼠标位置被移动 事件里,成功返回列表框的项目索引，失败返回-1
    .参数 列表框窗口句柄, 整数型
    .局部变量 坐标, 精易_坐标

    坐标 ＝ 鼠标_取位置 ()
    返回 (LBItemFromPt (列表框窗口句柄, 坐标.横, 坐标.纵, 真))

.子程序 外部列表框_置项目数值, , 公开, 置指定项目数值
    .参数 句柄, 整数型, , 列表框句柄
    .参数 项目索引, 整数型
    .参数 项目数值, 整数型

    SendMessageA (句柄, 410, 项目索引, 项目数值)

.子程序 列表框_读入配置文件, , 公开, 读入文件到列表框里，该文件要用<列表框_保存文本>命令保存的格式！<该命令一般都与“列表框_保存为配置文件”成双使用！>
    .参数 要读的文件名, 文本型, , 文件全路径
    .参数 列表框, 列表框, , 列表框
    .参数 是否读取前后缀, 逻辑型, 可空, 默认为假，将读取前后缀！
    .参数 前缀文本, 文本型, 可空, 要读取的《前缀文本》,“是否读取前后缀”为真时本参数才有效！
    .参数 后缀文本, 文本型, 可空, 要读取的《后缀文本》,“是否读取前后缀”为真时本参数才有效！
    .局部变量 节名数组, 文本型, , "0"
    .局部变量 计次, 整数型
    .局部变量 文本, 文本型

    节名数组 ＝ 取配置节名 (要读的文件名)
    .如果 (是否读取前后缀 ＝ 真)
        .计次循环首 (取数组成员数 (节名数组), 计次)
            文本 ＝ 取出中间文本 (读配置项 (要读的文件名, 到文本 (计次), 到文本 (计次), ), 前缀文本, 后缀文本)
            列表框.加入项目 (文本, )
        .计次循环尾 ()
    .否则
        
        .计次循环首 (取数组成员数 (节名数组), 计次)
            列表框.加入项目 (读配置项 (要读的文件名, 到文本 (计次), 到文本 (计次), ), )
        .计次循环尾 ()
    .如果结束
    

.子程序 列表框_保存为配置文件, , 公开, 将所有列表框里的文本保存到一个文件里！<该命令一般都与“列表框_读入配置文件”成双使用！>
    .参数 要保存的文件名, 文本型, , 文件全路径
    .参数 列表框, 列表框, , 列表框
    .参数 加前缀, 文本型, 可空, 在文本前面加上一段字符或汉字
    .参数 加后缀, 文本型, 可空, 在文本后面加上一段字符或汉字
    .局部变量 计次, 整数型
    .局部变量 URL条数, 整数型

    URL条数 ＝ 列表框.取项目数 ()
    .如果 (URL条数 ＝ 0)
        删除文件 (要保存的文件名)
        写到文件 (要保存的文件名, 到字节集 (“”))
    .否则
        删除文件 (要保存的文件名)
        .计次循环首 (URL条数, 计次)
            写配置项 (要保存的文件名, 到文本 (计次), 到文本 (计次), 加前缀 ＋ 列表框.取项目文本 (计次 － 1) ＋ 加后缀)
        .计次循环尾 ()
    .如果结束
    

.子程序 外部列表框_取鼠标处项目索引, 整数型, 公开, 请把些命令放在“_列表框_鼠标位置被移动”事件下
    .参数 列表框句柄
    .参数 横向位置, 整数型, , 把“_列表框1_鼠标位置被移动”下的“横向位置”的参数放在这里
    .参数 纵向位置, 整数型, , 把“_列表框1_鼠标位置被移动”下的“纵向位置”的参数放在这里

    返回 (发送消息整数 (列表框句柄, 425, 0, 横向位置 ＋ 纵向位置 × 65536))

.子程序 外部列表框_查找表项, 整数型, 公开, 查找匹配字符串，忽略大小写，从指定开始表项序号开始查找，当查到某表项的文本字符串的前面包括指定的字符串则结束，找不到则转到列表框第一项继续查找，直到查完所有表项，如果起始查找位置为-1则从列表框第一项开始查找，如果找到则返回表项序号，否则返回 -1 。
    .参数 列表框句柄, 整数型
    .参数 标题, 文本型, , 本参数指定欲查找表项的标题文本。
    .参数 起始查找位置, 整数型, 可空, 本参数指定查找表项的起始位置。如果本参数被省略，默认值为 -1 ，即从首项开始查找。
    .参数 是否精确匹配, 逻辑型, 可空, 本参数指定匹配标题文本时是否为精确匹配，如果本参数为假，则只要表项标题首部包含指定文本即认为匹配成功。如果本参数被省略，默认值为真。
    .局部变量 局_是否精确匹配, 整数型
    .局部变量 局_索引, 整数型

    .如果真 (是否为空 (起始查找位置))
        起始查找位置 ＝ -1
    .如果真结束
    .如果真 (是否为空 (是否精确匹配))
        是否精确匹配 ＝ 真
    .如果真结束
    局_是否精确匹配 ＝ 选择 (是否精确匹配, #LB_FINDSTRINGEXACT, #LB_FINDSTRING)
    局_索引 ＝ SendMessageA (列表框句柄, 局_是否精确匹配, 起始查找位置, 取指针文本_ (标题))
    返回 (局_索引)

.子程序 取出中间文本, 文本型, , 列表框_读入配置文件——要用到
    .参数 欲取全文本, 文本型, , 比如：欲取全文本为 12345
    .参数 前面文本, 文本型, , 3的前面为“2”
    .参数 后面文本, 文本型, , 3的后面为“4”
    .局部变量 前面位置, 整数型
    .局部变量 后面位置, 整数型
    .局部变量 取出多少字符, 整数型
    .局部变量 文本1, 文本型
    .局部变量 文本2, 文本型

    .如果真 (寻找文本 (欲取全文本, 前面文本, , 真) ≠ -1)
        前面位置 ＝ 寻找文本 (欲取全文本, 前面文本, , 真)
        文本1 ＝ 取文本右边 (欲取全文本, 取文本长度 (欲取全文本) － (前面位置 ＋ 取文本长度 (前面文本) － 1))
        后面位置 ＝ 寻找文本 (文本1, 后面文本, 1, 真)
        文本2 ＝ 取文本左边 (文本1, 后面位置 － 1)
        返回 (文本2)
    .如果真结束
    返回 (文本2)

.子程序 外部选择列表框_清空, , 公开, 清空选择列表框
    .参数 选择列表框句柄, 整数型, , 选择列表框句柄

    SendMessageA (选择列表框句柄, 388, 0, 0)

.子程序 外部选择列表框_选中, 逻辑型, 公开, 成功返回真,失败返回假
    .参数 选择列表框句柄, 整数型, , 选择列表框句柄
    .参数 选择列表框索引, 整数型, , 选择列表框索引,从1开始

    延时 (3)
    .如果真 (发送消息整数 (选择列表框句柄, 390, 选择列表框索引 － 1, 0) ≠ -1)
        返回 (真)
    .如果真结束
    返回 (假)

.子程序 外部选择列表框_打勾, 逻辑型, 公开, 成功返回真,失败返回假
    .参数 选择列表框句柄, 整数型, , 选择列表框句柄
    .参数 选择列表框索引, 整数型, , 选择列表框索引,从1开始

    延时 (3)
    .如果真 (发送消息整数 (选择列表框句柄, 390, 选择列表框索引 － 1, 0) ≠ -1)
        键盘_消息 (选择列表框句柄, #空格键, 5, 假)
        返回 (真)
    .如果真结束
    返回 (假)

.子程序 外部选择列表框_加入项目, , 公开, 添加新项目
    .参数 选择列表框句柄, 整数型, , 选择列表框句柄
    .参数 项目文本, 文本型, , 要添加的项目文本

    SendMessageA (选择列表框句柄, 385, -1, 取指针文本_ (项目文本))

.子程序 外部选择列表框_插入项目, , 公开, 插入新项目
    .参数 选择列表框句柄, 整数型, , 选择列表框句柄
    .参数 项目索引, 整数型, , 选择列表框索引,从1开始
    .参数 项目文本, 文本型, , 要插入的项目文本

    SendMessageA (选择列表框句柄, 385, 项目索引, 取指针文本_ (项目文本))

.子程序 外部选择列表框_取项目数, 整数型, 公开, 取选择列表框总项目数
    .参数 选择列表框句柄, 整数型, , 选择列表框句柄

    返回 (SendMessageA (选择列表框句柄, 395, 0, 0))

.子程序 外部选择列表框_取项目数值, 整数型, 公开, 取得指定项目数值
    .参数 选择列表框句柄, 整数型, , 选择列表框句柄
    .参数 项目索引, 整数型, , 选择列表框索引,从1开始

    返回 (SendMessageA (选择列表框句柄, 409, 项目索引 － 1, 0))

.子程序 外部选择列表框_置项目数值, , 公开, 置指定项目数值
    .参数 选择列表框句柄, 整数型, , 选择列表框句柄
    .参数 项目索引, 整数型, , 选择列表框索引,从1开始
    .参数 项目数值, 整数型, , 要置入的项目数值

    SendMessageA (选择列表框句柄, 410, 项目索引 － 1, 项目数值)

.子程序 外部选择列表框_取项目文本, 文本型, 公开, 取选择列表框指定项的项目文本
    .参数 选择列表框句柄, 整数型, , 选择列表框句柄
    .参数 项目索引, 整数型, , 选择列表框索引,从1开始
    .局部变量 文本, 文本型

    文本 ＝ 取空白文本 (SendMessageA (选择列表框句柄, 394, 项目索引 － 1, 0))
    SendMessageA (选择列表框句柄, 393, 项目索引 － 1, 取指针文本_ (文本))
    返回 (文本)

.子程序 子程序4, , , ——————————————————————————————————————————————————————————
    

.子程序 外部组合框_查找, 整数型, 公开, 返回-1表示没有找到。否则将返回找到的项目索引，索引从0开始。
    .参数 参_组合框句柄, 整数型
    .参数 参数_欲查找文本, 文本型, , 可以是文本前缀，如：查找“易语言4.12”，则可以是“易语言”
    .参数 参数_起始位置, 整数型, 可空, 默认为-1:表示从第一项开始查找。索引从0开始。

    .如果真 (是否为空 (参数_起始位置))
        参数_起始位置 ＝ -1
    .如果真结束
    返回 (SendMessageA (参_组合框句柄, #CB_FINDSTRING, 参数_起始位置, 取指针文本_ (参数_欲查找文本)))

.子程序 外部组合框_精确查找, 整数型, 公开, 本命令与查找相比，必须文本完全匹配才能找到项目。成功返回项目索引，失败返回-1。
    .参数 参_组合框句柄, 整数型
    .参数 参数_欲查找文本, 文本型, , 必须全字匹配
    .参数 参数_起始位置, 整数型, 可空, 默认为-1:表示从第一项开始查找。索引从0开始。

    .如果真 (是否为空 (参数_起始位置))
        参数_起始位置 ＝ -1
    .如果真结束
    返回 (SendMessageA (参_组合框句柄, #CB_FINDSTRINGEXACT, 参数_起始位置, 取指针文本_ (参数_欲查找文本)))

.子程序 外部组合框_向上展开列表, , 公开
    .参数 参_窗口句柄, 整数型

    集_窗口函数 ＝ SetWindowLongA (参_窗口句柄, #GWL_WNDPROC, 到整数 (&消息处理))
    外部组合框_弹开列表 (参_窗口句柄)
    SetWindowLongA (参_窗口句柄, #GWL_WNDPROC, 集_窗口函数)

.子程序 消息处理, 整数型, , 不要修改该子程序的返回值及参数的类型！
    .参数 窗口句柄, 整数型
    .参数 消息, 整数型
    .参数 参数1, 整数型
    .参数 参数2, 整数型
    .局部变量 局部_列表框, 精易_矩形
    .局部变量 局部_组合框, 精易_矩形
    .局部变量 局部_新TOP, 整数型

    .如果真 (消息 ＝ 308)
        GetWindowRect (参数2, 局部_列表框)
        GetWindowRect (窗口句柄, 局部_组合框)
        SetWindowPos (参数2, 0, 局部_列表框.左边, 局部_组合框.顶边 － (局部_列表框.底边 － 局部_列表框.顶边), 局部_列表框.右边 － 局部_列表框.左边, 局部_列表框.底边 － 局部_列表框.顶边, 0)
    .如果真结束
    返回 (CallWindowProcA (集_窗口函数, 窗口句柄, 消息, 参数1, 参数2))

.子程序 外部组合框_设置下拉高度, , 公开
    .参数 窗口句柄, 整数型
    .参数 高度, 整数型

    PostMessageA (窗口句柄, #CB_SETITEMHEIGHT, 0, 高度 － 6)

.子程序 外部组合框_设置下拉宽度, , 公开
    .参数 窗口句柄, 整数型
    .参数 宽度, 整数型

    PostMessageA (窗口句柄, #CB_SETDROPPEDWIDTH, 宽度, 0)

.子程序 外部组合框_设置高度, , 公开
    .参数 窗口句柄, 整数型
    .参数 高度, 整数型

    PostMessageA (窗口句柄, #CB_SETITEMHEIGHT, -1, 高度 － 6)

.子程序 外部组合框_取高度, 整数型, 公开
    .参数 窗口句柄, 整数型

    返回 (SendMessageA (窗口句柄, #CB_GETITEMHEIGHT, -1, 0) ＋ 6)
    

.子程序 外部组合框_取下拉高度, 整数型, 公开
    .参数 窗口句柄, 整数型

    返回 (SendMessageA (窗口句柄, #CB_GETITEMHEIGHT, 0, 0) ＋ 6)

.子程序 外部组合框_取下拉宽度, 整数型, 公开
    .参数 窗口句柄, 整数型

    返回 (SendMessageA (窗口句柄, #CB_GETDROPPEDWIDTH, 0, 0))

.子程序 外部组合框_清空, , 公开, 删除组合框所有项目
    .参数 句柄, 整数型, , 组合框句柄

    SendMessageA (句柄, #CB_RESETCONTENT, 0, 0)

.子程序 外部组合框_加入项目, , 公开, 给组合框添加项目
    .参数 句柄, 整数型, , 组合框句柄
    .参数 项目文本, 文本型, , 要添加的项目外部
    .参数 重复文本是否不加入, 逻辑型, 可空, 可空，默认为假，加入。真=有重复的不加入
    .局部变量 Ret, 整数型

    Ret ＝ SendMessageA (句柄, #CB_FINDSTRINGEXACT, 0, 取指针文本_ (项目文本))
    .如果真 (Ret ≠ -1 且 重复文本是否不加入)
        返回 ()
    .如果真结束
    SendMessageA (句柄, #CB_ADDSTRING, 0, 取指针文本_ (项目文本))

.子程序 外部组合框_插入项目, , 公开, 指定位置插入项目
    .参数 句柄, 整数型, , 组合框句柄
    .参数 项目索引, 整数型, , 插入位置
    .参数 项目文本, 文本型, , 要插入的项目文本

    SendMessageA (句柄, #CB_INSERTSTRING, 项目索引, 取指针文本_ (项目文本))

.子程序 外部组合框_取项目数, 整数型, 公开, 取回组合框总项目数
    .参数 句柄, 整数型, , 组合框句柄

    返回 (SendMessageA (句柄, #CB_GETCOUNT, 0, 0))

.子程序 外部组合框_取选中项, 整数型, 公开, 取回组合框现行选中项
    .参数 句柄, 整数型, , 组合框句柄

    返回 (SendMessageA (句柄, #CB_GETCURSEL, 0, 0))

.子程序 外部组合框_删除项目, , 公开, 删除指定索引项目
    .参数 句柄, 整数型, , 组合框句柄
    .参数 项目索引, 整数型, , 要删除的项目索引

    SendMessageA (句柄, #CB_DELETESTRING, 项目索引, 0)

.子程序 外部组合框_弹开列表, , 公开, 打开组合框下拉列表
    .参数 句柄, 整数型, , 组合框句柄

    SendMessageA (句柄, #CB_SHOWDROPDOWN, 1, 0)

.子程序 外部组合框_关闭列表, , 公开, 关闭组合框下拉列表
    .参数 句柄, 整数型, , 组合框句柄

    SendMessageA (句柄, #CB_SHOWDROPDOWN, 0, 0)

.子程序 外部组合框_取项目文本, 文本型, 公开, 取回组合框指定索引项目文本
    .参数 句柄, 整数型, , 组合框句柄
    .参数 项目索引, 整数型, , 项目索引，0表示第一行
    .局部变量 文本, 文本型

    文本 ＝ 取空白文本 (SendMessageA (句柄, #CB_GETLBTEXTLEN, 项目索引, 0))
    SendMessageA (句柄, #CB_GETLBTEXT, 项目索引, 取指针文本_ (文本))
    返回 (文本)

.子程序 外部组合框_取项目数值, 整数型, 公开, 取组合框指定项目数值
    .参数 句柄, 整数型, , 组合框句柄
    .参数 项目索引, 整数型, , 0表示第一项

    返回 (SendMessageA (句柄, #CB_GETITEMDATA, 项目索引, 0))

.子程序 外部组合框_置项目数值, , 公开, 置组合框指定项目数值
    .参数 句柄, 整数型, , 组合框句柄
    .参数 项目索引, 整数型, , 0表示第一项
    .参数 数值, 整数型, , 要置的项目数值

    SendMessageA (句柄, #CB_SETITEMDATA, 项目索引, 数值)

.子程序 外部组合框_置现行选中项, , 公开, 选中指定项目
    .参数 句柄, 整数型, , 组合框句柄
    .参数 项目索引, 整数型, , 0表示第一项
    .局部变量 PCOMBOBOXINFO, COMBOBOXINFO
    .局部变量 局_控件ID, 整数型

    SendMessageA (句柄, #CB_SETCURSEL, 项目索引, 0)
    PCOMBOBOXINFO ＝ 外部组合框_取结构信息 (句柄)
    局_控件ID ＝ 窗口_取控件ID (PCOMBOBOXINFO.hwndList)
    SendMessageA (句柄, #WM_COMMAND, 合并整数 (局_控件ID, #CBN_SELCHANGE), PCOMBOBOXINFO.hwndList)

.子程序 外部组合框_保存数据, 逻辑型, 公开, 如果要读入的话,直接 组合框.列表项目=读入文件(C:/001.lbb) 即可
    .参数 组合框句柄, 整数型, , 组合框句柄
    .参数 要保存的位置, 文本型, 可空, 可空  默认将保存在根目录下的data.zbb
    .局部变量 局_文件号, 整数型
    .局部变量 局_项目数, 整数型
    .局部变量 局_计次, 整数型
    .局部变量 局_临时文本, 文本型
    .局部变量 局_临时字节集, 字节集

    .如果真 (是否为空 (要保存的位置))
        要保存的位置 ＝ 取运行目录 () ＋ “\data.zbb”
    .如果真结束
    局_文件号 ＝ 打开内存文件 ()
    局_项目数 ＝ 外部组合框_取项目数 (组合框句柄)
    插入字节集 (局_文件号, 到字节集 (到字节 (局_项目数)) ＋ { 0 })
    .计次循环首 (局_项目数, 局_计次)
        局_临时文本 ＝ 外部组合框_取项目文本 (组合框句柄, 局_计次 － 1)
        插入字节集 (局_文件号, 到字节集 (取文本长度 (局_临时文本)) ＋ 到字节集 (局_临时文本))
    .计次循环尾 ()
    移动读写位置 (局_文件号, #文件首, 0)
    局_临时字节集 ＝ 读入字节集 (局_文件号, 取文件长度 (局_文件号))
    .如果 (写到文件 (要保存的位置, 局_临时字节集))
        关闭文件 (局_文件号)
        返回 (真)
    .否则
        关闭文件 (局_文件号)
    .如果结束
    返回 (假)

.子程序 外部组合框_取结构信息, COMBOBOXINFO, 公开, 返回组合框的结构信息
    .参数 组合框句柄, 整数型
    .局部变量 PCOMBOBOXINFO, COMBOBOXINFO

    PCOMBOBOXINFO.cbSize ＝ 4 × 13
    GetComboBoxInfo (组合框句柄, PCOMBOBOXINFO)
    返回 (PCOMBOBOXINFO)

.子程序 外部组合框_置可见项的最小数, , 公开, 设置组合框下拉列表中可见项的最小数量
    .参数 窗口句柄, 整数型, , 必须勾上Windows通用组件库6.0
    .参数 可见项的最小数, 整数型

    .如果真 (_WIN32_WINNT ＜ #_WIN32_WINNT_VISTA)
        输出调试文本 (#ERROR_NOTVERSION)
        返回 ()
    .如果真结束
    SendMessageA (窗口句柄, #CB_SETMINVISIBLE, 可见项的最小数, #NULL)

.子程序 外部组合框_取可见项的最小数, 整数型, 公开, 获取组合框下拉列表中可见项的最小数目
    .参数 窗口句柄, 整数型, , 必须勾上Windows通用组件库6.0

    .如果真 (_WIN32_WINNT ＜ #_WIN32_WINNT_VISTA)
        输出调试文本 (#ERROR_NOTVERSION)
        返回 (0)
    .如果真结束
    返回 (SendMessageA (窗口句柄, #CB_GETMINVISIBLE, #NULL, #NULL))

.子程序 子程序3, , , ——————————————————————————————————————————————————————————————
    

.子程序 外部超级列表框_保存数据, 逻辑型, 公开, 如果要读入的话,直接 超级列表框.表项=读入文件(C:\001.ebb) 即可
    .参数 超级列表框句柄, 整数型, , 超级列表框句柄
    .参数 要保存的位置, 文本型, , 如: C:\001.ebb 即可
    .参数 列表类型, 整数型, 可空, 默认为"报表列表框"  0=报表列表框 1=大图标列表框
    .参数 不保存指定列的索引, 整数型, 可空, 输入不保存指定列的索引,如:我不保存第1列,直接输入0,因为索引是多0开始的
    .参数 超级列表框类名, 文本型, 可空, 留空默认为 SysListView32
    .局部变量 局_列数, 整数型
    .局部变量 局_字节集, 字节集, , , 超级列表框列数
    .局部变量 局_表项计次, 整数型
    .局部变量 局_列计次, 整数型
    .局部变量 局_文件号, 整数型
    .局部变量 外部超级列表框, 外部超级列表框
    .局部变量 局_文本, 文本型

    .如果真 (是否为空 (超级列表框类名))
        超级列表框类名 ＝ “SysListView32”
    .如果真结束
    外部超级列表框.初始化 (超级列表框句柄, , 超级列表框类名)
    局_文件号 ＝ 打开内存文件 ()
    .判断开始 (列表类型 ＝ 0)
        局_列数 ＝ 外部超级列表框.取列数 () － 1
        .计次循环首 (外部超级列表框.取表项数 (), 局_表项计次)
            局_文本 ＝ 外部超级列表框.取标题 (局_表项计次 － 1, 0)
            插入字节集 (局_文件号, { 0 } ＋ 到字节集 (外部超级列表框.取图片 (局_表项计次 － 1, 0)) ＋ { 255, 255, 255, 255, 0, 0, 0, 0 } ＋ 到字节集 (外部超级列表框.取表项数值 (局_表项计次 － 1)) ＋ 到字节集 (局_文本) ＋ { 0, 0 })
            .如果 (是否为空 (不保存指定列的索引))
                .计次循环首 (局_列数, 局_列计次)
                    局_文本 ＝ 外部超级列表框.取标题 (局_表项计次 － 1, 局_列计次)
                    插入字节集 (局_文件号, { 1 } ＋ 到字节集 (外部超级列表框.取图片 (局_表项计次 － 1, 局_列计次)) ＋ { 255, 255, 255, 255, 0, 0, 0, 0, 0, 0, 0, 0 } ＋ 到字节集 (局_文本) ＋ { 0, 0 })
                .计次循环尾 ()
            .否则
                .计次循环首 (局_列数, 局_列计次)
                    .如果 (不保存指定列的索引 ＝ 局_列计次)
                        局_文本 ＝ “”
                    .否则
                        局_文本 ＝ 外部超级列表框.取标题 (局_表项计次 － 1, 局_列计次)
                    .如果结束
                    插入字节集 (局_文件号, { 1, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 0, 0, 0, 0, 0, 0 } ＋ 到字节集 (局_文本) ＋ { 0, 0 })
                .计次循环尾 ()
            .如果结束
            
        .计次循环尾 ()
    .判断 (列表类型 ＝ 1)
        .计次循环首 (外部超级列表框.取表项数 (), 局_表项计次)
            局_文本 ＝ 外部超级列表框.取标题 (局_表项计次 － 1, 0)
            插入字节集 (局_文件号, { 0 } ＋ 到字节集 (外部超级列表框.取图片 (局_表项计次 － 1, 0)) ＋ { 255, 255, 255, 255, 0, 0, 0, 0 } ＋ 到字节集 (外部超级列表框.取表项数值 (局_表项计次 － 1)) ＋ 到字节集 (局_文本) ＋ { 0, 0 })
        .计次循环尾 ()
    .默认
        
    .判断结束
    移动读写位置 (局_文件号, #文件首, 0)
    局_字节集 ＝ 读入字节集 (局_文件号, 取文件长度 (局_文件号))
    .如果 (写到文件 (要保存的位置, 局_字节集))
        关闭文件 (局_文件号)
        返回 (真)
    .否则
        关闭文件 (局_文件号)
    .如果结束
    返回 (假)
    

.子程序 外部超级列表框_保存数据_NEW, 逻辑型, 公开, BUG命令已弃用,如果要读入的话,直接 超级列表框.表项=读入文件(C:\001.ebb) 即可
    .参数 超级列表框句柄, 整数型, , 超级列表框句柄
    .参数 要保存的位置, 文本型, , 如: C:\001.ebb 即可
    .参数 列表类型, 整数型, 可空, 默认为"报表列表框"  0=报表列表框 1=大图标列表框
    .参数 不保存指定列的索引, 整数型, 可空, 输入不保存指定列的索引,如:我不保存第1列,直接输入0,因为索引是多0开始的
    .参数 超级列表框类名, 文本型, 可空, 留空默认为 SysListView32
    .局部变量 局_列数, 整数型
    .局部变量 局_表项数, 整数型
    .局部变量 局_字节集, 字节集, , , 超级列表框列数
    .局部变量 局_表项计次, 整数型
    .局部变量 局_列计次, 整数型
    .局部变量 局_文件号, 整数型
    .局部变量 外部超级列表框, 外部超级列表框
    .局部变量 局_文本, 文本型

    .局部变量 局_当前行计次, 整数型
    .局部变量 局_表项数值, 整数型

    .如果真 (是否为空 (超级列表框类名))
        超级列表框类名 ＝ “SysListView32”
    .如果真结束
    .如果真 (外部超级列表框.初始化 (超级列表框句柄, , 超级列表框类名) ＝ 假)
        输出调试文本 (“初始化超级列表框失败”)
        返回 (假)
    .如果真结束
    .如果真 (是否为空 (不保存指定列的索引))
        不保存指定列的索引 ＝ -1
    .如果真结束
    局_文件号 ＝ 打开内存文件 ()
    局_列数 ＝ 外部超级列表框.取列数 ()
    局_表项数 ＝ 外部超级列表框.取表项数 ()
    .计次循环首 (局_表项数, 局_表项计次)
        局_当前行计次 ＝ 0
        .计次循环首 (局_列数, 局_列计次)
            .如果 (局_列计次 － 1 ＝ 不保存指定列的索引)
                ' 这里便是不记录的列,直接跳到循环尾部
                到循环尾 ()
            .否则
                
            .如果结束
            
            局_文本 ＝ 外部超级列表框.取标题 (局_表项计次 － 1, 局_列计次 － 1)
            
            .判断开始 (局_当前行计次 ＝ 0)
                .判断开始 (局_列计次 － 1 ＝ 0)
                    局_表项数值 ＝ 外部超级列表框.取表项数值 (局_表项计次 － 1)
                    .判断开始 (局_表项数值 ＝ 0)
                        插入字节集 (局_文件号, { 0 } ＋ 到字节集 (外部超级列表框.取图片 (局_表项计次 － 1, 局_列计次 － 1)) ＋ { 255, 255, 255, 255, 0, 0, 0, 0, 0, 0 } ＋ 到字节集 (局_文本) ＋ { 0, 0 })
                    .默认
                        插入字节集 (局_文件号, { 0 } ＋ 到字节集 (外部超级列表框.取图片 (局_表项计次 － 1, 局_列计次 － 1)) ＋ { 255, 255, 255, 255, 0, 0, 0, 0 } ＋ 到字节集 (局_表项数值) ＋ 到字节集 (局_文本) ＋ { 0, 0 })
                    .判断结束
                    
                    
                .默认
                    插入字节集 (局_文件号, { 0 } ＋ { 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 0, 0 } ＋ 到字节集 (外部超级列表框.取表项数值 (局_表项计次 － 1)) ＋ 到字节集 (局_文本) ＋ { 0, 0 })
                .判断结束
                
            .默认
                插入字节集 (局_文件号, { 1, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 0, 0, 0, 0, 0, 0 } ＋ 到字节集 (局_文本) ＋ { 0, 0 })
            .判断结束
            
            局_当前行计次 ＝ 局_当前行计次 ＋ 1
        .计次循环尾 ()
    .计次循环尾 ()
    移动读写位置 (局_文件号, #文件首, 0)
    局_字节集 ＝ 读入字节集 (局_文件号, 取文件长度 (局_文件号))
    关闭文件 (局_文件号)
    写到文件 (要保存的位置, 局_字节集)
    返回 (真)
    

.子程序 外部超级列表框_上下移动, 文本型, 公开, 成功返回空文本，失败返回错误提示文本
    .参数 超级列表框句柄, 整数型
    .参数 移动方向, 整数型, , 1=上移1行，2=下移1行，3=移到第一行，4=移到最后一行
    .参数 是否移动第1列, 逻辑型, 可空, 假如第1列是序号的话,可以不移动,设置为真将移动,默认为假,不移动
    .局部变量 局_选中项, 整数型
    .局部变量 超级列表框, 外部超级列表框
    .局部变量 局_计次, 整数型
    .局部变量 局_列数, 整数型
    .局部变量 局_现数据, 文本型
    .局部变量 局_现数组, 文本型, , "0"
    .局部变量 局_目标表项, 整数型
    .局部变量 单一选择, 逻辑型

    超级列表框.初始化 (超级列表框句柄, 真)
    单一选择 ＝ 超级列表框.单一选择 ()
    局_选中项 ＝ 超级列表框.取现行选中项 ()
    .判断开始 (局_选中项 ＝ -1)
        窗口_置焦点 (超级列表框句柄)
        返回 (“请选中你要移动的项目”)
    .判断 (局_选中项 ＝ 0 且 移动方向 ＝ 1) ' 上移'
        返回 (“已在最顶部,无法再上移了”)
    .判断 (超级列表框.取表项数 () － 1 ＝ 局_选中项 且 移动方向 ＝ 2) ' 下移
        返回 (“已在最底部,无法再下移”)
    .判断 (局_选中项 ＝ 0 且 移动方向 ＝ 3) ' 移到第一行
        返回 (“已在第一行,无需再移动”)
    .判断 (超级列表框.取表项数 () － 1 ＝ 局_选中项 且 移动方向 ＝ 4) ' 移到最后一行'
        返回 (“已在最后一行,无需再移动”)
    .默认
        
    .判断结束
    .判断开始 (移动方向 ＝ 1)
        局_目标表项 ＝ 局_选中项 － 1
    .判断 (移动方向 ＝ 2)
        局_目标表项 ＝ 局_选中项 ＋ 1
    .默认
        
    .判断结束
    局_列数 ＝ 超级列表框.取列数 ()
    ' -----------------保存选中项数据--------------------------
    .计次循环首 (局_列数, 局_计次)
        加入成员 (局_现数组, 超级列表框.取标题 (局_选中项, 局_计次 － 1)) ' 保存表项文本
    .计次循环尾 ()
    加入成员 (局_现数组, 到文本 (超级列表框.取表项数值 (局_选中项))) ' 保存表项数值
    加入成员 (局_现数组, 到文本 (超级列表框.取图片 (局_选中项, 0))) ' 取图片
    .判断开始 (移动方向 ＝ 1 或 移动方向 ＝ 2)
        超级列表框.置现行选中项 (局_目标表项)
        超级列表框.保证显示 (局_目标表项)
        ' -----------------把目标项的数据置到现行选中项来--------------------------
        .计次循环首 (局_列数, 局_计次)
            .如果真 (是否移动第1列 ＝ 假 且 局_计次 ＝ 1)
                到循环尾 ()
            .如果真结束
            超级列表框.置标题 (局_选中项, 局_计次 － 1, 超级列表框.取标题 (局_目标表项, 局_计次 － 1))
        .计次循环尾 ()
        超级列表框.置表项数值 (局_选中项, 超级列表框.取表项数值 (局_目标表项))
        超级列表框.置图片 (局_选中项, 0, 超级列表框.取图片 (局_目标表项, 0))
        ' -----------------把已保存的数据置到目标项--------------------------
        .计次循环首 (局_列数, 局_计次)
            .如果真 (是否移动第1列 ＝ 假 且 局_计次 ＝ 1)
                到循环尾 ()
            .如果真结束
            超级列表框.置标题 (局_目标表项, 局_计次 － 1, 局_现数组 [局_计次])
        .计次循环尾 ()
        .如果真 (取数组成员数 (局_现数组) ＝ 局_计次 ＋ 1)
            超级列表框.置表项数值 (局_目标表项, 到数值 (局_现数组 [局_计次]))
            超级列表框.置图片 (局_目标表项, 0, 到数值 (局_现数组 [局_计次 ＋ 1]))
        .如果真结束
        
    .判断 (移动方向 ＝ 3 或 移动方向 ＝ 4)
        .判断开始 (移动方向 ＝ 3)
            局_目标表项 ＝ 0
        .判断 (移动方向 ＝ 4)
            局_目标表项 ＝ -1
        .默认
            
        .判断结束
        超级列表框.删除表项 (局_选中项)
        局_目标表项 ＝ 超级列表框.插入表项 (局_目标表项, 局_现数组 [1], 到数值 (局_现数组 [局_列数 ＋ 2]), , , 到数值 (局_现数组 [局_列数 ＋ 1]))
        超级列表框.置现行选中项 (局_目标表项)
        超级列表框.保证显示 (局_目标表项)
        .计次循环首 (局_列数 － 1, 局_计次)
            超级列表框.置标题 (局_目标表项, 局_计次, 局_现数组 [局_计次 ＋ 1])
        .计次循环尾 ()
    .默认
        
    .判断结束
    超级列表框.单一选择 (单一选择)
    返回 (“”)

.子程序 外部超级列表框_上移, , 公开
    .参数 超级列表框句柄, 整数型
    .参数 是否上移第1列, 逻辑型, 可空, 假如第1列是序号的话,可以不上移,设置为真将上移,默认为假,不上移
    .局部变量 局_现在选中项, 整数型
    .局部变量 超级列表框, 外部超级列表框
    .局部变量 局_计次, 整数型
    .局部变量 局_列数, 整数型
    .局部变量 局_现数据, 文本型
    .局部变量 局_现数组, 文本型, , "0"

    超级列表框.初始化 (超级列表框句柄, 真)
    局_现在选中项 ＝ 超级列表框.取现行选中项 ()
    .如果真 (局_现在选中项 ≤ 0)
        返回 ()
    .如果真结束
    局_列数 ＝ 超级列表框.取列数 ()
    超级列表框.置现行选中项 (局_现在选中项 － 1)
    ' -----------------保存选中项数据--------------------------
    .计次循环首 (局_列数, 局_计次)
        加入成员 (局_现数组, 超级列表框.取标题 (局_现在选中项, 局_计次 － 1))
    .计次循环尾 ()
    加入成员 (局_现数组, 到文本 (超级列表框.取表项数值 (局_现在选中项)))
    ' -----------------把前一项的数据置到现行选中项来--------------------------
    .计次循环首 (局_列数, 局_计次)
        .如果真 (是否上移第1列 ＝ 假 且 局_计次 ＝ 1)
            到循环尾 ()
        .如果真结束
        超级列表框.置标题 (局_现在选中项, 局_计次 － 1, 超级列表框.取标题 (局_现在选中项 － 1, 局_计次 － 1))
    .计次循环尾 ()
    ' -----------------把已保存的数据置到前一项--------------------------
    .计次循环首 (局_列数, 局_计次)
        .如果真 (是否上移第1列 ＝ 假 且 局_计次 ＝ 1)
            到循环尾 ()
        .如果真结束
        超级列表框.置标题 (局_现在选中项 － 1, 局_计次 － 1, 局_现数组 [局_计次])
    .计次循环尾 ()

.子程序 外部超级列表框_下移, , 公开
    .参数 超级列表框句柄, 整数型
    .参数 是否下移第1列, 逻辑型, 可空, 假如第1列是序号的话,可以不下移,设置为真将下移,默认为假,不下移
    .局部变量 局_现在选中项, 整数型
    .局部变量 超级列表框, 外部超级列表框
    .局部变量 局_计次, 整数型
    .局部变量 局_列数, 整数型
    .局部变量 局_现数据, 文本型
    .局部变量 局_现数组, 文本型, , "0"

    超级列表框.初始化 (超级列表框句柄, 真)
    局_现在选中项 ＝ 超级列表框.取现行选中项 ()
    .如果真 (局_现在选中项 ＝ -1 或 超级列表框.取表项数 () － 1 ＝ 局_现在选中项)
        返回 ()
    .如果真结束
    局_列数 ＝ 超级列表框.取列数 ()
    超级列表框.置现行选中项 (局_现在选中项 ＋ 1)
    ' -----------------保存选中项数据--------------------------
    .计次循环首 (局_列数, 局_计次)
        加入成员 (局_现数组, 超级列表框.取标题 (局_现在选中项, 局_计次 － 1))
    .计次循环尾 ()
    加入成员 (局_现数组, 到文本 (超级列表框.取表项数值 (局_现在选中项)))
    ' -----------------把后一项的数据置到现行选中项来--------------------------
    .计次循环首 (局_列数, 局_计次)
        .如果真 (是否下移第1列 ＝ 假 且 局_计次 ＝ 1)
            到循环尾 ()
        .如果真结束
        超级列表框.置标题 (局_现在选中项, 局_计次 － 1, 超级列表框.取标题 (局_现在选中项 ＋ 1, 局_计次 － 1))
    .计次循环尾 ()
    ' -----------------把已保存的数据置到后一项--------------------------
    .计次循环首 (局_列数, 局_计次)
        .如果真 (是否下移第1列 ＝ 假 且 局_计次 ＝ 1)
            到循环尾 ()
        .如果真结束
        超级列表框.置标题 (局_现在选中项 ＋ 1, 局_计次 － 1, 局_现数组 [局_计次])
    .计次循环尾 ()

.子程序 外部超级列表框_自动调整列宽, , 公开
    .参数 超级列表框句柄, 整数型
    .参数 要自动调整的列索引, 整数型

    SendMessageA (超级列表框句柄, #LVM_SETCOLUMNWIDTH, 要自动调整的列索引, -1) ' LVM_SETCOLUMNWIDTH|LVSCW_AUTOSIZE

.子程序 外部超级列表框_取鼠标处列坐标, 精易_坐标, 公开
    .参数 超级列表框句柄, 整数型
    .参数 超级列表框行号, 整数型
    .局部变量 局_坐标, 精易_坐标

    SendMessageA (超级列表框句柄, 4096 ＋ 16, 超级列表框行号, 取数据_通用型 (局_坐标))
    返回 (局_坐标)

.子程序 外部超级列表框_取鼠标处行列号, , 公开
    .参数 超级列表框句柄, 整数型
    .参数 超级列表框行号, 整数型, 参考
    .参数 超级列表框列号, 整数型, 参考
    .局部变量 局_表项信息, 表项结构信息
    .局部变量 局_坐标, 精易_坐标

    局_坐标 ＝ 窗口_取坐标 (超级列表框句柄)
    局_表项信息.横向 ＝ 局_坐标.横
    局_表项信息.纵向 ＝ 局_坐标.纵
    SendMessageA (超级列表框句柄, #LVM_SUBITEMHITTEST, 0, 取数据_通用型 (局_表项信息))
    超级列表框行号 ＝ 局_表项信息.行
    超级列表框列号 ＝ 局_表项信息.列

.子程序 子程序5, , , ——————————————————————————————————————
    

.子程序 外部编辑框_复制, , 公开, 通过句柄对指定编辑框进行复制操作
    .参数 编辑框句柄, 整数型
    .局部变量 临时文本, 文本型

    临时文本 ＝ 外部编辑框_取内容 (编辑框句柄)
    剪辑板_置文本 (临时文本)

.子程序 外部编辑框_剪切, , 公开, 通过句柄对指定编辑框进行剪切操作
    .参数 编辑框句柄, 整数型, , 编辑框句柄
    .局部变量 临时文本, 文本型

    临时文本 ＝ 外部编辑框_取内容 (编辑框句柄)
    外部编辑框_置内容 (编辑框句柄, “”)
    剪辑板_置文本 (临时文本)

.子程序 外部编辑框_删除, , 公开, 清空编辑框里的内容
    .参数 编辑框句柄, 整数型, , 编辑框句柄

    外部编辑框_置内容 (编辑框句柄, “”)

.子程序 外部编辑框_撤消, , 公开, 通过句柄对指定编辑框进行撤销操作
    .参数 编辑框句柄, 整数型, , 编辑框句柄

    发送消息整数 (编辑框句柄, 199, 1, 0)

.子程序 外部编辑框_全选, , 公开, 通过句柄对指定编辑框的内容进行全选
    .参数 编辑框句柄, 整数型, , 编辑框句柄

    窗口_置控件焦点 (编辑框句柄)
    外部编辑框_选中按位置 (编辑框句柄, 0, 取文本长度 (外部编辑框_取内容 (编辑框句柄)))

.子程序 外部编辑框_取行数, 整数型, 公开, 通过句柄取指定编辑框的总行数
    .参数 编辑框句柄, 整数型, , 编辑框句柄

    返回 (发送消息整数 (编辑框句柄, 186, 0, 0)) ' #EM_GETLINECOUNT=186

.子程序 外部编辑框_滚动行, , 公开, 上下滚动编辑里面的文本
    .参数 编辑框句柄, 整数型, , 编辑框句柄
    .参数 要滚动的行数, 整数型, , 正数向下滚动，负数向上滚动

    .如果真 (要滚动的行数 ＜ 0)
        发送消息整数 (编辑框句柄, 182, 0, 要滚动的行数)
    .如果真结束
    .如果真 (要滚动的行数 ＞ 0)
        发送消息整数 (编辑框句柄, 182, 1, 要滚动的行数)
    .如果真结束
    

.子程序 外部编辑框_置内容, , 公开, 通过句柄设置编辑框的内容
    .参数 编辑框句柄, 整数型, , 编辑框句柄
    .参数 文本, 文本型, , 要发送的文本

    SendMessageA (编辑框句柄, 12, 0, 取指针文本_ (文本))

.子程序 外部编辑框_取内容, 文本型, 公开, 通过句柄取指定编辑框的内容
    .参数 编辑框句柄, 整数型, , 编辑框句柄
    .局部变量 过度变量, 文本型
    .局部变量 结果文本, 文本型

    返回 (窗口_取控件内容 (编辑框句柄))

.子程序 外部编辑框_置左右边距, , 公开, 通过句柄设置编辑框的左右边距
    .参数 编辑框句柄, 整数型, , 编辑框句柄
    .参数 左边距, 整数型, , 新的距离值
    .参数 右边距, 整数型, , 新的距离值

    发送消息整数 (编辑框句柄, 211, 位或 (1, 2), 合并整数 (左边距, 右边距)) ' #EM_SETMARGINS=211'

.子程序 外部编辑框_置四边距, , 公开, 设置编辑框文字与四周边框的距离
    .参数 编辑框句柄, 整数型, , 直接 编辑框.取窗口句柄() 来获取
    .参数 边距距离, 整数型, , 新的距离值
    .局部变量 rect, 精易_矩形
    .局部变量 zb, 精易_坐标

    GetClientRect (编辑框句柄, rect)
    InflateRect (rect, －边距距离, －边距距离)
    zb.横 ＝ rect.左边
    zb.纵 ＝ rect.顶边
    SendMessageA (编辑框句柄, 179, 0, 取数据_通用型 (zb)) ' #EM_SETRECT=179

.子程序 外部编辑框_转成IE地址框, , 公开, 把普通的编辑框转成IE地址框
    .参数 编辑框句柄, 整数型, , 编辑框句柄

    SHAutoComplete (编辑框句柄, 0)

.子程序 外部编辑框_取消选择, , 公开, 取消编辑框内容的选择
    .参数 编辑框句柄, 整数型, , 编辑框句柄

    外部编辑框_选中按位置 (编辑框句柄, 0, 0)

.子程序 外部编辑框_加入文本, , 公开, 通过句柄给编辑框添加文本
    .参数 编辑框句柄, 整数型, , 编辑框句柄
    .参数 文本内容, 文本型, , 要添加的内容

    外部编辑框_置起始选择位置 (编辑框句柄, 外部编辑框_取文本长度 (编辑框句柄))
    文本_发送 (编辑框句柄, 文本内容)

.子程序 外部编辑框_滚到最后行, , 公开, 让编辑滚动到最后一行
    .参数 编辑框句柄, 整数型, , 编辑框句柄

    发送消息整数 (编辑框句柄, 182, 0, 65535)

.子程序 外部编辑框_选中按内容, , 公开, 选中编辑框指定的内容,如果指定的编辑框内没有指定的内容将不选择；
    .参数 编辑框句柄, 整数型, , 编辑框句柄
    .参数 要选择的内容, 文本型, , 搜索指定编辑框的内容并选择
    .局部变量 临时文本, 文本型
    .局部变量 起始位置, 整数型
    .局部变量 结束位置, 整数型

    临时文本 ＝ 外部编辑框_取内容 (编辑框句柄)
    起始位置 ＝ 寻找文本 (临时文本, 要选择的内容, , 假)
    .如果真 (起始位置 ≥ -1)
        结束位置 ＝ 起始位置 ＋ 取文本长度 (要选择的内容) － 1
        ' 窗口_置控件焦点 (编辑框句柄)
        外部编辑框_选中按位置 (编辑框句柄, 起始位置, 结束位置)
    .如果真结束
    

.子程序 外部编辑框_选中按位置, , 公开, 按起始位置和结束位置选择编辑框内的文本;
    .参数 编辑框句柄, 整数型, , 编辑框句柄
    .参数 开始位置, 整数型, , 开始选择位置,从1开始
    .参数 结束位置, 整数型, , 结束选择位置

    窗口_置控件焦点 (编辑框句柄)
    发送消息整数 (编辑框句柄, 177, 开始位置 － 1, 结束位置)

.子程序 外部编辑框_取光标位置, 整数型, 公开, 取光标编辑框的当前位置
    .参数 编辑框句柄, 整数型, , 编辑框句柄

    返回 (发送消息整数 (编辑框句柄, 176, 0, 0) ％ 65536)

.子程序 外部编辑框_置起始选择位置, , 公开
    .参数 编辑框句柄, 整数型
    .参数 起始选择位置, 整数型

    发送消息整数 (编辑框句柄, 177, 起始选择位置, 起始选择位置)

.子程序 外部编辑框_取文本长度, 整数型
    .参数 编辑框句柄, 整数型

    返回 (发送消息整数 (编辑框句柄, 14, 0, 0))

.子程序 外部编辑框_限制字符数, , 公开, 限制编辑框的输入字符数
    .参数 编辑框句柄, 整数型, , 编辑框句柄
    .参数 欲即制的字符数量, 整数型, , 欲即制的字符数量

    发送消息整数 (编辑框句柄, 197, 欲即制的字符数量, 0)

.子程序 外部编辑框_替换内容, , 公开, 通过句柄对指定编辑框的内容进行替换
    .参数 编辑框句柄, 整数型, , 编辑框句柄
    .参数 欲替换的文本, 文本型, , 欲替换的文本
    .参数 替换成的文本, 文本型, , 替换成的文本
    .参数 起始位置, 整数型, 可空, 留空为从 1 开始
    .参数 替换的次数, 整数型, 可空, 留空为替换1次；
    .参数 是否区分大小写, 逻辑型, 可空, 默认为假，不区分；
    .局部变量 临时文本, 文本型
    .局部变量 计次, 整数型

    临时文本 ＝ 外部编辑框_取内容 (编辑框句柄)
    .如果真 (替换的次数 ＝ 0)
        替换的次数 ＝ 1
    .如果真结束
    .如果真 (起始位置 ＝ 0)
        起始位置 ＝ 1
    .如果真结束
    临时文本 ＝ 子文本替换 (临时文本, 欲替换的文本, 替换成的文本, 起始位置, 替换的次数, 是否区分大小写)
    外部编辑框_置内容 (编辑框句柄, 临时文本)

.子程序 外部编辑框_替换选中内容, , , 替换编辑框内选中的文本
    .参数 编辑框句柄, 整数型, , 编辑框句柄
    .参数 替换成的文本, 文本型, , 替换成的文本

    发送消息文本 (编辑框句柄, 194, 0, 替换成的文本)

.子程序 外部编辑框_设为只读方式, , 公开, 设置编辑框为只读方式
    .参数 编辑框句柄, 整数型
    .参数 类型, 整数型, 可空, 默认为1；1=只读方式；2=普通方式；

    .如果真 (类型 ＝ 0 或 类型 ＝ 1)
        发送消息整数 (编辑框句柄, 207, -1, 0)
    .如果真结束
    .如果真 (类型 ＝ 2)
        发送消息整数 (编辑框句柄, 207, 0, 0)
    .如果真结束
    

.子程序 外部编辑框_设为密码方式, , 公开, 设置编辑框为密码方式
    .参数 编辑框句柄, 整数型
    .参数 类型, 整数型, 可空, 默认为1；1=密码方式；2=普通方式；

    .如果真 (类型 ＝ 0 或 类型 ＝ 1)
        发送消息整数 (编辑框句柄, 204, 1, 0)
    .如果真结束
    .如果真 (类型 ＝ 2)
        发送消息整数 (编辑框句柄, 204, 0, 0)
    .如果真结束
    

.子程序 外部编辑框_取指定行文本, 文本型, 公开, 取回编辑框指定行的文本
    .参数 编辑框句柄, 整数型, , 编辑框句柄
    .参数 行号, 整数型, , 0表示第一行
    .局部变量 文本, 文本型

    文本 ＝ 取空白文本 (255)
    发送消息文本 (编辑框句柄, 196, 行号 － 1, 文本)
    返回 (删尾空 (文本))

.子程序 外部编辑框_取密码框文本, 文本型, 公开
    .参数 编辑框句柄, 整数型
    .局部变量 局_遮盖符, 整数型
    .局部变量 局_缓冲区, 文本型
    .局部变量 局_文本长度

    ' 只要用于外部窗口
    局_遮盖符 ＝ 发送消息整数 (编辑框句柄, 210, 0, 0) ' 取得密码框密码遮盖符代码
    .如果真 (局_遮盖符 ≠ 0) ' 判断编辑框是否密码输入属性
        投递消息整数 (编辑框句柄, 204, 0, 0) ' 去掉密码输入属性
        局_缓冲区 ＝ 取空白文本 (255) ' 分配内存
        发送消息文本 (编辑框句柄, 13, 256, 局_缓冲区) ' 取得编辑框文本
        .如果真 (删首尾空 (局_缓冲区) ＝ “”)
            局_文本长度 ＝ GetWindowTextLengthA (编辑框句柄)
            局_缓冲区 ＝ 取空白文本 (局_文本长度 ＋ 1)
            GetWindowTextA (编辑框句柄, 局_缓冲区, 局_文本长度 ＋ 1)
        .如果真结束
        投递消息整数 (编辑框句柄, 204, 局_遮盖符, 0) ' 恢复编辑框密码输入属性
    .如果真结束
    返回 (删首尾空 (局_缓冲区))

.子程序 外部编辑框_内容是否改变过, 逻辑型, 公开, 判断编辑框的内容从程序创建完毕后是否改变过；真=改变过；假=没改变过；
    .参数 编辑框句柄, 整数型, , 编辑框句柄
    .局部变量 是否已改变过, 整数型

    是否已改变过 ＝ 发送消息整数 (编辑框句柄, 184, 0, 0)
    .如果真 (是否已改变过 ＝ 0)
        返回 (假)
    .如果真结束
    返回 (真)

.子程序 外部编辑框_取指定行文本长度, 整数型, 公开, 取得编辑框指定行文本长度
    .参数 编辑框句柄, 整数型, , 编辑框句柄
    .参数 行号, 整数型, , 0表示第一行

    返回 (SendMessageA (编辑框句柄, 193, SendMessageA (编辑框句柄, 187, 行号, 0), 0))

.子程序 外部编辑框_在光标处加入文本, , 公开
    .参数 编辑框句柄, 整数型
    .参数 要插入的文本, 文本型
    .局部变量 超始位置, 整数型
    .局部变量 结束位置, 整数型
    .局部变量 选择字符数, 整数型
    .局部变量 编辑框光标所在位置, 整数型
    .局部变量 原始文本长度, 整数型

    窗口_置控件焦点 (编辑框句柄)
    SendMessageA (编辑框句柄, 194, 1, 取指针文本_ (要插入的文本))
    ' 编辑框光标所在位置 ＝ 外部编辑框_取光标位置 (编辑框句柄)
    ' 原始文本长度 ＝ 取文本长度 (外部编辑框_取内容 (编辑框句柄))
    ' 外部编辑框_加入文本 (编辑框句柄, 要插入的文本)
    ' 外部编辑框_选中按位置 (编辑框句柄, 编辑框光标所在位置, 编辑框光标所在位置 ＋ 取文本长度 (要插入的文本) ＋ 文本_取出现次数 (要插入的文本, #换行符))

.子程序 外部编辑框_取光标所在行和列号, , 公开, 取得选定字符或光标所在行号和列号
    .参数 句柄, 整数型, , 编辑框句柄
    .参数 行号, 整数型, 参考 可空, 调用前设置一个变量用于装载返回的行号
    .参数 列号, 整数型, 参考 可空, 调用前设置一个变量用于装载返回的列号
    .局部变量 位置1, 整数型

    窗口_置焦点 (句柄)
    ' 位置1 ＝ SendMessageA (句柄, 176, 0, 0) ％ 65536
    ' 行号 ＝ SendMessageA (句柄, 201, 位置1, 0)
    ' 列号 ＝ 位置1 － SendMessageA (句柄, 187, 行号, 0)
    
    SendMessageA (句柄, 176, 取指针整数_ (位置1), 0)
    行号 ＝ SendMessageA (句柄, 201, 位置1, 0)
    列号 ＝ 位置1 － SendMessageA (句柄, 187, 行号, 0)
    行号 ＝ 行号 ＋ 1
    列号 ＝ 列号 ＋ 1

.子程序 外部编辑框_取光标所在行和列号W, , 公开, 取得选定字符或光标所在行号和列号  Unicode编码窗口适用
    .参数 句柄, 整数型, , 编辑框句柄
    .参数 行号, 整数型, 参考 可空, 调用前设置一个变量用于装载返回的行号
    .参数 列号, 整数型, 参考 可空, 调用前设置一个变量用于装载返回的列号
    .局部变量 位置1, 整数型

    窗口_置焦点 (句柄)
    SendMessageW (句柄, 176, 取指针整数_ (位置1), 0)
    行号 ＝ SendMessageW (句柄, 201, 位置1, 0)
    列号 ＝ 位置1 － SendMessageW (句柄, 187, 行号, 0)
    行号 ＝ 行号 ＋ 1
    列号 ＝ 列号 ＋ 1

.子程序 外部选择框_选中, , 公开, 选中外部程序的选择框
    .参数 窗口句柄, 整数型

    ' BM_SETCHECK
    SendMessageA (窗口句柄, 241, 1, 0) ' 1选中

.子程序 外部选择框_取消选中, , 公开, 取消选中外部程序的选择框
    .参数 窗口句柄, 整数型

    ' BM_SETCHECK
    SendMessageA (窗口句柄, 241, 0, 0) ' 0不选中

.子程序 外部选择框_取状态, 逻辑型, 公开, 判断目标选择框是否选中，选中返回真，没选中返回假；
    .参数 窗口句柄, 整数型, , 目标选择框的句柄

    .如果真 (SendMessageA (窗口句柄, 240, 0, 0) ＝ 0)
        返回 (假)
    .如果真结束
    返回 (真)

.子程序 外部选择框_点击, , 公开, 会触发选择框选中与取消选中事件
    .参数 窗口句柄, 整数型
    .局部变量 局_控件ID, 整数型

    局_控件ID ＝ 窗口_取控件ID (窗口句柄)
    SendMessageA (窗口句柄, #WM_COMMAND, 合并整数 (局_控件ID, 0), 窗口句柄)

.子程序 外部单选框_选中, , 公开, 选中外部程序的单选框
    .参数 窗口句柄, 整数型

    SendMessageA (窗口句柄, 241, 1, 0) ' 1选中

.子程序 外部单选框_取消选中, , 公开, 取消选中外部程序的单选框
    .参数 窗口句柄, 整数型

    SendMessageA (窗口句柄, 241, 0, 0) ' 0不选中
    
    

.子程序 外部单选框_取状态, 逻辑型, 公开, 判断目标单选框是否选中，选中返回真，没选中返回假；
    .参数 窗口句柄, 整数型, , 目标单选框的句柄

    .如果真 (SendMessageA (窗口句柄, 240, 0, 0) ＝ 0)
        返回 (假)
    .如果真结束
    返回 (真)

.子程序 树形框_允许拖动, 逻辑型, 公开, 允许鼠标左键拖放操作目标的项
    .参数 树形框句柄, 整数型
    .参数 项拖动处理函数, 整数型, 可空, int TreeMoveProc(HTREEITEM oldhItem, HTREEITEM newhItem);
    .局部变量 himl, 整数型
    .局部变量 oldWndProc, 整数型
    .局部变量 oldTreeProc, 整数型
    .局部变量 hParent, 整数型

    himl ＝ SendMessageW (树形框句柄, #TVM_GETIMAGELIST, #TVSIL_NORMAL, 0)
    .如果真 (himl ＝ #NULL)
        返回 (假)
    .如果真结束
    树形框_禁用拖动 (树形框句柄)
    oldTreeProc ＝ SetWindowLongW (树形框句柄, #GWL_WNDPROC, 到整数 (&Drop_TreeProc))
    SetPropA (树形框句柄, “{59E4C6F6-9104-4D10-9844-7FD21D8283AC}|oldTreeProc”, oldTreeProc)
    SetPropA (树形框句柄, “{59E4C6F6-9104-4D10-9844-7FD21D8283AC}|oldCallProc”, 项拖动处理函数)
    hParent ＝ GetParent (树形框句柄)
    oldWndProc ＝ SetWindowLongW (hParent, #GWL_WNDPROC, 到整数 (&Drop_WndProc))
    SetPropA (hParent, “{59E4C6F6-9104-4D10-9844-7FD21D8283AC}|oldWndProc”, oldWndProc)
    返回 (oldTreeProc ≠ #NULL 且 oldWndProc ≠ #NULL)

.子程序 树形框_禁用拖动, , 公开, 禁用鼠标左键拖放操作目标的项
    .参数 树形框句柄, 整数型
    .局部变量 oldWndProc, 整数型
    .局部变量 oldTreeProc, 整数型
    .局部变量 hParent, 整数型

    oldTreeProc ＝ GetPropA (树形框句柄, “{59E4C6F6-9104-4D10-9844-7FD21D8283AC}|oldTreeProc”)
    .如果真 (oldTreeProc ≠ #NULL)
        SetWindowLongW (树形框句柄, #GWL_WNDPROC, oldTreeProc)
        RemovePropA (树形框句柄, “{59E4C6F6-9104-4D10-9844-7FD21D8283AC}|oldTreeProc”)
    .如果真结束
    RemovePropA (树形框句柄, “{59E4C6F6-9104-4D10-9844-7FD21D8283AC}|oldCallProc”)
    hParent ＝ GetParent (树形框句柄)
    oldWndProc ＝ GetPropA (hParent, “{59E4C6F6-9104-4D10-9844-7FD21D8283AC}|oldWndProc”)
    .如果真 (oldWndProc ≠ #NULL)
        SetWindowLongW (hParent, #GWL_WNDPROC, oldWndProc)
        RemovePropA (hParent, “{59E4C6F6-9104-4D10-9844-7FD21D8283AC}|oldWndProc”)
    .如果真结束
    RemovePropA (树形框句柄, “{59E4C6F6-9104-4D10-9844-7FD21D8283AC}|hItem”)
    RemovePropA (树形框句柄, “{59E4C6F6-9104-4D10-9844-7FD21D8283AC}|DropMove”)

.子程序 Drop_TreeProc, 整数型
    .参数 hTreeCtrl, 整数型
    .参数 uMsg, 整数型
    .参数 wParam, 整数型
    .参数 lParam, 整数型
    .局部变量 oldTreeProc, 整数型
    .局部变量 dwDropMove, 整数型
    .局部变量 x, 整数型
    .局部变量 y, 整数型
    .局部变量 rc, 精易_矩形
    .局部变量 hItem, 整数型
    .局部变量 pht, 整数型

    oldTreeProc ＝ GetPropA (hTreeCtrl, “{59E4C6F6-9104-4D10-9844-7FD21D8283AC}|oldTreeProc”)
    .判断开始 (uMsg ＝ #WM_LBUTTONUP)
        dwDropMove ＝ GetPropA (hTreeCtrl, “{59E4C6F6-9104-4D10-9844-7FD21D8283AC}|DropMove”)
        .如果真 (dwDropMove ＝ 1)
            ImageList_DragLeave (hTreeCtrl)
            ImageList_EndDrag ()
            x ＝ LOWORD (lParam)
            y ＝ HIWORD (lParam)
            GetWindowRect (hTreeCtrl, rc)
            .如果 (x ＜ 0 或 x ＞ rc.右边 － rc.左边 或 y ＜ 0 或 y ＞ rc.底边 － rc.顶边)
                SendMessageW (hTreeCtrl, #TVM_SELECTITEM, #TVGN_DROPHILITE, #NULL)
            .否则
                hItem ＝ SendMessageW (hTreeCtrl, #TVM_GETNEXTITEM, #TVGN_DROPHILITE, #NULL)
                Drop_TreeMove (hTreeCtrl, GetPropA (hTreeCtrl, “{59E4C6F6-9104-4D10-9844-7FD21D8283AC}|hItem”), hItem)
                SendMessageW (hTreeCtrl, #TVM_SELECTITEM, #TVGN_CARET, hItem)
                SendMessageW (hTreeCtrl, #TVM_SELECTITEM, #TVGN_DROPHILITE, #NULL)
            .如果结束
            鼠标_释放 ()
            RemovePropA (hTreeCtrl, “{59E4C6F6-9104-4D10-9844-7FD21D8283AC}|hItem”)
            RemovePropA (hTreeCtrl, “{59E4C6F6-9104-4D10-9844-7FD21D8283AC}|DropMove”)
        .如果真结束
        
    .判断 (uMsg ＝ #WM_MOUSEMOVE)
        dwDropMove ＝ GetPropA (hTreeCtrl, “{59E4C6F6-9104-4D10-9844-7FD21D8283AC}|DropMove”)
        .如果真 (dwDropMove ＝ 1)
            x ＝ LOWORD (lParam)
            y ＝ HIWORD (lParam)
            pht ＝ LocalAlloc (#LMEM_ZEROINIT, 16) ' sizeof(TVHITTESTINFO)
            .如果真 (pht ≠ #NULL)
                ImageList_DragMove (x, y)
                ImageList_DragShowNolock (假)
                __set (pht, 0, x) ' pt => x
                __set (pht, 4, y) ' pt => y
                hItem ＝ SendMessageW (hTreeCtrl, #TVM_HITTEST, 0, pht)
                .如果真 (hItem ≠ #NULL)
                    SendMessageW (hTreeCtrl, #TVM_SELECTITEM, #TVGN_DROPHILITE, hItem)
                .如果真结束
                ImageList_DragShowNolock (真)
                LocalFree (pht)
            .如果真结束
            
        .如果真结束
        
    .默认
        
    .判断结束
    返回 (CallWindowProcW (oldTreeProc, hTreeCtrl, uMsg, wParam, lParam))

.子程序 Drop_WndProc, 整数型
    .参数 hWnd, 整数型
    .参数 uMsg, 整数型
    .参数 wParam, 整数型
    .参数 lParam, 整数型
    .局部变量 oldWndProc, 整数型
    .局部变量 oldTreeProc, 整数型
    .局部变量 hTreeCtrl, 整数型
    .局部变量 code, 整数型
    .局部变量 hItem, 整数型
    .局部变量 himl, 整数型
    .局部变量 x, 整数型
    .局部变量 y, 整数型

    oldWndProc ＝ GetPropA (hWnd, “{59E4C6F6-9104-4D10-9844-7FD21D8283AC}|oldWndProc”)
    .如果真 (uMsg ＝ #WM_NOTIFY)
        code ＝ __get (lParam, 8)
        .如果真 (code ＝ #TVN_BEGINDRAGA 或 code ＝ #TVN_BEGINDRAGW) ' NMTREEVIEWA
            hTreeCtrl ＝ __get (lParam, 0) ' hwndFrom
            oldTreeProc ＝ GetPropA (hTreeCtrl, “{59E4C6F6-9104-4D10-9844-7FD21D8283AC}|oldTreeProc”)
            .如果真 (oldTreeProc ≠ #NULL)
                hItem ＝ __get (lParam, 60) ' itemNew => hItem
                SetPropA (hTreeCtrl, “{59E4C6F6-9104-4D10-9844-7FD21D8283AC}|hItem”, hItem)
                himl ＝ SendMessageW (hTreeCtrl, #TVM_CREATEDRAGIMAGE, 0, hItem)
                ImageList_BeginDrag (himl, 0, 0, 0)
                x ＝ __get (lParam, 96) ' ptDrag => x
                y ＝ __get (lParam, 100) ' ptDrag => y
                ImageList_DragEnter (hTreeCtrl, x, y)
                SendMessageW (hTreeCtrl, #TVM_SELECTITEM, #TVGN_CARET, hItem)
                鼠标_捕获 (hTreeCtrl)
                SetPropA (hTreeCtrl, “{59E4C6F6-9104-4D10-9844-7FD21D8283AC}|DropMove”, 1)
            .如果真结束
            
        .如果真结束
        
    .如果真结束
    返回 (CallWindowProcW (oldWndProc, hWnd, uMsg, wParam, lParam))

.子程序 Drop_TreeMove
    .参数 hTreeCtrl, 整数型
    .参数 oldhItem, 整数型
    .参数 newhItem, 整数型
    .局部变量 oldCallProc, 整数型
    .局部变量 hParent, 整数型
    .局部变量 isPeer, 逻辑型
    .局部变量 dwSize, 整数型
    .局部变量 pis, 整数型
    .局部变量 aryhItem, 整数型, , "0"
    .局部变量 hItem, 整数型
    .局部变量 dwParent, 整数型
    .局部变量 dwSub, 整数型
    .局部变量 dwCount, 整数型
    .局部变量 aryhInsert, 整数型, , "0"
    .局部变量 temphItem, 整数型
    .局部变量 i, 整数型

    oldCallProc ＝ GetPropA (hTreeCtrl, “{59E4C6F6-9104-4D10-9844-7FD21D8283AC}|oldCallProc”)
    .如果真 (oldCallProc ≠ #NULL)
        .如果真 (调用子程序_ (oldCallProc, oldhItem, newhItem, , , , , , , , , , , , , ) ≠ 0)
            返回 ()
        .如果真结束
        
    .如果真结束
    
    hParent ＝ newhItem
    .判断循环首 (hParent ≠ #NULL)
        .如果真 (hParent ＝ oldhItem)
            isPeer ＝ 真
            跳出循环 ()
        .如果真结束
        hParent ＝ SendMessageW (hTreeCtrl, #TVM_GETNEXTITEM, #TVGN_PARENT, hParent)
    .判断循环尾 ()
    .如果真 (isPeer)
        返回 ()
    .如果真结束
    
    hParent ＝ SendMessageW (hTreeCtrl, #TVM_GETNEXTITEM, #TVGN_PARENT, oldhItem)
    .如果真 (hParent ＝ newhItem)
        返回 ()
    .如果真结束
    
    dwSize ＝ 68 ＋ 2 × #MAX_PATH ' sizeof(TVINSERTSTRUCTW) + sizeof(TCHAR) * MAX_PATH
    pis ＝ LocalAlloc (#LMEM_ZEROINIT, dwSize)
    .如果真 (pis ＝ #NULL)
        返回 ()
    .如果真结束
    
    __set (pis, 8, #TVIF_CHILDREN) ' mask
    __set (pis, 12, oldhItem) ' hItem
    SendMessageW (hTreeCtrl, #TVM_GETITEMW, 0, pis ＋ 8)
    .如果 (__get (pis, 40) ＝ 0) ' cChildren
        加入成员 (aryhItem, oldhItem)
    .否则
        isPeer ＝ 假
        temphItem ＝ oldhItem
        .判断循环首 (temphItem ≠ #NULL 且 isPeer ＝ 假)
            加入成员 (aryhItem, temphItem)
            hItem ＝ temphItem
            temphItem ＝ SendMessageW (hTreeCtrl, #TVM_GETNEXTITEM, #TVGN_CHILD, temphItem)
            .如果真 (temphItem ＝ #NULL)
                temphItem ＝ SendMessageW (hTreeCtrl, #TVM_GETNEXTITEM, #TVGN_NEXT, hItem)
                .判断循环首 (temphItem ＝ #NULL)
                    hParent ＝ SendMessageW (hTreeCtrl, #TVM_GETNEXTITEM, #TVGN_PARENT, hItem)
                    .如果真 (hParent ＝ oldhItem)
                        isPeer ＝ 真
                        跳出循环 ()
                    .如果真结束
                    hItem ＝ hParent
                    temphItem ＝ SendMessageW (hTreeCtrl, #TVM_GETNEXTITEM, #TVGN_NEXT, hParent)
                .判断循环尾 ()
            .如果真结束
            
        .判断循环尾 ()
    .如果结束
    
    dwParent ＝ Drop_GetLayer (hTreeCtrl, oldhItem)
    dwCount ＝ 取数组成员数 (aryhItem)
    SendMessageW (hTreeCtrl, #WM_SETREDRAW, 0, 0) ' 禁止重画
    .计次循环首 (dwCount, i)
        dwSub ＝ Drop_GetLayer (hTreeCtrl, aryhItem [i]) － dwParent
        memset (pis, 0, dwSize)
        __set (pis, 8, 位或 (#TVIF_HANDLE, #TVIF_IMAGE, #TVIF_INTEGRAL, #TVIF_PARAM, #TVIF_SELECTEDIMAGE, #TVIF_STATE, #TVIF_TEXT)) ' mask
        __set (pis, 12, aryhItem [i]) ' hItem
        __set (pis, 24, pis ＋ 68) ' pszText
        __set (pis, 28, #MAX_PATH) ' cchTextMax
        SendMessageW (hTreeCtrl, #TVM_GETITEMW, 0, pis ＋ 8)
        __set (pis, 0, newhItem) ' hParent
        .如果真 (dwSub ＞ 0 且 dwSub ≤ 取数组成员数 (aryhInsert))
            __set (pis, 0, aryhInsert [dwSub]) ' hParent
        .如果真结束
        __set (pis, 4, #TVI_LAST) ' hInsertAfter
        __set (pis, 8, 位或 (#TVIF_IMAGE, #TVIF_INTEGRAL, #TVIF_PARAM, #TVIF_SELECTEDIMAGE, #TVIF_STATE, #TVIF_TEXT)) ' mask
        __set (pis, 12, newhItem) ' hItem
        hItem ＝ SendMessageW (hTreeCtrl, #TVM_INSERTITEMW, 0, pis)
        .判断开始 (dwSub ＝ 取数组成员数 (aryhInsert))
            加入成员 (aryhInsert, hItem)
        .判断 (dwSub ＞ 0 且 dwSub ＋ 1 ≤ 取数组成员数 (aryhInsert))
            aryhInsert [dwSub ＋ 1] ＝ hItem
        .默认
            
        .判断结束
        
    .计次循环尾 ()
    LocalFree (pis)
    
    SendMessageW (hTreeCtrl, #TVM_DELETEITEM, 0, oldhItem)
    SendMessageW (hTreeCtrl, #WM_SETREDRAW, 1, 0) ' 允许重画

.子程序 Drop_GetLayer, 整数型
    .参数 hTreeCtrl, 整数型
    .参数 hItem, 整数型
    .局部变量 dwIndent, 整数型

    .判断循环首 (hItem ≠ #NULL)
        hItem ＝ SendMessageW (hTreeCtrl, #TVM_GETNEXTITEM, #TVGN_PARENT, hItem)
        递增 (dwIndent)
    .判断循环尾 ()
    返回 (dwIndent)

.版本 2

.程序集 HashMap_StrInt, , 公开, 源码收录自【https://bbs.125.la/forum.php?mod=viewthread&tid=14088175】
.程序集变量 成员_散列表, HashMap_Str_Str_节点型, , "0"
.程序集变量 成员_扩容因数, 双精度小数型
.程序集变量 成员_扩容阈值, 整数型
.程序集变量 成员_已用数据表链总数, 整数型
.程序集变量 成员_键总数量, 整数型
.程序集变量 成员_重新索引次数, 整数型

.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
    初始化 ()

.子程序 初始化, , 公开
    初始设置 (16, 0.75)

.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
    

.子程序 初始设置, 逻辑型, 公开, 默认初始容量为16,扩容因数为0.75
    .参数 初始容量大小, 整数型, 可空, 留空表示不改变,注意 改变初始容量大小会清除已有数据
    .参数 扩容因数, 双精度小数型, 可空, 留空表示不改变,注意 必须小于1且大于0
    .局部变量 初始容量, 整数型

    .如果真 (是否为空 (初始容量大小) ＝ 假)
        .如果真 (初始容量大小 ＜ 0)
            返回 (假)
        .如果真结束
        初始容量 ＝ 1
        .判断循环首 (初始容量 ＜ 初始容量大小)
            初始容量 ＝ 左移 (初始容量, 1)
        .判断循环尾 ()
        重定义数组 (成员_散列表, 假, 初始容量)
        成员_已用数据表链总数 ＝ 0
        成员_键总数量 ＝ 0
        成员_重新索引次数 ＝ 0
        更新阈值 ()
    .如果真结束
    .如果真 (是否为空 (扩容因数) ＝ 假)
        .如果真 (扩容因数 ≤ 0 或 扩容因数 ＞ 1)
            返回 (假)
        .如果真结束
        成员_扩容因数 ＝ 扩容因数
        更新阈值 ()
    .如果真结束
    返回 (真)

.子程序 加入, 逻辑型, 公开, 添加一个键值对
    .参数 键, 文本型, 可空
    .参数 值, 整数型, 可空
    .参数 禁止覆盖相同键, 逻辑型, 可空, 默认为假,如果为真,则已存在该键时不覆盖原值并返回假,否则覆盖原键值
    .局部变量 节点索引, 整数型
    .局部变量 新的键值, HashMap_Str_Str_键值型
    .局部变量 i, 整数型

    新的键值.键 ＝ 键
    新的键值.值 ＝ 值
    新的键值.散列值 ＝ 计算散列值 (键)
    .如果真 (成员_已用数据表链总数 ＋ 1 ≥ 成员_扩容阈值)
        重新索引 (取数组成员数 (成员_散列表) × 2)
    .如果真结束
    .如果真 (取数组成员数 (成员_散列表) ＝ 0)
        初始设置 (16, )
    .如果真结束
    节点索引 ＝ 计算索引 (新的键值.散列值, 取数组成员数 (成员_散列表))
    .变量循环首 (2, 取数组成员数 (成员_散列表 [节点索引].键值链数组), 1, i)
        .如果真 (成员_散列表 [节点索引].键值链数组 [i].键 ＝ 新的键值.键)
            .如果真 (禁止覆盖相同键)
                返回 (假)
            .如果真结束
            成员_散列表 [节点索引].键值链数组 [i].值 ＝ 新的键值.值
            返回 (真)
        .如果真结束
        
    .变量循环尾 ()
    成员_键总数量 ＝ 成员_键总数量 ＋ 1
    加入成员 (成员_散列表 [节点索引].键值链数组, 新的键值)
    成员_已用数据表链总数 ＝ 成员_已用数据表链总数 ＋ 1
    返回 (真)

.子程序 取值, 整数型, 公开, 取指定键的值
    .参数 键, 文本型
    .参数 返回_键是否存在, 逻辑型, 参考 可空
    .局部变量 节点索引, 整数型
    .局部变量 i, 整数型
    .局部变量 len, 整数型

    返回_键是否存在 ＝ 假
    len ＝ 取数组成员数 (成员_散列表)
    
    .如果真 (len ＝ 0)
        返回_键是否存在 ＝ 假
        返回 (0)
    .如果真结束
    
    节点索引 ＝ 计算索引 (计算散列值 (键), len)
    .变量循环首 (2, 取数组成员数 (成员_散列表 [节点索引].键值链数组), 1, i)
        .如果真 (成员_散列表 [节点索引].键值链数组 [i].键 ＝ 键)
            返回_键是否存在 ＝ 真
            返回 (成员_散列表 [节点索引].键值链数组 [i].值)
        .如果真结束
        
    .变量循环尾 ()
    返回 (0)

.子程序 删除, 逻辑型, 公开, 删除指定键的键值对
    .参数 键, 文本型
    .局部变量 节点索引, 整数型
    .局部变量 i, 整数型

    节点索引 ＝ 计算索引 (计算散列值 (键), 取数组成员数 (成员_散列表))
    .变量循环首 (2, 取数组成员数 (成员_散列表 [节点索引].键值链数组), 1, i)
        .如果真 (成员_散列表 [节点索引].键值链数组 [i].键 ＝ 键)
            删除成员 (成员_散列表 [节点索引].键值链数组, i, )
            成员_键总数量 ＝ 成员_键总数量 － 1
            .如果真 (取数组成员数 (成员_散列表 [节点索引].键值链数组) ＝ 1)
                成员_已用数据表链总数 ＝ 成员_已用数据表链总数 － 1
            .如果真结束
            返回 (真)
        .如果真结束
        
    .变量循环尾 ()
    返回 (假)

.子程序 计算散列值, 整数型, , java HashCode算法
    .参数 文本数据, 文本型
    .局部变量 i, 整数型
    .局部变量 h, 整数型
    .局部变量 文本字节集, 字节集

    文本字节集 ＝ 到字节集 (文本数据)
    .变量循环首 (1, 取字节集长度 (文本字节集), 1, i)
        h ＝ 31 × h ＋ 文本字节集 [i]
    .变量循环尾 ()
    返回 (h)
    ' 1.可以节省内存，因为hash值在相邻，这样hash的数组可以比较小。比如当用HashMap，以String为key时。
    
    ' 2.hash值相邻，如果存放在容器，比好HashSet，HashMap中时，实际存放的内存的位置也相邻，则存取的效率也高。（程序局部性原理）
    
    
    ' 以31为倍数，原因了31的二进制全是1，则可以有效地离散数据。
    

.子程序 更新阈值
    成员_扩容阈值 ＝ 成员_扩容因数 × 取数组成员数 (成员_散列表)
    

.子程序 计算索引, 整数型
    .参数 h, 整数型
    .参数 length, 整数型

    返回 (取绝对值 (h ％ length) ＋ 1)
    

.子程序 重新索引
    .参数 新表尺寸, 整数型
    .局部变量 原数据表, HashMap_Str_Str_节点型, , "0"
    .局部变量 新索引值, 整数型
    .局部变量 i, 整数型
    .局部变量 i2, 整数型
    .局部变量 x, 整数型
    .局部变量 t1, 整数型

    复制数组 (原数据表, 成员_散列表)
    重定义数组 (成员_散列表, 假, 新表尺寸)
    更新阈值 ()
    .变量循环首 (1, 取数组成员数 (原数据表), 1, i)
        .变量循环首 (2, 取数组成员数 (原数据表 [i].键值链数组), 1, i2)
            新索引值 ＝ 计算索引 (原数据表 [i].键值链数组 [i2].散列值, 新表尺寸)
            .如果真 (取数组成员数 (成员_散列表 [新索引值].键值链数组) ＝ 1)
                x ＝ x ＋ 1
            .如果真结束
            加入成员 (成员_散列表 [新索引值].键值链数组, 原数据表 [i].键值链数组 [i2])
        .变量循环尾 ()
    .变量循环尾 ()
    成员_已用数据表链总数 ＝ x
    成员_重新索引次数 ＝ 成员_重新索引次数 ＋ 1
    

.版本 2

.程序集 普通填表, , 公开
.程序集变量 集_网页文档, 对象
.程序集变量 集_窗口句柄, 整数型

.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
    线程_初始化COM库 ()

.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
    线程_取消COM库 ()

.子程序 初始化, 逻辑型, 公开, 使用网页填表时必须选初始化。成功返回真，失败返回假。
    .参数 浏览器句柄, 整数型, , 提供浏览器窗口句柄

    .如果真 (窗口_句柄是否有效 (浏览器句柄) ＝ 假)
        返回 (假)
    .如果真结束
    集_窗口句柄 ＝ 浏览器句柄
    网页_取网页文档对象 (集_窗口句柄, 集_网页文档)
    返回 (集_网页文档.是否为空 () ＝ 假)

.子程序 网页_取文档对象, 对象, 公开, 请先初始化后,再使用本命令
    返回 (集_网页文档)

.子程序 销毁, , 公开
    集_网页文档.清除 ()

.子程序 网页_取IE窗口句柄, 整数型, 公开
    .参数 窗口句柄, 整数型
    .局部变量 局_窗口类名, 文本型
    .局部变量 局_窗口句柄, 整数型
    .局部变量 局_x

    局_窗口句柄 ＝ FindWindowExA (窗口句柄, 0, 0, 0)
    .判断循环首 (局_窗口句柄 ＞ 0)
        局_窗口类名 ＝ 窗口_取类名 (局_窗口句柄)
        .如果真 (局_窗口类名 ＝ “Internet Explorer_Server”)
            返回 (局_窗口句柄)
        .如果真结束
        局_x ＝ 网页_取IE窗口句柄 (局_窗口句柄)
        .如果真 (局_x ≠ 0)
            返回 (局_x)
        .如果真结束
        局_窗口句柄 ＝ FindWindowExA (窗口句柄, 局_窗口句柄, 0, 0)
        处理事件 ()
    .判断循环尾 ()
    返回 (0)

.子程序 网页_取网页文档对象, 逻辑型, 公开, 通过浏览器句柄取网页文档对象
    .参数 浏览器句柄, 整数型
    .参数 文档对象, 对象, 参考, 返回的网页文档对象，只能提供变量
    .局部变量 窗口类名, 文本型
    .局部变量 资源编号, 整数型
    .局部变量 结果, 整数型
    .局部变量 消息值, 整数型
    .局部变量 对象, 对象
    .局部变量 是否IES窗口, 逻辑型
    .局部变量 子窗口句柄, 整数型
    .局部变量 权限文件名, 文本型

    窗口类名 ＝ 窗口_取类名 (浏览器句柄)
    .如果真 (窗口类名 ≠ “Internet Explorer_Server”)
        浏览器句柄 ＝ 网页_取IE窗口句柄 (浏览器句柄)
        .如果真 (浏览器句柄 ＝ 0)
            返回 (假)
        .如果真结束
        
    .如果真结束
    消息值 ＝ RegisterWindowMessageA (“WM_HTML_GETOBJECT”)
    SendMessageTimeoutA (浏览器句柄, 消息值, 0, 0, 2, 1000, 资源编号)
    结果 ＝ ObjectFromLresult (资源编号, { 32, 197, 111, 98, 30, 164, 207, 17, 167, 49, 0, 160, 201, 8, 38, 55 }, 0, 文档对象)
    .如果真 (结果 ＝ 0)
        返回 (真) ' 获取成功
    .如果真结束
    返回 (假)

.子程序 控件_所有属性操作读, 整数型, 公开, 取指定控件的各种属性。成功返回指定控件的所有数量，失败返回0。
    .参数 大类型, 整数型, 可空, 0=单选框，1=复选框，2=文本框，3=多行文本框，4=按钮，5=高级按钮，6=图片按钮，7=图片，8=链接。9=title链接。10=组合框。11=DIV。12=ULLI。13=SPAN。
    .参数 元素类型, 文本型, 可空, 如：input,textarea,button
    .参数 控件类型, 文本型, 可空, 如：text|password|file分隔
    .参数 控件标题, 文本型, 参考 可空 数组
    .参数 控件内容, 文本型, 参考 可空 数组
    .参数 控件名称, 文本型, 参考 可空 数组
    .参数 控件ID, 文本型, 参考 可空 数组
    .参数 所属类型, 文本型, 参考 可空 数组
    .参数 链接地址, 文本型, 参考 可空 数组
    .参数 图片地址, 文本型, 参考 可空 数组
    .参数 图片宽度, 文本型, 参考 可空 数组
    .参数 图片高度, 文本型, 参考 可空 数组
    .参数 选中状态, 文本型, 参考 可空 数组
    .参数 引用代码, 文本型, 参考 可空 数组
    .参数 是否标记, 逻辑型, 可空
    .参数 title链接标题, 文本型, 参考 可空 数组
    .参数 title链接地址, 文本型, 参考 可空 数组
    .参数 返回的对象, 对象, 参考 可空 数组
    .局部变量 二级计次, 整数型
    .局部变量 对象, 对象
    .局部变量 临时对象, 对象
    .局部变量 临时类型, 文本型
    .局部变量 控件类型数组, 文本型, , "0"
    .局部变量 控件类型数量, 整数型
    .局部变量 元素类型数组, 文本型, , "0"
    .局部变量 元素类型数量, 整数型
    .局部变量 元素计次, 整数型
    .局部变量 控件数量, 整数型
    .局部变量 title类型, 文本型

    元素类型数组 ＝ 分割文本 (元素类型, “|”, ) ' 元素类型
    元素类型数量 ＝ 取数组成员数 (元素类型数组) ' 元素类型
    控件类型数组 ＝ 分割文本 (控件类型, “|”, ) ' 控件类型
    控件类型数量 ＝ 取数组成员数 (控件类型数组) ' 控件类型
    .如果真 (控件类型数量 ＞ 0)
        .计次循环首 (元素类型数量, 元素计次)
            ' ******************************************************************************SPAN
            .如果真 (大类型 ＝ 13)
                对象 ＝ 集_网页文档.读对象型属性 (“body”, ).读对象型属性 (“all”, ) ' 取得第一个框架
                临时对象 ＝ 对象.对象型方法 (“tags”, “span”)
                .计次循环首 (临时对象.读数值属性 (“length”, ), 二级计次)
                    加入成员 (所属类型, 临时对象.读对象型属性 (“item”, 二级计次 － 1).读文本属性 (“tagName”, ))
                    加入成员 (控件标题, 临时对象.读对象型属性 (“item”, 二级计次 － 1).读文本属性 (“innerText”, ))
                    加入成员 (控件名称, 临时对象.读对象型属性 (“item”, 二级计次 － 1).读文本属性 (“name”, ))
                    加入成员 (控件ID, 临时对象.读对象型属性 (“item”, 二级计次 － 1).读文本属性 (“ID”, ))
                    加入成员 (控件内容, 临时对象.读对象型属性 (“item”, 二级计次 － 1).读文本属性 (“title”, ))
                    title类型 ＝ 子文本替换 (临时对象.读对象型属性 (“item”, 二级计次 － 1).读文本属性 (“outerHTML”, ), #换行符, , , , 假)
                    加入成员 (引用代码, title类型)
                    加入成员 (返回的对象, 临时对象.读对象型属性 (“item”, 二级计次 － 1))
                .计次循环尾 ()
                到循环尾 ()
            .如果真结束
            ' ******************************************************************************UL
            .如果真 (大类型 ＝ 12)
                对象 ＝ 集_网页文档.读对象型属性 (“body”, ).读对象型属性 (“all”, ) ' 取得第一个框架
                临时对象 ＝ 对象.对象型方法 (“tags”, “li”)
                .计次循环首 (临时对象.读数值属性 (“length”, ), 二级计次)
                    加入成员 (控件标题, 临时对象.读对象型属性 (“item”, 二级计次 － 1).读文本属性 (“innerText”, ))
                    加入成员 (控件ID, 临时对象.读对象型属性 (“item”, 二级计次 － 1).读文本属性 (“ID”, ))
                    title类型 ＝ 子文本替换 (临时对象.读对象型属性 (“item”, 二级计次 － 1).读文本属性 (“outerHTML”, ), #换行符, , , , 假)
                    加入成员 (引用代码, title类型)
                .计次循环尾 ()
                到循环尾 ()
            .如果真结束
            ' ******************************************************************************
            对象 ＝ 集_网页文档.对象型方法 (“getElementsByTagName”, 元素类型数组 [元素计次]) ' 取得第一个框架
            .计次循环首 (对象.读数值属性 (“length”, ), 二级计次)
                临时对象 ＝ 对象.对象型方法 (“item”, 二级计次 － 1)
                ' ******************************************************************************
                .如果真 (大类型 ＝ 9) ' title链接
                    title类型 ＝ 临时对象.读文本属性 (“title”, )
                    .如果真 (title类型 ≠ “”)
                        加入成员 (所属类型, 临时对象.读文本属性 (“tagname”, ))
                        加入成员 (title链接标题, title类型)
                        加入成员 (title链接地址, 临时对象.读文本属性 (“href”, ))
                        加入成员 (引用代码, 临时对象.读文本属性 (“outerHTML”, ))
                        加入成员 (返回的对象, 临时对象)
                    .如果真结束
                    到循环尾 ()
                .如果真结束
                ' ******************************************************************************
                .如果 (元素类型数组 [元素计次] ＝ “a” 或 元素类型数组 [元素计次] ＝ “cite” 或 元素类型数组 [元素计次] ＝ “img” 或 元素类型数组 [元素计次] ＝ “div”)
                    临时类型 ＝ 到小写 (临时对象.读文本属性 (“tagName”, ))
                .否则
                    临时类型 ＝ 到小写 (临时对象.读文本属性 (“type”, ))
                .如果结束
                ' ******************************************************************************
                .计次循环首 (控件类型数量, 二级计次)
                    .判断开始 (大类型 ＝ 0) ' 单选框
                        .如果真 (临时类型 ＝ 控件类型数组 [二级计次])
                            控件数量 ＝ 控件数量 ＋ 1
                            .如果真 (是否标记)
                                临时对象.写属性 (“name”, “单选框” ＋ 到文本 (控件数量))
                            .如果真结束
                            加入成员 (所属类型, 临时对象.读文本属性 (“type”, ))
                            加入成员 (控件内容, 临时对象.读文本属性 (“value”, ))
                            加入成员 (控件名称, 临时对象.读文本属性 (“name”, ))
                            加入成员 (控件ID, 临时对象.读文本属性 (“ID”, ))
                            加入成员 (选中状态, 到文本 (临时对象.读属性 (“checked”, ).取数值 () ＝ -1))
                            加入成员 (引用代码, 临时对象.读文本属性 (“outerHTML”, ))
                            加入成员 (返回的对象, 临时对象)
                        .如果真结束
                        
                    .判断 (大类型 ＝ 1) ' 复选框
                        .如果真 (临时类型 ＝ 控件类型数组 [二级计次])
                            控件数量 ＝ 控件数量 ＋ 1
                            .如果真 (是否标记)
                                临时对象.写属性 (“name”, “复选框” ＋ 到文本 (控件数量))
                            .如果真结束
                            加入成员 (所属类型, 临时对象.读文本属性 (“type”, ))
                            加入成员 (控件内容, 临时对象.读文本属性 (“value”, ))
                            加入成员 (控件名称, 临时对象.读文本属性 (“name”, ))
                            加入成员 (控件ID, 临时对象.读文本属性 (“ID”, ))
                            加入成员 (选中状态, 到文本 (临时对象.读属性 (“checked”, ).取数值 () ＝ -1))
                            加入成员 (引用代码, 临时对象.读文本属性 (“outerHTML”, ))
                            加入成员 (返回的对象, 临时对象)
                        .如果真结束
                        
                    .判断 (大类型 ＝ 2) ' 文本框
                        .如果真 (临时类型 ＝ 控件类型数组 [二级计次])
                            控件数量 ＝ 控件数量 ＋ 1
                            .如果真 (是否标记)
                                临时对象.写属性 (“value”, “文本框” ＋ 到文本 (控件数量))
                            .如果真结束
                            加入成员 (所属类型, 临时对象.读文本属性 (“type”, ))
                            加入成员 (控件内容, 临时对象.读文本属性 (“value”, ))
                            加入成员 (控件名称, 临时对象.读文本属性 (“name”, ))
                            加入成员 (控件ID, 临时对象.读文本属性 (“ID”, ))
                            加入成员 (引用代码, 临时对象.读文本属性 (“outerHTML”, ))
                            加入成员 (返回的对象, 临时对象)
                        .如果真结束
                        
                    .判断 (大类型 ＝ 3) ' 多行文本框
                        .如果真 (临时类型 ＝ 控件类型数组 [二级计次])
                            控件数量 ＝ 控件数量 ＋ 1
                            .如果真 (是否标记)
                                临时对象.写属性 (“value”, “多行文本框” ＋ 到文本 (控件数量))
                            .如果真结束
                            加入成员 (所属类型, 临时对象.读文本属性 (“type”, ))
                            加入成员 (控件内容, 临时对象.读文本属性 (“value”, ))
                            加入成员 (控件名称, 临时对象.读文本属性 (“name”, ))
                            加入成员 (控件ID, 临时对象.读文本属性 (“ID”, ))
                            加入成员 (引用代码, 临时对象.读文本属性 (“outerHTML”, ))
                            加入成员 (返回的对象, 临时对象)
                        .如果真结束
                        
                    .判断 (大类型 ＝ 4) ' 按钮
                        .如果真 (临时类型 ＝ 控件类型数组 [二级计次])
                            控件数量 ＝ 控件数量 ＋ 1
                            .如果真 (是否标记)
                                临时对象.写属性 (“value”, “按钮” ＋ 到文本 (控件数量))
                            .如果真结束
                            加入成员 (所属类型, 临时对象.读文本属性 (“tagName”, ))
                            加入成员 (控件内容, 临时对象.读文本属性 (“value”, ))
                            加入成员 (控件名称, 临时对象.读文本属性 (“name”, ))
                            加入成员 (控件ID, 临时对象.读文本属性 (“ID”, ))
                            加入成员 (引用代码, 临时对象.读文本属性 (“outerHTML”, ))
                            加入成员 (返回的对象, 临时对象)
                        .如果真结束
                        
                    .判断 (大类型 ＝ 5) ' 高级按钮
                        .如果真 (临时类型 ＝ 控件类型数组 [二级计次])
                            控件数量 ＝ 控件数量 ＋ 1
                            .如果真 (是否标记)
                                临时对象.写属性 (“innertext”, “高级按钮” ＋ 到文本 (控件数量))
                            .如果真结束
                            加入成员 (所属类型, 临时对象.读文本属性 (“type”, ))
                            加入成员 (控件标题, 临时对象.读文本属性 (“innertext”, ))
                            加入成员 (控件名称, 临时对象.读文本属性 (“name”, ))
                            加入成员 (控件ID, 临时对象.读文本属性 (“ID”, ))
                            加入成员 (引用代码, 临时对象.读文本属性 (“outerHTML”, ))
                            加入成员 (返回的对象, 临时对象)
                        .如果真结束
                        
                    .判断 (大类型 ＝ 6) ' 图片按钮
                        .如果真 (临时类型 ＝ 控件类型数组 [二级计次])
                            控件数量 ＝ 控件数量 ＋ 1
                            .如果真 (是否标记)
                                临时对象.写属性 (“name”, “图片按钮” ＋ 到文本 (控件数量))
                            .如果真结束
                            加入成员 (所属类型, 临时对象.读文本属性 (“type”, ))
                            加入成员 (控件内容, 临时对象.读文本属性 (“value”, ))
                            加入成员 (控件名称, 临时对象.读文本属性 (“name”, ))
                            加入成员 (控件ID, 临时对象.读文本属性 (“ID”, ))
                            加入成员 (图片地址, 临时对象.读文本属性 (“src”, ))
                            加入成员 (图片高度, 临时对象.读文本属性 (“width”, ))
                            加入成员 (图片宽度, 临时对象.读文本属性 (“height”, ))
                            加入成员 (引用代码, 临时对象.读文本属性 (“outerHTML”, ))
                            加入成员 (返回的对象, 临时对象)
                        .如果真结束
                        
                    .判断 (大类型 ＝ 7) ' 链接
                        .如果真 (临时类型 ＝ 控件类型数组 [二级计次])
                            加入成员 (所属类型, 临时对象.读文本属性 (“tagname”, ))
                            加入成员 (控件标题, 临时对象.读文本属性 (“innertext”, ))
                            加入成员 (链接地址, 临时对象.读文本属性 (“href”, ))
                            加入成员 (引用代码, 临时对象.读文本属性 (“outerHTML”, ))
                            加入成员 (title链接标题, 临时对象.读文本属性 (“title”, ))
                            加入成员 (返回的对象, 临时对象)
                        .如果真结束
                        
                    .判断 (大类型 ＝ 8) ' 图片
                        .如果真 (临时类型 ＝ 控件类型数组 [二级计次])
                            加入成员 (所属类型, 临时对象.读文本属性 (“tagName”, ))
                            加入成员 (图片地址, 临时对象.读文本属性 (“src”, ))
                            加入成员 (控件名称, 临时对象.读文本属性 (“name”, ))
                            加入成员 (控件ID, 临时对象.读文本属性 (“ID”, ))
                            加入成员 (图片高度, 临时对象.读文本属性 (“height”, ))
                            加入成员 (图片宽度, 临时对象.读文本属性 (“width”, ))
                            加入成员 (引用代码, 临时对象.读文本属性 (“outerHTML”, ))
                            加入成员 (title链接标题, 临时对象.读文本属性 (“title”, ))
                            加入成员 (返回的对象, 临时对象)
                        .如果真结束
                        
                    .判断 (大类型 ＝ 10) ' 组合框
                        .如果真 (临时类型 ＝ 控件类型数组 [二级计次])
                            加入成员 (所属类型, 临时对象.读文本属性 (“tagName”, ))
                            加入成员 (引用代码, 临时对象.读文本属性 (“outerHTML”, ))
                            加入成员 (返回的对象, 临时对象)
                        .如果真结束
                        
                    .判断 (大类型 ＝ 11) ' DIV
                        .如果真 (临时类型 ＝ 控件类型数组 [二级计次])
                            加入成员 (所属类型, 临时对象.读文本属性 (“tagName”, ))
                            加入成员 (控件名称, 临时对象.读文本属性 (“name”, ))
                            加入成员 (控件标题, 临时对象.读文本属性 (“innertext”, ))
                            加入成员 (控件ID, 临时对象.读文本属性 (“ID”, ))
                            加入成员 (引用代码, 临时对象.读文本属性 (“outerHTML”, ))
                            加入成员 (title链接标题, 临时对象.读文本属性 (“title”, ))
                            加入成员 (返回的对象, 临时对象)
                        .如果真结束
                        
                    .默认
                        
                    .判断结束
                    
                .计次循环尾 ()
            .计次循环尾 ()
        .计次循环尾 ()
        
    .如果真结束
    .判断开始 (大类型 ＝ 12)
        返回 (取数组成员数 (控件标题))
    .判断 (大类型 ＝ 13)
        返回 (取数组成员数 (控件标题))
    .默认
        
    .判断结束
    返回 (取数组成员数 (所属类型))

.子程序 _内部_INPUT_取数量_复单, 整数型, , 复选框和单选框专用
    .参数 元素TYPE名称, 文本型, , 如：checkbox  radio
    .参数 元素名称, 文本型, , 如：文本框、按钮、图片等等
    .参数 是否标记, 逻辑型, 可空, 可空。默认为不标记
    .局部变量 临时对象, 对象
    .局部变量 对象, 对象
    .局部变量 type, 文本型
    .局部变量 i, 整数型
    .局部变量 索引, 整数型
    .局部变量 元素代码, 文本型

    对象 ＝ 集_网页文档.读对象型属性 (“body”, ).读对象型属性 (“all”, ).对象型方法 (“tags”, “input”)
    .计次循环首 (对象.读数值属性 (“length”, ), i)
        临时对象 ＝ 对象.对象型方法 (“item”, i － 1)
        type ＝ 临时对象.读文本属性 (“type”, ) ' 读取属性类型
        .如果真 (寻找文本 (元素TYPE名称, type, , 假) ≠ -1)
            索引 ＝ 索引 ＋ 1
            .如果真 (是否标记)
                元素代码 ＝ 临时对象.读文本属性 (“outerHTML”, ) ＋ “<font color=red>[复” ＋ 到文本 (索引) ＋ “]</font>”
                临时对象.写属性 (“outerHTML”, 元素代码)
            .如果真结束
            
        .如果真结束
        
    .计次循环尾 ()
    返回 (索引)

.子程序 _内部_INPUT_取数量, 整数型
    .参数 元素TYPE名称, 文本型, , 如：text|file|passwrod   button|submit
    .参数 元素名称, 文本型, , 如：文本框、按钮、图片等等
    .参数 是否标记, 逻辑型, 可空, 可空。默认为不标记
    .局部变量 临时对象, 对象
    .局部变量 对象, 对象
    .局部变量 type, 文本型
    .局部变量 i, 整数型
    .局部变量 索引, 整数型

    对象 ＝ 集_网页文档.读对象型属性 (“body”, ).读对象型属性 (“all”, ).对象型方法 (“tags”, “input”)
    .计次循环首 (对象.读数值属性 (“length”, ), i)
        临时对象 ＝ 对象.对象型方法 (“item”, i － 1)
        type ＝ 临时对象.读文本属性 (“type”, ) ' 读取属性类型
        .如果真 (寻找文本 (元素TYPE名称, type, , 假) ≠ -1)
            索引 ＝ 索引 ＋ 1
            .如果真 (是否标记)
                临时对象.写属性 (“value”, 元素名称 ＋ 到文本 (索引))
            .如果真结束
            
        .如果真结束
        
    .计次循环尾 ()
    
    .判断开始 (寻找文本 (元素TYPE名称, “button”, , 假) ≠ -1)
        对象 ＝ 集_网页文档.读对象型属性 (“body”, ).读对象型属性 (“all”, ).对象型方法 (“tags”, “button”)
        .计次循环首 (对象.读数值属性 (“length”, ), i)
            临时对象 ＝ 对象.对象型方法 (“item”, i － 1)
            type ＝ 临时对象.读文本属性 (“type”, ) ' 读取属性类型
            .如果真 (寻找文本 (元素TYPE名称, type, , 假) ≠ -1)
                索引 ＝ 索引 ＋ 1
                .如果真 (是否标记)
                    临时对象.写属性 (“innerText”, 元素名称 ＋ 到文本 (索引))
                .如果真结束
                
            .如果真结束
            
        .计次循环尾 ()
    .默认
        
    .判断结束
    返回 (索引)

.子程序 _内部_INPUT_取对象, 对象
    .参数 元素TYPE名称, 文本型, , 如：text|file|passwrod   button|submit|reset
    .参数 名称_ID_索引, 文本型, , 网页文本框的文本框名称或ID或索引。从1开始。
    .参数 跳过次数, 整数型, 可空, 如果元素名称一样,可以用此参数;说明:跳过的次数，如果为0还是为不跳过，只有“是否跳过参数为真”且“跳过次数大于0的时候才会跳过”
    .参数 元素索引, 整数型, 参考 可空, 可空。请提供一个整数型的变量，用于存储返回的元素索引。
    .局部变量 局_临时对象, 对象
    .局部变量 局_对象, 对象
    .局部变量 type, 文本型
    .局部变量 i, 整数型
    .局部变量 局_索引, 整数型

    局_对象 ＝ 集_网页文档.读对象型属性 (“body”, ).读对象型属性 (“all”, ).对象型方法 (“tags”, “input”)
    局_索引 ＝ 到数值 (名称_ID_索引)
    .计次循环首 (局_对象.读数值属性 (“length”, ), i)
        局_临时对象 ＝ 局_对象.对象型方法 (“item”, i － 1)
        type ＝ 局_临时对象.读文本属性 (“type”, ) ' 读取属性类型
        .如果真 (寻找文本 (元素TYPE名称, type, , 假) ≠ -1)
            元素索引 ＝ 元素索引 ＋ 1
            .判断开始 (局_临时对象.读文本属性 (“name”, ) ＝ 名称_ID_索引)
                .判断开始 (跳过次数 ＞ 0) ' 如果跳过次数大于0,则跳过
                    跳过次数 ＝ 跳过次数 － 1
                    到循环尾 ()
                .默认
                    返回 (局_临时对象)
                .判断结束
                
            .判断 (局_临时对象.读文本属性 (“id”, ) ＝ 名称_ID_索引)
                .判断开始 (跳过次数 ＞ 0) ' 如果跳过次数大于0,则跳过
                    跳过次数 ＝ 跳过次数 － 1
                    到循环尾 ()
                .默认
                    返回 (局_临时对象)
                .判断结束
                
            .判断 (局_临时对象.读文本属性 (“title”, ) ＝ 名称_ID_索引)
                .判断开始 (跳过次数 ＞ 0) ' 如果跳过次数大于0,则跳过
                    跳过次数 ＝ 跳过次数 － 1
                    到循环尾 ()
                .默认
                    返回 (局_临时对象)
                .判断结束
                
            .判断 (元素索引 ＝ 局_索引)
                返回 (局_临时对象)
            .默认
                
            .判断结束
            
        .如果真结束
        
    .计次循环尾 ()
    .判断开始 (寻找文本 (元素TYPE名称, “button”, , 假) ≠ -1)
        局_对象 ＝ 集_网页文档.读对象型属性 (“body”, ).读对象型属性 (“all”, ).对象型方法 (“tags”, “button”)
        .计次循环首 (局_对象.读数值属性 (“length”, ), i)
            局_临时对象 ＝ 局_对象.对象型方法 (“item”, i － 1)
            type ＝ 局_临时对象.读文本属性 (“type”, ) ' 读取属性类型
            .如果真 (寻找文本 (元素TYPE名称, type, , 假) ≠ -1)
                元素索引 ＝ 元素索引 ＋ 1
                .判断开始 (局_临时对象.读文本属性 (“name”, ) ＝ 名称_ID_索引)
                    .判断开始 (跳过次数 ＞ 0) ' 如果跳过次数大于0,则跳过
                        跳过次数 ＝ 跳过次数 － 1
                        到循环尾 ()
                    .默认
                        返回 (局_临时对象)
                    .判断结束
                    
                .判断 (局_临时对象.读文本属性 (“id”, ) ＝ 名称_ID_索引)
                    .判断开始 (跳过次数 ＞ 0) ' 如果跳过次数大于0,则跳过
                        跳过次数 ＝ 跳过次数 － 1
                        到循环尾 ()
                    .默认
                        返回 (局_临时对象)
                    .判断结束
                    
                .判断 (局_临时对象.读文本属性 (“title”, ) ＝ 名称_ID_索引)
                    .判断开始 (跳过次数 ＞ 0) ' 如果跳过次数大于0,则跳过
                        跳过次数 ＝ 跳过次数 － 1
                        到循环尾 ()
                    .默认
                        返回 (局_临时对象)
                    .判断结束
                    
                .判断 (元素索引 ＝ 局_索引)
                    返回 (局_临时对象)
                .默认
                    
                .判断结束
                
            .如果真结束
            
        .计次循环尾 ()
    .默认
        
    .判断结束
    元素索引 ＝ -1
    局_临时对象.清除 ()
    返回 (局_临时对象)

.子程序 _内部_IMG_取数量, 整数型
    .参数 元素TYPE名称, 文本型, , 如：text|file|passwrod   button|submit
    .参数 元素名称, 文本型, , 如：文本框、按钮、图片等等
    .参数 是否标记, 逻辑型, 可空, 可空。默认为不标记
    .参数 枚举元素, 逻辑型, 可空, 可空。如果要枚举元素，请设置为真
    .参数 地址数组, 文本型, 参考 可空 数组, 用于存放 图片地址 数组的变量。
    .参数 图片宽度, 文本型, 参考 可空 数组, 用于存放 图片宽度 数组的变量。
    .参数 图片高度, 文本型, 参考 可空 数组, 用于存放 图片高度 数组的变量。
    .参数 图片名称, 文本型, 参考 可空 数组, 用于存放 图片名称 数组的变量。
    .参数 图片ID, 文本型, 参考 可空 数组, 用于存放 图片ID 数组的变量。
    .参数 图片标题, 文本型, 参考 可空 数组, 用于存放 图片标题 数组的变量。
    .局部变量 临时对象, 对象
    .局部变量 对象, 对象
    .局部变量 type, 文本型
    .局部变量 i, 整数型
    .局部变量 索引, 整数型

    对象 ＝ 集_网页文档.读对象型属性 (“body”, ).读对象型属性 (“all”, ).对象型方法 (“tags”, “input”)
    .计次循环首 (对象.读数值属性 (“length”, ), i)
        临时对象 ＝ 对象.对象型方法 (“item”, i － 1)
        type ＝ 临时对象.读文本属性 (“type”, ) ' 读取属性类型
        .如果真 (寻找文本 (元素TYPE名称, type, , 假) ≠ -1)
            索引 ＝ 索引 ＋ 1
            .如果真 (是否标记)
                临时对象.写属性 (“title”, 元素名称 ＋ 到文本 (索引))
            .如果真结束
            .如果真 (枚举元素)
                加入成员 (地址数组, 临时对象.读文本属性 (“src”, ))
                加入成员 (图片宽度, 临时对象.读文本属性 (“width”, ))
                加入成员 (图片高度, 临时对象.读文本属性 (“height”, ))
                加入成员 (图片名称, 临时对象.读文本属性 (“name”, ))
                加入成员 (图片ID, 临时对象.读文本属性 (“id”, ))
                加入成员 (图片标题, 临时对象.读文本属性 (“title”, ))
            .如果真结束
            
        .如果真结束
        
    .计次循环尾 ()
    .判断开始 (寻找文本 (元素TYPE名称, “image”, , 假) ≠ -1)
        对象 ＝ 集_网页文档.读对象型属性 (“body”, ).读对象型属性 (“all”, ).对象型方法 (“tags”, “img”)
        .计次循环首 (对象.读数值属性 (“length”, ), i)
            临时对象 ＝ 对象.对象型方法 (“item”, i － 1)
            索引 ＝ 索引 ＋ 1
            .如果真 (是否标记)
                临时对象.写属性 (“title”, 元素名称 ＋ 到文本 (索引))
            .如果真结束
            .如果真 (枚举元素)
                加入成员 (地址数组, 临时对象.读文本属性 (“src”, ))
                加入成员 (图片宽度, 临时对象.读文本属性 (“width”, ))
                加入成员 (图片高度, 临时对象.读文本属性 (“height”, ))
                加入成员 (图片名称, 临时对象.读文本属性 (“name”, ))
                加入成员 (图片ID, 临时对象.读文本属性 (“id”, ))
                加入成员 (图片标题, 临时对象.读文本属性 (“title”, ))
            .如果真结束
            
        .计次循环尾 ()
    .默认
        
    .判断结束
    返回 (索引)

.子程序 _内部_IMG_取对象, 对象
    .参数 元素TYPE名称, 文本型, , 如：text|file|passwrod   button|submit|reset
    .参数 名称_ID_索引, 文本型, , 网页文本框的文本框名称或ID或索引。从1开始。
    .参数 跳过次数, 整数型, 可空, 如果元素名称一样,可以用此参数;说明:跳过的次数，如果为0还是为不跳过，只有“是否跳过参数为真”且“跳过次数大于0的时候才会跳过”
    .参数 元素索引, 整数型, 参考 可空, 可空。请提供一个整数型的变量，用于存储返回的元素索引。
    .局部变量 临时对象, 对象
    .局部变量 对象, 对象
    .局部变量 type, 文本型
    .局部变量 i, 整数型
    .局部变量 局_索引, 整数型

    对象 ＝ 集_网页文档.读对象型属性 (“body”, ).读对象型属性 (“all”, ).对象型方法 (“tags”, “input”)
    局_索引 ＝ 到数值 (名称_ID_索引)
    .计次循环首 (对象.读数值属性 (“length”, ), i)
        临时对象 ＝ 对象.对象型方法 (“item”, i － 1)
        type ＝ 临时对象.读文本属性 (“type”, ) ' 读取属性类型
        .如果真 (寻找文本 (元素TYPE名称, type, , 假) ≠ -1)
            元素索引 ＝ 元素索引 ＋ 1
            .判断开始 (寻找文本 (临时对象.读文本属性 (“src”, ), 名称_ID_索引, , 假) ≠ -1)
                .判断开始 (跳过次数 ＞ 0) ' 如果跳过次数大于0,则跳过
                    跳过次数 ＝ 跳过次数 － 1
                    到循环尾 ()
                .默认
                    返回 (临时对象)
                .判断结束
                
            .判断 (临时对象.读文本属性 (“name”, ) ＝ 名称_ID_索引)
                .判断开始 (跳过次数 ＞ 0) ' 如果跳过次数大于0,则跳过
                    跳过次数 ＝ 跳过次数 － 1
                    到循环尾 ()
                .默认
                    返回 (临时对象)
                .判断结束
                
            .判断 (临时对象.读文本属性 (“id”, ) ＝ 名称_ID_索引)
                .判断开始 (跳过次数 ＞ 0) ' 如果跳过次数大于0,则跳过
                    跳过次数 ＝ 跳过次数 － 1
                    到循环尾 ()
                .默认
                    返回 (临时对象)
                .判断结束
                
            .判断 (临时对象.读文本属性 (“title”, ) ＝ 名称_ID_索引)
                .判断开始 (跳过次数 ＞ 0) ' 如果跳过次数大于0,则跳过
                    跳过次数 ＝ 跳过次数 － 1
                    到循环尾 ()
                .默认
                    返回 (临时对象)
                .判断结束
                
            .判断 (元素索引 ＝ 局_索引)
                返回 (临时对象)
            .默认
                
            .判断结束
            
        .如果真结束
        
    .计次循环尾 ()
    .判断开始 (寻找文本 (元素TYPE名称, “image”, , 假) ≠ -1)
        对象 ＝ 集_网页文档.读对象型属性 (“body”, ).读对象型属性 (“all”, ).对象型方法 (“tags”, “img”)
        .计次循环首 (对象.读数值属性 (“length”, ), i)
            临时对象 ＝ 对象.对象型方法 (“item”, i － 1)
            元素索引 ＝ 元素索引 ＋ 1
            .判断开始 (寻找文本 (临时对象.读文本属性 (“src”, ), 名称_ID_索引, , 假) ≠ -1)
                .判断开始 (跳过次数 ＞ 0) ' 如果跳过次数大于0,则跳过
                    跳过次数 ＝ 跳过次数 － 1
                    到循环尾 ()
                .默认
                    返回 (临时对象)
                .判断结束
                
            .判断 (临时对象.读文本属性 (“name”, ) ＝ 名称_ID_索引)
                .判断开始 (跳过次数 ＞ 0) ' 如果跳过次数大于0,则跳过
                    跳过次数 ＝ 跳过次数 － 1
                    到循环尾 ()
                .默认
                    返回 (临时对象)
                .判断结束
                
            .判断 (临时对象.读文本属性 (“id”, ) ＝ 名称_ID_索引)
                .判断开始 (跳过次数 ＞ 0) ' 如果跳过次数大于0,则跳过
                    跳过次数 ＝ 跳过次数 － 1
                    到循环尾 ()
                .默认
                    返回 (临时对象)
                .判断结束
                
            .判断 (临时对象.读文本属性 (“title”, ) ＝ 名称_ID_索引)
                .判断开始 (跳过次数 ＞ 0) ' 如果跳过次数大于0,则跳过
                    跳过次数 ＝ 跳过次数 － 1
                    到循环尾 ()
                .默认
                    返回 (临时对象)
                .判断结束
                
            .判断 (元素索引 ＝ 局_索引)
                返回 (临时对象)
            .默认
                
            .判断结束
            
        .计次循环尾 ()
    .默认
        
    .判断结束
    元素索引 ＝ -1
    临时对象.清除 ()
    返回 (临时对象)

.子程序 _内部_DIV_取数量, 整数型
    .参数 元素TYPE名称, 文本型, , 如：DIV
    .参数 元素名称, 文本型, , 如：文本框、按钮、图片等等
    .参数 是否标记, 逻辑型, 可空, 可空。默认为不标记
    .局部变量 局_对象临时对象, 对象
    .局部变量 局_对象对象, 对象
    .局部变量 type, 文本型
    .局部变量 i, 整数型
    .局部变量 索引, 整数型

    局_对象对象 ＝ 集_网页文档.读对象型属性 (“body”, ).读对象型属性 (“all”, ).对象型方法 (“tags”, “div”)
    .计次循环首 (局_对象对象.读数值属性 (“length”, ), i)
        局_对象临时对象 ＝ 局_对象对象.对象型方法 (“item”, i － 1)
        索引 ＝ 索引 ＋ 1
        .如果真 (是否标记)
            局_对象临时对象.方法 (“insertAdjacentHTML”, “afterBegin”, “<font color=red>Div” ＋ 到文本 (索引) ＋ “</font>”)
        .如果真结束
        
    .计次循环尾 ()
    返回 (索引)

.子程序 _内部_DIV_取对象, 对象
    .参数 元素TYPE名称, 文本型, , 如：DIV
    .参数 Class_ID_索引_Title, 文本型, , 网页文本框的文本框名称或ID或索引。从1开始。
    .参数 跳过次数, 整数型, 可空, 如果元素名称一样,可以用此参数;说明:跳过的次数，如果为0还是为不跳过，只有“是否跳过参数为真”且“跳过次数大于0的时候才会跳过”
    .参数 元素索引, 整数型, 参考 可空, 可空。请提供一个整数型的变量，用于存储返回的元素索引。
    .局部变量 局_临时对象, 对象
    .局部变量 局_对象, 对象
    .局部变量 type, 文本型
    .局部变量 i, 整数型
    .局部变量 局_索引, 整数型

    局_对象 ＝ 集_网页文档.读对象型属性 (“body”, ).读对象型属性 (“all”, ).对象型方法 (“tags”, “div”)
    局_索引 ＝ 到数值 (Class_ID_索引_Title)
    .计次循环首 (局_对象.读数值属性 (“length”, ), i)
        局_临时对象 ＝ 局_对象.对象型方法 (“item”, i － 1)
        元素索引 ＝ 元素索引 ＋ 1
        .判断开始 (局_临时对象.读文本属性 (“className”, ) ＝ Class_ID_索引_Title)
            .判断开始 (跳过次数 ＞ 0) ' 如果跳过次数大于0,则跳过
                跳过次数 ＝ 跳过次数 － 1
                到循环尾 ()
            .默认
                返回 (局_临时对象)
            .判断结束
            
        .判断 (局_临时对象.读文本属性 (“innerText”, ) ＝ Class_ID_索引_Title)
            .判断开始 (跳过次数 ＞ 0) ' 如果跳过次数大于0,则跳过
                跳过次数 ＝ 跳过次数 － 1
                到循环尾 ()
            .默认
                返回 (局_临时对象)
            .判断结束
            
        .判断 (局_临时对象.读文本属性 (“name”, ) ＝ Class_ID_索引_Title)
            .判断开始 (跳过次数 ＞ 0) ' 如果跳过次数大于0,则跳过
                跳过次数 ＝ 跳过次数 － 1
                到循环尾 ()
            .默认
                返回 (局_临时对象)
            .判断结束
            
        .判断 (局_临时对象.读文本属性 (“id”, ) ＝ Class_ID_索引_Title)
            .判断开始 (跳过次数 ＞ 0) ' 如果跳过次数大于0,则跳过
                跳过次数 ＝ 跳过次数 － 1
                到循环尾 ()
            .默认
                返回 (局_临时对象)
            .判断结束
            
        .判断 (局_临时对象.读文本属性 (“title”, ) ＝ Class_ID_索引_Title)
            .判断开始 (跳过次数 ＞ 0) ' 如果跳过次数大于0,则跳过
                跳过次数 ＝ 跳过次数 － 1
                到循环尾 ()
            .默认
                返回 (局_临时对象)
            .判断结束
            
        .判断 (元素索引 ＝ 局_索引)
            返回 (局_临时对象)
        .默认
            
        .判断结束
        
        
    .计次循环尾 ()
    元素索引 ＝ -1
    局_临时对象.清除 ()
    返回 (局_临时对象)

.子程序 _内部_SPAN_取数量, 整数型
    .参数 元素TYPE名称, 文本型, , 如：DIV
    .参数 元素名称, 文本型, , 如：文本框、按钮、图片等等
    .参数 是否标记, 逻辑型, 可空, 可空。默认为不标记
    .局部变量 临时对象, 对象
    .局部变量 对象, 对象
    .局部变量 type, 文本型
    .局部变量 i, 整数型
    .局部变量 索引, 整数型

    对象 ＝ 集_网页文档.读对象型属性 (“body”, ).读对象型属性 (“all”, ).对象型方法 (“tags”, “span”)
    .计次循环首 (对象.读数值属性 (“length”, ), i)
        临时对象 ＝ 对象.对象型方法 (“item”, i － 1)
        索引 ＝ 索引 ＋ 1
        .如果真 (是否标记)
            临时对象.方法 (“insertAdjacentHTML”, “afterBegin”, “<font color=red>Span” ＋ 到文本 (索引) ＋ “</font>”)
            ' afterBegin = 在文本前容器内插入内容
            ' beforeEnd = 在文本后容器内插入内容
            ' beforeBegin = 在文本前容器外插入内容
            ' afterEnd = 在文本后容器外插入内容
        .如果真结束
        
    .计次循环尾 ()
    返回 (索引)

.子程序 _内部_SPAN_取对象, 对象
    .参数 元素TYPE名称, 文本型, , 如：DIV
    .参数 标题_索引_ID_className, 文本型, , 网页文本框的文本框名称或ID或索引。从1开始。
    .参数 跳过次数, 整数型, 可空, 如果元素名称一样,可以用此参数;说明:跳过的次数，如果为0还是为不跳过，只有“是否跳过参数为真”且“跳过次数大于0的时候才会跳过”
    .参数 元素索引, 整数型, 参考 可空, 可空。请提供一个整数型的变量，用于存储返回的元素索引。
    .局部变量 临时对象, 对象
    .局部变量 对象, 对象
    .局部变量 type, 文本型
    .局部变量 i, 整数型
    .局部变量 局_索引, 整数型

    对象 ＝ 集_网页文档.读对象型属性 (“body”, ).读对象型属性 (“all”, ).对象型方法 (“tags”, “span”)
    局_索引 ＝ 到数值 (标题_索引_ID_className)
    .计次循环首 (对象.读数值属性 (“length”, ), i)
        临时对象 ＝ 对象.对象型方法 (“item”, i － 1)
        元素索引 ＝ 元素索引 ＋ 1
        .判断开始 (临时对象.读文本属性 (“className”, ) ＝ 标题_索引_ID_className)
            .判断开始 (跳过次数 ＞ 0) ' 如果跳过次数大于0,则跳过
                跳过次数 ＝ 跳过次数 － 1
                到循环尾 ()
            .默认
                返回 (临时对象)
            .判断结束
            
        .判断 (临时对象.读文本属性 (“innerText”, ) ＝ 标题_索引_ID_className)
            .判断开始 (跳过次数 ＞ 0) ' 如果跳过次数大于0,则跳过
                跳过次数 ＝ 跳过次数 － 1
                到循环尾 ()
            .默认
                返回 (临时对象)
            .判断结束
            
            
        .判断 (临时对象.读文本属性 (“name”, ) ＝ 标题_索引_ID_className)
            .判断开始 (跳过次数 ＞ 0) ' 如果跳过次数大于0,则跳过
                跳过次数 ＝ 跳过次数 － 1
                到循环尾 ()
            .默认
                返回 (临时对象)
            .判断结束
            
        .判断 (临时对象.读文本属性 (“id”, ) ＝ 标题_索引_ID_className)
            .判断开始 (跳过次数 ＞ 0) ' 如果跳过次数大于0,则跳过
                跳过次数 ＝ 跳过次数 － 1
                到循环尾 ()
            .默认
                返回 (临时对象)
            .判断结束
            
        .判断 (临时对象.读文本属性 (“title”, ) ＝ 标题_索引_ID_className)
            .判断开始 (跳过次数 ＞ 0) ' 如果跳过次数大于0,则跳过
                跳过次数 ＝ 跳过次数 － 1
                到循环尾 ()
            .默认
                返回 (临时对象)
            .判断结束
            
        .判断 (元素索引 ＝ 局_索引)
            返回 (临时对象)
        .默认
            
        .判断结束
        
    .计次循环尾 ()
    元素索引 ＝ -1
    临时对象.清除 ()
    返回 (临时对象)

.子程序 _内部_ULLI_取数量, 整数型
    .参数 元素TYPE名称, 文本型, , 如：DIV
    .参数 元素名称, 文本型, , 如：文本框、按钮、图片等等
    .参数 是否标记, 逻辑型, 可空, 可空。默认为不标记
    .局部变量 临时对象, 对象
    .局部变量 对象, 对象
    .局部变量 type, 文本型
    .局部变量 i, 整数型
    .局部变量 索引, 整数型

    对象 ＝ 集_网页文档.读对象型属性 (“body”, ).读对象型属性 (“all”, ).对象型方法 (“tags”, “li”)
    .计次循环首 (对象.读数值属性 (“length”, ), i)
        临时对象 ＝ 对象.对象型方法 (“item”, i － 1)
        索引 ＝ 索引 ＋ 1
        .如果真 (是否标记)
            临时对象.方法 (“insertAdjacentHTML”, “afterBegin”, “<font color=red>ULli” ＋ 到文本 (索引) ＋ “</font>”)
            ' afterBegin = 在文本前容器内插入内容
            ' beforeEnd = 在文本后容器内插入内容
            ' beforeBegin = 在文本前容器外插入内容
            ' afterEnd = 在文本后容器外插入内容
        .如果真结束
        
    .计次循环尾 ()
    返回 (索引)

.子程序 _内部_ULLI_取对象, 对象
    .参数 元素TYPE名称, 文本型, , 如：DIV
    .参数 Class_ID_索引_Title, 文本型, , 网页文本框的文本框名称或ID或索引。从1开始。
    .参数 跳过次数, 整数型, 可空, 如果元素名称一样,可以用此参数;说明:跳过的次数，如果为0还是为不跳过，只有“是否跳过参数为真”且“跳过次数大于0的时候才会跳过”
    .参数 元素索引, 整数型, 参考 可空, 可空。请提供一个整数型的变量，用于存储返回的元素索引。
    .局部变量 临时对象, 对象
    .局部变量 对象, 对象
    .局部变量 type, 文本型
    .局部变量 i, 整数型
    .局部变量 局_索引, 整数型

    对象 ＝ 集_网页文档.读对象型属性 (“body”, ).读对象型属性 (“all”, ).对象型方法 (“tags”, “li”)
    局_索引 ＝ 到数值 (Class_ID_索引_Title)
    .计次循环首 (对象.读数值属性 (“length”, ), i)
        临时对象 ＝ 对象.对象型方法 (“item”, i － 1)
        元素索引 ＝ 元素索引 ＋ 1
        .判断开始 (临时对象.读文本属性 (“innerText”, ) ＝ Class_ID_索引_Title)
            .判断开始 (跳过次数 ＞ 0) ' 如果跳过次数大于0,则跳过
                跳过次数 ＝ 跳过次数 － 1
                到循环尾 ()
            .默认
                返回 (临时对象)
            .判断结束
            
        .判断 (临时对象.读文本属性 (“className”, ) ＝ Class_ID_索引_Title)
            .判断开始 (跳过次数 ＞ 0) ' 如果跳过次数大于0,则跳过
                跳过次数 ＝ 跳过次数 － 1
                到循环尾 ()
            .默认
                返回 (临时对象)
            .判断结束
            
        .判断 (临时对象.读文本属性 (“id”, ) ＝ Class_ID_索引_Title)
            .判断开始 (跳过次数 ＞ 0) ' 如果跳过次数大于0,则跳过
                跳过次数 ＝ 跳过次数 － 1
                到循环尾 ()
            .默认
                返回 (临时对象)
            .判断结束
            
        .判断 (临时对象.读文本属性 (“title”, ) ＝ Class_ID_索引_Title)
            .判断开始 (跳过次数 ＞ 0) ' 如果跳过次数大于0,则跳过
                跳过次数 ＝ 跳过次数 － 1
                到循环尾 ()
            .默认
                返回 (临时对象)
            .判断结束
            
        .判断 (元素索引 ＝ 局_索引)
            返回 (临时对象)
        .默认
            
        .判断结束
        
        
    .计次循环尾 ()
    元素索引 ＝ -1
    临时对象.清除 ()
    返回 (临时对象)

.子程序 _内部_TEXTAREA_取数量, 整数型
    .参数 元素TYPE名称, 文本型, , 如：DIV
    .参数 元素名称, 文本型, , 如：文本框、按钮、图片等等
    .参数 是否标记, 逻辑型, 可空, 可空。默认为不标记
    .局部变量 临时对象, 对象
    .局部变量 对象, 对象
    .局部变量 type, 文本型
    .局部变量 i, 整数型
    .局部变量 索引, 整数型

    对象 ＝ 集_网页文档.读对象型属性 (“body”, ).读对象型属性 (“all”, ).对象型方法 (“tags”, “textarea”)
    .计次循环首 (对象.读数值属性 (“length”, ), i)
        临时对象 ＝ 对象.对象型方法 (“item”, i － 1)
        索引 ＝ 索引 ＋ 1
        .如果真 (是否标记)
            临时对象.方法 (“insertAdjacentHTML”, “afterBegin”, “<font color=red>ULli” ＋ 到文本 (索引) ＋ “</font>”)
            ' afterBegin = 在文本前容器内插入内容
            ' beforeEnd = 在文本后容器内插入内容
            ' beforeBegin = 在文本前容器外插入内容
            ' afterEnd = 在文本后容器外插入内容
        .如果真结束
        
    .计次循环尾 ()
    返回 (索引)

.子程序 _内部_TEXTAREA_取对象, 对象
    .参数 元素TYPE名称, 文本型, , 如：DIV
    .参数 Class_ID_索引_Title, 文本型, , 网页文本框的文本框名称或ID或索引。从1开始。
    .参数 跳过次数, 整数型, 可空, 如果元素名称一样,可以用此参数;说明:跳过的次数，如果为0还是为不跳过，只有“是否跳过参数为真”且“跳过次数大于0的时候才会跳过”
    .参数 元素索引, 整数型, 参考 可空, 可空。请提供一个整数型的变量，用于存储返回的元素索引。
    .局部变量 临时对象, 对象
    .局部变量 对象, 对象
    .局部变量 type, 文本型
    .局部变量 i, 整数型
    .局部变量 局_索引, 整数型

    对象 ＝ 集_网页文档.读对象型属性 (“body”, ).读对象型属性 (“all”, ).对象型方法 (“tags”, “textarea”)
    局_索引 ＝ 到数值 (Class_ID_索引_Title)
    .计次循环首 (对象.读数值属性 (“length”, ), i)
        临时对象 ＝ 对象.对象型方法 (“item”, i － 1)
        元素索引 ＝ 元素索引 ＋ 1
        .判断开始 (临时对象.读文本属性 (“innerText”, ) ＝ Class_ID_索引_Title)
            .判断开始 (跳过次数 ＞ 0) ' 如果跳过次数大于0,则跳过
                跳过次数 ＝ 跳过次数 － 1
                到循环尾 ()
            .默认
                返回 (临时对象)
            .判断结束
            
        .判断 (临时对象.读文本属性 (“className”, ) ＝ Class_ID_索引_Title)
            .判断开始 (跳过次数 ＞ 0) ' 如果跳过次数大于0,则跳过
                跳过次数 ＝ 跳过次数 － 1
                到循环尾 ()
            .默认
                返回 (临时对象)
            .判断结束
            
        .判断 (临时对象.读文本属性 (“id”, ) ＝ Class_ID_索引_Title)
            .判断开始 (跳过次数 ＞ 0) ' 如果跳过次数大于0,则跳过
                跳过次数 ＝ 跳过次数 － 1
                到循环尾 ()
            .默认
                返回 (临时对象)
            .判断结束
            
        .判断 (临时对象.读文本属性 (“title”, ) ＝ Class_ID_索引_Title)
            .判断开始 (跳过次数 ＞ 0) ' 如果跳过次数大于0,则跳过
                跳过次数 ＝ 跳过次数 － 1
                到循环尾 ()
            .默认
                返回 (临时对象)
            .判断结束
            
        .判断 (临时对象.读文本属性 (“Name”, ) ＝ Class_ID_索引_Title)
            .判断开始 (跳过次数 ＞ 0) ' 如果跳过次数大于0,则跳过
                跳过次数 ＝ 跳过次数 － 1
                到循环尾 ()
            .默认
                返回 (临时对象)
            .判断结束
            
        .判断 (元素索引 ＝ 局_索引)
            返回 (临时对象)
        .默认
            
        .判断结束
        
    .计次循环尾 ()
    元素索引 ＝ -1
    临时对象.清除 ()
    返回 (临时对象)

.子程序 _内部_A_取数量, 整数型
    .参数 元素TYPE名称, 文本型, , 如：DIV
    .参数 元素名称, 文本型, , 如：文本框、按钮、图片等等
    .参数 是否标记, 逻辑型, 可空, 可空。默认为不标记
    .参数 枚举元素, 逻辑型, 可空, 可空。如果要枚举元素，请设置为真
    .参数 地址数组, 文本型, 参考 可空 数组, 可空。请提供一个 文本型 的数组变量，用于存放 地址数组
    .参数 标题数组, 文本型, 参考 可空 数组, 可空。请提供一个 文本型 的数组变量，用于存放 标题数组
    .参数 元素名称数组, 文本型, 参考 可空 数组, 可空。请提供一个 文本型 的数组变量，用于存放 元素名称数组
    .参数 元素ID数组, 文本型, 参考 可空 数组, 可空。请提供一个 文本型 的数组变量，用于存放 元素ID数组
    .局部变量 临时对象, 对象
    .局部变量 对象, 对象
    .局部变量 元素源码, 文本型
    .局部变量 i, 整数型
    .局部变量 索引, 整数型

    对象 ＝ 集_网页文档.读对象型属性 (“body”, ).读对象型属性 (“all”, ).对象型方法 (“tags”, “a”)
    .如果 (枚举元素)
        .计次循环首 (对象.读数值属性 (“length”, ), i)
            临时对象 ＝ 对象.对象型方法 (“item”, i － 1)
            加入成员 (地址数组, 临时对象.读文本属性 (“href”, ))
            加入成员 (标题数组, 临时对象.读文本属性 (“innerText”, ))
            加入成员 (元素名称数组, 临时对象.读文本属性 (“name”, ))
            加入成员 (元素ID数组, 临时对象.读文本属性 (“id”, ))
        .计次循环尾 ()
        
    .否则
        .计次循环首 (对象.读数值属性 (“length”, ), i)
            临时对象 ＝ 对象.对象型方法 (“item”, i － 1)
            索引 ＝ 索引 ＋ 1
            .如果真 (是否标记)
                元素源码 ＝ 临时对象.读文本属性 (“innerHTML”, )
                临时对象.写属性 (“innerHTML”, 元素源码 ＋ “<font color=red>” ＋ 元素名称 ＋ 到文本 (索引) ＋ “</font>”)
            .如果真结束
            
        .计次循环尾 ()
    .如果结束
    返回 (对象.读数值属性 (“length”, ))

.子程序 _内部_A_取对象, 对象
    .参数 元素TYPE名称, 文本型, , 如：DIV
    .参数 地址_ID_索引_标题, 文本型, , 网页文本框的文本框名称或ID或索引。从1开始。
    .参数 跳过次数, 整数型, 可空, 如果元素名称一样,可以用此参数;说明:跳过的次数，如果为0还是为不跳过，只有“是否跳过参数为真”且“跳过次数大于0的时候才会跳过”
    .参数 元素索引, 整数型, 参考 可空, 可空。请提供一个整数型的变量，用于存储返回的元素索引。
    .局部变量 临时对象, 对象
    .局部变量 对象, 对象
    .局部变量 type, 文本型
    .局部变量 i, 整数型
    .局部变量 局_索引, 整数型

    对象 ＝ 集_网页文档.读对象型属性 (“body”, ).读对象型属性 (“all”, ).对象型方法 (“tags”, “a”)
    局_索引 ＝ 到数值 (地址_ID_索引_标题)
    .计次循环首 (对象.读数值属性 (“length”, ), i)
        临时对象 ＝ 对象.对象型方法 (“item”, i － 1)
        元素索引 ＝ 元素索引 ＋ 1
        .判断开始 (临时对象.读文本属性 (“href”, ) ＝ 地址_ID_索引_标题)
            .判断开始 (跳过次数 ＞ 0) ' 如果跳过次数大于0,则跳过
                跳过次数 ＝ 跳过次数 － 1
                到循环尾 ()
            .默认
                返回 (临时对象)
            .判断结束
            
        .判断 (临时对象.读文本属性 (“id”, ) ＝ 地址_ID_索引_标题)
            .判断开始 (跳过次数 ＞ 0) ' 如果跳过次数大于0,则跳过
                跳过次数 ＝ 跳过次数 － 1
                到循环尾 ()
            .默认
                返回 (临时对象)
            .判断结束
            
        .判断 (临时对象.读文本属性 (“title”, ) ＝ 地址_ID_索引_标题)
            .判断开始 (跳过次数 ＞ 0) ' 如果跳过次数大于0,则跳过
                跳过次数 ＝ 跳过次数 － 1
                到循环尾 ()
            .默认
                返回 (临时对象)
            .判断结束
            
        .判断 (临时对象.读文本属性 (“innerText”, ) ＝ 地址_ID_索引_标题)
            .判断开始 (跳过次数 ＞ 0) ' 如果跳过次数大于0,则跳过
                跳过次数 ＝ 跳过次数 － 1
                到循环尾 ()
            .默认
                返回 (临时对象)
            .判断结束
            
        .判断 (临时对象.读文本属性 (“className”, ) ＝ 地址_ID_索引_标题)
            .判断开始 (跳过次数 ＞ 0) ' 如果跳过次数大于0,则跳过
                跳过次数 ＝ 跳过次数 － 1
                到循环尾 ()
            .默认
                返回 (临时对象)
            .判断结束
            
            
        .判断 (元素索引 ＝ 局_索引)
            返回 (临时对象)
        .默认
            
        .判断结束
        
        
    .计次循环尾 ()
    元素索引 ＝ -1
    临时对象.清除 ()
    返回 (临时对象)

.子程序 _内部_CITE_取数量, 整数型
    .参数 元素TYPE名称, 文本型, , 如：DIV
    .参数 元素名称, 文本型, , 如：文本框、按钮、图片等等
    .参数 是否标记, 逻辑型, 可空, 可空。默认为不标记
    .局部变量 临时对象, 对象
    .局部变量 对象, 对象
    .局部变量 type, 文本型
    .局部变量 i, 整数型
    .局部变量 索引, 整数型

    对象 ＝ 集_网页文档.读对象型属性 (“body”, ).读对象型属性 (“all”, ).对象型方法 (“tags”, “cite”)
    .计次循环首 (对象.读数值属性 (“length”, ), i)
        临时对象 ＝ 对象.对象型方法 (“item”, i － 1)
        索引 ＝ 索引 ＋ 1
        .如果真 (是否标记)
            临时对象.方法 (“insertAdjacentHTML”, “afterBegin”, “<font color=red>ULli” ＋ 到文本 (索引) ＋ “</font>”)
            ' afterBegin = 在文本前容器内插入内容
            ' beforeEnd = 在文本后容器内插入内容
            ' beforeBegin = 在文本前容器外插入内容
            ' afterEnd = 在文本后容器外插入内容
        .如果真结束
        
    .计次循环尾 ()
    返回 (索引)

.子程序 _内部_CITE_取对象, 对象
    .参数 元素TYPE名称, 文本型, , 如：DIV
    .参数 Class_ID_索引_Title, 文本型, , 网页文本框的文本框名称或ID或索引。从1开始。
    .参数 跳过次数, 整数型, 可空, 如果元素名称一样,可以用此参数;说明:跳过的次数，如果为0还是为不跳过，只有“是否跳过参数为真”且“跳过次数大于0的时候才会跳过”
    .参数 元素索引, 整数型, 参考 可空, 可空。请提供一个整数型的变量，用于存储返回的元素索引。
    .局部变量 临时对象, 对象
    .局部变量 对象, 对象
    .局部变量 type, 文本型
    .局部变量 i, 整数型
    .局部变量 局_索引, 整数型

    对象 ＝ 集_网页文档.读对象型属性 (“body”, ).读对象型属性 (“all”, ).对象型方法 (“tags”, “cite”)
    局_索引 ＝ 到数值 (Class_ID_索引_Title)
    .计次循环首 (对象.读数值属性 (“length”, ), i)
        临时对象 ＝ 对象.对象型方法 (“item”, i － 1)
        元素索引 ＝ 元素索引 ＋ 1
        .判断开始 (临时对象.读文本属性 (“innerText”, ) ＝ Class_ID_索引_Title)
            .判断开始 (跳过次数 ＞ 0) ' 如果跳过次数大于0,则跳过
                跳过次数 ＝ 跳过次数 － 1
                到循环尾 ()
            .默认
                返回 (临时对象)
            .判断结束
            
        .判断 (临时对象.读文本属性 (“className”, ) ＝ Class_ID_索引_Title)
            .判断开始 (跳过次数 ＞ 0) ' 如果跳过次数大于0,则跳过
                跳过次数 ＝ 跳过次数 － 1
                到循环尾 ()
            .默认
                返回 (临时对象)
            .判断结束
            
        .判断 (临时对象.读文本属性 (“id”, ) ＝ Class_ID_索引_Title)
            .判断开始 (跳过次数 ＞ 0) ' 如果跳过次数大于0,则跳过
                跳过次数 ＝ 跳过次数 － 1
                到循环尾 ()
            .默认
                返回 (临时对象)
            .判断结束
            
        .判断 (临时对象.读文本属性 (“title”, ) ＝ Class_ID_索引_Title)
            .判断开始 (跳过次数 ＞ 0) ' 如果跳过次数大于0,则跳过
                跳过次数 ＝ 跳过次数 － 1
                到循环尾 ()
            .默认
                返回 (临时对象)
            .判断结束
            
        .判断 (元素索引 ＝ 局_索引)
            返回 (临时对象)
        .默认
            
        .判断结束
        
    .计次循环尾 ()
    元素索引 ＝ -1
    临时对象.清除 ()
    返回 (临时对象)

.子程序 控件_置标记, , 公开, 把网页上的控件填上标记。
    文本框_取数量 (真)
    多行文本框_取数量 (真)
    单选框_取数量 (真)
    复选框_取数量 (真)
    按钮_取数量 (真)
    组合框_取数量 (真)
    高级按钮_取数量 (真)
    图形按钮_取数量 (真)

.子程序 框架_取数量, 整数型, 公开, 返回框架的数量。
    .局部变量 一级框架, 对象
    .局部变量 二级框架, 对象
    .局部变量 三级框架, 对象
    .局部变量 四级框架, 对象
    .局部变量 一级框架文档, 对象
    .局部变量 二级框架文档, 对象
    .局部变量 三级框架文档, 对象
    .局部变量 四级框架文档, 对象
    .局部变量 一级计次, 整数型
    .局部变量 二级计次, 整数型
    .局部变量 三级计次, 整数型
    .局部变量 一级框架数量, 整数型
    .局部变量 二级框架数量, 整数型
    .局部变量 三级框架数量, 整数型
    .局部变量 四级框架数量, 整数型
    .局部变量 全部框架数, 整数型

    一级框架 ＝ 集_网页文档.读对象型属性 (“frames”, )
    .如果真 (集_网页文档.是否为空 () ＝ 假)
        全部框架数 ＝ 全部框架数 ＋ 1
    .如果真结束
    一级框架数量 ＝ 一级框架.读数值属性 (“length”, )
    .计次循环首 (一级框架数量, 一级计次)
        一级框架文档 ＝ 一级框架.对象型方法 (“item”, 一级计次 － 1).读对象型属性 (“document”, )
        二级框架 ＝ 一级框架文档.读对象型属性 (“frames”, )
        二级框架数量 ＝ 二级框架.读数值属性 (“length”, )
        .计次循环首 (二级框架数量, 二级计次)
            二级框架文档 ＝ 二级框架.对象型方法 (“item”, 二级计次 － 1).读对象型属性 (“document”, )
            三级框架 ＝ 二级框架文档.读对象型属性 (“frames”, )
            三级框架数量 ＝ 三级框架.读数值属性 (“length”, )
            .计次循环首 (三级框架数量, 三级计次)
                三级框架文档 ＝ 三级框架.对象型方法 (“item”, 三级计次 － 1).读对象型属性 (“document”, )
                四级框架 ＝ 三级框架文档.读对象型属性 (“frames”, )
                全部框架数 ＝ 全部框架数 ＋ 四级框架.读数值属性 (“length”, )
                全部框架数 ＝ 全部框架数 ＋ 1
            .计次循环尾 ()
            全部框架数 ＝ 全部框架数 ＋ 1
        .计次循环尾 ()
        全部框架数 ＝ 全部框架数 ＋ 1
    .计次循环尾 () ' 以上是把枚举一级的框架文档
    返回 (全部框架数)

.子程序 网页_跳转, , 公开, 在本窗口跳转到指定的网址
    .参数 网页地址, 文本型

    .如果真 (到小写 (取文本左边 (网页地址, 4)) ≠ “http”)
        网页地址 ＝ “http://” ＋ 网页地址
    .如果真结束
    集_网页文档.读对象型属性 (“parentWindow”, ).方法 (“navigate”, 网页地址)

.子程序 网页_跳转1, , 公开, 在本窗口跳转到指定的网址,如果 网页_跳转 失败，可试试本命令。
    .参数 网页地址, 文本型, , 要跳转的网站地址。

    .如果真 (到小写 (取文本左边 (网页地址, 4)) ≠ “http”)
        网页地址 ＝ “http://” ＋ 网页地址
    .如果真结束
    集_网页文档.写属性 (“location”, 网页地址)

.子程序 网页_缩放, 整数型, 公开, 放大或缩小网页视图。成功返回放大后的百分比。
    .参数 百分比, 整数型, , 如：110，就是放大百分之10。反则：如90，就是缩小到百分之90，100为恢复原大小。
    .局部变量 对象, 对象
    .局部变量 变焦, 双精度小数型

    对象 ＝ 集_网页文档.读对象型属性 (“Body”, ).读对象型属性 (“Style”, )
    变焦 ＝ 对象.读属性 (“Zoom”, ).取数值 ()
    变焦 ＝ 百分比 ÷ 100
    对象.写属性 (“Zoom”, 变焦)
    返回 (变焦 × 100)

.子程序 网页_取文本, 文本型, 公开, 取网页的文本。
    返回 (编码_Unicode到Ansi (集_网页文档.读对象型属性 (“documentElement”, ).读属性 (“innerText”, ).取字节集 ()))
    ' 返回 (集_网页文档.读对象型属性 (“documentElement”, ).读文本属性 (“innerText”, ))

.子程序 网页_取源码, 文本型, 公开, 取网页的源码。
    返回 (编码_Unicode到Ansi (集_网页文档.读对象型属性 (“documentElement”, ).读属性 (“outerHTML”, ).取字节集 ()))
    ' 返回 (集_网页文档.读对象型属性 (“documentElement”, ).读文本属性 (“outerHTML”, ))

.子程序 网页_取标题, 文本型, 公开, 取网页的标题。
    返回 (集_网页文档.读文本属性 (“title”, ))

.子程序 网页_执行脚本, , 公开, 在当前网页上执行指定的脚本命令。
    .参数 脚本代码, 文本型, , 脚本代码。
    .参数 脚本类型, 整数型, 可空, 默认为JavaScript。 0 = JavaScript。1 = VBScript。

    .如果真 (脚本类型 ＝ 0)
        集_网页文档.读对象型属性 (“parentWindow”, ).方法 (“execScript”, 脚本代码, “JavaScript”)
    .如果真结束
    .如果真 (脚本类型 ＝ 1)
        集_网页文档.读对象型属性 (“parentWindow”, ).方法 (“execScript”, 脚本代码, “VBScript”)
    .如果真结束
    

.子程序 网页_解除网页限制, , 公开, 可解除网页右键限制和防止复制限制!
    .局部变量 脚本代码, 文本型, , , 脚本代码。

    脚本代码 ＝ “javascript:document.onsdragstart=document.onselectstart=document.oncontextmenu=function(){return true}”
    网页_执行脚本 (脚本代码, 0)
    脚本代码 ＝ “javascript:document.onselectstart = document.oncontextmenu = document.onmousedown = document.onkeydown = function(){return true;};”
    网页_执行脚本 (脚本代码, 0)

.子程序 网页_执行事件, 逻辑型, 公开, 执行某个网页元素相关的脚本方法。成功返回真，失败返回假。
    .参数 元素对象, 对象, , 元素的对象，如：文本框的，直接用  文本框_取对象() 即可
    .参数 事件类型, 文本型, , 以 #网页事件_  开头的常量

    返回 (元素对象.逻辑方法 (“FireEvent”, 事件类型, 元素对象.读属性 (事件类型, )))

.子程序 网页_刷新, , 公开, 刷新当前页面
    网页_执行脚本 (“window.location.reload()”, 0)

.子程序 网页_取属性, 文本型, 公开, 取网页的所种属性，如：网页标题，地址，编码，大小，等等。
    .参数 属性类型, 文本型, , 请提供以 #网页属性_ 开头的常量值

    返回 (集_网页文档.读文本属性 (属性类型, ))

.子程序 网页_置属性, 逻辑型, 公开, 设置网页文档的属性。
    .参数 属性类型, 文本型, , 请提供以“#网页属性_”开头的常量值
    .参数 待写入值, 文本型

    返回 (集_网页文档.写属性 (属性类型, 待写入值))

.子程序 网页_修改, 逻辑型, 公开, 成功返回真，失败返回假。
    .参数 新源码, 文本型

    返回 (集_网页文档.读对象型属性 (“body”, ).写属性 (“innerHTML”, 新源码))

.子程序 网页_取坐标元素, 对象, 公开, 通过坐标取网页上的元素，成功返回元素的对象。
    .参数 横坐标, 整数型, 可空, （请提供屏幕的横坐标）留空则取鼠标所在位置的元素。
    .参数 纵坐标, 整数型, 可空, （请提供屏幕的纵坐标）留空则取鼠标所在位置的元素。
    .参数 网页地址, 文本型, 可空, 用于装载网页地址的变量
    .参数 控件类型, 文本型, 可空, 用于装载控件类型的变量
    .参数 元素标题, 文本型, 可空, 用于装载元素标题的变量
    .参数 元素名称, 文本型, 可空, 用于装载元素名称的变量
    .参数 元素ID, 文本型, 可空, 用于装载元素ID的变量
    .参数 链接地址, 文本型, 可空, 用于装载链接地址的变量
    .参数 引用代码, 文本型, 可空, 用于装载引用代码的变量
    .局部变量 窗口句柄, 整数型
    .局部变量 临时对象, 对象
    .局部变量 坐标, 精易_坐标
    .局部变量 矩形, 精易_位置和大小
    .局部变量 对象, 对象

    .如果 (横坐标 ＝ 0 且 纵坐标 ＝ 0)
        窗口句柄 ＝ 窗口_取鼠标处窗口句柄 ()
        .如果真 (窗口_取类名 (窗口句柄) ＝ “Internet Explorer_Server”)
            坐标 ＝ 鼠标_取位置 ()
            矩形 ＝ 窗口_取位置和大小 (窗口句柄)
            网页_取网页文档对象 (窗口句柄, 临时对象)
            对象 ＝ 临时对象.对象型方法 (“elementFromPoint”, 坐标.横 － 矩形.左边, 坐标.纵 － 矩形.顶边)
            网页地址 ＝ 临时对象.读文本属性 (“url”, )
            控件类型 ＝ 对象.读文本属性 (“tagName”, )
            元素标题 ＝ 对象.读文本属性 (“innerText”, )
            元素名称 ＝ 对象.读文本属性 (“name”, )
            元素ID ＝ 对象.读文本属性 (“ID”, )
            链接地址 ＝ 对象.读文本属性 (“href”, )
            引用代码 ＝ 对象.读文本属性 (“outerHTML”, )
            返回 (对象)
        .如果真结束
        
    .否则
        窗口句柄 ＝ 窗口_取鼠标处窗口句柄 ()
        .如果真 (窗口_取类名 (窗口句柄) ＝ “Internet Explorer_Server”)
            矩形 ＝ 窗口_取位置和大小 (窗口句柄)
            网页_取网页文档对象 (窗口句柄, 临时对象)
            对象 ＝ 临时对象.对象型方法 (“elementFromPoint”, 横坐标 － 矩形.左边, 纵坐标 － 矩形.顶边)
            网页地址 ＝ 临时对象.读文本属性 (“url”, )
            控件类型 ＝ 对象.读文本属性 (“tagName”, )
            元素标题 ＝ 对象.读文本属性 (“innerText”, )
            元素名称 ＝ 对象.读文本属性 (“name”, )
            元素ID ＝ 对象.读文本属性 (“ID”, )
            链接地址 ＝ 对象.读文本属性 (“href”, )
            引用代码 ＝ 对象.读文本属性 (“outerHTML”, )
            返回 (对象)
        .如果真结束
        
    .如果结束
    返回 (对象)

.子程序 网页_取元素坐标, 精易_坐标, 公开, 取指定元素对象的坐标。
    .参数 元素对象, 对象, , 可以通过“普通填表.按钮_取对象（）”方式,取得元素对象
    .局部变量 元素坐标, 精易_坐标

    元素坐标.横 ＝ 取元素横坐标 (元素对象)
    元素坐标.纵 ＝ 取元素纵坐标 (元素对象)
    返回 (元素坐标)

.子程序 取元素横坐标, 整数型
    .参数 元素对象, 对象
    .局部变量 横坐标, 整数型
    .局部变量 元素父对象, 对象

    横坐标 ＝ 元素对象.读数值属性 (“offsetLeft”, )
    元素父对象 ＝ 元素对象.读对象型属性 (“offsetParent”, )
    .如果真 (元素父对象.是否为空 () ＝ 假)
        横坐标 ＝ 横坐标 ＋ 取元素横坐标 (元素父对象)
    .如果真结束
    返回 (横坐标)
    ' //取元素横坐标
    ' function getLeft(e){
    ' var offset=e.offsetLeft;
    ' if(e.offsetParent=null) offset+=getLeft(e.offsetParent);
    ' return offset;
    ' }

.子程序 取元素纵坐标, 整数型
    .参数 元素对象, 对象
    .局部变量 纵坐标, 整数型
    .局部变量 元素父对象, 对象

    纵坐标 ＝ 元素对象.读数值属性 (“offsetTop”, )
    元素父对象 ＝ 元素对象.读对象型属性 (“offsetParent”, )
    .如果真 (元素父对象.是否为空 () ＝ 假)
        纵坐标 ＝ 纵坐标 ＋ 取元素纵坐标 (元素父对象)
    .如果真结束
    返回 (纵坐标)
    ' //取元素纵坐标
    ' function getTop(e){
    ' var offset=e.offsetTop;
    ' if(e.offsetParent=null) offset+=getTop(e.offsetParent);
    ' return offset;
    ' }

.子程序 网页_取顶级域名, 文本型, 公开, 取网页的顶级域名。
    返回 (集_网页文档.读文本属性 (“domain”, ))

.子程序 网页_取页面地址, 文本型, 公开, 取网页的页面地址。
    返回 (集_网页文档.读文本属性 (“location”, ))

.子程序 网页_取编码类型, 文本型, 公开, 取网页的编码类型。如：GBK。
    返回 (集_网页文档.读文本属性 (“charset”, ))

.子程序 网页_取选中内容, 文本型, 公开, 取当前网页上选中的内容。
    .参数 类型, 整数型, 可空, 默认为0。0.文本。1.HTML代码。 
    .局部变量 createRan, 对象

    createRan ＝ 集_网页文档.读对象型属性 (“selection”, ).对象型方法 (“createRange”, )
    .如果真 (createRan.是否为空 ())
        返回 (“”)
    .如果真结束
    .如果真 (类型 ＞ 0)
        返回 (createRan.读文本属性 (“htmlText”, ))
    .如果真结束
    返回 (createRan.读文本属性 (“Text”, ))

.子程序 网页_屏蔽信息框, , 公开, 直接无视网页上弹出来的信息框和对话框
    .局部变量 parentWindow, 对象

    parentWindow ＝ 集_网页文档.读对象型属性 (“parentWindow”, )
    parentWindow.方法 (“execScript”, “function alert(){return;}”, “JScript”)
    parentWindow.方法 (“execScript”, “function confirm(){return;}”, “JScript”)
    parentWindow.方法 (“execScript”, “function prompt(){return;}”, “JScript”)
    parentWindow.方法 (“execScript”, “function showModalDialog(){return;}”, “JScript”)

.子程序 网页_取页面大小, 文本型, 公开, 取当前网页的大小。
    返回 (集_网页文档.读文本属性 (“fileSize”, ))

.子程序 网页_隐藏滚动条, , 公开
    .局部变量 window, 对象

    window ＝ 集_网页文档.读对象型属性 (“parentWindow”, )
    window.通用方法 (“execScript”, “var jie = document.createStyleSheet();jie.addRule('html','overflow:hidden;');”)

.子程序 网页_滚动条控制, , 公开, 控制浏览器滚动条上下滑动。
    .参数 滚动距离, 整数型, , 正数为下滚，如：50。负数为上滚，如果-50。
    .参数 滚动类型, 整数型, 可空, 可空：默认为0。0=纵，1=横
    .局部变量 现在位置, 整数型

    .判断开始 (滚动类型 ＝ 0)
        现在位置 ＝ 集_网页文档.读对象型属性 (“documentElement”, ).读数值属性 (“scrollTop”, ) ＋ 滚动距离
        集_网页文档.读对象型属性 (“documentElement”, ).写属性 (“scrollTop”, 现在位置)
    .判断 (滚动类型 ＝ 1)
        现在位置 ＝ 集_网页文档.读对象型属性 (“documentElement”, ).读数值属性 (“scrollLeft”, ) ＋ 滚动距离
        集_网页文档.读对象型属性 (“documentElement”, ).写属性 (“scrollLeft”, 现在位置)
    .默认
        
    .判断结束
    

.子程序 网页_滚动条固定, , 公开, 控制浏览器滚动条上下滑动。
    .参数 横向位置, 整数型, , 横向位置
    .参数 纵向位置, 整数型, , 纵向位置

    集_网页文档.读对象型属性 (“documentElement”, ).写属性 (“scrollTop”, 纵向位置)
    集_网页文档.读对象型属性 (“documentElement”, ).写属性 (“scrollLeft”, 横向位置)

.子程序 网页_滚动条取位置, , 公开, 取滚动条横纵向位置。
    .参数 横向位置, 整数型, 参考 可空, 用于存放浏览器滚动横向的位置。
    .参数 纵向位置, 整数型, 参考 可空, 用于存放浏览器滚动纵向的位置。

    纵向位置 ＝ 到数值 (集_网页文档.读对象型属性 (“documentElement”, ).读文本属性 (“scrollTop”, ))
    横向位置 ＝ 到数值 (集_网页文档.读对象型属性 (“documentElement”, ).读文本属性 (“scrollLeft”, ))

.子程序 网页_滚动条取高宽, , 公开, 取出浏览器滚动条的高宽！
    .参数 滚动条高度, 整数型, 参考 可空, 用于存放浏览器滚动条高度的变量。
    .参数 滚动条宽度, 整数型, 参考 可空, 用于存放浏览器滚动条宽度的变量。

    滚动条高度 ＝ 到数值 (集_网页文档.读对象型属性 (“documentElement”, ).读文本属性 (“scrollHeight”, ))
    滚动条宽度 ＝ 到数值 (集_网页文档.读对象型属性 (“documentElement”, ).读文本属性 (“scrollWidth”, ))

.子程序 网页_替换选中内容, , 公开, 替换网页上选中的文本。
    .参数 替换为, 文本型, , 要替换为的文本。

    集_网页文档.读对象型属性 (“selection”, ).对象型方法 (“createRange”, ).方法 (“pasteHTML”, 替换为)

.子程序 网页_创建新网页, , 公开, 直接在Webbroswer或IES内写入一个完整的网页，创建前必须保证网页已打开。 
    .参数 新网页代码, 文本型, , 必须是完整的网页，即以<html>开头，以</html>结束。

    集_网页文档.方法 (“open”, )
    集_网页文档.方法 (“write”, 新网页代码)
    集_网页文档.方法 (“Close”, )

.子程序 网页_高亮关键字, , 公开
    .参数 关键字, 文本型, , 要高亮的网页关键字;
    .参数 文字颜色, 文本型, 可空, 可空:默认为红色;16进制的网页颜色;
    .参数 背景颜色, 文本型, 可空, 可空:默认为泥黄;16进制的网页颜色;
    .参数 是否加粗, 逻辑型, 可空, 可空:默认为假,不加粗,真=加粗;
    .局部变量 Body, 对象
    .局部变量 Range, 对象
    .局部变量 sTag, 文本型, , , 高亮开始标签
    .局部变量 eTag, 文本型, , , 高亮结束标签

    Body ＝ 集_网页文档.读对象型属性 (“body”, )
    .如果真 (文字颜色 ＝ “”)
        文字颜色 ＝ “ff0000”
    .如果真结束
    .如果真 (背景颜色 ＝ “”)
        背景颜色 ＝ “D6F20D”
    .如果真结束
    .判断开始 (是否加粗)
        sTag ＝ “<B style='COLOR: #” ＋ 文字颜色 ＋ “; BACKGROUND-COLOR: #” ＋ 背景颜色 ＋ “'>”
        eTag ＝ “</B>”
    .默认
        sTag ＝ “<font style='COLOR: #” ＋ 文字颜色 ＋ “; BACKGROUND-COLOR: #” ＋ 背景颜色 ＋ “'>”
        eTag ＝ “</font>”
    .判断结束
    .如果真 (Body.是否为空 () ＝ 假)
        Range ＝ Body.对象型方法 (“createTextRange”, )
        .判断循环首 (Range.逻辑方法 (“FindText”, 关键字))
            Range.方法 (“pasteHTML”, sTag ＋ Range.读文本属性 (“Text”, ) ＋ eTag)
            Range.方法 (“MoveStart”, “character”, 1)
        .判断循环尾 ()
    .如果真结束
    

.子程序 文本框_取对象, 对象, 公开, 根据网页文本框的Name或ID或索引取回对应的对象。
    .参数 名称_ID_索引, 文本型, , 网页文本框的文本框名称或ID或索引。从1开始。
    .参数 跳过次数, 整数型, 可空, 如果元素名称一样,可以用此参数;说明:跳过的次数，如果为0还是为不跳过，只有“是否跳过参数为真”且“跳过次数大于0的时候才会跳过”

    返回 (_内部_INPUT_取对象 (“text|password|file|email”, 名称_ID_索引, 跳过次数, ))

.子程序 文本框_取数量, 整数型, 公开, 取网页上的文本框数量。成功返回文本框的数量。失败返回0。
    .参数 是否标记, 逻辑型, 可空, 是否在每个文本框是写入标记文本。

    返回 (_内部_INPUT_取数量 (“text|password|file|email”, “文本框”, 是否标记))

.子程序 文本框_取内容, 文本型, 公开, 用元素ID、名称、索引。取指定的网页文本框中的内容;成功返回文本框的内容，失败返回空文本。
    .参数 名称_ID_索引, 文本型, , 网页文本框的文本框名称、ID、索引。索引从1开始。
    .参数 跳过次数, 整数型, 可空, 如果元素名称一样,可以用此参数;说明:跳过的次数，如果为0还是为不跳过，只有“是否跳过参数为真”且“跳过次数大于0的时候才会跳过”

    返回 (文本框_取对象 (名称_ID_索引, 跳过次数).读文本属性 (“value”, ))

.子程序 文本框_取索引, 整数型, 公开, 用文本框名称、ID、内容取出网页上指定的文本框索引，失败返回0。
    .参数 名称_ID, 文本型, , 网页文本框的文本框名称或ID
    .局部变量 元素索引, 整数型

    _内部_INPUT_取对象 (“text|password|file”, 名称_ID, , 元素索引)
    返回 (元素索引)

.子程序 文本框_取属性, 逻辑型, 公开, 取指定文本框的各种属性。成功返回真，失败返回假。
    .参数 控件索引, 整数型, , 网页控件的索引。从1开始。
    .参数 文本框内容, 文本型, 参考 可空, 用于装载文本框内容的变量。 
    .参数 文本框名称, 文本型, 参考 可空, 用于装载文本框名称的变量。 
    .参数 文本框ID, 文本型, 参考 可空, 用于装载文本框ID的变量。 
    .参数 文本框类型, 文本型, 参考 可空, 用于装载文本框类型的变量。 
    .参数 元素对象, 对象, 参考 可空, 用于装载元素对象的变量。 

    元素对象 ＝ 文本框_取对象 (到文本 (控件索引))
    .如果真 (是否为空 (文本框内容) ＝ 假)
        文本框内容 ＝ 元素对象.读文本属性 (“value”, )
    .如果真结束
    .如果真 (是否为空 (文本框名称) ＝ 假)
        文本框名称 ＝ 元素对象.读文本属性 (“name”, )
    .如果真结束
    .如果真 (是否为空 (文本框ID) ＝ 假)
        文本框ID ＝ 元素对象.读文本属性 (“id”, )
    .如果真结束
    .如果真 (是否为空 (文本框类型) ＝ 假)
        文本框类型 ＝ 元素对象.读文本属性 (“type”, )
    .如果真结束
    返回 (元素对象.是否为空 () ＝ 假)

.子程序 文本框_写内容, 逻辑型, 公开, 往指定的网页文本框写入指定的内容。成功返回真，失败返回假。
    .参数 名称_ID_索引, 文本型, , 网页文本框的文本框名称或ID或索引。从1开始。
    .参数 欲写内的内容, 文本型, , 欲写内的内容
    .参数 跳过次数, 整数型, 可空, 如果元素名称一样,可以用此参数;说明:跳过的次数，如果为0还是为不跳过，只有“是否跳过参数为真”且“跳过次数大于0的时候才会跳过”

    返回 (文本框_取对象 (名称_ID_索引, 跳过次数).写属性 (“value”, 欲写内的内容))

.子程序 文本框_置焦点, 逻辑型, 公开, 往指定的网页文本框置输入焦点
    .参数 名称_ID_索引, 文本型, , 网页文本框的文本框名称或ID或索引。从1开始。
    .参数 跳过次数, 整数型, 可空, 如果元素名称一样,可以用此参数;说明:跳过的次数，如果为0还是为不跳过，只有“是否跳过参数为真”且“跳过次数大于0的时候才会跳过”
    .局部变量 元素对象, 对象

    元素对象 ＝ 文本框_取对象 (名称_ID_索引, 跳过次数)
    元素对象.方法 (“focus”, )
    返回 (元素对象.是否为空 () ＝ 假)

.子程序 文件框_写内容, , 公开, 往指定的【文件框】写入内容
    .参数 索引_名称_ID, 文本型, , 文本框的【索引_名称_ID】，索引从1开始
    .参数 欲写内的内容, 文本型, , 欲写内的内容
    .参数 跳过次数, 整数型, 可空, 如果元素名称一样，可以用此参数。说明：跳过的次数，如果为0还是为不跳过，只有“是否跳过参数为真”且“跳过次数大于0的时候才会跳过”
    .局部变量 对象, 对象
    .局部变量 HOOK, 类_APIHOOK

    HOOK.安装 (“comdlg32.dll”, “GetOpenFileNameW”, &MyGetOpenFileNameA)
    全_文本 ＝ 欲写内的内容
    对象 ＝ 文本框_取对象 (索引_名称_ID, 跳过次数)
    对象.方法 (“click”, )
    HOOK.卸载 (“comdlg32.dll”, “GetOpenFileNameW”)

.子程序 多行文本框_取对象, 对象, , 获取指定多行文本框的对象。
    .参数 名称_ID_索引, 文本型, , 网页多行文本框的多行文本框名称或ID或索引。从1开始。
    .参数 跳过次数, 整数型, 可空, 如果元素名称一样,可以用此参数;说明:跳过的次数，如果为0还是为不跳过，只有“是否跳过参数为真”且“跳过次数大于0的时候才会跳过”

    返回 (_内部_TEXTAREA_取对象 (“textarea”, 名称_ID_索引, 跳过次数))

.子程序 多行文本框_置焦点, 逻辑型, 公开, 往指定的网页多行文本框置输入焦点
    .参数 名称_ID_索引, 文本型, , 网页多行文本框的多行文本框名称或ID或索引。从1开始。
    .参数 跳过次数, 整数型, 可空, 如果元素名称一样,可以用此参数;说明:跳过的次数，如果为0还是为不跳过，只有“是否跳过参数为真”且“跳过次数大于0的时候才会跳过”
    .局部变量 元素对象, 对象

    元素对象 ＝ 多行文本框_取对象 (名称_ID_索引, 跳过次数)
    元素对象.方法 (“focus”, )
    返回 (元素对象.是否为空 () ＝ 假)

.子程序 多行文本框_置状态, 逻辑型, 公开, 设置多行文本框的可视状态
    .参数 名称_ID_索引, 文本型, , 网页多行文本框的名称、ID、索引。索引从1开始。
    .参数 跳过次数, 整数型, 可空, 可空。如果元素名称一样,可以用此参数;说明:跳过的次数，如果为0还是为不跳过，只有“是否跳过参数为真”且“跳过次数大于0的时候才会跳过”
    .参数 隐藏, 逻辑型, 可空, 可空。默认为假。假=可视，真=隐藏

    返回 (多行文本框_取对象 (名称_ID_索引, 跳过次数).读对象型属性 (“style”, ).写属性 (“display”, 选择 (隐藏, “none”, “”)))

.子程序 多行文本框_取数量, 整数型, 公开, 取网页上的多行文本框数量。成功返回多行文本框的数量。失败返回0。
    .参数 是否标记, 逻辑型, 可空, 是否在每个多行文本框是写入标记文本。

    返回 (_内部_TEXTAREA_取数量 (“textarea”, “多行文本框”, 是否标记))

.子程序 多行文本框_取内容, 文本型, 公开, 用元素ID、名称、索引。取指定的网页多行文本框中的内容;成功返回多行文本框的内容，失败返回空文本。
    .参数 名称_ID_索引, 文本型, , 网页多行文本框的多行文本框名称、ID、索引。索引从1开始。
    .参数 跳过次数, 整数型, 可空, 如果元素名称一样,可以用此参数;说明:跳过的次数，如果为0还是为不跳过，只有“是否跳过参数为真”且“跳过次数大于0的时候才会跳过”

    返回 (多行文本框_取对象 (名称_ID_索引, 跳过次数).读文本属性 (“value”, ))

.子程序 多行文本框_取索引, 整数型, 公开, 用多行文本框名称、ID、内容取出网页上指定的多行文本框索引，失败返回0。
    .参数 名称_ID_内容, 文本型, , 网页多行文本框的多行文本框名称或ID
    .参数 跳过次数, 整数型, 可空, 如果元素名称一样,可以用此参数;说明:跳过的次数，如果为0还是为不跳过，只有“是否跳过参数为真”且“跳过次数大于0的时候才会跳过”
    .局部变量 元素索引, 整数型

    _内部_TEXTAREA_取对象 (“textarea”, 名称_ID_内容, 跳过次数, 元素索引)
    返回 (元素索引)

.子程序 多行文本框_取属性, 逻辑型, 公开, 取指定多行文本框的各种属性。成功返回真，失败返回假。
    .参数 控件索引, 整数型, , 网页控件的索引。从1开始。
    .参数 多行文本框内容, 文本型, 参考 可空, 用于装载多行文本框 内容 的变量。 
    .参数 多行文本框名称, 文本型, 参考 可空, 用于装载多行文本框 名称 的变量。 
    .参数 多行文本框ID, 文本型, 参考 可空, 用于装载多行文本框 ID 的变量。 
    .参数 元素对象, 对象, 参考 可空, 用于装载元素对象的变量。 

    元素对象 ＝ 多行文本框_取对象 (到文本 (控件索引), )
    .如果真 (是否为空 (多行文本框内容) ＝ 假)
        多行文本框内容 ＝ 元素对象.读文本属性 (“value”, )
    .如果真结束
    
    .如果真 (是否为空 (多行文本框名称) ＝ 假)
        多行文本框名称 ＝ 元素对象.读文本属性 (“name”, )
    .如果真结束
    
    .如果真 (是否为空 (多行文本框ID) ＝ 假)
        多行文本框ID ＝ 元素对象.读文本属性 (“id”, )
    .如果真结束
    
    返回 (元素对象.是否为空 () ＝ 假)

.子程序 多行文本框_写内容, 逻辑型, 公开, 往指定的网页多行文本框写入指定的内容。成功返回真，失败返回假。
    .参数 名称_ID_索引, 文本型, , 网页多行文本框的多行文本框名称或ID或索引。从1开始。
    .参数 欲写内的内容, 文本型, , 欲写内的内容
    .参数 跳过次数, 整数型, 可空, 如果元素名称一样,可以用此参数;说明:跳过的次数，如果为0还是为不跳过，只有“是否跳过参数为真”且“跳过次数大于0的时候才会跳过”

    返回 (多行文本框_取对象 (名称_ID_索引, 跳过次数).写属性 (“value”, 欲写内的内容))

.子程序 单选框_取对象, 对象, 公开, 获取到相应的元素对象
    .参数 标题_名称_ID_索引, 文本型, , 网页复选框的单选框标题、名称、ID、索引。索引从1开始。
    .参数 跳过次数, 整数型, 可空, 如果元素名称一样,可以用此参数;说明:跳过的次数，如果为0还是为不跳过，只有“是否跳过参数为真”且“跳过次数大于0的时候才会跳过”

    返回 (_内部_INPUT_取对象 (“radio”, 标题_名称_ID_索引, 跳过次数))

.子程序 单选框_取状态, 逻辑型, 公开, 判断指定的单选框是否选中，选中返回真，没选中返回假。
    .参数 标题_名称_ID_索引, 文本型
    .参数 跳过次数, 整数型, 可空, 网单选框_的索引。从1开始。

    返回 (单选框_取对象 (标题_名称_ID_索引, 跳过次数).读文本属性 (“checked”, ) ＝ “-1”)

.子程序 单选框_取数量, 整数型, 公开, 成功返回单选框的数量。失败返回0。
    .参数 是否标记, 逻辑型, 可空, 是否在每个单选框是写入标记文本。

    返回 (_内部_INPUT_取数量_复单 (“radio”, “单选框”, 是否标记))

.子程序 单选框_取索引, 整数型, 公开, 用单选框名称或ID取出网页上指定的单选框索引，失败返回0 。
    .参数 标题_名称_ID, 文本型, , 网页单选框的单选框名称或ID
    .参数 跳过次数, 整数型, 可空, 如果元素名称一样,可以用此参数;说明:跳过的次数，如果为0还是为不跳过，只有“是否跳过参数为真”且“跳过次数大于0的时候才会跳过”
    .局部变量 元素索引, 整数型

    _内部_INPUT_取对象 (“radio”, 标题_名称_ID, 跳过次数, 元素索引)
    返回 (元素索引)

.子程序 单选框_取属性, 逻辑型, 公开, 取指定单选框的各种属性。改变网页上指定的复选框状态，将它取消打勾。成功返回真，失败返回假。
    .参数 控件索引, 整数型, , 网页控件的索引。从1开始。
    .参数 元素标题, 文本型, 参考 可空, 用于装载单选框内容的变量。 
    .参数 元素名称, 文本型, 参考 可空, 用于装载单选框名称的变量。 
    .参数 元素ID, 文本型, 参考 可空, 用于装载单选框ID的变量。 
    .参数 元素类型, 文本型, 参考 可空, 用于装载单选框类型的变量。 
    .参数 元素对象, 对象, 参考 可空, 用于装载元素对象的变量。 

    元素对象 ＝ _内部_INPUT_取对象 (“radio”, 到文本 (控件索引))
    
    .如果真 (是否为空 (元素标题) ＝ 假)
        元素标题 ＝ 元素对象.读文本属性 (“title”, )
    .如果真结束
    
    .如果真 (是否为空 (元素名称) ＝ 假)
        元素名称 ＝ 元素对象.读文本属性 (“name”, )
    .如果真结束
    
    .如果真 (是否为空 (元素ID) ＝ 假)
        元素ID ＝ 元素对象.读文本属性 (“id”, )
    .如果真结束
    
    .如果真 (是否为空 (元素类型) ＝ 假)
        元素类型 ＝ 元素对象.读文本属性 (“type”, )
    .如果真结束
    返回 (元素对象.是否为空 () ＝ 假)

.子程序 单选框_选择, 逻辑型, 公开, 改变网页上指定的单选框选择状态，将它选中。成功返回真，失败返回假。
    .参数 标题_名称_ID_索引, 文本型, , 网页单选框的单选框标题、名称、ID、索引。索引从1开始。
    .参数 跳过次数, 整数型, 可空, 如果元素名称一样,可以用此参数;说明:跳过的次数，如果为0还是为不跳过，只有“是否跳过参数为真”且“跳过次数大于0的时候才会跳过”
    .参数 执行点击事件, 逻辑型, 可空, 执行鼠标单击事件，有些网页会判断你是否用过鼠标单击过。
    .局部变量 元素对象, 对象

    元素对象 ＝ 单选框_取对象 (标题_名称_ID_索引, 跳过次数)
    元素对象.写属性 (“checked”, “checked”)
    .如果真 (执行点击事件)
        网页_执行事件 (元素对象, #网页事件_onmousedown)
    .如果真结束
    返回 (元素对象.是否为空 () ＝ 假)

.子程序 单选框_取消选择, 逻辑型, 公开, 改变网页上指定的单选框选择状态，将它取消选中。成功返回真，失败返回假。
    .参数 标题_名称_ID_索引, 文本型, , 网页单选框的单选框标题、名称、ID、索引。索引从1开始。
    .参数 跳过次数, 整数型, 可空, 如果元素名称一样,可以用此参数;说明:跳过的次数，如果为0还是为不跳过，只有“是否跳过参数为真”且“跳过次数大于0的时候才会跳过”
    .参数 执行点击事件, 逻辑型, 可空, 执行鼠标单击事件，有些网页会判断你是否用过鼠标单击过。
    .局部变量 元素对象, 对象

    元素对象 ＝ 单选框_取对象 (标题_名称_ID_索引, 跳过次数)
    元素对象.写属性 (“checked”, “”)
    .如果真 (执行点击事件)
        网页_执行事件 (元素对象, #网页事件_onmousedown)
    .如果真结束
    返回 (元素对象.是否为空 () ＝ 假)

.子程序 单选框_置焦点, 逻辑型, 公开, 向指定的单选框置输入焦点
    .参数 标题_名称_ID_索引, 文本型, , 网页单选框的标题、名称、ID、索引。索引从1开始。
    .参数 跳过次数, 整数型, 可空, 如果元素名称一样,可以用此参数;说明:跳过的次数，如果为0还是为不跳过，只有“是否跳过参数为真”且“跳过次数大于0的时候才会跳过”
    .局部变量 元素对象, 对象

    元素对象 ＝ 单选框_取对象 (标题_名称_ID_索引, 跳过次数)
    元素对象.方法 (“focus”, )
    返回 (元素对象.是否为空 () ＝ 假)

.子程序 单选框_置状态, 逻辑型, 公开, 设置单选框的可视状态
    .参数 标题_名称_ID_索引, 文本型, , 网页单选框的标题、名称、ID、索引。索引从1开始。
    .参数 跳过次数, 整数型, 可空, 可空。如果元素名称一样,可以用此参数;说明:跳过的次数，如果为0还是为不跳过，只有“是否跳过参数为真”且“跳过次数大于0的时候才会跳过”
    .参数 隐藏, 逻辑型, 可空, 可空。默认为假。假=可视，真=隐藏

    返回 (单选框_取对象 (标题_名称_ID_索引, 跳过次数).读对象型属性 (“style”, ).写属性 (“display”, 选择 (隐藏, “none”, “”)))

.子程序 复选框_取对象, 对象, 公开, 获取到相应的元素对象
    .参数 标题_名称_ID_索引, 文本型, , 网页复选框的复选框标题、名称、ID、索引。索引从1开始。
    .参数 跳过次数, 整数型, 可空, 如果元素名称一样,可以用此参数;说明:跳过的次数，如果为0还是为不跳过，只有“是否跳过参数为真”且“跳过次数大于0的时候才会跳过”

    返回 (_内部_INPUT_取对象 (“checkbox”, 标题_名称_ID_索引, 跳过次数))

.子程序 复选框_取状态, 逻辑型, 公开, 判断指定的复选框是否选中，选中返回真，没选中返回假。
    .参数 标题_名称_ID_索引, 文本型, , 网页复选框的复选框标题、名称、ID、索引。索引从1开始。
    .参数 跳过次数, 整数型, 可空, 如果元素名称一样,可以用此参数;说明:跳过的次数，如果为0还是为不跳过，只有“是否跳过参数为真”且“跳过次数大于0的时候才会跳过”

    返回 (复选框_取对象 (标题_名称_ID_索引, 跳过次数).读文本属性 (“checked”, ) ＝ “-1”)

.子程序 复选框_取数量, 整数型, 公开, 成功返回复选框的数量。失败返回0。
    .参数 是否标记, 逻辑型, 可空, 是否在每个复选框是写入标记文本。

    返回 (_内部_INPUT_取数量_复单 (“checkbox”, “复选框”, 是否标记))

.子程序 复选框_取索引, 整数型, 公开, 用复选框名称或ID取出网页上指定的复选框索引，失败返回0 。
    .参数 标题_名称_ID, 文本型, , 网页复选框的复选框名称或ID
    .参数 跳过次数, 整数型, 可空, 如果元素名称一样,可以用此参数;说明:跳过的次数，如果为0还是为不跳过，只有“是否跳过参数为真”且“跳过次数大于0的时候才会跳过”
    .局部变量 元素索引, 整数型

    _内部_INPUT_取对象 (“checkbox”, 标题_名称_ID, 跳过次数, 元素索引)
    返回 (元素索引)

.子程序 复选框_取属性, 逻辑型, 公开, 取指定复选框的各种属性。改变网页上指定的复选框状态，将它取消打勾。成功返回真，失败返回假。
    .参数 控件索引, 整数型, , 网页控件的索引。从1开始。
    .参数 元素标题, 文本型, 可空, 用于装载复选框内容的变量。 
    .参数 元素名称, 文本型, 可空, 用于装载复选框名称的变量。 
    .参数 元素ID, 文本型, 可空, 用于装载复选框ID的变量。 
    .参数 元素类型, 文本型, 可空, 用于装载复选框类型的变量。 
    .参数 元素对象, 对象, 参考 可空, 用于装载元素对象的变量。 

    元素对象 ＝ _内部_INPUT_取对象 (“checkbox”, 到文本 (控件索引))
    
    .如果真 (是否为空 (元素标题) ＝ 假)
        元素标题 ＝ 元素对象.读文本属性 (“title”, )
    .如果真结束
    
    .如果真 (是否为空 (元素名称) ＝ 假)
        元素名称 ＝ 元素对象.读文本属性 (“name”, )
    .如果真结束
    
    .如果真 (是否为空 (元素ID) ＝ 假)
        元素ID ＝ 元素对象.读文本属性 (“id”, )
    .如果真结束
    
    .如果真 (是否为空 (元素类型) ＝ 假)
        元素类型 ＝ 元素对象.读文本属性 (“type”, )
    .如果真结束
    返回 (元素对象.是否为空 () ＝ 假)

.子程序 复选框_选择, 逻辑型, 公开, 改变网页上指定的复选框选择状态，将它选中。成功返回真，失败返回假。
    .参数 标题_名称_ID_索引, 文本型, , 网页复选框的复选框标题、名称、ID、索引。索引从1开始。
    .参数 跳过次数, 整数型, 可空, 如果元素名称一样,可以用此参数;说明:跳过的次数，如果为0还是为不跳过，只有“是否跳过参数为真”且“跳过次数大于0的时候才会跳过”
    .参数 执行点击事件, 逻辑型, 可空, 执行鼠标单击事件，有些网页会判断你是否用过鼠标单击过。
    .局部变量 元素对象, 对象

    元素对象 ＝ 复选框_取对象 (标题_名称_ID_索引, 跳过次数)
    元素对象.写属性 (“checked”, “checked”)
    .如果真 (执行点击事件)
        网页_执行事件 (元素对象, #网页事件_onmousedown)
    .如果真结束
    返回 (元素对象.是否为空 () ＝ 假)

.子程序 复选框_取消选择, 逻辑型, 公开, 改变网页上指定的复选框选择状态，将它取消选中。成功返回真，失败返回假。
    .参数 标题_名称_ID_索引, 文本型, , 网页复选框的复选框标题、名称、ID、索引。索引从1开始。
    .参数 跳过次数, 整数型, 可空, 如果元素名称一样,可以用此参数;说明:跳过的次数，如果为0还是为不跳过，只有“是否跳过参数为真”且“跳过次数大于0的时候才会跳过”
    .参数 执行点击事件, 逻辑型, 可空, 执行鼠标单击事件，有些网页会判断你是否用过鼠标单击过。
    .局部变量 元素对象, 对象

    元素对象 ＝ 复选框_取对象 (标题_名称_ID_索引, 跳过次数)
    元素对象.写属性 (“checked”, “”)
    .如果真 (执行点击事件)
        网页_执行事件 (元素对象, #网页事件_onmousedown)
    .如果真结束
    返回 (元素对象.是否为空 () ＝ 假)

.子程序 复选框_置焦点, 逻辑型, 公开, 向指定的复选框置输入焦点
    .参数 标题_名称_ID_索引, 文本型, , 网页复选框的复选框标题、名称、ID、索引。索引从1开始。
    .参数 跳过次数, 整数型, 可空, 如果元素名称一样,可以用此参数;说明:跳过的次数，如果为0还是为不跳过，只有“是否跳过参数为真”且“跳过次数大于0的时候才会跳过”
    .局部变量 元素对象, 对象

    元素对象 ＝ 复选框_取对象 (标题_名称_ID_索引, 跳过次数)
    元素对象.方法 (“focus”, )
    返回 (元素对象.是否为空 () ＝ 假)

.子程序 复选框_置状态, 逻辑型, 公开, 设置复选框的可视状态
    .参数 标题_名称_ID_索引, 文本型, , 网页复选框的标题、名称、ID、索引。索引从1开始。
    .参数 跳过次数, 整数型, 可空, 可空。如果元素名称一样,可以用此参数;说明:跳过的次数，如果为0还是为不跳过，只有“是否跳过参数为真”且“跳过次数大于0的时候才会跳过”
    .参数 隐藏, 逻辑型, 可空, 可空。默认为假。假=可视，真=隐藏

    返回 (复选框_取对象 (标题_名称_ID_索引, 跳过次数).读对象型属性 (“style”, ).写属性 (“display”, 选择 (隐藏, “none”, “”)))

.子程序 按钮_取对象, 对象, 公开, 获取到相应的元素对象
    .参数 标题_名称_ID_索引, 文本型, , 网页按钮的按钮标题、名称、ID、索引。索引从1开始。
    .参数 跳过次数, 整数型, 可空, 如果元素名称一样,可以用此参数;说明:跳过的次数，如果为0还是为不跳过，只有“是否跳过参数为真”且“跳过次数大于0的时候才会跳过”

    返回 (_内部_INPUT_取对象 (“button|submit|reset”, 标题_名称_ID_索引, 跳过次数))

.子程序 按钮_取属性, 逻辑型, 公开, 取指定按钮的各种属性。成功返回真，失败返回假。
    .参数 控件索引, 整数型, , 网页控件的索引。从1开始。
    .参数 按钮标题, 文本型, 参考 可空, 用于装载按钮内容的变量。 
    .参数 按钮名称, 文本型, 参考 可空, 用于装载按钮名称的变量。 
    .参数 按钮ID, 文本型, 参考 可空, 用于装载按钮ID的变量。 
    .参数 按钮类型, 文本型, 参考 可空, 用于装载按钮类型的变量。 
    .参数 元素对象, 对象, 参考 可空, 用于装载元素对象的变量。 

    元素对象 ＝ 按钮_取对象 (到文本 (控件索引), )
    .如果真 (是否为空 (按钮标题) ＝ 假)
        .判断开始 (元素对象.读文本属性 (“tagName”, ) ＝ “BUTTON”)
            按钮标题 ＝ 元素对象.读文本属性 (“innerText”, )
        .默认
            按钮标题 ＝ 元素对象.读文本属性 (“title”, )
        .判断结束
        
    .如果真结束
    .如果真 (是否为空 (按钮名称) ＝ 假)
        按钮名称 ＝ 元素对象.读文本属性 (“name”, )
    .如果真结束
    
    .如果真 (是否为空 (按钮ID) ＝ 假)
        按钮ID ＝ 元素对象.读文本属性 (“id”, )
    .如果真结束
    
    .如果真 (是否为空 (按钮类型) ＝ 假)
        按钮类型 ＝ 元素对象.读文本属性 (“type”, )
    .如果真结束
    返回 (元素对象.是否为空 () ＝ 假)

.子程序 按钮_取数量, 整数型, 公开, 成功返回按钮的数量。失败返回0。
    .参数 是否标记, 逻辑型, 可空, 是否在每个按钮是写入标记文本。

    返回 (_内部_INPUT_取数量 (“button|submit|reset”, “按钮”, 是否标记))

.子程序 按钮_取索引, 整数型, 公开, 用按钮名称或ID取出网页上指定的按钮索引，失败返回0 。
    .参数 标题_名称_ID, 文本型, , 网页按钮的按钮名称或ID
    .局部变量 元素索引, 整数型

    _内部_INPUT_取对象 (“button|submit|reset”, 标题_名称_ID, , 元素索引)
    返回 (元素索引)

.子程序 按钮_置焦点, 逻辑型, 公开, 向指定的按钮置输入焦点
    .参数 标题_名称_ID_索引, 文本型, , 网页按钮的标题、名称、ID、索引。索引从1开始。
    .参数 跳过次数, 整数型, 可空, 如果元素名称一样,可以用此参数;说明:跳过的次数，如果为0还是为不跳过，只有“是否跳过参数为真”且“跳过次数大于0的时候才会跳过”
    .局部变量 元素对象, 对象

    元素对象 ＝ 按钮_取对象 (标题_名称_ID_索引, 跳过次数)
    元素对象.方法 (“focus”, )
    返回 (元素对象.是否为空 () ＝ 假)

.子程序 按钮_置状态, 逻辑型, 公开, 设置按钮的可视状态
    .参数 标题_名称_ID_索引, 文本型, , 网页按钮的标题、名称、ID、索引。索引从1开始。
    .参数 跳过次数, 整数型, 可空, 可空。如果元素名称一样,可以用此参数;说明:跳过的次数，如果为0还是为不跳过，只有“是否跳过参数为真”且“跳过次数大于0的时候才会跳过”
    .参数 隐藏, 逻辑型, 可空, 可空。默认为假。假=可视，真=隐藏

    返回 (按钮_取对象 (标题_名称_ID_索引, 跳过次数).读对象型属性 (“style”, ).写属性 (“display”, 选择 (隐藏, “none”, “”)))

.子程序 按钮_点击, 逻辑型, 公开, 点击网页上的按钮。成功返回真，失败返回假。
    .参数 标题_名称_ID_索引, 文本型, , 网页按钮的按钮标题、名称、ID、索引。索引从1开始。
    .参数 跳过次数, 整数型, 可空, 如果元素名称一样,可以用此参数;说明:跳过的次数，如果为0还是为不跳过，只有“是否跳过参数为真”且“跳过次数大于0的时候才会跳过”
    .局部变量 元素对象, 对象

    元素对象 ＝ 按钮_取对象 (标题_名称_ID_索引, 跳过次数)
    元素对象.方法 (“click”, )
    返回 (元素对象.是否为空 () ＝ 假)

.子程序 高级按钮_取对象, 对象, 公开, 获取高级按钮的对象
    .参数 标题_名称_ID_索引, 文本型, , 网页高级按钮的高级按钮标题、名称、ID、索引。索引从1开始。
    .参数 跳过次数, 整数型, 可空, 如果元素名称一样,可以用此参数;说明:跳过的次数，如果为0还是为不跳过，只有“是否跳过参数为真”且“跳过次数大于0的时候才会跳过”

    返回 (_内部_CITE_取对象 (“cite”, 标题_名称_ID_索引, 跳过次数))

.子程序 高级按钮_取属性, 逻辑型, 公开, 取指定高级按钮的各种属性。成功返回真，失败返回假。
    .参数 控件索引, 整数型, , 网页控件的索引。从1开始。
    .参数 高级按钮标题, 文本型, 参考 可空, 用于装载高级按钮内容的变量。 
    .参数 高级按钮名称, 文本型, 参考 可空, 用于装载高级按钮名称的变量。 
    .参数 高级按钮ID, 文本型, 参考 可空, 用于装载高级按钮ID的变量。 
    .参数 元素对象, 对象, 参考 可空, 用于装载元素对象的变量。 

    元素对象 ＝ 高级按钮_取对象 (到文本 (控件索引), )
    .如果真 (是否为空 (高级按钮标题) ＝ 假)
        高级按钮标题 ＝ 元素对象.读文本属性 (“innerText”, )
    .如果真结束
    
    .如果真 (是否为空 (高级按钮名称) ＝ 假)
        高级按钮名称 ＝ 元素对象.读文本属性 (“name”, )
    .如果真结束
    
    .如果真 (是否为空 (高级按钮ID) ＝ 假)
        高级按钮ID ＝ 元素对象.读文本属性 (“id”, )
    .如果真结束
    
    返回 (元素对象.是否为空 () ＝ 假)

.子程序 高级按钮_取数量, 整数型, 公开, 成功返回高级按钮的数量。失败返回0。
    .参数 是否标记, 逻辑型, 可空, 是否在每个高级按钮是写入标记文本。

    返回 (_内部_CITE_取数量 (“cite”, “高级按钮”, 是否标记))

.子程序 高级按钮_取索引, 整数型, 公开, 用高级按钮名称或ID取出网页上指定的高级按钮索引，失败返回0 。
    .参数 标题_名称_ID, 文本型, , 网页高级按钮的高级按钮名称或ID
    .参数 跳过次数, 整数型, 可空, 如果元素名称一样,可以用此参数;说明:跳过的次数，如果为0还是为不跳过，只有“是否跳过参数为真”且“跳过次数大于0的时候才会跳过”
    .局部变量 元素索引, 整数型

    _内部_CITE_取对象 (“cite”, 标题_名称_ID, 跳过次数, 元素索引)
    返回 (元素索引)

.子程序 高级按钮_点击, 逻辑型, 公开, 点击网页上的高级按钮。成功返回真，失败返回假。
    .参数 标题_名称_ID_索引, 文本型, , 网页高级按钮的高级按钮标题、名称、ID、索引。索引从1开始。
    .参数 跳过次数, 整数型, 可空, 如果元素名称一样,可以用此参数;说明:跳过的次数，如果为0还是为不跳过，只有“是否跳过参数为真”且“跳过次数大于0的时候才会跳过”
    .局部变量 元素对象, 对象

    元素对象 ＝ 高级按钮_取对象 (标题_名称_ID_索引, 跳过次数)
    元素对象.方法 (“click”, )
    返回 (元素对象.是否为空 () ＝ 假)

.子程序 高级按钮_取源码, 文本型, 公开, 获取高级按钮的源码
    .参数 标题_名称_ID_索引, 文本型, , 网页高级按钮的高级按钮标题、名称、ID、索引。索引从1开始。
    .参数 跳过次数, 整数型, 可空, 如果元素名称一样,可以用此参数;说明:跳过的次数，如果为0还是为不跳过，只有“是否跳过参数为真”且“跳过次数大于0的时候才会跳过”

    返回 (高级按钮_取对象 (标题_名称_ID_索引, 跳过次数).读文本属性 (“outerHTML”, ))

.子程序 高级按钮_置焦点, 逻辑型, 公开, 向指定的高级按钮置输入焦点
    .参数 标题_名称_ID_索引, 文本型, , 网页高级按钮的复选框标题、名称、ID、索引。索引从1开始。
    .参数 跳过次数, 整数型, 可空, 如果元素名称一样,可以用此参数;说明:跳过的次数，如果为0还是为不跳过，只有“是否跳过参数为真”且“跳过次数大于0的时候才会跳过”
    .局部变量 元素对象, 对象

    元素对象 ＝ 高级按钮_取对象 (标题_名称_ID_索引, 跳过次数)
    元素对象.方法 (“focus”, )
    返回 (元素对象.是否为空 () ＝ 假)

.子程序 高级按钮_置状态, 逻辑型, 公开, 设置高级按钮的可视状态
    .参数 标题_名称_ID_索引, 文本型, , 网页高级按钮的标题、名称、ID、索引。索引从1开始。
    .参数 跳过次数, 整数型, 可空, 可空。如果元素名称一样,可以用此参数;说明:跳过的次数，如果为0还是为不跳过，只有“是否跳过参数为真”且“跳过次数大于0的时候才会跳过”
    .参数 隐藏, 逻辑型, 可空, 可空。默认为假。假=可视，真=隐藏

    返回 (高级按钮_取对象 (标题_名称_ID_索引, 跳过次数).读对象型属性 (“style”, ).写属性 (“display”, 选择 (隐藏, “none”, “”)))

.子程序 图形按钮_取对象, 对象, 公开, 获取到相应的元素对象
    .参数 标题_名称_ID_索引, 文本型, , 网页图片按钮的图片按钮标题、名称、ID、索引。索引从1开始。
    .参数 跳过次数, 整数型, 可空, 如果元素名称一样,可以用此参数;说明:跳过的次数，如果为0还是为不跳过，只有“是否跳过参数为真”且“跳过次数大于0的时候才会跳过”

    返回 (_内部_INPUT_取对象 (“image”, 标题_名称_ID_索引, 跳过次数))

.子程序 图形按钮_取属性, 逻辑型, 公开, 取指定图形按钮的各种属性。成功返回真，失败返回假。
    .参数 控件索引, 整数型, , 网页控件的索引。从1开始。
    .参数 图片按钮标题, 文本型, 参考 可空, 用于装载图片按钮内容的变量。 
    .参数 图片按钮名称, 文本型, 参考 可空, 用于装载图片按钮名称的变量。 
    .参数 图片按钮ID, 文本型, 参考 可空, 用于装载图片按钮ID的变量。 
    .参数 图片按钮类型, 文本型, 参考 可空, 用于装载图片按钮类型的变量。 
    .参数 元素对象, 对象, 参考 可空, 用于装载元素对象的变量。 

    元素对象 ＝ 图形按钮_取对象 (到文本 (控件索引), )
    .如果真 (是否为空 (图片按钮标题) ＝ 假)
        图片按钮标题 ＝ 元素对象.读文本属性 (“title”, )
    .如果真结束
    
    .如果真 (是否为空 (图片按钮名称) ＝ 假)
        图片按钮名称 ＝ 元素对象.读文本属性 (“name”, )
    .如果真结束
    
    .如果真 (是否为空 (图片按钮ID) ＝ 假)
        图片按钮ID ＝ 元素对象.读文本属性 (“id”, )
    .如果真结束
    
    .如果真 (是否为空 (图片按钮类型) ＝ 假)
        图片按钮类型 ＝ 元素对象.读文本属性 (“type”, )
    .如果真结束
    
    返回 (元素对象.是否为空 () ＝ 假)

.子程序 图形按钮_取数量, 整数型, 公开, 成功返回图形按钮的数量。失败返回0。
    .参数 是否标记, 逻辑型, 可空, 是否在每个图片按钮是写入标记文本。

    返回 (_内部_INPUT_取数量 (“image”, “图形按钮”, 是否标记))

.子程序 图形按钮_取索引, 整数型, 公开, 用图形按钮名称或ID取出网页上指定的图形按钮索引，失败返回0 。
    .参数 标题_名称_ID, 文本型, , 网页图片按钮的图片按钮名称或ID
    .参数 跳过次数, 整数型, 可空, 如果元素名称一样,可以用此参数;说明:跳过的次数，如果为0还是为不跳过，只有“是否跳过参数为真”且“跳过次数大于0的时候才会跳过”
    .局部变量 元素索引, 整数型

    _内部_INPUT_取对象 (“image”, 标题_名称_ID, 跳过次数, 元素索引)
    返回 (元素索引)

.子程序 图形按钮_点击, 逻辑型, 公开, 点击网页上的图形按钮。成功返回真，失败返回假。
    .参数 标题_名称_ID_索引, 文本型, , 网页图片按钮的图片按钮标题、名称、ID、索引。索引从1开始。
    .参数 跳过次数, 整数型, 可空, 如果元素名称一样,可以用此参数;说明:跳过的次数，如果为0还是为不跳过，只有“是否跳过参数为真”且“跳过次数大于0的时候才会跳过”
    .局部变量 元素对象, 对象

    元素对象 ＝ 图形按钮_取对象 (标题_名称_ID_索引, 跳过次数)
    元素对象.方法 (“click”, )
    返回 (元素对象.是否为空 () ＝ 假)

.子程序 图形按钮_取源码, 文本型, 公开, 获取指定图形按钮的源码
    .参数 标题_名称_ID_索引, 文本型, , 网页图片按钮的图片按钮标题、名称、ID、索引。索引从1开始。
    .参数 跳过次数, 整数型, 可空, 如果元素名称一样,可以用此参数;说明:跳过的次数，如果为0还是为不跳过，只有“是否跳过参数为真”且“跳过次数大于0的时候才会跳过”

    返回 (图形按钮_取对象 (标题_名称_ID_索引, 跳过次数).读文本属性 (“outerHTML”, ))

.子程序 图形按钮_置焦点, 逻辑型, 公开, 向指定的图形按钮置输入焦点
    .参数 标题_名称_ID_索引, 文本型, , 网页图形按钮的复选框标题、名称、ID、索引。索引从1开始。
    .参数 跳过次数, 整数型, 可空, 如果元素名称一样,可以用此参数;说明:跳过的次数，如果为0还是为不跳过，只有“是否跳过参数为真”且“跳过次数大于0的时候才会跳过”
    .局部变量 元素对象, 对象

    元素对象 ＝ 图形按钮_取对象 (标题_名称_ID_索引, 跳过次数)
    元素对象.方法 (“focus”, )
    返回 (元素对象.是否为空 () ＝ 假)

.子程序 链接_取对象, 对象, 公开, 获取链接的元素对象
    .参数 地址_ID_索引_标题, 文本型, , 网页链接的标题、地址、ID、索引。索引从1开始。
    .参数 跳过次数, 整数型, 可空, 如果元素名称一样,可以用此参数;说明:跳过的次数，如果为0还是为不跳过，只有“是否跳过参数为真”且“跳过次数大于0的时候才会跳过”

    返回 (_内部_A_取对象 (“a”, 地址_ID_索引_标题, 跳过次数))

.子程序 链接_取数量, 整数型, 公开, 取网页上的超级链接数目,成功返回链接数目，否则返回0。
    .参数 是否标记, 逻辑型, 可空, 是否在每个按钮是写入标记文本。

    返回 (_内部_A_取数量 (“a”, “链”, 是否标记))

.子程序 链接_取属性, 逻辑型, 公开, 取指定链接的各种属性。成功返回真。失败返回假。 
    .参数 控件索引, 整数型, , 网页控件的索引。从1开始。
    .参数 链接标题, 文本型, 可空, 用于装载 链接内容 的变量。 
    .参数 链接地址, 文本型, 可空, 用于装载 链接类型 的变量。 
    .参数 元素名称, 文本型, 可空, 用于装载 元素名称 的变量。
    .参数 元素ID, 文本型, 可空, 用于装载 元素ID 的变量。
    .参数 元素对象, 对象, 参考 可空, 用于装载 元素对象 的变量。 

    元素对象 ＝ 链接_取对象 (到文本 (控件索引), )
    .如果真 (是否为空 (链接标题) ＝ 假)
        链接标题 ＝ 元素对象.读文本属性 (“innerText”, )
    .如果真结束
    
    .如果真 (是否为空 (链接地址) ＝ 假)
        链接地址 ＝ 元素对象.读文本属性 (“href”, )
    .如果真结束
    
    .如果真 (是否为空 (元素ID) ＝ 假)
        元素ID ＝ 元素对象.读文本属性 (“id”, )
    .如果真结束
    
    .如果真 (是否为空 (元素名称) ＝ 假)
        元素名称 ＝ 元素对象.读文本属性 (“name”, )
    .如果真结束
    
    返回 (元素对象.是否为空 () ＝ 假)

.子程序 链接_取索引, 整数型, 公开, 用链接名称或ID取出网页上指定的链接索引，失败返回0 。
    .参数 地址_ID_索引_标题, 文本型, , 网页链接的标题、地址、ID、索引。索引从1开始。
    .参数 跳过次数, 整数型, 可空, 如果元素名称一样,可以用此参数;说明:跳过的次数，如果为0还是为不跳过，只有“是否跳过参数为真”且“跳过次数大于0的时候才会跳过”
    .局部变量 元素索引, 整数型

    _内部_A_取对象 (“a”, 地址_ID_索引_标题, 跳过次数, 元素索引)
    返回 (元素索引)

.子程序 链接_点击, 逻辑型, 公开, 点击网页上的链接。成功返回真。失败返回假。 
    .参数 地址_ID_索引_标题, 文本型, , 网页链接的标题、地址、ID、索引。索引从1开始。
    .参数 跳过次数, 整数型, 可空, 如果元素名称一样,可以用此参数;说明:跳过的次数，如果为0还是为不跳过，只有“是否跳过参数为真”且“跳过次数大于0的时候才会跳过”
    .参数 点击后在本窗口打开, 逻辑型, 可空, 可空。点击链接后,在本窗口内打开点击的链接地址
    .局部变量 元素对象, 对象

    元素对象 ＝ 链接_取对象 (地址_ID_索引_标题, 跳过次数)
    元素对象.写属性 (“target”, 选择 (点击后在本窗口打开, “_self”, “_blank”))
    元素对象.方法 (“click”, )
    返回 (元素对象.是否为空 () ＝ 假)

.子程序 链接_取源码, 文本型, 公开, 获取指定链接的源码。
    .参数 地址_ID_索引_标题, 文本型, , 网页链接的标题、地址、ID、索引。索引从1开始。
    .参数 跳过次数, 整数型, 可空, 如果元素名称一样,可以用此参数;说明:跳过的次数，如果为0还是为不跳过，只有“是否跳过参数为真”且“跳过次数大于0的时候才会跳过”

    返回 (链接_取对象 (地址_ID_索引_标题, 跳过次数).读文本属性 (“outerHTML”, ))

.子程序 链接_取标题, 文本型, 公开, 获取指定链接的标题。
    .参数 地址_ID_索引_标题, 文本型, , 网页链接的标题、地址、ID、索引。索引从1开始。
    .参数 跳过次数, 整数型, 可空, 如果元素名称一样,可以用此参数;说明:跳过的次数，如果为0还是为不跳过，只有“是否跳过参数为真”且“跳过次数大于0的时候才会跳过”

    返回 (链接_取对象 (地址_ID_索引_标题, 跳过次数).读文本属性 (“innerText”, ))

.子程序 链接_置焦点, 逻辑型, 公开, 向指定的链接置输入焦点
    .参数 地址_ID_索引_标题, 文本型, , 网页链接的标题、地址、ID、索引。索引从1开始。
    .参数 跳过次数, 整数型, 可空, 如果元素名称一样,可以用此参数;说明:跳过的次数，如果为0还是为不跳过，只有“是否跳过参数为真”且“跳过次数大于0的时候才会跳过”
    .局部变量 元素对象, 对象

    元素对象 ＝ 链接_取对象 (地址_ID_索引_标题, 跳过次数)
    元素对象.方法 (“focus”, )
    返回 (元素对象.是否为空 () ＝ 假)

.子程序 链接_置状态, 逻辑型, 公开, 设置链接的可视状态
    .参数 地址_ID_索引_标题, 文本型, , 网页链接的标题、地址、ID、索引。索引从1开始。
    .参数 跳过次数, 整数型, 可空, 可空。如果元素名称一样,可以用此参数;说明:跳过的次数，如果为0还是为不跳过，只有“是否跳过参数为真”且“跳过次数大于0的时候才会跳过”
    .参数 隐藏, 逻辑型, 可空, 可空。默认为假。假=可视，真=隐藏

    返回 (链接_取对象 (地址_ID_索引_标题, 跳过次数).读对象型属性 (“style”, ).写属性 (“display”, 选择 (隐藏, “none”, “”)))

.子程序 链接_枚举, 整数型, 公开, 枚举出所有超级链接，成功返回链接数量，失败返回0。
    .参数 标题数组, 文本型, 参考 可空 数组, 可空。请提供一个 文本型 的数组变量，用于存放 标题数组
    .参数 地址数组, 文本型, 参考 可空 数组, 可空。请提供一个 文本型 的数组变量，用于存放 地址数组
    .参数 元素名称数组, 文本型, 参考 可空 数组, 可空。请提供一个 文本型 的数组变量，用于存放 元素名称数组
    .参数 元素ID数组, 文本型, 参考 可空 数组, 可空。请提供一个 文本型 的数组变量，用于存放 元素ID数组

    返回 (_内部_A_取数量 (“a”, “链”, , 真, 地址数组, 标题数组, 元素名称数组, 元素ID数组))

.子程序 网页_验证码同步, 字节集, 公开, 直接同步网页上验证码回来，并且可以对图片进行格式转换
    .参数 验证码地址, 文本型, , 如果验证码地址包含?号,只需要填写问号之前的地址(包括?号)
    .参数 返回格式, 整数型, 可空, 可空。默认不转换   1=bmp　2=jpg　3=gif　4=tiff　5=png
    .局部变量 rang, 对象
    .局部变量 验证码, 字节集

    rang ＝ 集_网页文档.读对象型属性 (“body”, ).对象型方法 (“createControlRange”, )
    rang.方法 (“add”, 图片_取对象 (验证码地址))
    .如果真 (取反 (rang.逻辑方法 (“execCommand”, “copy”, 假, 0)))
        返回 ({ })
    .如果真结束
    验证码 ＝ 方法_取回验证码 ()
    .如果真 (返回格式 ≠ 0)
        图片_转换 (验证码, 返回格式, , 验证码)
    .如果真结束
    返回 (验证码)

.子程序 方法_取回验证码, 字节集
    .局部变量 图片句柄, 整数型
    .局部变量 信息, _验证码取图
    .局部变量 lpData, 整数型
    .局部变量 指针, 整数型
    .局部变量 位图, 字节集
    .局部变量 bmp, BITMAP
    .局部变量 私画布句柄, 整数型

    OpenClipboard (0)
    图片句柄 ＝ GetClipboardData (2)
    .如果真 (图片句柄 ＝ 0)
        CloseClipboard ()
        返回 ({ })
    .如果真结束
    .如果真 (GetObjectA (图片句柄, 28, bmp) ＝ 0)
        CloseClipboard ()
        返回 ({ })
    .如果真结束
    信息.biSize ＝ 40
    信息.biWidth ＝ bmp.bmWidth
    信息.biHeight ＝ bmp.bmHeight
    信息.biPlanes ＝ 1
    信息.biBitCount ＝ 24
    信息.biCompression ＝ 0
    信息.biSizeImage ＝ (bmp.bmWidth × 24 ＋ 31) ÷ 8 × bmp.bmHeight
    信息.biXPelsPerMeter ＝ 0
    信息.biYPelsPerMeter ＝ 0
    信息.biClrUsed ＝ 0
    信息.biClrImportant ＝ 0
    私画布句柄 ＝ CreateCompatibleDC (0)
    位图 ＝ 取空白字节集 (信息.biSizeImage)
    lpData ＝ lstrcpyn_字节集 (位图, 位图, 0)
    _位图复制2 (私画布句柄, 图片句柄, 0, 信息.biHeight, lpData, 信息, 0)
    DeleteDC (私画布句柄)
    EmptyClipboard ()
    CloseClipboard ()
    位图 ＝ 到字节集 (“BM”) ＋ 整数_到字节集 (信息.biSizeImage ＋ 54) ＋ 取空白字节集 (4) ＋ { 54, 0, 0, 0, 40, 0, 0, 0 } ＋ 整数_到字节集 (bmp.bmWidth) ＋ 整数_到字节集 (bmp.bmHeight) ＋ { 1, 0, 24, 0 } ＋ 取空白字节集 (4) ＋ 整数_到字节集 (信息.biSizeImage) ＋ 取空白字节集 (16) ＋ 指针到字节集 (lpData, 信息.biSizeImage)
    返回 (位图)

.子程序 图片_点击, 逻辑型, 公开, 点击网页上带有链接的图片。
    .参数 索引_地址_ID_title, 文本型, 可空, 可以为“索引_地址_ID_title”。索引从1开始。
    .参数 跳过次数, 整数型, 可空, 如果元素名称一样,可以用此参数;说明:跳过的次数，如果为0还是为不跳过，只有“是否跳过参数为真”且“跳过次数大于0的时候才会跳过”
    .局部变量 元素对象, 对象

    元素对象 ＝ _内部_IMG_取对象 (“image”, 索引_地址_ID_title, 跳过次数)
    元素对象.方法 (“click”, )
    返回 (元素对象.是否为空 () ＝ 假)

.子程序 图片_取对象, 对象, 公开, 获取指定图片的对象
    .参数 索引_地址_ID_title, 文本型, , 网页图片的“索引_地址_ID_title”。索引从1开始。
    .参数 跳过次数, 整数型, 可空, 如果元素名称一样,可以用此参数;说明:跳过的次数，如果为0还是为不跳过，只有“是否跳过参数为真”且“跳过次数大于0的时候才会跳过”

    返回 (_内部_IMG_取对象 (“image”, 索引_地址_ID_title, 跳过次数))

.子程序 图片_枚举, 整数型, 公开, 枚举当前网页上的所有图片地址和图片标题，返回图片的数目，失败返回0 。
    .参数 地址数组, 文本型, 参考 可空 数组, 用于存放 图片地址 数组的变量。
    .参数 图片宽度, 文本型, 参考 可空 数组, 用于存放 图片宽度 数组的变量。
    .参数 图片高度, 文本型, 参考 可空 数组, 用于存放 图片高度 数组的变量。
    .参数 图片名称, 文本型, 参考 可空 数组, 用于存放 图片名称 数组的变量。
    .参数 图片ID, 文本型, 参考 可空 数组, 用于存放 图片ID 数组的变量。
    .参数 图片标题, 文本型, 参考 可空 数组, 用于存放 图片标题 数组的变量。

    返回 (_内部_IMG_取数量 (“image”, “图片”, , 真, 地址数组, 图片宽度, 图片高度, 图片名称, 图片ID, 图片标题))

.子程序 图片_取数量, 整数型, 公开, 取网页上的图片数目,成功点击返回图片数目，否则返回0。
    .参数 是否标记, 逻辑型, 可空, 是否在每个图片上是写入标记文本，把鼠标放在上面即可看到。

    返回 (_内部_IMG_取数量 (“image”, “图片”, 是否标记))

.子程序 图片_取属性, 逻辑型, 公开, 取指定图片的地址。失败返回空文本。
    .参数 控件索引, 整数型, , 网页控件的索引。从1开始。
    .参数 图片地址, 文本型, 可空
    .参数 图片宽度, 文本型, 可空, 用于装载图片宽度的变量。
    .参数 图片高度, 文本型, 可空, 用于装载图片高度的变量。
    .参数 图片标题, 文本型, 可空, 用于装载图片标题的变量。
    .参数 图片名称, 文本型, 可空, 用于装载图片名称的变量。
    .参数 图片ID, 文本型, 可空, 用于装载图片ID的变量。
    .参数 元素对象, 对象, 参考 可空, 用于装载元素对象的变量。 

    元素对象 ＝ _内部_IMG_取对象 (“image”, 到文本 (控件索引), )
    .如果真 (是否为空 (图片地址) ＝ 假)
        图片地址 ＝ 元素对象.读文本属性 (“src”, )
    .如果真结束
    
    .如果真 (是否为空 (图片宽度) ＝ 假)
        图片宽度 ＝ 元素对象.读文本属性 (“width”, )
    .如果真结束
    
    .如果真 (是否为空 (图片高度) ＝ 假)
        图片高度 ＝ 元素对象.读文本属性 (“height”, )
    .如果真结束
    
    .如果真 (是否为空 (图片标题) ＝ 假)
        图片标题 ＝ 元素对象.读文本属性 (“title”, )
    .如果真结束
    
    .如果真 (是否为空 (图片名称) ＝ 假)
        图片名称 ＝ 元素对象.读文本属性 (“name”, )
    .如果真结束
    
    .如果真 (是否为空 (图片ID) ＝ 假)
        图片ID ＝ 元素对象.读文本属性 (“id”, )
    .如果真结束
    返回 (元素对象.是否为空 () ＝ 假)

.子程序 图片_取索引, 整数型, 公开, 用图片地址取出网页上指定的图片索引，失败返回0 。
    .参数 地址_名称_ID_title, 文本型, , 网页图片的图片 地址_ID
    .参数 跳过次数, 整数型, 可空, 如果元素名称一样,可以用此参数;说明:跳过的次数，如果为0还是为不跳过，只有“是否跳过参数为真”且“跳过次数大于0的时候才会跳过”
    .局部变量 元素索引, 整数型

    _内部_IMG_取对象 (“image”, 地址_名称_ID_title, 跳过次数, 元素索引)
    返回 (元素索引)

.子程序 图片_置状态, 逻辑型, 公开, 设置链接的可视状态
    .参数 索引_地址_ID_title, 文本型, , 网页图片的“索引_地址_ID_title”。索引从1开始。
    .参数 跳过次数, 整数型, 可空, 可空。如果元素名称一样,可以用此参数;说明:跳过的次数，如果为0还是为不跳过，只有“是否跳过参数为真”且“跳过次数大于0的时候才会跳过”
    .参数 隐藏, 逻辑型, 可空, 可空。默认为假。假=可视，真=隐藏

    返回 (图片_取对象 (索引_地址_ID_title, 跳过次数).读对象型属性 (“style”, ).写属性 (“display”, 选择 (隐藏, “none”, “”)))

.子程序 组合框_操作, 逻辑型
    .参数 组合框索引, 整数型, 可空
    .参数 操作类型, 整数型, 可空, 0=取项目数。1=取项目文本。2=置项目文本。3=取项目数值。4=置项目数值。5=取现行选中项。6=置现行选中项。7=按项文本选择。10=标记。
    .参数 项目索引, 整数型, 可空
    .参数 组合框项目数, 整数型, 参考 可空
    .参数 项目文本, 文本型, 可空
    .参数 要写入的项目文本, 文本型, 可空
    .参数 项目数值, 文本型, 可空
    .参数 要写入的项目数值, 文本型, 可空
    .参数 组合框数量, 整数型, 参考 可空
    .参数 是否标记, 逻辑型, 可空
    .参数 现行选中项, 整数型, 参考 可空
    .参数 按项文本选择, 文本型, 可空
    .参数 返回的对象, 对象, 参考 可空
    .局部变量 二级计次, 整数型
    .局部变量 对象, 对象
    .局部变量 控件数量, 整数型
    .局部变量 控件类型数组, 文本型, , "0"
    .局部变量 控件类型数量, 整数型
    .局部变量 是否成功, 逻辑型
    .局部变量 计次, 整数型

    控件类型数组 ＝ 分割文本 (“select-one|select”, “|”, )
    控件类型数量 ＝ 取数组成员数 (控件类型数组)
    .如果真 (控件类型数量 ＞ 0)
        ' 对象 ＝ 集_网页文档.读对象型属性 (“getElementsByTagName”, “select”)
        对象 ＝ 集_网页文档.读对象型属性 (“body”, ).读对象型属性 (“all”, ).对象型方法 (“tags”, “select”)
        .计次循环首 (对象.读数值属性 (“length”, ), 二级计次)
            返回的对象 ＝ 对象.对象型方法 (“item”, 二级计次 － 1)
            控件数量 ＝ 控件数量 ＋ 1
            .如果真 (操作类型 ＝ 10)
                .如果真 (是否标记)
                    返回的对象.写属性 (“selectedIndex”, 0)
                    返回的对象.对象型方法 (“item”, 0).写属性 (“text”, “组合框” ＋ 到文本 (控件数量))
                .如果真结束
                到循环尾 ()
            .如果真结束
            .如果真 (组合框索引 ＝ 控件数量)
                .判断开始 (操作类型 ＝ 0)
                    组合框项目数 ＝ 返回的对象.读数值属性 (“length”, )
                    返回 (真)
                .判断 (操作类型 ＝ 1) ' 取项目文本
                    项目文本 ＝ 返回的对象.对象型方法 (“item”, 项目索引 － 1).读文本属性 (“text”, )
                    返回 (真)
                .判断 (操作类型 ＝ 2) ' 置项目文本
                    返回 (返回的对象.对象型方法 (“item”, 项目索引 － 1).写属性 (“text”, 要写入的项目文本))
                .判断 (操作类型 ＝ 3) ' 取项目数值
                    项目数值 ＝ 返回的对象.对象型方法 (“item”, 项目索引 － 1).读文本属性 (“value”, )
                    返回 (真)
                .判断 (操作类型 ＝ 4) ' 置项目数值
                    返回 (返回的对象.对象型方法 (“item”, 项目索引 － 1).写属性 (“value”, 要写入的项目数值))
                .判断 (操作类型 ＝ 5) ' 取现行选中项
                    现行选中项 ＝ 返回的对象.读数值属性 (“selectedIndex”, )
                    返回 (真)
                .判断 (操作类型 ＝ 6) ' 置现行选中项
                    处理事件 ()
                    延时 (10)
                    是否成功 ＝ 返回的对象.写属性 (“selectedIndex”, 项目索引 － 1)
                    返回的对象.方法 (“fireEvent”, “onchange”)
                    返回 (是否成功)
                .判断 (操作类型 ＝ 7)
                    组合框项目数 ＝ 返回的对象.读数值属性 (“length”, )
                    .计次循环首 (组合框项目数, 计次)
                        .如果真 (返回的对象.对象型方法 (“item”, 计次 － 1).读文本属性 (“text”, ) ＝ 按项文本选择)
                            处理事件 ()
                            延时 (10)
                            是否成功 ＝ 返回的对象.写属性 (“selectedIndex”, 计次 － 1)
                            返回的对象.方法 (“fireEvent”, “onchange”)
                            返回 (是否成功)
                        .如果真结束
                        
                    .计次循环尾 ()
                .默认
                    
                .判断结束
                
            .如果真结束
            
        .计次循环尾 ()
    .如果真结束
    组合框数量 ＝ 控件数量
    返回 (假)

.子程序 组合框_取所有属性, 整数型, 公开, 取出组合框的全部属性。成功返回组合框数量。失败返回0。
    .参数 组合框项目数, 整数型, 参考 可空 数组, 用于装载组合框项目数的变量。
    .参数 所属类型, 文本型, 参考 可空 数组, 用于装载所属类型的变量。
    .参数 控件名称, 文本型, 参考 可空 数组, 用于装载控件名称的变量。
    .参数 控件ID, 文本型, 参考 可空 数组, 用于装载控件ID的变量。
    .参数 引用代码, 文本型, 参考 可空 数组, 用于装载引用代码的变量。
    .参数 是否标记, 逻辑型, 可空, 是否把每个组合框做上标记。
    .局部变量 文档数组, 对象, , "0"
    .局部变量 文档数量, 整数型
    .局部变量 一级计次, 整数型
    .局部变量 二级计次, 整数型
    .局部变量 对象, 对象
    .局部变量 临时对象, 对象
    .局部变量 控件数量, 整数型
    .局部变量 控件类型数组, 文本型, , "0"
    .局部变量 控件类型数量, 整数型
    .局部变量 是否成功, 逻辑型
    .局部变量 计次, 整数型

    控件类型数组 ＝ 分割文本 (“select-one|select”, “|”, )
    控件类型数量 ＝ 取数组成员数 (控件类型数组)
    .如果真 (控件类型数量 ＞ 0)
        对象 ＝ 集_网页文档.读对象型属性 (“getElementsByTagName”, “select”) ' 取得第一个框架
        .计次循环首 (对象.读数值属性 (“length”, ), 二级计次)
            临时对象 ＝ 对象.对象型方法 (“item”, 二级计次 － 1)
            控件数量 ＝ 控件数量 ＋ 1
            加入成员 (所属类型, 临时对象.读文本属性 (“type”, ))
            加入成员 (控件名称, 临时对象.读文本属性 (“name”, ))
            加入成员 (控件ID, 临时对象.读文本属性 (“ID”, ))
            加入成员 (组合框项目数, 临时对象.读数值属性 (“length”, ))
            加入成员 (引用代码, 临时对象.读文本属性 (“outerHTML”, ))
            .如果真 (是否标记)
                临时对象.写属性 (“selectedIndex”, 0)
                临时对象.对象型方法 (“item”, 0).写属性 (“text”, “组合框” ＋ 到文本 (控件数量))
            .如果真结束
            
        .计次循环尾 ()
        
        
    .如果真结束
    返回 (控件数量)

.子程序 组合框_取数量, 整数型, 公开, 取网页上的组合框数目,成功点击返回图片数目，否则返回0。
    .参数 是否标记, 逻辑型, 可空, 是否在每个组合框是写入标记文本。
    .局部变量 组合框数量, 整数型

    组合框_操作 (, 10, , , , , , , 组合框数量, 是否标记)
    返回 (组合框数量)

.子程序 组合框_取项目数, 整数型, 公开, 取指定组合框的项目数。成功返回项目数目，失败返回0。
    .参数 组合框索引, 整数型, , 索引从1开始。
    .局部变量 项目数, 整数型

    组合框_操作 (组合框索引, 0, , 项目数)
    返回 (项目数)

.子程序 组合框_取项目文本, 文本型, 公开, 取指定组合框的项目文本。成功返回项目文本，失败返回空文本。
    .参数 组合框索引, 整数型, , 索引从1开始。
    .参数 项目索引, 整数型, , 项目索引,从0开始。
    .局部变量 临时文本, 文本型

    组合框_操作 (组合框索引, 1, 项目索引, , 临时文本, , , , , , , , )
    返回 (临时文本)

.子程序 组合框_置项目文本, 逻辑型, 公开, 修改指定组合框的项目文本。成功返回真，失败返回假。
    .参数 组合框索引, 整数型, , 索引从1开始。
    .参数 项目索引, 整数型, , 项目索引,从0开始。
    .参数 项目文本, 文本型, , 要写入的项目文本。

    返回 (组合框_操作 (组合框索引, 2, 项目索引, , , 项目文本, , , , , , , ))

.子程序 组合框_取项目数值, 文本型, 公开, 取指定组合框的项目数值。成功返回项目数值，失败返回空文本。
    .参数 组合框索引, 整数型, , 索引从1开始。
    .参数 项目索引, 整数型, , 项目索引,从0开始。
    .局部变量 临时文本, 文本型

    组合框_操作 (组合框索引, 3, 项目索引, , , , 临时文本, , , )
    返回 (临时文本)

.子程序 组合框_置项目数值, 逻辑型, 公开, 修改指定组合框的项目数值。成功返回真，失败返回假。
    .参数 组合框索引, 整数型, , 索引从1开始。
    .参数 项目索引, 整数型, , 项目索引,从0开始。
    .参数 项目数值, 文本型, , 要写入的项目数值。

    返回 (组合框_操作 (组合框索引, 4, 项目索引, , , , , 项目数值, , , ))

.子程序 组合框_取现行选中项, 整数型, 公开, 取指定组合框的现行选中项。成功返回项目索引，失败返回0。
    .参数 组合框索引, 整数型, , 索引从1开始。
    .局部变量 现行选中项, 整数型

    组合框_操作 (组合框索引, 5, , , , , , , , , 现行选中项)
    返回 (现行选中项)

.子程序 组合框_置现行选中项, 逻辑型, 公开, 按索引修改指定组合框的现行选中项。成功返回真，失败返回假。
    .参数 组合框索引, 整数型, , 索引从1开始。
    .参数 项目索引, 整数型, , 项目索引,从0开始。

    返回 (组合框_操作 (组合框索引, 6, 项目索引))

.子程序 组合框_按项目文本选择, 逻辑型, 公开, 按项目文本修改指定组合框的现行选中项。成功返回真，失败返回假。
    .参数 组合框索引, 整数型, , 索引从1开始。
    .参数 项目文本, 文本型, , 要选择的项目文本。如果组合框里有个2008的项目，直接写2008就OK了。

    返回 (组合框_操作 (组合框索引, 7, , , , , , , , , , 项目文本))

.子程序 组合框_置焦点, 逻辑型, 公开, 向指定的组合框置输入焦点
    .参数 组合框索引, 整数型, , 索引从1开始。
    .局部变量 元素对象, 对象

    组合框_操作 (组合框索引, , , , , , , , , , , , 元素对象)
    元素对象.方法 (“focus”, )
    返回 (元素对象.是否为空 () ＝ 假)

.子程序 组合框_置状态, 逻辑型, 公开, 设置组合框的可视状态
    .参数 组合框索引, 整数型, , 索引从1开始。
    .参数 隐藏, 逻辑型, 可空, 可空。默认为假。假=可视，真=隐藏
    .局部变量 元素对象, 对象

    组合框_操作 (组合框索引, , , , , , , , , , , , 元素对象)
    返回 (元素对象.读对象型属性 (“style”, ).写属性 (“display”, 选择 (隐藏, “none”, “”)))

.子程序 表格_初始化, 文本型
    .参数 操作类型, 整数型, , 0=取数量,1=取文本,2=取源码,3=取单元格数量,4=取行数,5=取列数,6=取单元格文本,7=取单元格源码,8=置单元格文本
    .参数 表格索引, 整数型, 可空
    .参数 行索引, 整数型, 可空
    .参数 列索引, 整数型, 可空
    .参数 要置入的单元格文本, 文本型, 可空
    .局部变量 局_临时对象, 对象
    .局部变量 局_表格对象, 对象
    .局部变量 局_计次, 整数型

    局_临时对象 ＝ 集_网页文档.读对象型属性 (“body”, ).对象型方法 (“all”, )
    局_表格对象 ＝ 局_临时对象.对象型方法 (“tags”, “table”)
    .判断开始 (操作类型 ＝ 0)
        返回 (到文本 (局_表格对象.读数值属性 (“length”, )))
    .判断 (操作类型 ＝ 1)
        返回 (局_表格对象.对象型方法 (“item”, 表格索引 － 1).读文本属性 (“outerText”, ))
    .判断 (操作类型 ＝ 2)
        返回 (局_表格对象.对象型方法 (“item”, 表格索引 － 1).读文本属性 (“outerHTML”, ))
    .判断 (操作类型 ＝ 3)
        返回 (到文本 (局_表格对象.对象型方法 (“item”, 表格索引 － 1).读对象型属性 (“cells”, ).读数值属性 (“length”, )))
    .判断 (操作类型 ＝ 4) ' 取行数
        返回 (到文本 (局_表格对象.对象型方法 (“item”, 表格索引 － 1).读对象型属性 (“rows”, ).读数值属性 (“length”, )))
    .判断 (操作类型 ＝ 5) ' 取列数
        局_临时对象 ＝ 局_表格对象.对象型方法 (“item”, 表格索引 － 1).读对象型属性 (“rows”, )
        返回 (到文本 (局_临时对象.对象型方法 (“item”, 行索引 － 1).读对象型属性 (“cells”, ).读数值属性 (“length”, )))
    .判断 (操作类型 ＝ 6) ' 取单元格文本
        局_临时对象 ＝ 局_表格对象.对象型方法 (“item”, 表格索引 － 1).对象型方法 (“rows”, )
        局_临时对象 ＝ 局_临时对象.对象型方法 (“item”, 行索引 － 1).读对象型属性 (“cells”, )
        返回 (局_临时对象.对象型方法 (“item”, 列索引 － 1).读文本属性 (“outerText”, ))
    .判断 (操作类型 ＝ 7) ' 取单元格源码
        局_临时对象 ＝ 局_表格对象.对象型方法 (“item”, 表格索引 － 1).对象型方法 (“rows”, )
        局_临时对象 ＝ 局_临时对象.对象型方法 (“item”, 行索引 － 1).读对象型属性 (“cells”, )
        返回 (局_临时对象.对象型方法 (“item”, 列索引 － 1).读文本属性 (“outerHTML”, ))
    .判断 (操作类型 ＝ 8) ' 置单元格文本
        局_临时对象 ＝ 局_表格对象.对象型方法 (“item”, 表格索引 － 1).对象型方法 (“rows”, )
        局_临时对象 ＝ 局_临时对象.对象型方法 (“item”, 行索引 － 1).读对象型属性 (“cells”, )
        返回 (到文本 (局_临时对象.对象型方法 (“item”, 列索引 － 1).写属性 (“innerText”, 要置入的单元格文本)))
    .默认
        
    .判断结束
    返回 (“0”)

.子程序 表格_取数量, 整数型, 公开, 取得当前网页内的表格(table)的数目
    返回 (到数值 (表格_初始化 (0)))

.子程序 表格_取文本, 文本型, 公开, 取出指定表格内的所有单元格的文本
    .参数 表格索引, 整数型, , 表格索引从1开始

    返回 (表格_初始化 (1, 表格索引))

.子程序 表格_取源码, 文本型, 公开, 取出指定表格内的所有单元格的源码
    .参数 表格索引, 整数型, , 表格索引从1开始

    返回 (表格_初始化 (2, 表格索引))

.子程序 表格_取行数, 整数型, 公开, 取出指定表格内的行数
    .参数 表格索引, 整数型, , 表格索引从1开始

    返回 (到数值 (表格_初始化 (4, 表格索引)))

.子程序 表格_取列数, 整数型, 公开, 取出指定表格内的列数
    .参数 表格索引, 整数型, , 表格索引从1开始
    .参数 行数索引, 整数型, , 要取出列数的行索引

    返回 (到数值 (表格_初始化 (5, 表格索引, 行数索引, )))

.子程序 表格_取单元格文本, 文本型, 公开, 取指定单元格的文本
    .参数 表格索引, 整数型, , 表格索引从1开始
    .参数 行索引, 整数型, , 行索引从1开始
    .参数 列索引, 整数型, , 列索引从1开始

    返回 (表格_初始化 (6, 表格索引, 行索引, 列索引))

.子程序 表格_置单元格文本, 文本型, 公开, 取指定单元格的文本
    .参数 表格索引, 整数型, , 表格索引从1开始
    .参数 行索引, 整数型, , 行索引从1开始
    .参数 列索引, 整数型, , 列索引从1开始
    .参数 要置入的单元格文本, 文本型, 可空, 要置入的单元格文本

    返回 (表格_初始化 (8, 表格索引, 行索引, 列索引, 要置入的单元格文本))

.子程序 表格_取单元格源码, 文本型, 公开, 取指定单元格的源码
    .参数 表格索引, 整数型, , 表格索引从1开始
    .参数 行索引, 整数型, , 行索引从1开始
    .参数 列索引, 整数型, , 列索引从1开始

    返回 (表格_初始化 (7, 表格索引, 行索引, 列索引))

.子程序 表格_取单元格数量, 整数型, 公开, 取出指定表格内的所有单元格数量
    .参数 表格索引, 整数型, , 表格索引从1开始

    返回 (到数值 (表格_初始化 (3, 表格索引)))

.子程序 表单_取对象, 对象, 公开, 获取到表单的元素对象
    .参数 名称_ID_索引, 文本型, , 可以为：表单的元素名称、ID或索引
    .参数 元素索引, 整数型, 参考 可空, 请提供一个整数型的变量，用于存放该表单的 元素索引
    .局部变量 对象, 对象
    .局部变量 临时对象, 对象
    .局部变量 计次, 整数型

    对象 ＝ 集_网页文档.读对象型属性 (“forms”, )
    .计次循环首 (对象.读数值属性 (“length”, ), 计次)
        临时对象 ＝ 对象.对象型方法 (“item”, 计次 － 1)
        元素索引 ＝ 元素索引 ＋ 1
        .如果真 (临时对象.读文本属性 (“name”, ) ＝ 名称_ID_索引)
            返回 (临时对象)
        .如果真结束
        .如果真 (临时对象.读文本属性 (“id”, ) ＝ 名称_ID_索引)
            返回 (临时对象)
        .如果真结束
        .如果真 (元素索引 ＝ 到整数 (名称_ID_索引))
            返回 (临时对象)
        .如果真结束
        
    .计次循环尾 ()
    元素索引 ＝ -1
    临时对象.清除 ()
    返回 (临时对象)

.子程序 表单_提交, 逻辑型, 公开, 有时候登陆网站的时候取不到登陆按钮的元素名称或ID的时候，可以用表单来提交。
    .参数 名称_ID_索引, 文本型, , 可以为：表单的元素名称、ID或索引
    .局部变量 元素对象, 对象

    元素对象 ＝ 表单_取对象 (名称_ID_索引)
    元素对象.方法 (“submit”, )
    返回 (元素对象.是否为空 () ＝ 假)

.子程序 表单_取索引, 整数型, 公开, 用表单的名称、ID取出相对应的索引，失败返回-1
    .参数 名称_ID, 文本型, , 用表单的名称、ID取出相对应的索引
    .局部变量 元素索引, 整数型, , , 请提供一个整数型的变量，用于存放该对象的 元素索引

    表单_取对象 (名称_ID, 元素索引)
    返回 (元素索引)

.子程序 表单_取源码, 文本型, 公开, 获取指定表单的源码
    .参数 名称_ID_索引, 文本型, , 可以为：表单的元素名称、ID或索引

    返回 (表单_取对象 (名称_ID_索引).读文本属性 (“outerHTML”, ))

.子程序 表单_取数量, 整数型, 公开, 取回当前网页上的表单数目。
    返回 (集_网页文档.读对象型属性 (“forms”, ).读数值属性 (“length”, ))

.子程序 表单_取信息, 逻辑型, 公开, 通过表单的索引取回表单ID。
    .参数 名称_ID_索引, 文本型, , 可以为：表单的元素名称、ID或索引
    .参数 提交方式, 文本型, 可空, 请提供一个文本型的变量，用于存放该表单的 提交方式
    .参数 提交地址, 文本型, 可空, 请提供一个文本型的变量，用于存放该表单的 提交地址
    .局部变量 元素对象, 对象, , , 请提供一个整数型的变量，用于存放该对象的 元素索引

    元素对象 ＝ 表单_取对象 (名称_ID_索引)
    .如果真 (是否为空 (提交方式) ＝ 假)
        提交方式 ＝ 元素对象.读文本属性 (“method”, )
    .如果真结束
    
    .如果真 (是否为空 (提交地址) ＝ 假)
        提交地址 ＝ 元素对象.读文本属性 (“action”, )
    .如果真结束
    
    返回 (元素对象.是否为空 () ＝ 假)

.子程序 隐藏表单_取对象, 对象, 公开, 根据网页隐藏表单的Name或ID或索引取回对应的对象。
    .参数 名称_ID_索引, 文本型, , 网页文本框的文本框名称或ID或索引。从1开始。
    .参数 跳过次数, 整数型, 可空, 如果元素名称一样,可以用此参数;说明:跳过的次数，如果为0还是为不跳过，只有“是否跳过参数为真”且“跳过次数大于0的时候才会跳过”

    返回 (_内部_INPUT_取对象 (“hidden”, 名称_ID_索引, 跳过次数))

.子程序 隐藏表单_取数量, 整数型, 公开, 获取网页上的隐藏表单数量。成功返回隐藏表单的数量。失败返回0。
    返回 (_内部_INPUT_取数量 (“hidden”, “隐藏表单”, 假))

.子程序 隐藏表单_取内容, 文本型, 公开, 获取取指定的网页隐藏表单中的内容，成功返回隐藏表单的内容，失败返回空文本。
    .参数 名称_ID_索引, 文本型, , 网页文本框的文本框名称、ID、索引。索引从1开始。
    .参数 跳过次数, 整数型, 可空, 如果元素名称一样,可以用此参数;说明:跳过的次数，如果为0还是为不跳过，只有“是否跳过参数为真”且“跳过次数大于0的时候才会跳过”

    返回 (隐藏表单_取对象 (名称_ID_索引, 跳过次数).读文本属性 (“value”, ))

.子程序 隐藏表单_取索引, 整数型, 公开, 用隐藏表单“名称_ID”取出网页上指定的隐藏表单索引，失败返回0。
    .参数 名称_ID, 文本型, , 网页文本框的文本框名称或ID
    .局部变量 元素索引, 整数型

    _内部_INPUT_取对象 (“hidden”, 名称_ID, , 元素索引)
    返回 (元素索引)

.子程序 隐藏表单_取属性, 逻辑型, 公开, 取指定隐藏表单的各种属性。成功返回真，失败返回假。
    .参数 控件索引, 整数型, , 网页控件的索引。从1开始。
    .参数 隐藏表单内容, 文本型, 参考 可空, 用于装载隐藏表单内容的变量。 
    .参数 隐藏表单名称, 文本型, 参考 可空, 用于装载隐藏表单名称的变量。 
    .参数 隐藏表单ID, 文本型, 参考 可空, 用于装载隐藏表单ID的变量。 
    .参数 隐藏表单类型, 文本型, 参考 可空, 用于装载隐藏表单类型的变量。 
    .参数 元素对象, 对象, 参考 可空, 用于装载元素对象的变量。 

    元素对象 ＝ 隐藏表单_取对象 (到文本 (控件索引))
    .如果真 (是否为空 (隐藏表单内容) ＝ 假)
        隐藏表单内容 ＝ 元素对象.读文本属性 (“value”, )
    .如果真结束
    .如果真 (是否为空 (隐藏表单名称) ＝ 假)
        隐藏表单名称 ＝ 元素对象.读文本属性 (“name”, )
    .如果真结束
    .如果真 (是否为空 (隐藏表单ID) ＝ 假)
        隐藏表单ID ＝ 元素对象.读文本属性 (“id”, )
    .如果真结束
    .如果真 (是否为空 (隐藏表单类型) ＝ 假)
        隐藏表单类型 ＝ 元素对象.读文本属性 (“type”, )
    .如果真结束
    返回 (元素对象.是否为空 () ＝ 假)

.子程序 隐藏表单_写内容, 逻辑型, 公开, 往指定的网页隐藏表单写入指定的内容。成功返回真，失败返回假。
    .参数 名称_ID_索引, 文本型, , 网页文本框的文本框名称或ID或索引。从1开始。
    .参数 欲写内的内容, 文本型, , 欲写内的内容
    .参数 跳过次数, 整数型, 可空, 如果元素名称一样,可以用此参数;说明:跳过的次数，如果为0还是为不跳过，只有“是否跳过参数为真”且“跳过次数大于0的时候才会跳过”

    返回 (隐藏表单_取对象 (名称_ID_索引, 跳过次数).写属性 (“value”, 欲写内的内容))

.子程序 DIV_取对象, 对象, 公开, 获取到相应的元素对象
    .参数 标题_索引_ID_名称, 文本型, , 网页DIV的DIV标题、名称、ID、索引。索引从1开始。
    .参数 跳过次数, 整数型, 可空, 如果元素名称一样,可以用此参数;说明:跳过的次数，如果为0还是为不跳过，只有“是否跳过参数为真”且“跳过次数大于0的时候才会跳过”

    返回 (_内部_DIV_取对象 (“DIV”, 标题_索引_ID_名称, 跳过次数))

.子程序 DIV_取数量, 整数型, 公开, 取网页上的超级DIV数目,成功返回DIV数目，否则返回0。
    .参数 是否标记, 逻辑型, 可空, 是否在每个DIV里是写入标记文本。

    返回 (_内部_DIV_取数量 (“DIV”, “DIV”, 是否标记))

.子程序 DIV_取属性, 逻辑型, 公开, 取指定DIV的各种属性。成功返回真。失败返回假。 
    .参数 控件索引, 整数型, , 网页控件的索引。从1开始。
    .参数 元素类名, 文本型, 可空, 用于装载DIV内容的变量。 
    .参数 元素标题, 文本型, 可空, 用于装载DIV内容的变量。 
    .参数 元素ID, 文本型, 可空
    .参数 元素对象, 对象, 参考 可空, 用于装载元素对象的变量。 

    元素对象 ＝ DIV_取对象 (到文本 (控件索引))
    .如果真 (是否为空 (元素类名) ＝ 假)
        元素类名 ＝ 元素对象.读文本属性 (“className”, )
    .如果真结束
    
    .如果真 (是否为空 (元素标题) ＝ 假)
        元素标题 ＝ 元素对象.读文本属性 (“title”, )
    .如果真结束
    
    .如果真 (是否为空 (元素ID) ＝ 假)
        元素ID ＝ 元素对象.读文本属性 (“id”, )
    .如果真结束
    返回 (元素对象.是否为空 () ＝ 假)

.子程序 DIV_取内容, 文本型, 公开, 获取指定DIV的内容
    .参数 标题_索引_ID_名称, 文本型, , 网页DIV的DIV标题、名称、ID、索引。索引从1开始。
    .参数 跳过次数, 整数型, 可空, 如果元素名称一样,可以用此参数;说明:跳过的次数，如果为0还是为不跳过，只有“是否跳过参数为真”且“跳过次数大于0的时候才会跳过”

    返回 (_内部_DIV_取对象 (“DIV”, 标题_索引_ID_名称, 跳过次数).读文本属性 (“innerHTML”, ))

.子程序 DIV_写内容, 逻辑型, 公开, 往指定的DIV里写内容
    .参数 标题_索引_ID_名称, 文本型, , 网页DIV的DIV标题、名称、ID、索引。索引从1开始。
    .参数 欲写入的内容, 文本型, , 欲写入的内容，支持HTML代码
    .参数 跳过次数, 整数型, 可空, 如果元素名称一样,可以用此参数;说明:跳过的次数，如果为0还是为不跳过，只有“是否跳过参数为真”且“跳过次数大于0的时候才会跳过”

    返回 (_内部_DIV_取对象 (“DIV”, 标题_索引_ID_名称, 跳过次数).写属性 (“innerHTML”, 欲写入的内容))

.子程序 DIV_取源码, 文本型, 公开, 获取指定DIV的源码
    .参数 标题_索引_ID_名称, 文本型, , 网页DIV的DIV标题、名称、ID、索引。索引从1开始。
    .参数 跳过次数, 整数型, 可空, 如果元素名称一样,可以用此参数;说明:跳过的次数，如果为0还是为不跳过，只有“是否跳过参数为真”且“跳过次数大于0的时候才会跳过”

    返回 (_内部_DIV_取对象 (“DIV”, 标题_索引_ID_名称, 跳过次数).读文本属性 (“outerHTML”, ))

.子程序 DIV_取索引, 整数型, 公开, 通过DIV的“title标题_ID_名称_ClassName”获取他的索引，失败返回0 。
    .参数 title标题_ID_名称_ClassName, 文本型, , 网页DIV的“title标题_ID_名称_ClassName”
    .参数 跳过次数, 整数型, 可空, 如果元素名称一样,可以用此参数;说明:跳过的次数，如果为0还是为不跳过，只有“是否跳过参数为真”且“跳过次数大于0的时候才会跳过”
    .局部变量 元素索引, 整数型

    _内部_DIV_取对象 (“DIV”, title标题_ID_名称_ClassName, 跳过次数, 元素索引)
    返回 (元素索引)

.子程序 DIV_点击, 逻辑型, 公开, 点击网页上的DIV。成功返回真。失败返回假。 
    .参数 标题_索引_ID_Class, 文本型, , 网页DIV的DIV标题、类名、ID、索引。索引从1开始。
    .参数 跳过次数, 整数型, 可空, 如果元素名称一样,可以用此参数;说明:跳过的次数，如果为0还是为不跳过，只有“是否跳过参数为真”且“跳过次数大于0的时候才会跳过”
    .局部变量 元素对象, 对象, , , 用于装载元素对象的变量。 

    元素对象 ＝ DIV_取对象 (标题_索引_ID_Class, 跳过次数)
    元素对象.方法 (“click”, )
    返回 (元素对象.是否为空 () ＝ 假)

.子程序 DIV_置状态, 逻辑型, 公开, 设置DIV的可视状态
    .参数 标题_索引_ID_Class, 文本型, , 网页DIV的DIV标题、类名、ID、索引。索引从1开始。
    .参数 跳过次数, 整数型, 可空, 可空。如果元素名称一样,可以用此参数;说明:跳过的次数，如果为0还是为不跳过，只有“是否跳过参数为真”且“跳过次数大于0的时候才会跳过”
    .参数 隐藏, 逻辑型, 可空, 可空。默认为假。假=可视，真=隐藏

    返回 (DIV_取对象 (标题_索引_ID_Class, 跳过次数).读对象型属性 (“style”, ).写属性 (“display”, 选择 (隐藏, “none”, “”)))

.子程序 ULLI_取数量, 整数型, 公开, 成功返回控件数量，失败返回0。
    .参数 是否标记, 逻辑型, 可空, 是否在每个DIV里是写入标记文本。

    返回 (_内部_ULLI_取数量 (“li”, “ULLI”, 是否标记))

.子程序 ULLI_取索引, 整数型, 公开, 成功返回控件索引，失败返回0。
    .参数 标题_ID_ClassName, 文本型
    .参数 跳过次数, 整数型, 可空, 如果元素名称一样,可以用此参数;说明:跳过的次数，如果为0还是为不跳过，只有“是否跳过参数为真”且“跳过次数大于0的时候才会跳过”
    .局部变量 元素索引, 整数型

    _内部_ULLI_取对象 (“li”, 标题_ID_ClassName, 跳过次数, 元素索引)
    返回 (元素索引)

.子程序 ULLI_选择, 逻辑型, 公开, 成功返回真。失败返回假。
    .参数 标题_ID_ClassName, 文本型, , 可以为控件的标题、ID和索引。
    .参数 跳过次数, 整数型, 可空, 如果元素名称一样,可以用此参数;说明:跳过的次数，如果为0还是为不跳过，只有“是否跳过参数为真”且“跳过次数大于0的时候才会跳过”
    .局部变量 元素对象, 对象

    元素对象 ＝ _内部_ULLI_取对象 (“li”, 标题_ID_ClassName, 跳过次数)
    元素对象.方法 (“click”, )
    返回 (元素对象.是否为空 () ＝ 假)

.子程序 ULLI_取源码, 文本型, 公开, 获取指定ULLI的源码
    .参数 标题_ID_ClassName, 文本型, , 可以为控件的标题、ID和索引。
    .参数 跳过次数, 整数型, 可空, 如果元素名称一样,可以用此参数;说明:跳过的次数，如果为0还是为不跳过，只有“是否跳过参数为真”且“跳过次数大于0的时候才会跳过”

    返回 (_内部_ULLI_取对象 (“li”, 标题_ID_ClassName, 跳过次数).读文本属性 (#网页属性_网页源码, ))

.子程序 SPAN_取对象, 对象, 公开, 获取SPAN的元素对象
    .参数 标题_索引_ID_Class, 文本型, , 网页SPAN的SPAN标题、类名、ID、索引。索引从1开始。
    .参数 跳过次数, 整数型, 可空, 如果元素名称一样,可以用此参数;说明:跳过的次数，如果为0还是为不跳过，只有“是否跳过参数为真”且“跳过次数大于0的时候才会跳过”

    返回 (_内部_SPAN_取对象 (“SPAN”, 标题_索引_ID_Class, 跳过次数))

.子程序 SPAN_点击, 逻辑型, 公开, 点击网页上的SPAN。成功返回真。失败返回假。 
    .参数 标题_索引_ID_Class, 文本型, , 网页SPAN的SPAN标题、类名、ID、索引。索引从1开始。
    .参数 跳过次数, 整数型, 可空, 如果元素名称一样,可以用此参数;说明:跳过的次数，如果为0还是为不跳过，只有“是否跳过参数为真”且“跳过次数大于0的时候才会跳过”
    .局部变量 元素对象, 对象

    元素对象 ＝ SPAN_取对象 (标题_索引_ID_Class, 跳过次数)
    元素对象.方法 (“click”, )
    返回 (元素对象.是否为空 () ＝ 假)

.子程序 SPAN_取数量, 整数型, 公开, 成功返回控件数量，失败返回0。
    .参数 是否标记, 逻辑型, 可空, 是否在每个DIV里是写入标记文本。

    返回 (_内部_SPAN_取数量 (“SPAN”, “SPAN”, 是否标记))

.子程序 SPAN_取索引, 整数型, 公开, 成功返回到文本(到文本(控件索引))，失败返回0。
    .参数 标题_ID_Class, 文本型
    .参数 跳过次数, 整数型, 可空, 如果元素名称一样,可以用此参数;说明:跳过的次数，如果为0还是为不跳过，只有“是否跳过参数为真”且“跳过次数大于0的时候才会跳过”
    .局部变量 元素索引, 整数型

    _内部_SPAN_取对象 (“SPAN”, 标题_ID_Class, 跳过次数, 元素索引)
    返回 (元素索引)

.子程序 SPAN_取属性, 逻辑型, 公开, 取指定SPAN的各种属性。成功返回真，失败返回假。
    .参数 控件索引, 整数型, , 网页控件的索引。从1开始。
    .参数 元素标题, 文本型, 可空, 用于装载SPAN 元素标题 的变量。 
    .参数 元素类名, 文本型, 可空, 用于装载SPAN 元素类名 的变量。 
    .参数 元素内容, 文本型, 可空, 用于装载SPAN 元素内容 的变量。 
    .参数 元素ID, 文本型, 可空, 用于装载SPAN 元素ID 的变量。 
    .参数 元素对象, 对象, 参考 可空, 用于装载SPAN 元素对象 的变量。 

    元素对象 ＝ SPAN_取对象 (到文本 (控件索引), )
    .如果真 (是否为空 (元素标题) ＝ 假)
        元素标题 ＝ 元素对象.读文本属性 (“title”, )
    .如果真结束
    
    .如果真 (是否为空 (元素类名) ＝ 假)
        元素类名 ＝ 元素对象.读文本属性 (“className”, )
    .如果真结束
    
    .如果真 (是否为空 (元素内容) ＝ 假)
        元素内容 ＝ 元素对象.读文本属性 (“innerText”, )
    .如果真结束
    
    .如果真 (是否为空 (元素ID) ＝ 假)
        元素ID ＝ 元素对象.读文本属性 (“id”, )
    .如果真结束
    
    返回 (元素对象.是否为空 () ＝ 假)

.子程序 SPAN_取内容, 文本型, 公开, 获取指定SPAN的内容
    .参数 标题_索引_ID_Class, 文本型, , 网页SPAN的SPAN标题、类名、ID、索引。索引从1开始。
    .参数 跳过次数, 整数型, 可空, 如果元素名称一样,可以用此参数;说明:跳过的次数，如果为0还是为不跳过，只有“是否跳过参数为真”且“跳过次数大于0的时候才会跳过”

    返回 (SPAN_取对象 (标题_索引_ID_Class, 跳过次数).读文本属性 (“innerHTML”, ))

.子程序 SPAN_取源码, 文本型, 公开, 获取指定SPAN的源码
    .参数 标题_索引_ID_Class, 文本型, , 网页SPAN的SPAN标题、类名、ID、索引。索引从1开始。
    .参数 跳过次数, 整数型, 可空, 如果元素名称一样,可以用此参数;说明:跳过的次数，如果为0还是为不跳过，只有“是否跳过参数为真”且“跳过次数大于0的时候才会跳过”

    返回 (SPAN_取对象 (标题_索引_ID_Class, 跳过次数).读文本属性 (“outerHTML”, ))

.子程序 SPAN_写内容, 逻辑型, 公开, 往指定SPAN里写内容
    .参数 标题_索引_ID_Class, 文本型, , 网页SPAN的SPAN标题、类名、ID、索引。索引从1开始。
    .参数 欲写入的内容, 文本型, , 欲写入的内容，支持HTML代码
    .参数 跳过次数, 整数型, 可空, 如果元素名称一样,可以用此参数;说明:跳过的次数，如果为0还是为不跳过，只有“是否跳过参数为真”且“跳过次数大于0的时候才会跳过”

    返回 (SPAN_取对象 (标题_索引_ID_Class, 跳过次数).写属性 (“innerHTML”, 欲写入的内容))

.子程序 SPAN_置状态, 逻辑型, 公开, 设置SPAN的可视状态
    .参数 标题_索引_ID_Class, 文本型, , 网页SPAN的SPAN标题、类名、ID、索引。索引从1开始。
    .参数 跳过次数, 整数型, 可空, 可空。如果元素名称一样,可以用此参数;说明:跳过的次数，如果为0还是为不跳过，只有“是否跳过参数为真”且“跳过次数大于0的时候才会跳过”
    .参数 隐藏, 逻辑型, 可空, 可空。默认为假。假=可视，真=隐藏

    返回 (SPAN_取对象 (标题_索引_ID_Class, 跳过次数).读对象型属性 (“style”, ).写属性 (“display”, 选择 (隐藏, “none”, “”)))

.子程序 网页_屏蔽安全警报, , 公开, 只对IE6有效。用于屏蔽HTTPS网页操作时弹出的安全警告信息框，感谢坛友【易之易】提供
    .参数 屏蔽与解除, 整数型, 可空, 可空，默认为［屏蔽安全警报提示］。1=显示安全警报提示
    .局部变量 注册表, 注册表操作

    注册表.写DWORD值 (“HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Internet Settings”, “WarnOnHTTPSToHTTPRedirect”, 屏蔽与解除) ' 个人用户
    注册表.写DWORD值 (“HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Internet Settings”, “WarnOnHTTPSToHTTPRedirect”, 屏蔽与解除)

.子程序 网页_枚举子句柄, 逻辑型, , 取已打开的所有网页窗口句柄
    .参数 父句柄, 整数型, , 要取网页窗口的父窗口，要取整个系统的网页窗口请提供0
    .参数 欲装载的数组, 整数型, 参考 数组, 返回的句柄数组，只能提供数组型变量
    .局部变量 窗口句柄, 整数型
    .局部变量 窗口类名, 文本型

    窗口句柄 ＝ FindWindowExA (父句柄, 0, 0, 0)
    .判断循环首 (窗口句柄 ≠ 0)
        窗口类名 ＝ 窗口_取类名 (窗口句柄) ' 缓冲区
        .如果真 (窗口类名 ＝ “Internet Explorer_Server”)
            加入成员 (欲装载的数组, 窗口句柄)
        .如果真结束
        网页_枚举子句柄 (窗口句柄, 欲装载的数组)
        窗口句柄 ＝ FindWindowExA (父句柄, 窗口句柄, 0, 0)
    .判断循环尾 ()
    返回 (取数组成员数 (欲装载的数组) ≠ 0)

.子程序 取元素代码, 文本型, , 返回网页元素里的HTML代码(innerHTML)
    .参数 元素对象, 对象, , 网页元素对象，可以通过“取元素对象()”获取

    返回 (元素对象.读文本属性 (“innerHTML”, ))

.子程序 写超文本流, , , 直接在Webbroswer或外部网页框内写入一个完整的网页
    .参数 超文本流, 文本型, , 网页HTML代码，最好包含<html>与</html>

    集_网页文档.方法 (“open”, )
    集_网页文档.方法 (“write”, 超文本流)
    集_网页文档.方法 (“Close”, )

.子程序 取元素集合, 对象, , 获取基于指定元素名称的对象集合(getElementsByTagName)
    .参数 元素名称, 文本型, , 如：“a”、“table”、“div”、“img”..

    返回 (集_网页文档.对象型方法 (“getElementsByTagName”, 元素名称))

.子程序 取元素文本, 文本型, , 返回网页元素里的文本(innerText)
    .参数 元素对象, 对象, , 网页元素对象，可以通过“取元素对象()”获取

    返回 (元素对象.读文本属性 (“innerText”, ))

.子程序 置元素代码, 逻辑型, , 设置网页元素里的HTML代码(innerHTML)
    .参数 元素对象, 对象, , 网页元素对象，可以通过“取元素对象()”获取
    .参数 待写入值, 文本型

    返回 (元素对象.写属性 (“innerHTML”, 待写入值))

.子程序 置元素文本, 逻辑型, , 设置网页元素里的文本(innerText)
    .参数 元素对象, 对象, , 网页元素对象，可以通过“取元素对象()”获取
    .参数 待写入值, 文本型

    返回 (元素对象.写属性 (“innerText”, 待写入值))

.子程序 显示弹出窗口, 对象, , 在屏幕上显示弹出窗口(popup.show)，返回弹出窗口对象
    .参数 横向位置, 整数型, , 指定弹出窗口( popup )左上角横坐标。单位为像素( px )。 
    .参数 纵向位置, 整数型, , 指定弹出窗口( popup )左上角纵坐标。单位为像素( px )。 
    .参数 窗口宽度, 整数型, , 指定弹出窗口( popup )宽度。单位为像素( px )。
    .参数 窗口高度, 整数型, , 指定弹出窗口( popup )高度。单位为像素( px )。
    .参数 窗口内容, 文本型, , 待弹出窗口的内容
    .参数 背景颜色, 整数型, 可空, 可选项。指定弹出窗口( popup )背景颜色，默认为白色
    .参数 边框粗细, 整数型, 可空, 可选项。指定弹出窗口( popup )边框粗细。默认为1像素( px )。
    .参数 边框颜色, 整数型, 可空, 可选项。指定弹出窗口( popup )边框颜色。默认为1浅灰色。
    .参数 相对元素, 对象, 可空, 可选项。对象(Element)。指定 iX 和 iY 坐标所相对于的对象。如果忽略此参数，则默认相对于桌面(Desktop)。
    .局部变量 oPopup, 对象
    .局部变量 oBody, 对象

    oPopup ＝ 集_网页文档.读对象型属性 (“parentWindow”, ).对象型方法 (“createPopup”, )
    oBody ＝ oPopup.读对象型属性 (“document”, ).读对象型属性 (“body”, )
    .如果真 (是否为空 (背景颜色))
        背景颜色 ＝ #白色
    .如果真结束
    .如果真 (是否为空 (边框粗细))
        边框粗细 ＝ 1
    .如果真结束
    .如果真 (是否为空 (边框颜色))
        边框颜色 ＝ #浅灰
    .如果真结束
    oBody.读对象型属性 (“style”, ).写属性 (“backgroundColor”, 运算_颜色转换 (背景颜色))
    oBody.读对象型属性 (“style”, ).写属性 (“border”, “solid ” ＋ 运算_颜色转换 (边框颜色) ＋ 到文本 (边框粗细) ＋ “px”)
    oBody.写属性 (“innerHTML”, 窗口内容)
    .如果 (是否为空 (相对元素))
        oPopup.方法 (“show”, 横向位置, 纵向位置, 窗口宽度, 窗口高度)
    .否则
        oPopup.方法 (“show”, 横向位置, 纵向位置, 窗口宽度, 窗口高度, 相对元素)
    .如果结束
    返回 (oPopup)

.子程序 隐藏弹出窗口, , , popup.hide
    .参数 弹出窗口对象, 对象

    弹出窗口对象.方法 (“hide”, )

.子程序 置元素引用代码, 逻辑型, , 设置网页元素的引用代码(outerHTML)
    .参数 元素对象, 对象, , 网页元素对象，可以通过“取元素对象()”获取
    .参数 待写入值, 文本型

    返回 (元素对象.写属性 (“outerHTML”, 待写入值))

.子程序 置元素引用文本, 逻辑型, , 设置网页元素的引用文本(outerText)
    .参数 元素对象, 对象, , 网页元素对象，可以通过“取元素对象()”获取
    .参数 待写入值, 文本型

    返回 (元素对象.写属性 (“outerText”, 待写入值))

.子程序 取元素引用代码, 文本型, , 返回网页元素的引用代码(outerHTML)
    .参数 元素对象, 对象, , 网页元素对象，可以通过“取元素对象()”获取

    返回 (元素对象.读文本属性 (“outerHTML”, ))

.子程序 取元素引用文本, 文本型, , 返回网页元素的引用文本(outerText)
    .参数 元素对象, 对象, , 网页元素对象，可以通过“取元素对象()”获取

    返回 (元素对象.读文本属性 (“outerText”, ))

.子程序 就绪判断_文本关键字, 逻辑型, 公开, 通过【网页文本】关键字判断网页是否载入就绪,如果是就绪并且找到关键字,返回真,否则返回假
    .参数 浏览器窗口句柄, 整数型
    .参数 欲判断的关键字, 文本型
    .参数 超时返回, 整数型, 可空, 可空,单位为毫秒,默认为等待5000毫秒
    .参数 网页文档对象, 对象, 可空, 如果此参数不为空,将以此参数为主。第1个参数可以直接填0
    .局部变量 局_文本, 文本型
    .局部变量 局_时间, 整数型

    .如果真 (是否为空 (超时返回))
        超时返回 ＝ 5000
    .如果真结束
    局_时间 ＝ 取启动时间 ()
    .判断循环首 (真)
        .如果真 (窗口_句柄是否有效 (浏览器窗口句柄) ＝ 假)
            返回 (假)
        .如果真结束
        程序_延时 (300)
        .如果 (是否为空 (网页文档对象))
            初始化 (浏览器窗口句柄)
            局_文本 ＝ 网页_取文本 ()
        .否则
            局_文本 ＝ 编码_Unicode到Ansi (网页文档对象.读对象型属性 (“documentElement”, ).读属性 (“innerText”, ).取字节集 ())
            ' 局_文本 ＝ 网页文档对象.读对象型属性 (“documentElement”, ).读文本属性 (“innerText”, )
        .如果结束
        .判断开始 (寻找文本 (局_文本, 欲判断的关键字, , 假) ≠ -1)
            返回 (真)
        .判断 (取启动时间 () － 局_时间 ＞ 超时返回)
            返回 (假)
        .默认
            
        .判断结束
        
    .判断循环尾 ()
    返回 (假)

.子程序 就绪判断_源码关键字, 逻辑型, 公开, 通过【源码文本】关键字判断网页是否载入就绪,如果是就绪并且找到关键字,返回真,否则返回假
    .参数 浏览器窗口句柄, 整数型
    .参数 欲判断的关键字, 文本型
    .参数 是否区分大小写, 逻辑型, 可空
    .参数 超时返回, 整数型, 可空, 可空,单位为毫秒,默认为等待5000毫秒
    .参数 网页文档对象, 对象, 可空, 如果此参数不为空,将以此参数为主。第1个参数可以直接填0
    .局部变量 局_文本, 文本型
    .局部变量 局_时间, 整数型

    局_时间 ＝ 取启动时间 ()
    .如果真 (是否为空 (超时返回))
        超时返回 ＝ 5000
    .如果真结束
    .判断循环首 (真)
        .如果真 (窗口_句柄是否有效 (浏览器窗口句柄) ＝ 假)
            返回 (假)
        .如果真结束
        程序_延时 (300)
        .如果 (是否为空 (网页文档对象))
            初始化 (浏览器窗口句柄)
            局_文本 ＝ 网页_取源码 ()
        .否则
            局_文本 ＝ 编码_Unicode到Ansi (网页文档对象.读对象型属性 (“documentElement”, ).读属性 (“outerHTML”, ).取字节集 ())
            ' 局_文本 ＝ 网页文档对象.读对象型属性 (“documentElement”, ).读文本属性 (“outerHTML”, )
        .如果结束
        .判断开始 (寻找文本 (局_文本, 欲判断的关键字, , 是否区分大小写) ≠ -1)
            返回 (真)
        .判断 (取启动时间 () － 局_时间 ＞ 超时返回)
            返回 (假)
        .默认
            
        .判断结束
        
    .判断循环尾 ()
    返回 (假)
    

.版本 2

.程序集 正则表达式类, , 公开
.程序集变量 正则, 对象
.程序集变量 集_过度对象, 对象
.程序集变量 集_被搜索的文本, 变体型

.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
    线程_初始化COM库 ()

.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
    正则.清除 ()
    集_过度对象.清除 ()
    集_被搜索的文本.清除 ()
    线程_取消COM库 ()

.子程序 创建, 逻辑型, 公开, 根据指定的正则表达式文本创建一个正则表达式对象。本对象中的原有内容将被释放
    .参数 正则表达式文本, 文本型, , 比如“易语言4\.0(模块|支持库)?”
    .参数 被搜索的文本, 文本型
    .参数 是否区分大小写, 逻辑型, 可空, 可以留空,默认为假,不区分大小写; 真为区分大小写;本参数指定这个正则表达式在创建成功后进行匹配、搜索、替换时，是否区分大小写;
    .参数 是否匹配多行, 逻辑型, 可空, 可以留空,默认为真,允许匹配多行; 如果本成员值为真，字符“^”不仅匹配目标文本的开头，而且匹配目标文本中换行符（字符(10)，字符(13)或 #换行符）的后面；字符“$”不仅匹配目标文本的结尾，而且匹配目标文本中换行符的前面。否则字符“^”仅仅匹配目标文本的开头，“$”也仅仅匹配目标文本的结尾。
    .参数 是否全局匹配, 逻辑型, 可空, 可以留空，默认为真，全局匹配
    .参数 自动替换引号, 逻辑型, 可空, 可空。默认为不替换。说明：正则表达式文本为【formhash" value="7b4aa6c5】，这里面的引号处理起来很麻烦，直接把此参数设置为真，把"换成 #引号 再传进来就可以了，如：【formhash#引号 value=#引号7b4aa6c5】
    .局部变量 局_正则文本, 文本型

    
    是否区分大小写 ＝ 取反 (选择 (是否为空 (是否区分大小写), 假, 是否区分大小写))
    是否匹配多行 ＝ 选择 (是否为空 (是否匹配多行), 真, 是否匹配多行)
    是否全局匹配 ＝ 选择 (是否为空 (是否全局匹配), 真, 是否全局匹配)
    正则.清除 ()
    集_过度对象.清除 ()
    正则.创建 (“VBScript.RegExp”, )
    正则.写属性 (“IgnoreCase”, 是否区分大小写) ' 匹配时不区分大小写
    正则.写属性 (“Multiline”, 是否匹配多行) ' 是否匹配多行
    正则.写属性 (“Singleline”, 真) ' Singleline(单行模式)
    正则.写属性 (“Global”, 是否全局匹配) ' 是否全局匹配
    .判断开始 (自动替换引号)
        局_正则文本 ＝ 子文本替换 (正则表达式文本, “#引号”, #引号, , , 真)
    .默认
        局_正则文本 ＝ 正则表达式文本
    .判断结束
    正则.写属性 (“Pattern”, 局_正则文本)
    ' -----------------
    集_被搜索的文本.赋值 (被搜索的文本, )
    集_过度对象 ＝ 正则.对象型方法 (“Execute”, 集_被搜索的文本)
    ' .如果真 (取文本长度 (被搜索的文本) ＞ 510000)
        ' 输出调试文本 (“友情提醒：正则类 → 创建() 命令的参数二 → 被搜索的文本 的长度过长，可以会导致程序直接结束。”)
    ' .如果真结束
    ' 集_过度对象 ＝ 正则.对象型方法 (“Execute”, 被搜索的文本)
    ' 集_被搜索的文本 ＝ 被搜索的文本
    
    返回 (集_过度对象.是否为空 () ＝ 假)

.子程序 查看, , 公开,  
    正则.查看 ()

.子程序 取正则文本, 文本型, 公开, 返回以文本形式表示的正则表达式。如果该对象尚未创建，则返回空文本。本命令为高级对象成员命令
    返回 (选择 (正则.是否为空 (), “”, 正则.读文本属性 (“Pattern”, )))

.子程序 替换, 文本型, 公开, 替换在正则表达式查找中找到的文本
    .参数 用作替换的文本, 文本型, 可空, 用作替换的文本
    .局部变量 用作替换的文本_变体型, 变体型

    用作替换的文本_变体型.赋值 (用作替换的文本, )
    ' 返回 (编码_Unicode到Ansi (正则.通用方法 (“Replace”, 集_被搜索的文本, 用作替换的文本_变体型).取字节集 ()))
    返回 (正则.文本方法 (“Replace”, 集_被搜索的文本, 用作替换的文本_变体型))

.子程序 取匹配数量, 整数型, 公开, 取出该正则匹配到的数量
    返回 (集_过度对象.读数值属性 (“Count”, ))

.子程序 取匹配文本, 文本型, 公开, 取出该正则匹配到的文本
    .参数 匹配索引, 整数型, , 索引值从1开始
    .参数 起始位置, 整数型, 参考 可空, 可以被省略，提供参数数据时只能提供变量。该命令调用成功后，本参数存放取得的子文本在整个被搜索文本中的起始位置
    .局部变量 Match, 对象
    .局部变量 Value, 文本型

    Match ＝ 集_过度对象.读对象型属性 (“Item”, 匹配索引 － 1)
    ' ----------------------
    Value ＝ Match.读属性 (“Value”, ).取文本 ()
    .如果真 (是否为空 (起始位置) ＝ 假)
        起始位置 ＝ 寻找文本 (集_被搜索的文本.取文本 (), Value, Match.读数值属性 (“FirstIndex”, ), 选择 (正则.读属性 (“IgnoreCase”, ).取文本 () ＝ “0”, 真, 假)) － 1
    .如果真结束
    返回 (Value)
    ' Value ＝ Match.读文本属性 (“Value”, )
    ' .如果真 (是否为空 (起始位置) ＝ 假)
        ' 起始位置 ＝ 寻找文本 (集_被搜索的文本, Value, Match.读数值属性 (“FirstIndex”, ), 选择 (正则.读文本属性 (“IgnoreCase”, ) ＝ “0”, 真, 假)) － 1
    ' .如果真结束
    ' 返回 (Value)

.子程序 取子匹配文本, 文本型, 公开, 取出该正则的子表达式匹配到的文本
    .参数 匹配索引, 整数型, , 索引值从1开始
    .参数 子表达式索引, 整数型, , 欲取其值的子表达式,该参数对应与正则表达式中的一个子表达式以圆括号"( )"为标记,索引从1开始
    .参数 起始位置, 整数型, 参考 可空, 可以被省略，提供参数数据时只能提供变量。该命令调用成功后，本参数存放取得的子文本在整个被搜索文本中的起始位置
    .局部变量 Match, 对象
    .局部变量 SubMatches, 对象
    .局部变量 value, 文本型

    Match ＝ 集_过度对象.读对象型属性 (“Item”, 匹配索引 － 1)
    SubMatches ＝ Match.读对象型属性 (“SubMatches”, )
    value ＝ SubMatches.读属性 (“Item”, 子表达式索引 － 1).取文本 ()
    .如果真 (是否为空 (起始位置) ＝ 假)
        起始位置 ＝ 寻找文本 (集_被搜索的文本.取文本 (), value, Match.读数值属性 (“FirstIndex”, ), 选择 (正则.读属性 (“IgnoreCase”, ).取文本 () ＝ “0”, 真, 假)) － 1
        ' 起始位置 ＝ 寻找文本 (集_被搜索的文本, value, Match.读数值属性 (“FirstIndex”, ), 选择 (正则.读文本属性 (“IgnoreCase”, ) ＝ “0”, 真, 假)) － 1
    .如果真结束
    返回 (value)

.子程序 取子匹配数量, 整数型, 公开, 取出该正则的子表达式匹配到的数量
    返回 (集_过度对象.读对象型属性 (“Item”, 0).读对象型属性 (“SubMatches”, ).读数值属性 (“Count”, ))

.版本 2

.程序集 类_Cookie, , 公开, Cookie操作类   感谢【@bj2757 】提供源码
.程序集变量 cookie_s, Cookie, , "0", cookie数组

.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
    

.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
    

.子程序 加入Cookie, , 公开, 加入单个cookie
    .参数 cookie, Cookie, , 需要加入的cookie

    加入成员 (cookie_s, cookie)

.子程序 加入Cookie2, , 公开, 加入单个cookie
    .参数 健, 文本型, , Cookie的名字
    .参数 值, 文本型, , Cookie的值
    .局部变量 co, Cookie

    co.健 ＝ 健
    co.值 ＝ 值
    加入成员 (cookie_s, co)
    

.子程序 加入Cookie文本, , 公开, 自动解析cookie文本并加入当前cookie对象
    .参数 cookie字串, 文本型, , 需要加入的文本字串
    .局部变量 局_cookie数组, Cookie, , "0"

    Cookie解析 (cookie字串, 局_cookie数组)
    .如果真 (取数组成员数 (局_cookie数组) ＞ 0)
        加入Cookie数组 (局_cookie数组)
    .如果真结束
    

.子程序 加入Cookie数组, , 公开
    .参数 Cookie_数组, Cookie, 数组

    加入成员 (cookie_s, Cookie_数组)
    

.子程序 Cookie解析, , 公开, 根据cookie文本解析cookie并加入返回数组中
    .参数 Cookie文本, 文本型, , 需要解析的cookie文本字符串
    .参数 Cookie集合, Cookie, 参考 数组, 返回cookie集合
    .参数 删收尾引号, 逻辑型, 可空, 默认为真
    .局部变量 局_数组1, 文本型, , "0"
    .局部变量 局_index, 整数型
    .局部变量 i, 整数型
    .局部变量 cookie_i, Cookie

    局_数组1 ＝ 分割文本 (Cookie文本, “;”, )
    .如果真 (是否为空 (删收尾引号))
        删收尾引号 ＝ 真
    .如果真结束
    .计次循环首 (取数组成员数 (局_数组1), i)
        局_index ＝ 寻找文本 (局_数组1 [i], “=”, , 假)
        .如果真 (局_index ≠ -1)
            cookie_i.健 ＝ 删首尾空 (取文本左边 (局_数组1 [i], 局_index － 1))
            cookie_i.值 ＝ 删首尾空 (取文本右边 (局_数组1 [i], 取文本长度 (局_数组1 [i]) － 局_index))
            .如果真 (删收尾引号)
                .如果真 (取文本左边 (cookie_i.健, 1) ＝ #引号)
                    cookie_i.健 ＝ 取文本右边 (cookie_i.健, 取文本长度 (cookie_i.健) － 1)
                .如果真结束
                .如果真 (取文本右边 (cookie_i.健, 1) ＝ #引号)
                    cookie_i.健 ＝ 取文本左边 (cookie_i.健, 取文本长度 (cookie_i.健) － 1)
                .如果真结束
                .如果真 (取文本左边 (cookie_i.值, 1) ＝ #引号)
                    cookie_i.值 ＝ 取文本右边 (cookie_i.值, 取文本长度 (cookie_i.值) － 1)
                .如果真结束
                .如果真 (取文本右边 (cookie_i.值, 1) ＝ #引号)
                    cookie_i.值 ＝ 取文本左边 (cookie_i.值, 取文本长度 (cookie_i.值) － 1)
                .如果真结束
                
            .如果真结束
            
            加入成员 (Cookie集合, cookie_i)
        .如果真结束
        
    .计次循环尾 ()

.子程序 删除Cookie, 逻辑型, 公开, 根据cookie的键删除cookie
    .参数 cookieKey, 文本型, , 需要删除cookie的健
    .局部变量 i, 整数型

    .计次循环首 (取数组成员数 (cookie_s), i)
        .如果真 (cookie_s [i].健 ＝ cookieKey)
            删除成员 (cookie_s, i, )
            返回 (真)
            
        .如果真结束
        
    .计次循环尾 ()
    返回 (假)

.子程序 删除全部, , 公开, 删除当前对象中所有的cookie
    清除数组 (cookie_s)
    

.子程序 取Cookie文本, 文本型, 公开, 返回当前集合中所有的cookie组成的字符串
    .局部变量 i, 整数型
    .局部变量 返回, 文本型

    返回 ＝ “”
    .计次循环首 (取数组成员数 (cookie_s), i)
        返回 ＝ 返回 ＋ cookie_s [i].健 ＋ “=” ＋ cookie_s [i].值 ＋ “; ”
    .计次循环尾 ()
    返回 ＝ 取文本左边 (返回, 取文本长度 (返回) － 2)
    返回 (返回)

.子程序 取全部Cookie, 逻辑型, 公开, 如果当前对象没有Cookie则返回假
    .参数 Cookie数组, Cookie, 参考 数组, 返回的cookie所存放的数组

    .如果真 (取数组成员数 (cookie_s) ≤ 0)
        返回 (假)
        
    .如果真结束
    加入成员 (Cookie数组, cookie_s)
    返回 (真)

.子程序 取Cookie值, 文本型, 公开, 根据键取值 成功返回对应的值 失败返回空
    .参数 CookieKey, 文本型, , cookie健
    .局部变量 i, 整数型

    .计次循环首 (取数组成员数 (cookie_s), i)
        .如果真 (cookie_s [i].健 ＝ CookieKey)
            返回 (cookie_s [i].值)
        .如果真结束
        
    .计次循环尾 ()
    返回 (“”)

.子程序 取Cookie组, 文本型, 公开, 返回一组cookie
    .参数 CookieKey, 文本型, , cookie健

    .如果真 (取Cookie值 (CookieKey) ＝ “”)
        返回 (“”)
    .如果真结束
    返回 (CookieKey ＋ “=” ＋ 取Cookie值 (CookieKey))

.子程序 取Cookie组对象, Cookie, 公开, 返回一组cookie对象
    .参数 CookieKey, 文本型, , cookie健，也就是cookie名称
    .局部变量 i, 整数型
    .局部变量 f, Cookie

    .计次循环首 (取数组成员数 (cookie_s), i)
        .如果真 (cookie_s [i].健 ＝ CookieKey)
            f ＝ cookie_s [i]
        .如果真结束
        
    .计次循环尾 ()
    返回 (f)

.子程序 Cookie是否存在, 逻辑型, 公开, 根据key判断cookie中是否存在
    .参数 cookieKey, 文本型, , 需要判断的cookie的key
    .局部变量 i, 整数型

    .计次循环首 (取数组成员数 (cookie_s), i)
        .如果真 (cookie_s [i].健 ＝ cookieKey)
            返回 (真)
        .如果真结束
        
    .计次循环尾 ()
    返回 (假)
    

.子程序 Cookie是否存在数组中, 逻辑型, 公开, 根据key判断指定的cookie数组中是否存在
    .参数 CookieKey, 文本型, , 需要判断的cookie的key
    .参数 Cookie数组, Cookie, 数组, Cookie数组
    .局部变量 i, 整数型

    .计次循环首 (取数组成员数 (Cookie数组), i)
        .如果真 (Cookie数组 [i].健 ＝ CookieKey)
            返回 (真)
        .如果真结束
        
    .计次循环尾 ()
    返回 (假)
    

.子程序 Cookie是否存在文本中, 逻辑型, 公开, 根据key判断指定的cookie字符串文本中是否存在
    .参数 CookieKey, 文本型, , 需要判断的cookie的key
    .参数 Cookie文本, 文本型, , Cookie文本
    .局部变量 Cookie数组, Cookie, , "0", Cookie数组
    .局部变量 i, 整数型

    Cookie解析 (Cookie文本, Cookie数组)
    .如果真 (取数组成员数 (Cookie数组) ＞ 0)
        .计次循环首 (取数组成员数 (Cookie数组), i)
            .如果真 (Cookie数组 [i].健 ＝ CookieKey)
                返回 (真)
            .如果真结束
            
        .计次循环尾 ()
        
    .如果真结束
    返回 (假)
    

.版本 2

.程序集 类_DOM, , 公开
.程序集变量 类成员_对象, 对象

.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
    ' https://bbs.125.la/forum.php?mod=viewthread&tid=14482679
    ' CoInitialize (0)

.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
    ' CoUninitialize ()

.子程序 创建, 逻辑型, 公开
    .局部变量 ww, 逻辑型
    .局部变量 局_对象, 对象

    ww ＝ 局_对象.创建 (“{25336920-03F9-11CF-8FD0-00AA00686F13}”, )
    局_对象.写属性 (“designMode”, “on”)
    类成员_对象 ＝ 局_对象
    返回 (ww)

.子程序 解析, 逻辑型, 公开
    .参数 html文本, 文本型
    .局部变量 ww, 逻辑型
    .局部变量 局_对象, 对象

    ww ＝ 局_对象.创建 (“{25336920-03F9-11CF-8FD0-00AA00686F13}”, )
    局_对象.写属性 (“designMode”, “on”)
    类成员_对象.清除 ()
    类成员_对象 ＝ 局_对象
    类成员_对象.方法 (“write”, html文本)
    返回 (真)

.子程序 _____继承______, , 公开, 内部使用,外部别用
    .参数 参数_对象, 对象, 参考

    类成员_对象 ＝ 参数_对象

.子程序 取节点_按节点名_数组, 类_DOM_数组, 公开, TagName 建议在解析主对象用,返回的对象不一定有用 有效,------------需要.读对象型属性 (“body”, )
    .参数 参数_节点名, 文本型
    .局部变量 局_dom, 类_DOM_数组

    局_dom._____继承______ (类成员_对象.对象型方法 (“getElementsByTagName”, 参数_节点名))
    返回 (局_dom)

.子程序 取节点_按Name_数组, 类_DOM_数组, 公开, Name   有效
    .参数 Name, 文本型
    .局部变量 局_dom_pro, 类_DOM_数组

    局_dom_pro._____继承______ (类成员_对象.对象型方法 (“getElementsByName”, Name))
    返回 (局_dom_pro)

.子程序 取节点_按Class_数组, 类_DOM_数组, 公开, Class 测试有效,.读对象型属性 (“body”, )
    .参数 class, 文本型
    .局部变量 局_dom_pro, 类_DOM_数组

    局_dom_pro._____继承______ (类成员_对象.对象型方法 (“getElementsByClassName”, class))
    返回 (局_dom_pro)

.子程序 取节点_数组_全部子节点, 类_DOM_数组, 公开, css表达式 测试有效.---.读对象型属性 (“body”, )
    .局部变量 局_dom_pro, 类_DOM_数组

    局_dom_pro._____继承______ (类成员_对象.读对象型属性 (“childNodes”, ))
    返回 (局_dom_pro)

.子程序 取节点_数组_全部后代, 类_DOM_数组, 公开, css表达式 测试有效.---.读对象型属性 (“body”, )
    .局部变量 局_dom_pro, 类_DOM_数组

    局_dom_pro._____继承______ (类成员_对象.读对象型属性 (“all”, ))
    返回 (局_dom_pro)

.子程序 _css_数组, 类_DOM_数组, 公开, css表达式 可用
    .参数 css表达式, 文本型, 参考
    .局部变量 局_dom_pro, 类_DOM_数组

    局_dom_pro._____继承______ (类成员_对象.对象型方法 (“querySelectorAll”, css表达式))
    返回 (局_dom_pro)

.子程序 _css_数组2, 类_DOM_数组, 公开, css表达式 可用
    .参数 css表达式, 文本型, 参考
    .局部变量 局_dom_pro, 类_DOM_数组
    .局部变量 html文本, 文本型
    .局部变量 局_对象, 对象
    .局部变量 局_对象2, 对象

    html文本 ＝ “<html><body>” ＋ 类成员_对象.读文本属性 (“outerHTML”, ) ＋ “</body></html>”
    局_对象.创建 (“{25336920-03F9-11CF-8FD0-00AA00686F13}”, )
    局_对象.写属性 (“designMode”, “on”)
    局_对象.方法 (“write”, html文本)
    局_对象2 ＝ 局_对象.对象型方法 (“querySelectorAll”, css表达式)
    局_dom_pro._____继承______ (局_对象2)
    返回 (局_dom_pro)

.子程序 _css_1, 类_DOM, 公开, css表达式 只返回首个匹配结果
    .参数 css表达式, 文本型
    .局部变量 局_dom_pro, 类_DOM

    局_dom_pro._____继承______ (类成员_对象.对象型方法 (“querySelector”, css表达式))
    返回 (局_dom_pro)

.子程序 取节点_按id_1, 类_DOM, 公开
    .参数 参数_ID, 文本型
    .局部变量 局_dom_pro, 类_DOM

    局_dom_pro._____继承______ (类成员_对象.对象型方法 (“getElementById”, 参数_ID))
    返回 (局_dom_pro)

.子程序 取父节点_1, 类_DOM, 公开, css表达式 测试有效......读对象型属性 (“body”, )
    .局部变量 局_dom_pro, 类_DOM

    局_dom_pro._____继承______ (类成员_对象.读对象型属性 (“parentNode”, ))
    返回 (局_dom_pro)

.子程序 _Body_, 类_DOM, 公开
    .局部变量 局_dom, 类_DOM

    局_dom._____继承______ (类成员_对象.读对象型属性 (“body”, ))
    返回 (局_dom)

.子程序 取框架_iframe, 类_DOM, 公开, iframe
    .局部变量 局_dom, 类_DOM

    返回 (局_dom)

.子程序 是否有某属性, 逻辑型, 公开, 有用
    .参数 属性名_参数, 文本型

    返回 (类成员_对象.逻辑方法 (“hasAttribute”, 属性名_参数))

.子程序 是否有_属性, 逻辑型, 公开, 有用
    返回 (类成员_对象.逻辑方法 (“hasAttributes”, ))

.子程序 是否有子节点, 逻辑型, 公开, so   有用
    返回 (类成员_对象.逻辑方法 (“hasChildNodes”, ))

.子程序 取节点类型, 整数型, 公开, 某个数字代表某个类型,需要翻译
    返回 (到整数 (类成员_对象.读数值属性 (“nodeType”, )))

.子程序 取属性值_按属性名, 文本型, 公开, value   有用
    .参数 属性名_参数, 文本型

    返回 (类成员_对象.文本方法 (“getAttribute”, 属性名_参数))

.子程序 取节点名, 文本型, 公开, 标签名
    返回 (类成员_对象.读文本属性 (“tagName”, ))

.子程序 取title, 文本型, 公开, 标题
    返回 (类成员_对象.读文本属性 (“title”, ))

.子程序 取ID, 文本型, 公开, id
    返回 (类成员_对象.读文本属性 (“id”, ))

.子程序 取class, 文本型, 公开
    返回 (类成员_对象.读文本属性 (“className”, ))

.子程序 取href, 文本型, 公开, href,就是链接,网页中的链接
    返回 (类成员_对象.读文本属性 (“href”, ))

.子程序 取outerText, 文本型, 公开
    返回 (类成员_对象.读文本属性 (“outerText”, ))

.子程序 取innerText, 文本型, 公开
    返回 (类成员_对象.读文本属性 (“innerText”, ))

.子程序 取textContent, 文本型, 公开, 本节点可见字符串
    返回 (类成员_对象.读文本属性 (“textContent”, ))

.子程序 取innerHTML, 文本型, 公开, 全部后代源码,不包含自己
    返回 (类成员_对象.读文本属性 (“innerHTML”, ))

.子程序 取outerHTML, 文本型, 公开, 全部后代源码,包含自己
    返回 (类成员_对象.读文本属性 (“outerHTML”, ))

.版本 2

.程序集 类_DOM_数组, , 公开
.程序集变量 类成员_对象, 对象

.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
    

.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
    

.子程序 _____继承______, , 公开, 内部使用,外部别用
    .参数 参数_对象, 对象, 参考

    类成员_对象 ＝ 参数_对象

.子程序 _, 类_DOM, 公开, 取成员
    .参数 索引, 整数型, 可空, 从1开始,为空就是第一个
    .局部变量 局_DOM, 类_DOM

    索引 ＝ 选择 (是否为空 (索引), 1, 索引)
    局_DOM._____继承______ (类成员_对象.对象型方法 (“item”, 索引 － 1))
    返回 (局_DOM)

.子程序 取成员, 类_DOM, 公开, 取成员
    .参数 索引, 整数型, 可空, 从1开始,为空就是第一个
    .局部变量 局_DOM, 类_DOM

    索引 ＝ 选择 (是否为空 (索引), 1, 索引)
    局_DOM._____继承______ (类成员_对象.对象型方法 (“item”, 索引 － 1))
    返回 (局_DOM)

.子程序 取成员数, 整数型, 公开, 取成员数
    返回 (到整数 (类成员_对象.读数值属性 (“length”, )))

.版本 2

.程序集 类_FTP, , 公开
.程序集变量 初始句柄, 整数型
.程序集变量 连接句柄, 整数型

.子程序 是否已连接, 逻辑型, 公开, 判断FTP是否已连接服务器；
    返回 (连接句柄 ≠ 0)

.子程序 连接FTP服务器, 逻辑型, 公开, 连接FTP服务器；
    .参数 FTP服务器地址, 文本型
    .参数 用户名, 文本型, 可空
    .参数 密码, 文本型, 可空
    .参数 端口号, 整数型, 可空
    .参数 是否被动模式, 逻辑型, 可空
    .局部变量 Flags, 整数型

    .如果真 (是否为空 (用户名))
        用户名 ＝ “anonymous”
    .如果真结束
    .如果真 (是否为空 (密码))
        密码 ＝ 字符 (0)
    .如果真结束
    .如果真 (是否为空 (端口号))
        端口号 ＝ 21
    .如果真结束
    初始句柄 ＝ InternetOpenA (字符 (0), 1, 字符 (0), 字符 (0), 0)
    Flags ＝ 0
    .如果真 (是否被动模式)
        Flags ＝ 位或 (Flags, #INTERNET_FLAG_PASSIVE)
    .如果真结束
    连接句柄 ＝ InternetConnectA (初始句柄, FTP服务器地址, 端口号, 用户名, 密码, 1, Flags, 0)
    .如果真 (连接句柄 ≠ 0)
        返回 (真)
    .如果真结束
    断开FTP服务器 ()
    返回 (假)

.子程序 断开FTP服务器, 逻辑型, 公开, 断开FTP服务器；
    .局部变量 局_结果, 逻辑型

    .如果真 (连接句柄 ≠ #NULL)
        局_结果 ＝ InternetCloseHandle (连接句柄)
    .如果真结束
    .如果真 (局_结果)
        连接句柄 ＝ 0
    .如果真结束
    .如果真 (初始句柄 ≠ #NULL)
        局_结果 ＝ InternetCloseHandle (初始句柄)
    .如果真结束
    返回 (局_结果)

.子程序 目录创建, 逻辑型, 公开, 在FTP上创建目录；
    .参数 欲创建的目录名, 文本型, , 欲创建的目录名；

    .如果真 (连接句柄 ≠ 0)
        返回 (FtpCreateDirectoryA (连接句柄, 欲创建的目录名))
    .如果真结束
    返回 (假)

.子程序 目录删除, 逻辑型, 公开, 删除FTP上指定的目录；
    .参数 欲删除的目录名, 文本型, , 欲删除的目录名；

    .如果真 (连接句柄 ≠ 0)
        返回 (FtpRemoveDirectoryA (连接句柄, 欲删除的目录名))
    .如果真结束
    返回 (假)

.子程序 目录下载, 逻辑型, 公开, 下载FTP上指定的目录；
    .参数 欲下载的FTP目录, 文本型, , 欲下载的FTP目录名；
    .参数 本地目录, 文本型, , 注意，本地目录必须存在；
    .参数 是否使用ASCII码方式, 逻辑型, 可空
    .参数 错误信息, 文本型, 参考 数组, 返回下载
    .局部变量 文件, 文本型, , "0"
    .局部变量 属性, 整数型, , "0"
    .局部变量 计次, 整数型

    .如果真 (目录_是否存在 (本地目录) ＝ 假)
        目录_创建 (本地目录)
    .如果真结束
    .如果真 (连接句柄 ＝ 0 或 PathIsDirectoryA (本地目录) ≠ 16)
        返回 (假)
    .如果真结束
    .计次循环首 (目录列表 (欲下载的FTP目录, , 文件, 属性, , ), 计次)
        .如果真 (位与 (属性 [计次], 16) ＝ 0)
            .如果真 (文件下载 (欲下载的FTP目录 ＋ “/” ＋ 文件 [计次], 本地目录 ＋ “\” ＋ 文件 [计次], 是否使用ASCII码方式) ＝ 假)
                加入成员 (错误信息, 欲下载的FTP目录 ＋ “/” ＋ 文件 [计次])
            .如果真结束
            到循环尾 ()
        .如果真结束
        .如果真 (文件 [计次] ＝ “.” 或 文件 [计次] ＝ “..”)
            到循环尾 ()
        .如果真结束
        .如果真 (目录下载 (欲下载的FTP目录 ＋ “/” ＋ 文件 [计次], 本地目录 ＋ “\” ＋ 文件 [计次], 是否使用ASCII码方式, 错误信息) ＝ 假)
            加入成员 (错误信息, 欲下载的FTP目录 ＋ “/” ＋ 文件 [计次])
        .如果真结束
        处理事件 ()
    .计次循环尾 ()
    返回 (计次 ≠ 0 且 取数组成员数 (文件) ＝ 计次 － 1)

.子程序 目录上传, 逻辑型, 公开, 上传指定目录到FTP上；
    .参数 欲上传的本地目录, 文本型
    .参数 FTP目录路径, 文本型, , 目录要存在。
    .参数 是否使用ASCII码方式, 逻辑型, 可空
    .局部变量 文本, 文本型
    .局部变量 文件, 文本型, , "0"
    .局部变量 计次, 整数型

    .如果真 (目录是否存在 (FTP目录路径) ＝ 假)
        .如果真 (目录创建 (FTP目录路径) ＝ 假)
            返回 (假)
        .如果真结束
        
    .如果真结束
    .如果真 (连接句柄 ＝ 0 或 PathIsDirectoryA (欲上传的本地目录) ≠ 16)
        返回 (假)
    .如果真结束
    文本 ＝ 寻找文件 (欲上传的本地目录 ＋ “\*”, )
    .判断循环首 (文本 ≠ “”)
        .如果真 (文本 ≠ “.” 且 文本 ≠ “..”)
            加入成员 (文件, 文本)
        .如果真结束
        文本 ＝ 寻找文件 (, )
    .判断循环尾 ()
    .计次循环首 (取数组成员数 (文件), 计次)
        .如果真 (文件上传 (欲上传的本地目录 ＋ “\” ＋ 文件 [计次], FTP目录路径 ＋ “\” ＋ 文件 [计次], 到数值 (是否使用ASCII码方式)) ＝ 假)
            返回 (假)
        .如果真结束
        
    .计次循环尾 ()
    文本 ＝ “”
    清除数组 (文件)
    文本 ＝ 寻找文件 (欲上传的本地目录 ＋ “\*”, 16)
    .判断循环首 (文本 ≠ “”)
        .如果真 (文本 ≠ “.” 且 文本 ≠ “..”)
            加入成员 (文件, 文本)
        .如果真结束
        文本 ＝ 寻找文件 (, 16)
    .判断循环尾 ()
    .计次循环首 (取数组成员数 (文件), 计次)
        FtpCreateDirectoryA (连接句柄, FTP目录路径 ＋ “\” ＋ 文件 [计次])
        .如果真 (目录上传 (欲上传的本地目录 ＋ “\” ＋ 文件 [计次], FTP目录路径 ＋ “\” ＋ 文件 [计次], 是否使用ASCII码方式) ＝ 假)
            返回 (假)
        .如果真结束
        
    .计次循环尾 ()
    返回 (真)

.子程序 目录列表, 整数型, 公开, 枚举FTP指定目录里的所有文件；返回找到的文件个数；
    .参数 欲列出的文件类型, 文本型, 可空, 可空；留空取所有文件；或是指定文件类型，如："*.txt"；
    .参数 欲列出的文件属性, 整数型, 可空, 欲列出的文件属性:1、#只读文件； 2、#隐藏文件； 4、#系统文件； 16、#子目录； 32、#存档文件。通过将这些常量值加起来可以一次设置多个文件属性。如果省略本参数，默认为搜寻所有文件。
    .参数 存放文件名的数组, 文本型, 参考 可空 数组, 用于存放文件名的数组；
    .参数 存放文件属性数组, 整数型, 参考 可空 数组, 用于存放文件属性数组；
    .参数 存放文件尺寸数组, 长整数型, 参考 可空 数组, 用于存放文件尺寸数组；
    .参数 存放文件时间数组, 日期时间型, 参考 可空 数组, 用于存放文件时间数组；
    .局部变量 hFind, 整数型
    .局部变量 文件信息, 查找的文件信息
    .局部变量 局_目录名, 文本型
    .局部变量 nFileSizeLow, 长整数型
    .局部变量 nFileSizeHigh, 长整数型

    .如果真 (欲列出的文件类型 ＝ “”)
        欲列出的文件类型 ＝ “*.*”
    .如果真结束
    清除数组 (存放文件名的数组)
    清除数组 (存放文件属性数组)
    清除数组 (存放文件尺寸数组)
    清除数组 (存放文件时间数组)
    .如果真 (连接句柄 ＝ 0)
        返回 (0)
    .如果真结束
    .如果真 (是否为空 (欲列出的文件属性))
        欲列出的文件属性 ＝ 1 ＋ 2 ＋ 4 ＋ 16 ＋ 32
    .如果真结束
    欲列出的文件属性 ＝ 欲列出的文件属性 ＋ 128
    hFind ＝ FtpFindFirstFileA (连接句柄, 欲列出的文件类型, 文件信息, #INTERNET_FLAG_RELOAD, 0)
    .如果真 (hFind ＝ 0)
        返回 (0)
    .如果真结束
    .循环判断首 ()
        局_目录名 ＝ 字节数组_到文本 (文件信息.cFileName)
        .判断开始 (位与 (文件信息.dwFileAttributes, 欲列出的文件属性) ＝ 0)
            到循环尾 ()
        .判断 (取文本左边 (局_目录名, 1) ＝ “.”)
            到循环尾 ()
        .默认
            
        .判断结束
        加入成员 (存放文件名的数组, 局_目录名)
        加入成员 (存放文件属性数组, 文件信息.dwFileAttributes)
        nFileSizeLow ＝ 取字节集数据 (到字节集 (文件信息.nFileSizeLow), #长整数型, )
        nFileSizeHigh ＝ 取字节集数据 (到字节集 (文件信息.nFileSizeHigh), #长整数型, )
        加入成员 (存放文件尺寸数组, nFileSizeLow ＋ nFileSizeHigh × 4294967296)
        加入成员 (存放文件时间数组, 系统_时间变时间 (文件信息.ftLastWriteTime))
        处理事件 ()
    .循环判断尾 (InternetFindNextFileA (hFind, 文件信息) ≠ 0)
    InternetCloseHandle (hFind)
    返回 (取数组成员数 (存放文件名的数组))

.子程序 置现行目录, 逻辑型, 公开, 置现行目录；
    .参数 FTP目录路径, 文本型, , FTP目录路径；

    .如果真 (连接句柄 ≠ 0)
        返回 (FtpSetCurrentDirectoryA (连接句柄, FTP目录路径))
    .如果真结束
    返回 (假)

.子程序 取现行目录, 文本型, 公开, 取现行目录；
    .局部变量 目录, 文本型
    .局部变量 长度, 整数型

    .如果真 (连接句柄 ≠ 0)
        长度 ＝ 0
        FtpGetCurrentDirectoryA (连接句柄, 目录, 长度)
        目录 ＝ 取空白文本 (长度)
        FtpGetCurrentDirectoryA (连接句柄, 目录, 长度)
        返回 (目录)
    .如果真结束
    返回 (“”)

.子程序 文件删除, 逻辑型, 公开, 删除FTP上指定的文件；
    .参数 欲删除的FTP文件名, 文本型, , 欲删除的FTP文件名；

    .如果真 (连接句柄 ≠ 0)
        返回 (FtpDeleteFileA (连接句柄, 欲删除的FTP文件名))
    .如果真结束
    返回 (假)

.子程序 文件更名, 逻辑型, 公开, 更改FTP上指定文件的名字；
    .参数 欲改名的FTP文件名, 文本型, , 欲改名的FTP文件；
    .参数 新文件名称, 文本型, , 新文件名称；

    .如果真 (连接句柄 ≠ 0)
        返回 (FtpRenameFileA (连接句柄, 欲改名的FTP文件名, 新文件名称))
    .如果真结束
    返回 (假)

.子程序 文件下载, 逻辑型, 公开, 下载FTP上指定的文件；
    .参数 欲下载的FTP文件, 文本型, , ‘/1.txt 注意这里需要使用/
    .参数 本地文件名_绝对路径, 文本型, , 要保存到本地的路径，带文件名
    .参数 是否使用ASCII码方式, 逻辑型, 可空
    .局部变量 方式, 整数型

    .如果真 (连接句柄 ≠ 0)
        .如果真 (是否为空 (是否使用ASCII码方式))
            是否使用ASCII码方式 ＝ 假
            方式 ＝ 2
        .如果真结束
        .如果 (是否使用ASCII码方式)
            方式 ＝ 位或 (1, #INTERNET_FLAG_RELOAD) ' Forces a download of the requested file, object, or directory listing from the origin server, not from the cache.
        .否则
            方式 ＝ 位或 (2, #INTERNET_FLAG_RELOAD) ' #INTERNET_FLAG_RELOAD 防止下载缓存文件
        .如果结束
        返回 (FtpGetFileA (连接句柄, 欲下载的FTP文件, 本地文件名_绝对路径, 0, 0, 方式, 0))
    .如果真结束
    返回 (假)

.子程序 文件上传, 逻辑型, 公开, 上传指定文件到FTP上；
    .参数 欲上传的本地文件, 文本型, , 如：C:\012.txt
    .参数 FTP文件路径, 文本型, , 如：/www/012.txt   请注意/，别用成\了。
    .参数 文件上传方式, 整数型, 可空, 可空。默认为2  1=ASCII方式 2=二进制方式

    .如果真 (是否为空 (文件上传方式) 或 文件上传方式 ＝ 0)
        文件上传方式 ＝ 2
    .如果真结束
    .如果真 (连接句柄 ≠ 0)
        返回 (FtpPutFileA (连接句柄, 欲上传的本地文件, FTP文件路径, 文件上传方式, 0))
    .如果真结束
    返回 (假)

.子程序 文件取大小, 长整数型, 公开, 取出FTP上指定文件的大小；
    .参数 FTP文件路径, 文本型
    .局部变量 句柄, 整数型
    .局部变量 大小, , , "2"
    .局部变量 nFileSizeLow, 长整数型
    .局部变量 nFileSizeHigh, 长整数型

    .如果真 (连接句柄 ＝ 0)
        返回 (0)
    .如果真结束
    句柄 ＝ FtpOpenFileA (连接句柄, FTP文件路径, 2147483648, 2, 0)
    .如果真 (句柄 ＝ 0)
        返回 (0)
    .如果真结束
    大小 [1] ＝ FtpGetFileSize (句柄, 大小 [2])
    nFileSizeLow ＝ 取字节集数据 (到字节集 (大小 [1]), #长整数型, )
    nFileSizeHigh ＝ 取字节集数据 (到字节集 (大小 [2]), #长整数型, )
    InternetCloseHandle (句柄)
    返回 (nFileSizeLow ＋ nFileSizeHigh × 4294967296)

.子程序 目录取大小, 长整数型, 公开, 取出FTP上指定目录的大小；
    .参数 FTP目录路径, 文本型
    .局部变量 文件, 文本型, , "0"
    .局部变量 大小, 长整数型, , "0"
    .局部变量 属性, 整数型, , "0"
    .局部变量 结果, 长整数型
    .局部变量 计次, 整数型

    .如果真 (连接句柄 ＝ 0)
        返回 (0)
    .如果真结束
    .计次循环首 (目录列表 (FTP目录路径, , 文件, 属性, 大小), 计次)
        .如果真 (文件 [计次] ＝ “.” 或 文件 [计次] ＝ “..”)
            到循环尾 ()
        .如果真结束
        .如果真 (位与 (属性 [计次], 16) ＝ 0)
            结果 ＝ 结果 ＋ 大小 [计次]
            到循环尾 ()
        .如果真结束
        结果 ＝ 结果 ＋ 目录取大小 (FTP目录路径 ＋ “\” ＋ 文件 [计次])
    .计次循环尾 ()
    返回 (结果)

.子程序 文件取属性, 整数型, 公开, 取出FTP上指定文件的属性；
    .参数 FTP文件路径, 文本型
    .参数 区分大小写, 逻辑型, 可空, 默认为假！不区分大小写。
    .局部变量 计次, 整数型
    .局部变量 文本, 文本型
    .局部变量 查找的文件信息, 查找的文件信息
    .局部变量 寻找结果, 整数型
    .局部变量 文件属性, 整数型

    .如果真 (连接句柄 ＝ 0)
        返回 (-1)
    .如果真结束
    .如果 (区分大小写 ＝ 假)
        文本 ＝ 文本_到小写 (FTP文件路径)
    .否则
        文本 ＝ FTP文件路径
    .如果结束
    寻找结果 ＝ FtpFindFirstFileA (连接句柄, 文本, 查找的文件信息, #INTERNET_FLAG_RELOAD, 0)
    .如果真 (寻找结果 ＝ 0)
        返回 (-1)
    .如果真结束
    文件属性 ＝ 查找的文件信息.dwFileAttributes
    InternetCloseHandle (寻找结果)
    返回 (文件属性)

.子程序 目录取属性, 整数型, 公开, 取出FTP上指定目录的属性；
    .参数 FTP目录路径, 文本型
    .参数 区分大小写, 逻辑型, 可空, 默认为假！不区分大小写。
    .局部变量 文本, 文本型
    .局部变量 目录, 文本型, , "0"
    .局部变量 属性, 整数型, , "0"
    .局部变量 计次, 整数型

    .如果真 (连接句柄 ＝ 0)
        返回 (0)
    .如果真结束
    文本 ＝ 文本_去斜杠 (PathFindFileNameA (FTP目录路径))
    .如果真 (区分大小写 ＝ 假)
        文本 ＝ 文本_到小写 (文本)
    .如果真结束
    .计次循环首 (目录列表 (FTP目录路径 ＋ “/../*”, 16, 目录, 属性), 计次)
        .如果真 (文本_到小写 (目录 [计次]) ＝ 文本)
            返回 (属性 [计次])
        .如果真结束
        
    .计次循环尾 ()
    返回 (0)

.子程序 文件取时间, 日期时间型, 公开, 返回文件最后修改时间。失败返回100年1月1日
    .参数 FTP文件路径, 文本型
    .参数 区分大小写, 逻辑型, 可空, 默认为假！不区分大小写。
    .局部变量 计次, 整数型
    .局部变量 文本, 文本型
    .局部变量 查找的文件信息, 查找的文件信息
    .局部变量 寻找结果, 整数型
    .局部变量 文件时间, 日期时间型
    .局部变量 系统时间, 精易_时间

    .如果真 (连接句柄 ＝ 0)
        返回 ([1899年12月30日])
    .如果真结束
    .如果 (区分大小写 ＝ 假)
        文本 ＝ 文本_到小写 (FTP文件路径)
    .否则
        文本 ＝ FTP文件路径
    .如果结束
    寻找结果 ＝ FtpFindFirstFileA (连接句柄, 文本, 查找的文件信息, #INTERNET_FLAG_RELOAD, 0)
    .如果真 (寻找结果 ＝ 0)
        返回 ([1899年12月30日])
    .如果真结束
    InternetCloseHandle (寻找结果)
    返回 (系统_时间变时间 (查找的文件信息.ftLastWriteTime))

.子程序 目录取时间, 日期时间型, 公开, 返回目录最后修改时间。
    .参数 FTP目录路径, 文本型
    .参数 区分大小写, 逻辑型, 可空, 默认为假！不区分大小写。
    .局部变量 文本, 文本型
    .局部变量 目录, 文本型, , "0"
    .局部变量 时间, 日期时间型, , "0"
    .局部变量 计次, 整数型
    .局部变量 null, 日期时间型

    .如果真 (连接句柄 ＝ 0)
        返回 (null)
    .如果真结束
    文本 ＝ 文本_去斜杠 (PathFindFileNameA (FTP目录路径))
    .如果真 (区分大小写 ＝ 假)
        文本 ＝ 文本_到小写 (文本)
    .如果真结束
    .计次循环首 (目录列表 (FTP目录路径 ＋ “\..\*”, 16, 目录, , , 时间), 计次)
        .如果真 (文本_到小写 (目录 [计次]) ＝ 文本)
            返回 (时间 [计次])
        .如果真结束
        
    .计次循环尾 ()
    返回 (null)

.子程序 文件是否存在, 逻辑型, 公开, 判断FTP指定的文件是否存在；存在返回真，不存在返回假；
    .参数 FTP文件路径, 文本型
    .参数 区分大小写, 逻辑型, 可空, 默认为假！不区分大小写。
    .局部变量 文本, 文本型
    .局部变量 查找的文件信息, 查找的文件信息
    .局部变量 寻找结果, 整数型
    .局部变量 返回值, 逻辑型

    返回值 ＝ 假
    .如果真 (连接句柄 ＝ 0)
        返回 (假)
    .如果真结束
    .如果 (区分大小写 ＝ 假)
        文本 ＝ 文本_到小写 (FTP文件路径)
    .否则
        文本 ＝ FTP文件路径
    .如果结束
    寻找结果 ＝ FtpFindFirstFileA (连接句柄, 文本, 查找的文件信息, #INTERNET_FLAG_RELOAD, 0)
    .如果真 (寻找结果 ≠ 0)
        返回值 ＝ 真
    .如果真结束
    InternetCloseHandle (寻找结果)
    返回 (返回值)

.子程序 目录是否存在, 逻辑型, 公开, 判断FTP指定的目录是否存在；存在返回真，不存在返回假；
    .参数 FTP目录路径, 文本型
    .参数 区分大小写, 逻辑型, 可空, 默认为假！不区分大小写。
    .局部变量 文本, 文本型
    .局部变量 目录, 文本型, , "0"
    .局部变量 计次, 整数型

    .如果真 (连接句柄 ＝ 0)
        返回 (假)
    .如果真结束
    文本 ＝ 文本_去斜杠 (PathFindFileNameA (FTP目录路径))
    .如果真 (区分大小写 ＝ 假)
        文本 ＝ 文本_到小写 (文本)
    .如果真结束
    .计次循环首 (目录列表 (FTP目录路径 ＋ “/../*”, 16, 目录, , , ), 计次)
        .如果真 (文本_到小写 (目录 [计次]) ＝ 文本)
            返回 (真)
        .如果真结束
        
    .计次循环尾 ()
    返回 (假)

.子程序 进度下载, 逻辑型, 公开
    .参数 网络文件, 文本型
    .参数 本地文件, 文本型
    .参数 下载回调, 子程序指针, 可空, 3个参数；1＝已下载，长整数型指针。2=速度，整数型。3＝百分比，整数型。
    .局部变量 hOpen
    .局部变量 hOpenUrl
    .局部变量 bool, 逻辑型
    .局部变量 sReadBuffer, 字节型, , "0"
    .局部变量 lNumberOfBytesRead
    .局部变量 lCount, 长整数型
    .局部变量 hHttpQueryInfo
    .局部变量 sBuffer, 文本型
    .局部变量 FileSize
    .局部变量 handle
    .局部变量 StartTime
    .局部变量 TotalReadSize
    .局部变量 TimeConsuming, 整数型
    .局部变量 lSpeed, 整数型
    .局部变量 进度, , , , 单位：百分比。

    FileSize ＝ 文件取大小 (网络文件)
    .如果真 (FileSize ＝ 0)
        返回 (假)
    .如果真结束
    hOpenUrl ＝ FtpOpenFileA (连接句柄, 网络文件, -2147483648, 2, 0)
    .如果真 (hOpenUrl ＝ 0)
        返回 (假)
    .如果真结束
    handle ＝ 打开文件 (本地文件, 6, 1)
    StartTime ＝ GetTickCount ()
    .循环判断首 ()
        重定义数组 (sReadBuffer, 假, 2048)
        bool ＝ InternetReadFile_Byte (hOpenUrl, sReadBuffer, 2048, lNumberOfBytesRead)
        .如果 (lNumberOfBytesRead ＞ 0 且 bool)
            重定义数组 (sReadBuffer, 真, lNumberOfBytesRead)
            ' sReadBuffer ＝ 取空白字节集 (lNumberOfBytesRead)
            lCount ＝ lCount ＋ lNumberOfBytesRead ' 已下载
            写出数据 (handle, sReadBuffer)
            TotalReadSize ＝ TotalReadSize ＋ lNumberOfBytesRead
            TimeConsuming ＝ GetTickCount () － StartTime
            .如果真 (TimeConsuming ＞ 0)
                lSpeed ＝ TotalReadSize ÷ TimeConsuming ' 速度
            .如果真结束
            进度 ＝ 取整 (lCount ÷ FileSize × 100) ' 百分比
            .如果真 (是否为空 (下载回调) ＝ 假 或 到整数 (下载回调) ≠ 0)
                程序_Call (到整数 (下载回调), 取指针地址_长整数型 (lCount), lSpeed, 进度, , )
            .如果真结束
            处理事件 ()
        .否则
            跳出循环 ()
        .如果结束
        处理事件 ()
    .循环判断尾 (lNumberOfBytesRead ≠ 0)
    关闭文件 (handle)
    InternetCloseHandle (hOpen)
    InternetCloseHandle (hOpenUrl)
    返回 (真)

.子程序 系统_时间变时间, 日期时间型
    .参数 文件时间, FILETIME
    .局部变量 系统时间, 精易_时间
    .局部变量 时间, 日期时间型

    FileTimeToSystemTime (文件时间, 系统时间)
    SystemTimeToVariantTime (系统时间, 时间)
    返回 (时间)

.子程序 字节数组_到文本, 文本型
    .参数 字节数组, 字节型, 数组
    .局部变量 数组, 字节型, , "0"

    .如果真 (取数组成员数 (字节数组) ＝ 0)
        返回 (“”)
    .如果真结束
    数组 ＝ 字节数组
    加入成员 (数组, 0)
    返回 (lstrcpynA_字节型 (数组, 0, 0))

.子程序 文本_去斜杠, 文本型
    .参数 文本, 文本型
    .局部变量 长度, 整数型
    .局部变量 临时文本, 文本型

    临时文本 ＝ 文本
    .循环判断首 ()
        长度 ＝ lstrlenA (取指针文本_ (临时文本))
        StrTrimA (临时文本, “\”)
        StrTrimA (临时文本, “/”)
    .循环判断尾 (lstrlenA (取指针文本_ (临时文本)) ≠ 长度)
    返回 (临时文本)

.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
    

.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
    断开FTP服务器 ()

.版本 2

.程序集 类_HTML实体, , 公开, 源码收录自【https://bbs.125.la/forum.php?mod=viewthread&tid=14088175】
.程序集变量 m_HashTable, HashMap_StrInt, , , 这里用到了网络上的 hashmap，我觉得很轻量，内部用的是数组，所以特点是加入稍慢，但是查询速度非常好，很符合这里的应用场景
.程序集变量 m_UTF8, 字节集
.程序集变量 m_UTF8Len, 整数型

.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
    Init ()

.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
    

.子程序 Init, , , 初始化，解码前必须主动调用
    .局部变量 arr, 文本型, , "0"
    .局部变量 i, 整数型
    .局部变量 arr2, 文本型, , "0"
    .局部变量 temp, 文本型

    m_HashTable.初始化 ()
    arr ＝ 分割文本 (#HtmlEntitiesTable, #换行符, )
    temp ＝ 字符 (9)
    .计次循环首 (取数组成员数 (arr), i)
        arr2 ＝ 分割文本 (arr [i], temp, )
        .如果真 (取数组成员数 (arr2) ＝ 2)
            m_HashTable.加入 (arr2 [1], 到整数 (arr2 [2])) ' 覆盖了两个 html4 中的规范
        .如果真结束
        
    .计次循环尾 ()
    ' 输出调试文本 (m_HashTable.取数量 () ＝ 1448)
    ' 输出调试文本 (m_HashTable.取值 (“lang”))
    

.子程序 解码_ANSI, , 公开, 反转义 ANSI 文本
    .参数 ANSI, 文本型

    解码_UTF8 (编码_Ansi到Utf8 (ANSI))

.子程序 解码_UTF8, , 公开, 反转义 UTF8 文本，内码最终选择了 UTF8，大部分网页的编码也都是 UTF8，而且可以囊括目前世界上所有的字符
    .参数 UTF8, 字节集
    .局部变量 Pos, 整数型, , , ebp-4
    .局部变量 pUTF8, 长整数型
    .局部变量 remain, 整数型
    .局部变量 prejudge, 整数型
    .局部变量 prejudge_Byte, 字节型
    .局部变量 semicolon, 长整数型
    .局部变量 semicolon_Byte, 字节型
    .局部变量 i, 整数型
    .局部变量 tempBool, 逻辑型
    .局部变量 UnicodePoint, 整数型
    .局部变量 _4BytesLen, 整数型
    .局部变量 reduce, 整数型
    .局部变量 temp, 长整数型
    .局部变量 pAnd, 长整数型

    
    ' 1、防止传入的 UTF8 尾部不带\0
    ' 2、牺牲空间但是确保不改变原始数据，而且方便 Get 时的不同编码选择
    m_UTF8 ＝ 取空白字节集 (取字节集长度 (UTF8) ＋ 1)
    RtlMoveMemory (取指针字节集_ (m_UTF8), 取指针字节集_ (UTF8), 取字节集长度 (UTF8))
    
    ' 指针和数组(字节集)下标的配合使用是我的独门秘术，虽说指针很快，但是易里面对指针 read 和 write 都需要调用别的代码，反而不会比数组寻址快，配合使用有奇效
    pUTF8 ＝ 取指针字节集_ (m_UTF8)
    ' 记住这里的长度为到第一个\0为止的 UTF8 长度
    m_UTF8Len ＝ lstrlenA (pUTF8)
    
    .判断循环首 (Pos ＜ m_UTF8Len)
        ' 查找 & 位置  找不到说明可以结束了
        pAnd ＝ strchr (pUTF8 ＋ Pos, 38) ' &
        .如果真 (pAnd ＝ 0)
            跳出循环 ()
        .如果真结束
        
        Pos ＝ pAnd － pUTF8 ＋ 1
        remain ＝ m_UTF8Len － Pos
        .如果真 (remain ＜ 3) ' 最短也是类似 &#9; 至少 4 字节
            跳出循环 ()
        .如果真结束
        
        ' 最长的是 &CapitalDifferentialD; 和 &EmptyVerySmallSquare; 有 22 字节
        ' 这个操作算是这个代码的亮点：为了限定 strchr 范围，因为这是个很慢的函数。试想如果全文都是 & 却一个 ; 也没有，每次都会搜索到字符串的结尾，将极大地干扰解码速度
        .如果 (remain ＜ 21)
            ' 此处其实有个 "BUG"   例如 &#000000000000000000000000000009; 将不会被解码，但是这种奇葩并不去考虑，因为不会有哪个转义库会生成这种
            prejudge ＝ m_UTF8Len ＋ 1 ' 尾部0
        .否则
            prejudge ＝ Pos ＋ 22
        .如果结束
        
        ' 交换变量 (prejudge_Byte, m_UTF8 [prejudge])'交换变量是按照 4 字节来对齐的
        prejudge_Byte ＝ m_UTF8 [prejudge]
        m_UTF8 [prejudge] ＝ 0
        
        ' 查找分号位置
        semicolon ＝ strchr (pUTF8 ＋ Pos － 1, 59) ' ;
        
        ' 为什么这里的分支这么多：
        ' 代码可读性，尤其是易的代码可读性，有的时候和效率是不能兼得的。
        ' 如果在这里判断反条件然后 到循环尾()，编译后势必多一条指令
        ' 而这里的判断在多数情况下都会走的是那条反条件的分支，权衡之下的选择。
        .如果 (semicolon ≠ 0) ' 指针是否会小于0
            ' 返回的是指针，算出数组下标
            semicolon ＝ semicolon － pUTF8 ＋ 1
            .如果 (semicolon － Pos ≥ 3) ' & 和 分号 之间至少有两个字节
                ' 交换变量 (semicolon_Byte, m_UTF8 [semicolon])
                semicolon_Byte ＝ m_UTF8 [semicolon] ' 同上面一样的技巧，这里的截止符是为了 StrToIntEx，继续往下看
                m_UTF8 [semicolon] ＝ 0
                
                tempBool ＝ 真
                .如果 (m_UTF8 [Pos ＋ 1] ＝ 35) ' #  则可能是十进制或者十六进制
                    .判断开始 (m_UTF8 [Pos ＋ 2] ＝ 120 或 m_UTF8 [Pos ＋ 2] ＝ 88) ' x X
                        .变量循环首 (Pos ＋ 3, semicolon － 1, 1, i)
                            .如果真 (m_UTF8 [i] ＜ 48 或 m_UTF8 [i] ＞ 57) ' 0-9
                                .如果真 (m_UTF8 [i] ＜ 65 或 m_UTF8 [i] ＞ 70) ' A-F
                                    .如果真 (m_UTF8 [i] ＜ 97 或 m_UTF8 [i] ＞ 102) ' a-f
                                        tempBool ＝ 假
                                        跳出循环 ()
                                    .如果真结束
                                    
                                .如果真结束
                                
                            .如果真结束
                            
                        .变量循环尾 ()
                        .如果真 (tempBool) ' 确定是十六进制了
                            m_UTF8 [Pos ＋ 1] ＝ 48 ' 0 构造 0x 结构
                            StrToIntExA_整数 (pUTF8 ＋ Pos, #STIF_SUPPORT_HEX, UnicodePoint)
                        .如果真结束
                        
                        
                    .判断 (48 ≤ m_UTF8 [Pos ＋ 2] 且 m_UTF8 [Pos ＋ 2] ≤ 57) ' 0-9
                        .变量循环首 (Pos ＋ 3, semicolon － 1, 1, i)
                            .如果真 (m_UTF8 [i] ＜ 48 或 m_UTF8 [i] ＞ 57) ' 0-9
                                tempBool ＝ 假
                                跳出循环 ()
                            .如果真结束
                            
                        .变量循环尾 ()
                        
                        .如果真 (tempBool) ' 确定是十进制了
                            StrToIntExA_整数 (pUTF8 ＋ Pos ＋ 1, #STIF_DEFAULT, UnicodePoint)
                        .如果真结束
                        
                        
                    .默认
                        tempBool ＝ 假
                    .判断结束
                    
                    
                .否则
                    UnicodePoint ＝ m_HashTable.取值 (指针到文本 (pUTF8 ＋ Pos)) ' 可能是关键字
                    .如果真 (UnicodePoint ＝ 0) ' 并非关键字
                        tempBool ＝ 假
                    .如果真结束
                    
                .如果结束
                
                .如果 (tempBool)
                    ' 关于这个函数（UNICODE到UTF8）：
                    ' 初学 asm，在朋友的指导下完成了一个 asm 的版本，速度肯定快了很多，压测了还行，不知道有没有坑，自行测试。
                    ' 此处发布用的是 no-asm 版本的，其实就是编码知识。
                    ' 关于速度：其实正常的 html 页面中并不会有太多的 HTML Entity，所以这里一般不会是瓶颈。
                    _4BytesLen ＝ UNICODE到UTF8_no_asm (UnicodePoint, m_UTF8 [Pos], m_UTF8 [Pos ＋ 1], m_UTF8 [Pos ＋ 2], m_UTF8 [Pos ＋ 3])
                    ' 需要改变 prejudge Pos m_UTF8 UTF8Len
                    ' 其实只要关注 \0 的位置
                    ' 分号后面的包括\0移过来
                    RtlMoveMemory (pUTF8 ＋ Pos － 1 ＋ _4BytesLen, pUTF8 ＋ semicolon, m_UTF8Len － semicolon ＋ 1)
                    
                    reduce ＝ semicolon － Pos ＋ 1 － _4BytesLen ' 变短的长度
                    m_UTF8Len ＝ m_UTF8Len － reduce ' 文本的长度需要改变了
                    Pos ＝ Pos ＋ _4BytesLen － 1
                    prejudge ＝ prejudge － reduce
                    
                .否则
                    
                    m_UTF8 [Pos] ＝ 0 ' 同样增加分界  这样这个指针就只包含 m_UTF8[Pos+1] 到 m_UTF8[semicolon-1] 这么多字节
                    temp ＝ strrchr (pUTF8 ＋ Pos, 38) ' &  倒找
                    m_UTF8 [Pos] ＝ 38 ' &
                    .如果 (temp ＝ 0)
                        Pos ＝ semicolon
                    .否则
                        Pos ＝ temp － pUTF8
                    .如果结束
                    
                    ' 交换变量 (semicolon_Byte, m_UTF8 [semicolon])  ' 分号还得换回去
                    m_UTF8 [semicolon] ＝ semicolon_Byte
                    semicolon_Byte ＝ 0
                .如果结束
                
            .否则
                Pos ＝ semicolon
            .如果结束
            
        .否则
            m_UTF8 [Pos] ＝ 0
            temp ＝ strrchr (pUTF8 ＋ Pos, 38) ' &  倒找
            m_UTF8 [Pos] ＝ 38 ' &
            
            .如果 (temp ＝ 0)
                Pos ＝ prejudge － 1
            .否则
                Pos ＝ temp － pUTF8
            .如果结束
            
        .如果结束
        
        
        ' 交换变量 (prejudge_Byte, m_UTF8 [prejudge])  ' 交换回去
        m_UTF8 [prejudge] ＝ prejudge_Byte
        prejudge_Byte ＝ 0
        
        
        
    .判断循环尾 ()
    
    

.子程序 取值_UTF8, 字节集, 公开, 返回反转义的结果，带尾部\0的 UTF8 文本
    返回 (取字节集左边 (m_UTF8, m_UTF8Len ＋ 1))

.子程序 取值_UNICODE, 字节集, 公开, 返回反转义的结果，带尾部\0\0的 UNICODE 文本
    返回 (编码_Utf8到Unicode (m_UTF8))

.子程序 取值_ANSI, 文本型, 公开, 返回反转义的结果，ANSI 文本 !!! 用到了 HTML Entity 的很多都是无法用 ANSI 表达的字符，很可能乱码
    返回 (编码_Utf8到Ansi (m_UTF8))
    

.子程序 UNICODE到UTF8_no_asm, 整数型, , 0x24B62  转  F0 A4 AD A2
    .参数 NUM, 整数型, , 8
    .参数 b1, 字节型, 参考, c
    .参数 b2, 字节型, 参考, 10
    .参数 b3, 字节型, 参考, 14
    .参数 b4, 字节型, 参考, 18

    .判断开始 (进制_十六到十 (“10000”) ≤ NUM 且 NUM ≤ 进制_十六到十 (“10FFFF”))
        b4 ＝ 位或 (进制_十六到十 (“80”), 位与 (进制_十六到十 (“3F”), NUM))
        b3 ＝ 位或 (进制_十六到十 (“80”), 位与 (进制_十六到十 (“3F”), 右移 (NUM, 6)))
        b2 ＝ 位或 (进制_十六到十 (“80”), 位与 (进制_十六到十 (“3F”), 右移 (NUM, 12)))
        b1 ＝ 位或 (进制_十六到十 (“F0”), 右移 (NUM, 18))
        返回 (4)
    .判断 (进制_十六到十 (“0800”) ≤ NUM 且 NUM ≤ 进制_十六到十 (“FFFF”))
        b3 ＝ 位或 (进制_十六到十 (“80”), 位与 (进制_十六到十 (“3F”), NUM))
        b2 ＝ 位或 (进制_十六到十 (“80”), 位与 (进制_十六到十 (“3F”), 右移 (NUM, 6)))
        b1 ＝ 位或 (进制_十六到十 (“E0”), 右移 (NUM, 12))
        返回 (3)
    .判断 (进制_十六到十 (“0080”) ≤ NUM 且 NUM ≤ 进制_十六到十 (“07FF”))
        b2 ＝ 位或 (进制_十六到十 (“80”), 位与 (进制_十六到十 (“3F”), NUM))
        b1 ＝ 位或 (进制_十六到十 (“C0”), 右移 (NUM, 6))
        返回 (2)
    .判断 (进制_十六到十 (“0000”) ≤ NUM 且 NUM ≤ 进制_十六到十 (“007F”))
        b1 ＝ NUM
        返回 (1)
    .默认
        返回 (0)
    .判断结束
    
    
    
    

.版本 2

.程序集 类_json, , 公开
.程序集变量 dataName, 文本型
.程序集变量 JsonStr, 对象

.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
    dataName ＝ “da”
    初始化 ()

.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
    JsonStr.清除 ()
    CoUninitialize ()

.子程序 初始化
    CoInitialize (#NULL)
    .如果真 (JsonStr.创建 (“MSScriptControl.ScriptControl”, ) ＝ 假)
        输出调试文本 (“创建指定类型的 COM 对象失败！”)
        返回 ()
    .如果真结束
    JsonStr.写属性 (“Language”, “JavaScript”)
    JsonStr.逻辑方法 (“AddCode”, #js2)
    JsonStr.逻辑方法 (“Eval”, “var ” ＋ dataName ＋ “ = {}, str_Code = String.fromCharCode(9216), str_reg = new RegExp(str_Code, 'g')”)

.子程序 解析, 逻辑型, 公开, 如果返回假，请检查Json文本是否为标准格式，如果确定，请检查 Windows 里 System 和 SysWOW64 是否需要权限
    .参数 JSON文本, 文本型, , 必须是标准的JSON格式！如果文本中有转义字符且需要保留，请传入前自行处理。
    .参数 为对象, 逻辑型, 可空
    .参数 错误原因, JsonError, 可空
    .局部变量 局_JSON文本, 文本型
    .局部变量 局_JsonError, 对象

    ' 暂时无法通过替换换行的方式来纠正JSON格式，原因是如果JSON是格式化的，替换了换行格式就会错误！
    .如果真 (JsonStr.是否为空 () ＝ 假)
        JsonStr.清除 ()
        初始化 ()
    .如果真结束
    .如果真 (JsonStr.是否为空 ())
        返回 (假)
    .如果真结束
    JsonStr.逻辑方法 (“Eval”, “var ” ＋ dataName ＋ “ = null”)
    局_JSON文本 ＝ JSON文本
    .如果 (为对象)
        JsonStr.逻辑方法 (“AddCode”, “var ” ＋ dataName ＋ “ = ” ＋ 局_JSON文本)
    .否则
        JsonStr.逻辑方法 (“AddCode”, “var ” ＋ dataName ＋ “ = eval(” ＋ 局_JSON文本 ＋ “)”)
    .如果结束
    .如果真 (是否为空 (错误原因) ＝ 假)
        局_JsonError ＝ JsonStr.对象型方法 (“Error”, )
        错误原因.Number ＝ 局_JsonError.读数值属性 (“Number”, )
        错误原因.Source ＝ 局_JsonError.读文本属性 (“Source”, )
        错误原因.Description ＝ 局_JsonError.读文本属性 (“Description”, )
        错误原因.HelpFile ＝ 局_JsonError.读文本属性 (“HelpFile”, )
        错误原因.HelpContext ＝ 局_JsonError.读数值属性 (“HelpContext”, )
        错误原因.Text ＝ 局_JsonError.读文本属性 (“Text”, )
        错误原因.Line ＝ 局_JsonError.读数值属性 (“Line”, )
        错误原因.Column ＝ 局_JsonError.读数值属性 (“Column”, )
    .如果真结束
    返回 (JsonStr.逻辑方法 (“Eval”, dataName ＋ “ != null”))

.子程序 清除, 逻辑型, 公开
    返回 (JsonStr.逻辑方法 (“Eval”, dataName ＋ “ = {}”))

.子程序 取数据文本, 文本型, 公开
    返回 (JsonStr.文本方法 (“Eval”, “JSON.stringify(” ＋ dataName ＋ “).replace(str_reg, '\\')”))

.子程序 置属性, 逻辑型, 公开, 非认真阅读模块实现原理请无视返回值
    .参数 属性名, 文本型, 可空, ['属性名是INT或运算符']
    .参数 值, 文本型, 可空
    .参数 为对象, 逻辑型, 可空, 属性解析为json对象或数组
    .局部变量 局_属性名, 文本型
    .局部变量 局_值, 文本型
    .局部变量 局_是否存在, 逻辑型
    .局部变量 局_类型, 文本型

    局_属性名 ＝ 属性名
    局_值 ＝ 值
    
    局_是否存在 ＝ Property_exists (局_属性名)
    .如果真 (为对象)
        .如果真 (局_值 ＝ “”)
            局_值 ＝ “{}”
        .如果真结束
        局_类型 ＝ JsonStr.文本方法 (“Eval”, “Object.prototype.toString.call(” ＋ 局_属性名 ＋ “)”)
        .如果真 (局_是否存在 且 局_类型 ＝ “[object Object]”)
            返回 (JsonStr.逻辑方法 (“Eval”, 局_属性名 ＋ “ = get__extend(” ＋ 局_属性名 ＋ “, ” ＋ 局_值 ＋ “)”))
        .如果真结束
        返回 (JsonStr.逻辑方法 (“Eval”, 局_属性名 ＋ “ = eval(” ＋ 值 ＋ “)”))
    .如果真结束
    
    局_值 ＝ 子文本替换 (局_值, “\”, “\\”, , , 真)
    局_值 ＝ 子文本替换 (局_值, “'”, “\'”, , , 真)
    局_值 ＝ 子文本替换 (局_值, #引号, “\” ＋ #引号, , , 真)
    局_值 ＝ 子文本替换 (局_值, 字符 (13), “\r”, , , 真)
    局_值 ＝ 子文本替换 (局_值, 字符 (10), “\n”, , , 真)
    返回 (JsonStr.逻辑方法 (“Eval”, 局_属性名 ＋ “ = '” ＋ 局_值 ＋ “'.replace(/\\/g, str_Code)”))

.子程序 置属性对象, 逻辑型, 公开, 属性解析为json对象或数组！非认真阅读模块实现原理请无视返回值
    .参数 属性名, 文本型, 可空, ['属性名是INT或运算符']
    .参数 值, 文本型, 可空
    .局部变量 局_属性名, 文本型

    局_属性名 ＝ 属性名
    
    Property_exists (局_属性名)
    返回 (JsonStr.逻辑方法 (“Eval”, 局_属性名 ＋ “ = eval(” ＋ 值 ＋ “)”))

.子程序 Property_exists, 逻辑型
    .参数 属性名, 文本型, 参考 可空, 请勿用变量

    .判断开始 (属性名 ≈ dataName 且 JsonStr.逻辑方法 (“Eval”, 属性名 ＋ “ != null”))
        返回 (真)
    .判断 (属性名 ＝ “”)
        属性名 ＝ dataName
    .判断 (属性名 ≈ “[”)
        属性名 ＝ dataName ＋ 属性名
    .默认
        属性名 ＝ dataName ＋ “.” ＋ 属性名
    .判断结束
    返回 (JsonStr.逻辑方法 (“Eval”, 属性名 ＋ “ != null”))

.子程序 属性是否存在, 逻辑型, 公开
    .参数 属性名, 文本型, 可空
    .局部变量 局_属性名, 文本型

    局_属性名 ＝ 属性名
    返回 (Property_exists (局_属性名))

.子程序 取类型, 整数型, 公开, -1、未知；0、未定义；1、布尔值；2、数值；4、对象；5、数组；6、字符串
    .参数 属性名, 文本型, 可空, ['属性名是INT或运算符']
    .局部变量 局_属性名, 文本型
    .局部变量 局_类型, 文本型

    局_属性名 ＝ 属性名
    
    Property_exists (局_属性名)
    .如果真 (JsonStr.逻辑方法 (“Eval”, 局_属性名 ＋ “ == null”))
        返回 (0) ' 未定义
    .如果真结束
    局_类型 ＝ JsonStr.文本方法 (“Eval”, “Object.prototype.toString.call(” ＋ 局_属性名 ＋ “)”)
    .判断开始 (局_类型 ＝ “[object String]”)
        返回 (6) ' 字符串
    .判断 (局_类型 ＝ “[object Array]”)
        返回 (5) ' 数组
    .判断 (局_类型 ＝ “[object Object]”)
        返回 (4) ' 对象
    .判断 (局_类型 ＝ “[object Number]”)
        返回 (2) ' 数值
    .判断 (局_类型 ＝ “[object Boolean]”)
        返回 (1) ' 布尔值
    .默认
        返回 (-1) ' 未知
    .判断结束
    

.子程序 取通用属性, 文本型, 公开
    .参数 属性名, 文本型, 可空, ['属性名是INT或运算符']
    .参数 为对象, 逻辑型, 可空, 属性解析为json对象或数组
    .局部变量 局_属性名, 文本型

    局_属性名 ＝ 属性名
    
    Property_exists (局_属性名)
    .如果真 (为对象)
        返回 (JsonStr.文本方法 (“Eval”, “JSON.stringify(” ＋ 局_属性名 ＋ “).replace(str_reg, '\\')”))
    .如果真结束
    返回 (JsonStr.文本方法 (“Eval”, 局_属性名 ＋ “.toString().replace(str_reg, '\\')”))

.子程序 取所有属性名, 整数型, 公开, 属性名指向JSON类型必须为对象
    .参数 属性名数组, 文本型, 参考 可空 数组
    .参数 属性名, 文本型, 可空, ['属性名是INT或运算符']
    .局部变量 局_属性名, 文本型
    .局部变量 局_值, 文本型

    局_属性名 ＝ 属性名
    
    Property_exists (局_属性名)
    局_值 ＝ JsonStr.文本方法 (“Eval”, “get__name_All(” ＋ 局_属性名 ＋ “)”)
    属性名数组 ＝ 分割文本 (局_值, #换行符, )
    返回 (取数组成员数 (属性名数组))

.子程序 成员数, 整数型, 公开, 属性名指向JSON类型必须为数组
    .参数 属性名, 文本型, 可空, ['属性名是INT或运算符']
    .局部变量 局_属性名, 文本型

    局_属性名 ＝ 属性名
    
    Property_exists (局_属性名)
    返回 (到整数 (JsonStr.数值方法 (“Eval”, “get__count(” ＋ 局_属性名 ＋ “)”)))

.子程序 取属性, 类_json, 公开
    .参数 属性名, 文本型, 可空, ['属性名是INT或运算符']
    .局部变量 局_属性名, 文本型
    .局部变量 局_json, 类_json

    局_属性名 ＝ 属性名
    
    Property_exists (局_属性名)
    局_json.解析 (JsonStr.文本方法 (“Eval”, “JSON.stringify(” ＋ 局_属性名 ＋ “).replace(str_reg, '\\')”))
    返回 (局_json)

.子程序 加成员, 逻辑型, 公开
    .参数 值, 文本型, 可空
    .参数 属性名, 文本型, 可空, ['属性名是INT或运算符']
    .参数 为对象, 逻辑型, 可空, 属性解析为json对象或数组
    .参数 开头添加, 逻辑型, 可空, 留空默认为末尾添加
    .局部变量 局_属性名, 文本型
    .局部变量 局_值, 文本型

    局_属性名 ＝ 属性名
    局_值 ＝ 值
    
    Property_exists (局_属性名)
    .如果真 (为对象 ＝ 假)
        局_值 ＝ “'” ＋ 局_值 ＋ “'”
    .如果真结束
    
    .如果真 (开头添加)
        返回 (JsonStr.逻辑方法 (“Eval”, “if (Object.prototype.toString.call(” ＋ 局_属性名 ＋ “) != '[object Array]') { ” ＋ 局_属性名 ＋ “ = new Array() } ” ＋ 局_属性名 ＋ “.unshift(” ＋ 局_值 ＋ “)”))
    .如果真结束
    
    返回 (JsonStr.逻辑方法 (“Eval”, “if (Object.prototype.toString.call(” ＋ 局_属性名 ＋ “) != '[object Array]') { ” ＋ 局_属性名 ＋ “ = new Array() } ” ＋ 局_属性名 ＋ “.push(” ＋ 局_值 ＋ “)”))

.子程序 取成员, 类_json, 公开
    .参数 成员索引, 整数型, 可空, 成员索引从0开始
    .参数 属性名, 文本型, 可空, ['属性名是INT或运算符']
    .局部变量 局_属性名, 文本型
    .局部变量 局_json, 类_json

    局_属性名 ＝ 属性名
    
    Property_exists (局_属性名)
    局_json.解析 (JsonStr.文本方法 (“Eval”, “JSON.stringify(” ＋ 局_属性名 ＋ “[” ＋ 到文本 (成员索引) ＋ “]).replace(str_reg, '\\')”))
    返回 (局_json)

.子程序 取成员文本, 文本型, 公开
    .参数 成员索引, 整数型, 可空, 成员索引从0开始
    .参数 属性名, 文本型, 可空, ['属性名是INT或运算符']
    .参数 为对象, 逻辑型, 可空, 属性解析为json对象或数组
    .局部变量 局_属性名, 文本型

    局_属性名 ＝ 属性名
    
    Property_exists (局_属性名)
    .如果真 (为对象)
        返回 (JsonStr.文本方法 (“Eval”, “JSON.stringify(” ＋ 局_属性名 ＋ “[” ＋ 到文本 (成员索引) ＋ “]).replace(str_reg, '\\')”))
    .如果真结束
    返回 (JsonStr.文本方法 (“Eval”, 局_属性名 ＋ “[” ＋ 到文本 (成员索引) ＋ “].replace(str_reg, '\\')”))

.子程序 置成员, 逻辑型, 公开
    .参数 成员索引, 整数型, 可空, 成员索引从0开始
    .参数 属性名, 文本型, 可空, ['属性名是INT或运算符']
    .参数 值, 文本型, 可空
    .参数 为对象, 逻辑型, 可空, 属性解析为json对象或数组
    .局部变量 局_属性名, 文本型
    .局部变量 局_值, 文本型

    局_属性名 ＝ 属性名
    局_值 ＝ 值
    
    Property_exists (局_属性名)
    .如果真 (为对象 ＝ 假)
        局_值 ＝ “'” ＋ 局_值 ＋ “'”
    .如果真结束
    返回 (JsonStr.逻辑方法 (“Eval”, 局_属性名 ＋ “[” ＋ 到文本 (成员索引) ＋ “] = ” ＋ 局_值))

.子程序 删成员, 逻辑型, 公开
    .参数 成员索引, 整数型, 可空, 成员索引从0开始
    .参数 属性名, 文本型, 可空, ['属性名是INT或运算符']
    .局部变量 局_属性名, 文本型

    局_属性名 ＝ 属性名
    
    Property_exists (局_属性名)
    返回 (JsonStr.逻辑方法 (“Eval”, 局_属性名 ＋ “.splice(” ＋ 到文本 (成员索引) ＋ “, 1)”))

.子程序 删属性, 逻辑型, 公开
    .参数 属性名, 文本型, 可空, ['属性名是INT或运算符']
    .局部变量 局_属性名, 文本型

    局_属性名 ＝ 属性名
    
    Property_exists (局_属性名)
    返回 (JsonStr.逻辑方法 (“Eval”, “delete ” ＋ 局_属性名))

.子程序 置属性数值, 逻辑型, 公开
    .参数 属性名, 文本型, 可空, ['属性名是INT或运算符']
    .参数 值, 双精度小数型, 可空
    .局部变量 局_属性名, 文本型
    .局部变量 局_值, 文本型

    局_属性名 ＝ 属性名
    局_值 ＝ 到文本 (值)
    
    Property_exists (局_属性名)
    返回 (JsonStr.逻辑方法 (“Eval”, 局_属性名 ＋ “ = ” ＋ 局_值))

.子程序 取属性数值, 双精度小数型, 公开
    .参数 属性名, 文本型, 可空, ['属性名是INT或运算符']
    .局部变量 局_属性名, 文本型

    局_属性名 ＝ 属性名
    
    Property_exists (局_属性名)
    返回 (JsonStr.数值方法 (“Eval”, 局_属性名))

.子程序 取属性对象, 文本型, 公开
    .参数 属性名, 文本型, 可空, ['属性名是INT或运算符']
    .局部变量 局_属性名, 文本型

    局_属性名 ＝ 属性名
    
    Property_exists (局_属性名)
    返回 (JsonStr.文本方法 (“Eval”, “JSON.stringify(” ＋ 局_属性名 ＋ “).replace(str_reg, '\\')”))

.子程序 取回对象, 对象, 公开
    返回 (JsonStr)

.子程序 取所有属性值, 整数型, 公开, 取指定路径下所有属性的值
    .参数 属性值数组, 文本型, 参考 可空 数组
    .参数 属性名, 文本型, 可空, 属性名指向JSON类型必须为对象
    .参数 向下递归, 逻辑型, 可空
    .局部变量 局_属性名, 文本型
    .局部变量 局_值, 文本型
    .局部变量 len, 整数型

    局_属性名 ＝ 属性名
    
    Property_exists (局_属性名)
    JsonStr.方法 (“Eval”, “var str_all = new Array()”)
    JsonStr.方法 (“Eval”, “get__nodeValue(” ＋ 局_属性名 ＋ “, ” ＋ 选择 (向下递归, “true”, “false”) ＋ “)”)
    局_值 ＝ JsonStr.文本方法 (“Eval”, “str_all.join('[2020年7月20日20时0分0秒]')”)
    属性值数组 ＝ 分割文本 (局_值, “[2020年7月20日20时0分0秒]”, )
    len ＝ 取数组成员数 (属性值数组)
    返回 (len)

.版本 2

.程序集 类_POST数据类, , 公开
.程序集变量 _keys, 文本型, , "0"
.程序集变量 _values, 文本型, , "0"

.子程序 添加, , 公开, 添加指定键名与键值
    .参数 key, 文本型
    .参数 value, 文本型, , 当前值会进行utf-8的编码
    .参数 转码, 逻辑型, 可空, 可空，是否对[值]进行进行utf-8编码，默认为 假=不转码，真=转码

    .如果 (转码)
        加入成员 (_keys, 编码_gb2312到utf8 (key))
        加入成员 (_values, 编码_gb2312到utf8 (value))
    .否则
        加入成员 (_keys, key)
        加入成员 (_values, value)
    .如果结束
    

.子程序 添加_批量, , 公开, 批量加入[带转码]
    .参数 文本, 文本型, , 如：a=123&b=456
    .参数 转码, 逻辑型, 可空, 可空，是否对[值]进行进行utf-8编码，默认为 假=不转码，真=转码
    .局部变量 Arr, 文本型, , "0"
    .局部变量 i, 整数型

    Arr ＝ 分割文本 (文本, “&”, )
    .计次循环首 (取数组成员数 (Arr), i)
        添加 (文本_取左边 (Arr [i], “=”, , ), 文本_取右边 (Arr [i], “=”, , ), 转码)
    .计次循环尾 ()

.子程序 取值, 文本型, 公开, 取指定键名的值
    .参数 key, 文本型
    .局部变量 i, 整数型

    .计次循环首 (取数组成员数 (_keys), i)
        .如果真 (_keys [i] ＝ key)
            返回 (_values [i])
        .如果真结束
        
    .计次循环尾 ()
    返回 (“”)

.子程序 置值, , 公开, 置指定键名的键值
    .参数 key, 文本型
    .参数 value, 文本型
    .局部变量 i, 整数型

    .计次循环首 (取数组成员数 (_keys), i)
        .如果真 (_keys [i] ＝ key)
            _values [i] ＝ value
            返回 ()
        .如果真结束
        
    .计次循环尾 ()
    添加 (key, value)

.子程序 获取Post数据, 文本型, 公开, 将添加的数据以数据包格式返回  键名=键值&键名=键值
    .参数 是否URL编码, 逻辑型, 可空, 默认为假=不编码，真=URL编码
    .局部变量 i, 整数型
    .局部变量 value, 文本型
    .局部变量 str, 文本型

    .计次循环首 (取数组成员数 (_keys), i)
        .如果 (是否URL编码)
            str ＝ str ＋ 编码_URL编码 (_keys [i], 真, ) ＋ “=” ＋ 编码_URL编码 (_values [i], 真, ) ＋ “&”
        .否则
            str ＝ str ＋ _keys [i] ＋ “=” ＋ _values [i] ＋ “&”
        .如果结束
        
    .计次循环尾 ()
    str ＝ 取文本左边 (str, 取文本长度 (str) － 1)
    返回 (str)

.子程序 获取协议头数据, 文本型, 公开, 将添加的数据以协议头格式返回  键名:键值
    .参数 是否URL编码, 逻辑型, 可空, 默认为假=不编码，真=URL编码
    .局部变量 i, 整数型
    .局部变量 value, 文本型
    .局部变量 str, 文本型

    .计次循环首 (取数组成员数 (_keys), i)
        .如果 (是否URL编码)
            str ＝ str ＋ _keys [i] ＋ “: ” ＋ 编码_URL编码 (_values [i], 真, ) ＋ 字符 (13) ＋ 字符 (10)
        .否则
            str ＝ str ＋ _keys [i] ＋ “: ” ＋ _values [i] ＋ 字符 (13) ＋ 字符 (10)
        .如果结束
        
    .计次循环尾 ()
    str ＝ 取文本左边 (str, 取文本长度 (str) － 2)
    返回 (str)

.子程序 获取Key数组, , 公开
    .参数 arr, 文本型, 参考 数组

    arr ＝ _keys

.子程序 获取Value数组, , 公开
    .参数 arr, 文本型, 参考 数组

    arr ＝ _values

.子程序 清空, , 公开
    清除数组 (_keys)
    清除数组 (_values)
    

.子程序 删除, , 公开, 删除键值队  删除一个
    .参数 key, 文本型
    .局部变量 局_键名, 整数型

    .计次循环首 (取数组成员数 (_keys), 局_键名)
        .如果真 (_keys [局_键名] ＝ key)
            删除成员 (_keys, 局_键名, 1)
            删除成员 (_values, 局_键名, 1)
            返回 ()
        .如果真结束
        
    .计次循环尾 ()

.子程序 获取JSON文本, 文本型, 公开, 将添加的数据以JSON格式返回    ｛键名:键值｝
    .局部变量 i, 整数型
    .局部变量 Str, 文本型

    Str ＝ “{”
    .计次循环首 (取数组成员数 (_keys), i)
        Str ＝ Str ＋ #引号 ＋ _keys [i] ＋ #引号 ＋ “:” ＋ #引号 ＋ 处理元字符 (_values [i]) ＋ #引号 ＋ “,”
    .计次循环尾 ()
    Str ＝ rtrim (Str, “,”) ＋ “}”
    返回 (Str)

.子程序 处理元字符, 文本型
    .参数 文本, 文本型
    .局部变量 Str, 文本型

    Str ＝ 文本_替换 (文本, , , , #引号, “\” ＋ #引号, , , , , , , , )
    返回 (Str)
    

.子程序 rtrim, 文本型, , 函数从字符串的末端开始删除空白字符或其他预定义字符
    .参数 str, 文本型, , 规定要转换的字符串
    .参数 charlist, 文本型, , 可空，规定从字符串中删除哪些字符

    .如果真 (取文本右边 (str, 取文本长度 (charlist)) ＝ charlist)
        str ＝ 取文本左边 (str, 取文本长度 (str) － 取文本长度 (charlist))
    .如果真结束
    
    .如果真 (取文本左边 (str, 取文本长度 (charlist)) ＝ charlist)
        str ＝ 取文本右边 (str, 取文本长度 (str) － 取文本长度 (charlist))
    .如果真结束
    返回 (str)

.版本 2

.程序集 类_POST数据类_字节集, , 公开
.程序集变量 _keys, 文本型, , "0"
.程序集变量 _values, 字节集, , "0"
.程序集变量 _filename, 文本型, , "0"
.程序集变量 _types, 文本型, , "0"

.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
    

.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
    

.子程序 清空, , 公开
    清除数组 (_keys)
    清除数组 (_values)
    清除数组 (_types)
    清除数组 (_filename)

.子程序 添加, , 公开
    .参数 key, 文本型
    .参数 value, 字节集
    .参数 types, 文本型, 可空, 如： Content-Type: audio/mp3，请填写【audio/mp3】
    .参数 filename, 文本型, 可空, 如： Content-Type: audio/mp3，请填写【audio/mp3】

    加入成员 (_keys, key)
    加入成员 (_values, value)
    加入成员 (_types, types)
    加入成员 (_filename, filename)

.子程序 取值, 字节集, 公开
    .参数 key, 文本型
    .局部变量 i, 整数型

    .计次循环首 (取数组成员数 (_keys), i)
        .如果真 (_keys [i] ＝ key)
            返回 (_values [i])
        .如果真结束
        
    .计次循环尾 ()
    返回 ({ })

.子程序 置值, , 公开
    .参数 key, 文本型
    .参数 value, 字节集
    .局部变量 i, 整数型

    .计次循环首 (取数组成员数 (_keys), i)
        .如果真 (_keys [i] ＝ key)
            _values [i] ＝ value
            返回 ()
        .如果真结束
        
    .计次循环尾 ()
    添加 (key, value)

.子程序 ______获取Post数据, 字节集
    .参数 boundary, 文本型
    .参数 分割符数量, 整数型, 可空, 默认为2，如：--WebKitFormBoundaryPPRO2xsdBWf1T1h4
    .局部变量 i, 整数型
    .局部变量 head, 文本型
    .局部变量 t, 文本型
    .局部变量 bin, 字节集
    .局部变量 keys, 文本型, , "0"
    .局部变量 values, 文本型, , "0"

    .如果真 (分割符数量 ＝ 0)
        分割符数量 ＝ 2
    .如果真结束
    head ＝ 取重复文本 (分割符数量, “-”) ＋ boundary ＋ #换行符
    .计次循环首 (取数组成员数 (_keys), i)
        t ＝ head ＋ “Content-Disposition: form-data; name=” ＋ #引号 ＋ _keys [i] ＋ #引号 ＋ “; filename=” ＋ #引号 ＋ _keys [i] ＋ #引号 ＋ #换行符
        .如果真 (_types [i] ≠ “”)
            t ＝ t ＋ “Content-Type: ” ＋ _types [i] ＋ #换行符
        .如果真结束
        t ＝ t ＋ #换行符
        bin ＝ bin ＋ 到字节集 (t) ＋ _values [i] ＋ { 13, 10 }
    .计次循环尾 ()
    置入代码 ({ 255, 117, 236, 255, 117, 232, 139, 69, 8, 139, 0, 139, 88, 4, 137, 93, 236, 139, 88, 8, 137, 93, 232 })
    .计次循环首 (取数组成员数 (keys), i)
        t ＝ head ＋ “Content-Disposition: form-data; name=” ＋ #引号 ＋ keys [i] ＋ #引号 ＋ #换行符 ＋ #换行符
        t ＝ t ＋ values [i] ＋ #换行符
        bin ＝ bin ＋ 到字节集 (t)
    .计次循环尾 ()
    置入代码 ({ 143, 69, 236, 143, 69, 232 })
    bin ＝ bin ＋ 到字节集 (取重复文本 (分割符数量, “-”) ＋ boundary ＋ “--” ＋ #换行符)
    返回 (bin)

.子程序 获取Post数据, 字节集, 公开
    .参数 boundary, 文本型
    .参数 分割符数量, 整数型, 可空, 默认为2，如：--WebKitFormBoundaryPPRO2xsdBWf1T1h4
    .局部变量 i, 整数型
    .局部变量 head, 文本型
    .局部变量 t, 文本型
    .局部变量 bin, 字节集
    .局部变量 keys, 文本型, , "0"
    .局部变量 values, 文本型, , "0"

    ' 修复代码来自;https://bbs.125.la/forum.php?mod=viewthread&tid=14285660
    .如果真 (分割符数量 ＝ 0)
        分割符数量 ＝ 2
    .如果真结束
    head ＝ 取重复文本 (分割符数量, “-”) ＋ boundary ＋ #换行符
    .计次循环首 (取数组成员数 (_keys), i)
        t ＝ head ＋ “Content-Disposition: form-data; name=” ＋ #引号 ＋ _keys [i] ＋ #引号
        .如果 (_filename [i] ≠ “”)
            t ＝ t ＋ “; filename=” ＋ #引号 ＋ _filename [i] ＋ #引号 ＋ #换行符
        .否则
            t ＝ t ＋ #换行符
        .如果结束
        
        .如果真 (_types [i] ≠ “”)
            t ＝ t ＋ “Content-Type: ” ＋ _types [i] ＋ #换行符
        .如果真结束
        t ＝ t ＋ #换行符
        bin ＝ bin ＋ 到字节集 (t) ＋ _values [i] ＋ { 13, 10 }
    .计次循环尾 ()
    bin ＝ bin ＋ 到字节集 (取重复文本 (分割符数量, “-”) ＋ boundary ＋ “--” ＋ #换行符)
    返回 (bin)

.子程序 获取Key数组, , 公开
    .参数 arr, 文本型, 参考 数组
    .局部变量 keys, 文本型, , "0"
    .局部变量 len, 整数型
    .局部变量 i, 整数型

    置入代码 ({ 255, 117, 252, 139, 69, 8, 139, 0, 139, 64, 4, 137, 69, 252 })
    arr ＝ _keys
    重定义数组 (arr, 真, 取数组成员数 (_keys) ＋ 取数组成员数 (keys))
    .计次循环首 (取数组成员数 (keys), i)
        arr [取数组成员数 (_keys) ＋ i] ＝ keys [i]
    .计次循环尾 ()
    置入代码 ({ 143, 69, 252 })

.子程序 获取Value数组, , 公开
    .参数 arr, 字节集, 参考 数组
    .局部变量 values, 文本型, , "0"
    .局部变量 i, 整数型

    置入代码 ({ 255, 117, 252, 139, 69, 8, 139, 0, 139, 64, 8, 137, 69, 252 })
    arr ＝ _values
    重定义数组 (arr, 真, 取数组成员数 (_values) ＋ 取数组成员数 (values))
    .计次循环首 (取数组成员数 (values), i)
        arr [取数组成员数 (_values) ＋ i] ＝ 到字节集 (values [i])
    .计次循环尾 ()
    置入代码 ({ 143, 69, 252 })

.版本 2

.程序集 类_RegExp, , 公开, 线程内请先调用 _COM初始化(0)
.程序集变量 m_RegExp, 对象
.程序集变量 m_Matches, 对象
.程序集变量 m_Match, 对象
.程序集变量 m_SubMatches, 对象
.程序集变量 m_Search, 变体型
.程序集变量 m_Null, 逻辑型

.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
    m_Null ＝ 真

.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
    m_RegExp.清除 ()
    m_Matches.清除 ()
    m_Search.清除 ()
    CoUninitialize ()

.子程序 继承, , 公开, 内部使用
    .参数 RegExpClass, 类_RegExp, 参考 可空
    .参数 RegExp, 变体型, 可空
    .参数 Matches, 变体型, 可空
    .参数 Match, 变体型, 可空
    .参数 SubMatches, 变体型, 可空
    .参数 Search, 变体型, 可空
    .参数 Null, 逻辑型, 可空
    .局部变量 l_RegExp, 变体型
    .局部变量 l_Matches, 变体型
    .局部变量 l_Match, 变体型
    .局部变量 l_SubMatches, 变体型
    .局部变量 l_Search, 变体型
    .局部变量 l_Null, 逻辑型

    .如果 (是否为空 (RegExpClass) ＝ 假)
        l_RegExp.赋值 (m_RegExp, )
        l_Matches.赋值 (m_Matches, )
        l_Match.赋值 (m_Match, )
        l_SubMatches.赋值 (m_SubMatches, )
        l_Search ＝ m_Search
        l_Null ＝ m_Null
        RegExpClass.继承 (, l_RegExp, l_Matches, l_Match, l_SubMatches, l_Search, l_Null)
    .否则
        m_RegExp ＝ RegExp.取对象 ()
        m_Matches ＝ Matches.取对象 ()
        m_Match ＝ Match.取对象 ()
        m_SubMatches ＝ SubMatches.取对象 ()
        m_Search ＝ Search
        m_Null ＝ Null
    .如果结束
    

.子程序 创建, 逻辑型, 公开, 根据指定的正则表达式文本创建一个正则表达式对象。本对象中的原有内容将被释放
    .参数 正则表达式文本, 文本型
    .参数 被搜索的文本, 文本型
    .参数 是否区分大小写, 逻辑型, 可空
    .参数 是否匹配多行, 逻辑型, 可空
    .参数 是否全局匹配, 逻辑型, 可空
    .局部变量 局_正则文本, 文本型

    是否区分大小写 ＝ 取反 (选择 (是否为空 (是否区分大小写), 假, 是否区分大小写))
    是否匹配多行 ＝ 选择 (是否为空 (是否匹配多行), 真, 是否匹配多行)
    是否全局匹配 ＝ 选择 (是否为空 (是否全局匹配), 真, 是否全局匹配)
    m_RegExp.清除 ()
    m_Matches.清除 ()
    CoInitialize (0)
    m_RegExp.创建 (“VBScript.RegExp”, )
    m_RegExp.写属性 (“IgnoreCase”, 是否区分大小写) ' 匹配时不区分大小写
    m_RegExp.写属性 (“Multiline”, 是否匹配多行) ' 是否匹配多行
    m_RegExp.写属性 (“Singleline”, 真) ' Singleline(单行模式)
    m_RegExp.写属性 (“Global”, 是否全局匹配) ' 是否全局匹配
    局_正则文本 ＝ 正则表达式文本
    m_RegExp.写属性 (“Pattern”, 局_正则文本)
    ' -----------------
    m_Search.赋值 (被搜索的文本, )
    m_Matches ＝ m_RegExp.对象型方法 (“Execute”, m_Search)
    m_Null ＝ m_Matches.是否为空 ()
    返回 (m_Null ＝ 假)

.子程序 创建类, 类_RegExp, 公开, 根据指定的正则表达式文本创建一个正则表达式对象。本对象中的原有内容将被释放
    .参数 正则表达式文本, 文本型
    .参数 被搜索的文本, 文本型
    .参数 是否区分大小写, 逻辑型, 可空
    .参数 是否匹配多行, 逻辑型, 可空
    .参数 是否全局匹配, 逻辑型, 可空
    .局部变量 局_RegExp, 类_RegExp

    是否区分大小写 ＝ 取反 (选择 (是否为空 (是否区分大小写), 假, 是否区分大小写))
    是否匹配多行 ＝ 选择 (是否为空 (是否匹配多行), 真, 是否匹配多行)
    是否全局匹配 ＝ 选择 (是否为空 (是否全局匹配), 真, 是否全局匹配)
    创建 (正则表达式文本, 被搜索的文本, 是否区分大小写, 是否匹配多行, 是否全局匹配)
    继承 (局_RegExp)
    返回 (局_RegExp)
    

.子程序 是否空, 逻辑型, 公开
    返回 (m_Null)
    

.子程序 取匹配, 文本型, 公开, 取出该正则匹配到的文本
    .参数 匹配索引, 整数型, 可空, 索引值从1开始,留空默认1
    .局部变量 Match, 对象
    .局部变量 Value, 文本型
    .局部变量 Item, 整数型

    Item ＝ 选择 (是否为空 (匹配索引), 1, 匹配索引 － 1)
    Match ＝ m_Matches.读对象型属性 (“Item”, Item)
    Value ＝ Match.读属性 (“Value”, ).取文本 ()
    m_Match ＝ Match
    返回 (Value)

.子程序 创建自匹配, 类_RegExp, 公开, 根据指定匹配文本创建一个正则表达式对象。本对象中的原有内容将被释放
    .参数 正则表达式文本, 文本型
    .参数 匹配索引, 整数型, , 索引值从1开始,留空默认1
    .参数 是否区分大小写, 逻辑型, 可空
    .参数 是否匹配多行, 逻辑型, 可空
    .参数 是否全局匹配, 逻辑型, 可空

    是否区分大小写 ＝ 取反 (选择 (是否为空 (是否区分大小写), 假, 是否区分大小写))
    是否匹配多行 ＝ 选择 (是否为空 (是否匹配多行), 真, 是否匹配多行)
    是否全局匹配 ＝ 选择 (是否为空 (是否全局匹配), 真, 是否全局匹配)
    返回 (创建类 (正则表达式文本, 取匹配 (匹配索引), 是否区分大小写, 是否匹配多行, 是否全局匹配))
    

.子程序 替换, 文本型, 公开, 替换在正则表达式查找中找到的文本
    .参数 用作替换的文本, 文本型, 可空, 用作替换的文本
    .局部变量 局_用作替换的文本, 变体型

    局_用作替换的文本.赋值 (用作替换的文本, )
    返回 (m_RegExp.文本方法 (“Replace”, m_Search, 局_用作替换的文本))
    

.子程序 创建自替换, 类_RegExp, 公开, 根据指定匹配文本创建一个正则表达式对象。本对象中的原有内容将被释放
    .参数 正则表达式文本, 文本型
    .参数 用作替换的文本, 文本型, , 索引值从1开始,留空默认1
    .参数 是否区分大小写, 逻辑型, 可空
    .参数 是否匹配多行, 逻辑型, 可空
    .参数 是否全局匹配, 逻辑型, 可空

    是否区分大小写 ＝ 取反 (选择 (是否为空 (是否区分大小写), 假, 是否区分大小写))
    是否匹配多行 ＝ 选择 (是否为空 (是否匹配多行), 真, 是否匹配多行)
    是否全局匹配 ＝ 选择 (是否为空 (是否全局匹配), 真, 是否全局匹配)
    返回 (创建类 (正则表达式文本, 替换 (用作替换的文本), 是否区分大小写, 是否匹配多行, 是否全局匹配))
    

.子程序 取子匹配, 文本型, 公开, 取出该正则的子表达式匹配到的文本
    .参数 匹配索引, 整数型, 可空, 索引值从1开始
    .参数 子表达式索引, 整数型, 可空, 欲取其值的子表达式,该参数对应与正则表达式中的一个子表达式以圆括号"( )"为标记,索引从1开始
    .局部变量 Match, 对象
    .局部变量 SubMatches, 对象
    .局部变量 value, 文本型
    .局部变量 Item, 整数型

    Item ＝ 选择 (是否为空 (匹配索引), 1, 匹配索引 － 1)
    Match ＝ m_Matches.读对象型属性 (“Item”, Item)
    SubMatches ＝ Match.读对象型属性 (“SubMatches”, )
    Item ＝ 选择 (是否为空 (子表达式索引), 1, 子表达式索引 － 1)
    value ＝ SubMatches.读属性 (“Item”, Item).取文本 ()
    m_Match ＝ Match
    m_SubMatches ＝ SubMatches
    返回 (value)

.子程序 创建自子匹配, 类_RegExp, 公开, 根据指定匹配文本创建一个正则表达式对象。本对象中的原有内容将被释放
    .参数 正则表达式文本, 文本型
    .参数 匹配索引, 整数型, , 索引值从1开始
    .参数 子表达式索引, 整数型, , 欲取其值的子表达式,该参数对应与正则表达式中的一个子表达式以圆括号"( )"为标记,索引从1开始
    .参数 是否区分大小写, 逻辑型, 可空
    .参数 是否匹配多行, 逻辑型, 可空
    .参数 是否全局匹配, 逻辑型, 可空

    是否区分大小写 ＝ 取反 (选择 (是否为空 (是否区分大小写), 假, 是否区分大小写))
    是否匹配多行 ＝ 选择 (是否为空 (是否匹配多行), 真, 是否匹配多行)
    是否全局匹配 ＝ 选择 (是否为空 (是否全局匹配), 真, 是否全局匹配)
    返回 (创建类 (正则表达式文本, 取子匹配 (匹配索引, 子表达式索引), 是否区分大小写, 是否匹配多行, 是否全局匹配))
    
    

.子程序 取匹配数, 整数型, 公开, 取出该正则匹配到的数量
    返回 (m_Matches.读数值属性 (“Count”, ))

.子程序 取子匹配数, 整数型, 公开, 取出该正则的子表达式匹配到的数量
    返回 (m_Matches.读对象型属性 (“Item”, 0).读对象型属性 (“SubMatches”, ).读数值属性 (“Count”, ))

.子程序 取位置, 整数型, 公开, 取匹配起始位置
    .参数 匹配索引, 整数型, 可空
    .局部变量 l_FirstIndex, 整数型
    .局部变量 l_Bytes, 字节集
    .局部变量 l_Len, 整数型
    .局部变量 l_Width, 整数型
    .局部变量 l_Point, 整数型
    .局部变量 l_Item, 整数型
    .局部变量 n, 整数型
    .局部变量 i, 整数型

    l_Item ＝ 选择 (是否为空 (匹配索引), 1, 匹配索引 － 1)
    取匹配 (l_Item)
    l_FirstIndex ＝ m_Match.读数值属性 (“FirstIndex”, )
    .如果真 (l_FirstIndex ＞ 0)
        l_Bytes ＝ 到字节集 (m_Search.取文本 ())
        l_Len ＝ 取字节集长度 (l_Bytes)
        n ＝ 1
        i ＝ 0
        .判断循环首 (n ＜ l_Len)
            .判断开始 (n ＋ 1 ＞ l_Len)
                l_Width ＝ 1
            .判断 (l_Bytes [n] ＞ 128)
                l_Width ＝ 2
            .默认
                l_Width ＝ 1
            .判断结束
            .如果真 (i ≥ l_FirstIndex)
                跳出循环 ()
            .如果真结束
            n ＝ n ＋ l_Width
            i ＝ i ＋ 1
        .判断循环尾 ()
    .如果真结束
    返回 (n)

.版本 2

.程序集 类_XMLHTTP, , 公开
.程序集变量 对象, 对象

.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
    CoInitialize (0)
    创建 ()

.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
    CoUninitialize ()

.子程序 创建, 逻辑型, , 把这个方法放到类“_初始化”命令里就不用自己创建了
    .如果真 (对象.创建 (“MSXML2.XMLHTTP”, ) ＝ 假)
        返回 (假)
    .如果真结束
    返回 (真)

.子程序 打开, 逻辑型, 公开, 打开HTTP连接
    .参数 模式, 文本型, , 模式为POST GET PUT PROPFIND之一
    .参数 地址, 文本型, , 地址
    .参数 异步方式, 逻辑型, 可空, 是否为异步方式
    .参数 用户名, 文本型, 可空, 用户名
    .参数 密码, 文本型, 可空, 密码

    对象.方法 (“open”, 模式, 地址, 异步方式, 用户名, 密码)
    返回 (真)

.子程序 指定请求头数据, , 公开, 单独指定请求的http头
    .参数 头名称, 文本型, , 头名称
    .参数 值, 文本型, , 值

    对象.方法 (“setRequestHeader”, 头名称, 值)

.子程序 取响应头数据, 文本型, 公开, 从响应信息中获取指定的http头
    .参数 头标志, 文本型, , 头标志

    返回 (对象.文本方法 (“getResponseHeader”, 头标志))

.子程序 取所有头数据, 文本型, 公开, 获取响应的所有http头
    返回 (对象.文本方法 (“getAllResponseHeaders”, ))

.子程序 发送请求, , 公开, 发送请求
    .参数 发送数据, 文本型, 可空, 发送的数据

    对象.方法 (“send”, 发送数据)

.子程序 取消当前请求, , 公开, 取消当前请求
    对象.方法 (“abort”, )

.子程序 取状态码, 整数型, 公开, 返回当前请求的http状态码
    返回 (对象.读数值属性 (“status”, ))

.子程序 取状态文本, 文本型, 公开, 返回当前请求的状态文本
    返回 (对象.读文本属性 (“statusText”, ))

.子程序 取responseXML, 对象, 公开, 将响应信息格式化为 Xml 文档对象并返回
    返回 (对象.读对象型属性 (“responseXML”, ))

.子程序 取responseText, 文本型, 公开, 将响应信息作为字符串返回
    返回 (对象.读文本属性 (“responseText”, ))

.子程序 取响应数据, 变体型, 公开, 返回服务器响应数据
    返回 (对象.读属性 (“responseBody”, ))

.子程序 取responseStream, 变体型, 公开, 以Ado Stream对象的形式返回响应信息
    返回 (对象.读属性 (“responseStream”, ))

.子程序 取readyState, 整数型, 公开, 返回请求的当前状态
    返回 (对象.读数值属性 (“readyState”, ))

.子程序 置onreadystatechange, , 公开, 指定当readyState属性改变时的子程序指针
    .参数 参数值, 子程序指针

    对象.写属性 (“onreadystatechange”, 参数值)

.版本 2

.程序集 类_脚本组件, , 公开
.程序集变量 脚本对象, 对象

.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
    线程_初始化COM库 ()
    脚本对象.创建 (“ScriptControl”, )
    脚本对象.写属性 (“Language”, “JScript”)

.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
    脚本对象.清除 ()
    线程_取消COM库 ()

.子程序 执行, 逻辑型, 公开, 执行指定的代码文本。返回真为执行正常，返回假为出错，错误信息可以从“错误信息”属性中取得。
    .参数 脚本代码, 文本型
    .局部变量 脚本代码_变体型, 变体型

    ' 脚本代码_变体型.赋值 (编码_Ansi到Unicode (脚本代码), )
    ' 脚本对象.数值方法 (“ExecuteStatement”, 脚本代码_变体型)
    脚本对象.数值方法 (“ExecuteStatement”, 脚本代码)
    返回 (脚本对象.取错误 () ＝ “”)

.子程序 计算表达式, 文本型, 公开, 计算表达式并返回结果。
    .参数 表达式, 文本型

    返回 (脚本对象.文本方法 (“Eval”, 表达式))

.子程序 清除, , 公开
    脚本对象.数值方法 (“Reset”, )

.子程序 取错误, 文本型, 公开, 返回错误信息
    返回 (脚本对象.取错误 ())

.子程序 取脚本对象, 对象, 公开
    返回 (脚本对象)

.子程序 运行, 文本型, 公开, 在添加的代码中运行指定的过程，如有返回值返回相应文本，否则返回空文本。
    .参数 过程或函数名, 文本型
    .参数 参数1, 文本型, 可空
    .参数 参数2, 文本型, 可空
    .参数 参数3, 文本型, 可空
    .参数 参数4, 文本型, 可空
    .参数 参数5, 文本型, 可空
    .参数 参数6, 文本型, 可空

    .判断开始 (是否为空 (参数1) ＝ 假 且 是否为空 (参数2) ＝ 假 且 是否为空 (参数3) ＝ 假 且 是否为空 (参数4) ＝ 假 且 是否为空 (参数5) ＝ 假 且 是否为空 (参数6) ＝ 假)
        返回 (脚本对象.文本方法 (“Run”, 过程或函数名, 参数1, 参数2, 参数3, 参数4, 参数5, 参数6))
    .判断 (是否为空 (参数1) ＝ 假 且 是否为空 (参数2) ＝ 假 且 是否为空 (参数3) ＝ 假 且 是否为空 (参数4) ＝ 假 且 是否为空 (参数5) ＝ 假)
        返回 (脚本对象.文本方法 (“Run”, 过程或函数名, 参数1, 参数2, 参数3, 参数4, 参数5))
    .判断 (是否为空 (参数1) ＝ 假 且 是否为空 (参数2) ＝ 假 且 是否为空 (参数3) ＝ 假 且 是否为空 (参数4) ＝ 假)
        返回 (脚本对象.文本方法 (“Run”, 过程或函数名, 参数1, 参数2, 参数3, 参数4))
    .判断 (是否为空 (参数1) ＝ 假 且 是否为空 (参数2) ＝ 假 且 是否为空 (参数3) ＝ 假)
        返回 (脚本对象.文本方法 (“Run”, 过程或函数名, 参数1, 参数2, 参数3))
    .判断 (是否为空 (参数1) ＝ 假 且 是否为空 (参数2) ＝ 假)
        返回 (脚本对象.文本方法 (“Run”, 过程或函数名, 参数1, 参数2))
    .判断 (是否为空 (参数1) ＝ 假)
        返回 (脚本对象.文本方法 (“Run”, 过程或函数名, 参数1))
    .默认
        返回 (脚本对象.文本方法 (“Run”, 过程或函数名))
    .判断结束
    

.子程序 属性_语言, 文本型, 公开, 设置或返回正在使用的脚本语言名称。
    .参数 新语言属性, 整数型, 可空, 默认为为 JScript   0. JScript   1. VBScript

    .判断开始 (新语言属性 ＝ 0)
        脚本对象.写属性 (“Language”, “JScript”)
    .判断 (新语言属性 ＝ 1)
        脚本对象.写属性 (“Language”, “vbs”)
    .默认
        
    .判断结束
    返回 (脚本对象.读文本属性 (“Language”, ))

.子程序 属性_超时, 整数型, 公开, 设置或返回时间（毫秒），此时间后用户可选择中止脚本代码的执行或允许代码继续执行。
    .参数 新超时属性值, 整数型, 可空, 默认为-1，执行无超时

    .如果真 (是否为空 (新超时属性值))
        新超时属性值 ＝ -1
    .如果真结束
    脚本对象.写属性 (“Timeout”, 新超时属性值)
    返回 (脚本对象.读数值属性 (“Timeout”, ))

.子程序 属性_状态, 整数型
    .参数 新状态值, 整数型, 可空, 参数值为以下值之一： 0、Initialized； 1、Connected

    .如果真 (是否为空 (新状态值) ＝ 假)
        脚本对象.写属性 (“State”, 新状态值)
    .如果真结束
    返回 (脚本对象.读数值属性 (“State”, ))

.子程序 属性_是否使用图形界面, 逻辑型
    .参数 新是否使用图形界面属性, 逻辑型, 可空

    .如果真 (是否为空 (新是否使用图形界面属性) ＝ 假)
        脚本对象.写属性 (“AllowUI”, 新是否使用图形界面属性)
    .如果真结束
    返回 (脚本对象.读逻辑属性 (“AllowUI”, ))

.子程序 属性_图形界面父窗口句柄, 整数型
    .参数 新父窗口句柄, 整数型, 可空

    .如果真 (是否为空 (新父窗口句柄) ＝ 假)
        脚本对象.写属性 (“SitehWnd”, 新父窗口句柄)
    .如果真结束
    返回 (脚本对象.读数值属性 (“SitehWnd”, ))

.子程序 添加代码
    .参数 代码文本, 文本型

    脚本对象.数值方法 (“AddCode”, 代码文本)

.子程序 未封装的属性及方法
    ' 类型: IScriptControl  10个属性，6个方法，标记: {0E59F1D3-1FBE-11D0-8FF2-00A0D10038BC}
    ' -------------------------------- 属性列表 --------------------------------
    ' 属性读取格式： 〈逻辑型〉 对象．读逻辑属性 （"UseSafeSubset"）
    ' 属性写入格式： 〈逻辑型〉 对象．写属性 （"UseSafeSubset"，欲写入属性值）
    ' 参数<1>的名称为“欲写入属性值”，类型为“逻辑型”。
    ' 解释：Force script to execute in safe mode and disallow potentially harmful actions
    
    
    ' 属性读取格式： 〈对象(IScriptModuleCollection)〉 对象．读对象型属性 （"Modules"）
    ' 解释：Collection of modules for the ScriptControl
    
    ' 属性读取格式： 〈对象〉 对象．读对象型属性 （"CodeObject"）
    ' 解释：Object exposed by the scripting engine that contains methods and properties defined in the code added to the global module
    
    
    ' 属性读取格式： 〈对象(IScriptProcedureCollection)〉 对象．读对象型属性 （"Procedures"）
    ' 解释：Collection of procedures that are defined in the global module
    
    
    ' -------------------------------- 方法列表 --------------------------------
    ' 方法调用格式： 〈整数型〉 对象．数值方法 （"AddObject"，Name，Object，AddMembers）
    ' 参数<1>的名称为“Name”，类型为“文本型”。
    ' 参数<2>的名称为“Object”，类型为“对象”。
    ' 参数<3>的名称为“AddMembers”，类型为“逻辑型”，参数默认值为“假”。
    ' 解释：Add an object to the global namespace of the scripting engine
    

.版本 2

.程序集 集_IP
.子程序 IP_转至16进制, 文本型, 公开, 把IP地址转换至16进制的IP，如：“192.168.1.1”转换后为 “C0A80101”
    .参数 IP地址, 文本型, , 如：“192.168.1.1”
    .局部变量 num, 长整数型

    num ＝ IP_转至10进制 (IP地址)
    返回 (进制_十到十六 (num))

.子程序 IP_转至10进制, 长整数型, 公开, 把IP地址转换至10进制的IP，如：“192.168.1.1”转换后为 “3232235777”
    .参数 IP地址, 文本型, , 如：“192.168.1.1”
    .局部变量 num, 长整数型
    .局部变量 局_IP, 文本型, , "0"

    局_IP ＝ 分割文本 (IP地址, “.”, )
    .如果真 (取数组成员数 (局_IP) ＞ 3)
        返回 (到整数 (局_IP [4]) ＋ 到整数 (局_IP [3]) × 256 ＋ 到整数 (局_IP [2]) × 256 × 256 ＋ 到整数 (局_IP [1]) × 256 × 256 × 256)
    .如果真结束
    返回 (-1)

.子程序 IP_10进制转IP, 文本型, 公开, 把10进制的IP转换至文本型IP，如：“3232235777”转换后为“192.168.1.1”
    .参数 十进制IP, 长整数型, , 如：“3232235777”
    .局部变量 字节集, 字节集
    .局部变量 tt, 整数型, , "4", 101.4.163.132
    .局部变量 i, 整数型
    .局部变量 str, 文本型

    字节集 ＝ 取字节集左边 (到字节集 (十进制IP), 4)
    .变量循环首 (4, 1, -1, i)
        str ＝ str ＋ 到文本 (字节集 [i]) ＋ “.”
    .变量循环尾 ()
    返回 (取文本左边 (str, 取文本长度 (str) － 1))

.子程序 IP_16进制转IP, 文本型, 公开, 把16进制的IP转换至文本型IP，如：“C0A80101”转换后为“192.168.1.1”
    .参数 十六进制IP, 文本型, , 如：“C0A80101”

    返回 (IP_10进制转IP (进制_十六到十 (十六进制IP)))

.版本 2

.程序集 集_时间
.程序集变量 时间标记, 文本型, , "0"

.子程序 时间_秒到时分秒格式, 文本型, 公开, 返回指定格式的时间文本
    .参数 秒, 整数型
    .参数 格式, 文本型, 可空, 默认:d天h小时m分s秒
    .参数 自动补零, 逻辑型, 可空, 不足2位数自动前面补0
    .局部变量 局_天, 整数型
    .局部变量 局_小时, 整数型
    .局部变量 局_分, 整数型
    .局部变量 局_秒, 整数型
    .局部变量 局_位置, 整数型
    .局部变量 局_Time, 文本型

    局_秒 ＝ 秒
    .如果真 (是否为空 (格式) 或 格式 ＝ “”)
        格式 ＝ “d天h小时m分s秒”
    .如果真结束
    
    局_天 ＝ 局_秒 ÷ 86400
    局_小时 ＝ 局_秒 ％ 86400 ÷ 3600
    局_分 ＝ 局_秒 ％ 86400 ％ 3600 ÷ 60
    局_秒 ＝ 局_秒 ％ 86400 ％ 3600 ％ 60
    
    局_位置 ＝ 倒找文本 (格式, “d”, , 假)
    .如果真 (局_位置 ≠ -1)
        局_Time ＝ 到文本 (局_天)
        .如果真 (自动补零)
            局_Time ＝ 文本_自动补零 (局_Time, 2)
        .如果真结束
        格式 ＝ 文本替换 (格式, 局_位置, 1, 局_Time)
    .如果真结束
    
    局_位置 ＝ 倒找文本 (格式, “h”, , 假)
    .如果真 (局_位置 ≠ -1)
        局_Time ＝ 到文本 (局_小时)
        .如果真 (自动补零)
            局_Time ＝ 文本_自动补零 (局_Time, 2)
        .如果真结束
        格式 ＝ 文本替换 (格式, 局_位置, 1, 局_Time)
    .如果真结束
    
    局_位置 ＝ 倒找文本 (格式, “m”, , 假)
    .如果真 (局_位置 ≠ -1)
        局_Time ＝ 到文本 (局_分)
        .如果真 (自动补零)
            局_Time ＝ 文本_自动补零 (局_Time, 2)
        .如果真结束
        格式 ＝ 文本替换 (格式, 局_位置, 1, 局_Time)
    .如果真结束
    
    局_位置 ＝ 倒找文本 (格式, “s”, , 假)
    .如果真 (局_位置 ≠ -1)
        局_Time ＝ 到文本 (局_秒)
        .如果真 (自动补零)
            局_Time ＝ 文本_自动补零 (局_Time, 2)
        .如果真结束
        格式 ＝ 文本替换 (格式, 局_位置, 1, 局_Time)
    .如果真结束
    
    返回 (格式)

.子程序 时间_十八位时间戳转北京, 日期时间型, 公开, 将【18位的时间戳】转换成【北京标准时间】
    .参数 十八位时间戳, 文本型, , 要转换的18位时间时间戳
    .局部变量 十三位时间戳, 长整数型

    ' 例程来自：https://bbs.125.la/thread-14319889-1-1.html
    十三位时间戳 ＝ (到长整数 (十八位时间戳) － 到长整数 (“621355968000000000”)) ÷ 10000
    返回 (时间_格林威治转北京 (十三位时间戳))

.子程序 时间_北京转十八位时间戳, 文本型, 公开, 将【北京标准时间】转换成【18位的时间戳】
    .参数 时间, 日期时间型, , 要转换的时间
    .局部变量 十三位时间戳, 长整数型
    .局部变量 十八位时间戳, 长整数型

    ' 例程来自：https://bbs.125.la/thread-14319889-1-1.html
    十三位时间戳 ＝ 到长整数 (时间_到时间戳 (时间, 假, ))
    十八位时间戳 ＝ 十三位时间戳 × 10000 ＋ 到长整数 (“621355968000000000”)
    返回 (到文本 (十八位时间戳))

.子程序 时间_取时间间隔, 文本型, 公开, 返回一个文本，表示“时间1”减去“时间2”之后间隔的天，时，分，秒。返回示例：3天13时56分27秒
    .参数 时间1, 日期时间型
    .参数 时间2, 日期时间型
    .局部变量 剩余秒数A, 整数型
    .局部变量 剩余秒数B, 整数型
    .局部变量 剩余天, 整数型
    .局部变量 剩余小时, 整数型
    .局部变量 剩余分钟, 整数型
    .局部变量 剩余秒, 整数型
    .局部变量 返回时间, 文本型

    ' 源码出处：https://bbs.125.la/thread-14315424-1-1.html
    剩余秒数A ＝ 取时间间隔 (时间1, 时间2, 8)
    .如果真 (剩余秒数A ＜ 0)
        剩余秒数A ＝ 剩余秒数A × -1
    .如果真结束
    剩余秒数B ＝ 剩余秒数A ％ 86400
    剩余天 ＝ (剩余秒数A － 剩余秒数B) ÷ 86400
    剩余秒数A ＝ 剩余秒数B
    剩余秒数B ＝ 剩余秒数A ％ 3600
    剩余小时 ＝ (剩余秒数A － 剩余秒数B) ÷ 3600
    剩余秒数A ＝ 剩余秒数B
    剩余秒数B ＝ 剩余秒数A ％ 60
    剩余分钟 ＝ (剩余秒数A － 剩余秒数B) ÷ 60
    剩余秒 ＝ 剩余秒数B
    .如果真 (剩余天 ≠ 0)
        返回时间 ＝ 到文本 (剩余天) ＋ “天”
    .如果真结束
    .如果真 (剩余小时 ≠ 0)
        返回时间 ＝ 返回时间 ＋ 到文本 (剩余小时) ＋ “时”
    .如果真结束
    .如果真 (剩余分钟 ≠ 0)
        返回时间 ＝ 返回时间 ＋ 到文本 (剩余分钟) ＋ “分”
    .如果真结束
    .如果真 (剩余秒 ≠ 0)
        返回时间 ＝ 返回时间 ＋ 到文本 (剩余秒) ＋ “秒”
    .如果真结束
    返回 (返回时间)

.子程序 时间_转为GMT格式, 文本型, 公开, 将日期时间型数据转换为GMT格式 Greenwich Mean Time
    .参数 待转换时间, 日期时间型
    .局部变量 整数容器, 整数型
    .局部变量 GMT时间, 文本型

    整数容器 ＝ 取星期几 (待转换时间)
    .判断开始 (整数容器 ＝ 1)
        GMT时间 ＝ “Sun, ”
    .判断 (整数容器 ＝ 2)
        GMT时间 ＝ “Mon, ”
    .判断 (整数容器 ＝ 3)
        GMT时间 ＝ “Tue, ”
    .判断 (整数容器 ＝ 4)
        GMT时间 ＝ “Wed, ”
    .判断 (整数容器 ＝ 5)
        GMT时间 ＝ “Thu, ”
    .判断 (整数容器 ＝ 6)
        GMT时间 ＝ “Fri, ”
    .判断 (整数容器 ＝ 7)
        GMT时间 ＝ “Sat, ”
    .默认
        
    .判断结束
    GMT时间 ＝ GMT时间 ＋ 到文本 (取日 (待转换时间)) ＋ “-”
    整数容器 ＝ 取月份 (待转换时间)
    .判断开始 (整数容器 ＝ 1)
        GMT时间 ＝ GMT时间 ＋ “Jan” ＋ “-”
    .判断 (整数容器 ＝ 2)
        GMT时间 ＝ GMT时间 ＋ “Feb” ＋ “-”
    .判断 (整数容器 ＝ 3)
        GMT时间 ＝ GMT时间 ＋ “Mar” ＋ “-”
    .判断 (整数容器 ＝ 4)
        GMT时间 ＝ GMT时间 ＋ “Apr” ＋ “-”
    .判断 (整数容器 ＝ 5)
        GMT时间 ＝ GMT时间 ＋ “May” ＋ “-”
    .判断 (整数容器 ＝ 6)
        GMT时间 ＝ GMT时间 ＋ “Jun” ＋ “-”
    .判断 (整数容器 ＝ 7)
        GMT时间 ＝ GMT时间 ＋ “Jul” ＋ “-”
    .判断 (整数容器 ＝ 8)
        GMT时间 ＝ GMT时间 ＋ “Aug” ＋ “-”
    .判断 (整数容器 ＝ 9)
        GMT时间 ＝ GMT时间 ＋ “Sep” ＋ “-”
    .判断 (整数容器 ＝ 10)
        GMT时间 ＝ GMT时间 ＋ “Oct” ＋ “-”
    .判断 (整数容器 ＝ 11)
        GMT时间 ＝ GMT时间 ＋ “Nov” ＋ “-”
    .判断 (整数容器 ＝ 12)
        GMT时间 ＝ GMT时间 ＋ “Dec” ＋ “-”
    .默认
        
    .判断结束
    
    
    
    GMT时间 ＝ GMT时间 ＋ 到文本 (取年份 (待转换时间)) ＋ “ ” ＋ 到文本 (内部_补全 (取小时 (待转换时间))) ＋ “:” ＋ 到文本 (内部_补全 (取分钟 (待转换时间))) ＋ “:” ＋ 到文本 (内部_补全 (取秒 (待转换时间))) ＋ “ GMT”
    返回 (GMT时间)

.子程序 内部_补全, 文本型
    .参数 参_原数据, 整数型
    .局部变量 局_新数据, 文本型

    .如果真 (参_原数据 ＜ 10)
        局_新数据 ＝ “0” ＋ 到文本 (参_原数据)
        返回 (局_新数据)
    .如果真结束
    返回 (到文本 (参_原数据))

.子程序 时间_转为GMT格式1, 文本型, 公开, 感谢会员shituo提供代码，将日期时间型数据转换为GMT格式 Greenwich Mean Time
    .参数 待转换时间, 日期时间型, 可空, 可为空，默认即现行时间。
    .局部变量 GMT时间, 文本型
    .局部变量 time, 精易_时间
    .局部变量 Success, 逻辑型

    .如果 (是否为空 (待转换时间))
        ' GetLocalTime (time)
        GetSystemTime (time)
    .否则
        ' time.年 ＝ 取年份 (待转换时间)
        ' time.月 ＝ 取月份 (待转换时间)
        ' time.日 ＝ 取日 (待转换时间)
        ' time.时 ＝ 取小时 (待转换时间)
        ' time.分 ＝ 取分钟 (待转换时间)
        ' time.秒 ＝ 取秒 (待转换时间)
        VariantTimeToSystemTime (待转换时间, time)
    .如果结束
    
    GMT时间 ＝ 取空白文本 (128)
    Success ＝ InternetTimeFromSystemTime (time, 0, GMT时间, 128)
    返回 (选择 (Success, GMT时间, “”))

.子程序 时间_转为GMT格式2, 文本型, 公开, 将日期时间型数据转换为GMT格式 Greenwich Mean Time
    .参数 Time, 日期时间型, 可空, 可空，默认即现行时间。
    .局部变量 Success, 逻辑型
    .局部变量 pwszTimeStr, 字节集
    .局部变量 sTime, 精易_时间
    .局部变量 Retrun, 文本型

    .如果 (是否为空 (Time))
        ' GetLocalTime (sTime)
        GetSystemTime (sTime)
    .否则
        sTime.年 ＝ 取年份 (Time)
        sTime.月 ＝ 取月份 (Time)
        sTime.日 ＝ 取日 (Time)
        sTime.时 ＝ 取小时 (Time)
        sTime.分 ＝ 取分钟 (Time)
        sTime.秒 ＝ 取秒 (Time)
        sTime.星期 ＝ 取星期几 (Time)
    .如果结束
    
    pwszTimeStr ＝ 取空白字节集 (100)
    Success ＝ WinHttpTimeFromSystemTime (sTime, pwszTimeStr)
    Retrun ＝ 编码_Unicode到Ansi (pwszTimeStr)
    返回 (Retrun)

.子程序 时间_转为GMT格式3, 文本型, 公开, 将日期时间型数据转换为GMT格式 Greenwich Mean Time
    .参数 lpDateTime, 日期时间型, 可空
    .局部变量 time, 精易_时间
    .局部变量 lpDateStr, 文本型
    .局部变量 lpTimeStr, 文本型

    ' 例程收录自：https://bbs.125.la/thread-14396648-1-1.html
    .判断开始 (是否为空 (lpDateTime))
        GetSystemTime (time)
    .判断 (VariantTimeToSystemTime (lpDateTime, time) ≠ 1)
        返回 (“”)
    .默认
        
    .判断结束
    ' Fri, 21 Jun 2019 09:18:38 GMT
    lpDateStr ＝ 取空白文本 (50)
    lpTimeStr ＝ 取空白文本 (24)
    GetDateFormatA (#en_US, 0, time, “ddd, dd MMM yyyy”, lpDateStr, 50)
    GetTimeFormatA (#en_US, 0, time, “HH:mm:ss GMT”, lpTimeStr, 24)
    返回 (lpDateStr ＋ “ ” ＋ lpTimeStr)

.子程序 时间_GMT转为时间, 日期时间型, 公开, 感谢会员shituo提供代码，将GMT文本时间 转换成日期时间型
    .参数 GMT时间, 文本型
    .参数 东八区时差, 逻辑型, 可空, 默认为真
    .局部变量 stime, 精易_时间
    .局部变量 DateFormat, 日期时间型

    InternetTimeToSystemTime (GMT时间, stime, 0)
    DateFormat ＝ 指定时间 (stime.年, stime.月, stime.日, stime.时, stime.分, stime.秒)
    .如果真 (是否为空 (东八区时差) 或 东八区时差)
        DateFormat ＝ 增减时间 (DateFormat, #小时, 8)
    .如果真结束
    返回 (DateFormat)

.子程序 时间_GMT转为时间1, 日期时间型, 公开, 将GMT文本时间 转换成日期时间型
    .参数 GMT时间, 文本型
    .参数 东八区时差, 逻辑型, 可空, 默认为真
    .局部变量 Success, 逻辑型
    .局部变量 pwszTimeStr, 字节集
    .局部变量 sTime, 精易_时间
    .局部变量 DateFormat, 日期时间型

    pwszTimeStr ＝ 编码_Ansi到Unicode (GMT时间)
    Success ＝ WinHttpTimeToSystemTime (pwszTimeStr, sTime)
    DateFormat ＝ 指定时间 (sTime.年, sTime.月, sTime.日, sTime.时, sTime.分, sTime.秒)
    .如果真 (是否为空 (东八区时差) 或 东八区时差)
        DateFormat ＝ 增减时间 (DateFormat, #小时, 8)
    .如果真结束
    返回 (DateFormat)

.子程序 时间_取现行时间戳, 文本型, 公开, 生成秒或毫秒时间戳，默认生成毫秒时间戳。
    .参数 是否取十位时间戳, 逻辑型, 可空, 本参数为真时，将生成10位时间戳返回
    .局部变量 时间b, 精易_时间
    .局部变量 返回值, 文本型
    .局部变量 毫秒数, 文本型
    .局部变量 时间a, 文本型

    GetLocalTime (时间b)
    毫秒数 ＝ 文本_自动补零 (到文本 (时间b.毫), 3)
    时间a ＝ 到文本 (到长整数 (取时间间隔 (取现行时间 (), 到时间 (“1970-01-01 08:00:00”), #秒)))
    返回值 ＝ 时间a ＋ 毫秒数
    ' 返回值 ＝ 选择 (是否取十位时间戳, 取文本左边 (时间a ＋ 毫秒数, 10), 时间a ＋ 毫秒数)
    .判断开始 (是否取十位时间戳)
        返回值 ＝ 取文本左边 (返回值, 10)
        .判断循环首 (取文本长度 (返回值) ＜ 10)
            返回值 ＝ 返回值 ＋ “0”
        .判断循环尾 ()
        返回 (返回值)
    .默认
        
        .判断循环首 (取文本长度 (返回值) ＜ 13)
            返回值 ＝ 返回值 ＋ “0”
        .判断循环尾 ()
        返回 (返回值)
    .判断结束
    

.子程序 时间_取现行时间戳1, 长整数型, 公开, 生成秒或毫秒时间戳
    .参数 精确到毫秒, 逻辑型, 可空, 默认为假 精确到秒10位数 精确到毫秒13位数
    .局部变量 ret, 长整数型

    ' https://bbs.125.la/forum.php?mod=viewthread&tid=14649396
    GetSystemTimeAsFileTime (取指针地址_长整数型 (ret))
    ret ＝ FileTimeToUnixTime (ret)
    .如果 (精确到毫秒)
        ret ＝ ret ÷ 10000
    .否则
        ret ＝ ret ÷ 10000000
    .如果结束
    返回 (ret)

.子程序 时间_取北京时间戳, 文本型, 公开, 生成秒或毫秒时间戳，默认生成毫秒时间戳。
    .参数 是否取十位时间戳, 逻辑型, 可空, 本参数为真时，将生成10位时间戳返回
    .局部变量 局_时间, 日期时间型

    局_时间 ＝ 时间_取北京时间 ()
    返回 (时间_到时间戳 (局_时间, 是否取十位时间戳, ))

.子程序 时间_取北京时间, 日期时间型, 公开, 获取北京时间，超稳定，长久不失效，代码提供者：aqwvwv
    .参数 参_网址, 文本型, 可空
    .局部变量 局_返回协议头, 文本型
    .局部变量 局_时间, 日期时间型

    .如果真 (是否为空 (参_网址))
        参_网址 ＝ “http://www.baidu.com/”
    .如果真结束
    网页_访问_对象 (参_网址, 2, , , , , 局_返回协议头, , , , , , , , , , , , )
    局_返回协议头 ＝ 文本_取出中间文本 (局_返回协议头, “Date:”, #换行符)
    局_时间 ＝ 时间_GMT转为时间 (局_返回协议头)
    返回 (局_时间)

.子程序 时间_到时间戳, 文本型, 公开, 把指定日期时间转换为秒或毫秒时间戳,默认生成毫秒时间戳。
    .参数 欲处理的时间, 日期时间型, 可空, 可为空，默认为现行时间。此处参数影响最终结果，如果含毫秒且毫秒不要为0，请留空！
    .参数 十位时间戳, 逻辑型, 可空, 本参数为真时，将生成10位时间戳返回
    .参数 是否补满10位, 逻辑型, 可空, 如果参数为真，则保证一定取出至少10位，如果不足10位，在前面补0。如果为假，则直接取出。
    .局部变量 SystemTime, 精易_时间
    .局部变量 vTime, 日期时间型
    .局部变量 szTimeStamp, 文本型
    .局部变量 szMilliseconds, 文本型

    GetLocalTime (SystemTime)
    .如果 (是否为空 (欲处理的时间))
        SystemTimeToVariantTime (SystemTime, vTime)
    .否则
        vTime ＝ 欲处理的时间
    .如果结束
    szTimeStamp ＝ 到文本 (取时间间隔 (vTime, 到时间 (“1970-01-01 08:00:00”), #秒))
    .如果真 (是否补满10位)
        szTimeStamp ＝ 文本_自动补零 (szTimeStamp, 10)
    .如果真结束
    .如果真 (十位时间戳)
        返回 (取文本左边 (szTimeStamp, 10))
    .如果真结束
    .如果 (是否为空 (欲处理的时间))
        szMilliseconds ＝ 文本_自动补零 (到文本 (SystemTime.毫), 3)
    .否则
        szMilliseconds ＝ “000”
    .如果结束
    返回 (szTimeStamp ＋ szMilliseconds)

.子程序 时间_到时间戳1, 文本型, 公开, 时间 => Unix时间戳
    .参数 时间, 日期时间型, 可空
    .参数 时间单位, 整数型, 可空, 秒、毫秒
    .局部变量 SystemTime, 精易_时间
    .局部变量 localFileTime, FILETIME
    .局部变量 FileTime, FILETIME
    .局部变量 li, 长整数型

    .如果 (是否为空 (时间))
        GetLocalTime (SystemTime)
        SystemTimeToFileTime (SystemTime, localFileTime)
        LocalFileTimeToFileTime (localFileTime, FileTime)
        li ＝ 合并长整数 (FileTime.dwLowDateTime, FileTime.dwHighDateTime)
    .否则
        li ＝ VariantTimeToQuadPart (时间)
    .如果结束
    li ＝ 到长整数 (li － VariantTimeToQuadPart ([1970年1月1日8时]))
    .如果 (时间单位 ＝ 1)
        li ＝ 到长整数 (li ÷ 10000) ' 毫秒
    .否则
        li ＝ 到长整数 (li ÷ 10000000) ' 秒
    .如果结束
    返回 (到文本 (li))

.子程序 时间_取随机时间戳, 文本型, 公开, 生成一个随机的时间戳。如：0.842703761170252
    .局部变量 VBscript, 对象
    .局部变量 局_文本, 文本型

    线程_初始化COM库 ()
    VBscript.创建 (“ScriptControl”, )
    VBscript.写属性 (“Language”, “JScript”)
    VBscript.数值方法 (“ExecuteStatement”, “function time(){return Math.random().toString()}”)
    局_文本 ＝ VBscript.文本方法 (“Run”, “time”)
    VBscript.清除 ()
    线程_取消COM库 ()
    返回 (局_文本)

.子程序 时间_时间戳转文本, 文本型, 公开, 把一个13位的时间戳，如：1325252169718 转成 2011-12-30 21:36:09
    .参数 时间戳, 文本型
    .参数 小时制式, 整数型, 可空, 留空或为0取当前系统时间制式，1表示12小时制，2表示24小时制; 注: 本参数只对10位时间戳有效
    .局部变量 VBscript, 对象
    .局部变量 局_文本, 文本型
    .局部变量 局_时间, 日期时间型
    .局部变量 局_制式, 整数型

    .如果 (取文本长度 (时间戳) ＝ 10)
        局_时间 ＝ 增减时间 (到时间 (“1970.01.01 08:00:00”), #秒, 到整数 (时间戳))
        .如果 (小时制式 ≤ 0 或 小时制式 ＞ 2)
            局_制式 ＝ 时间_取制式 ()
        .否则
            局_制式 ＝ 小时制式 － 1
        .如果结束
        返回 (选择 (局_制式 ＝ 0, 时间_格式化 (局_时间, “yyyy-MM-dd ”, “hh:mm:ss”, ), 时间_格式化 (局_时间, “yyyy-MM-dd ”, “HH:mm:ss”, )))
    .否则
        CoInitialize (0)
        .如果真 (VBscript.创建 (“ScriptControl”, ))
            VBscript.写属性 (“Language”, “JScript”)
            VBscript.数值方法 (“ExecuteStatement”, #TimestampToString ＋ “var Timer=new Date();Timer.setTime('” ＋ 时间戳 ＋ “');”)
            局_文本 ＝ VBscript.文本方法 (“Eval”, “Timer.format('yyyy-MM-dd hh:mm:ss')”, )
            VBscript.清除 ()
        .如果真结束
        CoUninitialize ()
        返回 (局_文本)
    .如果结束
    

.子程序 时间_时间戳转文本1, 文本型, 公开, Unix时间戳 => 时间
    .参数 Unix时间戳, 文本型
    .参数 时间单位, 整数型, 可空, 秒、毫秒
    .局部变量 li, 长整数型
    .局部变量 vTime, 日期时间型

    .如果 (时间单位 ＝ 1)
        li ＝ VariantTimeToQuadPart ([1970年1月1日8时]) ＋ 到长整数 (到长整数 (Unix时间戳) × 10000) ' 毫秒
    .否则
        li ＝ VariantTimeToQuadPart ([1970年1月1日8时]) ＋ 到长整数 (到长整数 (Unix时间戳) × 10000000) ' 秒
    .如果结束
    vTime ＝ QuadPartToVariantTime (li)
    返回 (时间_到文本 (vTime, 1, , 2))

.子程序 时间_取公历节日, 文本型, 公开, 根据公历年月日,返回公历的节日,某些节日需要有年代才能确定是星期几.
    .参数 公历年, 整数型, 可空
    .参数 公历月, 整数型, 可空
    .参数 公历日, 整数型, 可空
    .局部变量 节日文本, 文本型
    .局部变量 星期几, 整数型

    星期几 ＝ 取星期几 (到时间 (到文本 (公历年) ＋ “年” ＋ 到文本 (公历月) ＋ “月” ＋ 到文本 (公历日) ＋ “日”))
    节日文本 ＝ “”
    .如果真 (公历月 ＝ 1 且 公历日 ＝ 1)
        节日文本 ＝ “元旦”
    .如果真结束
    .如果真 (公历月 ＝ 2 且 公历日 ＝ 14)
        节日文本 ＝ “情人节”
    .如果真结束
    .如果真 (公历月 ＝ 3 且 公历日 ＝ 5)
        节日文本 ＝ “雷峰纪念日”
    .如果真结束
    .如果真 (公历月 ＝ 3 且 公历日 ＝ 8)
        节日文本 ＝ “国际劳动妇女节”
    .如果真结束
    .如果真 (公历月 ＝ 3 且 公历日 ＝ 12)
        节日文本 ＝ “植树节”
    .如果真结束
    .如果真 (公历月 ＝ 3 且 公历日 ＝ 15)
        节日文本 ＝ “国际消费者权益日”
    .如果真结束
    .如果真 (公历月 ＝ 3 且 公历日 ＝ 23)
        节日文本 ＝ “国际气象日”
    .如果真结束
    .如果真 (公历月 ＝ 3 且 公历日 ＝ 31)
        节日文本 ＝ “安全教育日”
    .如果真结束
    .如果真 (公历月 ＝ 4 且 公历日 ＝ 1)
        节日文本 ＝ “愚人节”
    .如果真结束
    .如果真 (公历月 ＝ 4 且 公历日 ＝ 7)
        节日文本 ＝ “世界卫生日”
    .如果真结束
    .如果真 (公历月 ＝ 4 且 公历日 ＝ 22)
        节日文本 ＝ “世界地球日”
    .如果真结束
    .如果真 (公历月 ＝ 5 且 公历日 ＝ 1)
        节日文本 ＝ “国际劳动节”
    .如果真结束
    .如果真 (公历月 ＝ 5 且 公历日 ＝ 4)
        节日文本 ＝ “青年节”
    .如果真结束
    .如果真 (公历月 ＝ 5 且 公历日 ＝ 8)
        节日文本 ＝ “世界红十字日”
    .如果真结束
    .如果真 (公历月 ＝ 5 且 公历日 ＝ 12)
        节日文本 ＝ “国际护士节”
    .如果真结束
    .如果真 (公历月 ＝ 5 且 公历日 ＝ 15)
        节日文本 ＝ “国际家庭日”
    .如果真结束
    .如果真 (公历月 ＝ 5 且 公历日 ＝ 16)
        节日文本 ＝ “全国助残日”
    .如果真结束
    .如果真 (公历月 ＝ 5 且 公历日 ＝ 17)
        节日文本 ＝ “国际电信日”
    .如果真结束
    .如果真 (公历月 ＝ 5 且 公历日 ＝ 31)
        节日文本 ＝ “世界无烟日”
    .如果真结束
    .如果真 (公历月 ＝ 6 且 公历日 ＝ 1)
        节日文本 ＝ “国际儿童节”
    .如果真结束
    .如果真 (公历月 ＝ 6 且 公历日 ＝ 5)
        节日文本 ＝ “国际环境保护日”
    .如果真结束
    .如果真 (公历月 ＝ 6 且 公历日 ＝ 6)
        节日文本 ＝ “全国爱眼日”
    .如果真结束
    .如果真 (公历月 ＝ 6 且 公历日 ＝ 25)
        节日文本 ＝ “全国土地日”
    .如果真结束
    .如果真 (公历月 ＝ 6 且 公历日 ＝ 26)
        节日文本 ＝ “国际禁毒日”
    .如果真结束
    .如果真 (公历月 ＝ 7 且 公历日 ＝ 1)
        节日文本 ＝ “党的生日、香港回归日”
    .如果真结束
    .如果真 (公历月 ＝ 7 且 公历日 ＝ 7)
        节日文本 ＝ “抗日战争胜利日”
    .如果真结束
    .如果真 (公历月 ＝ 7 且 公历日 ＝ 11)
        节日文本 ＝ “世界人口日”
    .如果真结束
    .如果真 (公历月 ＝ 8 且 公历日 ＝ 1)
        节日文本 ＝ “中国建军节”
    .如果真结束
    .如果真 (公历月 ＝ 8 且 公历日 ＝ 8)
        节日文本 ＝ “父亲节”
    .如果真结束
    .如果真 (公历月 ＝ 9 且 公历日 ＝ 8)
        节日文本 ＝ “国际扫盲日”
    .如果真结束
    .如果真 (公历月 ＝ 9 且 公历日 ＝ 9)
        节日文本 ＝ “毛泽东逝世”
    .如果真结束
    .如果真 (公历月 ＝ 9 且 公历日 ＝ 10)
        节日文本 ＝ “中国教师节”
    .如果真结束
    .如果真 (公历月 ＝ 9 且 公历日 ＝ 20)
        节日文本 ＝ “中国爱牙日”
    .如果真结束
    .如果真 (公历月 ＝ 9 且 公历日 ＝ 27)
        节日文本 ＝ “世界旅游日”
    .如果真结束
    .如果真 (公历月 ＝ 9 且 公历日 ＝ 28)
        节日文本 ＝ “世界聋人日、孔子诞辰”
    .如果真结束
    .如果真 (公历月 ＝ 10 且 公历日 ＝ 1)
        节日文本 ＝ “世界音乐日、国庆节”
    .如果真结束
    .如果真 (公历月 ＝ 10 且 公历日 ＝ 4)
        节日文本 ＝ “世界动物日”
    .如果真结束
    .如果真 (公历月 ＝ 10 且 公历日 ＝ 6)
        节日文本 ＝ “老人节”
    .如果真结束
    .如果真 (公历月 ＝ 10 且 公历日 ＝ 8)
        节日文本 ＝ “全国高血压日”
    .如果真结束
    .如果真 (公历月 ＝ 10 且 公历日 ＝ 9)
        节日文本 ＝ “世界邮政日”
    .如果真结束
    .如果真 (公历月 ＝ 10 且 公历日 ＝ 14)
        节日文本 ＝ “世界标准日”
    .如果真结束
    .如果真 (公历月 ＝ 10 且 公历日 ＝ 24)
        节日文本 ＝ “联合国日”
    .如果真结束
    .如果真 (公历月 ＝ 11 且 公历日 ＝ 1)
        节日文本 ＝ “万圣节”
    .如果真结束
    .如果真 (公历月 ＝ 11 且 公历日 ＝ 2)
        节日文本 ＝ “万灵节”
    .如果真结束
    .如果真 (公历月 ＝ 11 且 公历日 ＝ 12)
        节日文本 ＝ “孙中山诞辰”
    .如果真结束
    .如果真 (公历月 ＝ 11 且 公历日 ＝ 17)
        节日文本 ＝ “国际学生日”
    .如果真结束
    .如果真 (公历月 ＝ 12 且 公历日 ＝ 5)
        节日文本 ＝ “国际志愿人员日”
    .如果真结束
    .如果真 (公历月 ＝ 12 且 公历日 ＝ 20)
        节日文本 ＝ “澳门回归”
    .如果真结束
    .如果真 (公历月 ＝ 12 且 公历日 ＝ 25)
        节日文本 ＝ “圣诞节”
    .如果真结束
    .如果真 (公历月 ＝ 12 且 公历日 ＝ 26)
        节日文本 ＝ “毛泽东诞辰”
    .如果真结束
    .如果真 (公历月 ＝ 5 且 公历日 ＞ 7 且 公历日 ＜ 15 且 星期几 ＝ 1)
        节日文本 ＝ “母亲节”
    .如果真结束
    .如果真 (公历月 ＝ 6 且 公历日 ＞ 14 且 公历日 ＜ 22 且 星期几 ＝ 1)
        节日文本 ＝ “父亲节”
    .如果真结束
    .如果真 (公历月 ＝ 11 且 公历日 ＞ 21 且 星期几 ＝ 1)
        节日文本 ＝ “感恩节”
    .如果真结束
    返回 (节日文本)

.子程序 时间_取节气文本, 文本型, 公开, 立春,雨水,惊蛰,春分,清明,谷雨；立夏,小满,芒种,夏至,小暑,大暑；立秋,处暑,白露,秋分,寒露,霜降；立冬,小雪,大雪,冬至,小寒,大寒
    .参数 节气顺序, 整数型, , 根据24个节气返回节气名称.

    .判断开始 (节气顺序 ＝ 1)
        返回 (“立春”)
    .判断 (节气顺序 ＝ 2)
        返回 (“雨水”)
    .判断 (节气顺序 ＝ 3)
        返回 (“惊蛰”)
    .判断 (节气顺序 ＝ 4)
        返回 (“春分”)
    .判断 (节气顺序 ＝ 5)
        返回 (“清明”)
    .判断 (节气顺序 ＝ 6)
        返回 (“谷雨”)
    .判断 (节气顺序 ＝ 7)
        返回 (“立夏”)
    .判断 (节气顺序 ＝ 8)
        返回 (“小满”)
    .判断 (节气顺序 ＝ 9)
        返回 (“芒种”)
    .判断 (节气顺序 ＝ 10)
        返回 (“夏至”)
    .判断 (节气顺序 ＝ 11)
        返回 (“小暑”)
    .判断 (节气顺序 ＝ 12)
        返回 (“大暑”)
    .判断 (节气顺序 ＝ 13)
        返回 (“立秋”)
    .判断 (节气顺序 ＝ 14)
        返回 (“处暑”)
    .判断 (节气顺序 ＝ 15)
        返回 (“白露”)
    .判断 (节气顺序 ＝ 16)
        返回 (“秋分”)
    .判断 (节气顺序 ＝ 17)
        返回 (“寒露”)
    .判断 (节气顺序 ＝ 18)
        返回 (“霜降”)
    .判断 (节气顺序 ＝ 19)
        返回 (“立冬”)
    .判断 (节气顺序 ＝ 20)
        返回 (“小雪”)
    .判断 (节气顺序 ＝ 21)
        返回 (“大雪”)
    .判断 (节气顺序 ＝ 22)
        返回 (“冬至”)
    .判断 (节气顺序 ＝ 23)
        返回 (“小寒”)
    .判断 (节气顺序 ＝ 24)
        返回 (“大寒”)
    .默认
        返回 (“”)
    .判断结束
    

.子程序 时间_取美式日期, 文本型, 公开, 转换日期时间表达为美式表达方式
    .参数 日期时间, 日期时间型
    .局部变量 日期, 日期时间型
    .局部变量 美式日期, 文本型

    日期 ＝ 日期时间
    美式日期 ＝ 到文本 (取年份 (日期))
    美式日期 ＝ 美式日期 ＋ “/” ＋ 到文本 (取月份 (日期))
    美式日期 ＝ 美式日期 ＋ “/” ＋ 到文本 (取日 (日期))
    返回 (美式日期)
    

.子程序 时间_取农历节日, 文本型, 公开, 取农历所对应该的节日，需要事先知道农历日期的月份，与日子，
    .参数 农历月份, 整数型
    .参数 农历天数, 整数型
    .局部变量 节日文本, 文本型

    节日文本 ＝ “”
    .如果真 (农历月份 ＝ 1 且 农历天数 ＝ 1)
        节日文本 ＝ “春节”
        
    .如果真结束
    .如果真 (农历月份 ＝ 1 且 农历天数 ＝ 15)
        节日文本 ＝ “元宵节”
        
    .如果真结束
    .如果真 (农历月份 ＝ 2 且 农历天数 ＝ 2)
        节日文本 ＝ “中和节”
        
    .如果真结束
    .如果真 (农历月份 ＝ 5 且 农历天数 ＝ 5)
        节日文本 ＝ “端午节”
        
    .如果真结束
    .如果真 (农历月份 ＝ 7 且 农历天数 ＝ 7)
        节日文本 ＝ “七巧节”
        
    .如果真结束
    .如果真 (农历月份 ＝ 8 且 农历天数 ＝ 15)
        节日文本 ＝ “中秋节”
        
    .如果真结束
    .如果真 (农历月份 ＝ 9 且 农历天数 ＝ 9)
        节日文本 ＝ “重阳节”
        
    .如果真结束
    .如果真 (农历月份 ＝ 12 且 农历天数 ＝ 8)
        节日文本 ＝ “腊八节”
        
    .如果真结束
    .如果真 (农历月份 ＝ 12 且 农历天数 ＝ 24)
        节日文本 ＝ “小年”
        
    .如果真结束
    返回 (节日文本)

.子程序 时间_取身份证比较, 逻辑型, 公开, 对身份证号和一个日期进行比较,看两者是否一致
    .参数 身份证号, 文本型
    .参数 比较日期, 日期时间型
    .局部变量 长度, 整数型

    长度 ＝ 取文本长度 (身份证号)
    .如果真 (长度 ＝ 15)
        .如果 (到数值 (“19” ＋ 取文本中间 (身份证号, 7, 2)) ＝ 取年份 (比较日期) 且 到数值 (取文本中间 (身份证号, 9, 2)) ＝ 取月份 (比较日期) 且 到数值 (取文本中间 (身份证号, 11, 2)) ＝ 取日 (比较日期))
            返回 (真)
        .否则
            返回 (假)
        .如果结束
        
    .如果真结束
    .如果真 (长度 ＝ 18)
        .如果 (到数值 (取文本中间 (身份证号, 7, 4)) ＝ 取年份 (比较日期) 且 到数值 (取文本中间 (身份证号, 11, 2)) ＝ 取月份 (比较日期) 且 到数值 (取文本中间 (身份证号, 13, 2)) ＝ 取日 (比较日期))
            返回 (真)
        .否则
            返回 (假)
        .如果结束
        
    .如果真结束
    返回 (假)
    

.子程序 时间_取中国星期几, 文本型, 公开, 返回一个星期文本
    .参数 目标时间, 日期时间型, 可空, 如果星期数不为零,本参数不处理,否则将本参数内的时间进行处理.
    .局部变量 星期数, 整数型, , , 如果空或为零时取下面时间的返回星期几

    目标时间 ＝ 选择 (是否为空 (目标时间), 取现行时间 (), 目标时间)
    星期数 ＝ 取星期几 (目标时间)
    返回 (多项选择 (星期数, “星期日”, “星期一”, “星期二”, “星期三”, “星期四”, “星期五”, “星期六”))

.子程序 时间_取身份证日期, 文本型, 公开, 取一个身份证号中的出生日期,在本程序前对身份证是否正确进行简单判断,应该用真正的判断程序进行判断
    .参数 身份证号, 文本型
    .局部变量 长度, 整数型

    长度 ＝ 取文本长度 (身份证号)
    .如果真 (长度 ＝ 15)
        返回 (“19” ＋ 取文本中间 (身份证号, 7, 6))
    .如果真结束
    .如果真 (长度 ＝ 18)
        返回 (取文本中间 (身份证号, 7, 8))
    .如果真结束
    返回 (“”)
    

.子程序 时间_取身份证性别, 文本型, 公开, 判断身份证的性别
    .参数 身份证号, 文本型
    .局部变量 长度, 整数型

    长度 ＝ 取文本长度 (身份证号)
    .如果真 (长度 ＝ 15)
        .如果 (到数值 (取文本中间 (身份证号, 15, 1)) ％ 2 ＝ 1)
            返回 (“男”)
        .否则
            返回 (“女”)
        .如果结束
        
    .如果真结束
    .如果真 (长度 ＝ 18)
        .如果 (到数值 (取文本中间 (身份证号, 17, 1)) ％ 2 ＝ 1)
            返回 (“男”)
        .否则
            返回 (“女”)
        .如果结束
        
    .如果真结束
    返回 (“身份证有误”)

.子程序 时间_取身份证判断, 逻辑型, 公开, 判断身份证号是否正确，检测1900年到2030年中15位或18位身份证，正确返回真，错误返回假。
    .参数 身份证号, 文本型
    .局部变量 长度, 整数型
    .局部变量 局_年
    .局部变量 局_月
    .局部变量 局_日
    .局部变量 局_乘数, 整数型, , "0"
    .局部变量 局_计次
    .局部变量 和, 整数型

    长度 ＝ 取文本长度 (身份证号)
    .如果真 (长度 ＝ 15 或 长度 ＝ 18)
        .如果真 (长度 ＝ 15)
            .如果真 (到数值 (取文本中间 (身份证号, 9, 2)) ≥ 13 或 到数值 (取文本中间 (身份证号, 9, 2)) ＝ 0)
                ' 输出调试文本 (取文本中间 (身份证号, 9, 2))
                返回 (假) ' 月份大于12个月3201057302
            .如果真结束
            .如果真 (到数值 (取文本中间 (身份证号, 11, 2)) ≥ 32 或 到数值 (取文本中间 (身份证号, 11, 2)) ＝ 0)
                ' 输出调试文本 (取文本中间 (身份证号, 11, 2))
                返回 (假) ' 日子大于32天
            .如果真结束
            返回 (真)
        .如果真结束
        
        .如果真 (长度 ＝ 18)
            局_年 ＝ 到数值 (取文本中间 (身份证号, 7, 4))
            .如果真 (局_年 ≤ 1900 或 局_年 ≥ 2030)
                ' 输出调试文本 (取文本中间 (身份证号, 9, 2))
                返回 (假) ' 年份小于1900年,大于2030年
            .如果真结束
            局_月 ＝ 到数值 (取文本中间 (身份证号, 11, 2))
            .如果真 (局_月 ≥ 13 或 局_月 ＝ 0)
                ' 输出调试文本 (取文本中间 (身份证号, 11, 2))
                返回 (假) ' 月份大于12个月
            .如果真结束
            局_日 ＝ 到数值 (取文本中间 (身份证号, 13, 2))
            .如果真 (局_日 ≥ 32 或 局_日 ＝ 0)
                ' 输出调试文本 (取文本中间 (身份证号, 13, 2))
                返回 (假) ' 日子大于32天
            .如果真结束
            ' 校验码计算公式 由易友【小爬虫】提供。
            局_乘数 ＝ { 7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2 }
            .计次循环首 (17, 局_计次)
                和 ＝ 和 ＋ 到整数 (取文本中间 (身份证号, 局_计次, 1)) × 局_乘数 [局_计次]
            .计次循环尾 ()
            和 ＝ 和 ％ 11
            返回 (多项选择 (和 ＋ 1, “1”, “0”, “x”, “9”, “8”, “7”, “6”, “5”, “4”, “3”, “2”) ＝ 到小写 (取文本右边 (身份证号, 1)))
        .如果真结束
        
    .如果真结束
    返回 (假)

.子程序 时间_身份证号转换, 文本型, 公开, 从15位转换到18位身份证号
    .参数 身份证号, 文本型
    .局部变量 加权因子, 整数型, , "17"
    .局部变量 校验码串, 文本型, , "11"
    .局部变量 位, 文本型
    .局部变量 累加, 整数型
    .局部变量 校验码, 文本型
    .局部变量 计数, 整数型
    .局部变量 长度, 整数型

    加权因子 ＝ { 7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2 }
    校验码串 ＝ { “1”, “0”, “X”, “9”, “8”, “7”, “6”, “5”, “4”, “3”, “2” }
    长度 ＝ 取文本长度 (身份证号)
    .如果真 (长度 ≠ 18)
        .如果真 (长度 ≠ 15)
            返回 (“”) ' 信息框 (“身份证号码长度非法！”, #错误图标, )
        .如果真结束
        
    .如果真结束
    .如果真 (长度 ＝ 15)
        身份证号 ＝ 取文本左边 (身份证号, 6) ＋ “19” ＋ 取文本右边 (身份证号, 9)
    .如果真结束
    .计次循环首 (17, 计数)
        位 ＝ 取文本中间 (身份证号, 计数, 1)
        累加 ＝ 累加 ＋ 到数值 (位) × 加权因子 [计数]
    .计次循环尾 ()
    校验码 ＝ 校验码串 [累加 ％ 11 ＋ 1]
    身份证号 ＝ 取文本左边 (身份证号, 17) ＋ 校验码
    返回 (身份证号)

.子程序 时间_到文本, 文本型, 公开, 返回文本格式的现行时间，如：2005053107123
    .参数 操作时间, 日期时间型, 可空, 可空。留空为现行时间
    .参数 输出格式, 整数型, 可空, 可空。0=N年N月N日 N时N分N秒  1=年-月-日 时:分:秒  2=年/月/日 时/分/秒  3=年月日时分秒
    .参数 取出类型, 整数型, 可空, 可空。留空为全部，1=只取年月日，2=取月日，3=只取时分秒，4=时分，5=分秒
    .参数 小时制式, 整数型, 可空, 留空或为0取当前系统时间制式，1表示12小时制，2表示24小时制
    .局部变量 局_日期格式, 文本型
    .局部变量 局_时间格式, 文本型
    .局部变量 局_格式, 文本型
    .局部变量 局_制式, 整数型

    操作时间 ＝ 选择 (是否为空 (操作时间), 取现行时间 (), 操作时间)
    输出格式 ＝ 选择 (输出格式 ≥ 0 且 输出格式 ≤ 3, 输出格式, 0)
    局_日期格式 ＝ 多项选择 (输出格式 ＋ 1, “yyyy年MM月dd日 ”, “yyyy-MM-dd ”, “yyyy/MM/dd ”, “yyyyMMdd”)
    局_日期格式 ＝ 选择 (取出类型 ≥ 3 且 取出类型 ≤ 5, “”, 局_日期格式)
    局_时间格式 ＝ 多项选择 (输出格式 ＋ 1, “hh时mm分ss秒”, “hh:mm:ss”, “hh/mm/ss”, “hhmmss”)
    局_时间格式 ＝ 选择 (取出类型 ≥ 1 且 取出类型 ≤ 2, “”, 局_时间格式)
    .如果真 (取出类型 ＝ 1)
        局_日期格式 ＝ 删首尾空 (局_日期格式)
    .如果真结束
    .如果真 (取出类型 ＝ 2)
        局_日期格式 ＝ 多项选择 (输出格式 ＋ 1, “MM月dd日”, “MM-dd”, “MM/dd”, “MMdd”)
    .如果真结束
    .如果真 (取出类型 ＝ 4)
        局_时间格式 ＝ 多项选择 (输出格式 ＋ 1, “hh时mm分”, “hh:mm”, “hh/mm”, “hhmm”)
    .如果真结束
    .如果真 (取出类型 ＝ 5)
        局_时间格式 ＝ 多项选择 (输出格式 ＋ 1, “mm分ss秒”, “mm:ss”, “mm/ss”, “mmss”)
    .如果真结束
    .如果 (小时制式 ≤ 0 或 小时制式 ＞ 2)
        局_制式 ＝ 时间_取制式 ()
    .否则
        局_制式 ＝ 小时制式 － 1
    .如果结束
    局_时间格式 ＝ 选择 (局_制式 ＝ 1, 子文本替换 (局_时间格式, “hh”, “HH”, , , 真), 局_时间格式)
    局_格式 ＝ 时间_格式化 (操作时间, 局_日期格式, 局_时间格式)
    返回 (局_格式)

.子程序 时间_身份证号15到18, 文本型, 公开, 将15位身份证转换为18位
    .参数 身份证号15, 文本型
    .局部变量 计数, 整数型
    .局部变量 加权因子, 整数型
    .局部变量 加权码, 文本型
    .局部变量 转换后号, 文本型

    转换后号 ＝ 取文本左边 (身份证号15, 6) ＋ “19” ＋ 取文本右边 (身份证号15, 9)
    .变量循环首 (18, 2, -1, 计数)
        加权因子 ＝ 加权因子 ＋ 求次方 (2, 计数 － 1) ％ 11 × 到数值 (取文本中间 (转换后号, 19 － 计数, 1))
    .变量循环尾 ()
    加权因子 ＝ 加权因子 ％ 11
    .判断开始 (加权因子 ＝ 0)
        加权码 ＝ “1”
    .判断 (加权因子 ＝ 1)
        加权码 ＝ “0”
    .判断 (加权因子 ＝ 2)
        加权码 ＝ “X”
    .默认
        加权码 ＝ 删首尾空 (到文本 (12 － 加权因子))
    .判断结束
    返回 (转换后号 ＋ 加权码)

.子程序 时间_北京转格林威治, 长整数型, 公开, 将【北京标准时间】转换成【格林威治的标准时间】，13位的时间戳可用“时间_取现行时间戳（）”获得
    .参数 欲转换的时间, 日期时间型, 可空, 如果为空则取当前时间，如: 1970-01-01 08:00:00 或 2009年2月9日12时36分36秒

    .如果真 (是否为空 (欲转换的时间))
        欲转换的时间 ＝ 取现行时间 ()
    .如果真结束
    返回 (取时间间隔 (欲转换的时间, [1970年1月1日8时], #秒))

.子程序 时间_格林威治转北京, 日期时间型, 公开, 将【格林威治的标准时间】转换成【北京标准时间】,源码修改至官方用户
    .参数 要转换的格林威治时间, 长整数型, , 要转换的格林威治时间
    .局部变量 time, 日期时间型
    .局部变量 待转数据, 整数型
    .局部变量 局_时间, 整数型

    time ＝ 指定时间 (1970, 1, 1, 8, 0, 0)
    局_时间 ＝ 取文本长度 (到文本 (要转换的格林威治时间))
    .如果 (局_时间 ≠ 10)
        待转数据 ＝ 到整数 (取文本左边 (到文本 (要转换的格林威治时间), 10))
    .否则
        待转数据 ＝ 要转换的格林威治时间
    .如果结束
    返回 (增减时间 (time, #秒, 待转数据))

.子程序 FileTimeToUnixTime, 长整数型
    .参数 FlieTime, 长整数型
    .局部变量 ll, 长整数型

    ll ＝ FlieTime － 1.16444736e+017
    返回 (ll)

.子程序 UnixTimeToFileTime, 长整数型
    .参数 UnixTime, 长整数型
    .局部变量 ll, 长整数型
    .局部变量 位数, 整数型
    .局部变量 乘数, 整数型

    位数 ＝ 取整数位数 (UnixTime)
    乘数 ＝ 1
    .计次循环首 (17 － 位数, )
        乘数 ＝ 乘数 × 10
    .计次循环尾 ()
    ll ＝ UnixTime × 乘数 ＋ 1.16444736e+017
    返回 (ll)

.子程序 取整数位数, 整数型
    .参数 长整数, 长整数型
    .局部变量 n, 整数型
    .局部变量 l, 长整数型

    l ＝ 长整数
    n ＝ 1
    .循环判断首 ()
        l ＝ l ÷ 10
        .如果 (l ≥ 1)
            n ＝ n ＋ 1
        .否则
            跳出循环 ()
        .如果结束
        
    .循环判断尾 (l ≥ 1)
    返回 (n)

.子程序 时间_WMI时间转日期, 日期时间型, 公开, 失败返回  [100年1月1日]
    .参数 WMI数据时间, 文本型, , 如“20140926001639.000000+480”
    .局部变量 局_时间对象, 对象
    .局部变量 局_返回时间, 日期时间型

    CoInitialize (0)
    .如果 (局_时间对象.创建 (“WbemScripting.SWbemDateTime”, ))
        局_时间对象.写属性 (“Value”, WMI数据时间)
        局_返回时间 ＝ 局_时间对象.日期方法 (“GetVarDate”, )
        局_时间对象.清除 ()
    .否则
        局_返回时间 ＝ 到时间 (0)
    .如果结束
    CoUninitialize ()
    返回 (局_返回时间)

.子程序 时间_格式化, 文本型, 公开, 格式化指定日期与时间，失败返回空文本   GetTimeFormatA 该函数支持的最早时间是1600.1.1
    .参数 欲格式化时间, 日期时间型
    .参数 日期格式, 文本型, 可空, 可以为空，格式：yyyy [年]，M [月],d [日],dddd [星期]，如;yyyy/M/d dddd(年/月/日 星期几)
    .参数 时间格式, 文本型, 可空, 可以为空，格式：tt [上午或下午],h [小时],m [分钟], s [秒] 。如;hh:mm:ss(小时:分钟:秒),tt hh:mm:ss(上午或下午 小时:分钟:秒)
    .参数 使用24小时制, 逻辑型, 可空
    .参数 指定语言环境, 整数型, 可空, #LOCALE_*
    .局部变量 SystemTime, 精易_时间
    .局部变量 szDateStr, 文本型
    .局部变量 dwFlags, 整数型
    .局部变量 szTimeStr, 文本型

    .如果真 (VariantTimeToSystemTime (欲格式化时间, SystemTime) ＝ 1)
        szDateStr ＝ 取空白文本 (51)
        assignZero (szDateStr, GetDateFormatA (指定语言环境, 0, SystemTime, 日期格式 ＋ 字符 (#NULL), szDateStr, 50))
        szTimeStr ＝ 取空白文本 (51)
        .如果真 (使用24小时制)
            dwFlags ＝ #TIME_FORCE24HOURFORMAT
        .如果真结束
        assignZero (szTimeStr, GetTimeFormatA (指定语言环境, dwFlags, SystemTime, 时间格式 ＋ 字符 (#NULL), szTimeStr, 50))
    .如果真结束
    返回 (szDateStr ＋ szTimeStr)

.子程序 时间_格式化EX, 文本型, 公开, 将易语言中默认获取到的含有汉字的时间格式化为不含汉字的时间，源码由雪山凌狐提供
    .参数 未格式化时间, 日期时间型, , 使用易语言自带命令：取现行时间()等获取到的含汉字的时间
    .参数 日期间间隔, 文本型, 可空, 默认为“-”
    .参数 时间间间隔, 文本型, 可空, 默认为“:”
    .参数 返回模式, 整数型, 可空, 模式1为只返回时间（时分秒），模式为2为只返回日期（年月日），模式3为两者都返回，模式4为都返回，但日期与时间之间没有空格。如果为空，默认为1，如果不符合要求，返回为空
    .局部变量 格式化后时间, 文本型
    .局部变量 年份, 文本型
    .局部变量 月份, 文本型
    .局部变量 日, 文本型
    .局部变量 小时, 文本型
    .局部变量 分钟, 文本型
    .局部变量 秒, 文本型

    .如果真 (是否为空 (日期间间隔))
        日期间间隔 ＝ “-”
    .如果真结束
    .如果真 (是否为空 (时间间间隔))
        时间间间隔 ＝ “:”
    .如果真结束
    .如果真 (是否为空 (返回模式))
        返回模式 ＝ 1
    .如果真结束
    
    
    年份 ＝ 到文本 (取年份 (未格式化时间))
    月份 ＝ 到文本 (取月份 (未格式化时间))
    .如果真 (取文本长度 (月份) ＝ 1)
        月份 ＝ “0” ＋ 月份
    .如果真结束
    日 ＝ 到文本 (取日 (未格式化时间))
    .如果真 (取文本长度 (日) ＝ 1)
        日 ＝ “0” ＋ 日
    .如果真结束
    小时 ＝ 到文本 (取小时 (未格式化时间))
    .如果真 (取文本长度 (小时) ＝ 1)
        小时 ＝ “0” ＋ 小时
    .如果真结束
    分钟 ＝ 到文本 (取分钟 (未格式化时间))
    .如果真 (取文本长度 (分钟) ＝ 1)
        分钟 ＝ “0” ＋ 分钟
    .如果真结束
    秒 ＝ 到文本 (取秒 (未格式化时间))
    .如果真 (取文本长度 (秒) ＝ 1)
        秒 ＝ “0” ＋ 秒
    .如果真结束
    
    .判断开始 (返回模式 ＝ 1)
        格式化后时间 ＝ 小时 ＋ 时间间间隔 ＋ 分钟 ＋ 时间间间隔 ＋ 秒
    .判断 (返回模式 ＝ 2)
        格式化后时间 ＝ 年份 ＋ 日期间间隔 ＋ 月份 ＋ 日期间间隔 ＋ 日
    .判断 (返回模式 ＝ 3)
        格式化后时间 ＝ 年份 ＋ 日期间间隔 ＋ 月份 ＋ 日期间间隔 ＋ 日 ＋ “ ” ＋ 小时 ＋ 时间间间隔 ＋ 分钟 ＋ 时间间间隔 ＋ 秒
    .判断 (返回模式 ＝ 4)
        格式化后时间 ＝ 年份 ＋ 日期间间隔 ＋ 月份 ＋ 日期间间隔 ＋ 日 ＋ 小时 ＋ 时间间间隔 ＋ 分钟 ＋ 时间间间隔 ＋ 秒
    .默认
        
    .判断结束
    
    
    返回 (格式化后时间)
    
    

.子程序 时间_取制式, 整数型, 公开, 取当前系统时间制式，返回值；0表示12小时制，1表示24小时制
    .局部变量 iTime, 文本型

    iTime ＝ 取空白文本 (4)
    GetLocaleInfo (0, #LOCALE_ITIME, iTime, 4)
    返回 (到整数 (iTime))

.子程序 时间_同步校时, 日期时间型, 公开, 调用http://www.baidu.com网址接口,win8以上系统需要管理员权限
    .参数 参_是否同步, 逻辑型, 可空, 是否同步到北京时间，为空默认不同步
    .局部变量 返回文本, 文本型
    .局部变量 取出的时间, 文本型
    .局部变量 时间, 日期时间型

    网页_访问S (“https://www.baidu.com”, 2, , , , , 返回文本)
    取出的时间 ＝ 删首尾空 (文本_取出中间文本 (返回文本, “Date:”, #换行符))
    时间 ＝ 时间_GMT转为时间 (取出的时间)
    .如果真 (参_是否同步)
        置现行时间 (时间)
    .如果真结束
    返回 (时间)

.子程序 时间_取月初, 日期时间型, 公开, 源码由论坛用户【ds9660】雕哥提供。
    .参数 参_指定时间, 日期时间型, 可空

    .如果真 (是否为空 (参_指定时间))
        参_指定时间 ＝ 取现行时间 ()
    .如果真结束
    返回 (增减时间 (取日期 (参_指定时间), #日, 1 － 取日 (参_指定时间)))

.子程序 时间_取月末, 日期时间型, 公开, 源码由论坛用户【ds9660】雕哥提供。
    .参数 参_指定时间, 日期时间型, 可空
    .局部变量 局_下月, 日期时间型

    .如果真 (是否为空 (参_指定时间))
        参_指定时间 ＝ 取现行时间 ()
    .如果真结束
    局_下月 ＝ 取日期 (增减时间 (参_指定时间, #月份, 1))
    返回 (增减时间 (局_下月, #日, －取日 (局_下月)))

.子程序 时间_取某年天数, 整数型, 公开, 阳历。
    .参数 某时间, 日期时间型

    返回 (选择 (取年份 (某时间) ％ 4 ＝ 0, 366, 365))

.子程序 时间_取月总天数, 整数型, 公开, 阳历。
    .参数 输入_年
    .参数 输入_月
    .局部变量 datestr, 日期时间型
    .局部变量 sday
    .局部变量 eday, 日期时间型

    datestr ＝ 到时间 (到文本 (输入_年) ＋ “-” ＋ 到文本 (输入_月) ＋ “-” ＋ “1”)
    eday ＝ 增减时间 (datestr, #月份, 1)
    eday ＝ 增减时间 (eday, #日, -1)
    返回 (取日 (eday))

.子程序 时间_取第几周, , 公开, 查询指定日期是第几周
    .参数 参_指定日期, 日期时间型, 可空
    .参数 参_当月第几周, 整数型, 参考 可空
    .参数 参_当年第几周, 整数型, 参考 可空
    .局部变量 局_时间, 日期时间型

    局_时间 ＝ 选择 (是否为空 (参_指定日期), 取现行时间 (), 参_指定日期)
    参_当月第几周 ＝ 到整数 (编码_运行JS代码 (#时间取周数, “getMonthWeek”, 到文本 (取年份 (局_时间)), 到文本 (取月份 (局_时间)), 到文本 (取日 (局_时间)), ))
    参_当年第几周 ＝ 到整数 (编码_运行JS代码 (#时间取周数, “getYearWeek”, 到文本 (取年份 (局_时间)), 到文本 (取月份 (局_时间)), 到文本 (取日 (局_时间)), ))

.子程序 时间_取月份, 文本型, 公开, 返回一个月份,源码由论坛用户【shandmail 】提供
    .参数 目标时间, 日期时间型, 可空, 如果空或为零时取下面时间的返回月份
    .参数 是否英文, 逻辑型, 可空
    .局部变量 月数, 整数型

    ' 命令出自：https://bbs.125.la/forum.php?mod=viewthread&tid=13928859
    目标时间 ＝ 选择 (是否为空 (目标时间), 取现行时间 (), 目标时间)
    月数 ＝ 取月份 (目标时间)
    .如果 (是否英文)
        返回 (多项选择 (月数, “January”, “February”, “March”, “April”, “May”, “June”, “July”, “August”, “September”, “October”, “November”, “December”))
    .否则
        返回 (多项选择 (月数, “一月”, “二月”, “三月”, “四月”, “五月”, “六月”, “七月”, “八月”, “九月”, “十月”, “十一月”, “十二月”))
    .如果结束
    

.子程序 时间_JSON转为时间, 日期时间型, 公开, 把JSON数据格式的日期（yyyy-MM-ddTHH:mm:ss.SSSZ）转北京时间
    .参数 JSON时间, 文本型, , JSON数据格式的日期（YYYY-MM-DDTHH:mm:ss.sssZ）
    .局部变量 局_UTC, 文本型
    .局部变量 局_时间, 日期时间型
    .局部变量 i, 整数型

    i ＝ 寻找文本 (JSON时间, “.”, , 假)
    .如果真 (i ＝ -1)
        i ＝ 寻找文本 (JSON时间, “Z”, , 假)
    .如果真结束
    .如果真 (i ＝ -1)
        输出调试文本 (“传递了错误的JSON时间！”)
        返回 ([1899年12月30日])
    .如果真结束
    局_UTC ＝ 取文本左边 (JSON时间, i － 1)
    局_UTC ＝ 子文本替换 (局_UTC, “T”, 字符 (32), , , 真)
    局_时间 ＝ 到时间 (局_UTC)
    局_时间 ＝ 增减时间 (局_时间, #小时, 8) ' 东八区
    返回 (局_时间)

.子程序 时间_时间转为JSON, 文本型, 公开, 格式化为JSON数据格式（yyyy-MM-ddTHH:mm:ss.SSSZ）
    .参数 时间, 日期时间型, 可空, 留空时间默认取系统UTC时间格式。不为空请先减8个小时（东8区）。
    .局部变量 SystemTime, 精易_时间

    .如果真 (是否为空 (时间))
        GetSystemTime (SystemTime)
        SystemTimeToVariantTime (SystemTime, 时间)
    .如果真结束
    返回 (时间_格式化 (时间, “yyyy'-'MM'-'dd'T'”, “hh':'mm':'ss'.” ＋ 文本_自动补零 (到文本 (SystemTime.毫), 3) ＋ “Z'”, 真, #LOCALE_INVARIANT))

.子程序 时间_判断二十四节气, 文本型, 公开, 返回文本型：若节气日，返回节气名称；不是节气日返回空。注：判断日期范围为1901年1月1日—2099年12月31日
    .参数 日期, 日期时间型
    .局部变量 年, 整数型
    .局部变量 月, 整数型
    .局部变量 日, 整数型
    .局部变量 节气判断, 文本型

    ' https://bbs.125.la/thread-14459286-1-1.html
    节气判断 ＝ “”
    年 ＝ 取年份 (日期)
    月 ＝ 取月份 (日期)
    日 ＝ 取日 (日期)
    .判断开始 (年 ≥ 2000 且 年 ＜ 2100) ' 21世纪判断
        年 ＝ 年 － 2000
        .判断开始 (月 ＝ 2 且 日 ＝ 取整 (年 × 0.2422 ＋ 3.87) － 取整 (年 ÷ 4))
            节气判断 ＝ “立春”
        .判断 (月 ＝ 2 且 日 ＝ 取整 (年 × 0.2422 ＋ 18.73) － 取整 (年 ÷ 4) 且 年 ≠ 26)
            节气判断 ＝ “雨水”
        .判断 (月 ＝ 3 且 日 ＝ 取整 (年 × 0.2422 ＋ 5.63) － 取整 (年 ÷ 4))
            节气判断 ＝ “惊蛰”
        .判断 (月 ＝ 3 且 日 ＝ 取整 (年 × 0.2422 ＋ 20.646) － 取整 (年 ÷ 4) 且 年 ≠ 84)
            节气判断 ＝ “春分”
        .判断 (月 ＝ 4 且 日 ＝ 取整 (年 × 0.2422 ＋ 4.81) － 取整 (年 ÷ 4))
            节气判断 ＝ “清明”
        .判断 (月 ＝ 4 且 日 ＝ 取整 (年 × 0.2422 ＋ 20.1) － 取整 (年 ÷ 4))
            节气判断 ＝ “谷雨”
        .判断 (月 ＝ 5 且 日 ＝ 取整 (年 × 0.2422 ＋ 5.52) － 取整 (年 ÷ 4))
            节气判断 ＝ “立夏”
        .判断 (月 ＝ 5 且 日 ＝ 取整 (年 × 0.2422 ＋ 21.04) － 取整 (年 ÷ 4) 且 年 ≠ 8)
            节气判断 ＝ “小满”
        .判断 (月 ＝ 6 且 日 ＝ 取整 (年 × 0.2422 ＋ 5.678) － 取整 (年 ÷ 4))
            节气判断 ＝ “芒种”
        .判断 (月 ＝ 6 且 日 ＝ 取整 (年 × 0.2422 ＋ 21.37) － 取整 (年 ÷ 4))
            节气判断 ＝ “夏至”
        .判断 (月 ＝ 7 且 日 ＝ 取整 (年 × 0.2422 ＋ 7.108) － 取整 (年 ÷ 4) 且 年 ≠ 16)
            节气判断 ＝ “小暑”
        .判断 (月 ＝ 7 且 日 ＝ 取整 (年 × 0.2422 ＋ 22.83) － 取整 (年 ÷ 4))
            节气判断 ＝ “大暑”
        .判断 (月 ＝ 8 且 日 ＝ 取整 (年 × 0.2422 ＋ 7.5) － 取整 (年 ÷ 4) 且 年 ≠ 2)
            节气判断 ＝ “立秋”
        .判断 (月 ＝ 8 且 日 ＝ 取整 (年 × 0.2422 ＋ 23.13) － 取整 (年 ÷ 4))
            节气判断 ＝ “处暑”
        .判断 (月 ＝ 9 且 日 ＝ 取整 (年 × 0.2422 ＋ 7.646) － 取整 (年 ÷ 4))
            节气判断 ＝ “白露”
        .判断 (月 ＝ 9 且 日 ＝ 取整 (年 × 0.2422 ＋ 23.042) － 取整 (年 ÷ 4))
            节气判断 ＝ “秋分”
        .判断 (月 ＝ 10 且 日 ＝ 取整 (年 × 0.2422 ＋ 8.318) － 取整 (年 ÷ 4))
            节气判断 ＝ “寒露”
        .判断 (月 ＝ 10 且 日 ＝ 取整 (年 × 0.2422 ＋ 23.438) － 取整 (年 ÷ 4) 且 年 ≠ 89)
            节气判断 ＝ “霜降”
        .判断 (月 ＝ 11 且 日 ＝ 取整 (年 × 0.2422 ＋ 7.438) － 取整 (年 ÷ 4) 且 年 ≠ 89)
            节气判断 ＝ “立冬”
        .判断 (月 ＝ 11 且 日 ＝ 取整 (年 × 0.2422 ＋ 22.36) － 取整 (年 ÷ 4))
            节气判断 ＝ “小雪”
        .判断 (月 ＝ 12 且 日 ＝ 取整 (年 × 0.2422 ＋ 7.18) － 取整 (年 ÷ 4))
            节气判断 ＝ “大雪”
        .判断 (月 ＝ 12 且 日 ＝ 取整 (年 × 0.2422 ＋ 21.94) － 取整 (年 ÷ 4) 且 年 ≠ 21)
            节气判断 ＝ “冬至”
        .判断 (月 ＝ 1 且 日 ＝ 取整 (年 × 0.2422 ＋ 5.4055) － 取整 (年 ÷ 4) 且 年 ≠ 19)
            节气判断 ＝ “小寒”
        .判断 (月 ＝ 1 且 日 ＝ 取整 (年 × 0.2422 ＋ 20.12) － 取整 (年 ÷ 4) 且 年 ≠ 82)
            节气判断 ＝ “大寒”
        .默认
            
        .判断结束
        
    .判断 (年 ＞ 1900 且 年 ＜ 2000) ' 20世纪判断
        年 ＝ 年 － 1900
        .判断开始 (月 ＝ 2 且 日 ＝ 取整 (年 × 0.2422 ＋ 4.6295) － 取整 (年 ÷ 4))
            节气判断 ＝ “立春”
        .判断 (月 ＝ 2 且 日 ＝ 取整 (年 × 0.2422 ＋ 19.4599) － 取整 (年 ÷ 4))
            节气判断 ＝ “雨水”
        .判断 (月 ＝ 3 且 日 ＝ 取整 (年 × 0.2422 ＋ 6.3826) － 取整 (年 ÷ 4))
            节气判断 ＝ “惊蛰”
        .判断 (月 ＝ 3 且 日 ＝ 取整 (年 × 0.2422 ＋ 21.4155) － 取整 (年 ÷ 4))
            节气判断 ＝ “春分”
        .判断 (月 ＝ 4 且 日 ＝ 取整 (年 × 0.2422 ＋ 5.59) － 取整 (年 ÷ 4))
            节气判断 ＝ “清明”
        .判断 (月 ＝ 4 且 日 ＝ 取整 (年 × 0.2422 ＋ 20.888) － 取整 (年 ÷ 4))
            节气判断 ＝ “谷雨”
        .判断 (月 ＝ 5 且 日 ＝ 取整 (年 × 0.2422 ＋ 6.318) － 取整 (年 ÷ 4) 且 年 ≠ 11)
            节气判断 ＝ “立夏”
        .判断 (月 ＝ 5 且 日 ＝ 取整 (年 × 0.2422 ＋ 21.86) － 取整 (年 ÷ 4))
            节气判断 ＝ “小满”
        .判断 (月 ＝ 6 且 日 ＝ 取整 (年 × 0.2422 ＋ 6.5) － 取整 (年 ÷ 4) 且 年 ≠ 2)
            节气判断 ＝ “芒种”
        .判断 (月 ＝ 6 且 日 ＝ 取整 (年 × 0.2422 ＋ 22.2) － 取整 (年 ÷ 4) 且 年 ≠ 28)
            节气判断 ＝ “夏至”
        .判断 (月 ＝ 7 且 日 ＝ 取整 (年 × 0.2422 ＋ 7.928) － 取整 (年 ÷ 4) 且 年 ≠ 25)
            节气判断 ＝ “小暑”
        .判断 (月 ＝ 7 且 日 ＝ 取整 (年 × 0.2422 ＋ 23.65) － 取整 (年 ÷ 4) 且 年 ≠ 22)
            节气判断 ＝ “大暑”
        .判断 (月 ＝ 8 且 日 ＝ 取整 (年 × 0.2422 ＋ 7.5) － 取整 (年 ÷ 4))
            节气判断 ＝ “立秋”
        .判断 (月 ＝ 8 且 日 ＝ 取整 (年 × 0.2422 ＋ 23.95) － 取整 (年 ÷ 4))
            节气判断 ＝ “处暑”
        .判断 (月 ＝ 9 且 日 ＝ 取整 (年 × 0.2422 ＋ 8.44) － 取整 (年 ÷ 4) 且 年 ≠ 27)
            节气判断 ＝ “白露”
        .判断 (月 ＝ 9 且 日 ＝ 取整 (年 × 0.2422 ＋ 23.822) － 取整 (年 ÷ 4) 且 年 ≠ 42)
            节气判断 ＝ “秋分”
        .判断 (月 ＝ 10 且 日 ＝ 取整 (年 × 0.2422 ＋ 9.098) － 取整 (年 ÷ 4))
            节气判断 ＝ “寒露”
        .判断 (月 ＝ 10 且 日 ＝ 取整 (年 × 0.2422 ＋ 24.218) － 取整 (年 ÷ 4))
            节气判断 ＝ “霜降”
        .判断 (月 ＝ 11 且 日 ＝ 取整 (年 × 0.2422 ＋ 8.218) － 取整 (年 ÷ 4))
            节气判断 ＝ “立冬”
        .判断 (月 ＝ 11 且 日 ＝ 取整 (年 × 0.2422 ＋ 23.08) － 取整 (年 ÷ 4) 且 年 ≠ 78)
            节气判断 ＝ “小雪”
        .判断 (月 ＝ 12 且 日 ＝ 取整 (年 × 0.2422 ＋ 7.9) － 取整 (年 ÷ 4) 且 年 ≠ 54)
            节气判断 ＝ “大雪”
        .判断 (月 ＝ 12 且 日 ＝ 取整 (年 × 0.2422 ＋ 22.6) － 取整 (年 ÷ 4) 且 年 ≠ 18)
            节气判断 ＝ “冬至”
        .判断 (月 ＝ 1 且 日 ＝ 取整 (年 × 0.2422 ＋ 6.11) － 取整 (年 ÷ 4) 且 年 ≠ 82)
            节气判断 ＝ “小寒”
        .判断 (月 ＝ 1 且 日 ＝ 取整 (年 × 0.2422 ＋ 20.84) － 取整 (年 ÷ 4))
            节气判断 ＝ “大寒”
        .默认
            
        .判断结束
        
    .默认
        
    .判断结束
    返回 (节气判断)

.子程序 时间_星期几取日期, 日期时间型, 公开, 返回指定时间段里指定星期几的日期
    .参数 参_时间, 日期时间型, 可空, 留空默认取当前时间
    .参数 参_星期几, 整数型, , 1-7，分别代表星期一到星期日
    .局部变量 局_星期几, 整数型
    .局部变量 局_天差, 整数型
    .局部变量 局_返回日期, 日期时间型

    ' https://bbs.125.la/thread-14479245-1-1.html
    .如果真 (是否为空 (参_时间))
        参_时间 ＝ 取现行时间 ()
    .如果真结束
    局_星期几 ＝ 取星期几 (参_时间)
    .判断开始 (局_星期几 ＝ 1)
        局_星期几 ＝ 7
    .默认
        局_星期几 ＝ 局_星期几 － 1
    .判断结束
    局_天差 ＝ 局_星期几 － 参_星期几
    局_返回日期 ＝ 增减时间 (参_时间, #日, －局_天差)
    返回 (局_返回日期)

.子程序 时间_取间隔_开始, , 公开, 取微秒级时间间隔.[Mr.Yang提供]
    .参数 标记, 文本型, 可空, 用于区分不同的时间.与"时间_取间隔_结束"对应.
    .局部变量 Count, 长整数型
    .局部变量 a, 整数型
    .局部变量 i, 整数型

    ' https://bbs.125.la/thread-14545116-1-1.html
    标记 ＝ 选择 (标记 ＝ “”, “耗时”, 标记)
    .计次循环首 (取数组下标 (时间标记, 1), i)
        .如果真 (时间标记 [i] [1] ＝ 标记) ' 标记已存在
            a ＝ i
            跳出循环 ()
        .如果真结束
        
    .计次循环尾 ()
    .如果真 (a ＝ 0) ' 标记未创建
        重定义数组 (时间标记, 真, 取数组下标 (时间标记, 1) ＋ 1, 2) ' 创建标记
        a ＝ 取数组下标 (时间标记, 1)
        时间标记 [a] [1] ＝ 标记
    .如果真结束
    QueryPerformanceCounter (Count)
    时间标记 [a] [2] ＝ 到文本 (Count)

.子程序 时间_取间隔_结束, 文本型, 公开, 取微秒级时间间隔.返回间隔时间.[Mr.Yang提供]
    .参数 标记, 文本型, 可空, 用于区分不同的时间.与"时间_取间隔_开始"对应.
    .局部变量 Count, 长整数型
    .局部变量 a, 整数型
    .局部变量 i, 整数型
    .局部变量 频率, 长整数型
    .局部变量 间隔时间, 双精度小数型
    .局部变量 局_时, 整数型
    .局部变量 局_分, 整数型
    .局部变量 局_秒, 整数型
    .局部变量 局_毫秒, 双精度小数型
    .局部变量 返回文本, 文本型

    .如果真 (频率 ＝ 0) ' 获取HPET频率
        QueryPerformanceFrequency (Count)
        频率 ＝ Count
    .如果真结束
    QueryPerformanceCounter (Count)
    标记 ＝ 选择 (标记 ＝ “”, “耗时”, 标记)
    .计次循环首 (取数组下标 (时间标记, 1), i)
        .如果真 (时间标记 [i] [1] ＝ 标记) ' 标记已存在
            a ＝ i
            跳出循环 ()
        .如果真结束
        
    .计次循环尾 ()
    .如果真 (a ＝ 0)
        输出调试文本 (#引号 ＋ “时间_取间隔” ＋ #引号 ＋ “ 标记不存在!”)
        返回 (“”)
    .如果真结束
    间隔时间 ＝ (Count － 到数值 (时间标记 [a] [2])) ÷ 频率 × 1000
    局_时 ＝ 间隔时间 ％ 86400000 ÷ 3600000
    局_分 ＝ 间隔时间 ％ 86400000 ％ 3600000 ÷ 60000
    局_秒 ＝ 间隔时间 ％ 86400000 ％ 3600000 ％ 60000 ÷ 1000
    局_毫秒 ＝ 四舍五入 (间隔时间 ％ 86400000 ％ 3600000 ％ 60000 ％ 1000, 4)
    .如果真 (局_时 ≠ 0)
        返回文本 ＝ 返回文本 ＋ 到文本 (局_时) ＋ “时”
    .如果真结束
    .如果真 (局_分 ≠ 0)
        返回文本 ＝ 返回文本 ＋ 到文本 (局_分) ＋ “分”
    .如果真结束
    .如果真 (局_秒 ≠ 0)
        返回文本 ＝ 返回文本 ＋ 到文本 (局_秒) ＋ “秒”
    .如果真结束
    .如果真 (局_毫秒 ≠ 0)
        返回文本 ＝ 返回文本 ＋ 到文本 (局_毫秒) ＋ “毫秒”
    .如果真结束
    输出调试文本 (标记 ＋ “:” ＋ 返回文本)
    返回 (返回文本)

.子程序 FileTimeToVariantTime, 日期时间型, 公开
    .参数 FileTime, FILETIME
    .局部变量 LocalTime, FILETIME
    .局部变量 SystemTime, 精易_时间
    .局部变量 vTime, 日期时间型

    FileTimeToLocalFileTime (FileTime, LocalTime)
    FileTimeToSystemTime (LocalTime, SystemTime)
    SystemTimeToVariantTime (SystemTime, vTime)
    返回 (vTime)

.子程序 VariantTimeToFileTime, FILETIME, 公开
    .参数 vTime, 日期时间型
    .局部变量 SystemTime, 精易_时间
    .局部变量 LocalTime, FILETIME
    .局部变量 FileTime, FILETIME

    VariantTimeToSystemTime (vTime, SystemTime)
    SystemTimeToFileTime (SystemTime, LocalTime)
    LocalFileTimeToFileTime (LocalTime, FileTime)
    返回 (FileTime)

.子程序 VariantTimeToQuadPart, 长整数型, 公开, 时间 => 长整数
    .参数 vTime, 日期时间型
    .局部变量 FileTime, FILETIME

    FileTime ＝ VariantTimeToFileTime (vTime)
    返回 (合并长整数 (FileTime.dwLowDateTime, FileTime.dwHighDateTime))

.子程序 QuadPartToVariantTime, 日期时间型, 公开, 长整数 => 时间
    .参数 li, 长整数型
    .局部变量 FileTime, FILETIME

    FileTime.dwLowDateTime ＝ LOWPART (li)
    FileTime.dwHighDateTime ＝ HIGHPART (li)
    返回 (FileTimeToVariantTime (FileTime))

.子程序 时间_取NTP服务器时间戳, 长整数型, 公开, 通过NTP服务器获取网络时间！成功返回Unix时间戳，失败返回-1。
    .参数 NTP服务器, 文本型, 可空, time.windows.com
    .参数 精确到毫秒, 逻辑型, 可空
    .局部变量 NtpName, 文本型
    .局部变量 wsaData, 套接字信息
    .局部变量 hints, 整数型
    .局部变量 ai_list, 整数型
    .局部变量 ai_family, 整数型
    .局部变量 ai_socktype, 整数型
    .局部变量 ai_protocol, 整数型
    .局部变量 sock, 整数型
    .局部变量 ai_addrlen, 整数型
    .局部变量 ai_addr, 整数型
    .局部变量 dwBufLen, 整数型
    .局部变量 ntpBuf, 整数型
    .局部变量 iRes, 整数型
    .局部变量 readfds, 整数型
    .局部变量 timeout, 字节集
    .局部变量 nTimestampSeconds, 整数型
    .局部变量 nTimestampFractions, 整数型
    .局部变量 nlTime, 长整数型

    .如果 (是否为空 (NTP服务器))
        NtpName ＝ “time.windows.com”
    .否则
        NtpName ＝ NTP服务器
    .如果结束
    nlTime ＝ #INVALID_SOCKET
    .如果真 (WSAStartup (合并短整数 (1, 1), wsaData) ＝ #ERROR_SUCCESS)
        hints ＝ LocalAlloc (#LMEM_ZEROINIT, 32) ' sizeof(addrinfo)
        __set (hints, 4, #AF_UNSPEC)
        __set (hints, 8, #SOCK_DGRAM)
        __set (hints, 12, #IPPROTO_UDP)
        ' time.windows.com => 时间服务器
        ' 123 => 网络时间协议（NTP）
        .如果真 (getaddrinfo (NtpName, “123”, hints, 取指针整数_ (ai_list)) ＝ #ERROR_SUCCESS)
            ai_family ＝ __get (ai_list, 4)
            ai_socktype ＝ __get (ai_list, 8)
            ai_protocol ＝ __get (ai_list, 12)
            sock ＝ socket (ai_family, ai_socktype, ai_protocol)
            .如果真 (sock ≠ #INVALID_SOCKET)
                ai_addrlen ＝ __get (ai_list, 16)
                ai_addr ＝ __get (ai_list, 24)
                dwBufLen ＝ 48 ' sizeof(NTPPacket)
                ntpBuf ＝ LocalAlloc (#LMEM_ZEROINIT, dwBufLen)
                __set (ntpBuf, 0, 27)
                iRes ＝ sendto1 (sock, ntpBuf, dwBufLen, 0, ai_addr, ai_addrlen)
                .如果真 (iRes ＝ dwBufLen)
                    readfds ＝ LocalAlloc (#LMEM_ZEROINIT, 260) ' sizeof(fd_set)
                    __set (readfds, 0, 1)
                    __set (readfds, 4, sock)
                    timeout ＝ { 3, 0, 0, 0, 0, 0, 0, 0 } ' 3秒
                    iRes ＝ select1 (sock ＋ 1, readfds, #NULL, #NULL, 取指针_字节集型 (timeout))
                    .如果真 (iRes ＞ 0)
                        memset (ntpBuf, 0, dwBufLen)
                        iRes ＝ recvfrom1 (sock, ntpBuf, dwBufLen, 0, ai_addr, ai_addrlen)
                        .如果真 (iRes ＝ dwBufLen)
                            nTimestampSeconds ＝ __get (ntpBuf, 40)
                            nlTime ＝ 整数_有符号转无符号 (ntohl (nTimestampSeconds)) － 2208988800 ' 减去1970年1月1日到现在的秒数
                            .如果真 (精确到毫秒)
                                nTimestampFractions ＝ __get (ntpBuf, 44)
                                nlTime ＝ nlTime × 1000
                                nlTime ＝ nlTime ＋ 整数_有符号转无符号 (ntohl (nTimestampFractions)) × 2e-010 × 1000
                            .如果真结束
                            
                        .如果真结束
                        
                    .如果真结束
                    LocalFree (readfds)
                .如果真结束
                LocalFree (ntpBuf)
                closesocket (sock)
            .如果真结束
            freeaddrinfo (ai_list)
        .如果真结束
        LocalFree (hints)
        WSACleanup ()
    .如果真结束
    返回 (nlTime)

.子程序 时间_格式化毫秒, 文本型, 公开, 返回的时间值将始终采用hh小时mm分钟ss秒的形式。超过二十四小时的时间不会转换为天或月。几分之一秒被忽略。
    .参数 毫秒, 整数型
    .局部变量 iSize, 整数型
    .局部变量 pszTime, 整数型
    .局部变量 TimeStr, 文本型

    iSize ＝ StrFromTimeIntervalA (#NULL, 0, 毫秒, 10)
    iSize ＝ iSize ＋ 1
    pszTime ＝ LocalAlloc (#LMEM_ZEROINIT, iSize)
    StrFromTimeIntervalA (pszTime, iSize, 毫秒, 10)
    TimeStr ＝ 指针到文本 (pszTime)
    LocalFree (pszTime)
    返回 (TimeStr)

.子程序 DateTimeToVariantTime, 日期时间型, 公开, 20220628113010.454317+480 => 2022-06-28 11:30:10
    .参数 DateTime, 字节集
    .局部变量 pISWbemDateTime, 整数型
    .局部变量 pFileTime, 整数型
    .局部变量 li, 长整数型
    .局部变量 vTime, 日期时间型
    .局部变量 hr, 整数型

    CoInitialize (#NULL)
    hr ＝ CoCreateInstance1 (取指针_字节集型 (#CLSID_SWbemDateTime), #NULL, #CLSCTX_INPROC_SERVER, 取指针_字节集型 (#IID_ISWbemDateTime), pISWbemDateTime)
    .如果真 (hr ＝ #S_OK 且 pISWbemDateTime ≠ #NULL)
        hr ＝ CallObject (pISWbemDateTime, #ISWbemDateTime_put_Value, 取指针_字节集型 (DateTime), , , , , , , , )
        .如果真 (hr ＝ #S_OK)
            hr ＝ CallObject (pISWbemDateTime, #ISWbemDateTime_GetFileTime, #VARIANT_FALSE, 取指针整数_ (pFileTime), , , , , , , )
            .如果真 (hr ＝ #S_OK)
                li ＝ 到长整数 (编码_Unicode到Ansi (指针_到字节集W (pFileTime)))
                vTime ＝ QuadPartToVariantTime (li)
            .如果真结束
            
        .如果真结束
        SafeRelease (pISWbemDateTime)
    .如果真结束
    CoUninitialize ()
    返回 (vTime)

.子程序 LdapToVariantTime, 文本型, 公开, 130305048577611542 => 2013-12-03 08:40:57
    .参数 Ldap时间戳, 长整数型
    .局部变量 li, 长整数型
    .局部变量 vTime, 日期时间型

    li ＝ 到长整数 (VariantTimeToQuadPart ([1899年12月30日]) ＋ Ldap时间戳)
    vTime ＝ QuadPartToVariantTime (li)
    返回 (时间_到文本 (vTime, 1, , 2))

.子程序 VariantTimeToLdap, 文本型, 公开, 2013-12-03 08:40:57 => 130305048570000000
    .参数 vTime, 日期时间型, 可空
    .局部变量 SystemTime, 精易_时间
    .局部变量 FileTime, FILETIME
    .局部变量 li, 长整数型

    .如果 (是否为空 (vTime))
        GetSystemTime (SystemTime)
        SystemTimeToFileTime (SystemTime, FileTime)
        li ＝ 合并长整数 (FileTime.dwLowDateTime, FileTime.dwHighDateTime)
    .否则
        li ＝ VariantTimeToQuadPart (vTime)
    .如果结束
    li ＝ 到长整数 (li － VariantTimeToQuadPart ([1899年12月30日]))
    返回 (到文本 (li))

.版本 2

.程序集 集_编码进制转换
.程序集变量 集_AVX2, 逻辑型
.程序集变量 集_SSE2, 逻辑型

.子程序 BASE64编解码_ASM_初始化, , 公开
    ' 有BUG可以联系：lyjdgkg
    ' 1.1版更新
    ' 1)  整合 AVX2指令集版本进去，内部会判断CPU是否支持，CPU支持的话性能会比80386版再提升90%左右，前提是需要编码的数据足够长。
    
    ' 1.2更新
    ' 1)  修复 BASE64编码_ASM()  计算 申请长度 的mulx指令，在老CPU上出现异常问题（感谢 sometimes 的反馈）。
    
    集_AVX2 ＝ CPU_IsAVX2_ASM ()
    集_SSE2 ＝ CPU_IsSSE2_ASM ()
    

.子程序 BASE64编码_ASM, 文本型, 公开, 调用前务必调用 BASE64编解码_ASM_初始化   自动选择版本：AVX2、80386
    .参数 参_字节集, 字节集
    .局部变量 局_长度, 整数型, , , 0x4
    .局部变量 局_AVX2, 逻辑型, , , 0x8
    .局部变量 局_申请长度, 整数型, , , 0xC

    置入代码 ({ 139, 69, 8, 139, 0, 133, 192, 116, 7, 139, 64, 4, 62, 137, 69, 252 }) ' 局_长度 ＝ 取字节集长度 (参_字节集)
    .如果真 (局_长度 ＞ 0)
        局_AVX2 ＝ 集_AVX2
        置入代码 ({ 139, 77, 252, 184, 171, 170, 170, 170, 141, 73, 2, 247, 225, 209, 234, 141, 4, 149, 1, 0, 0, 0, 137, 69, 244 }) ' 局_申请长度 = (局_长度 + 2) / 3 * 4 + 1
        内存_申请内存 (局_申请长度)
        ' 由VS2017+ICC编译后反汇编修整，字节集可转换为16进制，然后在x64dbg内找个地，CTRL+SHIFT+V 粘贴进去即可查看汇编代码。
        置入代码 ({ 137, 69, 244, 139, 85, 252, 139, 77, 8, 139, 9, 131, 193, 8, 255, 117, 248, 81, 80, 232, 7, 0, 0, 0, 139, 69, 244, 201, 194, 4, 0, 232, 215, 1, 0, 0, 86, 87, 83, 131, 236, 20, 139, 242, 139, 68, 36, 36, 139, 217, 139, 124, 36, 40, 137, 68, 36, 4, 128, 124, 36, 44, 0, 116, 9, 131, 254, 28, 15, 131, 28, 1, 0, 0, 131, 254, 2, 15, 134, 136, 0, 0, 0, 139, 206, 51, 210, 131, 193, 254, 15, 132, 125, 0, 0, 0, 137, 52, 36, 137, 76, 36, 8, 137, 124, 36, 12, 139, 116, 36, 12, 15, 182, 12, 50, 15, 182, 124, 50, 1, 15, 182, 116, 50, 2, 131, 194, 3, 137, 84, 36, 16, 15, 182, 20, 25, 131, 225, 3, 136, 16, 139, 215, 193, 225, 4, 131, 231, 15, 193, 234, 4, 11, 202, 193, 231, 2, 15, 182, 140, 25, 0, 1, 0, 0, 136, 72, 1, 139, 206, 193, 233, 6, 11, 249, 15, 182, 148, 31, 0, 1, 0, 0, 136, 80, 2, 15, 182, 140, 30, 0, 1, 0, 0, 139, 84, 36, 16, 136, 72, 3, 131, 192, 4, 59, 84, 36, 8, 114, 153, 139, 52, 36, 139, 124, 36, 12, 235, 2, 51, 210, 43, 242, 116, 104, 15, 182, 12, 58, 131, 254, 1, 117, 39, 15, 182, 20, 25, 131, 225, 3, 193, 225, 4, 136, 16, 15, 182, 140, 25, 0, 1, 0, 0, 187, 61, 0, 0, 0, 136, 72, 1, 136, 88, 2, 136, 88, 3, 131, 192, 4, 235, 56, 15, 182, 116, 58, 1, 139, 254, 15, 182, 20, 25, 131, 225, 3, 193, 225, 4, 131, 230, 15, 193, 239, 4, 11, 207, 136, 16, 15, 182, 140, 25, 0, 1, 0, 0, 136, 72, 1, 15, 182, 156, 179, 0, 1, 0, 0, 136, 88, 2, 198, 64, 3, 61, 131, 192, 4, 139, 84, 36, 4, 198, 0, 0, 43, 194, 43, 84, 36, 36, 3, 208, 133, 192, 15, 69, 194, 131, 196, 20, 91, 95, 94, 194, 12, 0, 197, 254, 111, 131, 0, 2, 0, 0, 197, 254, 111, 179, 32, 2, 0, 0, 197, 254, 111, 171, 64, 2, 0, 0, 197, 254, 111, 163, 96, 2, 0, 0, 197, 254, 111, 147, 128, 2, 0, 0, 197, 254, 111, 155, 160, 2, 0, 0, 196, 226, 125, 140, 71, 252, 235, 5, 197, 254, 111, 71, 252, 196, 226, 125, 0, 131, 192, 2, 0, 0, 131, 198, 232, 197, 253, 219, 187, 224, 2, 0, 0, 131, 199, 24, 197, 197, 228, 206, 197, 253, 219, 253, 197, 197, 213, 131, 0, 3, 0, 0, 197, 245, 235, 192, 197, 253, 216, 202, 197, 253, 100, 251, 197, 245, 248, 207, 196, 226, 93, 0, 201, 197, 253, 252, 193, 197, 254, 127, 0, 131, 192, 32, 131, 254, 32, 115, 175, 137, 68, 36, 4, 197, 248, 119, 233, 79, 254, 255, 255, 232, 0, 0, 0, 0, 89, 131, 193, 5, 195 })
        ' 码表（空间换时间）
        ' *** 缩略程序块 ***
        置入代码 ({ 65, 65, 65, 65, 66, 66, 66, 66, 67, 67, 67, 67, 68, 68, 68, 68, 69, 69, 69, 69, 70, 70, 70, 70, 71, 71, 71, 71, 72, 72, 72, 72, 73, 73, 73, 73, 74, 74, 74, 74, 75, 75, 75, 75, 76, 76, 76, 76, 77, 77, 77, 77, 78, 78, 78, 78, 79, 79, 79, 79, 80, 80, 80, 80, 81, 81, 81, 81, 82, 82, 82, 82, 83, 83, 83, 83, 84, 84, 84, 84, 85, 85, 85, 85, 86, 86, 86, 86, 87, 87, 87, 87, 88, 88, 88, 88, 89, 89, 89, 89, 90, 90, 90, 90, 97, 97, 97, 97, 98, 98, 98, 98, 99, 99, 99, 99, 100, 100, 100, 100, 101, 101, 101, 101, 102, 102, 102, 102, 103, 103, 103, 103, 104, 104, 104, 104, 105, 105, 105, 105, 106, 106, 106, 106, 107, 107, 107, 107, 108, 108, 108, 108, 109, 109, 109, 109, 110, 110, 110, 110, 111, 111, 111, 111, 112, 112, 112, 112, 113, 113, 113, 113, 114, 114, 114, 114, 115, 115, 115, 115, 116, 116, 116, 116, 117, 117, 117, 117, 118, 118, 118, 118, 119, 119, 119, 119, 120, 120, 120, 120, 121, 121, 121, 121, 122, 122, 122, 122, 48, 48, 48, 48, 49, 49, 49, 49, 50, 50, 50, 50, 51, 51, 51, 51, 52, 52, 52, 52, 53, 53, 53, 53, 54, 54, 54, 54, 55, 55, 55, 55, 56, 56, 56, 56, 57, 57, 57, 57, 43, 43, 43, 43, 47, 47, 47, 47, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 43, 47, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 43, 47, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 43, 47, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 43, 47 })
        ' AVX2码表
        ' *** 缩略程序块 ***
        置入代码 ({ 0, 0, 0, 0, 0, 0, 0, 128, 0, 0, 0, 128, 0, 0, 0, 128, 0, 0, 0, 128, 0, 0, 0, 128, 0, 0, 0, 128, 0, 0, 0, 128, 64, 0, 0, 4, 64, 0, 0, 4, 64, 0, 0, 4, 64, 0, 0, 4, 64, 0, 0, 4, 64, 0, 0, 4, 64, 0, 0, 4, 64, 0, 0, 4, 240, 3, 63, 0, 240, 3, 63, 0, 240, 3, 63, 0, 240, 3, 63, 0, 240, 3, 63, 0, 240, 3, 63, 0, 240, 3, 63, 0, 240, 3, 63, 0, 65, 71, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 237, 240, 0, 0, 65, 71, 252, 252, 252, 252, 252, 252, 252, 252, 252, 252, 237, 240, 0, 0, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 5, 4, 6, 5, 8, 7, 9, 8, 11, 10, 12, 11, 14, 13, 15, 14, 1, 0, 2, 1, 4, 3, 5, 4, 7, 6, 8, 7, 10, 9, 11, 10, 0, 252, 192, 15, 0, 252, 192, 15, 0, 252, 192, 15, 0, 252, 192, 15, 0, 252, 192, 15, 0, 252, 192, 15, 0, 252, 192, 15, 0, 252, 192, 15, 16, 0, 0, 1, 16, 0, 0, 1, 16, 0, 0, 1, 16, 0, 0, 1, 16, 0, 0, 1, 16, 0, 0, 1, 16, 0, 0, 1, 16, 0, 0, 1 })
    .如果真结束
    返回 (“”)

.子程序 BASE64解码_ASM, 字节集, 公开, 调用前务必调用 BASE64编解码_ASM_初始化   自动选择版本：AVX2、80386
    .参数 参_文本, 文本型
    .局部变量 局_长度, 整数型, , , 0x4
    .局部变量 局_AVX2, 逻辑型, , , 0x8
    .局部变量 局_申请长度, 整数型, , , 0xC

    局_长度 ＝ 取文本长度_ASM (参_文本)
    .如果真 (局_长度 ＞ 0)
        局_AVX2 ＝ 集_AVX2
        置入代码 ({ 139, 77, 252, 193, 233, 2, 141, 68, 73, 10, 62, 137, 69, 244 }) ' 局_申请长度 = 局_长度 / 4 * 3 + 10
        内存_申请内存 (局_申请长度)
        ' 由VS2017+ICC编译后反汇编修整，字节集可转换为16进制，然后在x64dbg内找个地，CTRL+SHIFT+V 粘贴进去即可查看汇编代码。
        置入代码 ({ 137, 69, 244, 199, 0, 1, 0, 0, 0, 131, 192, 8, 139, 77, 252, 139, 85, 8, 139, 18, 255, 117, 248, 82, 80, 232, 12, 0, 0, 0, 139, 77, 244, 137, 65, 4, 139, 193, 201, 194, 4, 0, 232, 70, 2, 0, 0, 86, 87, 83, 131, 236, 12, 139, 242, 139, 68, 36, 28, 139, 249, 139, 92, 36, 32, 128, 124, 36, 36, 0, 15, 132, 152, 0, 0, 0, 131, 255, 45, 15, 130, 143, 0, 0, 0, 197, 254, 111, 170, 0, 16, 0, 0, 197, 254, 111, 162, 32, 16, 0, 0, 197, 254, 111, 154, 64, 16, 0, 0, 197, 254, 111, 146, 96, 16, 0, 0, 197, 254, 111, 11, 197, 253, 114, 209, 4, 197, 245, 219, 245, 197, 253, 219, 197, 196, 226, 93, 0, 254, 196, 226, 101, 0, 240, 196, 226, 125, 23, 254, 117, 74, 197, 245, 116, 245, 131, 199, 224, 197, 205, 252, 192, 131, 195, 32, 197, 254, 111, 178, 128, 16, 0, 0, 196, 226, 109, 0, 248, 197, 245, 252, 207, 196, 226, 117, 4, 130, 160, 16, 0, 0, 197, 253, 245, 138, 192, 16, 0, 0, 196, 226, 117, 0, 186, 224, 16, 0, 0, 196, 226, 77, 54, 199, 197, 254, 127, 0, 131, 192, 24, 131, 255, 45, 115, 148, 197, 248, 119, 133, 255, 15, 132, 126, 1, 0, 0, 131, 255, 4, 15, 130, 117, 1, 0, 0, 247, 199, 3, 0, 0, 0, 15, 133, 105, 1, 0, 0, 128, 124, 59, 255, 61, 117, 14, 141, 87, 255, 131, 199, 254, 128, 124, 26, 255, 61, 15, 69, 250, 139, 207, 193, 233, 2, 131, 231, 3, 141, 81, 255, 15, 68, 202, 137, 76, 36, 8, 133, 201, 139, 200, 118, 98, 51, 210, 137, 124, 36, 4, 139, 250, 137, 4, 36, 15, 182, 3, 139, 20, 134, 15, 182, 67, 1, 11, 148, 134, 0, 4, 0, 0, 15, 182, 67, 2, 11, 148, 134, 0, 8, 0, 0, 15, 182, 67, 3, 11, 148, 134, 0, 12, 0, 0, 129, 250, 255, 255, 255, 1, 15, 131, 254, 0, 0, 0, 139, 194, 71, 131, 195, 4, 136, 17, 193, 232, 8, 193, 234, 16, 136, 65, 1, 136, 81, 2, 131, 193, 3, 59, 124, 36, 8, 114, 176, 139, 124, 36, 4, 139, 4, 36, 133, 255, 116, 122, 131, 255, 1, 117, 13, 15, 182, 19, 139, 28, 150, 137, 28, 36, 136, 25, 235, 76, 131, 255, 2, 117, 24, 15, 182, 19, 15, 182, 91, 1, 139, 20, 150, 11, 148, 158, 0, 4, 0, 0, 137, 20, 36, 136, 17, 235, 47, 137, 124, 36, 4, 15, 182, 59, 139, 20, 190, 15, 182, 123, 1, 15, 182, 91, 2, 11, 148, 190, 0, 4, 0, 0, 11, 148, 158, 0, 8, 0, 0, 137, 20, 36, 136, 17, 193, 234, 8, 136, 81, 1, 139, 124, 36, 4, 129, 60, 36, 255, 255, 255, 1, 115, 111, 139, 84, 36, 8, 141, 52, 127, 3, 246, 193, 238, 3, 141, 12, 82, 3, 241, 235, 73, 15, 182, 59, 139, 20, 190, 15, 182, 123, 1, 11, 148, 190, 0, 4, 0, 0, 15, 182, 123, 2, 15, 182, 91, 3, 11, 148, 190, 0, 8, 0, 0, 11, 148, 158, 0, 12, 0, 0, 129, 250, 255, 255, 255, 1, 115, 45, 139, 116, 36, 8, 139, 218, 139, 211, 136, 25, 141, 116, 118, 3, 193, 234, 8, 193, 235, 16, 136, 81, 1, 136, 89, 2, 133, 246, 116, 15, 43, 68, 36, 28, 3, 198, 131, 196, 12, 91, 95, 94, 194, 12, 0, 51, 192, 131, 196, 12, 91, 95, 94, 194, 12, 0, 232, 0, 0, 0, 0, 90, 131, 194, 5, 195 })
        ' 码表，有点大（空间换时间）
        ' *** 缩略程序块 ***
        置入代码 ({ 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 248, 0, 0, 0, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 252, 0, 0, 0, 208, 0, 0, 0, 212, 0, 0, 0, 216, 0, 0, 0, 220, 0, 0, 0, 224, 0, 0, 0, 228, 0, 0, 0, 232, 0, 0, 0, 236, 0, 0, 0, 240, 0, 0, 0, 244, 0, 0, 0, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 0, 0, 0, 0, 4, 0, 0, 0, 8, 0, 0, 0, 12, 0, 0, 0, 16, 0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 28, 0, 0, 0, 32, 0, 0, 0, 36, 0, 0, 0, 40, 0, 0, 0, 44, 0, 0, 0, 48, 0, 0, 0, 52, 0, 0, 0, 56, 0, 0, 0, 60, 0, 0, 0, 64, 0, 0, 0, 68, 0, 0, 0, 72, 0, 0, 0, 76, 0, 0, 0, 80, 0, 0, 0, 84, 0, 0, 0, 88, 0, 0, 0, 92, 0, 0, 0, 96, 0, 0, 0, 100, 0, 0, 0, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 104, 0, 0, 0, 108, 0, 0, 0, 112, 0, 0, 0, 116, 0, 0, 0, 120, 0, 0, 0, 124, 0, 0, 0, 128, 0, 0, 0, 132, 0, 0, 0, 136, 0, 0, 0, 140, 0, 0, 0, 144, 0, 0, 0, 148, 0, 0, 0, 152, 0, 0, 0, 156, 0, 0, 0, 160, 0, 0, 0, 164, 0, 0, 0, 168, 0, 0, 0, 172, 0, 0, 0, 176, 0, 0, 0, 180, 0, 0, 0, 184, 0, 0, 0, 188, 0, 0, 0, 192, 0, 0, 0, 196, 0, 0, 0, 200, 0, 0, 0, 204, 0, 0, 0, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 3, 224, 0, 0, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 3, 240, 0, 0, 3, 64, 0, 0, 3, 80, 0, 0, 3, 96, 0, 0, 3, 112, 0, 0, 3, 128, 0, 0, 3, 144, 0, 0, 3, 160, 0, 0, 3, 176, 0, 0, 3, 192, 0, 0, 3, 208, 0, 0, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 0, 0, 0, 0, 0, 16, 0, 0, 0, 32, 0, 0, 0, 48, 0, 0, 0, 64, 0, 0, 0, 80, 0, 0, 0, 96, 0, 0, 0, 112, 0, 0, 0, 128, 0, 0, 0, 144, 0, 0, 0, 160, 0, 0, 0, 176, 0, 0, 0, 192, 0, 0, 0, 208, 0, 0, 0, 224, 0, 0, 0, 240, 0, 0, 1, 0, 0, 0, 1, 16, 0, 0, 1, 32, 0, 0, 1, 48, 0, 0, 1, 64, 0, 0, 1, 80, 0, 0, 1, 96, 0, 0, 1, 112, 0, 0, 1, 128, 0, 0, 1, 144, 0, 0, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 1, 160, 0, 0, 1, 176, 0, 0, 1, 192, 0, 0, 1, 208, 0, 0, 1, 224, 0, 0, 1, 240, 0, 0, 2, 0, 0, 0, 2, 16, 0, 0, 2, 32, 0, 0, 2, 48, 0, 0, 2, 64, 0, 0, 2, 80, 0, 0, 2, 96, 0, 0, 2, 112, 0, 0, 2, 128, 0, 0, 2, 144, 0, 0, 2, 160, 0, 0, 2, 176, 0, 0, 2, 192, 0, 0, 2, 208, 0, 0, 2, 224, 0, 0, 2, 240, 0, 0, 3, 0, 0, 0, 3, 16, 0, 0, 3, 32, 0, 0, 3, 48, 0, 0, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 0, 15, 128, 0, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 0, 15, 192, 0, 0, 13, 0, 0, 0, 13, 64, 0, 0, 13, 128, 0, 0, 13, 192, 0, 0, 14, 0, 0, 0, 14, 64, 0, 0, 14, 128, 0, 0, 14, 192, 0, 0, 15, 0, 0, 0, 15, 64, 0, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 128, 0, 0, 0, 192, 0, 0, 1, 0, 0, 0, 1, 64, 0, 0, 1, 128, 0, 0, 1, 192, 0, 0, 2, 0, 0, 0, 2, 64, 0, 0, 2, 128, 0, 0, 2, 192, 0, 0, 3, 0, 0, 0, 3, 64, 0, 0, 3, 128, 0, 0, 3, 192, 0, 0, 4, 0, 0, 0, 4, 64, 0, 0, 4, 128, 0, 0, 4, 192, 0, 0, 5, 0, 0, 0, 5, 64, 0, 0, 5, 128, 0, 0, 5, 192, 0, 0, 6, 0, 0, 0, 6, 64, 0, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 0, 6, 128, 0, 0, 6, 192, 0, 0, 7, 0, 0, 0, 7, 64, 0, 0, 7, 128, 0, 0, 7, 192, 0, 0, 8, 0, 0, 0, 8, 64, 0, 0, 8, 128, 0, 0, 8, 192, 0, 0, 9, 0, 0, 0, 9, 64, 0, 0, 9, 128, 0, 0, 9, 192, 0, 0, 10, 0, 0, 0, 10, 64, 0, 0, 10, 128, 0, 0, 10, 192, 0, 0, 11, 0, 0, 0, 11, 64, 0, 0, 11, 128, 0, 0, 11, 192, 0, 0, 12, 0, 0, 0, 12, 64, 0, 0, 12, 128, 0, 0, 12, 192, 0, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 0, 0, 62, 0, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 0, 0, 63, 0, 0, 0, 52, 0, 0, 0, 53, 0, 0, 0, 54, 0, 0, 0, 55, 0, 0, 0, 56, 0, 0, 0, 57, 0, 0, 0, 58, 0, 0, 0, 59, 0, 0, 0, 60, 0, 0, 0, 61, 0, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 3, 0, 0, 0, 4, 0, 0, 0, 5, 0, 0, 0, 6, 0, 0, 0, 7, 0, 0, 0, 8, 0, 0, 0, 9, 0, 0, 0, 10, 0, 0, 0, 11, 0, 0, 0, 12, 0, 0, 0, 13, 0, 0, 0, 14, 0, 0, 0, 15, 0, 0, 0, 16, 0, 0, 0, 17, 0, 0, 0, 18, 0, 0, 0, 19, 0, 0, 0, 20, 0, 0, 0, 21, 0, 0, 0, 22, 0, 0, 0, 23, 0, 0, 0, 24, 0, 0, 0, 25, 0, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 0, 0, 26, 0, 0, 0, 27, 0, 0, 0, 28, 0, 0, 0, 29, 0, 0, 0, 30, 0, 0, 0, 31, 0, 0, 0, 32, 0, 0, 0, 33, 0, 0, 0, 34, 0, 0, 0, 35, 0, 0, 0, 36, 0, 0, 0, 37, 0, 0, 0, 38, 0, 0, 0, 39, 0, 0, 0, 40, 0, 0, 0, 41, 0, 0, 0, 42, 0, 0, 0, 43, 0, 0, 0, 44, 0, 0, 0, 45, 0, 0, 0, 46, 0, 0, 0, 47, 0, 0, 0, 48, 0, 0, 0, 49, 0, 0, 0, 50, 0, 0, 0, 51, 0, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1, 255, 255, 255, 1 })
        ' AVX2码表
        ' *** 缩略程序块 ***
        置入代码 ({ 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 21, 17, 17, 17, 17, 17, 17, 17, 17, 17, 19, 26, 27, 27, 27, 26, 21, 17, 17, 17, 17, 17, 17, 17, 17, 17, 19, 26, 27, 27, 27, 26, 16, 16, 1, 2, 4, 8, 4, 8, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 1, 2, 4, 8, 4, 8, 16, 16, 16, 16, 16, 16, 16, 16, 0, 16, 19, 4, 191, 191, 185, 185, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 19, 4, 191, 191, 185, 185, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 4, 0, 0, 0, 5, 0, 0, 0, 6, 0, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 0, 16, 1, 0, 0, 16, 1, 0, 0, 16, 1, 0, 0, 16, 1, 0, 0, 16, 1, 0, 0, 16, 1, 0, 0, 16, 1, 0, 0, 16, 1, 0, 2, 1, 0, 6, 5, 4, 10, 9, 8, 14, 13, 12, 255, 255, 255, 255, 2, 1, 0, 6, 5, 4, 10, 9, 8, 14, 13, 12, 255, 255, 255, 255 })
    .如果真结束
    返回 ({ })

.子程序 取文本长度_ASM, 整数型, 公开, 调用前务必调用 BASE64编解码_ASM_初始化    取文本型数据的长度，不包含结束0。自动选择版本：AVX2、SSE2、80386
    .参数 参_文本, 通用型, 参考, 文本变量或文本指针

    .判断开始 (集_AVX2)
        ' AVX2对齐版
        置入代码 ({ 139, 69, 8, 139, 0, 133, 192, 116, 51, 139, 232, 139, 200, 197, 253, 87, 192, 131, 225, 31, 131, 224, 224, 197, 253, 116, 8, 197, 253, 215, 209, 211, 234, 211, 226, 15, 188, 210, 117, 16, 131, 192, 32, 197, 253, 116, 8, 197, 253, 215, 209, 15, 188, 210, 116, 240, 43, 197, 1, 208, 93, 194, 4, 0 })
        ' *** 缩略程序块 ***
        ' mov eax,dword ptr ss:[ebp+0x8]
        ' mov eax,dword ptr ds:[eax]
        ' test eax,eax
        ' je end_1
        ' mov ebp,eax
        ' mov ecx,eax
        ' vxorpd ymm0,ymm0,ymm0
        ' and ecx,0x1F
        ' and eax,0xFFFFFFE0
        ' vpcmpeqb ymm1,ymm0,yword ptr ds:[eax]
        ' vpmovmskb edx,ymm1
        ' shr edx,cl
        ' shl edx,cl
        ' bsf edx,edx
        ' jne end_0
        ' loop_1:
        ' add eax,0x20
        ' vpcmpeqb ymm1,ymm0,yword ptr ds:[eax]
        ' vpmovmskb edx,ymm1
        ' bsf edx,edx
        ' je loop_1
        ' end_0:
        ' sub eax,ebp
        ' add eax,edx
        ' end_1:
        ' pop ebp
        ' ret 0x4
        
    .判断 (集_SSE2)
        ' SSE2对齐版
        置入代码 ({ 139, 69, 8, 139, 0, 133, 192, 116, 59, 137, 197, 137, 193, 102, 15, 239, 192, 131, 225, 15, 131, 224, 240, 102, 15, 111, 8, 102, 15, 116, 200, 102, 15, 215, 209, 211, 234, 211, 226, 15, 188, 210, 117, 20, 131, 192, 16, 102, 15, 111, 8, 102, 15, 116, 200, 102, 15, 215, 209, 15, 188, 210, 116, 236, 41, 232, 1, 208, 93, 194, 4, 0 })
        ' *** 缩略程序块 ***
        ' mov eax,dword ptr ss:[ebp+0x8]
        ' mov eax,dword ptr ds:[eax]
        ' test eax,eax
        ' je end_
        
        ' mov ebp,eax
        ' mov ecx,eax
        ' pxor xmm0,xmm0
        ' and ecx,0xF
        ' and eax,0xFFFFFFF0
        ' movdqa xmm1,xmmword ptr ds:[eax]
        ' pcmpeqb xmm1,xmm0
        ' pmovmskb edx,xmm1
        ' shr edx,cl
        ' shl edx,cl
        ' bsf edx,edx
        ' jne Label_a
        
        ' Label_b:
        ' add eax,0x10
        ' movdqa xmm1,xmmword ptr ds:[eax]
        ' pcmpeqb xmm1,xmm0
        ' pmovmskb edx,xmm1
        ' bsf edx,edx
        ' je Label_b
        
        ' Label_a:
        ' sub eax,ebp
        ' add eax,edx
        
        ' end_:
        ' pop ebp
        ' ret 0x4
        
    .默认
        ' 80386版
        置入代码 ({ 139, 69, 8, 139, 0, 133, 192, 116, 46, 87, 141, 80, 3, 139, 56, 131, 192, 4, 141, 143, 255, 254, 254, 254, 247, 215, 35, 207, 129, 225, 128, 128, 128, 128, 116, 233, 247, 193, 128, 128, 0, 0, 117, 6, 193, 233, 16, 131, 192, 2, 208, 225, 27, 194, 95, 201, 194, 4, 0 })
        ' *** 缩略程序块 ***
        ' mov eax,dword ptr [ebp+0x8]
        ' mov eax,dword ptr [eax]
        ' test eax,eax
        ' jz exit
        ' push edi
        ' lea edx,dword ptr [eax+0x3]
        
        ' label_b:
        ' mov edi,dword ptr [eax]
        ' add eax,4
        ' lea ecx,dword ptr [edi-0x01010101]
        ' not edi
        ' and ecx,edi
        ' and ecx,0x80808080
        ' jz label_b
        
        ' test ecx,0x8080
        ' jnz label_f
        ' shr ecx,16
        ' add eax,2
        
        ' label_f:
        ' shl cl,1
        ' sbb eax,edx
        ' pop edi
        ' exit:
        ' leave
        ' ret 0x4
    .判断结束
    返回 (0)

.子程序 CPU_IsAVX2_ASM, 逻辑型, , 判断CPU是否支持AVX2指令集
    置入代码 ({ 83, 184, 1, 0, 0, 0, 15, 162, 129, 225, 0, 0, 0, 24, 129, 249, 0, 0, 0, 24, 117, 43, 184, 7, 0, 0, 0, 185, 0, 0, 0, 0, 15, 162, 131, 227, 32, 131, 251, 32, 117, 23, 185, 0, 0, 0, 0, 15, 1, 208, 131, 224, 6, 131, 248, 6, 117, 7, 184, 1, 0, 0, 0, 235, 2, 51, 192, 91, 201, 195 })
    ' *** 缩略程序块 ***
    ' push ebx
    ' mov eax,0x1
    ' cpuid
    ' and ecx,0x18000000
    ' cmp ecx,0x18000000  //检查两个OXFAX和AVX特征标志
    ' jne NOT_SUPPORTED
    ' //处理器支持AVX指令，xgetbv已启用
    ' mov eax,0x7
    ' mov ecx,0x0
    ' cpuid
    ' and ebx,0x20
    ' cmp ebx,0x20  //检查AVX2特征标志
    ' jne NOT_SUPPORTED
    ' mov ecx,0x0
    ' xgetbv
    ' and eax,0x6
    ' cmp eax,0x6   //检查是否启用XMM和YMM状态支持
    ' jne NOT_SUPPORTED
    ' mov eax,0x1
    ' jmp done
    ' NOT_SUPPORTED:
    ' xor eax,eax
    ' done:
    ' pop ebx
    ' leave
    ' ret
    返回 (假)

.子程序 CPU_IsSSE2_ASM, 逻辑型, , 判断CPU是否支持SEE2指令集
    置入代码 ({ 83, 184, 1, 0, 0, 0, 15, 162, 129, 226, 0, 0, 0, 4, 139, 194, 91, 201, 195 })
    ' *** 缩略程序块 ***
    ' push ebx
    ' mov eax,0x1
    ' cpuid
    ' and edx,0x4000000  //检查EDX二进制值的第27位，是否为1，为1表示支持SSE2
    ' mov eax,edx
    ' pop ebx
    ' leave
    ' ret
    
    ' EDX二进制位信息：
    ' *** 缩略程序块 ***
    ' 1左移0 =FPU
    ' 1左移1 =VME
    ' 1左移2 =DE
    ' 1左移3 =PSE
    ' 1左移4 =TSC
    ' 1左移5 =MSR
    ' 1左移6 =PAE
    ' 1左移7 =MCE
    ' 1左移8 =CMPXCHG8B
    ' 1左移9 =APIC
    ' 1左移11=SYSENTER/SYSEXIT
    ' 1左移12=MTRR
    ' 1左移13=PGE
    ' 1左移14=MCA
    ' 1左移15=CMOV
    ' 1左移16=PAT
    ' 1左移17=PSE36
    ' 1左移18=PNS
    ' 1左移19=CLFSH
    ' 1左移21=DebugStore
    ' 1左移22=ACPI
    ' 1左移23=MMX
    ' 1左移24=FXSR
    ' 1左移25=SSE
    ' 1左移26=SSE2
    ' 1左移27=Selfsnoop
    ' 1左移28=HTT
    ' 1左移29=TM
    ' 1左移31=PBE
    返回 (假)

.子程序 编码_URL编码_快速, 文本型, 公开, 与PHP的 urlencode() 函数功能相同
    .参数 数据, 字节集, , 绝对不能是空字节集
    .参数 大写, 逻辑型, 可空
    .局部变量 文本长度, 整数型
    .局部变量 返回值, 文本型

    文本长度 ＝ 0
    置入代码 ({ 80, 139, 69, 8, 139, 0, 139, 64, 4, 107, 192, 3, 137, 69, 252, 88 })
    ' push eax
    ' mov eax,[ebp+8]
    ' mov eax,[eax]
    ' mov eax,[eax+4]
    ' imul eax,3
    ' mov [ebp-4],eax
    ' pop eax
    返回值 ＝ 取空白文本 (文本长度)
    置入代码 ({ 235, 31, 128, 227, 15, 128, 251, 0, 114, 10, 128, 251, 9, 119, 5, 128, 195, 48, 235, 12, 10, 246, 116, 5, 128, 195, 55, 235, 3, 128, 195, 87, 195, 80, 83, 81, 82, 86, 87, 139, 117, 8, 138, 117, 12, 128, 230, 1, 139, 54, 139, 126, 4, 131, 198, 8, 51, 201, 139, 69, 248, 235, 117, 138, 28, 49, 50, 255, 128, 251, 32, 116, 15, 128, 251, 45, 116, 10, 128, 251, 46, 116, 5, 128, 251, 95, 117, 2, 235, 38, 128, 251, 48, 114, 7, 128, 251, 57, 119, 2, 235, 26, 128, 251, 65, 114, 7, 128, 251, 90, 119, 2, 235, 14, 128, 251, 97, 114, 7, 128, 251, 122, 119, 2, 235, 2, 183, 1, 10, 255, 116, 34, 178, 37, 136, 16, 138, 211, 138, 218, 192, 235, 4, 232, 110, 255, 255, 255, 136, 88, 1, 138, 218, 232, 100, 255, 255, 255, 136, 88, 2, 131, 192, 3, 235, 13, 138, 20, 49, 128, 250, 32, 117, 2, 178, 43, 136, 16, 64, 65, 59, 207, 114, 135, 50, 219, 136, 24, 95, 94, 90, 89, 91, 88 })
    ' jmp MAIN
    ' DEC2HEX:
    ' AND BL,0FH
    ' .if BL >=0 && BL <=9
    ' ADD BL,30H
    ' .else
    ' .if DH
    ' ADD BL,37H
    ' .elseif
    ' ADD BL,57H
    ' .endif
    ' .endif
    ' ret
    ' MAIN:
    ' push eax
    ' push ebx
    ' push ecx
    ' push edx
    ' push esi
    ' push edi
    ' mov esi,[ebp+8]
    ' mov dh,[ebp+12]
    ' and dh,1
    ' mov esi,[esi]
    ' mov edi,[esi+4]
    ' add esi,8
    ' xor ecx,ecx
    ' mov eax,[ebp-8]
    ' .while ecx < edi
    ' mov bl,[esi+ecx]
    ' xor bh,bh
    ' .if bl == 32 || bl == 45 || bl == 46 || bl == 95
    ' .elseif bl >= 48 && bl <= 57
    ' .elseif bl >= 65 && bl <= 90
    ' .elseif bl >= 97 && bl <= 122
    ' .else
    ' mov bh,1
    ' .endif
    ' .if bh
    ' mov dl,"%"
    ' mov [eax],dl
    ' mov dl,bl
    ' mov bl,dl
    ' shr bl,4
    ' call DEC2HEX
    ' mov [eax+1],bl
    ' mov bl,dl
    ' call DEC2HEX
    ' mov [eax+2],bl
    ' add eax,3
    ' .else
    ' mov dl,[esi+ecx]
    ' .if dl == 32
    ' mov dl,43
    ' .endif
    ' mov [eax],dl
    ' inc eax
    ' .endif
    ' inc ecx
    ' .endw
    ' xor bl,bl
    ' mov [eax],bl
    ' pop edi
    ' pop esi
    ' pop edx
    ' pop ecx
    ' pop ebx
    ' pop eax
    
    返回 (返回值)

.子程序 汇编_字节集URL解码, , , 将参数的内容直接进行URL解码,结果在原变量中
    .参数 局_字节集变量参数, 字节集

    置入代码 ({ 96, 139, 69, 8, 139, 0, 131, 192, 8, 80, 139, 248, 139, 240, 172, 60, 0, 116, 37, 60, 37, 117, 30, 73, 172, 60, 57, 118, 4, 36, 223, 44, 7, 44, 48, 138, 224, 192, 228, 4, 172, 60, 57, 118, 4, 36, 223, 44, 7, 44, 48, 10, 196, 170, 235, 214, 91, 139, 67, 252, 78, 43, 198, 3, 199, 137, 67, 252, 97, 201, 194, 4, 0 })

.子程序 编码_URL解码_快速, 文本型, 公开
    .参数 参_解码文本, 文本型
    .参数 参_是否UTF8, 逻辑型, 可空
    .参数 参_汇编模式, 逻辑型, 可空
    .局部变量 局_字节集变量, 字节集
    .局部变量 局_返回字节集, 字节型, , "0"
    .局部变量 局_循环容器, 整数型
    .局部变量 Len, 整数型
    .局部变量 c1, 字节型
    .局部变量 c0, 字节型
    .局部变量 num, 整数型

    .如果真 (参_解码文本 ＝ “”)
        返回 (“”)
    .如果真结束
    
    局_字节集变量 ＝ 到字节集 (参_解码文本)
    .如果 (参_汇编模式)
        ' http://bbs.125.la/forum.php?mod=viewthread&tid=14226272
        局_字节集变量 ＝ 局_字节集变量 ＋ { 0 }
        汇编_字节集URL解码 (局_字节集变量)
    .否则
        Len ＝ 取字节集长度 (局_字节集变量)
        局_循环容器 ＝ 1
        .判断循环首 (局_循环容器 ≤ Len)
            .判断开始 (局_字节集变量 [局_循环容器] ≠ 37)
                加入成员 (局_返回字节集, 局_字节集变量 [局_循环容器])
            .默认
                
                局_循环容器 ＝ 局_循环容器 ＋ 1
                .如果真 (Len ＜ 局_循环容器)
                    ' 防止数组溢出
                    跳出循环 ()
                .如果真结束
                c1 ＝ 局_字节集变量 [局_循环容器]
                局_循环容器 ＝ 局_循环容器 ＋ 1
                
                .如果真 (Len ＜ 局_循环容器)
                    ' 防止数组溢出
                    跳出循环 ()
                .如果真结束
                
                c0 ＝ 局_字节集变量 [局_循环容器]
                num ＝ hex2dec (c1) × 16 ＋ hex2dec (c0)
                加入成员 (局_返回字节集, num)
            .判断结束
            
            局_循环容器 ＝ 局_循环容器 ＋ 1
        .判断循环尾 ()
        局_字节集变量 ＝ 到字节集 (局_返回字节集)
    .如果结束
    
    .如果真 (参_是否UTF8)
        返回 (编码_Utf8到Ansi (局_字节集变量))
    .如果真结束
    返回 (到文本 (局_字节集变量))

.子程序 hex2dec, 整数型
    .参数 c, 字节型

    .判断开始 (c ≥ 48 且 c ≤ 57)
        返回 (c － 48)
    .判断 (c ≥ 97 且 c ≤ 102)
        返回 (c － 97 ＋ 10)
    .判断 (c ≥ 65 且 c ≤ 70)
        返回 (c － 65 ＋ 10)
    .默认
        返回 (-1)
    .判断结束
    

.子程序 编码_URL编码_JS, 文本型, 公开
    .参数 参_待编码文本, 文本型
    .参数 参_类型, 整数型, 可空, 默认：0     0=encodeURI 1=encodeURIComponent  
    .局部变量 JS, 类_脚本组件
    .局部变量 局_结果, 文本型
    .局部变量 局_类型, 文本型

    .判断开始 (参_类型 ＝ 0)
        局_类型 ＝ “encodeURI” ' 支持&符号编码 感谢【不想说话的树】提供
    .判断 (参_类型 ＝ 1)
        局_类型 ＝ “encodeURIComponent”
    .默认
        局_类型 ＝ “encodeURI”
    .判断结束
    局_结果 ＝ JS.运行 (局_类型, 参_待编码文本, , , , , )
    ' encodeURIComponent   把URI字符串采用URF-8编码格式转化成escape格式的字符串。与encodeURI相比，这个函数会将更多的字符进行编码，比如"/"等字符。所以如果字符串里面包含了URI的几个部分的话，不能用这个来进行编码。否则“/”字符被编码后将URL显示错误。不会被此方法编码的字符：! * ( )
    
    ' encodeURI  把URI字符串采用UTF-8编码格式转化成escape格式的字符串。不会被此方法编码的字符：! @ # $ & ( ) = ： / ; ? + '
    返回 (局_结果)

.子程序 编码_URL解码_JS, 文本型, 公开
    .参数 参_待编码文本, 文本型
    .参数 参_类型, 整数型, 可空, 默认：0     0=decodeURI 1=decodeURIComponent  
    .局部变量 JS, 类_脚本组件
    .局部变量 局_结果, 文本型
    .局部变量 局_类型, 文本型

    .判断开始 (参_类型 ＝ 0)
        局_类型 ＝ “decodeURI”
    .判断 (参_类型 ＝ 1)
        局_类型 ＝ “decodeURIComponent”
    .默认
        局_类型 ＝ “decodeURI”
    .判断结束
    局_结果 ＝ JS.运行 (局_类型, 参_待编码文本, , , , , )
    返回 (局_结果)

.子程序 编码_URL编码_局部, 文本型, 公开, 一般含有中文或#%&+符号的GET或POST表单参数才需要进行编码..不要对整个网址域名和页面文件名称进行编码
    .参数 参_URL, 文本型, , 注意:不要编码整个网址,如 http://www.baidu.com/s?wd=精易模块 只需要编码 精易模块 文本
    .参数 参_是否UTF8, 逻辑型, 可空, 采用UFT_8编码     示例代码如  "http://www.baidu.com/s?wd=" + URL编码 ( "精易模块" )
    .局部变量 局_符号, 逻辑型, , , 把符号 :/?-=()_*. 也编码.注意:不该对网址域名和页面文件名进行符号编码,但GET或POST的提交参数可以进行符号编码.

    .局部变量 局_TEMP, 字节集
    .局部变量 计次, 整数型
    .局部变量 局_返回, 字节集
    .局部变量 索引, 整数型
    .局部变量 局_指针, 整数型

    .如果 (参_是否UTF8)
        局_TEMP ＝ 编码_UTF8编码 (参_URL, )
    .否则
        局_TEMP ＝ 到字节集 (参_URL)
    .如果结束
    
    .如果真 (SEH_安装简单SEH ())
        局_返回 ＝ 取空白字节集 (取字节集长度 (局_TEMP) × 3 ＋ 64)
        局_指针 ＝ 取字节集指针 (局_返回)
        
        .计次循环首 (取字节集长度 (局_TEMP), 计次)
            递增 (索引)
            递增 (局_指针) ' 58,47,63,45,61,40,41,95,46
            .如果真 (局_TEMP [计次] ＞ 32 且 局_TEMP [计次] ＜ 127) ' 排除空格与之前的字符及128值
                .如果真 (局_TEMP [计次] ≠ 35 且 局_TEMP [计次] ≠ 37 且 局_TEMP [计次] ≠ 38 且 局_TEMP [计次] ≠ 43) ' #%&+
                    局_返回 [索引] ＝ 局_TEMP [计次]
                    到循环尾 ()
                .如果真结束
                
            .如果真结束
            局_返回 [索引] ＝ 37
            wvsprintfA_整数型 (局_指针, “%02X”, 局_TEMP [计次])
            索引 ＝ ADD__ (索引, 2, )
            局_指针 ＝ ADD__ (局_指针, 2, )
            
            
            
        .计次循环尾 ()
        
    .如果真结束
    SEH_删除简单SEH ()
    返回 (到文本 (局_返回))

.子程序 编码_URL解码_局部, 文本型, 公开
    .参数 参_URL, 文本型, , 待解码的密文URL地址
    .参数 参_是否UTF8, 逻辑型, 可空, 采用UFT_8解码
    .局部变量 局_TEMP, 字节集
    .局部变量 计次, 整数型
    .局部变量 局_长度, 整数型
    .局部变量 局_H, 整数型
    .局部变量 局_L, 整数型
    .局部变量 局_返回, 字节集
    .局部变量 索引, 整数型
    .局部变量 局_窄文, 文本型

    局_TEMP ＝ 到字节集 (参_URL) ＋ { 0, 0, 0, 0, 0, 0, 0, 0 }
    局_长度 ＝ 取字节集长度 (局_TEMP)
    局_返回 ＝ 取空白字节集 (局_长度)
    局_长度 ＝ 局_长度 － 8
    .判断循环首 (计次 ＜ 局_长度)
        递增 (计次)
        递增 (索引)
        ' 37,48,49,50,51,52,53,54,55,56,57,65,66,67,68,69,70,97,98,99,100,101,102 '%0-9A-Fa-f
        .如果 (局_TEMP [计次] ＝ 37) ' %
            递增 (计次)
            .判断开始 (局_TEMP [计次] ＞ 96) ' a-f
                局_H ＝ 局_TEMP [计次] － 87
            .判断 (局_TEMP [计次] ＞ 64) ' A-F
                局_H ＝ 局_TEMP [计次] － 55
            .默认
                局_H ＝ 局_TEMP [计次] － 48
            .判断结束
            
            递增 (计次)
            .判断开始 (局_TEMP [计次] ＞ 96) ' a-f
                局_L ＝ 局_TEMP [计次] － 87
            .判断 (局_TEMP [计次] ＞ 64) ' A-F
                局_L ＝ 局_TEMP [计次] － 55
            .默认
                局_L ＝ 局_TEMP [计次] － 48
            .判断结束
            
            局_返回 [索引] ＝ 局_H × 16 ＋ 局_L
        .否则
            局_返回 [索引] ＝ 局_TEMP [计次]
        .如果结束
        
    .判断循环尾 ()
    .如果真 (参_是否UTF8)
        编码_UTF8解码 (局_返回, 局_窄文)
        返回 (局_窄文)
    .如果真结束
    返回 (到文本 (局_返回))

.子程序 编码_UTF8编码, 字节集, 公开, 已弃用！请使用 编码_Unicode到Utf8
    .参数 文本数据, 文本型, 可空, 本函数的两个参数根据需要只可提供其中之一个参数
    .参数 宽文本型, 字节集, 可空, 本函数的两个参数根据需要只可提供其中之一个参数
    .局部变量 字数, 整数型
    .局部变量 长度, 整数型
    .局部变量 宽文, 字节集

    .局部变量 UTF8, 字节集

    .如果真 (文本数据 ＝ “” 且 宽文本型 ＝ { })
        返回 ({ })
    .如果真结束
    .如果 (SEH_安装简单SEH ())
        .如果 (文本数据 ≠ “”) ' 先转为宽文本
            字数 ＝ MultiByteToWideChar (0, 0, 取指针文本_ (文本数据), -1, 0, 0)
            字数 ＝ SUB__ (字数, 1)
            长度 ＝ 字数 × 2
            
            宽文 ＝ 取空白字节集 (长度)
            MultiByteToWideChar (0, 0, 取指针文本_ (文本数据), -1, 取指针_字节集型 (宽文), 字数)
            
        .否则
            宽文 ＝ 宽文本型
            字数 ＝ 取字节集长度 (宽文) ＼ 2
        .如果结束
        
        长度 ＝ WideCharToMultiByte (65001, 0, 取指针字节集_ (宽文), 字数, 取指针字节集_ (UTF8), 0, 0, 0)
        UTF8 ＝ 取空白字节集 (长度)
        WideCharToMultiByte (65001, 0, 取指针字节集_ (宽文), 字数, 取指针_字节集型 (UTF8), 长度, 0, 0)
        
    .否则
        UTF8 ＝ { }
    .如果结束
    SEH_删除简单SEH ()
    返回 (UTF8)

.子程序 编码_UTF8解码, 字节集, 公开, 已弃用！请使用 编码_Utf8到Unicode
    .参数 UTF8数据, 字节集, , 待解码的UTF8格式编码数据
    .参数 文本数据, 文本型, 参考 可空, 参考返回 文本数据
    .局部变量 指针, 整数型
    .局部变量 长度, 整数型

    .局部变量 字符, 整数型
    .局部变量 宽文, 字节集

    文本数据 ＝ “”
    .如果真 (UTF8数据 ≠ { })
        .如果 (SEH_安装简单SEH ())
            长度 ＝ 取字节集长度 (UTF8数据)
            指针 ＝ 取字节集指针 (UTF8数据)
            字符 ＝ MultiByteToWideChar (65001, 0, 指针, 长度, 0, 0)
            
            宽文 ＝ 取空白字节集 (字符 × 2)
            MultiByteToWideChar (65001, 0, 指针, 长度, 取指针_字节集型 (宽文), 字符)
            .如果真 (假 ＝ 是否为空 (文本数据))
                长度 ＝ WideCharToMultiByte (0, 0, 取指针字节集_ (宽文), 字符, 取指针文本_ (文本数据), 0, 0, 0)
                文本数据 ＝ 取空白文本 (长度)
                WideCharToMultiByte (0, 0, 取指针字节集_ (宽文), 字符, 取指针_文本型 (文本数据), 长度, 0, 0)
            .如果真结束
            
        .否则
            宽文 ＝ { }
        .如果结束
        SEH_删除简单SEH ()
        返回 (宽文)
    .如果真结束
    返回 ({ })

.子程序 进制_三十六到十, 长整数型, 公开, 将三十六进制文本转换为十进制长整数，暂不支持负数。源码由雪山凌狐提供
    .参数 三十六进制文本, 文本型, , 传入三十六进制的文本，必须为字母或者数字，字母无论大小写，但最好大写
    .局部变量 循环次数, 整数型
    .局部变量 文本长度, 整数型
    .局部变量 此次字符, 文本型
    .局部变量 十进制和, 长整数型

    文本长度 ＝ 取文本长度 (三十六进制文本)
    .计次循环首 (文本长度, 循环次数)
        此次字符 ＝ 取文本中间 (三十六进制文本, 文本长度 － 循环次数 ＋ 1, 1)
        十进制和 ＝ 十进制和 ＋ 进制_三十六_字符处理 (此次字符) × 到长整数 (求次方 (36, 循环次数 － 1))
    .计次循环尾 ()
    返回 (十进制和)

.子程序 进制_三十六_字符处理, 整数型, , 每次只能传入一个字符，不符合要求的一律返回0，内部使用，不公开。源码由雪山凌狐提供
    .参数 待处理的三十六进制字符, 文本型, , 每次只能传入一个字符
    .局部变量 str, 文本型
    .局部变量 szTmp, 文本型
    .局部变量 nPos, 整数型

    str ＝ “0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ”
    szTmp ＝ 到大写 (取文本左边 (待处理的三十六进制字符, 1))
    nPos ＝ 寻找文本 (str, szTmp, , 假)
    .如果真 (nPos ＝ -1 或 nPos ＝ 1)
        返回 (0)
    .如果真结束
    返回 (nPos － 1) ' 写专业一点,这个不是写给老板看的,不需要写那么多行代码
    
    ' *** 缩略程序块 ***
    ' .判断开始 (待处理的三十六进制字符 ＝ “0”)
        ' 返回 (0)
    ' .判断 (待处理的三十六进制字符 ＝ “1”)
        ' 返回 (1)
    ' .判断 (待处理的三十六进制字符 ＝ “2”)
        ' 返回 (2)
    ' .判断 (待处理的三十六进制字符 ＝ “3”)
        ' 返回 (3)
    ' .判断 (待处理的三十六进制字符 ＝ “4”)
        ' 返回 (4)
    ' .判断 (待处理的三十六进制字符 ＝ “5”)
        ' 返回 (5)
    ' .判断 (待处理的三十六进制字符 ＝ “6”)
        ' 返回 (6)
    ' .判断 (待处理的三十六进制字符 ＝ “7”)
        ' 返回 (7)
    ' .判断 (待处理的三十六进制字符 ＝ “8”)
        ' 返回 (8)
    ' .判断 (待处理的三十六进制字符 ＝ “9”)
        ' 返回 (9)
    ' .判断 (到大写 (待处理的三十六进制字符) ＝ “A”)
        ' 返回 (10)
    ' .判断 (到大写 (待处理的三十六进制字符) ＝ “B”)
        ' 返回 (11)
    ' .判断 (到大写 (待处理的三十六进制字符) ＝ “C”)
        ' 返回 (12)
    ' .判断 (到大写 (待处理的三十六进制字符) ＝ “D”)
        ' 返回 (13)
    ' .判断 (到大写 (待处理的三十六进制字符) ＝ “E”)
        ' 返回 (14)
    ' .判断 (到大写 (待处理的三十六进制字符) ＝ “F”)
        ' 返回 (15)
    ' .判断 (到大写 (待处理的三十六进制字符) ＝ “G”)
        ' 返回 (16)
    ' .判断 (到大写 (待处理的三十六进制字符) ＝ “H”)
        ' 返回 (17)
    ' .判断 (到大写 (待处理的三十六进制字符) ＝ “I”)
        ' 返回 (18)
    ' .判断 (到大写 (待处理的三十六进制字符) ＝ “J”)
        ' 返回 (19)
    ' .判断 (到大写 (待处理的三十六进制字符) ＝ “K”)
        ' 返回 (20)
    ' .判断 (到大写 (待处理的三十六进制字符) ＝ “L”)
        ' 返回 (21)
    ' .判断 (到大写 (待处理的三十六进制字符) ＝ “M”)
        ' 返回 (22)
    ' .判断 (到大写 (待处理的三十六进制字符) ＝ “N”)
        ' 返回 (23)
    ' .判断 (到大写 (待处理的三十六进制字符) ＝ “O”)
        ' 返回 (24)
    ' .判断 (到大写 (待处理的三十六进制字符) ＝ “P”)
        ' 返回 (25)
    ' .判断 (到大写 (待处理的三十六进制字符) ＝ “Q”)
        ' 返回 (26)
    ' .判断 (到大写 (待处理的三十六进制字符) ＝ “R”)
        ' 返回 (27)
    ' .判断 (到大写 (待处理的三十六进制字符) ＝ “S”)
        ' 返回 (28)
    ' .判断 (到大写 (待处理的三十六进制字符) ＝ “T”)
        ' 返回 (29)
    ' .判断 (到大写 (待处理的三十六进制字符) ＝ “U”)
        ' 返回 (30)
    ' .判断 (到大写 (待处理的三十六进制字符) ＝ “V”)
        ' 返回 (31)
    ' .判断 (到大写 (待处理的三十六进制字符) ＝ “W”)
        ' 返回 (32)
    ' .判断 (到大写 (待处理的三十六进制字符) ＝ “X”)
        ' 返回 (33)
    ' .判断 (到大写 (待处理的三十六进制字符) ＝ “Y”)
        ' 返回 (34)
    ' .判断 (到大写 (待处理的三十六进制字符) ＝ “Z”)
        ' 返回 (35)
    ' .默认
        ' 返回 (0)
    ' .判断结束
    

.子程序 进制_十到三十六, 文本型, 公开, 将十进制数转换为三十六进制文本，暂不支持负数，返回的三十六进制文本若有字母默认为大写字母。源码由雪山凌狐提供
    .参数 十进制数, 长整数型, , 传入十进制数
    .局部变量 剩余十进制数, 长整数型
    .局部变量 余数, 整数型
    .局部变量 三十六进制数, 文本型

    剩余十进制数 ＝ 十进制数
    .循环判断首 ()
        余数 ＝ 到整数 (剩余十进制数 ％ 36)
        剩余十进制数 ＝ 剩余十进制数 ＼ 36
        三十六进制数 ＝ 进制_三十六_整数处理 (余数) ＋ 三十六进制数
    .循环判断尾 (剩余十进制数 ≥ 36)
    三十六进制数 ＝ 进制_三十六_整数处理 (到整数 (剩余十进制数)) ＋ 三十六进制数
    
    返回 (三十六进制数)
    

.子程序 进制_三十六_整数处理, 文本型, , 传入范围为0-35，若不符合要求则返回空文本，内部使用，不公开。源码由雪山凌狐提供
    .参数 十进制数, 整数型, , 传入十进制数，范围为0-35
    .局部变量 str, 文本型

    str ＝ “0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ”
    返回 (取文本中间 (str, 十进制数 ＋ 1, 1))
    
    ' *** 缩略程序块 ***
    ' .判断开始 (十进制数 ＝ 0)
        ' 返回 (“0”)
    ' .判断 (十进制数 ＝ 1)
        ' 返回 (“1”)
    ' .判断 (十进制数 ＝ 2)
        ' 返回 (“2”)
    ' .判断 (十进制数 ＝ 3)
        ' 返回 (“3”)
    ' .判断 (十进制数 ＝ 4)
        ' 返回 (“4”)
    ' .判断 (十进制数 ＝ 5)
        ' 返回 (“5”)
    ' .判断 (十进制数 ＝ 6)
        ' 返回 (“6”)
    ' .判断 (十进制数 ＝ 7)
        ' 返回 (“7”)
    ' .判断 (十进制数 ＝ 8)
        ' 返回 (“8”)
    ' .判断 (十进制数 ＝ 9)
        ' 返回 (“9”)
    ' .判断 (十进制数 ＝ 10)
        ' 返回 (“A”)
    ' .判断 (十进制数 ＝ 11)
        ' 返回 (“B”)
    ' .判断 (十进制数 ＝ 12)
        ' 返回 (“C”)
    ' .判断 (十进制数 ＝ 13)
        ' 返回 (“D”)
    ' .判断 (十进制数 ＝ 14)
        ' 返回 (“E”)
    ' .判断 (十进制数 ＝ 15)
        ' 返回 (“F”)
    ' .判断 (十进制数 ＝ 16)
        ' 返回 (“G”)
    ' .判断 (十进制数 ＝ 17)
        ' 返回 (“H”)
    ' .判断 (十进制数 ＝ 18)
        ' 返回 (“I”)
    ' .判断 (十进制数 ＝ 19)
        ' 返回 (“J”)
    ' .判断 (十进制数 ＝ 20)
        ' 返回 (“K”)
    ' .判断 (十进制数 ＝ 21)
        ' 返回 (“L”)
    ' .判断 (十进制数 ＝ 22)
        ' 返回 (“M”)
    ' .判断 (十进制数 ＝ 23)
        ' 返回 (“N”)
    ' .判断 (十进制数 ＝ 24)
        ' 返回 (“O”)
    ' .判断 (十进制数 ＝ 25)
        ' 返回 (“P”)
    ' .判断 (十进制数 ＝ 26)
        ' 返回 (“Q”)
    ' .判断 (十进制数 ＝ 27)
        ' 返回 (“R”)
    ' .判断 (十进制数 ＝ 28)
        ' 返回 (“S”)
    ' .判断 (十进制数 ＝ 29)
        ' 返回 (“T”)
    ' .判断 (十进制数 ＝ 30)
        ' 返回 (“U”)
    ' .判断 (十进制数 ＝ 31)
        ' 返回 (“V”)
    ' .判断 (十进制数 ＝ 32)
        ' 返回 (“W”)
    ' .判断 (十进制数 ＝ 33)
        ' 返回 (“X”)
    ' .判断 (十进制数 ＝ 34)
        ' 返回 (“Y”)
    ' .判断 (十进制数 ＝ 35)
        ' 返回 (“Z”)
    ' .默认
        ' 返回 (“”)
    ' .判断结束
    

.子程序 编码_Ansi到Utf8_无BOM文件, 逻辑型, 公开, 将文本内容写出保存成utf8无BOM格式编码文件。成功返回真，失败返回假。源码由雪山凌狐提供
    .参数 文本, 文本型, , 请输入要转换的文本
    .参数 保存路径, 文本型, , 请输入保存到的文件的完整路径
    .局部变量 stream, 对象
    .局部变量 newstream, 对象

    线程_初始化COM库 ()
    .如果真 (stream.创建 (“adodb.stream”, ) ＝ 假)
        返回 (假)
    .如果真结束
    stream.写属性 (“Type”, 2) ' text
    stream.写属性 (“mode”, 3)
    stream.写属性 (“Charset”, “utf-8”)
    stream.方法 (“Open”, )
    stream.方法 (“WriteText”, 文本)
    stream.写属性 (“Position”, 3)
    .如果真 (newstream.创建 (“adodb.stream”, ) ＝ 假)
        返回 (假)
    .如果真结束
    newstream.写属性 (“mode”, 3)
    newstream.写属性 (“Type”, 1)
    newstream.方法 (“Open”, )
    stream.方法 (“CopyTo”, newstream)
    newstream.方法 (“SaveToFile”, 保存路径, 2)
    stream.方法 (“flush”, )
    stream.方法 (“Close”, )
    线程_取消COM库 ()
    
    返回 (真)

.子程序 到逻辑型, 逻辑型, 公开, 为了方便将文本型的真假二字转换成逻辑型数据或整数型转换为逻辑型编写的子程序，如果输入空值会默认返回假.源码由雪山凌狐提供
    .参数 欲转换的文本型数据, 文本型, 可空, 正常的文本型数据为“真”字或者“假”字，其他情况一律返回假，为空时默认返回假，跟整数型数据二选其一
    .参数 欲转换的整数型数据, 整数型, 可空, 传入0返回假，其他整数都返回真，若为空，默认传入0，返回假，跟文本型数据二选其一
    .参数 转换模式, 整数型, 可空, 模式1为文本型，模式2为整数型，传入其他或为空则默认为模式1

    .如果真 (是否为空 (转换模式))
        转换模式 ＝ 1
    .如果真结束
    .如果真 (转换模式 ＜ 1 或 转换模式 ＞ 2)
        转换模式 ＝ 1
    .如果真结束
    
    .判断开始 (转换模式 ＝ 1)
        ' 转换的是文本
        .如果真 (是否为空 (欲转换的文本型数据))
            返回 (假)
        .如果真结束
        
        .如果 (欲转换的文本型数据 ＝ “真”)
            返回 (真)
        .否则
            返回 (假)
        .如果结束
        
        
    .判断 (转换模式 ＝ 2)
        ' 转换的是整数
        .如果真 (是否为空 (欲转换的整数型数据))
            欲转换的整数型数据 ＝ 0
        .如果真结束
        
        .如果 (欲转换的整数型数据 ＝ 0)
            返回 (假)
        .否则
            返回 (真)
        .如果结束
        
    .默认
        ' 不会运行这一句的，但是为了让程序具有返回值定义，添加的
        返回 (假)
    .判断结束
    

.子程序 到逻辑型_通用版, 逻辑型, 公开, 非0数值,非空字符串,非空字节集返回真,其他返回假,支持所有基础数据类型,禁止传递非基础数据类型,否则都返回假
    .参数 数据, 通用型, , 如果传递过来的是文本或字节集,并且这个数据是"假",那也返回假,有没有空格都支持,支持传递栈地址,堆地址
    .局部变量 addr, 整数型
    .局部变量 bin, 字节集
    .局部变量 ret, 字节集

    置入代码 ({ 139, 69, 8, 137, 69, 252 }) ' 取参数地址,存到第一个变量
    IsBadCodePtr (addr) ' 判断指针是否有效
    置入代码 ({ 131, 248, 0, 118, 7, 139, 69, 8, 201, 194, 4, 0 }) ' 如果指针无效,则返回,非0返回真
    IsBadCodePtr (指针_到整数 (addr)) ' 在判断一下,有可能用户传递过来的是变量的栈地址
    置入代码 ({ 11, 192, 117, 8, 139, 69, 8, 139, 0, 137, 69, 252 }) ' 如果传递过来的是栈地址,那就取堆地址,并放到第一个变量,如果不是则不处理
    
    bin ＝ 指针到字节集 (addr, 4) ' 取这个地址的4个字节,做为一个判断是字节集还是文本的方法
    ' 这样的判断不是很严谨,如果有人非要搞事情,传递个  字符(1)+字符(0)+字符(0)+字符(0),那这里也会被判断为字节集,不过搞事情的人不多,不要紧
    .判断开始 (bin ＝ { 1, 0, 0, 0 }) ' 传过来的是字节集类型
        ret ＝ 指针到字节集 (addr ＋ 8, 指针_到整数 (addr ＋ 4)) ' 字节集从第八个字节才是实际数据,第4-第七个字节是数据长度,把数据取出来
        ret ＝ 子字节集替换 (ret, { 32 }, , , ) ' 删除全部的空格
        .如果真 (ret ＝ 到字节集 (“假”)) ' 如果这个字节集是"假" 这个字,也返回假,这里不做非ansi编码的判断,需要的自己加
            返回 (假)
        .如果真结束
        返回 (ret ≠ { }) ' 剩下的只要不是空字节集就返回真
    .默认
        ' 不做非基础类型的判断,只做文本和字节集的判断
        .如果真 (删全部空 (指针到文本 (addr)) ＝ “假”) ' 如果传递过来的是"假" 那就返回假,这里不做非ansi编码的判断,需要的自己加
            返回 (假)
        .如果真结束
        返回 (取字节集左边 (bin, 1) ≠ { 0 }) ' 剩下的只要不是空字符串都返回真
    .判断结束
    返回 (假)

.子程序 内部_bmzh, 字节集, , 内部调用
    .参数 待转换数据, 字节集
    .参数 转换前编码, 文本型
    .参数 转换后编码, 文本型
    .参数 转换后数据开始位置, 整数型, 可空
    .局部变量 对象, 对象
    .局部变量 文本, 文本型
    .局部变量 字节集, 字节集
    .局部变量 变体型, 变体型

    对象.创建 (“Adodb.Stream”, )
    对象.写属性 (“Type”, 1) ' 流类型为字节集
    对象.方法 (“Open”, )
    变体型.置类型 (7)
    变体型.创建数组 (1, 取字节集长度 (待转换数据))
    变体型.赋值 (待转换数据, )
    对象.方法 (“Write”, 变体型)
    对象.写属性 (“Position”, 0)
    对象.写属性 (“Type”, 2) ' 流类型为文本
    对象.写属性 (“Charset”, 转换前编码)
    文本 ＝ 对象.文本方法 (“ReadText”, )
    对象.方法 (“Close”, )
    对象.方法 (“Open”, )
    对象.写属性 (“Charset”, 转换后编码)
    对象.方法 (“WriteText”, 文本)
    对象.写属性 (“Position”, 0)
    对象.写属性 (“Type”, 1) ' 流类型为字节集
    .如果真 (是否为空 (转换后数据开始位置) ＝ 假)
        对象.写属性 (“Position”, 转换后数据开始位置)
    .如果真结束
    字节集 ＝ 对象.通用方法 (“Read”, ).取字节集 ()
    对象.清除 ()
    返回 (字节集)

.子程序 编码_编码转换对象, 字节集, 公开, 默认“UTF-8”到“GBK”解码
    .参数 待转换数据, 字节集
    .参数 转换前编码, 文本型, 可空, utf-8；unicode；GBK 等
    .参数 转换后编码, 文本型, 可空, utf-8；unicode；GBK 等
    .参数 转换后数据开始位置, 整数型, 可空, 位置从0开始。unicode编码标识占2个字节，utf-8编码标识占3个字节
    .局部变量 ret, 字节集

    .如果真 (转换前编码 ＝ “”)
        转换前编码 ＝ “UTF-8”
    .如果真结束
    
    .如果真 (转换后编码 ＝ “”)
        转换后编码 ＝ “GBK”
    .如果真结束
    线程_初始化COM库 ()
    .如果 (是否为空 (转换后数据开始位置))
        ret ＝ 内部_bmzh (待转换数据, 转换前编码, 转换后编码)
    .否则
        ret ＝ 内部_bmzh (待转换数据, 转换前编码, 转换后编码, 转换后数据开始位置)
    .如果结束
    线程_取消COM库 ()
    返回 (ret)

.子程序 A2W_CP, 字节集
    .参数 lpa, 字节集
    .参数 acp, 整数型, , #CP_x
    .局部变量 ByteStr, 字节集
    .局部变量 lpsz, 整数型
    .局部变量 len, 整数型
    .局部变量 CharStr, 字节集

    ByteStr ＝ lpa ＋ { 0 }
    lpsz ＝ 取指针字节集_ (ByteStr)
    .如果真 (lpsz ≠ 0 且 strlen (lpsz) ＞ 0)
        len ＝ MultiByteToWideChar (acp, 0, lpsz, -1, 0, 0)
        CharStr ＝ 取空白字节集 (len × 2)
        MultiByteToWideChar (acp, 0, lpsz, -1, 取指针_字节集型 (CharStr), len)
    .如果真结束
    返回 (CharStr)

.子程序 W2A_CP, 字节集
    .参数 lpw, 字节集
    .参数 acp, 整数型, , #CP_x
    .局部变量 CharStr, 字节集
    .局部变量 lpwsz, 整数型
    .局部变量 len, 整数型
    .局部变量 ByteStr, 字节集
    .局部变量 lpsz, 整数型

    CharStr ＝ lpw ＋ { 0, 0 }
    lpwsz ＝ 取指针字节集_ (CharStr)
    .如果真 (lpwsz ≠ 0 且 lstrlenW (lpwsz) ＞ 0)
        len ＝ WideCharToMultiByte (acp, 0, lpwsz, -1, 0, 0, 0, 0)
        ByteStr ＝ 取空白字节集 (len)
        lpsz ＝ 取指针_字节集型 (ByteStr)
        WideCharToMultiByte (acp, 0, lpwsz, -1, lpsz, len, 0, 0)
        ByteStr ＝ 指针到字节集 (lpsz, strlen (lpsz)) ' 不保留结尾的0
    .如果真结束
    返回 (ByteStr)

.子程序 Ansi到Unicode, 字节集
    .参数 Ansi, 文本型
    .参数 原始编码, 整数型, 可空, #CP_UTF8

    .如果真 (是否为空 (原始编码))
        原始编码 ＝ #CP_UTF8
    .如果真结束
    返回 (A2W_CP (到字节集 (Ansi), 原始编码))

.子程序 Unicode到Ansi, 文本型
    .参数 Unicode, 字节集
    .参数 目标编码, 整数型, 可空, #CP_ACP
    .局部变量 szChar, 字节集

    .如果真 (是否为空 (目标编码))
        目标编码 ＝ #CP_ACP
    .如果真结束
    szChar ＝ W2A_CP (Unicode, 目标编码)
    返回 (取字节集数据 (szChar, #文本型, ))

.子程序 编码_运行JS代码, 文本型, 公开, 失败返回“JS代码运行失败”，如果此命令用于线程内，请在线程子程序里的第一行加上 线程_初始化COM库 ()
    .参数 JS代码, 文本型
    .参数 函数名, 文本型, , 要运行的Js函数名
    .参数 参数一, 文本型, 可空
    .参数 参数二, 文本型, 可空
    .参数 参数三, 文本型, 可空
    .参数 参数四, 文本型, 可空
    .局部变量 脚本, 类_脚本组件

    .如果真 (脚本.执行 (JS代码))
        返回 (脚本.运行 (函数名, 参数一, 参数二, 参数三, 参数四))
    .如果真结束
    返回 (“JS代码运行失败”)
    

.子程序 编码_URL解码, 文本型, 公开, %BE%AB%D2%D7%C2%DB%CC%B3 => 精易论坛
    .参数 URL, 文本型
    .参数 是否UTF8, 逻辑型, 可空, 先将文本串解码为文本,再从UTF8转成GBK编码
    .局部变量 dwSize, 整数型
    .局部变量 pUrl, 整数型
    .局部变量 pBuf, 整数型
    .局部变量 cBuf, 字节型
    .局部变量 sByte, 短整数型
    .局部变量 szText, 字节集
    .局部变量 i, 整数型

    dwSize ＝ 取文本长度 (URL)
    .如果真 (dwSize ＝ 0)
        返回 (“”)
    .如果真结束
    pUrl ＝ 取指针_文本型 (URL)
    pBuf ＝ LocalAlloc (#LMEM_ZEROINIT, dwSize ＋ 1)
    .如果真 (pBuf ≠ #NULL)
        .判断循环首 (i ≤ dwSize)
            cBuf ＝ __get_byte (pUrl, 0)
            .判断开始 (cBuf ＝ 0)
                跳出循环 ()
            .判断 (cBuf ＝ 37) ' %
                sByte ＝ 指针_到短整数型_汇编 (pUrl ＋ 1)
                .如果 (sscanf (取指针地址_短整数型 (sByte), “%x”, cBuf) ＞ 0)
                    pUrl ＝ pUrl ＋ 3
                    __set_byte (pBuf, i, cBuf)
                .否则
                    pUrl ＝ pUrl ＋ 1
                    __set_byte (pBuf, i, cBuf)
                .如果结束
                
            .判断 (cBuf ＝ 43) ' +
                pUrl ＝ pUrl ＋ 1
                __set_byte (pBuf, i, 32)
            .判断 (cBuf ＞ 38 且 cBuf ＜ 43 或 cBuf ＝ 45 或 cBuf ＝ 46 或 (cBuf ＞ 47 且 cBuf ＜ 58) 或 (cBuf ＞ 64 且 cBuf ＜ 91) 或 (cBuf ＞ 96 且 cBuf ＜ 123) 或 cBuf ＝ 95)
                pUrl ＝ pUrl ＋ 1
                __set_byte (pBuf, i, cBuf)
            .默认
                pUrl ＝ pUrl ＋ 1
                __set_byte (pBuf, i, cBuf)
            .判断结束
            i ＝ i ＋ 1
        .判断循环尾 ()
        .如果真 (i ＞ 0)
            szText ＝ 指针到字节集 (pBuf, i)
        .如果真结束
        LocalFree (pBuf)
    .如果真结束
    .如果真 (是否UTF8)
        返回 (编码_Utf8到Ansi (szText))
    .如果真结束
    返回 (取字节集数据 (szText, #文本型, ))

.子程序 编码_URL编码, 文本型, 公开, 精易论坛 => %BE%AB%D2%D7%C2%DB%CC%B3
    .参数 欲编码的文本, 文本型
    .参数 不编码字母数字, 逻辑型, 可空, 不需要编码【字母数字.-】可以把此参数设置为真
    .参数 是否UTF8, 逻辑型, 可空, 先把文本转换成UTF8编码,再编码成URL
    .局部变量 szChar, 字节集

    .如果 (是否UTF8)
        szChar ＝ 编码_Ansi到Utf8 (欲编码的文本)
    .否则
        szChar ＝ 到字节集 (欲编码的文本)
    .如果结束
    返回 (URL编码_字节集 (szChar, 不编码字母数字))

.子程序 URL编码_字节集, 文本型
    .参数 被转换数据, 字节集
    .参数 不转换部分字符, 逻辑型, , '()*-. 0-9 A-Z a-z_
    .局部变量 dwLen, 整数型
    .局部变量 szChar, 字节集
    .局部变量 pChar, 整数型
    .局部变量 i, 整数型
    .局部变量 n, 整数型

    dwLen ＝ 取字节集长度 (被转换数据)
    .如果真 (dwLen ＞ 0)
        szChar ＝ 取空白字节集 (dwLen × 3 ＋ 1) ' 必须0结尾
        pChar ＝ 取指针字节集_ (szChar)
        .计次循环首 (dwLen, i)
            .如果真 (被转换数据 [i] ＝ 0)
                到循环尾 ()
            .如果真结束
            
            ' 被转换数据 [i] ＞ 38 且 被转换数据 [i] ＜ 43┃'()*
            ' 被转换数据 [i] ＝ 45┃-
            ' 被转换数据 [i] ＝ 46┃.
            ' 被转换数据 [i] ＞ 47 且 被转换数据 [i] ＜ 58┃0-9
            ' 被转换数据 [i] ＞ 64 且 被转换数据 [i] ＜ 91┃A-Z
            ' 被转换数据 [i] ＞ 96 且 被转换数据 [i] ＜ 123┃a-z
            ' 被转换数据 [i] ＝ 95┃_
            
            .判断开始 (不转换部分字符 且 (被转换数据 [i] ＞ 38 且 被转换数据 [i] ＜ 43 或 被转换数据 [i] ＝ 45 或 被转换数据 [i] ＝ 46 或 (被转换数据 [i] ＞ 47 且 被转换数据 [i] ＜ 58) 或 (被转换数据 [i] ＞ 64 且 被转换数据 [i] ＜ 91) 或 (被转换数据 [i] ＞ 96 且 被转换数据 [i] ＜ 123) 或 被转换数据 [i] ＝ 95))
                __set_byte (pChar, n, 被转换数据 [i])
                n ＝ n ＋ 1
            .判断 (被转换数据 [i] ＝ 32) ' 空格
                __set_byte (pChar, n, 43)
                n ＝ n ＋ 1
            .默认
                n ＝ n ＋ sprintf (pChar ＋ n, “%%%02X”, 被转换数据 [i])
            .判断结束
            
        .计次循环尾 ()
    .如果真结束
    返回 (取字节集数据 (szChar, #文本型, ))

.子程序 编码_URL编码1, 文本型, 公开, { 62, 216, 35, 221, 0, 0 } => %F0%9F%A4%A3
    .参数 欲编码的文本, 字节集
    .参数 忽略保留字符, 逻辑型, 可空, 默认为真
    .局部变量 nMaxCount, 整数型
    .局部变量 szBuffer, 文本型
    .局部变量 pszBuffer, 整数型
    .局部变量 i, 整数型
    .局部变量 n, 整数型

    nMaxCount ＝ 取字节集长度 (欲编码的文本)
    .如果真 (nMaxCount ＞ 0)
        szBuffer ＝ 取空白文本 (nMaxCount × 3 ＋ 1)
        pszBuffer ＝ 取指针文本_ (szBuffer)
        .计次循环首 (nMaxCount, i)
            .如果真 (欲编码的文本 [i] ＝ 0)
                跳出循环 ()
            .如果真结束
            
            .判断开始 (欲编码的文本 [i] ＞ 47 且 欲编码的文本 [i] ＜ 58 或 (欲编码的文本 [i] ＞ 64 且 欲编码的文本 [i] ＜ 91) 或 (欲编码的文本 [i] ＞ 96 且 欲编码的文本 [i] ＜ 123))
                
                ' 欲编码的文本 [i] ＞ 47 且 欲编码的文本 [i] ＜ 58┃0-9
                ' 欲编码的文本 [i] ＞ 64 且 欲编码的文本 [i] ＜ 91┃A-Z
                ' 欲编码的文本 [i] ＞ 96 且 欲编码的文本 [i] ＜ 123┃a-z
                
                __set_byte (pszBuffer, n, 欲编码的文本 [i])
                n ＝ n ＋ 1
            .判断 (是否为空 (忽略保留字符) 或 忽略保留字符 且 (欲编码的文本 [i] ＞ 38 且 欲编码的文本 [i] ＜ 43 或 欲编码的文本 [i] ＝ 45 或 欲编码的文本 [i] ＝ 46 或 欲编码的文本 [i] ＝ 95 或 欲编码的文本 [i] ＝ 126))
                
                ' 欲编码的文本 [i] ＞ 38 且 欲编码的文本 [i] ＜ 43┃'()*
                ' 欲编码的文本 [i] ＝ 45┃-
                ' 欲编码的文本 [i] ＝ 46┃.
                ' 欲编码的文本 [i] ＝ 95┃_
                ' 欲编码的文本 [i] ＝ 126┃~
                
                __set_byte (pszBuffer, n, 欲编码的文本 [i])
                n ＝ n ＋ 1
            .判断 (是否为空 (忽略保留字符) 或 忽略保留字符 且 欲编码的文本 [i] ＝ 32) ' 空格
                __set_byte (pszBuffer, n, 43)
                n ＝ n ＋ 1
            .默认
                n ＝ n ＋ sprintf (pszBuffer ＋ n, “%%%02X”, 位与 (欲编码的文本 [i], 255))
            .判断结束
            
        .计次循环尾 ()
        __set_byte (pszBuffer, n, 0)
    .如果真结束
    返回 (szBuffer)

.子程序 编码_BASE64编码, 文本型, 公开, BASE64编码处理；成功返回编码后的文本；
    .参数 待编码数据, 字节集, , 待编码字节集
    .局部变量 局_数据, 字节集
    .局部变量 局_余数, 整数型
    .局部变量 局_临时, 字节型, , "3"
    .局部变量 局_变量, 整数型
    .局部变量 局_集合, 字节集
    .局部变量 局_长度, 整数型
    .局部变量 局_字符, 字节集
    .局部变量 i, 整数型

    局_数据 ＝ 待编码数据
    局_长度 ＝ 取字节集长度 (局_数据)
    .如果真 (局_长度 ＜ 1)
        返回 (“”)
    .如果真结束
    局_余数 ＝ 局_长度 ％ 3
    .如果真 (局_余数 ＞ 0)
        局_数据 ＝ 局_数据 ＋ 取空白字节集 (3 － 局_余数)
    .如果真结束
    局_长度 ＝ 取字节集长度 (局_数据)
    局_字符 ＝ 取空白字节集 (局_长度 × 4 ÷ 3)
    i ＝ 1
    局_集合 ＝ 到字节集 (“ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/”)
    .变量循环首 (1, 局_长度, 3, 局_变量)
        局_临时 [1] ＝ 局_数据 [局_变量]
        局_临时 [2] ＝ 局_数据 [局_变量 ＋ 1]
        局_临时 [3] ＝ 局_数据 [局_变量 ＋ 2]
        局_字符 [i] ＝ 局_集合 [右移 (局_临时 [1], 2) ＋ 1]
        局_字符 [i ＋ 1] ＝ 局_集合 [左移 (位与 (局_临时 [1], 3), 4) ＋ 右移 (局_临时 [2], 4) ＋ 1]
        局_字符 [i ＋ 2] ＝ 局_集合 [左移 (位与 (局_临时 [2], 15), 2) ＋ 右移 (局_临时 [3], 6) ＋ 1]
        局_字符 [i ＋ 3] ＝ 局_集合 [位与 (局_临时 [3], 63) ＋ 1]
        i ＝ i ＋ 4
    .变量循环尾 ()
    .如果真 (局_余数 ＞ 0)
        局_长度 ＝ 取字节集长度 (局_字符)
        .如果 (局_余数 ＝ 1)
            局_字符 [局_长度 － 1] ＝ 到字节 (取代码 (“=”, ))
            局_字符 [局_长度] ＝ 到字节 (取代码 (“=”, ))
        .否则
            局_字符 [局_长度] ＝ 到字节 (取代码 (“=”, ))
        .如果结束
        
    .如果真结束
    返回 (到文本 (局_字符))

.子程序 编码_BASE64解码, 字节集, 公开, BASE64解码处理；成功返回解码后的字节集数据；
    .参数 编码文本, 文本型, , 待解码的文本
    .参数 去除右边空白字节集, 逻辑型, 可空
    .局部变量 Alphabets, 文本型
    .局部变量 aryPhase, 字节集
    .局部变量 aryBin, 字节集
    .局部变量 dwSize, 整数型
    .局部变量 dwMult, 整数型
    .局部变量 nMaxCount, 整数型
    .局部变量 aryData, 字节集
    .局部变量 aryTemp, 字节型, , "4"
    .局部变量 i, 整数型
    .局部变量 n, 整数型

    aryBin ＝ 到字节集 (编码文本)
    aryBin ＝ 子字节集替换 (aryBin, { 32 }, , , ) ' 空格
    aryBin ＝ 子字节集替换 (aryBin, { 13, 10 }, , , ) ' 换行
    dwSize ＝ 取字节集长度 (aryBin)
    .如果真 (dwSize ＝ 0)
        返回 ({ })
    .如果真结束
    Alphabets ＝ “ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/”
    aryPhase ＝ 取空白字节集 (256)
    .计次循环首 (64, i)
        aryPhase [取代码 (Alphabets, i)] ＝ i － 1
    .计次循环尾 ()
    dwMult ＝ dwSize ＼ 4
    .如果真 (dwSize ％ 4 ≠ 0)
        dwMult ＝ dwMult ＋ 1
    .如果真结束
    .判断开始 (倒找字节集 (aryBin, { 61, 61 }, ) ≠ -1)
        nMaxCount ＝ 2
    .判断 (倒找字节集 (aryBin, { 61 }, ) ≠ -1)
        nMaxCount ＝ 1
    .默认
        
    .判断结束
    aryData ＝ 取空白字节集 (dwMult × 3)
    n ＝ 1
    .变量循环首 (1, dwSize － 3, 4, i)
        aryTemp [1] ＝ aryPhase [aryBin [i]]
        aryTemp [2] ＝ aryPhase [aryBin [i ＋ 1]]
        aryTemp [3] ＝ aryPhase [aryBin [i ＋ 2]]
        aryTemp [4] ＝ aryPhase [aryBin [i ＋ 3]]
        aryData [n] ＝ 左移 (aryTemp [1], 2) ＋ 位与 (右移 (aryTemp [2], 4), 3)
        aryData [n ＋ 1] ＝ 位与 (左移 (aryTemp [2], 4), 240) ＋ 位与 (右移 (aryTemp [3], 2), 15)
        aryData [n ＋ 2] ＝ 位与 (左移 (aryTemp [3], 6), 192) ＋ aryTemp [4]
        n ＝ n ＋ 3
    .变量循环尾 ()
    assignZero (aryData, dwMult × 3 － nMaxCount, 真)
    .如果真 (去除右边空白字节集)
        aryData ＝ 去除右边空字节集 (aryData)
    .如果真结束
    返回 (aryData)

.子程序 编码_BASE64编码A, 字节集, 公开, Api版，编码_BASE64编码
    .参数 欲转换的数据, 字节集
    .参数 dwFlags, 整数型, 可空, #CRYPT_STRING_*
    .局部变量 dwBinLen, 整数型
    .局部变量 dwSigLen, 整数型
    .局部变量 pszString, 整数型
    .局部变量 szString, 字节集

    .如果真 (是否为空 (dwFlags))
        dwFlags ＝ 位或 (#CRYPT_STRING_BASE64, #CRYPT_STRING_NOCRLF)
    .如果真结束
    dwBinLen ＝ 取字节集长度 (欲转换的数据)
    .如果真 (CryptBinaryToStringA (欲转换的数据, dwBinLen, dwFlags, #NULL, dwSigLen) ＝ 假)
        返回 ({ })
    .如果真结束
    pszString ＝ LocalAlloc (#LMEM_ZEROINIT, dwSigLen)
    .如果真 (pszString ≠ #NULL)
        CryptBinaryToStringA (欲转换的数据, dwBinLen, dwFlags, pszString, dwSigLen)
        szString ＝ 指针到字节集 (pszString, dwSigLen)
        LocalFree (pszString)
    .如果真结束
    返回 (szString)

.子程序 编码_BASE64解码A, 字节集, 公开, Api版，编码_BASE64解码
    .参数 欲转换的数据, 字节集
    .参数 dwFlags, 整数型, 可空, #CRYPT_STRING_*
    .局部变量 dwSigLen, 整数型
    .局部变量 dwBinLen, 整数型
    .局部变量 pszBinary, 整数型
    .局部变量 szBinary, 字节集

    .如果真 (是否为空 (dwFlags))
        dwFlags ＝ #CRYPT_STRING_BASE64
    .如果真结束
    dwSigLen ＝ 取字节集长度 (欲转换的数据)
    .如果真 (CryptStringToBinaryA (欲转换的数据, dwSigLen, dwFlags, #NULL, dwBinLen, #NULL, #NULL) ＝ 假)
        返回 ({ })
    .如果真结束
    pszBinary ＝ LocalAlloc (#LMEM_ZEROINIT, dwBinLen)
    .如果真 (pszBinary ≠ #NULL)
        CryptStringToBinaryA (欲转换的数据, dwSigLen, dwFlags, pszBinary, dwBinLen, #NULL, #NULL)
        szBinary ＝ 指针到字节集 (pszBinary, dwBinLen)
        LocalFree (pszBinary)
    .如果真结束
    返回 (szBinary)

.子程序 编码_RC4加密, 字节集, 公开
    .参数 明文, 字节集
    .参数 密钥, 文本型

    返回 (校验_取rc4 (明文, 密钥))

.子程序 编码_RC4解密, 字节集, 公开
    .参数 密文, 字节集
    .参数 密钥, 文本型

    返回 (校验_取rc4 (密文, 密钥))

.子程序 去除右边空字节集, 字节集
    .参数 字节集数据, 字节集
    .局部变量 i, 整数型
    .局部变量 字节集, 字节集

    字节集 ＝ 字节集数据
    .计次循环首 (取字节集长度 (字节集数据), i)
        .如果 (取字节集右边 (字节集, 1) ＝ { 0 })
            字节集 ＝ 取字节集左边 (字节集, 取字节集长度 (字节集) － 1)
        .否则
            跳出循环 ()
        .如果结束
        
    .计次循环尾 ()
    返回 (字节集)

.子程序 编码_简体到繁体, 文本型, 公开, 将简体中文转换成繁体中文；成功返回转换后的繁体内容；
    .参数 简体文本, 文本型, , 欲转换的文本内容
    .局部变量 文本长度, 整数型
    .局部变量 繁体文本, 文本型

    文本长度 ＝ 取文本长度 (简体文本)
    繁体文本 ＝ 取空白文本 (文本长度)
    _文本简繁体转换 (2052, 67108864, 简体文本, 文本长度, 繁体文本, 文本长度)
    返回 (繁体文本)
    ' 第一个参数Locale在这里代表所处理的文本的编码格式，2052为中文GBK编码。
    ' 第二个参数dwMapFlags代表转换目标类型，67108864为到繁体类型，33554432为到简体类型

.子程序 编码_繁体到简体, 文本型, 公开, 将繁体中文转换成简体中文；成功返回转换后的简体内容；
    .参数 繁体文本, 文本型, , 欲转换的文本内容
    .局部变量 文本长度, 整数型
    .局部变量 简体文本, 文本型

    文本长度 ＝ 取文本长度 (繁体文本)
    简体文本 ＝ 取空白文本 (文本长度)
    _文本简繁体转换 (2052, 33554432, 繁体文本, 文本长度, 简体文本, 文本长度)
    返回 (简体文本)

.子程序 编码_usc2到ansi, 文本型, 公开, 将usc2转变成ansi  如 %u0031%u0032%u0033 转换后为 123 失败返回空文本
    .参数 欲转换的文本, 文本型, , \u %u \u25 等3种格式,如果是其它格式,请先用子文本替换成这三种的任意一种才能正常转换
    .局部变量 脚本对象, 对象
    .局部变量 局_文本, 文本型
    .局部变量 局_返回值, 文本型

    局_文本 ＝ 子文本替换 (欲转换的文本, #换行符, “{$}”, , , 真)
    局_文本 ＝ 子文本替换 (局_文本, 字符 (10), “{//n//}”, , , 真) ' 临时
    .如果真 (取字节集左边 (到字节集 (取文本左边 (局_文本, 10)), 1) ＝ { 13 })
        局_文本 ＝ 到文本 (子字节集替换 (到字节集 (局_文本), { 13 }, { }, , 1))
    .如果真结束
    .判断开始 (寻找文本 (局_文本, “\u”, , 假) ≠ -1)
        局_文本 ＝ 子文本替换 (局_文本, “\u”, “%u”, , , 真)
    .判断 (寻找文本 (局_文本, “\u25”, , 假) ≠ -1)
        局_文本 ＝ 子文本替换 (局_文本, “\u25”, “%u”, , , 真)
    .默认
        
    .判断结束
    局_文本 ＝ 子文本替换 (局_文本, “'”, “\'”, , , 真)
    线程_初始化COM库 ()
    脚本对象.创建 (“ScriptControl”, )
    脚本对象.写属性 (“Language”, “JScript”)
    脚本对象.数值方法 (“ExecuteStatement”, “function xx(){var x='” ＋ 局_文本 ＋ “';return unescape(x);}”)
    局_返回值 ＝ 脚本对象.文本方法 (“Run”, “xx”)
    局_文本 ＝ 内_编码_Unicode到Ansi_对象 (到字节集 (局_文本))
    局_返回值 ＝ 选择 (取文本长度 (局_返回值) ＝ 0, 局_文本, 局_返回值)
    脚本对象.清除 ()
    线程_取消COM库 ()
    局_返回值 ＝ 子文本替换 (局_返回值, “{$}”, #换行符, , , 真)
    局_返回值 ＝ 子文本替换 (局_返回值, “{//n//}”, 字符 (10), , , 真)
    返回 (局_返回值)

.子程序 内_编码_Unicode到Ansi_对象, 文本型, , 带BOM头信息编码转换。
    .参数 参_欲转换的内容, 字节集
    .局部变量 变_Dx, 对象
    .局部变量 变_Text, 文本型
    .局部变量 变_btx, 变体型
    .局部变量 变_type, 文本型

    CoInitialize (0)
    变_btx.赋值 (参_欲转换的内容, )
    .如果真 (变_Dx.创建 (“Adodb.Stream”, ) ＝ 假)
        返回 (“”)
    .如果真结束
    变_Dx.写属性 (“Type”, 1)
    变_Dx.写属性 (“Mode”, 3)
    变_Dx.方法 (“Open”, )
    变_Dx.方法 (“Write”, 变_btx)
    变_Dx.写属性 (“Position”, 0)
    变_Dx.写属性 (“Type”, 2)
    变_Dx.写属性 (“Charset”, “unicode”)
    变_Text ＝ 变_Dx.文本方法 (“ReadText”, )
    变_Dx.方法 (“Close”, )
    CoUninitialize ()
    返回 (变_Text)

.子程序 编码_ansi到usc2, 文本型, 公开, 将ansi转变成usc2  如 123 转换后为 %u0031%u0032%u0033 失败返回空文本
    .参数 欲转换的文本, 文本型
    .参数 是否不转换括号, 逻辑型, 可空, 可空。默认为假，转换。 真 = 不转换 { }[ ]( ) 等括号，注意；不处理全角字符串
    .参数 是否不转换符号, 逻辑型, 可空, 可空。默认为假，转换。 真 = 不转换:," 等符号
    .参数 分割符, 文本型, 可空, 可空。默认为：%u  如填：%u,返回的数据如:%u0031%u0032%u0033，填\u，返回的数据如:\u0031\u0032\u0033
    .局部变量 脚本对象, 对象
    .局部变量 局_文本, 文本型

    局_文本 ＝ 子文本替换 (欲转换的文本, “'”, “’”, , , 真)
    线程_初始化COM库 ()
    脚本对象.创建 (“ScriptControl”, )
    脚本对象.写属性 (“Language”, “JScript”)
    脚本对象.数值方法 (“ExecuteStatement”, “function xx(){var x='” ＋ 局_文本 ＋ “';return escape(x);}”)
    局_文本 ＝ 脚本对象.文本方法 (“Run”, “xx”)
    脚本对象.清除 ()
    线程_取消COM库 ()
    .如果真 (是否不转换括号)
        局_文本 ＝ 子文本替换 (局_文本, “%7B”, “{”, , , 真)
        局_文本 ＝ 子文本替换 (局_文本, “%7D”, “}”, , , 真)
        局_文本 ＝ 子文本替换 (局_文本, “%5B”, “[”, , , 真)
        局_文本 ＝ 子文本替换 (局_文本, “%5D”, “]”, , , 真)
        局_文本 ＝ 子文本替换 (局_文本, “%28”, “(”, , , 真)
        局_文本 ＝ 子文本替换 (局_文本, “%29”, “)”, , , 真)
    .如果真结束
    .如果真 (是否不转换符号)
        局_文本 ＝ 子文本替换 (局_文本, “%3A”, “:”, , , 真)
        局_文本 ＝ 子文本替换 (局_文本, “%2C”, “,”, , , 真)
        局_文本 ＝ 子文本替换 (局_文本, “%22”, #引号, , , 真)
    .如果真结束
    
    .如果真 (分割符 ≠ “%u” 且 删首尾空 (分割符) ≠ “”)
        局_文本 ＝ 子文本替换 (局_文本, “%u”, 分割符, , , 真)
    .如果真结束
    返回 (子文本替换 (局_文本, “’”, “'”, , 取文本长度 (局_文本), 真))

.子程序 编码_usc2到Unicode, 字节集, 公开, \uD83D\uDD25\uD83D\uDCE6 => { 61, 216, 37, 221, 61, 216, 230, 220, 0, 0 }
    .参数 欲转换的文本, 文本型
    .局部变量 coding, 文本型
    .局部变量 script, 对象
    .局部变量 variant, 变体型

    CoInitialize (#NULL)
    script.创建 (“ScriptControl”, )
    script.写属性 (“Language”, “JScript”)
    script.方法 (“AddCode”, “function ascii2native(result){var character=result.split('\\u');var native1=character[0];for(var i=1;i<character.length;i++){var code=character[i];native1+=String.fromCharCode(parseInt('0x'+code.substring(0,4)));if(code.length>4){native1+=code.substring(4,code.length)}}return native1}”)
    coding ＝ 子文本替换 (欲转换的文本, “\”, “\\”, , , 真)
    coding ＝ 子文本替换 (coding, #引号, “\” ＋ #引号, , , 真)
    coding ＝ 子文本替换 (coding, #换行符, “\r\n”, , , 真)
    variant ＝ script.通用方法 (“Eval”, “ascii2native(” ＋ #引号 ＋ coding ＋ #引号 ＋ “)”)
    VariantToSize (取数据_通用型 (variant))
    script.清除 ()
    CoUninitialize ()
    返回 (variant.取字节集 ())

.子程序 编码_Unicode到usc2, 文本型, 公开, { 61, 216, 37, 221, 61, 216, 230, 220 } => \uD83D\uDD25\uD83D\uDCE6
    .参数 欲转换的Unicode, 字节集
    .参数 不转换字母和数字, 逻辑型, 可空, a-z A-Z 0-9
    .参数 不转换标点符号, 逻辑型, 可空, !"#$%&'()*+,-./:;<=>?@[\]^_`{|}~
    .局部变量 dwSize, 整数型
    .局部变量 szBuf, 字节集
    .局部变量 pszBuf, 整数型
    .局部变量 sChar, 整数型
    .局部变量 ptr, 整数型
    .局部变量 i, 整数型

    dwSize ＝ 文本_取长度W (欲转换的Unicode)
    .如果真 (dwSize ＝ 0)
        返回 (“”)
    .如果真结束
    dwSize ＝ dwSize × 6 ＋ 1
    szBuf ＝ 取空白字节集 (dwSize)
    pszBuf ＝ 取指针_字节集型 (szBuf)
    ptr ＝ 取指针_字节集型 (欲转换的Unicode)
    .变量循环首 (0, 取字节集长度 (欲转换的Unicode) － 2, 2, i)
        sChar ＝ __get_short (ptr, i)
        .判断开始 (sChar ＝ 0)
            跳出循环 ()
        .判断 (sChar ≥ 97 且 sChar ≤ 122 或 (sChar ≥ 65 且 sChar ≤ 90) 或 (sChar ≥ 48 且 sChar ≤ 57)) ' a-z || A-Z || 0-9
            .如果真 (不转换字母和数字)
                __set_byte (pszBuf, 0, 到字节 (sChar))
                pszBuf ＝ pszBuf ＋ 1
                到循环尾 ()
            .如果真结束
            
        .判断 (sChar ≥ 32 且 sChar ≤ 47 或 (sChar ≥ 58 且 sChar ≤ 64) 或 (sChar ≥ 91 且 sChar ≤ 96) 或 (sChar ≥ 123 且 sChar ≤ 126)) ' 包括空格
            .如果真 (不转换标点符号)
                __set_byte (pszBuf, 0, 到字节 (sChar))
                pszBuf ＝ pszBuf ＋ 1
                到循环尾 ()
            .如果真结束
            
        .默认
            
        .判断结束
        pszBuf ＝ pszBuf ＋ sprintf (pszBuf, “\u%04X”, sChar)
    .变量循环尾 ()
    返回 (取字节集数据 (szBuf, #文本型, ))

.子程序 编码_usc2到ansi_EX, 文本型, 公开, 将usc2转变成ansi  如 %u0031%u0032%u0033 转换后为 123 失败返回空文本
    .参数 欲转换的文本, 文本型
    .参数 分割符, 文本型, , 如:%u0031%u0032%u0033，分隔符填：%u
    .局部变量 Usc2, 文本型, , , 欲转换的Ucs2编码的16进制文本
    .局部变量 Script, 对象
    .局部变量 sbuffer, 文本型

    Usc2 ＝ 子文本替换 (欲转换的文本, 分割符, “%u”, , , 真)
    CoInitialize (0)
    Script.创建 (“ScriptControl”, )
    Script.写属性 (“Language”, “JScript”)
    Script.数值方法 (“ExecuteStatement”, “function xx(){var x='” ＋ Usc2 ＋ “';return unescape(x);}”)
    sbuffer ＝ Script.文本方法 (“Run”, “xx”)
    Script.清除 ()
    CoUninitialize ()
    返回 (sbuffer)

.子程序 编码_ansi到usc2_EX, 文本型, 公开, 将ansi转变成usc2   如 123 转换后为 %u0031%u0032%u0033 失败返回空文本
    .参数 欲转换的文本, 文本型
    .参数 分割符, 文本型, , 如填：%u,返回的数据如:%u0031%u0032%u0033
    .参数 是否不转换括号, 逻辑型, 可空, 可空。默认为假，转换。 真 = 不转换 { }[ ]( ) 等括号
    .参数 是否不转换符号, 逻辑型, 可空, 可空。默认为假，转换。 真 = 不转换:," 等符号
    .局部变量 Unicode, 字节集
    .局部变量 len, 整数型
    .局部变量 i, 整数型
    .局部变量 allUsc2, 文本型
    .局部变量 oneUsc2, 文本型, , , EX加强版 由“御风软件”提供

    Unicode ＝ 编码_Ansi到Unicode (欲转换的文本, )
    len ＝ 文本_取长度W (Unicode)
    .计次循环首 (len, i)
        oneUsc2 ＝ 取文本右边 (“00” ＋ 取十六进制文本 (Unicode [i × 2]), 2) ＋ 取文本右边 (“00” ＋ 取十六进制文本 (Unicode [i × 2 － 1]), 2)
        oneUsc2 ＝ 分割符 ＋ oneUsc2
        allUsc2 ＝ allUsc2 ＋ oneUsc2
    .计次循环尾 ()
    .如果真 (是否不转换括号)
        allUsc2 ＝ 子文本替换 (allUsc2, 分割符 ＋ “007B”, “{”, , , 真)
        allUsc2 ＝ 子文本替换 (allUsc2, 分割符 ＋ “007D”, “}”, , , 真)
        allUsc2 ＝ 子文本替换 (allUsc2, 分割符 ＋ “005B”, “[”, , , 真)
        allUsc2 ＝ 子文本替换 (allUsc2, 分割符 ＋ “005D”, “]”, , , 真)
    .如果真结束
    .如果真 (是否不转换符号)
        allUsc2 ＝ 子文本替换 (allUsc2, 分割符 ＋ “003A”, “:”, , , 真)
        allUsc2 ＝ 子文本替换 (allUsc2, 分割符 ＋ “002C”, “,”, , , 真)
        allUsc2 ＝ 子文本替换 (allUsc2, 分割符 ＋ “0022”, #引号, , , 真)
    .如果真结束
    返回 (allUsc2)

.子程序 编码_utf8到gb2312, 文本型, 公开
    .参数 欲转换的源码, 文本型

    返回 (编码_Unicode到Ansi (Ansi到Unicode (欲转换的源码, #CP_UTF8)))

.子程序 编码_gb2312到utf8, 文本型, 公开
    .参数 欲转换的源码, 文本型

    返回 (Unicode到Ansi (编码_Ansi到Unicode (欲转换的源码, ), #CP_UTF8))

.子程序 编码_ASCII到Unicode, 字节集, 公开, 已弃用！请使用 编码_Ansi到Unicode
    .参数 ASCII文本, 文本型, , 欲转换的ASCII文本

    返回 (Ansi到Unicode (ASCII文本, m_CodePage))

.子程序 编码_U编码转换, 文本型, 公开, 默认转换类型为to16un
    .参数 要转的文本, 文本型
    .参数 转换类型, 文本型, 可空, to16on to16un to10on to10un
    .局部变量 js, 类_脚本组件

    .如果真 (是否为空 (转换类型))
        转换类型 ＝ “to16un”
    .如果真结束
    js.执行 (#U码)
    返回 (js.运行 (转换类型, 要转的文本))

.子程序 编码_Unicode到Ansi, 文本型, 公开, 将Unicode码转换为Ansi码；成功返回转换后的文本；
    .参数 Unicode, 字节集, , 欲转换的Unicode字节集

    返回 (Unicode到Ansi (Unicode, m_CodePage))

.子程序 编码_Unicode到Ansi_对象, 文本型, 公开, 带BOM头信息编码转换。
    .参数 欲转换的文本, 字节集
    .局部变量 Dx, 对象
    .局部变量 Text, 文本型
    .局部变量 btx, 变体型
    .局部变量 type, 文本型

    CoInitialize (0)
    btx.赋值 (欲转换的文本, )
    .如果真 (Dx.创建 (“Adodb.Stream”, ) ＝ 假)
        返回 (“”)
    .如果真结束
    Dx.写属性 (“Type”, 1)
    Dx.写属性 (“Mode”, 3)
    Dx.方法 (“Open”, )
    Dx.方法 (“Write”, btx)
    Dx.写属性 (“Position”, 0)
    Dx.写属性 (“Type”, 2)
    Dx.写属性 (“Charset”, “unicode”)
    Text ＝ Dx.文本方法 (“ReadText”, )
    Dx.方法 (“Close”, )
    CoUninitialize ()
    返回 (Text)

.子程序 编码_Ansi到Unicode, 字节集, 公开, 将Ansi码转换为Unicode码；成功返回转换后的字节集；
    .参数 Ansi, 文本型, , 欲转换的Ansi文本
    .参数 非标准Unicode编码, 逻辑型, 可空, 默认为假，为标准Unicode编码
    .局部变量 szChar, 字节集

    szChar ＝ A2W_CP (到字节集 (Ansi), m_CodePage)
    .如果真 (非标准Unicode编码)
        szChar ＝ 删除Unicode结尾空白字节 (szChar)
    .如果真结束
    返回 (szChar)

.子程序 编码_Unicode到Ansi_文本型, 文本型, 公开, 将Unicode码转换为Ansi码，成功返回转换后的文本。
    .参数 UniCode文本, 文本型, , 欲转换的Unicode文本，如：“&#31934&#26131&#-29766&#22363”
    .局部变量 arrChar, 文本型, , "0"
    .局部变量 szChar, 字节集
    .局部变量 iTemp, 整数型
    .局部变量 len, 整数型
    .局部变量 i, 整数型
    .局部变量 n, 整数型

    arrChar ＝ 分割文本 (UniCode文本, “&#”, )
    len ＝ 取数组成员数 (arrChar)
    .如果真 (len ＞ 1)
        szChar ＝ 取空白字节集 ((len － 1) × 2 ＋ 1)
        .变量循环首 (2, len, 1, i)
            .如果 (寻找文本 (arrChar [i], “x”, , 真) ＝ 1)
                iTemp ＝ 进制_十六到十 (取文本中间 (arrChar [i], 2, 4))
            .否则
                iTemp ＝ 到整数 (arrChar [i])
            .如果结束
            __set_byte (取指针字节集_ (szChar), n, LOBYTE (iTemp))
            __set_byte (取指针字节集_ (szChar), n ＋ 1, HIBYTE (iTemp))
            n ＝ n ＋ 2
        .变量循环尾 ()
        szChar ＝ W2A_CP (szChar, m_CodePage)
    .如果真结束
    返回 (取字节集数据 (szChar, #文本型, ))

.子程序 编码_Ansi到Unicode_文本型, 文本型, 公开, 将Ansi码转换为Unicode码，如：将“精易论坛”转换后将返回格式如：“&#31934&#26131&#-29766&#22363”
    .参数 Ansi, 文本型, , 欲转换的文本，如：“精易论坛”。
    .局部变量 szChar, 字节集

    szChar ＝ 编码_Ansi到Unicode (Ansi, 真)
    返回 (编码_Unicode转实体编号 (szChar))

.子程序 编码_Unicode转实体编号, 文本型, 公开, HTML实体编号是一段以连字号加井号(&#)开头、以分号(;)结尾的文本(字符串)
    .参数 欲转换的数据, 字节集
    .参数 是否以分号结尾, 逻辑型, 可空, 默认为假
    .局部变量 pByte, 整数型
    .局部变量 szByte, 字节集
    .局部变量 wBuf, 整数型
    .局部变量 len, 整数型
    .局部变量 i, 整数型
    .局部变量 n, 整数型

    len ＝ 取字节集长度 (欲转换的数据)
    .如果真 (len ＞ 1)
        szByte ＝ 取空白字节集 (len × 选择 (是否以分号结尾, 6, 5) ＋ 1) ' 5是短整数最大值32767转Ascii占用的长度
        pByte ＝ 取指针字节集_ (szByte)
        .变量循环首 (1, len, 2, i)
            wBuf ＝ MAKEWORD (欲转换的数据 [i], 欲转换的数据 [i ＋ 1])
            .如果真 (wBuf ＝ 0)
                跳出循环 ()
            .如果真结束
            n ＝ n ＋ sprintf (pByte ＋ n, 选择 (是否以分号结尾, “&#%d;”, “&#%d”), wBuf)
        .变量循环尾 ()
    .如果真结束
    返回 (取字节集数据 (szByte, #文本型, ))

.子程序 编码_Ansi到ASCII_文本型, 文本型, 公开, 此代码由易友【菜虫】提供， 将Ansi码转换为ASCII码，如：将“精易论坛”转换后将返回格式如：“&#48811&#53975&#49883&#52403”
    .参数 Ansi, 文本型, , 欲转换的文本，如：“精易论坛”。
    .局部变量 长度, 整数型
    .局部变量 i, 小数型
    .局部变量 长度2, 整数型
    .局部变量 数据, 字节集
    .局部变量 局_文本, 文本型

    .如果真 (删首尾空 (Ansi) ＝ “”)
        返回 (“”)
    .如果真结束
    
    长度 ＝ 1
    .循环判断首 ()
        i ＝ i ＋ 1
        长度2 ＝ 取文本长度 (Ansi)
        数据 ＝ 到字节集 (取文本中间 (Ansi, i × 2 － 长度, 2))
        .如果 (数据 [1] ＜ 128)
            长度 ＝ 1 ＋ 长度
            局_文本 ＝ 局_文本 ＋ “&#” ＋ 到文本 (数据 [1])
        .否则
            局_文本 ＝ 局_文本 ＋ “&#” ＋ 到文本 (数据 [1] × 256 ＋ 数据 [2])
        .如果结束
        
    .循环判断尾 (i × 2 － 长度 ＋ 1 ＜ 取文本长度 (Ansi))
    返回 (局_文本)

.子程序 编码_Utf8到Unicode, 字节集, 公开, 将UTF8数据转换到Unicode
    .参数 utf8字节集, 字节集

    返回 (A2W_CP (utf8字节集, #CP_UTF8))

.子程序 编码_Unicode到Utf8, 字节集, 公开, 将Unicode转换到UTF8
    .参数 Unicode字节集, 字节集

    返回 (W2A_CP (Unicode字节集, #CP_UTF8))

.子程序 编码_Ansi到Utf8, 字节集, 公开
    .参数 ansi文本, 文本型

    返回 (W2A_CP (编码_Ansi到Unicode (ansi文本, ), #CP_UTF8))

.子程序 编码_Ansi到Utf8_对象, 字节集, 公开
    .参数 文本, 文本型
    .局部变量 stream, 对象
    .局部变量 string, 变体型

    线程_初始化COM库 ()
    .如果真 (stream.创建 (“adodb.stream”, ) ＝ 假)
        返回 ({ })
    .如果真结束
    stream.写属性 (“Type”, 2) ' text
    stream.写属性 (“Charset”, “utf-8”)
    stream.方法 (“Open”, )
    stream.方法 (“WriteText”, 文本)
    stream.写属性 (“Position”, 0)
    stream.写属性 (“Type”, 1) ' 二进制
    string ＝ stream.通用方法 (“Read”, stream.读数值属性 (“Size”, ))
    stream.方法 (“Close”, )
    线程_取消COM库 ()
    返回 (string.取字节集 ())

.子程序 编码_Utf8到Ansi, 文本型, 公开
    .参数 utf8字节集, 字节集

    返回 (编码_Unicode到Ansi (A2W_CP (utf8字节集, #CP_UTF8)))

.子程序 编码_Utf8到Ansi_对象, 文本型, 公开
    .参数 欲转换的文本, 字节集
    .局部变量 Dx, 对象
    .局部变量 Text, 文本型
    .局部变量 btx, 变体型
    .局部变量 type, 文本型

    CoInitialize (0)
    btx.赋值 (欲转换的文本, )
    .如果真 (Dx.创建 (“Adodb.Stream”, ) ＝ 假)
        返回 (“”)
    .如果真结束
    Dx.写属性 (“Type”, 1)
    Dx.写属性 (“Mode”, 3)
    Dx.方法 (“Open”, )
    Dx.方法 (“Write”, btx)
    Dx.写属性 (“Position”, 0)
    Dx.写属性 (“Type”, 2)
    Dx.写属性 (“Charset”, “UTF-8”)
    Text ＝ Dx.文本方法 (“ReadText”, )
    Dx.方法 (“Close”, )
    CoUninitialize ()
    返回 (Text)

.子程序 编码_BIG5到繁体, 文本型, 公开
    .参数 待转换文本, 文本型

    返回 (编码_Unicode到Ansi (Ansi到Unicode (待转换文本, #CP_BIG5)))

.子程序 编码_BIG5到简体, 文本型, 公开
    .参数 待转换文本, 文本型

    返回 (编码_繁体到简体 (编码_BIG5到繁体 (待转换文本)))

.子程序 编码_繁体到BIG5, 文本型, 公开
    .参数 待转换文本, 文本型

    返回 (Unicode到Ansi (编码_Ansi到Unicode (待转换文本, ), #CP_BIG5))

.子程序 编码_简体到BIG5, 文本型, 公开
    .参数 待转换文本, 文本型

    返回 (编码_繁体到BIG5 (编码_简体到繁体 (待转换文本)))

.子程序 编码_Ansi到Unicode_JS, 文本型, 公开
    .参数 待转文本, 文本型
    .局部变量 script, 对象
    .局部变量 ret, 文本型
    .局部变量 str, 文本型

    ' https://bbs.125.la/thread-14448656-1-1.html
    CoInitialize (0)
    script.创建 (“scriptcontrol”, )
    script.写属性 (“Language”, “JScript”)
    str ＝ “var Unicode = function(str){return escape(str).replace(/%/g,” ＋ #引号 ＋ “\\” ＋ #引号 ＋ “).toLowerCase();}”
    script.文本方法 (“Eval”, str)
    ret ＝ script.文本方法 (“Run”, “Unicode”, 待转文本)
    CoUninitialize ()
    返回 (ret)

.子程序 编码_Unicode到Ansi_JS, 文本型, 公开
    .参数 待转文本, 文本型
    .局部变量 script, 对象
    .局部变量 ret, 文本型
    .局部变量 str, 文本型

    ' https://bbs.125.la/thread-14448656-1-1.html
    CoInitialize (0)
    script.创建 (“scriptcontrol”, )
    script.写属性 (“Language”, “JScript”)
    str ＝ “var unUnicode = function(str){return unescape(str.replace(/\\/g,” ＋ #引号 ＋ “%” ＋ #引号 ＋ “));}”
    script.文本方法 (“Eval”, str)
    ret ＝ script.文本方法 (“Run”, “unUnicode”, 待转文本)
    CoUninitialize ()
    返回 (ret)

.子程序 编码_Base64转图片, 字节集, 公开, 成功返回图片，失败返回空字节集
    .参数 Base64, 文本型, , data:image/xxx;base64,
    .局部变量 局_Base64, 文本型

    局_Base64 ＝ Base64
    .如果真 (局_Base64 ≈ “data:image/jpg;base64,” 或 局_Base64 ≈ “data:image/jpeg;base64,” 或 局_Base64 ≈ “data:image/gif;base64,” 或 局_Base64 ≈ “data:image/bmp;base64,” 或 局_Base64 ≈ “data:image/png;base64,” 或 局_Base64 ≈ “data:image/ico;base64,”)
        局_Base64 ＝ 文本_取右边 (局_Base64, “,”, , ) ' data:image/xxx;base64,
        局_Base64 ＝ 子文本替换 (局_Base64, “\n”, , , , 真)
        返回 (编码_BASE64解码 (局_Base64, ))
    .如果真结束
    输出调试文本 (“格式错误，只支持.jpg/.jpeg/.gif/.bmp/.png/.ico等开头的格式！如：data:image/jpeg;base64,xxx”)
    返回 ({ })

.子程序 bin2hex, 文本型, 公开, 字节集转十六进制文本:快速
    .参数 src, 字节集
    .局部变量 dst, 文本型
    .局部变量 len, 整数型

    ' http://bbs.125.la/forum.php?mod=redirect&goto=findpost&ptid=14619753&pid=19663060
    置入代码 ({ 139, 69, 8, 86, 139, 48, 133, 246, 117, 4, 49, 192, 235, 5, 139, 70, 4, 3, 192, 137, 69, 248 })
    dst ＝ 取空白文本 (len)
    置入代码 ({ 133, 246, 116, 5, 139, 78, 4, 133, 201, 116, 83, 141, 86, 8, 199, 69, 236, 48, 49, 50, 51, 199, 69, 240, 52, 53, 54, 55, 199, 69, 244, 56, 57, 65, 66, 199, 69, 248, 67, 68, 69, 70, 133, 210, 116, 48, 133, 192, 116, 44, 141, 52, 10, 59, 214, 115, 37, 144, 15, 182, 10, 193, 233, 4, 66, 15, 182, 76, 13, 236, 136, 8, 15, 182, 74, 255, 131, 225, 15, 141, 64, 2, 15, 182, 76, 13, 236, 136, 72, 255, 59, 214, 114, 220, 94 })
    ' __start
    ' 取消该处代码,易语言将申请新的内存区域来存放dst，看起来是没作用的,觉得有必要的可注释掉本区域代码
    置入代码 ({ 139, 69, 252 }) ' mov eax,[ebp-0x4]
    置入代码 ({ 201 }) ' leave
    置入代码 ({ 194, 4, 0 }) ' retn 4
    ' __end
    返回 (dst)

.子程序 hex2bin, 字节集, 公开, 十六进制文本转字节集(未2字节对齐情况下将忽略最后一位):快速
    .参数 src, 文本型
    .局部变量 bin, 字节集
    .局部变量 len, 整数型

    ' http://bbs.125.la/forum.php?mod=redirect&goto=findpost&ptid=14619753&pid=19663060
    置入代码 ({ 139, 69, 8, 86, 139, 48, 133, 246, 117, 4, 49, 192, 235, 20, 139, 206, 141, 81, 1, 139, 255, 138, 1, 65, 132, 192, 117, 249, 43, 202, 139, 193, 209, 232, 137, 69, 248, 81 })
    bin ＝ 取空白字节集 (len)
    置入代码 ({ 89, 133, 246, 116, 91, 83, 87, 141, 28, 14, 139, 69, 252, 139, 192, 141, 120, 8, 59, 243, 115, 72, 139, 255, 15, 190, 14, 141, 65, 159, 131, 248, 25, 119, 3, 131, 193, 224, 15, 190, 86, 1, 141, 66, 159, 131, 248, 25, 119, 3, 131, 194, 224, 131, 198, 2, 128, 249, 57, 118, 5, 128, 233, 55, 235, 3, 128, 233, 48, 128, 250, 57, 118, 5, 128, 234, 55, 235, 3, 128, 234, 48, 192, 225, 4, 10, 202, 136, 15, 71, 59, 243, 114, 186, 95, 91, 94 })
    ' __start
    ' 取消该处代码,易语言将申请新的内存区域来存放dst，看起来是没作用的,觉得有必要的可注释掉本区域代码
    置入代码 ({ 139, 69, 252 }) ' mov eax,[ebp-0x4]
    置入代码 ({ 201 }) ' leave
    置入代码 ({ 194, 4, 0 }) ' retn 4
    ' __end
    返回 (bin)

.子程序 分隔子程序0, , , ●●●●●●●●●●●●●●●●●●进制转换●●●●●●●●●●●●●●●●●●
    

.子程序 进制_二到十, 整数型, 公开, 将二进制转换成十进制(返回十进制整数)  @福仔
    .参数 二进制文本, 文本型, , 欲转换的二进制
    .局部变量 bin, 字节集
    .局部变量 i, 整数型
    .局部变量 len, 整数型
    .局部变量 ret, 整数型

    bin ＝ 到字节集 (取文本右边 (删全部空 (二进制文本), 32))
    len ＝ 取字节集长度 (bin)
    ret ＝ 0
    .计次循环首 (len, i)
        .如果真 (bin [len ＋ 1 － i] ＝ 49)
            ret ＝ __set_bit_on (ret, i － 1)
        .如果真结束
        
    .计次循环尾 ()
    返回 (ret)

.子程序 进制_十到二, 文本型, 公开, 将十进制转换成二进制  @福仔
    .参数 十进制数, 整数型
    .局部变量 bit, 字节集
    .局部变量 i, 整数型

    bit ＝ 取重复字节集 (32, { 48 }) ' 48="0"
    .计次循环首 (32, i)
        .如果真 (__query_bit (十进制数, i － 1))
            bit [32 － i ＋ 1] ＝ 49 ' 49="1"
        .如果真结束
        
    .计次循环尾 ()
    返回 (到文本 (bit))

.子程序 进制_八到十, 整数型, 公开, 将八进制转换成十进制(返回十进制整数)
    .参数 八进制文本, 文本型, , 欲转换的八进制文本
    .局部变量 计次, 整数型
    .局部变量 结果, 整数型

    .计次循环首 (取文本长度 (八进制文本), 计次)
        结果 ＝ 结果 ＋ 到数值 (取文本中间 (八进制文本, 计次, 1)) × 求次方 (8, 取文本长度 (八进制文本) － 计次)
    .计次循环尾 ()
    返回 (结果)

.子程序 进制_十到八, 文本型, 公开, 将十进制转换成八进制(返回八进制文本)
    .参数 十进制数, 长整数型, , 欲转换的十进制数
    .局部变量 余数, 长整数型, , "0"
    .局部变量 八进制文本, 文本型
    .局部变量 计次, 整数型

    .循环判断首 ()
        加入成员 (余数, 十进制数 ％ 8)
        十进制数 ＝ 十进制数 ÷ 8
        .如果真 (十进制数 ＜ 8)
            加入成员 (余数, 取整 (十进制数))
            跳出循环 ()
        .如果真结束
        
    .循环判断尾 (真)
    .计次循环首 (取数组成员数 (余数), 计次)
        八进制文本 ＝ 八进制文本 ＋ 到文本 (余数 [取数组成员数 (余数) － 计次 ＋ 1])
    .计次循环尾 ()
    .如果真 (取文本左边 (八进制文本, 1) ＝ “0”)
        八进制文本 ＝ 转换去除首部零 (八进制文本)
    .如果真结束
    返回 (八进制文本)

.子程序 进制_十到十六, 文本型, 公开, 十进制到十六进制（支持负数）@LLJ
    .参数 十进制长整数, 长整数型, , 不支持无符号长整数型，易BUG，超过15位长整数型，不能直接使用，必须 用 到长整数()转换
    .参数 是否在前端补零, 逻辑型, 可空, 如果为真，则自动在前面补0，补足位数。如果为假，则不补零；默认为假
    .局部变量 局部_低32位, 整数型, , , ebp-0x8
    .局部变量 局部_高32位, 整数型, , , ebp-0xc
    .局部变量 局部_结果, 文本型, , , ebp-0x4
    .局部变量 零的个数, 整数型
    .局部变量 i, 整数型
    .局部变量 是否为长整数, 逻辑型
    .局部变量 dwBufLen, 整数型

    置入代码 ({ 139, 69, 8, 137, 69, 248, 139, 69, 12, 137, 69, 244 })
    ' mov eax,[ebp+0x08]
    ' mov [ebp-0x08],eax
    ' mov eax,[ebp+0x0c]
    ' mov [ebp-0x0c],eax
    局部_结果 ＝ _十进制 (局部_低32位)
    .如果真 (局部_高32位 ≠ 0)
        局部_结果 ＝ _十进制 (局部_高32位) ＋ 局部_结果
        是否为长整数 ＝ 真
    .如果真结束
    
    dwBufLen ＝ 取文本长度 (局部_结果)
    .如果 (是否在前端补零 ＝ 假)
        .计次循环首 (dwBufLen, i)
            .如果 (取文本中间 (局部_结果, i, 1) ＝ “0” 且 i ＜ dwBufLen)
                零的个数 ＝ 零的个数 ＋ 1
            .否则
                跳出循环 ()
            .如果结束
            
        .计次循环尾 ()
        局部_结果 ＝ 取文本右边 (局部_结果, dwBufLen － 零的个数)
        ' 去掉前面所有的0
    .否则
        .如果真 (是否为长整数 ＝ 真)
            局部_结果 ＝ 取重复文本 (16 － dwBufLen, “0”) ＋ 局部_结果
        .如果真结束
        
    .如果结束
    
    返回 (局部_结果)

.子程序 进制_十六到十, 长整数型, 公开, 感谢【@haishifu 】优化
    .参数 参_十六进制文本, 文本型, , 字母不区分大小写
    .局部变量 局_十六进制文本字节集, 字节集
    .局部变量 局_十六进制缓冲, 字节集
    .局部变量 局_记录, 整数型
    .局部变量 局_长度, 整数型
    .局部变量 i, 整数型
    .局部变量 局_字节, 字节型
    .局部变量 局_高位, 整数型
    .局部变量 局_低位, 整数型
    .局部变量 局_结果, 长整数型

    局_十六进制文本字节集 ＝ 到字节集 (参_十六进制文本)
    局_长度 ＝ 取字节集长度 (局_十六进制文本字节集)
    
    局_十六进制缓冲 ＝ 取空白字节集 (16)
    局_记录 ＝ 16
    
    .计次循环首 (局_长度, i)
        局_字节 ＝ 局_十六进制文本字节集 [局_长度 － i ＋ 1]
        .判断开始 (局_字节 ＞ 47 且 局_字节 ＜ 58)
            局_十六进制缓冲 [局_记录] ＝ 局_字节 － 48
            局_记录 ＝ 局_记录 － 1
            
        .判断 (局_字节 ＞ 64 且 局_字节 ＜ 71)
            局_十六进制缓冲 [局_记录] ＝ 局_字节 － 55
            局_记录 ＝ 局_记录 － 1
            
        .判断 (局_字节 ＞ 96 且 局_字节 ＜ 103)
            局_十六进制缓冲 [局_记录] ＝ 局_字节 － 87
            局_记录 ＝ 局_记录 － 1
        .默认
            
        .判断结束
        
        .如果真 (局_记录 ＜ 1)
            跳出循环 ()
        .如果真结束
        
    .计次循环尾 ()
    
    局_低位 ＝ 局_十六进制缓冲 [9] × 268435456 ＋ 局_十六进制缓冲 [10] × 16777216 ＋ 局_十六进制缓冲 [11] × 1048576 ＋ 局_十六进制缓冲 [12] × 65536 ＋ 局_十六进制缓冲 [13] × 4096 ＋ 局_十六进制缓冲 [14] × 256 ＋ 局_十六进制缓冲 [15] × 16 ＋ 局_十六进制缓冲 [16]
    
    局_高位 ＝ 局_十六进制缓冲 [1] × 268435456 ＋ 局_十六进制缓冲 [2] × 16777216 ＋ 局_十六进制缓冲 [3] × 1048576 ＋ 局_十六进制缓冲 [4] × 65536 ＋ 局_十六进制缓冲 [5] × 4096 ＋ 局_十六进制缓冲 [6] × 256 ＋ 局_十六进制缓冲 [7] × 16 ＋ 局_十六进制缓冲 [8]
    
    内部_汇编复制内存 (取指针_通用型 (局_结果) ＋ 4, 取指针_通用型 (局_高位), 4)
    内部_汇编复制内存 (取指针_通用型 (局_结果), 取指针_通用型 (局_低位), 4)
    返回 (局_结果)
    

.子程序 进制_十六到十_汇编, 整数型, 公开, 遇到错误时终止；@混沌在此
    .参数 十六进制, 文本型

    ' 该命令收录自：https://bbs.125.la/thread-14334303-1-1.html
    置入代码 ({ 49, 192, 139, 93, 8, 139, 27, 133, 219, 116, 55, 49, 210, 138, 19, 67, 128, 250, 57, 119, 10, 128, 250, 48, 114, 5, 128, 234, 48, 235, 28, 128, 250, 70, 119, 10, 128, 250, 65, 114, 5, 128, 234, 55, 235, 13, 128, 250, 102, 119, 15, 128, 250, 97, 114, 10, 128, 234, 87, 193, 224, 4, 1, 208, 235, 203, 93, 194, 4, 0 })
    返回 (0)

.子程序 内部_汇编复制内存
    .参数 目的地址, 整数型, , 缓冲区长度需大于或等于长度
    .参数 源地址, 整数型
    .参数 长度, 整数型

    置入代码 ({ 96, 139, 77, 16, 139, 125, 8, 139, 117, 12, 243, 164, 97 })
    

.子程序 _十进制, 文本型
    .参数 十进制整数, 整数型
    .局部变量 ret, 文本型

    ret ＝ 取空白文本 (8)
    置入代码 ({ 139, 69, 8, 87, 139, 125, 252, 49, 201, 177, 8, 80, 36, 15, 60, 9, 119, 4, 4, 48, 235, 2, 4, 55, 136, 68, 15, 255, 88, 193, 232, 4, 226, 233, 95 })
    ' mov eax,dword[ebp+0x8]
    ' push edi
    ' mov edi,dword[ebp-4]
    ' xor ecx,ecx
    ' mov cl ,byte 8
    ' a:
    ' push eax
    ' and al,0xf
    ' cmp al,byte 9
    ' ja b
    ' add al, 48 ;数字
    ' jmp short c
    ' b:
    ' add al,55 ;字母
    ' c:
    ' mov byte [edi+ecx-1], al
    ' pop eax
    ' shr eax,4 ;右移4位 相当于除以16
    ' loop a
    ' pop edi
    返回 (ret)

.子程序 _十六进制, 整数型
    .参数 十六进制文本, 文本型
    .局部变量 局部_十六进制, 字节集
    .局部变量 局部_计次, 整数型
    .局部变量 局部_十六进制数, 整数型
    .局部变量 局部_结果, 整数型

    局部_十六进制 ＝ 到字节集 (十六进制文本)
    .计次循环首 (取字节集长度 (局部_十六进制), 局部_计次)
        .判断开始 (局部_十六进制 [局部_计次] ≥ 97) ' 十六进制 [计次] ≤ 102
            局部_十六进制数 ＝ 局部_十六进制 [局部_计次] － 87 ' 小写
        .判断 (局部_十六进制 [局部_计次] ≥ 65) ' 十六进制 [计次] ≤ 70
            局部_十六进制数 ＝ 局部_十六进制 [局部_计次] － 55 ' 大写
        .默认
            局部_十六进制数 ＝ 局部_十六进制 [局部_计次] － 48 ' 数字
        .判断结束
        局部_结果 ＝ 左移 (局部_结果, 4) ＋ 局部_十六进制数 ' 左移4位 相当于乘以16
    .计次循环尾 ()
    返回 (局部_结果)

.子程序 转换去除首部零, 文本型
    .参数 文本, 文本型
    .局部变量 计次, 整数型

    .计次循环首 (取文本长度 (文本), 计次)
        .如果真 (取文本中间 (文本, 计次, 1) ≠ “0”)
            跳出循环 ()
        .如果真结束
        
    .计次循环尾 ()
    返回 (取文本右边 (文本, 取文本长度 (文本) － 计次 ＋ 1))

.子程序 进制_二八十六到十, 整数型, 公开, 将非十进制的标准格式文本转换成十进制整数值
    .参数 欲转换的值, 文本型, , 欲转换的值，文本型！
    .参数 数值类型, 整数型, 可空, 0，#十六进制；1，#十进制（默认）；2，#八进制；3，#二进制
    .局部变量 s, 整数型, , , 最终结果
    .局部变量 a, 整数型, , , 中间变量
    .局部变量 b, 整数型, , , 中间变量
    .局部变量 c, 文本型, , , 中间变量
    .局部变量 d, 整数型, , , 中间变量

    欲转换的值 ＝ 到小写 (欲转换的值)
    .如果真 (是否为空 (数值类型))
        数值类型 ＝ 1
    .如果真结束
    s ＝ 0
    .判断开始 (数值类型 ＝ 0)
        a ＝ 取文本长度 (欲转换的值)
        .变量循环首 (1, a, 1, b)
            c ＝ 取文本中间 (欲转换的值, a － b ＋ 1, 1)
            .如果真 (取代码 (c, ) ≤ 取代码 (“f”, ) 且 取代码 (c, ) ≥ 取代码 (“a”, ) 或 (取代码 (c, ) ≤ 取代码 (“F”, ) 且 取代码 (c, ) ≥ 取代码 (“A”, )))
                .如果真 (取代码 (c, ) ≥ 取代码 (“A”, ) 且 取代码 (c, ) ≤ 取代码 (“F”, ))
                    d ＝ 取代码 (c, ) － 取代码 (“A”, ) ＋ 10
                .如果真结束
                .如果真 (取代码 (c, ) ≥ 取代码 (“a”, ) 且 取代码 (c, ) ≤ 取代码 (“f”, ))
                    d ＝ 取代码 (c, ) － 取代码 (“a”, ) ＋ 10
                .如果真结束
                
            .如果真结束
            .如果真 (取代码 (c, ) ≤ 取代码 (“9”, ) 且 取代码 (c, ) ≥ 取代码 (“0”, ))
                d ＝ 到数值 (c)
            .如果真结束
            s ＝ s ＋ 求次方 (16, b － 1) × d
        .变量循环尾 ()
    .默认
        
    .判断结束
    .判断开始 (数值类型 ＝ 1)
        s ＝ 到数值 (欲转换的值)
    .默认
        
    .判断结束
    .判断开始 (数值类型 ＝ 2)
        a ＝ 取文本长度 (欲转换的值)
        .变量循环首 (1, a, 1, b)
            c ＝ 取文本中间 (欲转换的值, a － b ＋ 1, 1)
            .如果真 (取代码 (c, ) ≤ 取代码 (“7”, ) 且 取代码 (c, ) ≥ 取代码 (“0”, ))
                d ＝ 到数值 (c)
            .如果真结束
            s ＝ s ＋ 求次方 (8, b － 1) × d
        .变量循环尾 ()
    .默认
        
    .判断结束
    .判断开始 (数值类型 ＝ 3)
        a ＝ 取文本长度 (欲转换的值)
        .变量循环首 (1, a, 1, b)
            c ＝ 取文本中间 (欲转换的值, a － b ＋ 1, 1)
            .如果真 (取代码 (c, ) ≤ 取代码 (“1”, ) 且 取代码 (c, ) ≥ 取代码 (“0”, ))
                d ＝ 到数值 (c)
            .如果真结束
            s ＝ s ＋ 求次方 (2, b － 1) × d
        .变量循环尾 ()
    .默认
        
    .判断结束
    返回 (s)

.子程序 进制_十六进制转有符号的十进制, 整数型, 公开, D0 -> -48
    .参数 十六进制, 文本型

    返回 (位异或 (进制_十六到十 (十六进制), 128) － 128)

.子程序 进制_有符号的十进制转十六进制, 文本型, 公开, -48 -> D0
    .参数 有符号的十进制, 整数型

    返回 (进制_十到十六 (位或 (有符号的十进制 ＋ 128, 128)))

.子程序 分隔子程序1, , , ●●●●●●●●●●●●●●●●●●校验●●●●●●●●●●●●●●●●●●
    

.子程序 MD过程, 文本型
    .参数 x, 字节集
    .参数 种类, 整数型
    .参数 长度, 整数型
    .局部变量 hCryptProv, 整数型
    .局部变量 hKey, 整数型
    .局部变量 hHash, 整数型
    .局部变量 pbBuffer, 字节集
    .局部变量 cbHash, 整数型
    .局部变量 rgbHash, 字节集
    .局部变量 rgbDigits, 字节集
    .局部变量 局_MD5, 字节集
    .局部变量 b, 整数型
    .局部变量 i, 整数型
    .局部变量 len, 整数型

    .如果真 (CryptAcquireContextA (hCryptProv, “”, “”, 1, -268435456) ＝ 0)
        .如果真 (CryptAcquireContextA (hCryptProv, “”, “”, 1, 0) ＝ 0)
            返回 (“”)
        .如果真结束
        
    .如果真结束
    
    .如果 (CryptCreateHash (hCryptProv, 种类, hKey, 0, hHash) ＝ 0)
        CryptReleaseContext (hCryptProv, 0)
        返回 (“”)
    .否则
        pbBuffer ＝ x
        len ＝ 取字节集长度 (x)
        .如果 (CryptHashData (hHash, pbBuffer, len, 0) ＝ 0)
            CryptDestroyHash (hHash)
            CryptReleaseContext (hCryptProv, 0)
            返回 (“”)
            
        .否则
            rgbHash ＝ 取空白字节集 (长度)
            cbHash ＝ 长度
            .如果 (CryptGetHashParam (hHash, 2, rgbHash, cbHash, 0) ＝ 0)
                CryptDestroyHash (hHash)
                CryptReleaseContext (hCryptProv, 0)
                返回 (“”)
                
            .否则
                rgbDigits ＝ 到字节集 (“0123456789ABCDEF”)
                局_MD5 ＝ 取空白字节集 (长度 × 2)
                .变量循环首 (0, cbHash － 1, 1, i)
                    b ＝ rgbHash [i ＋ 1]
                    局_MD5 [i × 2 ＋ 1] ＝ rgbDigits [右移 (b, 4) ＋ 1]
                    局_MD5 [i × 2 ＋ 2] ＝ rgbDigits [位与 (b, 15) ＋ 1]
                .变量循环尾 ()
                CryptDestroyHash (hHash)
                CryptReleaseContext (hCryptProv, 0)
            .如果结束
            
        .如果结束
        
    .如果结束
    返回 (到文本 (局_MD5))

.子程序 校验_取hmac_md5, 文本型, 公开
    .参数 数据, 字节集
    .参数 密钥, 文本型

    返回 (bin2hex_ (HMAC_md5 (数据, 密钥), 真))

.子程序 校验_取md5, 文本型, 公开, 取数据MD5
    .参数 字节集数据, 字节集, , 要取数据摘要的字节集
    .参数 返回值转成大写, 逻辑型, 可空, 可空，默认为假。假=小写  真=大写
    .参数 是否取16位, 逻辑型, 可空, 可空，默认为32位
    .局部变量 t, 文本型

    t ＝ MD过程 (字节集数据, 32771, 16)
    .如果真 (返回值转成大写 ＝ 假)
        t ＝ 到小写 (t)
    .如果真结束
    
    .判断开始 (是否取16位)
        返回 (取文本中间 (t, 9, 16))
    .默认
        返回 (t)
    .判断结束
    

.子程序 校验_取md5_进度, 文本型, 公开, 支持大文件获取，失败返回空文本。
    .参数 文件路径, 文本型
    .参数 进度回调, 子程序指针, 可空, 1个参数【进度】整数型。
    .局部变量 hFile, 整数型
    .局部变量 context, MD5_CTX
    .局部变量 Data, 字节集
    .局部变量 Length, 整数型
    .局部变量 Count, 长整数型
    .局部变量 FileLong, 长整数型
    .局部变量 Pos, 整数型
    .局部变量 i, 整数型
    .局部变量 strMD5, 文本型
    .局部变量 读写位置, 整数型

    .如果真 (文件是否存在 (文件路径))
        hFile ＝ CreateFileA (文件路径, #GENERIC_READ, 位或 (#FILE_SHARE_WRITE, #FILE_SHARE_READ), 0, #OPEN_EXISTING, 536870912, 0) ' FILE_FLAG_NO_BUFFERING = 536870912
        .如果真 (hFile ≠ 0)
            FileLong ＝ 内部_取文件长度 (hFile)
            ' 移到文件首 (hFile)
            ' SetFilePointerEx (hFile, －内部_取文件长度 (hFile), 读写位置, 2)
            MD5Init (context)
            .循环判断首 ()
                内部_读入字节集 (hFile, Data, 8 × 1024 × 1024)
                Length ＝ 取字节集长度 (Data)
                Count ＝ Length ＋ Count
                Pos ＝ Count ÷ FileLong × 100
                .如果真 (到整数 (进度回调) ＞ 0)
                    程序_Call (到整数 (进度回调), Pos, , , , )
                .如果真结束
                MD5Update_bin (context, Data, Length)
                处理事件 ()
            .循环判断尾 (Count ＜ FileLong)
            MD5Final (context)
            .计次循环首 (16, i)
                strMD5 ＝ strMD5 ＋ 取文本右边 (到文本 (0) ＋ 到小写 (取十六进制文本 (context.digest [i])), 2)
            .计次循环尾 ()
        .如果真结束
        CloseHandle (hFile)
    .如果真结束
    返回 (到大写 (strMD5))
    
    
    

.子程序 校验_取md5_进度W, 文本型, 公开, 支持大文件获取
    .参数 文件路径, 字节集
    .参数 进度回调, 整数型, 可空, 进度值
    .局部变量 dwFlags, 整数型
    .局部变量 hFile, 整数型
    .局部变量 dwSize, 长整数型
    .局部变量 ulSize, 整数型
    .局部变量 dwTotal, 长整数型
    .局部变量 ctx, MD5_CTX
    .局部变量 pMem, 整数型
    .局部变量 md5Str, 文本型
    .局部变量 i, 整数型

    dwFlags ＝ 选择 (文件_是否为目录W (文件路径), #FILE_FLAG_BACKUP_SEMANTICS, #FILE_ATTRIBUTE_NORMAL)
    hFile ＝ CreateFileW (文件路径, #GENERIC_READ, #FILE_SHARE_READ, #NULL, #OPEN_EXISTING, dwFlags, #NULL)
    .如果真 (hFile ≠ #INVALID_HANDLE_VALUE)
        .如果真 (GetFileSizeEx (hFile, 取指针长整数_ (dwSize)) ＝ 假)
            输出调试文本 (取错误信息文本_API (, ))
        .如果真结束
        pMem ＝ HeapAlloc (GetProcessHeap (), #HEAP_ZERO_MEMORY, m_stageSize)
        .如果真 (pMem ≠ #NULL)
            MD5Init (ctx)
            .循环判断首 ()
                .如果真 (ReadFile_整数型 (hFile, pMem, m_stageSize, ulSize, #NULL) 且 ulSize ＞ 0)
                    dwTotal ＝ dwTotal ＋ ulSize
                    .如果真 (进度回调 ≠ #NULL)
                        调用子程序_ (进度回调, dwTotal ÷ dwSize × 100, , , , , , , , , , , , , , )
                    .如果真结束
                    MD5Update (ctx, pMem, ulSize)
                .如果真结束
                处理事件 ()
            .循环判断尾 (ulSize ≠ 0)
            MD5Final (ctx)
            HeapFree (GetProcessHeap (), 0, pMem)
        .如果真结束
        CloseHandle (hFile)
        md5Str ＝ 字节集_字节集到十六进制 (指针到字节集 (取数据_通用型_数组 (ctx.digest), 16))
    .如果真结束
    返回 (md5Str)

.子程序 内部_读入字节集, 整数型, 公开, 成功返回 实际读入的字节数 ,失败返回 -1
    .参数 文件句柄, 整数型, , 该句柄由“打开文件”命令所返回。
    .参数 存放数据的变量, 字节集, 参考
    .参数 欲读入数据的长度, 整数型
    .局部变量 缓冲区, 字节集
    .局部变量 读入的字符数, 整数型

    .如果真 (欲读入数据的长度 ＝ 0)
        欲读入数据的长度 ＝ 内部_取文件长度 (文件句柄) － 取读写位置 (文件句柄)
    .如果真结束
    缓冲区 ＝ 取空白字节集 (欲读入数据的长度)
    ReadFile (文件句柄, 缓冲区, 欲读入数据的长度, 读入的字符数, 0)
    .判断开始 (欲读入数据的长度 ＝ 读入的字符数)
        存放数据的变量 ＝ 缓冲区
    .默认
        存放数据的变量 ＝ 取字节集左边 (缓冲区, 读入的字符数)
    .判断结束
    返回 (读入的字符数)

.子程序 内部_取文件长度, 长整数型, 公开, 成功返回文件长度 ,失败返回 -1
    .参数 文件句柄, 整数型, , 该句柄由“打开文件”命令所返回。
    .局部变量 长度, 长整数型

    .如果真 (GetFileSizeEx (文件句柄, 取指针长整数_ (长度)))
        返回 (长度)
    .如果真结束
    返回 (-1)

.子程序 校验_取md5_文本, 文本型, 公开, 取文本MD5，支持中文。
    .参数 欲取MD5的文本串, 文本型, , 要取数据摘要的字节集
    .参数 是否包含中文, 逻辑型, 可空, 如果“欲取MD5的文本”中包含有汉字，设置为空，返回的MD5将不一样。
    .参数 返回值转成大写, 逻辑型, 可空, 可空，默认为假。假=小写  真=大写
    .参数 是否取16位, 逻辑型, 可空, 可空，默认为32位
    .局部变量 局_MD5, 文本型

    .如果 (是否包含中文)
        局_MD5 ＝ 编码_gb2312到utf8 (欲取MD5的文本串)
    .否则
        局_MD5 ＝ 欲取MD5的文本串
    .如果结束
    返回 (校验_取md5 (到字节集 (局_MD5), 返回值转成大写, 是否取16位))

.子程序 校验_取md4, 文本型, 公开
    .参数 字节集数据, 字节集, , 要取数据摘要的字节集

    返回 (到小写 (MD过程 (字节集数据, 32770, 16)))

.子程序 校验_取md2, 文本型, 公开
    .参数 字节集数据, 字节集, , 要取数据摘要的字节集

    返回 (到小写 (MD过程 (字节集数据, 32769, 16)))

.子程序 校验_取rc4, 字节集, 公开, RC4校验，与易的输出形式一样，可能和其它校验程序输出形式不一样，可自行进行相应调整。
    .参数 原文, 字节集, , 需要加、解密的字节集
    .参数 密码, 文本型, , 输入相应的密码
    .局部变量 m, 字节型, , "256"
    .局部变量 i, 整数型
    .局部变量 j, 整数型
    .局部变量 key, 字节集
    .局部变量 密码长度, 整数型
    .局部变量 原文长度, 整数型
    .局部变量 结果, 字节集
    .局部变量 x, 整数型
    .局部变量 k, 字节型, , "256"
    .局部变量 temp, 字节型

    原文长度 ＝ 取字节集长度 (原文)
    .如果真 (原文长度 ＜ 1)
        返回 ({ })
    .如果真结束
    密码长度 ＝ 取文本长度 (密码)
    结果 ＝ 取空白字节集 (原文长度)
    .计次循环首 (256, i)
        m [i] ＝ i － 1
    .计次循环尾 ()
    .如果真 (密码长度 ＞ 0)
        key ＝ 到字节集 (密码)
        j ＝ 1
        .计次循环首 (256, i)
            k [i] ＝ key [j]
            j ＝ j ＋ 1
            .如果真 (j ＞ 密码长度)
                j ＝ 1
            .如果真结束
            
        .计次循环尾 ()
        j ＝ 0
        .计次循环首 (256, i)
            j ＝ 位与 (j ＋ m [i] ＋ k [i], 255)
            temp ＝ m [i]
            m [i] ＝ m [j ＋ 1]
            m [j ＋ 1] ＝ temp
        .计次循环尾 ()
    .如果真结束
    i ＝ 0
    j ＝ 0
    .计次循环首 (原文长度, x)
        i ＝ 位与 (i ＋ 1, 255)
        j ＝ 位与 (j ＋ m [i ＋ 1], 255)
        temp ＝ m [i ＋ 1]
        m [i ＋ 1] ＝ m [j ＋ 1]
        m [j ＋ 1] ＝ temp
        结果 [x] ＝ 位异或 (原文 [x], m [位与 (m [i ＋ 1] ＋ m [j ＋ 1], 255) ＋ 1])
    .计次循环尾 ()
    返回 (结果)

.子程序 校验_取sha1, 文本型, 公开, 返回40位的校验数据
    .参数 字节集数据, 字节集, , 要取数据摘要的字节集

    返回 (到小写 (MD过程 (字节集数据, 32772, 20)))

.子程序 校验_取crc32, 文本型, 公开, 用于取crc32，结果为16进制文本
    .参数 字节集数据, 字节集, , 要取CRC32数据字节集
    .参数 是否在前端补零, 逻辑型, 可空, 如果为真，则自动在前面补0，补足8位数。如果为假，则不补零；默认为假
    .局部变量 crcval, 整数型
    .局部变量 长度, 整数型
    .局部变量 i, 整数型
    .局部变量 结果, 文本型
    .局部变量 位置, 整数型
    .局部变量 crc, 整数型
    .局部变量 table, 整数型, , "256"
    .局部变量 crc32, 文本型

    长度 ＝ 取字节集长度 (字节集数据)
    .如果真 (长度 ＜ 1)
        返回 (“”)
    .如果真结束
    .变量循环首 (0, 255, 1, i) ' 用来得到码表
        crc ＝ i
        .变量循环首 (1, 8, 1, )
            .如果 (位与 (crc, 1) ≠ 0)
                crc ＝ 位异或 (位与 (右移 (crc, 1), 2147483647), 3988292384) ' crc xor EDB88320
            .否则
                crc ＝ 位与 (右移 (crc, 1), 2147483647)
            .如果结束
            
        .变量循环尾 ()
        table [i ＋ 1] ＝ crc
    .变量循环尾 ()
    crcval ＝ 4294967295
    .计次循环首 (长度, i)
        位置 ＝ 位异或 (字节集数据 [i], 位与 (crcval, 255)) ＋ 1 ' 查表
        crcval ＝ 位异或 (位与 (右移 (crcval, 8), 16777215), table [位置])
    .计次循环尾 ()
    crc32 ＝ 取十六进制文本 (位取反 (crcval))
    .如果真 (是否在前端补零)
        crc32 ＝ 文本_自动补零 (crc32, 8)
    .如果真结束
    返回 (crc32)

.子程序 校验_取sha512, 文本型, 公开
    .参数 数据, 字节集
    .局部变量 date, 字节集

    date ＝ Hash模板 (数据, #CALG_SHA_512)
    .如果 (date ＝ { })
        返回 (“”)
    .否则
        返回 (bin2hex_ (date, 真))
    .如果结束
    

.子程序 校验_取sha256, 文本型, 公开
    .参数 数据, 字节集
    .局部变量 date, 字节集

    date ＝ Hash模板 (数据, #CALG_SHA_256)
    .如果 (date ＝ { })
        返回 (“”)
    .否则
        返回 (bin2hex_ (date, 真))
    .如果结束
    

.子程序 bin2hex_, 文本型
    .参数 bin, 字节集
    .参数 转换为小写, 逻辑型, 可空
    .参数 填充空格, 逻辑型, 可空
    .局部变量 数组, 字节型, , "0"
    .局部变量 返回字节集, 字节集
    .局部变量 ki, 整数型
    .局部变量 i, 整数型
    .局部变量 高4位, 整数型
    .局部变量 低4位, 整数型

    .如果 (转换为小写)
        数组 ＝ { 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 97, 98, 99, 100, 101, 102 }
    .否则
        数组 ＝ { 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 65, 66, 67, 68, 69, 70 }
    .如果结束
    
    
    ki ＝ 取字节集长度 (bin)
    .如果 (填充空格)
        返回字节集 ＝ 取空白字节集 (ki × 3)
    .否则
        返回字节集 ＝ 取空白字节集 (ki × 2)
    .如果结束
    
    
    .计次循环首 (ki, i)
        高4位 ＝ bin [i] ÷ 16 ＋ 1
        低4位 ＝ bin [i] ％ 16 ＋ 1
        .如果 (填充空格)
            返回字节集 [i × 3 － 2] ＝ 32
            返回字节集 [i × 3 － 1] ＝ 数组 [高4位]
            返回字节集 [i × 3] ＝ 数组 [低4位]
        .否则
            返回字节集 [i × 2 － 1] ＝ 数组 [高4位]
            返回字节集 [i × 2] ＝ 数组 [低4位]
        .如果结束
        
    .计次循环尾 ()
    返回 (删首尾空 (到文本 (返回字节集)))

.子程序 HMAC_md5, 字节集, , 返回字节集结果，请自行用 bin2hex_ 或 base64_encode 转换为需要的格式
    .参数 数据, 字节集
    .参数 密钥, 文本型
    .局部变量 Hash类型, 整数型
    .局部变量 key, 字节集

    Hash类型 ＝ #CALG_MD5
    key ＝ 到字节集 (密钥)
    返回 (hmac模板 (数据, key, Hash类型))

.子程序 Hash模板, 字节集
    .参数 数据, 字节集
    .参数 Hash类型, 整数型
    .局部变量 phProv, 整数型
    .局部变量 计算结果, 字节集

    .如果真 (CryptAcquireContext_x (phProv, “”, “”, #PROV_RSA_AES, #CRYPT_VERIFYCONTEXT) ＝ 假)
        .如果真 (CryptAcquireContext_x (phProv, “”, “”, #PROV_RSA_AES, #NULL) ＝ 假)
            返回 ({ })
        .如果真结束
        
    .如果真结束
    计算结果 ＝ 执行hash (phProv, Hash类型, 数据)
    CryptReleaseContext_x (phProv, 0)
    返回 (计算结果)

.子程序 hmac模板, 字节集
    .参数 数据, 字节集
    .参数 key, 字节集
    .参数 Hash类型, 整数型
    .局部变量 phProv, 整数型
    .局部变量 计算结果, 字节集
    .局部变量 区块长度, 整数型
    .局部变量 ipad, 字节集
    .局部变量 opad, 字节集
    .局部变量 实际key, 字节集
    .局部变量 i, 整数型
    .局部变量 字节集2, 字节集
    .局部变量 字节集1, 字节集

    .如果真 (CryptAcquireContext_x (phProv, “”, “”, #PROV_RSA_AES, #CRYPT_VERIFYCONTEXT) ＝ 假)
        .如果真 (CryptAcquireContext_x (phProv, “”, “”, #PROV_RSA_AES, #NULL) ＝ 假)
            返回 ({ })
        .如果真结束
        
    .如果真结束
    
    .判断开始 (Hash类型 ＝ #CALG_SHA_384 或 Hash类型 ＝ #CALG_SHA_512)
        区块长度 ＝ 128
    .默认
        区块长度 ＝ 64
    .判断结束
    
    .如果 (取字节集长度 (key) ＞ 区块长度)
        计算结果 ＝ 执行hash (phProv, Hash类型, key)
        .如果真 (计算结果 ＝ { })
            CryptReleaseContext_x (phProv, 0)
            返回 ({ })
        .如果真结束
        实际key ＝ 计算结果
    .否则
        实际key ＝ key
    .如果结束
    
    实际key ＝ 实际key ＋ 取空白字节集 (区块长度 － 取字节集长度 (实际key))
    ipad ＝ 取空白字节集 (区块长度)
    opad ＝ 取空白字节集 (区块长度)
    .计次循环首 (区块长度, i)
        ipad [i] ＝ 位异或 (实际key [i], 54)
        opad [i] ＝ 位异或 (实际key [i], 92)
    .计次循环尾 ()
    
    ipad ＝ ipad ＋ 数据
    计算结果 ＝ 执行hash (phProv, Hash类型, ipad)
    .如果真 (计算结果 ＝ { })
        CryptReleaseContext_x (phProv, 0)
        返回 ({ })
    .如果真结束
    
    opad ＝ opad ＋ 计算结果
    
    计算结果 ＝ 执行hash (phProv, Hash类型, opad)
    CryptReleaseContext_x (phProv, 0)
    返回 (计算结果)

.子程序 执行hash, 字节集
    .参数 phProv, 整数型
    .参数 Hash类型, 整数型
    .参数 数据, 字节集
    .局部变量 pbBuffer, 字节集
    .局部变量 len, 整数型
    .局部变量 计算结果, 字节集
    .局部变量 散列长度, 整数型
    .局部变量 hhash, 整数型

    .如果真 (CryptCreateHash_x (phProv, Hash类型, 0, 0, hhash) ＝ 假)
        返回 ({ })
    .如果真结束
    pbBuffer ＝ 数据
    len ＝ 取字节集长度 (pbBuffer)
    .如果真 (CryptHashData_x (hhash, pbBuffer, len, 0) ＝ 假)
        CryptDestroyHash (hhash)
        返回 ({ })
    .如果真结束
    散列长度 ＝ 0
    .如果真 (CryptGetHashParam_x (hhash, #HP_HASHVAL, 0, 散列长度, 0) ＝ 假)
        CryptDestroyHash (hhash)
        返回 ({ })
    .如果真结束
    计算结果 ＝ 取空白字节集 (散列长度)
    .如果真 (CryptGetHashParam_x (hhash, #HP_HASHVAL, 取地址_字节集 (计算结果), 散列长度, 0) ＝ 假)
        CryptDestroyHash (hhash)
        返回 ({ })
    .如果真结束
    CryptDestroyHash (hhash)
    计算结果 ＝ 取字节集左边 (计算结果, 散列长度)
    返回 (计算结果)
    

.子程序 校验_哈希值计算, 文本型, 公开, 大文件计算哈希值
    .参数 欲计算哈希的文件, 文本型
    .参数 哈希算法, 整数型, , #CALG_
    .参数 进度回调事件, 整数型, 可空, 进度百分比
    .参数 缓冲长度, 整数型, 可空, 默认为4096
    .局部变量 hProv, 整数型
    .局部变量 hHash, 整数型
    .局部变量 hFile, 整数型
    .局部变量 dwLowPart, 整数型
    .局部变量 dwHighPart, 整数型
    .局部变量 dwFileSize, 长整数型
    .局部变量 dwReadSize, 长整数型
    .局部变量 pbData, 字节集
    .局部变量 dwNumBytesRead, 整数型
    .局部变量 dwHashSize, 整数型
    .局部变量 HashValue, 字节集
    .局部变量 szHashData, 文本型

    .如果真 (缓冲长度 ≤ 0)
        缓冲长度 ＝ 4096
    .如果真结束
    .如果真 (CryptAcquireContextA (hProv, 字符 (#NULL), 字符 (#NULL), #PROV_RSA_AES, #CRYPT_VERIFYCONTEXT) ＝ 1)
        .如果真 (CryptCreateHash (hProv, 哈希算法, 0, 0, hHash) ＝ 1)
            hFile ＝ CreateFileA (欲计算哈希的文件, #GENERIC_READ, #FILE_SHARE_READ, #NULL, #OPEN_EXISTING, #FILE_FLAG_SEQUENTIAL_SCAN, #NULL)
            .如果真 (hFile ≠ #INVALID_HANDLE_VALUE)
                dwLowPart ＝ GetFileSize (hFile, dwHighPart)
                dwFileSize ＝ 合并长整数 (dwLowPart, dwHighPart)
                pbData ＝ 取空白字节集 (缓冲长度)
                .判断循环首 (ReadFile (hFile, pbData, 缓冲长度, dwNumBytesRead, #NULL) ＝ 1)
                    .如果真 (dwNumBytesRead ＝ 0)
                        跳出循环 ()
                    .如果真结束
                    dwReadSize ＝ dwReadSize ＋ dwNumBytesRead
                    .如果真 (进度回调事件 ≠ #NULL)
                        调用子程序_ (进度回调事件, 到整数 (dwReadSize ÷ dwFileSize × 100), , , , , , , , , , , , , , )
                    .如果真结束
                    CryptHashData (hHash, pbData, dwNumBytesRead, 0)
                .判断循环尾 ()
                CloseHandle (hFile)
                CryptGetHashParam_x (hHash, #HP_HASHVAL, #NULL, dwHashSize, 0)
                .如果真 (dwHashSize ＞ 0)
                    HashValue ＝ 取空白字节集 (dwHashSize)
                    CryptGetHashParam (hHash, #HP_HASHVAL, HashValue, dwHashSize, 0)
                    szHashData ＝ 字节集_字节集到十六进制2 (HashValue)
                .如果真结束
                
            .如果真结束
            CryptDestroyHash (hHash)
        .如果真结束
        CryptReleaseContext (hProv, 0)
    .如果真结束
    返回 (szHashData)

.子程序 取地址_字节集, 整数型
    .参数 变量, 字节集, 参考

    ' mov eax, [ebp+8]
    ' mov eax, [eax]
    ' add eax, 8
    ' mov esp ,ebp
    ' pop ebp
    ' retn 4
    置入代码 ({ 139, 69, 8, 139, 0, 131, 192, 8, 139, 229, 93, 194, 4, 0 }) ' <!!!>
    返回 (0)

.子程序 get_BLOBHEADER, 字节集
    .参数 bType, 整数型
    .参数 bVersion, 整数型
    .参数 reserved, 整数型
    .参数 aiKeyAlg, 整数型
    .局部变量 字节集, 字节集
    .局部变量 全部字节集, 字节集

    字节集 ＝ 到字节集 (bType)
    全部字节集 ＝ 取字节集左边 (字节集, 1)
    字节集 ＝ 到字节集 (bVersion)
    全部字节集 ＝ 全部字节集 ＋ 取字节集左边 (字节集, 1)
    字节集 ＝ 到字节集 (reserved)
    全部字节集 ＝ 全部字节集 ＋ 取字节集左边 (字节集, 2)
    全部字节集 ＝ 全部字节集 ＋ 到字节集 (aiKeyAlg)
    返回 (全部字节集)

.子程序 _padding填充, 字节集
    .参数 数据, 字节集
    .参数 块大小, 整数型
    .参数 填充算法, 整数型
    .局部变量 补位全长度, 整数型
    .局部变量 最后字节, 字节集
    .局部变量 算法块大小, 整数型
    .局部变量 填充块数, 整数型
    .局部变量 第一块填充数, 整数型

    .如果真 (块大小 ＝ 0)
        返回 (数据)
    .如果真结束
    .如果真 (填充算法 ＝ 1)
        返回 (数据)
    .如果真结束
    
    .如果真 (填充算法 ＝ 2)
        补位全长度 ＝ 块大小 － 取字节集长度 (数据) ％ 块大小
        返回 (数据 ＋ 取重复字节集 (补位全长度, { 0 }))
    .如果真结束
    
    .如果真 (填充算法 ＝ 3)
        补位全长度 ＝ 块大小 － 取字节集长度 (数据) ％ 块大小
        最后字节 ＝ 到字节集 (到字节 (补位全长度))
        返回 (数据 ＋ 取重复字节集 (补位全长度 － 1, { 0 }) ＋ 最后字节)
    .如果真结束
    
    .如果真 (填充算法 ＝ 4)
        补位全长度 ＝ 块大小 － 取字节集长度 (数据) ％ 块大小
        最后字节 ＝ 到字节集 (到字节 (补位全长度))
        返回 (数据 ＋ 取随机字节集 (补位全长度 － 1) ＋ 最后字节)
    .如果真结束
    
    
    .如果真 (填充算法 ＝ 7 或 填充算法 ＝ 5)
        补位全长度 ＝ 块大小 － 取字节集长度 (数据) ％ 块大小
        返回 (数据 ＋ 取重复字节集 (补位全长度, 到字节集 (到字节 (补位全长度))))
    .如果真结束
    
    返回 (数据)

.子程序 数据分块, 整数型
    .参数 数据, 字节集
    .参数 块大小, 整数型
    .参数 返回数据块, 字节集, 数组
    .局部变量 当前位置, 整数型
    .局部变量 块数量, 整数型
    .局部变量 数据长度, 整数型
    .局部变量 i, 整数型
    .局部变量 当前数据, 字节集
    .局部变量 返回数组, 字节集, , "0"

    清除数组 (返回数据块)
    数据长度 ＝ 取字节集长度 (数据)
    块数量 ＝ 数据长度 ÷ 块大小
    .如果真 (数据长度 ％ 块大小 ≠ 0)
        块数量 ＝ 块数量 ＋ 1
    .如果真结束
    当前位置 ＝ 1
    .计次循环首 (块数量, i)
        当前数据 ＝ 取字节集中间 (数据, 当前位置, 块大小)
        当前位置 ＝ 当前位置 ＋ 块大小
        加入成员 (返回数组, 当前数据)
    .计次循环尾 ()
    返回数据块 ＝ 返回数组
    返回 (取数组成员数 (返回数据块))
    
    

.子程序 取随机字节集, 字节集
    .参数 长度, 整数型
    .局部变量 返回字节集, 字节集
    .局部变量 i, 整数型

    返回字节集 ＝ 取空白字节集 (长度)
    置随机数种子 ()
    .计次循环首 (长度, i)
        返回字节集 [i] ＝ 取随机数 (1, 255)
    .计次循环尾 ()
    返回 (返回字节集)
    
    

.子程序 _padding去填充, 字节集
    .参数 数据, 字节集
    .参数 填充算法, 整数型
    .局部变量 ki, 整数型
    .局部变量 i, 整数型
    .局部变量 当前位置, 整数型
    .局部变量 右边字节集, 字节集
    .局部变量 补位长度, 整数型
    .局部变量 总长度, 整数型
    .局部变量 实际长度, 整数型

    
    .如果真 (数据 ＝ { })
        返回 (数据)
    .如果真结束
    .如果真 (填充算法 ＝ 1)
        返回 (数据)
    .如果真结束
    .如果真 (填充算法 ＝ 2)
        ki ＝ 取字节集长度 (数据)
        当前位置 ＝ ki
        .计次循环首 (ki, )
            .如果真 (数据 [当前位置] ≠ 0)
                返回 (取字节集左边 (数据, 当前位置))
            .如果真结束
            当前位置 ＝ 当前位置 － 1
        .计次循环尾 ()
        返回 ({ })
    .如果真结束
    
    .如果真 (填充算法 ＝ 3 或 填充算法 ＝ 7 或 填充算法 ＝ 5)
        总长度 ＝ 取字节集长度 (数据)
        右边字节集 ＝ 取字节集右边 (数据, 1)
        补位长度 ＝ 到整数 (右边字节集 [1])
        实际长度 ＝ 总长度 － 补位长度
        返回 (取字节集左边 (数据, 实际长度))
    .如果真结束
    返回 (数据)

.子程序 取对称算法加密_块, 字节集, , AES和DES是块加密
    .参数 数据, 字节集
    .参数 密钥, 字节集
    .参数 对称算法类型, 整数型
    .参数 IV, 字节集, 可空
    .参数 填充方式, 整数型, 可空
    .参数 模式, 整数型, 可空
    .局部变量 phProv, 整数型
    .局部变量 BLOBHEADER, 字节集
    .局部变量 keyBlob, 字节集
    .局部变量 字节集密钥, 字节集
    .局部变量 hKey, 整数型
    .局部变量 明文块, 字节集, , "0"
    .局部变量 块大小, 整数型
    .局部变量 i, 整数型
    .局部变量 ki, 整数型
    .局部变量 待加密数据, 字节集
    .局部变量 参数字节集, 字节集
    .局部变量 参数长度, 整数型
    .局部变量 是否最后块, 逻辑型
    .局部变量 存储空间, 字节集
    .局部变量 存储空间大小, 整数型
    .局部变量 加密数据大小, 整数型
    .局部变量 全部密文, 字节集
    .局部变量 算法库, 整数型

    .如果真 (对称算法类型 ＝ #CALG_AES)
        对称算法类型 ＝ #CALG_AES_128
    .如果真结束
    
    .如果 (对称算法类型 ＝ #CALG_AES 或 对称算法类型 ＝ #CALG_AES_128 或 对称算法类型 ＝ #CALG_AES_192 或 对称算法类型 ＝ #CALG_AES_256)
        算法库 ＝ #PROV_RSA_AES
    .否则
        算法库 ＝ #PROV_RSA_FULL
    .如果结束
    
    
    .如果真 (模式 ＝ 0)
        模式 ＝ #CRYPT_MODE_CBC
    .如果真结束
    .如果真 (CryptAcquireContext_x (phProv, “”, “”, 算法库, #CRYPT_VERIFYCONTEXT) ＝ 假)
        .如果真 (CryptAcquireContext_x (phProv, “”, “”, 算法库, #NULL) ＝ 假)
            返回 ({ })
        .如果真结束
        
    .如果真结束
    字节集密钥 ＝ 密钥
    待加密数据 ＝ 数据
    BLOBHEADER ＝ get_BLOBHEADER (#PLAINTEXTKEYBLOB, #CUR_BLOB_VERSION, 0, 对称算法类型)
    keyBlob ＝ BLOBHEADER ＋ 到字节集 (取字节集长度 (字节集密钥)) ＋ 字节集密钥
    .如果真 (CryptImportKey (phProv, keyBlob, 取字节集长度 (keyBlob), 0, #CRYPT_EXPORTABLE, hKey) ＝ 假)
        CryptReleaseContext_x (phProv, 0)
        返回 ({ })
    .如果真结束
    
    参数字节集 ＝ 到字节集 (模式)
    参数长度 ＝ 4
    .如果真 (CryptSetKeyParam (hKey, #KP_MODE, 参数字节集, 0) ＝ 假)
        CryptDestroyKey (hKey)
        CryptReleaseContext_x (phProv, 0)
        返回 ({ })
    .如果真结束
    
    
    参数字节集 ＝ 取空白字节集 (4)
    参数长度 ＝ 4
    
    CryptGetKeyParam (hKey, #KP_BLOCKLEN, 参数字节集, 参数长度, 0)
    块大小 ＝ 取字节集数据 (参数字节集, #整数型, )
    块大小 ＝ 块大小 ÷ 8
    .如果真 (块大小 ＝ 0)
        CryptDestroyKey (hKey)
        CryptReleaseContext_x (phProv, 0)
        返回 ({ })
    .如果真结束
    
    待加密数据 ＝ _padding填充 (待加密数据, 块大小, 填充方式)
    
    .如果真 (IV ＝ { })
        IV ＝ 取空白字节集 (块大小)
    .如果真结束
    
    .如果真 (CryptSetKeyParam (hKey, #KP_IV, IV, 0) ＝ 假)
        CryptDestroyKey (hKey)
        CryptReleaseContext_x (phProv, 0)
        返回 ({ })
    .如果真结束
    
    
    
    
    数据分块 (待加密数据, 块大小, 明文块)
    ki ＝ 取数组成员数 (明文块)
    .计次循环首 (ki, i)
        .如果 (ki ＝ i)
            是否最后块 ＝ 真
        .否则
            是否最后块 ＝ 假
        .如果结束
        
        存储空间 ＝ 明文块 [i] ＋ 取空白字节集 (块大小)
        加密数据大小 ＝ 取字节集长度 (明文块 [i])
        存储空间大小 ＝ 取字节集长度 (存储空间)
        
        .如果真 (CryptEncrypt_x (hKey, 0, 是否最后块, 0, 存储空间, 加密数据大小, 存储空间大小) ＝ 假)
            CryptDestroyKey (hKey)
            CryptReleaseContext_x (phProv, 0)
            返回 ({ })
        .如果真结束
        
        存储空间 ＝ 取字节集左边 (存储空间, 加密数据大小)
        全部密文 ＝ 全部密文 ＋ 存储空间
    .计次循环尾 ()
    全部密文 ＝ 取字节集左边 (全部密文, 取字节集长度 (全部密文) － 块大小)
    CryptDestroyKey (hKey)
    CryptReleaseContext_x (phProv, 0)
    返回 (全部密文)

.子程序 取对称算法解密_块, 字节集
    .参数 数据, 字节集
    .参数 密钥, 字节集
    .参数 对称算法类型, 整数型
    .参数 IV, 字节集, 可空
    .参数 填充方式, 整数型, 可空
    .参数 模式, 整数型, 可空
    .局部变量 phProv, 整数型
    .局部变量 BLOBHEADER, 字节集
    .局部变量 keyBlob, 字节集
    .局部变量 字节集密钥, 字节集
    .局部变量 hKey, 整数型
    .局部变量 密文块, 字节集, , "0"
    .局部变量 块大小, 整数型
    .局部变量 i, 整数型
    .局部变量 ki, 整数型
    .局部变量 待解密数据, 字节集
    .局部变量 参数字节集, 字节集
    .局部变量 参数长度, 整数型
    .局部变量 是否最后块, 逻辑型
    .局部变量 存储空间, 字节集
    .局部变量 解密数据大小, 整数型
    .局部变量 全部明文, 字节集
    .局部变量 算法库, 整数型

    .如果真 (对称算法类型 ＝ #CALG_AES)
        对称算法类型 ＝ #CALG_AES_128
    .如果真结束
    
    .如果 (对称算法类型 ＝ #CALG_AES 或 对称算法类型 ＝ #CALG_AES_128 或 对称算法类型 ＝ #CALG_AES_192 或 对称算法类型 ＝ #CALG_AES_256)
        算法库 ＝ #PROV_RSA_AES
    .否则
        算法库 ＝ #PROV_RSA_FULL
    .如果结束
    
    
    
    .如果真 (填充方式 ＝ 0)
        填充方式 ＝ #PKCS5_PADDING
    .如果真结束
    .如果真 (模式 ＝ 0)
        模式 ＝ #CRYPT_MODE_CBC
    .如果真结束
    .如果真 (CryptAcquireContext_x (phProv, “”, “”, 算法库, #CRYPT_VERIFYCONTEXT) ＝ 假)
        .如果真 (CryptAcquireContext_x (phProv, “”, “”, 算法库, #NULL) ＝ 假)
            返回 ({ })
        .如果真结束
        
    .如果真结束
    字节集密钥 ＝ 密钥
    待解密数据 ＝ 数据
    BLOBHEADER ＝ get_BLOBHEADER (#PLAINTEXTKEYBLOB, #CUR_BLOB_VERSION, 0, 对称算法类型)
    keyBlob ＝ BLOBHEADER ＋ 到字节集 (取字节集长度 (字节集密钥)) ＋ 字节集密钥
    
    .如果真 (CryptImportKey (phProv, keyBlob, 取字节集长度 (keyBlob), 0, #CRYPT_EXPORTABLE, hKey) ＝ 假)
        CryptReleaseContext_x (phProv, 0)
        返回 ({ })
    .如果真结束
    
    参数字节集 ＝ 到字节集 (模式)
    参数长度 ＝ 4
    .如果真 (CryptSetKeyParam (hKey, #KP_MODE, 参数字节集, 0) ＝ 假)
        CryptDestroyKey (hKey)
        CryptReleaseContext_x (phProv, 0)
        返回 ({ })
    .如果真结束
    
    
    参数字节集 ＝ 取空白字节集 (4)
    参数长度 ＝ 4
    
    CryptGetKeyParam (hKey, #KP_BLOCKLEN, 参数字节集, 参数长度, 0)
    块大小 ＝ 取字节集数据 (参数字节集, #整数型, )
    块大小 ＝ 块大小 ÷ 8
    .如果真 (块大小 ＝ 0)
        CryptDestroyKey (hKey)
        CryptReleaseContext_x (phProv, 0)
        返回 ({ })
    .如果真结束
    
    
    .如果真 (IV ＝ { })
        IV ＝ 取空白字节集 (块大小)
    .如果真结束
    
    .如果真 (CryptSetKeyParam (hKey, #KP_IV, IV, 0) ＝ 假)
        CryptDestroyKey (hKey)
        CryptReleaseContext_x (phProv, 0)
        返回 ({ })
    .如果真结束
    
    
    数据分块 (待解密数据, 块大小, 密文块)
    ki ＝ 取数组成员数 (密文块)
    .计次循环首 (ki, i)
        存储空间 ＝ 密文块 [i]
        解密数据大小 ＝ 取字节集长度 (密文块 [i])
        
        .如果真 (CryptDecrypt_x (hKey, 0, 假, 0, 存储空间, 解密数据大小) ＝ 假)
            CryptDestroyKey (hKey)
            CryptReleaseContext_x (phProv, 0)
            返回 ({ })
        .如果真结束
        
        存储空间 ＝ 取字节集左边 (存储空间, 解密数据大小)
        全部明文 ＝ 全部明文 ＋ 存储空间
    .计次循环尾 ()
    CryptDestroyKey (hKey)
    CryptReleaseContext_x (phProv, 0)
    全部明文 ＝ _padding去填充 (全部明文, 填充方式)
    返回 (全部明文)
    

.子程序 取对称算法加密_流, 字节集, , RC2和RC4是流加密
    .参数 数据, 字节集
    .参数 密钥, 字节集
    .参数 对称算法类型, 整数型
    .局部变量 字节集密钥, 字节集
    .局部变量 待加密数据, 字节集
    .局部变量 BLOBHEADER, 字节集
    .局部变量 keyBlob, 字节集
    .局部变量 phProv, 整数型
    .局部变量 hKey, 整数型
    .局部变量 存储空间, 字节集
    .局部变量 存储空间长度, 整数型
    .局部变量 数据长度, 整数型

    
    .如果真 (CryptAcquireContext_x (phProv, “”, “”, #PROV_RSA_FULL, #CRYPT_VERIFYCONTEXT) ＝ 假)
        .如果真 (CryptAcquireContext_x (phProv, “”, “”, #PROV_RSA_FULL, #NULL) ＝ 假)
            返回 ({ })
        .如果真结束
        
    .如果真结束
    
    
    字节集密钥 ＝ 密钥
    待加密数据 ＝ 数据
    BLOBHEADER ＝ get_BLOBHEADER (#PLAINTEXTKEYBLOB, #CUR_BLOB_VERSION, 0, 对称算法类型)
    keyBlob ＝ BLOBHEADER ＋ 到字节集 (取字节集长度 (字节集密钥)) ＋ 字节集密钥
    .如果真 (CryptImportKey (phProv, keyBlob, 取字节集长度 (keyBlob), 0, #CRYPT_EXPORTABLE, hKey) ＝ 假)
        CryptReleaseContext_x (phProv, 0)
        
        返回 ({ })
    .如果真结束
    
    存储空间 ＝ 待加密数据 ＋ 待加密数据
    存储空间长度 ＝ 取字节集长度 (存储空间)
    数据长度 ＝ 取字节集长度 (待加密数据)
    .如果真 (CryptEncrypt_x (hKey, 0, 真, 0, 存储空间, 数据长度, 存储空间长度) ＝ 假)
        返回 ({ })
    .如果真结束
    存储空间 ＝ 取字节集左边 (存储空间, 数据长度)
    返回 (存储空间)
    
    
    

.子程序 取对称算法解密_流, 字节集
    .参数 数据, 字节集
    .参数 密钥, 字节集
    .参数 对称算法类型, 整数型
    .局部变量 字节集密钥, 字节集
    .局部变量 待解密数据, 字节集
    .局部变量 BLOBHEADER, 字节集
    .局部变量 keyBlob, 字节集
    .局部变量 phProv, 整数型
    .局部变量 hKey, 整数型
    .局部变量 存储空间, 字节集
    .局部变量 存储空间长度, 整数型
    .局部变量 数据长度, 整数型

    .如果真 (CryptAcquireContext_x (phProv, “”, “”, #PROV_RSA_FULL, #CRYPT_VERIFYCONTEXT) ＝ 假)
        .如果真 (CryptAcquireContext_x (phProv, “”, “”, #PROV_RSA_FULL, #NULL) ＝ 假)
            返回 ({ })
        .如果真结束
        
    .如果真结束
    
    
    字节集密钥 ＝ 密钥
    待解密数据 ＝ 数据
    BLOBHEADER ＝ get_BLOBHEADER (#PLAINTEXTKEYBLOB, #CUR_BLOB_VERSION, 0, 对称算法类型)
    keyBlob ＝ BLOBHEADER ＋ 到字节集 (取字节集长度 (字节集密钥)) ＋ 字节集密钥
    .如果真 (CryptImportKey (phProv, keyBlob, 取字节集长度 (keyBlob), 0, #CRYPT_EXPORTABLE, hKey) ＝ 假)
        CryptReleaseContext_x (phProv, 0)
        返回 ({ })
    .如果真结束
    
    存储空间 ＝ 待解密数据 ＋ 待解密数据
    存储空间长度 ＝ 取字节集长度 (存储空间)
    数据长度 ＝ 取字节集长度 (待解密数据)
    .如果真 (CryptDecrypt_x (hKey, 0, 真, 0, 存储空间, 数据长度) ＝ 假)
        返回 ({ })
    .如果真结束
    存储空间 ＝ 取字节集左边 (存储空间, 数据长度)
    返回 (存储空间)
    
    

.子程序 对称加密, 字节集, 公开, 支持 RC2/4，AES，DES，3DES
    .参数 数据, 字节集
    .参数 密钥, 字节集, , 如果不是RC2和RC4，则密钥长度必须为块大小,否则会填充{0}或截取
    .参数 算法, 文本型, 可空, #对称算法_***
    .参数 填充, 整数型, 可空, #数据填充_*** 默认为 PKCS5_PADDING，如果是RC2和RC4，无需提供
    .参数 IV, 字节集, 可空, 如果是RC2和RC4，无需提供，否则默认为16个{0}字节
    .局部变量 数组, 文本型, , "0"
    .局部变量 密钥字节集, 字节集
    .局部变量 密钥长度, 整数型
    .局部变量 算法代码, 整数型
    .局部变量 模式代码, 整数型
    .局部变量 块大小, 整数型

    .判断开始 (算法 ＝ “RC2”)
        返回 (取对称算法加密_流 (数据, 密钥, #CALG_RC2))
    .判断 (算法 ＝ “RC4”)
        返回 (取对称算法加密_流 (数据, 密钥, #CALG_RC4))
    .默认
        
    .判断结束
    数组 ＝ 分割文本 (算法, “-”, )
    .如果真 (取数组成员数 (数组) ≠ 2)
        返回 ({ })
    .如果真结束
    
    .如果真 (IV ＝ { })
        IV ＝ { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
    .如果真结束
    
    .如果真 (填充 ＝ 0)
        填充 ＝ 5
    .如果真结束
    .如果真 (填充 ＜ 1 或 填充 ＞ 7)
        返回 ({ })
    .如果真结束
    
    
    .判断开始 (数组 [1] ＝ “AES”)
        算法代码 ＝ #CALG_AES_128
        块大小 ＝ 16
    .判断 (数组 [1] ＝ “AES192”)
        算法代码 ＝ #CALG_AES_192
        块大小 ＝ 24
    .判断 (数组 [1] ＝ “AES256”)
        算法代码 ＝ #CALG_AES_256
        块大小 ＝ 32
    .判断 (数组 [1] ＝ “DES”)
        算法代码 ＝ #CALG_DES
        块大小 ＝ 8
    .判断 (数组 [1] ＝ “3DES”)
        算法代码 ＝ #CALG_3DES
        块大小 ＝ 24
    .默认
        返回 ({ })
    .判断结束
    
    .判断开始 (数组 [2] ＝ “CBC”)
        模式代码 ＝ #CRYPT_MODE_CBC
    .判断 (数组 [2] ＝ “ECB”)
        模式代码 ＝ #CRYPT_MODE_ECB
    .判断 (数组 [2] ＝ “OFB”)
        模式代码 ＝ #CRYPT_MODE_OFB
    .判断 (数组 [2] ＝ “CFB”)
        模式代码 ＝ #CRYPT_MODE_CFB
    .判断 (数组 [2] ＝ “CTS”)
        模式代码 ＝ #CRYPT_MODE_CTS
    .默认
        返回 ({ })
    .判断结束
    
    密钥字节集 ＝ 密钥
    密钥长度 ＝ 取字节集长度 (密钥字节集)
    .如果真 (密钥长度 ≠ 块大小)
        .如果 (密钥长度 ＞ 块大小)
            密钥字节集 ＝ 取字节集左边 (密钥字节集, 块大小)
        .否则
            密钥字节集 ＝ 密钥字节集 ＋ 取空白字节集 (块大小 － 取字节集长度 (密钥字节集))
        .如果结束
        
    .如果真结束
    
    返回 (取对称算法加密_块 (数据, 密钥字节集, 算法代码, IV, 填充, 模式代码))
    

.子程序 对称解密, 字节集, 公开, 支持 RC2/4，AES，DES，3DES
    .参数 数据, 字节集
    .参数 密钥, 字节集, , 如果不是RC2和RC4，则密钥长度必须为块大小,否则会填充{0}或截取
    .参数 算法, 文本型, 可空, #对称算法_***
    .参数 填充, 整数型, 可空, #数据填充_*** 默认为 PKCS5_PADDING，如果是RC2和RC4，无需提供
    .参数 IV, 字节集, 可空, 如果是RC2和RC4，无需提供，否则默认为16个{0}字节
    .局部变量 数组, 文本型, , "0"
    .局部变量 密钥字节集, 字节集
    .局部变量 密钥长度, 整数型
    .局部变量 算法代码, 整数型
    .局部变量 模式代码, 整数型
    .局部变量 块大小, 整数型

    .判断开始 (算法 ＝ “RC2”)
        返回 (取对称算法解密_流 (数据, 密钥, #CALG_RC2))
    .判断 (算法 ＝ “RC4”)
        返回 (取对称算法解密_流 (数据, 密钥, #CALG_RC4))
    .默认
        
    .判断结束
    数组 ＝ 分割文本 (算法, “-”, )
    .如果真 (取数组成员数 (数组) ≠ 2)
        返回 ({ })
    .如果真结束
    
    .如果真 (IV ＝ { })
        IV ＝ { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
    .如果真结束
    
    .如果真 (填充 ＝ 0)
        填充 ＝ 5
    .如果真结束
    .如果真 (填充 ＜ 1 或 填充 ＞ 7)
        返回 ({ })
    .如果真结束
    
    
    .判断开始 (数组 [1] ＝ “AES”)
        算法代码 ＝ #CALG_AES_128
        块大小 ＝ 16
    .判断 (数组 [1] ＝ “AES192”)
        算法代码 ＝ #CALG_AES_192
        块大小 ＝ 24
    .判断 (数组 [1] ＝ “AES256”)
        算法代码 ＝ #CALG_AES_256
        块大小 ＝ 32
    .判断 (数组 [1] ＝ “DES”)
        算法代码 ＝ #CALG_DES
        块大小 ＝ 8
    .判断 (数组 [1] ＝ “3DES”)
        算法代码 ＝ #CALG_3DES
        块大小 ＝ 24
    .默认
        返回 ({ })
    .判断结束
    
    .判断开始 (数组 [2] ＝ “CBC”)
        模式代码 ＝ #CRYPT_MODE_CBC
    .判断 (数组 [2] ＝ “ECB”)
        模式代码 ＝ #CRYPT_MODE_ECB
    .判断 (数组 [2] ＝ “OFB”)
        模式代码 ＝ #CRYPT_MODE_OFB
    .判断 (数组 [2] ＝ “CFB”)
        模式代码 ＝ #CRYPT_MODE_CFB
    .判断 (数组 [2] ＝ “CTS”)
        模式代码 ＝ #CRYPT_MODE_CTS
    .默认
        返回 ({ })
    .判断结束
    
    
    
    
    
    密钥字节集 ＝ 密钥
    密钥长度 ＝ 取字节集长度 (密钥字节集)
    .如果真 (密钥长度 ≠ 块大小)
        .如果 (密钥长度 ＞ 块大小)
            密钥字节集 ＝ 取字节集左边 (密钥字节集, 块大小)
        .否则
            密钥字节集 ＝ 密钥字节集 ＋ 取空白字节集 (块大小 － 取字节集长度 (密钥字节集))
        .如果结束
        
    .如果真结束
    
    返回 (取对称算法解密_块 (数据, 密钥字节集, 算法代码, IV, 填充, 模式代码))
    

.子程序 AES_DES_算法, 字节集, 公开, 参考常量  #对称算法_
    .参数 对称算法, 文本型, , 参考常量  #对称算法_
    .参数 数据, 字节集
    .参数 密钥, 字节集
    .参数 是否加解, 逻辑型, , 真=加密
    .局部变量 填充方式, 整数型
    .局部变量 结果, 字节集

    填充方式 ＝ #数据填充_ZERO_PADDING
    .如果 (是否加解)
        结果 ＝ 对称加密 (数据, 密钥, 对称算法, 填充方式)
    .否则
        结果 ＝ 对称解密 (数据, 密钥, 对称算法, 填充方式)
    .如果结束
    返回 (结果)

.子程序 编码_八进制解码, 字节集, 公开, \276\253\322\327\302\333\314\263 => 精易论坛
    .参数 欲解码的数据, 文本型
    .局部变量 ptr, 整数型
    .局部变量 dwSize, 整数型
    .局部变量 pBuf, 整数型
    .局部变量 cBuf, 字节型
    .局部变量 pTemp, 整数型
    .局部变量 szBuf, 字节集
    .局部变量 nSize, 整数型
    .局部变量 i, 整数型

    ptr ＝ 取指针_文本型 (欲解码的数据)
    dwSize ＝ 取文本长度 (欲解码的数据)
    pBuf ＝ LocalAlloc (#LMEM_ZEROINIT, dwSize)
    nSize ＝ ptr ＋ dwSize
    pTemp ＝ LocalAlloc (#LMEM_ZEROINIT, 4)
    .判断循环首 (ptr ＜ nSize)
        cBuf ＝ __get_byte (ptr, 0)
        .如果 (cBuf ＝ 92) ' \
            memcpy (pTemp, ptr ＋ 1, 3)
            sscanf (pTemp, “%o”, cBuf)
            __set_byte (pBuf, i, cBuf)
            ptr ＝ ptr ＋ 4
        .否则
            __set_byte (pBuf, i, cBuf)
            ptr ＝ ptr ＋ 1
        .如果结束
        i ＝ i ＋ 1
    .判断循环尾 ()
    LocalFree (pTemp)
    szBuf ＝ 指针到字节集 (pBuf, i)
    LocalFree (pBuf)
    返回 (szBuf)

.版本 2

.程序集 集_网页
.程序集变量 集_屏蔽信息框线程句柄, 整数型, , , 开始屏蔽信息框
.程序集变量 集_点击信息框标识文本, 文本型, , , 点击屏蔽信息框
.程序集变量 集_按钮的标题, 文本型, , , 点击屏蔽信息框

.子程序 网页_取IP地址, 精易_IP归属地, 公开
    .局部变量 局_网址, 文本型
    .局部变量 局_返回, 文本型
    .局部变量 局_Json, 类_json
    .局部变量 局_归属地, 精易_IP归属地

    局_网址 ＝ “https://ip.taobao.com/outGetIpInfo?ip=myip&accessKey=alibaba-inc”
    局_返回 ＝ 编码_Utf8到Ansi (网页_访问 (局_网址))
    局_返回 ＝ 子文本替换 (局_返回, 字符 (10), , , , 真)
    局_Json.解析 (局_返回)
    局_归属地.IP ＝ 局_Json.取通用属性 (“data.ip”)
    局_归属地.国家 ＝ 局_Json.取通用属性 (“data.country”)
    局_归属地.省份 ＝ 局_Json.取通用属性 (“data.region”)
    局_归属地.城市 ＝ 局_Json.取通用属性 (“data.city”)
    局_归属地.运营商 ＝ 局_Json.取通用属性 (“data.isp”)
    返回 (局_归属地)

.子程序 网页_IE浏览器网页跳转静音, , 公开, 默认为真  真=静音
    .参数 参_是否静音, 逻辑型, 可空

    .如果真 (是否为空 (参_是否静音))
        参_是否静音 ＝ 真
    .如果真结束
    CoInternetSetFeatureEnabled (#FEATURE_DISABLE_NAVIGATION_SOUNDS, #SET_FEATURE_ON_PROCESS, 参_是否静音) ' 21

.子程序 网页_协议头_取信息, 文本型, 公开, 取出协议头中的某个值 例如302跳转协议头中的 Location
    .参数 参_源协议头, 文本型
    .参数 参_键名, 文本型, , 例如：Location
    .局部变量 局_数组, 文本型, , "0"
    .局部变量 i, 整数型
    .局部变量 局_数据, 文本型
    .局部变量 局_长度, 整数型

    局_数组 ＝ 分割文本 (参_源协议头, #换行符, )
    局_长度 ＝ 取文本长度 (参_键名)
    .计次循环首 (取数组成员数 (局_数组), i)
        .如果真 (取文本左边 (局_数组 [i], 局_长度) ＝ 参_键名)
            局_数据 ＝ 文本_取右边 (局_数组 [i], 参_键名 ＋ “: ”)
            返回 (局_数据)
        .如果真结束
        
    .计次循环尾 ()
    返回 (“”)
    
    

.子程序 网页_JS格式化_EX, 文本型, 公开
    .参数 参数1, 文本型
    .局部变量 JS命令, 类_脚本组件
    .局部变量 结果, 文本型

    JS命令.执行 (#JS格式化EX)
    结果 ＝ JS命令.运行 (“FJsDecoder”, 参数1)
    返回 (结果)

.子程序 网页_文字翻译, 文本型, 公开, 调用 有道翻译  支持中翻英  或  多语翻中
    .参数 参_待翻译, 文本型
    .局部变量 局_网址, 文本型
    .局部变量 局_方式, 整数型
    .局部变量 ADD_协议头, 类_POST数据类
    .局部变量 局_提交协议头, 文本型
    .局部变量 局_结果, 字节集
    .局部变量 局_返回, 文本型
    .局部变量 局_待翻译, 文本型

    局_待翻译 ＝ 编码_URL编码 (参_待翻译, , 真)
    局_网址 ＝ “http://elephant.browser.360.cn/?t=translate&i=” ＋ 局_待翻译 ＋ “&type=AUTO&doctype=text&xmlVersion=1.1&keyfrom=360se&m=youdao”
    局_方式 ＝ 0
    ADD_协议头.添加 (“Connection”, “ keep-alive”)
    ADD_协议头.添加 (“Referer”, “ http://fanyi.youdao.com/translate”)
    ADD_协议头.添加 (“User-Agent”, “ Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 Safari/537.36”)
    ADD_协议头.添加 (“Accept-Language”, “ zh-CN,zh;q=0.8”)
    局_提交协议头 ＝ ADD_协议头.获取协议头数据 ()
    局_结果 ＝ 网页_访问_对象 (局_网址, 局_方式, , , , 局_提交协议头, , , , , , , , , , , )
    局_返回 ＝ 到文本 (编码_编码转换对象 (局_结果))
    局_返回 ＝ 文本_取右边 (局_返回, “result=”)
    返回 (局_返回)

.子程序 网页_更改IE版本, 逻辑型, 公开, 需要XP以上系统支持，且IE版本不低于8，写入后永久生效。多数情况需获取管理员权限，详情参阅：https://docs.microsoft.com/en-us/previous-versions/windows/internet-explorer/ie-developer/general-info/ee330730(v=vs.85)#browser-emulation
    .参数 类型, 整数型, 可空, 为空或0移除写入的版本  1=ie7  2=ie8   3=ie9   4=ie10   5=ie11
    .参数 是否使用所有用户, 逻辑型, 可空, 默认为假！使用当前用户，为真则使用所有用户。
    .局部变量 局_处理器, 文本型
    .局部变量 参数, 整数型

    ' https://bbs.125.la/thread-14547669-1-1.html
    
    局_处理器 ＝ 读环境变量 (“PROCESSOR_ARCHITECTURE”)
    
    .如果真 (类型 ≤ 0 或 类型 ＞ 5)
        .如果真 (是否使用所有用户)
            .判断开始 (局_处理器 ＝ “x86”)
                返回 (删除注册项 (#本地机器, “SOFTWARE\Microsoft\Internet Explorer\MAIN\FeatureControl\FEATURE_BROWSER_EMULATION\” ＋ 取执行文件名 ()))
            .判断 (局_处理器 ＝ “AMD64”)
                返回 (删除注册项 (#本地机器, “SOFTWARE\Wow6432Node\Microsoft\Internet Explorer\MAIN\FeatureControl\FEATURE_BROWSER_EMULATION\” ＋ 取执行文件名 ()))
            .默认
                
            .判断结束
            返回 (假)
        .如果真结束
        返回 (删除注册项 (#现行用户, “Software\Microsoft\Internet Explorer\Main\FeatureControl\FEATURE_BROWSER_EMULATION\” ＋ 取执行文件名 ()))
    .如果真结束
    
    .判断开始 (类型 ＝ 1)
        参数 ＝ 7000 ' IE 7
    .判断 (类型 ＝ 2)
        参数 ＝ 8000 ' IE 8
    .判断 (类型 ＝ 3)
        参数 ＝ 9000 ' IE 9
    .判断 (类型 ＝ 4)
        参数 ＝ 10000 ' IE 10
    .判断 (类型 ＝ 5)
        参数 ＝ 11000 ' IE 11
    .默认
        
    .判断结束
    
    .如果真 (是否使用所有用户)
        .判断开始 (局_处理器 ＝ “x86”)
            返回 (写注册项 (#本地机器, “SOFTWARE\Microsoft\Internet Explorer\MAIN\FeatureControl\FEATURE_BROWSER_EMULATION\” ＋ 取执行文件名 (), 参数))
        .判断 (局_处理器 ＝ “AMD64”)
            返回 (写注册项 (#本地机器, “SOFTWARE\Wow6432Node\Microsoft\Internet Explorer\MAIN\FeatureControl\FEATURE_BROWSER_EMULATION\” ＋ 取执行文件名 (), 参数))
        .默认
            
        .判断结束
        返回 (假)
    .如果真结束
    
    返回 (写注册项 (#现行用户, “Software\Microsoft\Internet Explorer\Main\FeatureControl\FEATURE_BROWSER_EMULATION\” ＋ 取执行文件名 (), 参数))
    ' 写注册项 (#现行用户, “Software\Microsoft\Internet Explorer\Main\FeatureControl\FEATURE_GPU_RENDERING\” ＋ 取执行文件名 (), 1)

.子程序 网页_eval解密, 文本型, 公开
    .参数 原JS文本, 文本型, , 需要加密\解密的JS源文本
    .局部变量 脚本, 类_脚本组件
    .局部变量 结果, 文本型

    结果 ＝ 脚本.计算表达式 (子文本替换 (原JS文本, “eval”, “”, , , 真))
    返回 (结果)

.子程序 网页_eval加密, 文本型, 公开
    .参数 原JS文本, 文本型, , 需要加密\解密的JS源文本
    .局部变量 脚本, 类_脚本组件
    .局部变量 结果, 文本型

    脚本.执行 (#eval加密)
    结果 ＝ 脚本.运行 (“encode”, 原JS文本)
    返回 (结果)

.子程序 内部_协议头取值, 文本型
    .参数 协议头, 文本型
    .局部变量 位置, 整数型
    .局部变量 结果, 文本型

    位置 ＝ 寻找文本 (协议头, “:”, , 假)
    .如果真 (位置 ≠ -1)
        结果 ＝ 取文本右边 (协议头, 取文本长度 (协议头) － 位置)
    .如果真结束
    返回 (删首尾空 (结果))

.子程序 内部_协议头取名, 文本型
    .参数 协议头, 文本型
    .局部变量 位置, 整数型
    .局部变量 结果, 文本型

    位置 ＝ 寻找文本 (协议头, “:”, , 假)
    .如果真 (位置 ≠ -1)
        结果 ＝ 取文本左边 (协议头, 位置 － 1)
    .如果真结束
    返回 (删首尾空 (结果))

.子程序 内部_设Cookie, , , 设定前，请先清除
    .参数 域名, 文本型, , 只接受域名
    .参数 Cookie内容, 文本型, , 以“;”号结尾
    .局部变量 网址, 文本型
    .局部变量 计次, 整数型
    .局部变量 Cookies, 文本型, , "0"

    网址 ＝ “http://” ＋ 域名
    Cookies ＝ 分割文本 (Cookie内容, “;”, )
    .计次循环首 (取数组成员数 (Cookies), 计次)
        InternetSetCookieA (网址, 内部_Cookie取名 (Cookies [计次]), 内部_Cookie取值 (Cookies [计次]))
    .计次循环尾 ()

.子程序 网页_Cookie合并更新ex, 文本型, 公开, 返回更新后的Cookie 感谢【小小n】提供
    .参数 旧Cookie, 文本型, 参考, a=1; b=2
    .参数 新Cookie, 文本型, , a=1; b=2
    .局部变量 局_新Cookie组, 文本型, , "0"
    .局部变量 局_合并Cookie组, 文本型, , "0"
    .局部变量 局_计次, 整数型
    .局部变量 初步合并, 文本型
    .局部变量 已存在名称, 文本型, , "0"
    .局部变量 C, 整数型
    .局部变量 倒序索引, 整数型
    .局部变量 i, 整数型
    .局部变量 是否存在, 逻辑型
    .局部变量 名称, 文本型
    .局部变量 值, 文本型
    .局部变量 局_合并cookie, 文本型

    
    ' 初步合并 顺序：旧→新
    ' 能处理单次http请求返回多个同名Cookie的情况,例如同时存在 Set-Cookie: a=1;  和 Set-Cookie: a=2; 这种情况以后者为新
    初步合并 ＝ 旧Cookie ＋ 选择 (旧Cookie ≠ “” 且 新Cookie ≠ “”, “; ”, “”) ＋ 新Cookie
    ' 输出调试文本 (“初步合并: ” ＋ 初步合并)
    
    局_合并Cookie组 ＝ 分割文本 (初步合并, “; ”, )
    C ＝ 取数组成员数 (局_合并Cookie组)
    .计次循环首 (C, 局_计次)
        ' 更新 倒序：新→旧，名称已记录的Cookie一定是更加新的Cookie
        倒序索引 ＝ C ＋ 1 － 局_计次
        名称 ＝ 内部_Cookie取名ex (删首尾空 (局_合并Cookie组 [倒序索引]))
        值 ＝ 内部_Cookie取值 (删首尾空 (局_合并Cookie组 [倒序索引]))
        .如果 (名称 ≠ “”) ' 过滤
            是否存在 ＝ 假
            .计次循环首 (取数组成员数 (已存在名称), i)
                .如果真 (已存在名称 [i] ＝ 名称)
                    是否存在 ＝ 真
                    跳出循环 ()
                .如果真结束
                
            .计次循环尾 ()
            .如果 (是否存在 ＝ 假)
                .如果 (值 ≠ “” 且 到小写 (值) ≠ “deleted”) ' 过滤
                    ' 输出调试文本 (“有效[” ＋ 名称 ＋ “=” ＋ 值 ＋ “]”)
                    加入成员 (局_新Cookie组, 局_合并Cookie组 [倒序索引])
                .否则
                    ' 输出调试文本 (“名称[” ＋ 名称 ＋ “]过滤无效值”)
                .如果结束
                加入成员 (已存在名称, 名称)
            .否则
                ' 输出调试文本 (“名称[” ＋ 名称 ＋ “]已存在”)
            .如果结束
            
        .否则
            ' 输出调试文本 (“过滤无效名称[” ＋ 局_合并Cookie组 [倒序索引] ＋ “]”)
        .如果结束
        
    .计次循环尾 ()
    局_合并cookie ＝ “”
    .计次循环首 (取数组成员数 (局_新Cookie组), i)
        .如果真 (局_合并cookie ≠ “”)
            局_合并cookie ＝ “; ” ＋ 局_合并cookie
        .如果真结束
        局_合并cookie ＝ 局_新Cookie组 [i] ＋ 局_合并cookie
    .计次循环尾 ()
    旧Cookie ＝ 局_合并cookie
    返回 (局_合并cookie)

.子程序 内部_Cookie取名ex, 文本型
    .参数 Cookie, 文本型
    .局部变量 位置, 整数型
    .局部变量 结果, 文本型

    位置 ＝ 寻找文本 (Cookie, “=”, , 假)
    .判断开始 (位置 ≠ -1)
        ' 输出调试文本 (Cookie, 位置)
        结果 ＝ 取文本左边 (Cookie, 位置 － 1)
    .默认
        结果 ＝ “” ' 无效名称应返回空
    .判断结束
    返回 (删首尾空 (结果))

.子程序 网页_Cookie合并更新, 文本型, 公开, 返回更新后的Cookie
    .参数 旧Cookie, 文本型, 参考
    .参数 新Cookie, 文本型
    .局部变量 局_旧Cookie组, 文本型, , "0"
    .局部变量 局_新Cookie组, 文本型, , "0"
    .局部变量 局_计次, 整数型

    ' 初步格式化
    旧Cookie ＝ 删首尾空 (旧Cookie)
    .如果真 (取文本右边 (旧Cookie, 1) ＝ “;”)
        旧Cookie ＝ 旧Cookie ＋ 字符 (#空格键)
    .如果真结束
    
    新Cookie ＝ 删首尾空 (新Cookie)
    .如果真 (取文本右边 (新Cookie, 1) ＝ “;”)
        新Cookie ＝ 新Cookie ＋ 字符 (#空格键)
    .如果真结束
    
    ' 开始更新Cookie
    局_旧Cookie组 ＝ 分割文本 (旧Cookie, “; ”, )
    局_新Cookie组 ＝ 分割文本 (新Cookie, “; ”, )
    .计次循环首 (取数组成员数 (局_旧Cookie组), 局_计次)
        .如果真 (内部_数组成员是否存在1 (局_新Cookie组, 内部_Cookie取名 (局_旧Cookie组 [局_计次])) ＝ 假)
            加入成员 (局_新Cookie组, 局_旧Cookie组 [局_计次])
        .如果真结束
        
    .计次循环尾 ()
    ' 去除无效的Cookie
    旧Cookie ＝ “”
    .计次循环首 (取数组成员数 (局_新Cookie组), 局_计次)
        .如果真 (取文本右边 (局_新Cookie组 [局_计次], 8) ≠ “=deleted”)
            旧Cookie ＝ 旧Cookie ＋ 局_新Cookie组 [局_计次] ＋ “; ”
        .如果真结束
        
    .计次循环尾 ()
    旧Cookie ＝ 取文本左边 (旧Cookie, 取文本长度 (旧Cookie) － 2)
    ' 对重复的Cookie进行合并
    旧Cookie ＝ 文本_去重复文本 (旧Cookie, “; ”)
    返回 (旧Cookie)

.子程序 内部_数组成员是否存在1, 逻辑型, , Cookie处理专用
    .参数 数组, 文本型, 数组
    .参数 要判断值, 文本型
    .局部变量 局_计次, 整数型

    .计次循环首 (取数组成员数 (数组), 局_计次)
        .如果真 (内部_Cookie取名 (数组 [局_计次]) ＝ 要判断值)
            返回 (真)
        .如果真结束
        
    .计次循环尾 ()
    返回 (假)

.子程序 内部_Cookie取值, 文本型
    .参数 Cookie, 文本型
    .局部变量 位置, 整数型
    .局部变量 结果, 文本型

    位置 ＝ 寻找文本 (Cookie, “=”, , 假)
    .如果真 (位置 ≠ -1)
        结果 ＝ 取文本右边 (Cookie, 取文本长度 (Cookie) － 位置)
    .如果真结束
    返回 (结果)

.子程序 内部_Cookie取名, 文本型
    .参数 Cookie, 文本型
    .局部变量 位置, 整数型
    .局部变量 结果, 文本型

    位置 ＝ 寻找文本 (Cookie, “=”, , 假)
    .判断开始 (位置 ≠ -1)
        结果 ＝ 取文本左边 (Cookie, 位置 － 1)
    .默认
        结果 ＝ Cookie
    .判断结束
    返回 (删首尾空 (结果))

.子程序 网页_处理协议头, 文本型, 公开, 将协议头中的键名首字母处理为大写
    .参数 参_原始协议头, 文本型
    .局部变量 局_数组, 文本型, , "0"
    .局部变量 i, 整数型
    .局部变量 局_键名, 文本型
    .局部变量 局_键名右, 文本型
    .局部变量 局_键名左, 文本型
    .局部变量 局_协议头, 文本型
    .局部变量 局_键名拼接, 文本型
    .局部变量 局_键名数组, 文本型, , "0"
    .局部变量 局_总数, 整数型
    .局部变量 x, 整数型
    .局部变量 局_键值, 文本型
    .局部变量 局_冒号位置, 整数型

    局_数组 ＝ 分割文本 (参_原始协议头, #换行符, )
    .计次循环首 (取数组成员数 (局_数组), i)
        局_冒号位置 ＝ 寻找文本 (局_数组 [i], “:”, , 假)
        .如果真 (局_冒号位置 ＝ -1)
            到循环尾 ()
        .如果真结束
        
        局_键名 ＝ 取文本中间 (局_数组 [i], 1, 局_冒号位置 － 1)
        .如果 (寻找文本 (局_键名, “-”, , 假) ≠ -1)
            局_键名拼接 ＝ “”
            局_键名数组 ＝ 分割文本 (局_键名, “-”, )
            局_总数 ＝ 取数组成员数 (局_键名数组)
            .计次循环首 (局_总数, x)
                .如果 (x ＝ 局_总数)
                    局_键名拼接 ＝ 局_键名拼接 ＋ 文本_首字母改大写 (局_键名数组 [x])
                .否则
                    局_键名拼接 ＝ 局_键名拼接 ＋ 文本_首字母改大写 (局_键名数组 [x]) ＋ “-”
                .如果结束
                
            .计次循环尾 ()
            
            局_键名 ＝ 局_键名拼接
        .否则
            局_键名 ＝ 文本_首字母改大写 (局_键名)
        .如果结束
        
        局_键值 ＝ 取文本右边 (局_数组 [i], 取文本长度 (局_数组 [i]) － 取文本长度 (局_键名))
        .如果真 (取代码 (取文本左边 (局_键值, 1), ) ＝ 32)
            局_键值 ＝ 取文本右边 (局_键值, 取文本长度 (局_键值) － 1)
        .如果真结束
        
        局_协议头 ＝ 局_协议头 ＋ 局_键名 ＋ 局_键值 ＋ #换行符
        
        
    .计次循环尾 ()
    局_协议头 ＝ 取文本左边 (局_协议头, 取文本长度 (局_协议头) － 取文本长度 (#换行符))
    返回 (局_协议头)

.子程序 网页_处理协议头ex, 文本型, 公开, 将协议头中的键名首字母处理为大写
    .参数 参_原始协yi头, 文本型
    .局部变量 首分, 文本型, , "0"
    .局部变量 次分, 文本型, , "0"
    .局部变量 代码, 整数型
    .局部变量 位置, 整数型
    .局部变量 输出, 文本型
    .局部变量 文件号, 整数型
    .局部变量 i, 整数型

    ' 该命令出自：https://bbs.125.la/thread-14325247-1-1.html
    文件号 ＝ 打开内存文件 ()
    首分 ＝ 分割文本 (参_原始协yi头, #换行符, )
    .计次循环首 (取数组成员数 (首分), i)
        次分 ＝ 分割文本 (首分 [i], “:”, )
        .如果真 (取数组成员数 (次分) ≥ 2)
            代码 ＝ 取代码 (次分 [1], 1)
            .如果真 (代码 ≥ 97 且 代码 ≤ 122)
                次分 [1] ＝ 文本替换 (次分 [1], 1, 1, 字符 (代码 － 32))
                位置 ＝ 寻找文本 (次分 [1], “-”, , 假)
                .判断循环首 (位置 ≠ -1)
                    位置 ＝ 位置 ＋ 1
                    代码 ＝ 取代码 (次分 [1], 位置)
                    .如果真 (代码 ≥ 97 且 代码 ≤ 122)
                        次分 [1] ＝ 文本替换 (次分 [1], 位置, 1, 字符 (代码 － 32))
                    .如果真结束
                    位置 ＝ 寻找文本 (次分 [1], “-”, 位置, 假)
                .判断循环尾 ()
                首分 [i] ＝ 文本替换 (首分 [i], 1, 取文本长度 (次分 [1]), 次分 [1])
            .如果真结束
            代码 ＝ 取代码 (次分 [2], 1)
            .如果真 (代码 ≠ 32)
                首分 [i] ＝ 文本替换 (首分 [i], 取文本长度 (次分 [1]) ＋ 1, 1, “: ”)
            .如果真结束
            
        .如果真结束
        写文本行 (文件号, 首分 [i])
    .计次循环尾 ()
    移到文件首 (文件号)
    输出 ＝ 读入文本 (文件号, )
    关闭文件 (文件号)
    返回 (输出)

.子程序 网页_访问_对象, 字节集, 公开, 使用WinHttp的对象方式访问网页
    .参数 网址, 文本型, , 完整的网页地址,必须包含http://或者https://
    .参数 访问方式, 整数型, 可空, 0=GET 1=POST 2=HEAD 3=PUT  4=OPTIONS  5=DELETE  6=TRACE  7=CONNECT  8=PATCH
    .参数 提交信息, 文本型, 可空, "POST"专用   自动UTF8编码
    .参数 提交Cookies, 文本型, 参考 可空, 设置提交时的cookie
    .参数 返回Cookies, 文本型, 参考 可空, 返回的Cookie
    .参数 附加协议头, 文本型, 可空, 一行一个请用换行符隔开
    .参数 返回协议头, 文本型, 参考 可空, 返回的协议头
    .参数 返回状态代码, 整数型, 参考 可空, 网页返回的状态代码，例如：200；302；404等
    .参数 禁止重定向, 逻辑型, 可空, 默认不禁止网页重定向
    .参数 字节集提交, 字节集, 可空, 提交字节集数据
    .参数 代理地址, 文本型, 可空, 代理地址，格式为 8.8.8.8:88
    .参数 超时, 整数型, 可空, 秒|默认为15秒,-1为无限等待
    .参数 代理用户名, 文本型, 可空, 用户名
    .参数 代理密码, 文本型, 可空, 密码
    .参数 代理标识, 整数型, 可空, 代理标识，默认为1，0为路由器
    .参数 对象继承, 对象, 可空, 此处可自行提供对象，不再主动创建
    .参数 是否自动合并更新Cookie, 逻辑型, 可空, 默认为真，自动合并更新
    .参数 是否补全必要协议头, 逻辑型, 可空, 当附件协议头为空时自动添加必要的UA协议头 默认为真，假将不再添加非传入协议头
    .参数 是否处理协议头大小写, 逻辑型, 可空, 将协议头中的键名首字母处理为大写  默认为真
    .局部变量 局_访问方式, 文本型
    .局部变量 局_WinHttp, 对象
    .局部变量 局_发送协议头, 文本型, , "0"
    .局部变量 局_返回协议头, 文本型, , "0"
    .局部变量 局_计次, 整数型
    .局部变量 局_网页数据, 字节集
    .局部变量 局_变体提交, 变体型
    .局部变量 局_附加协议头, 文本型

    .如果真 (是否为空 (是否自动合并更新Cookie))
        是否自动合并更新Cookie ＝ 真
    .如果真结束
    
    .如果真 (是否为空 (是否补全必要协议头))
        是否补全必要协议头 ＝ 真
    .如果真结束
    
    .如果真 (是否为空 (是否处理协议头大小写))
        是否处理协议头大小写 ＝ 真
    .如果真结束
    
    线程_初始化COM库 ()
    
    .如果真 (访问方式 ＜ 0 或 访问方式 ＞ 8)
        访问方式 ＝ 0
    .如果真结束
    局_访问方式 ＝ 多项选择 (访问方式 ＋ 1, “GET”, “POST”, “HEAD”, “PUT”, “OPTIONS”, “DELETE”, “TRACE”, “CONNECT”, “PATCH”)
    
    .判断开始 (是否为空 (对象继承))
        .如果真 (局_WinHttp.创建 (“WinHttp.WinHttpRequest.5.1”, ) ＝ 假)
            返回 ({ })
        .如果真结束
        
    .默认
        局_WinHttp ＝ 对象继承
    .判断结束
    
    .如果真 (超时 ≠ -1)
        .如果 (超时 ＜ 1)
            超时 ＝ 15000
        .否则
            超时 ＝ 超时 × 1000
        .如果结束
        局_WinHttp.方法 (“SetTimeouts”, 超时, 超时, 超时, 超时)
    .如果真结束
    
    .如果真 (代理地址 ≠ “”)
        局_WinHttp.方法 (“SetProxy”, 2, 代理地址)
    .如果真结束
    局_WinHttp.方法 (“Open”, 局_访问方式, 网址, 假)
    .如果真 (禁止重定向)
        局_WinHttp.写属性 (“Option”, 6, 0)
    .如果真结束
    
    局_WinHttp.写属性 (“Option”, 4, 13056) ' 忽略错误标志
    
    局_附加协议头 ＝ 附加协议头
    .如果真 (是否补全必要协议头)
        .如果真 (寻找文本 (局_附加协议头, “Accept:”, , 真) ＝ -1)
            局_附加协议头 ＝ 局_附加协议头 ＋ #换行符 ＋ “Accept: */*”
        .如果真结束
        
        .如果真 (寻找文本 (局_附加协议头, “Referer:”, , 真) ＝ -1)
            局_附加协议头 ＝ 局_附加协议头 ＋ #换行符 ＋ “Referer: ” ＋ 网址
        .如果真结束
        
        .如果真 (寻找文本 (局_附加协议头, “Accept-Language:”, , 真) ＝ -1)
            局_附加协议头 ＝ 局_附加协议头 ＋ #换行符 ＋ “Accept-Language: zh-cn”
        .如果真结束
        
        .如果真 (寻找文本 (局_附加协议头, “User-Agent:”, , 真) ＝ -1)
            局_附加协议头 ＝ 局_附加协议头 ＋ #换行符 ＋ “User-Agent: Mozilla/4.0 (compatible; MSIE 9.0; Windows NT 6.1)”
        .如果真结束
        
        .如果真 (访问方式 ＝ 1)
            .如果真 (寻找文本 (局_附加协议头, “Content-Type:”, , 真) ＝ -1)
                局_附加协议头 ＝ 局_附加协议头 ＋ #换行符 ＋ “Content-Type: application/x-www-form-urlencoded”
            .如果真结束
            
        .如果真结束
        
    .如果真结束
    
    .如果真 (是否处理协议头大小写)
        局_附加协议头 ＝ 网页_处理协议头 (局_附加协议头)
    .如果真结束
    
    .如果真 (代理地址 ≠ “” 且 代理用户名 ≠ “”)
        .如果真 (是否为空 (代理标识))
            代理标识 ＝ 1
        .如果真结束
        
        局_WinHttp.方法 (“SetCredentials”, 代理用户名, 代理密码, 代理标识)
        .如果真 (代理标识 ＝ 1)
            局_WinHttp.方法 (“SetRequestHeader”, “Proxy-Authorization”, “Basic ” ＋ 编码_BASE64编码 (到字节集 (代理用户名 ＋ “:” ＋ 代理密码)))
        .如果真结束
        
    .如果真结束
    
    .如果真 (取反 (是否为空 (提交Cookies)))
        .如果真 (取文本长度 (提交Cookies) ＞ 0)
            .如果真 (寻找文本 (提交Cookies, “Cookie:”, , 真) ≠ -1)
                提交Cookies ＝ 子文本替换 (提交Cookies, “Cookie:”, “”, , , 假)
            .如果真结束
            
        .如果真结束
        局_WinHttp.方法 (“SetRequestHeader”, “Cookie”, 提交Cookies)
    .如果真结束
    
    
    .判断开始 (寻找文本 (局_附加协议头, #换行符, , 假) ＝ -1)
        局_WinHttp.方法 (“SetRequestHeader”, 内部_协议头取名 (局_附加协议头), 内部_协议头取值 (局_附加协议头))
    .默认
        局_发送协议头 ＝ 分割文本 (局_附加协议头, #换行符, )
        .计次循环首 (取数组成员数 (局_发送协议头), 局_计次)
            .如果真 (局_发送协议头 [局_计次] ≠ “”)
                .如果真 (内部_协议头取名 (局_发送协议头 [局_计次]) ＝ “Connection”)
                    .如果真 (内部_协议头取值 (局_发送协议头 [局_计次]) ＝ “keep-alive”)
                        到循环尾 () ' 筛选排除此参数 避免协议头有此参数 HTTP对象又自动添加此参数
                    .如果真结束
                    
                .如果真结束
                
                局_WinHttp.方法 (“SetRequestHeader”, 内部_协议头取名 (局_发送协议头 [局_计次]), 内部_协议头取值 (局_发送协议头 [局_计次]))
            .如果真结束
            
        .计次循环尾 ()
    .判断结束
    
    .判断开始 (字节集提交 ＝ { })
        局_WinHttp.方法 (“Send”, 提交信息)
    .默认
        局_变体提交.赋值 (字节集提交, )
        局_WinHttp.方法 (“Send”, 局_变体提交)
    .判断结束
    局_网页数据 ＝ 局_WinHttp.读属性 (“ResponseBody”, ).取字节集 ()
    返回协议头 ＝ 局_WinHttp.读文本属性 (“GetAllResponseHeaders”, )
    返回状态代码 ＝ 局_WinHttp.读数值属性 (“Status”, )
    局_WinHttp.读文本属性 (“StatusText”, )
    局_返回协议头 ＝ 分割文本 (返回协议头, #换行符, )
    返回Cookies ＝ HeadersToCookie (局_返回协议头)
    .如果真 (是否自动合并更新Cookie)
        .如果真 (取反 (是否为空 (提交Cookies)))
            返回Cookies ＝ 网页_Cookie合并更新 (提交Cookies, 返回Cookies)
        .如果真结束
        
    .如果真结束
    局_WinHttp.清除 ()
    线程_取消COM库 ()
    返回 (局_网页数据)

.子程序 网页_访问, 字节集, 公开, 使用WinInet的API方式访问网页
    .参数 网址, 文本型, , 完整的网页地址,必须包含http://或者https://
    .参数 访问方式, 整数型, 可空, 0=GET 1=POST 2=HEAD 3=PUT  4=OPTIONS  5=DELETE  6=TRACE  7=CONNECT  8=PATCH
    .参数 提交信息, 文本型, 可空, POST专用
    .参数 提交Cookies, 文本型, 参考 可空, 设置提交时的cookie
    .参数 返回Cookies, 文本型, 可空, 返回的Cookie
    .参数 附加协议头, 文本型, 可空, 一行一个请用换行符隔开,建议填写常量值或文本值,防止因传参引发错误
    .参数 返回协议头, 文本型, 参考 可空, 返回的协议头
    .参数 禁止重定向, 逻辑型, 可空, 默认不禁止网页重定向
    .参数 字节集提交, 字节集, 可空, 提交字节集数据
    .参数 代理地址, 文本型, 可空, 代理地址，格式为:ip:port,例如:8.8.8.8:88
    .参数 是否自动合并更新Cookie, 逻辑型, 可空, 默认为真，自动合并更新
    .参数 是否补全必要协议头, 逻辑型, 可空, 当附件协议头为空时自动添加必要的UA协议头 默认为真，假将不再添加非传入协议头
    .参数 是否处理协议头大小写, 逻辑型, 可空, 将协议头中的键名首字母处理为大写  默认为真
    .参数 是否使用socks4代理, 逻辑型, 可空, 设置代理类型，假为http(s)代理，真为socks4代理
    .局部变量 局_Internet句柄, 整数型
    .局部变量 局_Internet连接句柄, 整数型
    .局部变量 局_HTTP请求句柄, 整数型
    .局部变量 局_计次, 整数型
    .局部变量 局_字节集, 字节集
    .局部变量 局_访问方式, 文本型
    .局部变量 局_User_Agent, 文本型
    .局部变量 局_返回协议头, 文本型, , "0"
    .局部变量 局_页面内容, 字节集
    .局部变量 局_请求标记, 整数型
    .局部变量 局_重定向地址, 文本型
    .局部变量 局_HTTPS, 逻辑型
    .局部变量 bAutoDecode, 整数型
    .局部变量 局_附加协议头, 文本型
    .局部变量 buffersIn, INTERNET_BUFFERSA
    .局部变量 dwStart, 整数型
    .局部变量 aryData, 字节集
    .局部变量 dwDataSize, 整数型
    .局部变量 dwOutSize, 整数型

    
    .如果真 (是否为空 (是否自动合并更新Cookie))
        是否自动合并更新Cookie ＝ 真
    .如果真结束
    
    .如果真 (是否为空 (是否补全必要协议头))
        是否补全必要协议头 ＝ 真
    .如果真结束
    
    .如果真 (是否为空 (是否处理协议头大小写))
        是否处理协议头大小写 ＝ 真
    .如果真结束
    
    局_附加协议头 ＝ 附加协议头
    .如果真 (是否处理协议头大小写)
        局_附加协议头 ＝ 网页_处理协议头 (局_附加协议头)
    .如果真结束
    
    ' 局_访问方式 ＝ 选择 (访问方式 ＝ 1, “POST”, “GET”)
    .如果真 (访问方式 ＜ 0 或 访问方式 ＞ 8)
        访问方式 ＝ 0
    .如果真结束
    局_访问方式 ＝ 多项选择 (访问方式 ＋ 1, “GET”, “POST”, “HEAD”, “PUT”, “OPTIONS”, “DELETE”, “TRACE”, “CONNECT”, “PATCH”)
    
    .如果真 (到小写 (取文本左边 (网址, 8)) ＝ “https://”)
        局_HTTPS ＝ 真
    .如果真结束
    
    .判断开始 (寻找文本 (局_附加协议头, “User-Agent:”, , 真) ≠ -1)
        局_User_Agent ＝ 删首尾空 (文本_取出中间文本 (局_附加协议头 ＋ #换行符, “User-Agent:”, #换行符, , ))
        .如果真 (局_User_Agent ＝ “”)
            局_User_Agent ＝ 内部_协议头取值 (局_附加协议头)
        .如果真结束
        
    .默认
        局_User_Agent ＝ “Mozilla/4.0 (compatible; MSIE 9.0; Windows NT 6.1)”
    .判断结束
    
    .判断开始 (代理地址 ＝ “”)
        局_Internet句柄 ＝ InternetOpenA (局_User_Agent, 1, 字符 (0), 字符 (0), 0)
    .默认
        .判断开始 (是否使用socks4代理)
            局_Internet句柄 ＝ InternetOpenA (局_User_Agent, 3, “SOCKS=” ＋ 代理地址, “”, 0)
        .默认
            .判断开始 (局_HTTPS) ' 用于解决win7下https协议代理无效问题
                局_Internet句柄 ＝ InternetOpenA (局_User_Agent, 3, 代理地址, “”, 0)
            .默认
                局_Internet句柄 ＝ InternetOpenA (局_User_Agent, 3, “http=” ＋ 代理地址, “”, 0)
            .判断结束
            
        .判断结束
        
    .判断结束
    
    .如果真 (局_Internet句柄 ＝ 0)
        ' InternetCloseHandle (局_Internet句柄)
        返回 ({ })
    .如果真结束
    局_Internet连接句柄 ＝ InternetConnectA (局_Internet句柄, 网页_取域名 (网址), 网页_取端口 (网址), 字符 (0), 字符 (0), 3, 0, 0)
    .如果真 (局_Internet连接句柄 ＝ 0)
        ' InternetCloseHandle (局_Internet连接句柄)
        InternetCloseHandle (局_Internet句柄)
        返回 ({ })
    .如果真结束
    
    局_请求标记 ＝ 位或 (#INTERNET_FLAG_RELOAD, #INTERNET_COOKIE_THIRD_PARTY)
    .如果真 (取反 (是否为空 (提交Cookies)))
        局_请求标记 ＝ 位或 (局_请求标记, #INTERNET_FLAG_NO_COOKIES)
    .如果真结束
    
    .如果真 (禁止重定向)
        局_请求标记 ＝ 位或 (局_请求标记, #INTERNET_FLAG_NO_AUTO_REDIRECT)
    .如果真结束
    
    .判断开始 (局_HTTPS)
        局_请求标记 ＝ 位或 (局_请求标记, #INTERNET_FLAG_SECURE)
    .默认
        局_请求标记 ＝ 位或 (局_请求标记, #INTERNET_FLAG_IGNORE_REDIRECT_TO_HTTPS)
    .判断结束
    
    局_HTTP请求句柄 ＝ HttpOpenRequestA (局_Internet连接句柄, 局_访问方式, 网页_取页面地址 (网址), “HTTP/1.1”, 字符 (0), 字符 (0), 局_请求标记, 0)
    .如果真 (局_HTTP请求句柄 ＝ 0)
        ' InternetCloseHandle (局_HTTP请求句柄)
        InternetCloseHandle (局_Internet连接句柄)
        InternetCloseHandle (局_Internet句柄)
        返回 ({ })
    .如果真结束
    
    InternetSetOption (局_HTTP请求句柄, #INTERNET_OPTION_SECURITY_FLAGS, 127872, 4)
    
    .如果真 (是否补全必要协议头)
        .如果真 (局_附加协议头 ＝ “”)
            局_附加协议头 ＝ “Accept: */*”
        .如果真结束
        
        .如果真 (寻找文本 (局_附加协议头, “Accept:”, , 真) ＝ -1)
            局_附加协议头 ＝ 局_附加协议头 ＋ #换行符 ＋ “Accept: */*”
        .如果真结束
        
        
        .如果真 (寻找文本 (局_附加协议头, “Referer:”, , 真) ＝ -1)
            局_附加协议头 ＝ 局_附加协议头 ＋ #换行符 ＋ “Referer: ” ＋ 网址
        .如果真结束
        
        .如果真 (寻找文本 (局_附加协议头, “Accept-Language:”, , 真) ＝ -1)
            局_附加协议头 ＝ 局_附加协议头 ＋ #换行符 ＋ “Accept-Language: zh-cn”
        .如果真结束
        
        .如果真 (访问方式 ＝ 1)
            .如果真 (寻找文本 (局_附加协议头, “Content-Type:”, , 真) ＝ -1)
                局_附加协议头 ＝ 局_附加协议头 ＋ #换行符 ＋ “Content-Type: application/x-www-form-urlencoded”
            .如果真结束
            
        .如果真结束
        
    .如果真结束
    
    .如果真 (提交Cookies ≠ “”)
        .判断开始 (寻找文本 (提交Cookies, “Cookie:”, , 假) ＝ -1)
            局_附加协议头 ＝ 局_附加协议头 ＋ #换行符 ＋ “Cookie: ” ＋ 提交Cookies
        .默认
            局_附加协议头 ＝ 局_附加协议头 ＋ #换行符 ＋ 提交Cookies
        .判断结束
        
    .如果真结束
    
    
    ' 在Vista之后  可以自动解压Gzip
    ' bAutoDecode ＝ 1
    ' InternetSetOptionA_传址 (局_HTTP请求句柄, #INTERNET_OPTION_HTTP_DECODING, bAutoDecode, 4)
    
    .判断开始 (访问方式 ＝ 0)
        HttpSendRequestA (局_HTTP请求句柄, 局_附加协议头, 取文本长度 (局_附加协议头), 0, 0)
    .默认
        .如果真 (字节集提交 ＝ { })
            字节集提交 ＝ 到字节集 (提交信息)
        .如果真结束
        buffersIn.dwStructSize ＝ 40 ' sizeof(INTERNET_BUFFERSA)
        buffersIn.lpcszHeader ＝ 取指针_文本型 (局_附加协议头)
        buffersIn.dwHeadersLength ＝ 取文本长度 (局_附加协议头)
        buffersIn.dwBufferTotal ＝ 取字节集长度 (字节集提交)
        .如果真 (HttpSendRequestExA (局_HTTP请求句柄, buffersIn, #NULL, #HSR_INITIATE, 0))
            dwStart ＝ 1
            .判断循环首 (真)
                aryData ＝ 取字节集中间 (字节集提交, dwStart, m_stageSize)
                dwDataSize ＝ 取字节集长度 (aryData)
                .如果真 (dwDataSize ＝ 0)
                    跳出循环 ()
                .如果真结束
                dwStart ＝ dwStart ＋ dwDataSize
                .如果真 (InternetWriteFile (局_HTTP请求句柄, aryData, dwDataSize, dwOutSize))
                    .如果真 (dwDataSize ≠ dwOutSize)
                        输出调试文本 (“指向接收写入文件的字节数与要写入文件的字节数不符”)
                        暂停 ()
                    .如果真结束
                    
                .如果真结束
                
            .判断循环尾 ()
            HttpEndRequestA (局_HTTP请求句柄, #NULL, 0, 0)
        .如果真结束
        
    .判断结束
    
    局_计次 ＝ 0
    局_字节集 ＝ 取空白字节集 (1024)
    .循环判断首 ()
        .如果真 (InternetReadFile (局_HTTP请求句柄, 局_字节集, 1024, 局_计次))
            局_页面内容 ＝ 局_页面内容 ＋ 取字节集左边 (局_字节集, 局_计次)
        .如果真结束
        
    .循环判断尾 (局_计次 ≠ 0)
    返回协议头 ＝ 取空白文本 (5000)
    HttpQueryInfoA (局_HTTP请求句柄, 22, 返回协议头, 5000, 0)
    ' 返回协议头 ＝ 子文本替换 (返回协议头, “Set-Cookie”, “Set-Cookie”, , , 假)
    InternetCloseHandle (局_HTTP请求句柄)
    InternetCloseHandle (局_Internet连接句柄)
    InternetCloseHandle (局_Internet句柄)
    局_返回协议头 ＝ 分割文本 (返回协议头, #换行符, )
    返回Cookies ＝ HeadersToCookie (局_返回协议头)
    .如果真 (是否自动合并更新Cookie)
        .如果真 (取反 (是否为空 (提交Cookies)))
            返回Cookies ＝ 网页_Cookie合并更新 (提交Cookies, 返回Cookies)
        .如果真结束
        
    .如果真结束
    返回 (局_页面内容)

.子程序 网页_访问S, 文本型, 公开, 源码由[洫蜘蛛]提供,使用WinHttp的 API方式访问网页,如果返回是“?”请查询返回协议头是否有“Content-Encoding: gzip“表示gzip压缩过网页，可用 网页_GZIP解压()命令解压，如果返回是乱码，则返回原始文本，请自行转换编码，失败返回空文本，请取出状态文本。
    .参数 网址, 文本型, , 完整的网页地址,必须包含http://或者https://
    .参数 访问方式, 整数型, 可空, 0=GET 1=POST 2=HEAD  3=PUT  4=OPTIONS  5=DELETE  6=TRACE  7=CONNECT  8=PATCH
    .参数 提交信息, 文本型, 可空, POST专用
    .参数 提交Cookies, 文本型, 参考 可空, 设置提交时的cookie
    .参数 返回Cookies, 文本型, 参考 可空, 返回的Cookie
    .参数 附加协议头, 文本型, 可空, 一行一个请用换行符隔开,建议填写常量值或文本值,防止因传参引发错误
    .参数 返回协议头, 文本型, 参考 可空, 返回的协议头
    .参数 禁止重定向, 逻辑型, 可空, 默认不禁止网页重定向
    .参数 网站登录用户名, 文本型, 可空, 自动登录网页用户名 如路由器
    .参数 网站登录密码, 文本型, 可空
    .参数 代理地址, 文本型, 可空, 代理地址，格式为 8.8.8.8:88
    .参数 代理帐号, 文本型, 可空
    .参数 代理密码, 文本型, 可空
    .参数 超时时间, 整数型, 可空, 可以被省略，单位：秒，默认30秒，如果提供大于0的数值，则修改操作超时时间。
    .参数 返回重定向, 文本型, 参考 可空, 可以被省略，提供参数时只能提供文本型变量，用于当发生重定向时取回页面重定向的地址。
    .参数 返回状态文本, 文本型, 参考 可空
    .参数 返回原始数据, 字节集, 参考 可空, 可以被省略，返回原始网页编码
    .参数 是否自动合并更新Cookie, 逻辑型, 可空, 默认为真，自动合并更新
    .参数 是否补全必要协议头, 逻辑型, 可空, 当附件协议头为空时自动添加必要的UA协议头 默认为真，假将不再添加非传入协议头
    .参数 字节集提交, 字节集, 可空, 提交字节集数据
    .参数 是否处理协议头大小写, 逻辑型, 可空, 将协议头中的键名首字母处理为大写  默认为真
    .局部变量 局_URL结构, URL_COMPONENTS
    .局部变量 局_网页地址, 字节集
    .局部变量 局_域名, 文本型
    .局部变量 局_端口, 整数型
    .局部变量 局_重定向地址, 文本型
    .局部变量 局_HTTPS, 逻辑型
    .局部变量 局_会话句柄, 整数型
    .局部变量 局_User_Agent, 文本型
    .局部变量 局_代理名称, 字节集
    .局部变量 局_会话类型, 整数型
    .局部变量 局_连接句柄, 整数型
    .局部变量 局_请求句柄, 整数型
    .局部变量 局_访问方式, 文本型
    .局部变量 局_页面地址, 字节集
    .局部变量 局_设置超时, 整数型
    .局部变量 局_请求标记, 整数型
    .局部变量 局_请求协议, 文本型
    .局部变量 局_请求报头, 字节集
    .局部变量 局_数据长度, 整数型
    .局部变量 局_提交数据, 字节集
    .局部变量 局_可读长度, 整数型
    .局部变量 局_缓存数据, 字节集
    .局部变量 局_网页数据, 字节集
    .局部变量 局_网页内容, 文本型
    .局部变量 局_文本数组, 文本型, , "0"
    .局部变量 局_编码类型, 文本型
    .局部变量 局_解码对象, 对象
    .局部变量 局_变体型, 变体型
    .局部变量 局_计次, 整数型
    .局部变量 局_正则, 正则表达式类
    .局部变量 aryHotFixID, 文本型, , "0"
    .局部变量 len, 整数型
    .局部变量 dwStart, 整数型
    .局部变量 aryData, 字节集
    .局部变量 dwDataSize, 整数型
    .局部变量 dwOutSize, 整数型

    .如果真 (_WIN32_WINNT ＜ #_WIN32_WINNT_WIN8 且 IsDebuggerPresent ())
        len ＝ 系统_遍历修复补丁ID (aryHotFixID, “KB3140245”)
        .如果真 (len ＝ 0)
            输出调试文本 (“缺少修复补丁(KB3140245) 可能导致该功能无效”)
            输出调试文本 (“https://bbs.125.la/thread-14086625-1-1.html”)
        .如果真结束
        
    .如果真结束
    
    .如果真 (是否为空 (是否自动合并更新Cookie))
        是否自动合并更新Cookie ＝ 真
    .如果真结束
    
    .如果真 (是否为空 (是否补全必要协议头))
        是否补全必要协议头 ＝ 真
    .如果真结束
    
    .如果真 (是否为空 (是否处理协议头大小写))
        是否处理协议头大小写 ＝ 真
    .如果真结束
    
    .如果 (WinHttpCheckPlatform ())
        局_URL结构.dwStructSize ＝ 60
        连续赋值 (-1, 局_URL结构.dwSchemeLength, 局_URL结构.dwHostNameLength, 局_URL结构.dwUrlPathLength, 局_URL结构.dwExtraInfoLength)
        局_网页地址 ＝ 编码_Ansi到Unicode (网址)
        .如果 (WinHttpCrackUrl (局_网页地址, 取字节集长度 (局_网页地址), 0, 局_URL结构))
            局_域名 ＝ 编码_Unicode到Ansi (指针到字节集 (局_URL结构.lpszHostName, 局_URL结构.dwHostNameLength × 2))
            局_页面地址 ＝ 选择 (局_URL结构.dwUrlPathLength ＜ 1, 编码_Ansi到Unicode (“/”), 指针到字节集 (局_URL结构.lpszUrlPath, 局_URL结构.dwUrlPathLength × 2) ＋ 指针到字节集 (局_URL结构.lpszExtraInfo, 局_URL结构.dwExtraInfoLength × 2) ＋ { 0, 0 })
            局_端口 ＝ 局_URL结构.nPort
            局_HTTPS ＝ #INTERNET_SCHEME_HTTPS ＝ 局_URL结构.nScheme
            局_会话类型 ＝ 选择 (取文本长度 (代理地址) ＞ 0, #WINHTTP_ACCESS_TYPE_NAMED_PROXY, #WINHTTP_ACCESS_TYPE_NO_PROXY)
            局_代理名称 ＝ 选择 (取文本长度 (代理地址) ＝ 0, { 0, 0 }, 选择 (局_HTTPS, 编码_Ansi到Unicode (代理地址), 编码_Ansi到Unicode (“http=” ＋ 代理地址)))
            局_会话句柄 ＝ WinHttpOpen (0, 局_会话类型, 局_代理名称, 0, 0)
            .如果 (局_会话句柄 ≠ 0)
                局_设置超时 ＝ 选择 (超时时间 ＞ 0, 超时时间 × 1000, 30000)
                .如果 (WinHttpSetTimeouts (局_会话句柄, 局_设置超时, 局_设置超时, 局_设置超时, 局_设置超时))
                    局_连接句柄 ＝ WinHttpConnect (局_会话句柄, 编码_Ansi到Unicode (局_域名, ), 局_端口, 0)
                    .如果 (局_连接句柄 ≠ 0)
                        局_访问方式 ＝ 选择 (访问方式 ＜ 0 或 访问方式 ＞ 8, “GET”, 多项选择 (访问方式 ＋ 1, “GET”, “POST”, “HEAD”, “PUT”, “OPTIONS”, “DELETE”, “TRACE”, “CONNECT”, “PATCH”))
                        局_请求句柄 ＝ WinHttpOpenRequest (局_连接句柄, 编码_Ansi到Unicode (局_访问方式, ), 局_页面地址, 0, #WINHTTP_NO_REFERER, #WINHTTP_DEFAULT_ACCEPT_TYPES, 选择 (局_HTTPS, #WINHTTP_FLAG_SECURE, 0))
                        .如果 (局_请求句柄 ≠ 0)
                            .如果真 (取文本长度 (网站登录用户名) ＞ 0 且 取文本长度 (网站登录密码) ＞ 0)
                                .如果真 (WinHttpSetCredentials (局_请求句柄, #WINHTTP_AUTH_TARGET_SERVER, #WINHTTP_AUTH_SCHEME_BASIC, 编码_Ansi到Unicode (网站登录用户名, ), 编码_Ansi到Unicode (网站登录密码, ), 0) ＝ 假)
                                    返回状态文本 ＝ “707 设置代理凭证失败!”
                                    WinHttpCloseHandle (局_请求句柄)
                                    WinHttpCloseHandle (局_连接句柄)
                                    WinHttpCloseHandle (局_会话句柄)
                                    返回 (“”)
                                .如果真结束
                                
                            .如果真结束
                            .如果真 (取文本长度 (代理帐号) ＞ 0 且 取文本长度 (代理密码) ＞ 0)
                                .如果真 (WinHttpSetCredentials (局_请求句柄, #WINHTTP_AUTH_TARGET_PROXY, #WINHTTP_AUTH_SCHEME_BASIC, 编码_Ansi到Unicode (代理帐号, ), 编码_Ansi到Unicode (代理密码, ), 0) ＝ 假)
                                    WinHttpCloseHandle (局_请求句柄)
                                    WinHttpCloseHandle (局_连接句柄)
                                    WinHttpCloseHandle (局_会话句柄)
                                    返回状态文本 ＝ “707 设置代理凭证失败!”
                                    返回 (“”)
                                .如果真结束
                                
                            .如果真结束
                            
                            
                            .如果真 (WinHttpSetOption (局_请求句柄, #WINHTTP_OPTION_SECURITY_FLAGS, 13056, 4) ＝ 假)
                                返回状态文本 ＝ “忽略错误/证书错误  失败！”
                                WinHttpCloseHandle (局_请求句柄)
                                WinHttpCloseHandle (局_连接句柄)
                                WinHttpCloseHandle (局_会话句柄)
                                返回 (“”)
                                
                            .如果真结束
                            
                            .判断开始 (提交Cookies ＝ “”)
                                局_请求标记 ＝ #WINHTTP_OPTION_DISABLE_FEATURE
                            .默认
                                局_请求标记 ＝ #WINHTTP_OPTION_ENABLE_FEATURE
                            .判断结束
                            
                            .如果真 (WinHttpSetOption (局_请求句柄, 局_请求标记, #WINHTTP_DISABLE_COOKIES, 4) ＝ 假)
                                返回状态文本 ＝ “708 禁止自动设置Cookies失败!”
                                WinHttpCloseHandle (局_请求句柄)
                                WinHttpCloseHandle (局_连接句柄)
                                WinHttpCloseHandle (局_会话句柄)
                                返回 (“”)
                            .如果真结束
                            .如果真 (禁止重定向)
                                .如果真 (WinHttpSetOption (局_请求句柄, #WINHTTP_OPTION_DISABLE_FEATURE, #WINHTTP_DISABLE_REDIRECTS, 4) ＝ 假)
                                    返回状态文本 ＝ “709 重定向设置失败!”
                                    WinHttpCloseHandle (局_请求句柄)
                                    WinHttpCloseHandle (局_连接句柄)
                                    WinHttpCloseHandle (局_会话句柄)
                                    返回 (“”)
                                .如果真结束
                                
                            .如果真结束
                            
                            .如果真 (取文本长度 (附加协议头) ＞ 0) ' 先加载用户设置的协议头，后面再进行补充。
                                局_请求协议 ＝ 附加协议头 ＋ #换行符
                            .如果真结束
                            
                            
                            .如果真 (是否补全必要协议头)
                                .如果真 (寻找文本 (局_请求协议, “User-Agent: ”, 1, 真) ＝ -1)
                                    局_请求协议 ＝ 局_请求协议 ＋ “User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0)” ＋ #换行符
                                .如果真结束
                                .如果真 (寻找文本 (局_请求协议, “Accept: ”, 1, 真) ＝ -1)
                                    局_请求协议 ＝ 局_请求协议 ＋ “Accept: text/html, application/xhtml+xml, */*” ＋ #换行符
                                .如果真结束
                                .如果真 (寻找文本 (局_请求协议, “Accept-Encoding: ”, 1, 真) ＝ -1)
                                    局_请求协议 ＝ 局_请求协议 ＋ “Accept-Encoding: identity” ＋ #换行符
                                .如果真结束
                                .如果真 (寻找文本 (局_请求协议, “Accept-Language: ”, 1, 真) ＝ -1)
                                    局_请求协议 ＝ 局_请求协议 ＋ “Accept-Language: zh-cn” ＋ #换行符
                                .如果真结束
                                
                                .如果真 (访问方式 ＝ 1)
                                    .如果真 (寻找文本 (局_请求协议, “Content-Type:”, , 真) ＝ -1)
                                        局_请求协议 ＝ 局_请求协议 ＋ “Content-Type: application/x-www-form-urlencoded” ＋ #换行符
                                    .如果真结束
                                    
                                .如果真结束
                                .如果真 (寻找文本 (局_请求协议, “Cache-Control: ”, , 真) ＝ -1)
                                    局_请求协议 ＝ 局_请求协议 ＋ “Cache-Control: no-cache” ＋ #换行符
                                .如果真结束
                                
                            .如果真结束
                            
                            .如果真 (是否处理协议头大小写)
                                局_请求协议 ＝ 网页_处理协议头 (局_请求协议)
                            .如果真结束
                            
                            
                            .如果真 (寻找文本 (局_请求协议, “Connection”, , 假) ≠ -1)
                                .如果真 (网页_协议头_取信息 (局_请求协议, “Connection”) ＝ “keep-alive”)
                                    局_请求协议 ＝ 子文本替换 (局_请求协议, “Connection: keep-alive” ＋ #换行符, “”, , , 真) ' 筛选排除此参数 避免协议头有此参数 HTTP对象又自动添加此参数
                                .如果真结束
                                
                            .如果真结束
                            
                            .如果真 (寻找文本 (局_请求协议, “Cookie:”, , 真) ＝ -1)
                                .如果真 (取文本长度 (提交Cookies) ＞ 0)
                                    .判断开始 (寻找文本 (提交Cookies, “Cookie:”, , 真) ＝ -1)
                                        局_请求协议 ＝ 局_请求协议 ＋ #换行符 ＋ “Cookie: ” ＋ 提交Cookies ＋ #换行符
                                    .默认
                                        局_请求协议 ＝ 局_请求协议 ＋ #换行符 ＋ 提交Cookies ＋ #换行符
                                    .判断结束
                                    
                                .如果真结束
                                
                            .如果真结束
                            
                            局_请求报头 ＝ 编码_Ansi到Unicode (局_请求协议, )
                            局_数据长度 ＝ 取字节集长度 (局_请求报头) ÷ 2 － 1
                            .如果 (WinHttpAddRequestHeaders (局_请求句柄, 局_请求报头, 局_数据长度, #WINHTTP_ADDREQ_FLAG_ADD))
                                .如果 (字节集提交 ＝ { })
                                    局_提交数据 ＝ 到字节集 (提交信息)
                                .否则
                                    局_提交数据 ＝ 字节集提交
                                .如果结束
                                
                                局_数据长度 ＝ 取字节集长度 (局_提交数据)
                                .如果 (WinHttpSendRequest (局_请求句柄, 0, 0, { }, 0, 局_数据长度, 0))
                                    dwStart ＝ 1
                                    .判断循环首 (真)
                                        aryData ＝ 取字节集中间 (局_提交数据, dwStart, m_stageSize)
                                        dwDataSize ＝ 取字节集长度 (aryData)
                                        .如果真 (dwDataSize ＝ 0)
                                            跳出循环 ()
                                        .如果真结束
                                        dwStart ＝ dwStart ＋ dwDataSize
                                        .如果真 (WinHttpWriteData (局_请求句柄, aryData, dwDataSize, dwOutSize))
                                            .如果真 (dwDataSize ≠ dwOutSize)
                                                输出调试文本 (“指向接收写入文件的字节数与要写入文件的字节数不符”)
                                                暂停 ()
                                            .如果真结束
                                            
                                        .如果真结束
                                        
                                    .判断循环尾 ()
                                    .如果 (WinHttpReceiveResponse (局_请求句柄, 0))
                                        局_缓存数据 ＝ { }
                                        局_网页数据 ＝ { }
                                        .判断循环首 (WinHttpQueryDataAvailable (局_请求句柄, 局_可读长度))
                                            .如果真 (局_可读长度 ＜ 1)
                                                跳出循环 ()
                                            .如果真结束
                                            局_缓存数据 ＝ 取空白字节集 (局_可读长度)
                                            .如果真 (WinHttpReadData (局_请求句柄, 局_缓存数据, 局_可读长度, 局_数据长度) ＝ 假)
                                                返回状态文本 ＝ “713 读取数据失败!”
                                                跳出循环 ()
                                            .如果真结束
                                            局_网页数据 ＝ 局_网页数据 ＋ 取字节集左边 (局_缓存数据, 局_数据长度)
                                        .判断循环尾 ()
                                        局_缓存数据 ＝ { }
                                        局_数据长度 ＝ 0
                                        WinHttpQueryHeaders (局_请求句柄, #WINHTTP_QUERY_RAW_HEADERS_CRLF, 0, 局_缓存数据, 局_数据长度, #WINHTTP_NO_HEADER_INDEX)
                                        局_缓存数据 ＝ 取空白字节集 (局_数据长度)
                                        .如果真 (WinHttpQueryHeaders (局_请求句柄, #WINHTTP_QUERY_RAW_HEADERS_CRLF, 0, 局_缓存数据, 局_数据长度, #WINHTTP_NO_HEADER_INDEX))
                                            返回协议头 ＝ 编码_Unicode到Ansi (局_缓存数据)
                                            返回状态文本 ＝ 取文本中间 (返回协议头, 10, 寻找文本 (返回协议头, #换行符, 10, 假) － 10)
                                            
                                            局_文本数组 ＝ 分割文本 (返回协议头, #换行符, )
                                            返回Cookies ＝ HeadersToCookie (局_文本数组)
                                            .计次循环首 (取数组成员数 (局_文本数组), 局_计次)
                                                .如果真 (文本比较 (取文本左边 (局_文本数组 [局_计次], 10), “Location: ”, 假) ＝ 0)
                                                    返回重定向 ＝ 取文本中间 (局_文本数组 [局_计次], 11, 取文本长度 (局_文本数组 [局_计次]) － 10)
                                                .如果真结束
                                                
                                            .计次循环尾 ()
                                            
                                            .如果真 (是否自动合并更新Cookie)
                                                .如果真 (取反 (提交Cookies ＝ “”))
                                                    返回Cookies ＝ 网页_Cookie合并更新 (提交Cookies, 返回Cookies)
                                                .如果真结束
                                                
                                            .如果真结束
                                            ' -------------------提取网页编码，并转码
                                            返回原始数据 ＝ 局_网页数据
                                            局_网页内容 ＝ 到文本 (返回原始数据)
                                            CoInitialize (0)
                                            .如果真 (局_正则.创建 (“<meta.+?charset=[^\w]?([-\w]+)”, 取文本左边 (局_网页内容, 1024), , , , ))
                                                局_编码类型 ＝ 局_正则.取子匹配文本 (1, 1, )
                                                .如果真 (取文本长度 (局_编码类型) ＞ 0)
                                                    .如果真 (局_编码类型 ≠ “gbk” 或 局_编码类型 ≠ “gb2312”) ' 如果为中文就不处理
                                                        .如果真 (局_解码对象.创建 (“Adodb.Stream”, ))
                                                            局_变体型.赋值 (局_网页数据, )
                                                            局_解码对象.写属性 (“Type”, 1)
                                                            局_解码对象.写属性 (“Mode”, 3)
                                                            局_解码对象.方法 (“Open”, )
                                                            局_解码对象.方法 (“Write”, 局_变体型)
                                                            局_解码对象.写属性 (“Position”, 0)
                                                            局_解码对象.写属性 (“Type”, 2)
                                                            局_解码对象.写属性 (“Charset”, 局_编码类型)
                                                            局_网页内容 ＝ 局_解码对象.文本方法 (“ReadText”, )
                                                            局_解码对象.方法 (“Close”, )
                                                            局_解码对象.清除 ()
                                                            局_变体型.清除 ()
                                                        .如果真结束
                                                        
                                                    .如果真结束
                                                    
                                                .如果真结束
                                                处理事件 ()
                                            .如果真结束
                                            CoUninitialize ()
                                        .如果真结束
                                        处理事件 ()
                                    .否则
                                        返回状态文本 ＝ “712 服务器未响应!”
                                    .如果结束
                                    处理事件 ()
                                .否则
                                    返回状态文本 ＝ “711 发送请求失败!”
                                .如果结束
                                处理事件 ()
                            .否则
                                返回状态文本 ＝ “710 设置协议头失败!”
                            .如果结束
                            处理事件 ()
                        .否则
                            返回状态文本 ＝ “704 创建WinHttp请求失败!”
                        .如果结束
                        处理事件 ()
                    .否则
                        返回状态文本 ＝ “703 创建WinHttp连接失败!”
                    .如果结束
                    处理事件 ()
                    
                .否则
                    返回状态文本 ＝ “705 设置超时时间失败!”
                .如果结束
                处理事件 ()
                
            .否则
                返回状态文本 ＝ “702 创建WinHttp会话失败!”
            .如果结束
            处理事件 ()
        .否则
            返回状态文本 ＝ “701 解析URL地址失败!”
        .如果结束
        处理事件 ()
    .否则
        返回状态文本 ＝ “700 当前系统不支持WinHttp服务!”
    .如果结束
    WinHttpCloseHandle (局_请求句柄)
    WinHttpCloseHandle (局_连接句柄)
    WinHttpCloseHandle (局_会话句柄)
    返回 (局_网页内容)

.子程序 网页_URL取本地地址, 文本型, 公开, 通过文件的URL地址，获取缓存在本地的文件地址，成功返回本地文件地址，失败或不存在返回空文本。目前知道不支持搜狗浏览器。
    .参数 文件地址, 文本型, , 如：http://bbs.125.la/static/image/common/logo.png
    .局部变量 缓存信息, INTERNET_CACHE_ENTRY_INFO
    .局部变量 dwbuffer, 整数型
    .局部变量 memaddr, 整数型

    GetUrlCacheEntryInfo (文件地址, 0, dwbuffer) ' 获取dwbuffer大小
    .判断开始 (_GetLastError () ＝ 2) ' 指定的缓存条目在缓存中没有找到。
        输出调试文本 (“指定的缓存条目在缓存中没有找到。”)
        返回 (“”)
        
    .判断 (_GetLastError () ＝ 122) ' 有缓存文件
        memaddr ＝ LocalAlloc (0, dwbuffer) ' 申请内存
        GetUrlCacheEntryInfo (文件地址, memaddr, dwbuffer)
        RtlMoveMemory_GetUrlCache (缓存信息, memaddr, 80)
        LocalFree (memaddr) ' 释放内存
        返回 (缓存信息.lpszLocalFileName)
    .默认
        
    .判断结束
    返回 (“”)

.子程序 网页_GZIP压缩_文本, 文本型, 公开, 返回 Base64编码 感谢【@surplus 】提供源码
    .参数 Text, 文本型
    .参数 是否线程, 逻辑型, 可空
    .局部变量 对象, 对象
    .局部变量 eval, 变体型
    .局部变量 ret, 文本型

    .如果真 (是否线程)
        线程_初始化COM库 ()
    .如果真结束
    Text ＝ 编码_URL编码 (Text, 真, 真)
    对象.创建 (“ScriptControl”, )
    对象.写属性 (“Language”, “JScript”)
    对象.逻辑方法 (“AddCode”, #Gzip)
    eval ＝ 对象.通用方法 (“Eval”, “Gzip_Encrypt('” ＋ Text ＋ “')”) ' 这里要填写单引号， 也就是 Gzip_Encrypt('1233')  否则遇到 易语言的引号 会冲突 导致 压缩失败
    ret ＝ eval.取文本 ()
    对象.清除 ()
    .如果真 (是否线程)
        线程_取消COM库 ()
    .如果真结束
    返回 (到文本 (编码_BASE64编码A (字节集_文本转字节集 (“{” ＋ ret ＋ “}”))))

.子程序 网页_GZIP解压_文本, 文本型, 公开, 传递 Base64编码 感谢【@surplus 】提供源码
    .参数 Text, 文本型
    .参数 是否线程, 逻辑型, 可空
    .局部变量 对象, 对象
    .局部变量 eval, 变体型
    .局部变量 ret, 文本型
    .局部变量 局_转码内容, 字节集

    .如果真 (是否线程)
        线程_初始化COM库 ()
    .如果真结束
    Text ＝ 字节集_字节集转文本ex (编码_BASE64解码A (到字节集 (Text)))
    Text ＝ 取文本左边 (取文本右边 (Text, 取文本长度 (Text) － 1), 取文本长度 (Text) － 2)
    对象.创建 (“ScriptControl”, )
    对象.写属性 (“Language”, “JScript”)
    对象.逻辑方法 (“AddCode”, #Gzip)
    eval ＝ 对象.通用方法 (“Eval”, “Gzip_Decrypt('” ＋ Text ＋ “')”) ' 这里要填写单引号， 也就是 Gzip_Decrypt('1233')  否则遇到 易语言的引号 会冲突 导致 压缩失败
    ret ＝ eval.取文本 ()
    对象.清除 ()
    .如果真 (是否线程)
        线程_取消COM库 ()
    .如果真结束
    局_转码内容 ＝ 字节集_文本转字节集ex (“{” ＋ ret ＋ “}”)
    返回 (编码_URL解码_快速 (编码_Utf8到Ansi (局_转码内容), ))

.子程序 网页_GZIP压缩, 字节集, 公开, 感谢小磊提供，gzip.dll文件请自行到这里来下载并放到程序根目录下即可。http://pan.baidu.com/share/link?shareid=222122&uk=2013335237
    .参数 inData, 字节集
    .局部变量 context, 整数型
    .局部变量 inData2, 字节集
    .局部变量 inLength, 整数型
    .局部变量 buffer, 字节集
    .局部变量 inUsed, 整数型
    .局部变量 outUsed, 整数型
    .局部变量 hResult, 整数型
    .局部变量 retBytes, 字节集
    .局部变量 upRetByts, 字节集
    .局部变量 压缩位置, 整数型

    buffer ＝ 取空白字节集 (8192) ' #MAX_BUF
    InitCompression ()
    CreateCompression (context, 3) ' #GZIP_LVL
    .循环判断首 ()
        inData2 ＝ 取字节集中间 (inData, 压缩位置 ＋ 1, 8192) ' #MAX_BUF
        inLength ＝ 取字节集长度 (inData2)
        hResult ＝ Compress (context, inData2, inLength, buffer, 8192, inUsed, outUsed, 3)
        .如果真 (0 ≠ outUsed)
            upRetByts ＝ upRetByts ＋ 取字节集左边 (buffer, outUsed)
            压缩位置 ＝ 压缩位置 ＋ inUsed
        .如果真结束
        
    .循环判断尾 (hResult ＝ 0)
    DestroyCompression (context)
    返回 (upRetByts)

.子程序 网页_GZIP解压, 字节集, 公开, 感谢小磊提供，gzip.dll文件请自行到这里来下载并放到程序根目录下即可。http://pan.baidu.com/share/link?shareid=222122&uk=2013335237
    .参数 inData, 字节集
    .局部变量 context, 整数型
    .局部变量 inData2, 字节集
    .局部变量 inLength, 整数型
    .局部变量 buffer, 字节集
    .局部变量 inUsed, 整数型
    .局部变量 outUsed, 整数型
    .局部变量 hResult, 整数型
    .局部变量 retBytes, 字节集
    .局部变量 upRetByts, 字节集
    .局部变量 解压位置, 整数型

    buffer ＝ 取空白字节集 (8192)
    InitDecompression ()
    CreateDecompression (context, 3)
    .循环判断首 ()
        inData2 ＝ 取字节集中间 (inData, 解压位置 ＋ 1, 8192)
        inLength ＝ 取字节集长度 (inData2)
        hResult ＝ Decompress (context, inData2, inLength, buffer, 8192, inUsed, outUsed)
        .如果真 (0 ≠ outUsed)
            upRetByts ＝ upRetByts ＋ 取字节集左边 (buffer, outUsed)
            解压位置 ＝ 解压位置 ＋ inUsed
        .如果真结束
        
    .循环判断尾 (hResult ＝ 0)
    DestroyDecompression (context)
    返回 (upRetByts)

.子程序 网页_JS格式化, 文本型, 公开, 感谢小磊提供，格式化未处理的JS文本
    .参数 js代码, 文本型, , 需要加密\解密的源码
    .参数 压缩模式, 逻辑型, 可空, 假为格式化代码,真为压缩代码
    .局部变量 js, 类_脚本组件
    .局部变量 str, 文本型

    js.执行 (#JS格式化)
    .判断开始 (压缩模式)
        返回 (js.运行 (“ysjs”, js代码))
    .默认
        返回 (js.运行 (“js_beautify”, js代码))
    .判断结束
    

.子程序 网页_置浏览器代理, , 公开, 设置当前程序中浏览器的代理,不影响外部浏览器使用
    .参数 代理IP, 文本型, 可空, 格式ip地址+端口，例如【192.168.1.10:80】,留空为取消代理
    .局部变量 op, INTERNET_PROXY_INFO

    .如果 (是否为空 (代理IP) ＝ 假)
        op.dwAccessType ＝ #INTERNET_OPEN_TYPE_PROXY
        op.lpszProxy ＝ “ftp= ” ＋ 代理IP ＋ “;http= ” ＋ 代理IP ＋ “;socks= ” ＋ 代理IP
        op.lpszProxyBypass ＝ “”
        InternetSetOptionA2 (0, #INTERNET_OPTION_PROXY, op, 12)
        InternetSetOptionA_传址 (0, #INTERNET_OPTION_SETTINGS_CHANGED, 0, 0)
    .否则
        
        op.dwAccessType ＝ #INTERNET_OPEN_TYPE_DIRECT
        op.lpszProxy ＝ “”
        op.lpszProxyBypass ＝ “”
        InternetSetOptionA2 (0, #INTERNET_OPTION_PROXY, op, 12)
        InternetSetOptionA_传址 (0, #INTERNET_OPTION_SETTINGS_CHANGED, 0, 0)
    .如果结束
    

.子程序 网页_置浏览器UA, 逻辑型, 公开, 设置当前程序中浏览器的UserAgent,不影响外部浏览器使用
    .参数 UserAgent, 文本型

    返回 (UrlMkSetSessionOption (#URLMON_OPTION_USERAGENT, UserAgent, 取文本长度 (UserAgent), 0) ＝ 0)

.子程序 网页_取网页源码, 文本型, 公开, 获取指定网址的网页源码文本
    .参数 网址, 文本型, , 请提供要取源码的网址

    返回 (到文本 (网页_访问 (网址)))

.子程序 网页_取文本_reg, 文本型, 公开, 去掉网页源码中的HTML标签，保留纯文本(正则方式)
    .参数 网页源码, 文本型, , 网页源码如果含中文且乱码的,请先解码
    .局部变量 正则, 正则表达式类
    .局部变量 局_源码, 文本型

    局_源码 ＝ 网页源码
    正则.创建 (“<!--[\s\S]*?-->|<script[\s\S]*?</script>|<style[\s\S]*?</style>|<[^>]+>|&.{1,8};”, 局_源码, , , , )
    局_源码 ＝ 正则.替换 ()
    返回 (局_源码)

.子程序 网页_取文本_dom, 文本型, 公开, 去掉网页源码中的HTML标签，保留纯文本(DOM方式)
    .参数 网页源码, 文本型, , 网页源码如果含中文且乱码的,请先解码
    .局部变量 dom, 对象
    .局部变量 局_源码, 文本型

    局_源码 ＝ 网页源码
    CoInitialize (0)
    dom.创建 (“{25336920-03F9-11CF-8FD0-00AA00686F13}”, )
    dom.方法 (“write”, “<HTML><BODY><div></div></BODY></HTML>”)
    dom.对象型方法 (“body”, ).写属性 (“innerHTML”, 局_源码)
    dom.方法 (“close”, )
    局_源码 ＝ dom.对象型方法 (“body”, ).读文本属性 (“outerText”, )
    CoUninitialize ()
    返回 (局_源码)

.子程序 网页_取端口, 整数型, 公开, 取出网站服务器的默认端口
    .参数 网址, 文本型
    .局部变量 端口, 文本型
    .局部变量 位置, 整数型

    端口 ＝ 网页_取域名 (网址, , 真)
    位置 ＝ 倒找文本 (端口, “:”, , 假)
    .判断开始 (位置 ≠ -1)
        返回 (到整数 (取文本右边 (端口, 取文本长度 (端口) － 位置)))
    .判断 (取文本左边 (到小写 (网址), 5) ＝ “https”)
        返回 (443)
    .默认
        返回 (80)
    .判断结束
    

.子程序 网页_取域名, 文本型, 公开, 通过“/”或者“.”来获取网址中的域名，默认使用“/”方式
    .参数 网址, 文本型
    .参数 去除二级域名, 逻辑型, 可空
    .参数 不过滤端口, 逻辑型, 可空
    .参数 后缀点数量, 整数型, 可空, 不留空表示通过“.”的方式取域名 。如：.com后缀点数量为1 ,.com.cn后缀点数量为2
    .局部变量 域名, 文本型
    .局部变量 位置, 整数型
    .局部变量 二级, 文本型, , "0"
    .局部变量 域名长度, 整数型
    .局部变量 前点开始, 整数型, , , 如www.bbs.125.la   www后面.的位置
    .局部变量 前点结束, 整数型, , , 如www.bbs.125.la   bbs后面.的位置
    .局部变量 后点开始, 整数型, , , 如www.bbs.125.la   125后面.的位置

    域名 ＝ 到小写 (网址)
    .判断开始 (是否为空 (后缀点数量)) ' 使用“/”方式获取域名，网页_访问() 内部 必须使用这个
        .如果真 (取文本右边 (域名, 1) ≠ “/”)
            域名 ＝ 域名 ＋ “/”
        .如果真结束
        
        .判断开始 (取文本左边 (域名, 8) ＝ “https://”)
            域名 ＝ 文本_取出中间文本 (域名, “https://”, “/”)
        .默认
            .如果真 (寻找文本 (域名, “http://”, , 假) ＝ -1)
                域名 ＝ “http://” ＋ 域名
            .如果真结束
            域名 ＝ 文本_取出中间文本 (域名, “http://”, “/”)
        .判断结束
        
        .如果真 (去除二级域名)
            二级 ＝ 分割文本 (域名, “.”, )
            位置 ＝ 取数组成员数 (二级)
            .如果真 (位置 ＞ 1)
                域名 ＝ 二级 [位置 － 1] ＋ “.” ＋ 二级 [位置]
            .如果真结束
            
        .如果真结束
        
    .默认
        ' 通过“.”的方式取域名，支持任何后缀域名
        域名 ＝ 子文本替换 (域名, “http://”, “”, , , 真)
        域名 ＝ 子文本替换 (域名, “https://”, “”, , , 真)
        位置 ＝ 寻找文本 (域名, “/”, , 假) ' 一撇位置
        .如果真 (位置 ≠ -1)
            域名 ＝ 取文本左边 (域名, 位置 － 1)
        .如果真结束
        连续赋值 (取文本长度 (域名), 域名长度, 后点开始)
        .计次循环首 (后缀点数量, )
            后点开始 ＝ 倒找文本 (域名, “.”, 后点开始, 假)
        .计次循环尾 ()
        前点结束 ＝ 倒找文本 (域名, “.”, 后点开始, 假)
        .判断开始 (去除二级域名)
            域名 ＝ 取文本右边 (域名, 域名长度 － 前点结束)
        .默认
            ' 保留二级域名---------------------------------------
            .如果真 (前点结束 ≠ -1) ' 至少是二级域名
                前点开始 ＝ 倒找文本 (域名, “.”, 前点结束, 假)
                .如果真 (前点开始 ≠ -1) ' 至少是三级域名
                    域名 ＝ 取文本右边 (域名, 域名长度 － 前点开始)
                .如果真结束
                
            .如果真结束
            
        .判断结束
        
    .判断结束
    ' 端口过滤处理--------------------------------------------------------
    .判断开始 (不过滤端口)
        返回 (域名)
    .默认
        位置 ＝ 寻找文本 (域名, “:”, , 假) ' 冒号位置
        .判断开始 (位置 ≠ -1)
            返回 (取文本左边 (域名, 位置 － 1))
        .默认
            返回 (域名)
        .判断结束
        
    .判断结束
    

.子程序 网页_取外网IP, 文本型, 公开, 取本机的外网IP！注意，本命令调用的是第三方接口，接口随时可能失效。
    .参数 所在省市, 文本型, 可空, 可空。请提供一个文本变量，用于存放您所在的省市，注：有些接口无法取出城市
    .参数 接口, 整数型, 可空, 可空。0、ip138；1、ip-api.com；2、cdid.c-ctrip.com；3、ip.cn；4、whois.pconline.com.cn；5、uc；6、ip.sb；7、ipinfo
    .局部变量 局_结果, 字节集
    .局部变量 局_网址, 文本型
    .局部变量 局_返回, 文本型
    .局部变量 局_IP, 文本型

    .判断开始 (接口 ＝ 1)
        局_网址 ＝ “http://ip-api.com/json/?lang=zh-CN”
        局_返回 ＝ 编码_Utf8到Ansi (网页_访问_对象 (局_网址, , , , , , , , , , , , , , , , , , ))
        局_IP ＝ 文本_取出中间文本 (局_返回, #引号 ＋ “query” ＋ #引号 ＋ “:” ＋ #引号, #引号, , )
        所在省市 ＝ 文本_取出中间文本 (局_返回, #引号 ＋ “regionName” ＋ #引号 ＋ “:” ＋ #引号, #引号, , )
    .判断 (接口 ＝ 2)
        局_网址 ＝ “https://cdid.c-ctrip.com/model-poc2/h”
        局_IP ＝ 编码_Utf8到Ansi (网页_访问_对象 (局_网址, , , , , , , , , , , , , , , , , , ))
        所在省市 ＝ “” ' 返回无省市
    .判断 (接口 ＝ 3)
        局_网址 ＝ “https://ip.cn/api/index?ip=&type=0”
        局_返回 ＝ 编码_Utf8到Ansi (网页_访问_对象 (局_网址, , , , , “User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/47.0.2526.80 Safari/537.36 Core/1.47.277.400 QQBrowser/9.4.7658.400”, , , , , , , , , , , , , ))
        局_IP ＝ 文本_取出中间文本 (局_返回, #引号 ＋ “ip” ＋ #引号 ＋ “:” ＋ #引号, #引号, , )
        所在省市 ＝ 文本_取出中间文本 (局_返回, #引号 ＋ “address” ＋ #引号 ＋ “:” ＋ #引号, #引号, , )
    .判断 (接口 ＝ 4)
        局_网址 ＝ “http://whois.pconline.com.cn/ipJson.jsp?json=true”
        局_返回 ＝ 到文本 (网页_访问_对象 (局_网址, , , , , , , , , , , , , , , , , , ))
        局_IP ＝ 文本_取出中间文本 (局_返回, #引号 ＋ “ip” ＋ #引号 ＋ “:” ＋ #引号, #引号, , )
        所在省市 ＝ 文本_取出中间文本 (局_返回, #引号 ＋ “pro” ＋ #引号 ＋ “:” ＋ #引号, #引号, , )
    .判断 (接口 ＝ 5)
        局_网址 ＝ “https://www.uc.cn/ip”
        局_返回 ＝ 编码_Utf8到Ansi (网页_访问_对象 (局_网址, , , , , , , , , , , , , , , , , , ))
        局_IP ＝ 文本_取右边 (局_返回, “IP:”, , )
        所在省市 ＝ “” ' 返回无省市
    .判断 (接口 ＝ 6)
        局_网址 ＝ “https://api.ip.sb/ip”
        局_返回 ＝ 到文本 (网页_访问_对象 (局_网址, , , , , , , , , , , , , , , , , , ))
        局_IP ＝ 文本_取左边 (局_返回, 字符 (10), , )
        所在省市 ＝ “” ' 返回无省市
    .判断 (接口 ＝ 7)
        局_网址 ＝ “https://ipinfo.io/json”
        局_返回 ＝ 网页_访问S (局_网址, , , , , , , , , , , , , , , , , , , , )
        局_IP ＝ 文本_取出中间文本 (局_返回, “ip” ＋ #引号 ＋ “: ” ＋ #引号, #引号, , )
        所在省市 ＝ “” ' 返回无省市
    .默认
        局_网址 ＝ “http://www.ip138.com”
        局_结果 ＝ 网页_访问_对象 (局_网址, , , , , “User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.87 Safari/537.36”, , , , , , , , , , , , , )
        局_网址 ＝ 到文本 (字节集_取中间 (局_结果, 到字节集 (“<iframe src=”) ＋ { 34 }, { 34 }, )) ' 引号
        .如果真 (局_网址 ≈ “http” ＝ 假)
            局_网址 ＝ “http:” ＋ 局_网址
        .如果真结束
        局_返回 ＝ 编码_Utf8到Ansi (网页_访问_对象 (局_网址, , , , , , , , , , , , , , , , , , ))
        局_IP ＝ 文本_取出中间文本 (局_返回, “您的IP地址是：”, “</title>”, , )
        所在省市 ＝ 文本_取出中间文本 (局_返回, “来自：”, 字符 (10) ＋ “</p>”, , )
    .判断结束
    返回 (局_IP)

.子程序 网页_置Cookie, 逻辑型, 公开, 设置本地IE的cookie
    .参数 网址, 文本型
    .参数 Cookie名称, 文本型, 可空, 为空清除所有
    .参数 Cookie内容, 文本型, 可空, 为空清除
    .参数 有效期, 日期时间型, 可空, 为空不保存
    .局部变量 域名, 文本型
    .局部变量 GMT时间, 文本型
    .局部变量 现有Cookie, 文本型
    .局部变量 整数容器, 整数型
    .局部变量 名称, 文本型
    .局部变量 CookieStr, 文本型

    域名 ＝ 网页_取域名 (网址)
    CookieStr ＝ Cookie内容
    .如果 (Cookie名称 ≠ “”)
        .如果真 (Cookie内容 ＝ “”)
            CookieStr ＝ “delete”
            有效期 ＝ 指定时间 (1999, 1, 1, 1, 1, 1)
        .如果真结束
        .如果真 (有效期 ≠ 指定时间 (1899, 12, 30, 0, 0, 0))
            GMT时间 ＝ 时间_转为GMT格式 (有效期)
            CookieStr ＝ CookieStr ＋ “; expires=” ＋ GMT时间
        .如果真结束
        CookieStr ＝ CookieStr ＋ “; path=/”
        InternetSetCookieA (“http://” ＋ 域名, Cookie名称, CookieStr)
        CookieStr ＝ CookieStr ＋ “; domain=.” ＋ 网页_取域名 (域名, 真, )
        返回 (InternetSetCookieA (“http://” ＋ 域名, Cookie名称, CookieStr))
    .否则
        现有Cookie ＝ 网页_取Cookie (“http://” ＋ 域名)
        .如果真 (现有Cookie ≠ “”)
            整数容器 ＝ 寻找文本 (现有Cookie, “=”, 1, 真)
            .如果真 (整数容器 ＞ 0)
                名称 ＝ 取文本左边 (现有Cookie, 整数容器 － 1)
                网页_置Cookie (“http://” ＋ 域名, 名称)
                网页_置Cookie (“http://” ＋ 域名)
            .如果真结束
            
        .如果真结束
        返回 (真)
    .如果结束
    

.子程序 网页_置Cookie1, , 公开
    .参数 网站域名, 文本型
    .参数 Cookie值, 文本型, , 整个Cookie值
    .参数 有效期, 日期时间型, 可空, 可空。默认为2088年8月8日8时
    .局部变量 局_数组, 文本型, , "0"
    .局部变量 i, 整数型
    .局部变量 局_C名称, 文本型
    .局部变量 局_C内容, 文本型
    .局部变量 局_位置, 整数型

    .如果真 (是否为空 (有效期))
        有效期 ＝ [2088年8月8日8时]
    .如果真结束
    局_数组 ＝ 分割文本 (Cookie值, “;”, )
    .计次循环首 (取数组成员数 (局_数组), i)
        局_位置 ＝ 寻找文本 (局_数组 [i], “=”, , 假)
        .如果真 (局_位置 ＝ -1)
            到循环尾 ()
        .如果真结束
        局_C名称 ＝ 删首尾空 (取文本左边 (局_数组 [i], 局_位置 － 1))
        局_C内容 ＝ 删首尾空 (取文本右边 (局_数组 [i], 取文本长度 (局_数组 [i]) － 局_位置))
        网页_置Cookie (网站域名, 局_C名称, 局_C内容, 有效期)
    .计次循环尾 ()

.子程序 网页_取Cookie, 文本型, 公开, 取出指定域名在本机的cookie
    .参数 域名, 文本型, , 只接受域名
    .参数 Cookie名称, 文本型, 可空, 为空返回全部Cookie
    .局部变量 网址, 文本型
    .局部变量 读取内容, 文本型
    .局部变量 读取内容1, 文本型

    网址 ＝ “http://” ＋ 域名
    连续赋值 (取空白文本 (3000), 读取内容, 读取内容1)
    InternetGetCookieA (网址, 字符 (0), 读取内容, 3000)
    InternetGetCookieExA (网址, 字符 (0), 读取内容1, 3000, 8192, 0)
    读取内容 ＝ 网页_Cookie合并更新 (读取内容, 读取内容1)
    .如果真 (Cookie名称 ≠ “”)
        读取内容 ＝ 网页_取单条Cookie (读取内容, Cookie名称)
    .如果真结束
    返回 (读取内容)
    

.子程序 网页_取Cookie2, 文本型, 公开, [Mr.Yang]
    .参数 域名, 文本型, , 欲取出cookie域名 例:<a href="http://baidu.com或baidu.com" target="_blank">http://baidu.com或baidu.com</a>
    .参数 Path, 文本型, 可空, 取出存放在path的cookie
    .参数 Cookie名称, 文本型, 可空, 为空返回全部Cookie
    .局部变量 _域名, 文本型
    .局部变量 _Path, 文本型
    .局部变量 读取内容, 文本型
    .局部变量 读取内容1, 文本型

    .如果 (寻找文本 (域名, “://”, , 假) ＝ -1)
        _域名 ＝ “http://” ＋ 域名
    .否则
        _域名 ＝ 域名
    .如果结束
    
    .如果真 (取文本右边 (_域名, 1) ＝ “/”)
        _域名 ＝ 文本_删右边 (_域名, 1)
    .如果真结束
    .如果真 (Path ≠ “”)
        _Path ＝ Path
        .如果真 (取文本左边 (_Path, 1) ≠ “/”)
            _Path ＝ “/” ＋ _Path
        .如果真结束
        .如果真 (取文本右边 (_Path, 1) ≠ “/”)
            _Path ＝ _Path ＋ “/”
        .如果真结束
        _域名 ＝ _域名 ＋ _Path
    .如果真结束
    连续赋值 (取空白文本 (3000), 读取内容, 读取内容1)
    InternetGetCookieA (_域名, 字符 (0), 读取内容, 3000)
    InternetGetCookieExA (_域名, 字符 (0), 读取内容1, 3000, 8192, 0)
    网页_Cookie合并更新 (读取内容, 读取内容1)
    .如果真 (Cookie名称 ≠ “”)
        读取内容 ＝ 网页_取单条Cookie (读取内容, Cookie名称)
    .如果真结束
    返回 (读取内容)

.子程序 网页_取单条Cookie, 文本型, 公开, 从左往右获取
    .参数 Cookie, 文本型
    .参数 名称, 文本型
    .参数 不附带名称, 逻辑型, 可空
    .局部变量 t, 文本型

    Cookie ＝ 删首尾空 (Cookie)
    .如果真 (取文本右边 (Cookie, 1) ≠ “;”)
        Cookie ＝ Cookie ＋ “; ”
    .如果真结束
    t ＝ 取单条Cookie (Cookie, 名称)
    .判断开始 (不附带名称 或 t ＝ “”)
        返回 (t)
    .默认
        返回 (名称 ＋ “=” ＋ t)
    .判断结束
    

.子程序 取单条Cookie, 文本型
    .参数 原Cookies, 文本型
    .参数 单条Cookie名称, 文本型
    .局部变量 Cookies, 文本型, , "0"
    .局部变量 i, 整数型
    .局部变量 Name, 文本型

    Cookies ＝ 分割文本 (原Cookies, “;”, )
    .计次循环首 (取数组成员数 (Cookies), i)
        Name ＝ 文本_取左边 (删首尾空 (Cookies [i]), “=”, , )
        .如果真 (到小写 (Name) ＝ 到小写 (单条Cookie名称))
            .如果真 (寻找文本 (删首尾空 (Cookies [i]), “:”, , 假) ≠ -1)
                返回 (文本_取出中间文本 (删首尾空 (Cookies [i]), “=”, “:”, , ))
            .如果真结束
            返回 (文本_取右边 (删首尾空 (Cookies [i]), “=”, -1, ))
        .如果真结束
        
    .计次循环尾 ()
    返回 (“”)

.子程序 网页_清除Cookie, , 公开, 清除本机IE里的cookie
    .参数 域名, 文本型, , 只接受域名
    .局部变量 Cookie值1, 文本型
    .局部变量 Cookie值2, 文本型
    .局部变量 Cookie, 文本型, , "0"
    .局部变量 计次, 整数型
    .局部变量 最终Cookie, 文本型
    .局部变量 Cookie名, 文本型

    ClearInternetCacheW (编码_Ansi到Unicode (域名, ))
    Cookie值1 ＝ “deleted; expires=Fri, 1-Jan-1999 1:1:1 GMT; path=/;”
    Cookie值2 ＝ Cookie值1 ＋ “ domain=” ＋ 网页_取域名 (域名, 真)
    最终Cookie ＝ 网页_取Cookie (域名)
    Cookie ＝ 分割文本 (最终Cookie, “;”, )
    .计次循环首 (取数组成员数 (Cookie), 计次)
        Cookie名 ＝ 内部_Cookie取名 (Cookie [计次])
        InternetSetCookieA (“http://” ＋ 域名, Cookie名, Cookie值1)
        InternetSetCookieA (“http://” ＋ 域名, Cookie名, Cookie值2)
    .计次循环尾 ()

.子程序 ClearInternetCacheW
    .参数 域名, 字节集
    .局部变量 dwEntrySize, 整数型
    .局部变量 hEntry, 整数型
    .局部变量 lpCacheEntry, 整数型
    .局部变量 szSourceUrlName, 字节集
    .局部变量 szUrlSearchPattern, 字节集

    szUrlSearchPattern ＝ 编码_Ansi到Unicode (“Cookie:”, )
    hEntry ＝ FindFirstUrlCacheEntryW (取指针_字节集型 (szUrlSearchPattern), #NULL, dwEntrySize)
    lpCacheEntry ＝ LocalAlloc (#LMEM_ZEROINIT, dwEntrySize)
    hEntry ＝ FindFirstUrlCacheEntryW (取指针_字节集型 (szUrlSearchPattern), lpCacheEntry, dwEntrySize)
    .如果真 (hEntry ≠ #NULL)
        .循环判断首 ()
            szSourceUrlName ＝ 指针_到字节集W (指针_到整数 (lpCacheEntry ＋ 4))
            .如果真 (寻找字节集 (szSourceUrlName, 删除Unicode结尾空白字节 (域名, ), ) ≠ -1)
                DeleteUrlCacheEntryW (指针_到整数 (lpCacheEntry ＋ 4))
            .如果真结束
            
        .循环判断尾 (FindNextUrlCacheEntryW (hEntry, lpCacheEntry, dwEntrySize))
        FindCloseUrlCache (hEntry)
    .如果真结束
    LocalFree (lpCacheEntry)

.子程序 网页_清除Cookie文件, 逻辑型, 公开, 【此命令由小磊提供】，删除本地IE缓存的cookie文件
    .参数 关键字, 文本型, 可空, 输入Cookie文件的关键字即可,空则清除全部
    .参数 Cookie路径, 文本型, 参考 可空, 传递Cookie路径
    .局部变量 文件名, 文本型
    .局部变量 已删除, 逻辑型

    Cookie路径 ＝ 取文本注册项 (3, “Software\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders\Cookies”, )
    文件名 ＝ 寻找文件 (Cookie路径 ＋ “\*.txt”, )
    .判断循环首 (文件名 ≠ “”)
        .如果真 (寻找文本 (文件名, 关键字, 1, 假) ≠ -1 或 关键字 ＝ “”)
            .如果真 (删除文件 (Cookie路径 ＋ “\” ＋ 文件名))
                已删除 ＝ 真
            .如果真结束
            
        .如果真结束
        文件名 ＝ 寻找文件 (, )
    .判断循环尾 ()
    返回 (已删除)

.子程序 网页_删除IE缓存文件, 逻辑型, 公开, 【此命令由小磊提供】，删除本地IE的缓存文件
    .参数 缓存文件路径, 文本型, 参考 可空, 传递缓存文件路径
    .局部变量 文件名, 文本型
    .局部变量 已删除, 逻辑型

    缓存文件路径 ＝ 取文本注册项 (3, “Software\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders\Cache”, )
    文件名 ＝ 寻找文件 (缓存文件路径 ＋ “\*.*”, )
    .判断循环首 (文件名 ≠ “”)
        .如果真 (删除文件 (缓存文件路径 ＋ “\” ＋ 文件名))
            已删除 ＝ 真
        .如果真结束
        文件名 ＝ 寻找文件 (, )
    .判断循环尾 ()
    返回 (已删除)

.子程序 网页_保存, , 公开, 保存网页
    .参数 浏览器句柄, 整数型

    网页_发送命令 (浏览器句柄, 0, 258)

.子程序 网页_打印, , 公开, 打印
    .参数 浏览器句柄, 整数型

    网页_发送命令 (浏览器句柄, 0, 260) ' #define ID_IE_FILE_PRINT 260

.子程序 网页_全选, , 公开, 全选
    .参数 浏览器句柄, 整数型

    网页_发送命令 (浏览器句柄, 0, 31)

.子程序 网页_打印预览, , 公开, 打印预览
    .参数 浏览器句柄, 整数型

    网页_发送命令 (浏览器句柄, 0, 93)

.子程序 网页_查找关键字, , , 查找关键字
    .参数 浏览器句柄, 整数型

    网页_发送命令 (浏览器句柄, 0, 67)

.子程序 网页_保存html文档, , 公开, 保存html文档
    .参数 浏览器句柄, 整数型

    网页_发送命令 (浏览器句柄, 0, 71)

.子程序 网页_查看网页属性, , 公开, 查看网页属性
    .参数 浏览器句柄, 整数型

    网页_发送命令 (浏览器句柄, 0, 28)

.子程序 网页_设置网页字体, , 公开, 设置网页字体
    .参数 浏览器句柄, 整数型

    网页_发送命令 (浏览器句柄, 0, 90)

.子程序 网页_发送命令, , , 发送IE命令
    .参数 窗口句柄, 整数型, , 网页框句柄
    .参数 命令类型, 整数型, , 命令类型
    .参数 命令ID, 整数型, , 命令ID
    .局部变量 hwndSDV, 整数型, , , Shell DocObject View
    .局部变量 hwndIES, 整数型, , , Internet Explorer_Server

    窗口_查找网页句柄 (窗口句柄, hwndSDV, hwndIES)
    .如果真 (hwndSDV ≠ 0 且 hwndIES ≠ 0)
        .判断开始 (命令类型 ＝ 1)
            发送消息整数 (hwndIES, 273, 命令ID, 0)
        .默认
            发送消息整数 (hwndSDV, 273, 命令ID, 0)
        .判断结束
        
    .如果真结束
    

.子程序 窗口_查找网页句柄, , , 取网页框(WebBrowser)的子窗口句柄
    .参数 Hwnd, 整数型
    .参数 hwndSDV, 整数型, 参考, Shell DocObject View
    .参数 hwndIES, 整数型, 参考, Internet Explorer_Server
    .局部变量 窗口句柄, 整数型
    .局部变量 窗口类名, 文本型

    窗口句柄 ＝ FindWindowExA (Hwnd, 0, 0, 0)
    .判断循环首 (窗口句柄 ≠ 0)
        窗口类名 ＝ 窗口_取类名 (窗口句柄)
        .如果 (窗口类名 ＝ “Shell DocObject View”)
            hwndSDV ＝ 窗口句柄
            跳出循环 ()
        .否则
            窗口_查找网页句柄 (窗口句柄, hwndSDV, hwndIES)
        .如果结束
        窗口句柄 ＝ FindWindowExA (Hwnd, 窗口句柄, 0, 0)
    .判断循环尾 ()
    .如果真 (hwndSDV ≠ 0)
        窗口类名 ＝ 窗口_取类名 (窗口句柄)
        .如果真 (窗口类名 ＝ “Shell DocObject View”)
            hwndIES ＝ FindWindowExA (hwndSDV, 0, 0, 0)
        .如果真结束
        
    .如果真结束
    

.子程序 网页_取网址引用, 文本型, 公开, 返回指定网址的引用信息
    .参数 网址, 文本型
    .局部变量 pwszUrl1, 字节集
    .局部变量 urlComp, URL_COMPONENTS
    .局部变量 bool, 逻辑型
    .局部变量 lpszScheme, 文本型
    .局部变量 lpszHostName, 文本型
    .局部变量 Agreement, 文本型

    urlComp.dwStructSize ＝ 60
    urlComp.dwSchemeLength ＝ -1
    urlComp.dwHostNameLength ＝ -1
    urlComp.dwUrlPathLength ＝ -1
    urlComp.dwExtraInfoLength ＝ -1
    
    Agreement ＝ 文本_取左边 (网址, “//”)
    .如果真 (Agreement ＝ “mms:”)
        网址 ＝ 子文本替换 (网址, Agreement, “http:”, , , 真)
    .如果真结束
    pwszUrl1 ＝ 编码_Ansi到Unicode (网址)
    bool ＝ WinHttpCrackUrl (pwszUrl1, 取字节集长度 (pwszUrl1), 0, urlComp)
    .如果真 (bool)
        lpszScheme ＝ 编码_Unicode到Ansi (指针到字节集 (urlComp.lpszScheme, urlComp.dwSchemeLength × 2))
        lpszHostName ＝ 编码_Unicode到Ansi (指针到字节集 (urlComp.lpszHostName, urlComp.dwHostNameLength × 2))
        .如果真 (Agreement ＝ “mms:”)
            返回 (Agreement ＋ “//” ＋ lpszHostName)
        .如果真结束
        返回 (lpszScheme ＋ “://” ＋ lpszHostName)
    .如果真结束
    返回 (“”)

.子程序 网页_取页面地址, 文本型, 公开, 返回指定网址的页面地址
    .参数 网址, 文本型
    .局部变量 页面地址, 文本型
    .局部变量 符号位置, 整数型
    .局部变量 域名, 文本型

    域名 ＝ 网页_取域名 (网址)
    符号位置 ＝ 寻找文本 (网址, “/”, 寻找文本 (网址, 域名, 1, 真), 真)
    .如果 (符号位置 ＞ 0)
        页面地址 ＝ 取文本右边 (网址, 取文本长度 (网址) － 符号位置 ＋ 1)
    .否则
        页面地址 ＝ “/”
    .如果结束
    返回 (页面地址)

.子程序 网页_取网址文件名, 文本型, 公开, 取一个网站地址中的文件名
    .参数 网址, 文本型
    .局部变量 分隔块, 文本型, , "0"
    .局部变量 块数, 整数型
    .局部变量 文件名, 文本型

    分隔块 ＝ 分割文本 (网址, “/”, )
    块数 ＝ 取数组成员数 (分隔块)
    .如果真 (块数 ＝ 0)
        返回 (“”)
    .如果真结束
    返回 (分隔块 [块数])

.子程序 网页_取网络文件名, 文本型, 公开, 取特殊网络文件名，如{35419830/13139680144000128.mp3?xcode=91d07544}，取出文件名为“我可以抱你吗.mp3”
    .参数 网址, 文本型
    .局部变量 name, 文本型
    .局部变量 hOpen, 整数型
    .局部变量 hOpenUrl
    .局部变量 Length
    .局部变量 bool, 逻辑型
    .局部变量 sBuffer, 文本型

    hOpen ＝ InternetOpenA (“”, 0, 字符 (0), 字符 (0), 0)
    .如果真 (hOpen ≠ 0)
        hOpenUrl ＝ InternetOpenUrlA (hOpen, 网址, 字符 (0), 0, 2147483648, 0)
        .如果真 (hOpenUrl ≠ 0)
            bool ＝ HttpQueryInfoA (hOpenUrl, 22, “”, Length, 0) ' #HTTP_QUERY_RAW_HEADERS_CRLF
            sBuffer ＝ 取空白文本 (Length)
            bool ＝ HttpQueryInfoA (hOpenUrl, 22, sBuffer, Length, 0)
            .如果真 (bool)
                name ＝ 文本_取出中间文本 (sBuffer, “filename=” ＋ #引号, #引号)
            .如果真结束
            InternetCloseHandle (hOpenUrl)
        .如果真结束
        InternetCloseHandle (hOpen)
    .如果真结束
    返回 (name)

.子程序 网页_是否为网页, 逻辑型, 公开, 判断输入的地址是否为URL地址。
    .参数 网页地址, 文本型

    返回 (PathIsURL (网页地址))

.子程序 网页_还原网页颜色, 文本型, 公开, 转换颜色值到网页颜色的代码
    .参数 颜色值, 整数型
    .局部变量 结果文本, 文本型

    结果文本 ＝ 取十六进制文本 (颜色值)
    结果文本 ＝ 取文本中间 (结果文本, 5, 2) ＋ 取文本中间 (结果文本, 3, 2) ＋ 取文本左边 (结果文本, 2)
    .如果 (取文本长度 (结果文本) ＜ 6)
        结果文本 ＝ 取文本左边 (“#” ＋ 结果文本 ＋ “000000”, 7)
    .否则
        结果文本 ＝ “#” ＋ 结果文本
    .如果结束
    返回 (结果文本)

.子程序 网页_转换为HTML色, 文本型, 公开, 将RGB色转换为HTML色
    .参数 RGB颜色值, 整数型
    .局部变量 HTML颜色值, 文本型
    .局部变量 字节集, 字节集
    .局部变量 局_文本, 文本型

    字节集 ＝ 到字节集 (RGB颜色值)
    
    局_文本 ＝ 取十六进制文本 (字节集 [1])
    HTML颜色值 ＝ HTML颜色值 ＋ 选择 (取文本长度 (局_文本) ＝ 1, 局_文本 ＋ “0”, 局_文本)
    
    局_文本 ＝ 取十六进制文本 (字节集 [3])
    HTML颜色值 ＝ HTML颜色值 ＋ 选择 (取文本长度 (局_文本) ＝ 1, 局_文本 ＋ “0”, 局_文本)
    
    局_文本 ＝ 取十六进制文本 (字节集 [2])
    HTML颜色值 ＝ HTML颜色值 ＋ 选择 (取文本长度 (局_文本) ＝ 1, 局_文本 ＋ “0”, 局_文本)
    返回 (HTML颜色值)

.子程序 网页_取十进制颜色值, 整数型, 公开, 把十六进制的网页颜色值转换成十进制的颜色值    
    .参数 十六进制的颜色值, 文本型, , 234A97
    .局部变量 字节集, 字节集
    .局部变量 str, 文本型

    str ＝ 子文本替换 (十六进制的颜色值, “#”, “”, , , 真)
    字节集 ＝ 取空白字节集 (4)
    字节集 [1] ＝ 进制_十六到十 (取文本中间 (str, 1, 2))
    字节集 [2] ＝ 进制_十六到十 (取文本中间 (str, 3, 2))
    字节集 [3] ＝ 进制_十六到十 (取文本中间 (str, 5, 2))
    返回 (取字节集数据 (字节集, #整数型, ))

.子程序 网页_打开指定网址, , 公开, 使用系统默认的浏览器打开一个网址
    .参数 网页地址, 文本型, , 要打开的网页地址

    ShellExecuteA (0, “open”, 网页地址, “”, “”, 1)

.子程序 网页_创建快捷方式, 逻辑型, 公开, 创建网页快捷方式
    .参数 快捷方式文件名, 文本型, , 扩展名为.url全路径
    .参数 网页地址, 文本型
    .参数 ico图标, 文本型, 可空
    .参数 快捷键, 文本型, 可空, 如"CTRL+SHIFT+F"
    .局部变量 Wshom, 对象
    .局部变量 oUrlLink, 对象

    CoInitialize (0)
    .如果真 (Wshom.创建 (“{F935DC22-1CF0-11d0-ADB9-00C04FD58A0B}”, ))
        快捷方式文件名 ＝ 选择 (文件_取扩展名 (快捷方式文件名) ≠ “.url”, 快捷方式文件名 ＋ “.url”, 快捷方式文件名)
        oUrlLink ＝ Wshom.对象型方法 (“CreateShortcut”, 快捷方式文件名)
        oUrlLink.写属性 (“TargetPath”, 网页地址)
        oUrlLink.写属性 (“WindowStyle”, 2)
        oUrlLink.写属性 (“IconLocation”, ico图标)
        写配置项 (快捷方式文件名, “InternetShortcut”, “IconFile”, ico图标)
        写配置项 (快捷方式文件名, “InternetShortcut”, “IconIndex”, “0”)
        oUrlLink.写属性 (“Hotkey”, 快捷键)
        oUrlLink.数值方法 (“Save”, )
        Wshom.清除 ()
    .如果真结束
    CoUninitialize ()
    返回 (文件_是否存在 (快捷方式文件名))

.子程序 网页_取快捷方式地址, 文本型, 公开, 取网页快捷方式的地址；
    .参数 文件路径, 文本型

    返回 (读配置项 (文件路径, “InternetShortcut”, “URL”, ))

.子程序 网页_网络文件是否存在, 逻辑型, 公开, 判断网络上的文件是否存在，存在返回真，否则返回假；
    .参数 网络文件名, 文本型
    .局部变量 IXMLHTTP, 对象
    .局部变量 局_返回, 逻辑型

    CoInitialize (0)
    IXMLHTTP.创建 (“msxml2.XMLHTTP”, )
    IXMLHTTP.方法 (“open”, “HEAD”, 网络文件名, 假)
    IXMLHTTP.方法 (“send”, )
    局_返回 ＝ IXMLHTTP.读数值属性 (“Status”, ) ＝ 200
    IXMLHTTP.清除 ()
    CoUninitialize ()
    返回 (局_返回)

.子程序 网页_开始屏蔽信息框, 逻辑型, 公开, 屏蔽掉电脑上把有页页信息框，成功开始屏蔽返回真，失败返回假；
    .如果真 (集_屏蔽信息框线程句柄 ＝ 0)
        集_屏蔽信息框线程句柄 ＝ 线程_启动 (&内部_屏蔽网页信息框)
        返回 (真)
    .如果真结束
    .如果真 (集_屏蔽信息框线程句柄 ≠ 0)
        输出调试文本 (“已经开始了屏蔽网页信息框，请不要重复使用！”)
    .如果真结束
    返回 (假)

.子程序 网页_停止屏蔽信息框, , 公开, 停止屏蔽掉电脑上把有页页信息框
    线程_销毁 (集_屏蔽信息框线程句柄)
    线程_关闭句柄 (集_屏蔽信息框线程句柄)
    集_屏蔽信息框线程句柄 ＝ 0

.子程序 内部_屏蔽网页信息框, 整数型
    .参数 整数, 整数型
    .局部变量 窗口句柄, 整数型
    .局部变量 窗口标题, 文本型
    .局部变量 静态, 整数型
    .局部变量 子窗口数组, 整数型, , "0"
    .局部变量 i, 整数型

    静态 ＝ 1
    .判断循环首 (静态 ＝ 1) ' 构造死循环.又不让编译器不通过
        .计次循环首 (窗口_枚举所有子窗口 (, 子窗口数组, “#32770”), i)
            窗口标题 ＝ 窗口_取标题 (子窗口数组 [i])
            .如果真 (窗口标题 ＝ “来自网页的消息”) ' WIN7是IE9+提示这个
                发送消息整数 (子窗口数组 [i], 16, 0, 0)
            .如果真结束
            .如果真 (窗口标题 ＝ “Microsoft Internet Explorer”) ' ie6
                发送消息整数 (子窗口数组 [i], 16, 0, 0)
            .如果真结束
            
        .计次循环尾 ()
        延时 (500)
    .判断循环尾 ()
    返回 (0)

.子程序 网页_自动点击网页信息框, , 公开, 自动点击网页上弹出的消息框
    .参数 窗口句柄, 整数型, , 程序本身的窗口句柄,直接用 取窗口句柄() 命令即可
    .参数 网页信息框的标题, 文本型, 可空, 可空，网页信息框的标题,默认为【Microsoft Internet Explorer】
    .参数 按钮的标题, 文本型, 可空, 可空，消息框上要点击的按钮标题,默认为【确定】
    .参数 停止, 逻辑型, 可空, 可空，如果将此参数设置为真，将停止自动点击信息框
    .参数 监控间隔, 整数型, 可空, 可空，默认为300毫秒。

    .如果真 (停止)
        时钟_销毁 (窗口句柄, 100)
        返回 ()
    .如果真结束
    
    .如果真 (是否为空 (监控间隔) 或 监控间隔 ＜ 50)
        监控间隔 ＝ 300
    .如果真结束
    .如果真 (是否为空 (网页信息框的标题))
        网页信息框的标题 ＝ “Microsoft Internet Explorer”
    .如果真结束
    .如果真 (是否为空 (按钮的标题))
        按钮的标题 ＝ “确定”
    .如果真结束
    集_按钮的标题 ＝ 网页信息框的标题 ＋ “|” ＋ 按钮的标题
    时钟_创建 (窗口句柄, 100, 监控间隔, &开始自动点击网页信息框)

.子程序 开始自动点击网页信息框
    .局部变量 窗口句柄, 整数型
    .局部变量 子窗口句柄, 整数型

    窗口句柄 ＝ 窗口_取句柄 (, , “#32770”, 文本_取左边 (集_按钮的标题, “|”))
    子窗口句柄 ＝ 窗口_取句柄 (窗口句柄, , “Button”, 文本_取右边 (集_按钮的标题, “|”))
    .如果真 (子窗口句柄 ＞ 0)
        鼠标_消息 (子窗口句柄, 5, 5)
    .如果真结束
    

.子程序 网页_自动点击网页信息框_带返回值, 逻辑型, 公开, 成功返回真，失败返回假。
    .参数 网页信息框的标题, 文本型, 可空, 网页信息框的标题,默认为【Microsoft Internet Explorer】
    .参数 按钮的标题, 文本型, 可空, 消息框上要点击的按钮标题,默认为【确定】
    .参数 超时返回, 整数型, 可空, 可空，单位为毫秒，默认为5000毫秒。
    .参数 监控间隔, 整数型, 可空, 可空，默认为300毫秒。
    .局部变量 窗口句柄, 整数型
    .局部变量 子窗口句柄, 整数型
    .局部变量 局_超时, 整数型
    .局部变量 局_线程句柄, 整数型
    .局部变量 局_返回值, 整数型
    .局部变量 局_时间, 整数型

    .如果真 (是否为空 (网页信息框的标题))
        网页信息框的标题 ＝ “Microsoft Internet Explorer”
    .如果真结束
    .如果真 (是否为空 (按钮的标题))
        按钮的标题 ＝ “确定”
    .如果真结束
    .如果真 (是否为空 (超时返回) 或 超时返回 ＜ 1000)
        超时返回 ＝ 5000
    .如果真结束
    .如果真 (是否为空 (监控间隔) 或 监控间隔 ＜ 50)
        监控间隔 ＝ 300
    .如果真结束
    
    集_按钮的标题 ＝ 网页信息框的标题 ＋ “|” ＋ 按钮的标题
    局_线程句柄 ＝ 线程_启动 (&开始自动点击网页信息框_带返回值, 监控间隔)
    局_时间 ＝ 取启动时间 ()
    .循环判断首 ()
        局_返回值 ＝ MsgWaitForMultipleObjects (1, 局_线程句柄, 假, 超时返回, 1215)
        .如果真 (取启动时间 () － 局_时间 ≥ 超时返回)
            局_返回值 ＝ 258
        .如果真结束
        程序_延时 (300)
    .循环判断尾 (局_返回值 ≠ 0 且 局_返回值 ≠ 258) ' 258=已超时,0=线程正常结束
    .如果真 (局_返回值 ＝ 258) ' 线程_销毁 (局_线程句柄)
        线程_销毁 (局_线程句柄)
        CloseHandle (局_线程句柄)
    .如果真结束
    返回 (局_返回值 ≠ 258) ' 如果不是超时,则为真

.子程序 开始自动点击网页信息框_带返回值
    .参数 监控间隔, 整数型
    .局部变量 窗口句柄, 整数型
    .局部变量 子窗口句柄, 整数型

    .判断循环首 (真)
        窗口句柄 ＝ 窗口_取句柄 (, , “#32770”, 文本_取左边 (集_按钮的标题, “|”))
        子窗口句柄 ＝ 窗口_取句柄 (窗口句柄, , “Button”, 文本_取右边 (集_按钮的标题, “|”))
        .如果真 (子窗口句柄 ＞ 0)
            鼠标_消息 (子窗口句柄, 5, 5)
            鼠标_消息 (子窗口句柄, 5, 5)
            返回 ()
        .如果真结束
        程序_延时 (监控间隔)
    .判断循环尾 ()

.子程序 立即刷新注册表
    发送消息整数 (GetDesktopWindow (), 26, 0, 0)

.子程序 网页_屏蔽网页复制提示, , 公开, 目前只测试了IE8
    .参数 是否屏蔽, 逻辑型, 可空, 默认为真，允许网页复制，假为不允许。
    .局部变量 注册表, 注册表操作

    .如果 (是否为空 (是否屏蔽) 或 是否屏蔽 ＝ 真)
        注册表.写DWORD值 (“HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Internet Settings\Zones\3”, “1407”, 0)
    .否则
        注册表.写DWORD值 (“HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Internet Settings\Zones\3”, “1407”, 1)
    .如果结束
    立即刷新注册表 ()

.子程序 网页_禁止允许一键操作, , 公开, 一键操作所有设置（写注册项，影响全局，不仅仅是软件的自带浏览器）
    .参数 禁止允许gif图片, 逻辑型, 可空, 禁止或允许 播放GIF动画图片，可以加快网页的显示速度。默认为假，允许。
    .参数 禁止允许显示图片, 逻辑型, 可空, 禁止或允许 显示网页中的图片，可以加快网页的显示速度。默认为假，允许。
    .参数 禁止允许背景声音, 逻辑型, 可空, 禁止或允许 播放网页背景声音，如：mid、mp3等等。默认为假，允许。
    .参数 禁止允许点击声音, 逻辑型, 可空, 禁止或允许 在点击网页链接或网页跳转时,会有一个点击的声音,用此命令可以禁止或恢复它。默认为假，允许。
    .参数 禁止允许播放网页视频, 逻辑型, 可空, 禁止或允许 播放网页中的视频，可以加快网页的显示速度。默认为假，允许。

    网页_禁止允许gif图片 (禁止允许gif图片)
    网页_禁止允许显示图片 (禁止允许显示图片)
    网页_禁止允许背景声音 (禁止允许背景声音)
    网页_禁止允许点击声音 (禁止允许点击声音)
    网页_禁止允许播放网页视频 (禁止允许播放网页视频)

.子程序 网页_禁止允许gif图片, 逻辑型, 公开, 禁止或允许 播放GIF动画图片，可以加快网页的显示速度。默认为假，允许。（写注册项，影响全局，不仅仅是软件的自带浏览器）
    .参数 禁止或允许, 逻辑型, 可空, 可空：默认为假 真=禁止 假=允许
    .局部变量 局_文本, 文本型

    局_文本 ＝ 选择 (禁止或允许, “no”, “yes”)
    禁止或允许 ＝ 写注册项 (#现行用户, “Software\Microsoft\Internet Explorer\Main\Play_Animations”, 局_文本)
    立即刷新注册表 ()
    返回 (禁止或允许)

.子程序 网页_禁止允许背景声音, 逻辑型, 公开, 禁止或允许 播放网页背景声音，如：mid、mp3等等。默认为假，允许。（写注册项，影响全局，不仅仅是软件的自带浏览器）
    .参数 禁止或允许, 逻辑型, 可空, 可空：默认为假 真=禁止 假=允许
    .局部变量 局_文本, 文本型

    局_文本 ＝ 选择 (禁止或允许, “no”, “yes”)
    禁止或允许 ＝ 写注册项 (#现行用户, “Software\Microsoft\Internet Explorer\Main\Play_Background_Sounds”, 局_文本)
    立即刷新注册表 ()
    返回 (禁止或允许)

.子程序 网页_禁止允许显示图片, 逻辑型, 公开, 禁止或允许 显示网页中的图片，可以加快网页的显示速度。默认为假，允许。（写注册项，影响全局，不仅仅是软件的自带浏览器）
    .参数 禁止或允许, 逻辑型, 可空, 可空：默认为假 真=禁止 假=允许
    .局部变量 局_文本, 文本型

    局_文本 ＝ 选择 (禁止或允许, “no”, “yes”)
    禁止或允许 ＝ 写注册项 (#现行用户, “Software\Microsoft\Internet Explorer\Main\Display Inline Images”, 局_文本)
    立即刷新注册表 ()
    返回 (禁止或允许)

.子程序 网页_禁止允许点击声音, 逻辑型, 公开, 禁止或允许 在点击网页链接或网页跳转时,会有一个点击的声音,用此命令可以禁止或恢复它。默认为假，允许。（写注册项，影响全局，不仅仅是软件的自带浏览器）
    .参数 禁止或允许, 逻辑型, 可空, 可空：默认为假 真=禁止 假=允许
    .局部变量 局_声音路径, 文本型
    .局部变量 局_REG路径, 文本型
    .局部变量 注册表, 注册表操作

    局_REG路径 ＝ “HKEY_CURRENT_USER\AppEvents\Schemes\Apps\Explorer\Navigating\.Current”
    局_声音路径 ＝ 到文本 (注册表.取字节集 (局_REG路径, “”, 到数值 (文本_取右边 (注册表.取键名类型 (局_REG路径), “：”))))
    .如果真 (删首尾空 (局_声音路径) ＝ “”)
        返回 (假)
    .如果真结束
    .判断开始 (禁止或允许)
        .如果真 (取文本右边 (局_声音路径, 1) ＝ “1”)
            返回 (真)
        .如果真结束
        返回 (注册表.写字节集 (局_REG路径, “”, 到字节集 (局_声音路径 ＋ “1”), 到数值 (文本_取右边 (注册表.取键名类型 (局_REG路径), “：”))))
    .判断 (禁止或允许 ＝ 假)
        .如果真 (取文本右边 (局_声音路径, 1) ≠ “1”)
            返回 (真)
        .如果真结束
        局_声音路径 ＝ 取文本左边 (局_声音路径, 取文本长度 (局_声音路径) － 1)
        返回 (注册表.写字节集 (局_REG路径, “”, 到字节集 (局_声音路径), 到数值 (文本_取右边 (注册表.取键名类型 (局_REG路径), “：”))))
    .默认
        
    .判断结束
    返回 (假)

.子程序 网页_禁止允许播放网页视频, 逻辑型, , 禁止或允许 播放网页中的视频，可以加快网页的显示速度。默认为假，允许。（写注册项，影响全局，不仅仅是软件的自带浏览器）
    .参数 禁止或允许, 逻辑型, 可空, 可空：默认为假 真=禁止 假=允许
    .局部变量 局_文本, 文本型

    局_文本 ＝ 选择 (禁止或允许, “no”, “yes”)
    禁止或允许 ＝ 写注册项 (#现行用户, “Software\Microsoft\Internet Explorer\Main\Display Inline Videos”, 局_文本)
    立即刷新注册表 ()
    返回 (禁止或允许)

.子程序 网页_取编码, 文本型, 公开, 用于取出指定网页地址的编码
    .参数 网页地址, 文本型
    .局部变量 局_网页内容, 文本型
    .局部变量 局_正则, 正则表达式类
    .局部变量 局_编码类型, 文本型

    局_网页内容 ＝ 到文本 (网页_访问 (网页地址))
    .如果真 (取文本长度 (局_网页内容) ＞ 0)
        .如果真 (局_正则.创建 (“<meta.+?charset=[^\w]?([-\w]+)”, 取文本左边 (局_网页内容, 1024)))
            局_编码类型 ＝ 局_正则.取子匹配文本 (1, 1)
        .如果真结束
        返回 (局_编码类型)
    .如果真结束
    返回 (“”)

.子程序 网页_取网络文件尺寸, 长整数型, 公开
    .参数 欲取网络文件地址, 文本型
    .局部变量 hOpen
    .局部变量 hOpenUrl
    .局部变量 sbuffer, 文本型
    .局部变量 Length, 整数型

    hOpen ＝ InternetOpenA (“”, 0, 字符 (0), 字符 (0), 0)
    .如果真 (hOpen ≠ 0)
        hOpenUrl ＝ InternetOpenUrlA (hOpen, 欲取网络文件地址, 字符 (0), 0, 2147483648, 0)
        .如果真 (hOpenUrl ≠ 0)
            HttpQueryInfoA (hOpenUrl, 5, “”, Length, 0)
            sbuffer ＝ 取空白文本 (Length)
            HttpQueryInfoA (hOpenUrl, 5, sbuffer, Length, 0)
            InternetCloseHandle (hOpenUrl)
        .如果真结束
        InternetCloseHandle (hOpen)
    .如果真结束
    返回 (到长整数 (sbuffer))

.子程序 网络_取网络文件大小_对象版, 长整数型, 公开
    .参数 url, 文本型
    .参数 代理IP, 文本型, 可空
    .局部变量 局_http, 对象
    .局部变量 局_结果, 变体型
    .局部变量 局_返回, 长整数型

    ' 该例程收录自：https://bbs.125.la/thread-14380851-1-1.html
    CoInitialize (0)
    .如果 (局_http.创建 (“WinHttp.WinHttpRequest.5.1”, ))
        局_http.方法 (“SetTimeouts”, 5000, 5000, 10000, 5000)
        局_http.方法 (“open”, “HEAD”, url, 假)
        局_http.方法 (“setRequestHeader”, “User-Agent”, “Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)”)
        局_http.方法 (“setRequestHeader”, “Accept-Language”, “zh-cn”)
        局_http.方法 (“setRequestHeader”, “Connection”, “Keep-Alive”)
        .如果真 (是否为空 (代理IP) ＝ 假)
            局_http.方法 (“SetProxy”, 代理IP)
        .如果真结束
        局_http.方法 (“send”, )
        局_结果 ＝ 局_http.读属性 (“status”, )
        .如果 (到整数 (局_结果.取数值 ()) ＝ 200)
            局_结果 ＝ 局_http.读属性 (“GetResponseHeader”, “Content-Length”)
            局_返回 ＝ 到长整数 (局_结果.取数值 ())
            CoUninitialize ()
            返回 (局_返回)
        .否则
            CoUninitialize ()
            返回 (-1)
        .如果结束
        
    .否则
        CoUninitialize ()
        返回 (-2)
    .如果结束
    

.子程序 网址_取所有参数, 整数型, 公开, 取出指定网址中所有的键名和键值，返回取到的数量。
    .参数 参_网址, 文本型
    .参数 参_名称, 文本型, 参考 可空, 返回名称；如：http://www.baidu.com/nihao?id=123456&name=hello，其中nihao就是名称
    .参数 参_键名数组, 文本型, 参考 可空 数组
    .参数 参_键值数组, 文本型, 参考 可空 数组
    .局部变量 局_临时url, 文本型
    .局部变量 局_最后位置, 整数型
    .局部变量 局_参数文本, 文本型
    .局部变量 局_返回位置1, 整数型
    .局部变量 局_起始位置1, 整数型
    .局部变量 局_返回位置2, 整数型
    .局部变量 局_参数名, 文本型
    .局部变量 局_返回位置3, 整数型
    .局部变量 局_参数值, 文本型

    ' https://bbs.125.la/thread-14496162-1-1.html
    
    局_临时url ＝ 参_网址
    
    局_最后位置 ＝ 寻找文本 (局_临时url, “?”, , 假) ' 针对url中参数部分包含url，会导致解析最后一个url，所以要从第一个?位置开始寻找
    
    .判断开始 (局_最后位置 ＝ -1)
        局_最后位置 ＝ 倒找文本 (局_临时url, “/”, , 假)
    .默认
        局_最后位置 ＝ 倒找文本 (局_临时url, “/”, 局_最后位置, 假) ' 通常url参数部分都是从最后一个/符号开始的
    .判断结束
    
    局_参数文本 ＝ 取文本右边 (局_临时url, 取文本长度 (局_临时url) － 局_最后位置)
    
    局_返回位置1 ＝ 寻找文本 (局_参数文本, “?”, , 假)
    .判断开始 (局_返回位置1 ≠ -1)
        参_名称 ＝ 取文本左边 (局_参数文本, 局_返回位置1 － 1)
    .默认
        参_名称 ＝ “”
    .判断结束
    
    ' 替换掉第一次出现的?符号，部分url第一个参数是用?号开始的
    局_参数文本 ＝ 子文本替换 (局_参数文本, “?”, “&”, , 1, 真)
    清除数组 (参_键名数组)
    清除数组 (参_键值数组)
    .判断循环首 (真)
        
        ' 寻找参数名，&和=直接的就是参数名
        局_返回位置1 ＝ 寻找文本 (局_参数文本, “&”, 局_起始位置1, 假)
        
        .如果真 (局_返回位置1 ＝ -1)
            跳出循环 ()
        .如果真结束
        
        局_返回位置2 ＝ 寻找文本 (局_参数文本, “=”, 局_返回位置1, 假)
        .如果真 (局_返回位置2 ＝ -1)
            跳出循环 ()
        .如果真结束
        
        ' 如果寻找到&和?就取出两个符号之间的参数名
        局_参数名 ＝ 取文本中间 (局_参数文本, 局_返回位置1 ＋ 1, 局_返回位置2 － 局_返回位置1 － 1)
        加入成员 (参_键名数组, 局_参数名)
        
        ' 寻找参数值，从上一次的=号位置开始寻找&号，中间的内容就是参数值了
        局_返回位置3 ＝ 寻找文本 (局_参数文本, “&”, 局_返回位置2, 假)
        .判断开始 (局_返回位置3 ＝ -1) ' 如果找不到&符号，表示到url尾部了，取出尾部所有内容即可
            局_参数值 ＝ 取文本右边 (局_参数文本, 取文本长度 (局_参数文本) － 局_返回位置2)
        .默认
            局_参数值 ＝ 取文本中间 (局_参数文本, 局_返回位置2 ＋ 1, 局_返回位置3 － 局_返回位置2 － 1)
        .判断结束
        加入成员 (参_键值数组, 局_参数值)
        
        ' 最后一次找到的=符号的位置要赋值给起始位置
        局_起始位置1 ＝ 局_返回位置2
        
    .判断循环尾 ()
    返回 (取数组成员数 (参_键名数组))

.子程序 网页_参数Ascii排序, 文本型, 公开, 对传入的请求参数按参数名的字典序（ASCII码)排序
    .参数 请求参数, 文本型, , url键值对格式(即key1=value1&key2=value2)
    .参数 排序方式, 整数型, 可空, 0.升序排序 1.降序排序  留空默认 0.升序
    .局部变量 局_参数名, 文本型, , "0"
    .局部变量 局_字符串, 文本型
    .局部变量 len, 整数型
    .局部变量 i, 整数型

    ' https://bbs.125.la/forum.php?mod=viewthread&tid=14511499
    .如果真 (排序方式 ＜ 0 或 排序方式 ＞ 1)
        排序方式 ＝ 0
    .如果真结束
    局_参数名 ＝ 分割文本 (请求参数, “&”, )
    数组_排序 (局_参数名, 排序方式, 真)
    len ＝ 取数组成员数 (局_参数名)
    .计次循环首 (len, i)
        局_字符串 ＝ 局_字符串 ＋ 局_参数名 [i]
        .如果真 (i ＜ len)
            局_字符串 ＝ 局_字符串 ＋ “&”
        .如果真结束
        
    .计次循环尾 ()
    返回 (局_字符串)

.子程序 网址_取指定参数值, 文本型, 公开, 成功返回键值，失败返回空。
    .参数 网址, 文本型
    .参数 参数名, 文本型
    .局部变量 len, 整数型
    .局部变量 局_键名, 文本型, , "0"
    .局部变量 局_键值, 文本型, , "0"
    .局部变量 i, 整数型

    len ＝ 网址_取所有参数 (网址, , 局_键名, 局_键值)
    .计次循环首 (len, i)
        .如果真 (局_键名 [i] ＝ 参数名)
            返回 (局_键值 [i])
        .如果真结束
        
    .计次循环尾 ()
    返回 (“”)

.子程序 网页_掩码计算, 整数型, 公开, 例：起始IP：121.224.0.0   结束IP：121.239.255.255   返回12
    .参数 起始IP, 文本型
    .参数 结束IP, 文本型
    .局部变量 L_起始IP, 文本型, , "0"
    .局部变量 L_结束IP, 文本型, , "0"
    .局部变量 L_起始IP_二进制, 文本型
    .局部变量 L_结束IP_二进制, 文本型
    .局部变量 L_01, 整数型
    .局部变量 L_起始IP_二进制_Arr, 文本型, , "0"
    .局部变量 L_结束IP_二进制_Arr, 文本型, , "0"

    ' https://bbs.125.la/forum.php?mod=viewthread&tid=14634957
    L_起始IP ＝ 分割文本 (起始IP, “.”, )
    L_结束IP ＝ 分割文本 (结束IP, “.”, )
    .计次循环首 (4, L_01)
        L_起始IP_二进制 ＝ L_起始IP_二进制 ＋ 取文本右边 (进制_十到二 (到整数 (L_起始IP [L_01])), 8)
        L_结束IP_二进制 ＝ L_结束IP_二进制 ＋ 取文本右边 (进制_十到二 (到整数 (L_结束IP [L_01])), 8)
    .计次循环尾 ()
    .计次循环首 (32, L_01)
        .如果真 (取文本中间 (L_起始IP_二进制, L_01, 1) ≠ 取文本中间 (L_结束IP_二进制, L_01, 1))
            返回 (L_01 － 1)
        .如果真结束
        
    .计次循环尾 ()
    返回 (0)

.子程序 网页_掩码取结束IP, 文本型, 公开, 例：121.224.0.0/12   起始IP：121.224.0.0 掩码：12     返回结束IP：121.239.255.255
    .参数 起始IP, 文本型, , 例：121.224.0.0
    .参数 掩码, 整数型, , 例：12
    .局部变量 L_起始IP, 文本型, , "0"
    .局部变量 L_结束IP, 文本型
    .局部变量 L_起始IP_二进制, 文本型
    .局部变量 L_结束IP_二进制, 文本型
    .局部变量 L_01, 整数型
    .局部变量 L_02, 整数型

    ' https://bbs.125.la/forum.php?mod=viewthread&tid=14634957
    L_起始IP ＝ 分割文本 (起始IP, “.”, )
    .计次循环首 (4, L_01)
        L_起始IP_二进制 ＝ L_起始IP_二进制 ＋ 取文本右边 (进制_十到二 (到整数 (L_起始IP [L_01])), 8)
    .计次循环尾 ()
    L_结束IP_二进制 ＝ 取文本左边 (L_起始IP_二进制, 掩码) ＋ 取文本右边 (“11111111111111111111111111111111”, 32 － 掩码)
    .计次循环首 (4, L_02)
        L_结束IP ＝ L_结束IP ＋ 到文本 (进制_二到十 (取文本中间 (L_结束IP_二进制, (L_02 － 1) × 8 ＋ 1, 8))) ＋ “.”
    .计次循环尾 ()
    返回 (取文本左边 (L_结束IP, 取文本长度 (L_结束IP) － 1))

.子程序 网页_断点续传, , 公开, 文件下载
    .参数 欲下载的Url, 文本型
    .参数 欲写入文件的路径, 文本型
    .参数 交互回调函数, 整数型, 可空, 第一个参数为待下载文件总长度指针，第二个参数为已下载总长度指针。

    网页_断点续传W (编码_Ansi到Unicode (欲下载的Url, ), 编码_Ansi到Unicode (欲写入文件的路径, ), 交互回调函数)

.子程序 网页_断点续传W, , 公开, 文件下载
    .参数 欲下载的Url, 字节集
    .参数 欲写入文件的路径, 字节集
    .参数 交互回调函数, 整数型, 可空, 第一个参数为待下载文件总长度指针，第二个参数为已下载总长度指针。
    .局部变量 hInternet, 整数型
    .局部变量 hFile, 整数型
    .局部变量 dwFileSize, 长整数型
    .局部变量 szHeaderAdd, 字节集
    .局部变量 hConnect, 整数型
    .局部变量 dwBufLen, 整数型
    .局部变量 pMem, 整数型
    .局部变量 dwContentLen, 长整数型
    .局部变量 aryBin, 字节集
    .局部变量 dwSize, 整数型
    .局部变量 timestamp, 长整数型

    timestamp ＝ 到长整数 (时间_到时间戳1 (, 1))
    hInternet ＝ InternetOpenW (#NULL, #INTERNET_OPEN_TYPE_PRECONFIG, #NULL, #NULL, 0)
    .如果真 (hInternet ＝ #NULL)
        返回 ()
    .如果真结束
    hFile ＝ CreateFileW (欲写入文件的路径, 位或 (#GENERIC_READ, #GENERIC_WRITE), #FILE_SHARE_READ, #NULL, #OPEN_ALWAYS, #FILE_ATTRIBUTE_NORMAL, #NULL)
    .如果真 (hFile ≠ #INVALID_HANDLE_VALUE)
        SetFilePointerEx (hFile, 0, dwFileSize, #FILE_END)
        szHeaderAdd ＝ 编码_Ansi到Unicode (#headers ＋ “Range: bytes=” ＋ 到文本 (dwFileSize) ＋ “-” ＋ #换行符, )
        hConnect ＝ InternetOpenUrlW (hInternet, 取指针_字节集型 (欲下载的Url), 取指针_字节集型 (szHeaderAdd), -1, #INTERNET_FLAG_NO_CACHE_WRITE, #NULL)
        .如果真 (hConnect ≠ #NULL)
            dwBufLen ＝ 16 ' sizeof(__int64) * sizeof(wchar_t)
            pMem ＝ HeapAlloc (GetProcessHeap (), #HEAP_ZERO_MEMORY, dwBufLen)
            .如果真 (pMem ≠ #NULL)
                .如果真 (HttpQueryInfoW (hConnect, 位或 (#HTTP_QUERY_CONTENT_LENGTH, #HTTP_QUERY_FLAG_NUMBER64), pMem, dwBufLen, #NULL))
                    dwContentLen ＝ __get_int64 (pMem, 0)
                .如果真结束
                HeapFree (GetProcessHeap (), 0, pMem)
            .如果真结束
            .如果真 (dwContentLen ＞ 0)
                aryBin ＝ 取空白字节集 (m_stageSize)
                .循环判断首 ()
                    .如果真 (InternetReadFile (hConnect, aryBin, m_stageSize, dwSize) ＝ 假)
                        跳出循环 ()
                    .如果真结束
                    .如果真 (dwSize ＝ 0)
                        跳出循环 ()
                    .如果真结束
                    dwFileSize ＝ dwFileSize ＋ dwSize
                    WriteFile (hFile, aryBin, dwSize, #NULL, #NULL)
                    .如果真 (交互回调函数 ≠ #NULL)
                        调用子程序x64_ (交互回调函数, dwContentLen, dwFileSize, , , , , , , , , , , , , )
                    .如果真结束
                    处理事件 ()
                .循环判断尾 (真)
            .如果真结束
            InternetCloseHandle (hConnect)
        .如果真结束
        CloseHandle (hFile)
    .如果真结束
    InternetCloseHandle (hInternet)
    输出调试文本 (“耗时：” ＋ 到文本 (到长整数 (时间_到时间戳1 (, 1)) － timestamp) ＋ “ms”)

.子程序 template_DownProgFunc, , , <= 网页_断点续传
    .参数 dwContentLen, 长整数型
    .参数 dwFileSize, 长整数型

    

.子程序 CreateIWinHttpRequest, 字节集
    .参数 网址, 文本型
    .参数 方法, 文本型
    .参数 请求, 字节集, 可空
    .参数 请求协议头, 文本型, 可空
    .参数 响应协议头, 文本型, 可空
    .参数 解析超时, 整数型, 可空
    .参数 连接超时, 整数型, 可空
    .参数 发送超时, 整数型, 可空
    .参数 接收超时, 整数型, 可空
    .参数 状态代码, 整数型, 参考 可空
    .局部变量 pIWinHttpRequest, 整数型
    .局部变量 wszUrl, 字节集
    .局部变量 wszMethod, 字节集
    .局部变量 pvarVal, 整数型
    .局部变量 pvBody, 整数型
    .局部变量 aryHeader, 文本型, , "0"
    .局部变量 dwCount, 整数型
    .局部变量 szHeader, 文本型
    .局部变量 wszHeader, 字节集
    .局部变量 wszValue, 字节集
    .局部变量 psa, 整数型
    .局部变量 pvData, 整数型
    .局部变量 cElements, 整数型
    .局部变量 szBuffer, 字节集
    .局部变量 hr, 整数型
    .局部变量 i, 整数型

    CoInitialize (#NULL)
    hr ＝ CoCreateInstance1 (取指针_字节集型 (#CLSID_WinHttpRequest), #NULL, #CLSCTX_INPROC_SERVER, 取指针_字节集型 (#IID_IWinHttpRequest), pIWinHttpRequest)
    .如果真 (hr ＝ #S_OK 且 pIWinHttpRequest ≠ #NULL)
        .如果真 (是否为空 (解析超时))
            解析超时 ＝ 0
        .如果真结束
        .如果真 (是否为空 (连接超时))
            连接超时 ＝ 60000
        .如果真结束
        .如果真 (是否为空 (发送超时))
            发送超时 ＝ 30000
        .如果真结束
        .如果真 (是否为空 (接收超时))
            接收超时 ＝ 30000
        .如果真结束
        hr ＝ CallObject (pIWinHttpRequest, #IWinHttpRequest_SetTimeouts, 解析超时, 连接超时, 发送超时, 接收超时, , , , , )
        
        pvarVal ＝ LocalAlloc (#LMEM_ZEROINIT, 16) ' sizeof(VARIANT)
        __set_short (pvarVal, 0, 3) ' VT_I4
        __set (pvarVal, 8, 13056) ' SslErrorFlag_Ignore_All
        hr ＝ CallObject (pIWinHttpRequest, #IWinHttpRequest_put_Option, #WinHttpRequestOption_SslErrorIgnoreFlags, pvarVal, , , , , , , )
        
        memset (pvarVal, 0, 16)
        __set_short (pvarVal, 0, 11) ' VT_BOOL
        __set_short (pvarVal, 8, #VARIANT_FALSE)
        wszUrl ＝ 编码_Ansi到Unicode (网址, )
        wszMethod ＝ 编码_Ansi到Unicode (方法, )
        hr ＝ CallObject (pIWinHttpRequest, #IWinHttpRequest_Open, 取指针_字节集型 (wszMethod), 取指针_字节集型 (wszUrl), pvarVal, , , , , , )
        
        wszHeader ＝ 编码_Ansi到Unicode (“User-Agent”, )
        wszValue ＝ 编码_Ansi到Unicode (“Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.87 Safari/537.36”, )
        hr ＝ CallObject (pIWinHttpRequest, #IWinHttpRequest_SetRequestHeader, 取指针_字节集型 (wszHeader), #NULL, , , , , , , ) ' 删除
        hr ＝ CallObject (pIWinHttpRequest, #IWinHttpRequest_SetRequestHeader, 取指针_字节集型 (wszHeader), 取指针_字节集型 (wszValue), , , , , , , ) ' 赋值
        
        .如果真 (是否为空 (请求协议头) ＝ 假)
            aryHeader ＝ 分割文本 (请求协议头, #换行符, )
            dwCount ＝ 取数组成员数 (aryHeader)
            .计次循环首 (dwCount, i)
                szHeader ＝ 删首尾空 (aryHeader [i])
                wszHeader ＝ 编码_Ansi到Unicode (文本_取左边 (szHeader, “:”, -1, ), )
                wszValue ＝ 编码_Ansi到Unicode (文本_取右边 (szHeader, “:”, -1, ), )
                .如果真 (wszHeader ＝ { })
                    到循环尾 ()
                .如果真结束
                hr ＝ CallObject (pIWinHttpRequest, #IWinHttpRequest_SetRequestHeader, 取指针_字节集型 (wszHeader), #NULL, , , , , , , ) ' 删除
                .如果真 (wszValue ＝ { })
                    到循环尾 ()
                .如果真结束
                hr ＝ CallObject (pIWinHttpRequest, #IWinHttpRequest_SetRequestHeader, 取指针_字节集型 (wszHeader), 取指针_字节集型 (wszValue), , , , , , , ) ' 赋值
            .计次循环尾 ()
        .如果真结束
        
        psa ＝ LocalAlloc (#LMEM_ZEROINIT, 24) ' sizeof(SAFEARRAY)
        __set_short (psa, 0, 1) ' SAFEARRAY => cDims
        __set_short (psa, 2, 128) ' SAFEARRAY => fFeatures
        __set (psa, 4, 1) ' SAFEARRAY => cbElements
        __set (psa, 12, 取指针_字节集型 (请求)) ' SAFEARRAY => pvData
        __set (psa, 16, 取字节集长度 (请求)) ' SAFEARRAY => rgsabound->cElements
        memset (pvarVal, 0, 16)
        __set_short (pvarVal, 0, 位或 (8192, 17)) ' VT_ARRAY | VT_UI1
        __set (pvarVal, 8, psa)
        hr ＝ CallObject (pIWinHttpRequest, #IWinHttpRequest_Send, __get (pvarVal, 0), __get (pvarVal, 4), __get (pvarVal, 8), __get (pvarVal, 12), , , , , )
        LocalFree (psa)
        
        hr ＝ CallObject (pIWinHttpRequest, #IWinHttpRequest_get_Status, 取指针整数_ (状态代码), , , , , , , , )
        ' hr ＝ CallObject (pIWinHttpRequest, #IWinHttpRequest_get_ResponseText, 取指针整数_ (bstrText), , , , , , , , )
        
        memset (pvarVal, 0, 16)
        hr ＝ CallObject (pIWinHttpRequest, #IWinHttpRequest_get_ResponseBody, pvarVal, , , , , , , , )
        psa ＝ __get (pvarVal, 8) ' VARIANT => SAFEARRAY
        .如果真 (hr ＝ #S_OK 且 psa ≠ #NULL)
            pvData ＝ __get (psa, 12) ' SAFEARRAY => pvData
            cElements ＝ __get (psa, 16) ' SAFEARRAY => rgsabound->cElements
            .如果真 (pvData ≠ #NULL 且 cElements ＞ 0)
                szBuffer ＝ 指针到字节集 (pvData, cElements)
            .如果真结束
            连续赋值 (#NULL, pvData, cElements)
            SafeArrayDestroy (psa)
        .如果真结束
        LocalFree (pvarVal)
        
        .如果真 (是否为空 (响应协议头) ＝ 假)
            hr ＝ CallObject (pIWinHttpRequest, #IWinHttpRequest_GetAllResponseHeaders, 取指针整数_ (pvData), , , , , , , , )
            .如果真 (hr ＝ #S_OK 且 pvData ≠ #NULL)
                响应协议头 ＝ 编码_Unicode到Ansi (指针_到字节集W (pvData))
                SysFreeString (pvData)
            .如果真结束
            
        .如果真结束
        
        hr ＝ SafeRelease (pIWinHttpRequest)
    .如果真结束
    CoUninitialize ()
    返回 (szBuffer)

.子程序 网页_修补TLS协议, 逻辑型, 公开, 启用 TLS 1.1 和 TLS 1.2 协议
    返回 (系统_写数值注册项 (#HKEY_LOCAL_MACHINE, “SOFTWARE\Microsoft\Windows\CurrentVersion\Internet Settings\WinHttp”, #REG_DWORD, “DefaultSecureProtocols”, 2560, 假))

.子程序 HeadersToCookie, 文本型
    .参数 aryHeaders, 文本型, 数组
    .局部变量 dwCount, 整数型
    .局部变量 dwBegin, 整数型
    .局部变量 dwEnd, 整数型
    .局部变量 szHeaders, 文本型
    .局部变量 i, 整数型

    dwCount ＝ 取数组成员数 (aryHeaders)
    .计次循环首 (dwCount, i)
        dwBegin ＝ 寻找文本 (aryHeaders [i], “set-cookie:”, 1, 真)
        .如果真 (dwBegin ＝ 1)
            dwEnd ＝ 寻找文本 (aryHeaders [i], “;”, 12, 真)
            .如果真 (dwEnd ≠ -1)
                .如果真 (szHeaders ≠ “”)
                    szHeaders ＝ szHeaders ＋ “; ”
                .如果真结束
                szHeaders ＝ szHeaders ＋ 删首尾空 (取文本中间 (aryHeaders [i], 12, dwEnd － 12))
            .如果真结束
            
        .如果真结束
        
    .计次循环尾 ()
    返回 (szHeaders)

.版本 2

.程序集 类_线程池, , 公开, 更加灵活的线程池
.程序集变量 成员_线程池IOCP, 整数型
.程序集变量 线程池_状态, 逻辑型
.程序集变量 线程池_处理函数, 整数型
.程序集变量 成员_线程数, 整数型

.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
    

.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
    关闭 (1)

.子程序 启动, 逻辑型, 公开, 成功返回真，失败返回假。
    .参数 线程数, 整数型, , 处理客户请求的最大线程池的数目，最小为1。
    .参数 处理函数, 子程序指针, , 处理函数，该函数必须有一个整数形的参数。
    .参数 超时返回, 整数型, 可空, 单位为：毫秒。默认为0一直等待。
    .局部变量 临时_线程内存状态地址, 整数型

    .如果真 (线程池_状态)
        返回 (假)
    .如果真结束
    .如果真 (线程数 ＜ 1)
        线程数 ＝ 1
    .如果真结束
    
    临时_线程内存状态地址 ＝ HeapAlloc (GetProcessHeap (), #HEAP_ZERO_MEMORY, 16)
    ' 地址结构依次为：
    ' 完成端口IOCP句柄
    ' 线程池状态。 1运行，0停止
    ' 处理函数。到整数(子程序指针)
    ' 超时时间
    
    成员_线程池IOCP ＝ CreateIoCompletionPort (-1, 0, 0, 线程数)
    线程池_状态 ＝ 真
    线程池_处理函数 ＝ 到整数 (处理函数)
    
    RtlMoveMemory_Eint_int (临时_线程内存状态地址, 成员_线程池IOCP, 4)
    RtlMoveMemory_Eint_int (临时_线程内存状态地址 ＋ 4, 到整数 (1), 4)
    RtlMoveMemory_Eint_int (临时_线程内存状态地址 ＋ 8, 线程池_处理函数, 4)
    RtlMoveMemory_Eint_int (临时_线程内存状态地址 ＋ 12, 超时返回, 4)
    成员_线程数 ＝ 线程数
    .计次循环首 (成员_线程数, )
        CloseHandle (线程_启动 (&内部_线程, 临时_线程内存状态地址)) ' 这几个句柄不再需要了，关闭
    .计次循环尾 ()
    返回 (真)

.子程序 加入工作, 逻辑型, 公开, 成功返回真，失败返回假。
    .参数 任务参数, 整数型

    .如果真 (取反 (线程池_状态))
        返回 (假)
    .如果真结束
    返回 (PostQueuedCompletionStatus (成员_线程池IOCP, 任务参数, 0, 0) ＝ 1)

.子程序 关闭, 逻辑型, 公开, 成功返回真，失败返回假。
    .参数 等待时间, 整数型, 可空, 可空。默认为“5000”毫秒。等待线程池销毁的时间，单位毫秒。如果为-1则无限等待。
    .参数 执行函数, 整数型, 可空, 可空。成功关闭后，执行此函数。
    .参数 传入参数, 整数型, 可空, 可空。第2个参数为空时，此参数无效。
    .局部变量 关闭, 逻辑型

    .如果真 (取反 (线程池_状态))
        返回 (假)
    .如果真结束
    
    线程池_状态 ＝ 假
    .计次循环首 (成员_线程数, )
        PostQueuedCompletionStatus (成员_线程池IOCP, 0, -999, 0) ' 通知所有线程退出
    .计次循环尾 ()
    
    .判断开始 (是否为空 (等待时间))
        等待时间 ＝ 5000
    .判断 (等待时间 ＝ -1)
        等待时间 ＝ 5000 × 5000
    .默认
        
    .判断结束
    ' 处理事件 ()
    ' 延时 (等待时间)
    程序_延时 (等待时间)
    ' 处理事件 ()
    关闭 ＝ CloseHandle (成员_线程池IOCP)
    返回 (关闭)

.子程序 取状态, 逻辑型, 公开, 取一个线程池的状态
    返回 (线程池_状态)

.版本 2

.程序集 类_队列, , 公开, 【先进先出】
.程序集变量 临界资源, 临界许可, , , 临界许可 用来做线程兼容的
.程序集变量 Heap, 整数型, , , 堆句柄
.程序集变量 Ptr, 整数型, , , 内存块句柄
.程序集变量 Ptrlen, 整数型, , , 内存块当前长度
.程序集变量 Tmplen, 整数型, , , 缓冲区大小
.程序集变量 Pushi, 整数型, , , 压入位置
.程序集变量 Popi, 整数型, , , 弹出位置
.程序集变量 Count, 整数型, , , 队列数量

.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
    InitializeCriticalSection_临界许可 (临界资源) ' 初始化临界许可 （许可证）
    Tmplen ＝ 1048576 ' 1mb‘默认缓冲区大小1MB
    Heap ＝ HeapCreate (1, Tmplen, 0) ' 申请一个堆
    Ptr ＝ HeapAlloc (Heap, 8, Tmplen) ' 申请一个内存块 大小为1M
    Ptrlen ＝ Tmplen
    Pushi ＝ 0
    Popi ＝ 0
    Count ＝ 0

.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
    HeapDestroy (Heap) ' 销毁堆
    Count ＝ 0
    Ptr ＝ 0
    Heap ＝ 0
    DeleteCriticalSection_临界许可 (临界资源) ' 删除临界资源

.子程序 增量缓冲区, 逻辑型, , 增量缓冲区
    .参数 len, 整数型
    .局部变量 tmp_len, 整数型
    .局部变量 tmp_ptr, 整数型

    tmp_len ＝ Ptrlen － Popi ' 算出有效数据长度
    Ptrlen ＝ tmp_len ＋ Tmplen ＋ len ' 算出移动后的大小 （其实应该先判断下减去演出位置后是否够本次压入 够的话可以直接返回的）
    tmp_ptr ＝ HeapAlloc (Heap, 8, Ptrlen) ' 新申请一块内存 （其实可以 HeapReAlloc ）
    .如果真 (tmp_ptr ＝ 0) ' 申请不到 那只能返回啦
        Ptrlen ＝ tmp_len ＋ Popi ' 还原内存块长度
        返回 (假)
    .如果真结束
    RtlMoveMemory (tmp_ptr, Ptr ＋ Popi, tmp_len) ' 把有效数据移动到新内存块
    HeapFree (Heap, 1, Ptr) ' 销毁旧内存块
    Ptr ＝ tmp_ptr ' 赋值新内存块地址
    Pushi ＝ Pushi － Popi ' 算出移动后的压入位置
    Popi ＝ 0
    返回 (真)

.子程序 收缩缓冲区, , , 收缩缓冲区
    .局部变量 tmp_len, 整数型
    .局部变量 tmp_ptr, 整数型

    ' //收缩和增量原理一样  （其实这里可以优化的很多 下面的写法内存收回并不及时）
    tmp_len ＝ Ptrlen － Popi
    tmp_ptr ＝ HeapAlloc (Heap, 8, tmp_len)
    .如果真 (tmp_ptr ＝ 0)
        返回 ()
    .如果真结束
    RtlMoveMemory (tmp_ptr, Ptr ＋ Popi, tmp_len)
    HeapFree (Heap, 1, Ptr)
    Ptr ＝ tmp_ptr
    Ptrlen ＝ tmp_len
    Pushi ＝ Pushi － Popi
    Popi ＝ 0
    返回 ()

.子程序 置缓冲区大小, , 公开, 置缓冲区大小 缓冲区大小建议是压入数据长度的倍数。（缓冲区大小不影响队列的容量）
    .参数 缓冲区大小, 整数型, 可空, 单位：KB，缓冲区大小 默认1M
    .局部变量 temp, 整数型

    EnterCriticalSection_临界许可 (临界资源) ' 进入临界
    .如果 (缓冲区大小 ＝ 0)
        Tmplen ＝ 1024 × 1024 ' 默认1MB
    .否则
        Tmplen ＝ 缓冲区大小 × 1024
    .如果结束
    LeaveCriticalSection_临界许可 (临界资源) ' 退出临界

.子程序 压入字节集, 逻辑型, 公开, 压入字节集 。成功返回真，失败返回假。
    .参数 bin, 字节集, , 要压入的数据
    .局部变量 len, 整数型

    len ＝ 取字节集长度 (bin)
    .如果真 (len ＜ 1)
        返回 (假)
    .如果真结束
    EnterCriticalSection_临界许可 (临界资源) ' 进入临界
    .如果真 (Pushi ＋ 4 ＋ len ＞ Ptrlen) ' 如果 压入位置+本次长度+占位符4 超过了内存块长度
        .如果真 (增量缓冲区 (len ＋ 4) ＝ 假) ' 执行增量操作
            LeaveCriticalSection_临界许可 (临界资源) ' 退出临界
            返回 (假)
        .如果真结束
        
    .如果真结束
    RtlMoveMemory_Eint_int (Ptr ＋ Pushi, len, 4) ' 写入bin的长度
    Pushi ＝ Pushi ＋ 4 ' 压入位置 + 4
    RtlMoveMemory_Ebin_int (Ptr ＋ Pushi, bin, len) ' 写入bin
    Pushi ＝ Pushi ＋ len ' 压入位置 + bin的长度
    Count ＝ Count ＋ 1 ' 队列数 + 1
    LeaveCriticalSection_临界许可 (临界资源) ' 退出临界
    返回 (真)

.子程序 弹出字节集, 逻辑型, 公开, 弹出字节集 。成功返回真，失败返回假。
    .参数 bin, 字节集, 参考, 用来接收弹出数据的变量
    .局部变量 len, 整数型

    EnterCriticalSection_临界许可 (临界资源) ' 进入临界
    .如果真 (Count ＜ 1) ' 队列数量少于 1
        LeaveCriticalSection_临界许可 (临界资源) ' 退出临界
        返回 (假)
    .如果真结束
    .如果真 (Popi ＞ Tmplen) ' 弹出位置超过缓冲区长度 表示内存块前端有很多空闲内存可以收回
        收缩缓冲区 ()
    .如果真结束
    len ＝ 0
    RtlMoveMemory_整数传址1 (len, Ptr ＋ Popi, 4) ' 取出本次bin数据的长度信息
    Popi ＝ Popi ＋ 4
    bin ＝ 取空白字节集 (len) ' 初始化E的变量用来接收bin
    RtlMoveMemory_字节集传址1 (bin, Ptr ＋ Popi, len) ' 复制bin
    Popi ＝ Popi ＋ len ' 弹出位置后移
    Count ＝ Count － 1 ' 队列数量减去 1
    LeaveCriticalSection_临界许可 (临界资源) ' 退出临界
    返回 (真)

.子程序 压入文本, 逻辑型, 公开, 压入文本 。成功返回真，失败返回假。
    .参数 str, 文本型, , 要压入的数据
    .局部变量 len, 整数型

    len ＝ 取文本长度 (str)
    .如果真 (len ＜ 1)
        返回 (假)
    .如果真结束
    EnterCriticalSection_临界许可 (临界资源) ' 进入临界
    .如果真 (Pushi ＋ 4 ＋ len ＞ Ptrlen)
        .如果真 (增量缓冲区 (len ＋ 4) ＝ 假)
            LeaveCriticalSection_临界许可 (临界资源) ' 退出临界
            返回 (假)
        .如果真结束
        
    .如果真结束
    RtlMoveMemory_Eint_int (Ptr ＋ Pushi, len, 4)
    Pushi ＝ Pushi ＋ 4
    RtlMoveMemory_Estr_int (Ptr ＋ Pushi, str, len)
    Pushi ＝ Pushi ＋ len
    Count ＝ Count ＋ 1
    LeaveCriticalSection_临界许可 (临界资源) ' 退出临界
    返回 (真)

.子程序 弹出文本, 逻辑型, 公开, 弹出文本 。成功返回真，失败返回假。
    .参数 str, 文本型, 参考, 用来接收弹出数据的变量
    .局部变量 len, 整数型

    EnterCriticalSection_临界许可 (临界资源) ' 进入临界
    .如果真 (Count ＜ 1)
        LeaveCriticalSection_临界许可 (临界资源) ' 退出临界
        返回 (假)
    .如果真结束
    .如果真 (Popi ＞ Tmplen)
        收缩缓冲区 ()
    .如果真结束
    len ＝ 0
    RtlMoveMemory_整数传址1 (len, Ptr ＋ Popi, 4)
    Popi ＝ Popi ＋ 4
    str ＝ 取空白文本 (len)
    RtlMoveMemory (取指针_文本型 (str), Ptr ＋ Popi, len)
    Popi ＝ Popi ＋ len
    Count ＝ Count － 1
    LeaveCriticalSection_临界许可 (临界资源) ' 退出临界
    返回 (真)

.子程序 压入整数, 逻辑型, 公开, 压入整数 。成功返回真，失败返回假。
    .参数 int, 整数型, , 要压入的数据

    EnterCriticalSection_临界许可 (临界资源) ' 进入临界
    .如果真 (Pushi ＋ 8 ＞ Ptrlen)
        .如果真 (增量缓冲区 (8) ＝ 假)
            LeaveCriticalSection_临界许可 (临界资源) ' 退出临界
            返回 (假)
        .如果真结束
        
    .如果真结束
    RtlMoveMemory_Eint_int (Ptr ＋ Pushi, 4, 4)
    Pushi ＝ Pushi ＋ 4
    RtlMoveMemory_Eint_int (Ptr ＋ Pushi, int, 4)
    Pushi ＝ Pushi ＋ 4
    Count ＝ Count ＋ 1
    LeaveCriticalSection_临界许可 (临界资源) ' 退出临界
    返回 (真)

.子程序 弹出整数, 逻辑型, 公开, 弹出整数 。成功返回真，失败返回假。
    .参数 int, 整数型, 参考, 用来接收弹出数据的变量

    EnterCriticalSection_临界许可 (临界资源) ' 进入临界
    .如果真 (Count ＜ 1)
        LeaveCriticalSection_临界许可 (临界资源) ' 退出临界
        返回 (假)
    .如果真结束
    .如果真 (Popi ＞ Tmplen)
        收缩缓冲区 ()
    .如果真结束
    Popi ＝ Popi ＋ 4
    RtlMoveMemory_整数传址1 (int, Ptr ＋ Popi, 4)
    Popi ＝ Popi ＋ 4
    Count ＝ Count － 1
    LeaveCriticalSection_临界许可 (临界资源) ' 退出临界
    返回 (真)

.子程序 取数量, 整数型, 公开
    返回 (Count)

.子程序 清空, , 公开
    memset (Ptr, 0, Tmplen) ' 内存清零
    Ptrlen ＝ Tmplen
    连续赋值 (0, Pushi, Popi, Count)

.版本 2

.程序集 集_信号量
.子程序 信号量_创建, 整数型, 公开, 创建一个信号量。成功返回信号量句柄，失败返回0 。
    .参数 初始数值, 整数型, 可空
    .参数 最大数值, 整数型, 可空, 如果留空 默认为1
    .参数 标识, 文本型, 可空

    返回 (CreateSemaphore (0, 初始数值, 选择 (是否为空 (最大数值) ＝ 真, 1, 最大数值), 标识))

.子程序 信号量_打开, 整数型, 公开, 打开一个信号量。成功返回信号量句柄，失败返回0 。
    .参数 标识, 文本型, 可空

    返回 (OpenSemaphore (2031619, 真, 标识))

.子程序 信号量_销毁, 逻辑型, 公开, 销毁指定信号量。
    .参数 句柄, 整数型

    .如果真 (句柄 ＝ 0)
        返回 (假)
    .如果真结束
    返回 (CloseHandle (句柄))

.子程序 信号量_增加, 逻辑型, 公开, 成功返回真，失败返回假。
    .参数 句柄, 整数型
    .参数 递增数值, 整数型, 可空, 留空为1 要增加的值，这个值必须大于0。
    .参数 返回递增前的值, 整数型, 参考 可空, 返回信号量上次的值（被增加前的值）。

    .如果真 (句柄 ＝ 0)
        返回 (假)
    .如果真结束
    .如果真 (是否为空 (递增数值) ＝ 真)
        递增数值 ＝ 1
    .如果真结束
    返回 (ReleaseSemaphore (句柄, 递增数值, 返回递增前的值))

.子程序 信号量_递减, 逻辑型, 公开, 成功返回真，失败返回假。
    .参数 句柄, 整数型
    .参数 超时值, 整数型, 可空
    .局部变量 ret, 整数型

    .如果真 (句柄 ＝ 0)
        返回 (假)
    .如果真结束
    ret ＝ WaitForSingleObject (句柄, 选择 (是否为空 (超时值) ＝ 真, -1, 超时值))
    返回 (ret ＝ 0)
    

.版本 2

.程序集 集_指针
.子程序 取指针地址_小数型, 整数型, 公开
    .参数 欲取地址的数据, 小数型, 参考

    返回 (lstrcpyn_小数型 (欲取地址的数据, 欲取地址的数据, 0))

.子程序 取指针地址_整数型, 整数型, 公开
    .参数 欲取地址的数据, 整数型, 参考

    返回 (lstrcpyn_整数型 (欲取地址的数据, 欲取地址的数据, 0))

.子程序 取指针地址_短整数型, 整数型, 公开
    .参数 欲取地址的数据, 短整数型, 参考

    返回 (lstrcpyn_短整数型 (欲取地址的数据, 欲取地址的数据, 0))

.子程序 取指针地址_长整数型, 整数型, 公开
    .参数 欲取地址的数据, 长整数型, 参考

    返回 (lstrcpyn_长整数型 (欲取地址的数据, 欲取地址的数据, 0))

.子程序 取指针地址_字节型, 整数型, 公开
    .参数 欲取地址的数据, 字节型, 参考

    返回 (lstrcpyn_字节型 (欲取地址的数据, 欲取地址的数据, 0))

.子程序 取指针地址_字节集型, 整数型, 公开
    .参数 欲取地址的数据, 字节集, 参考

    返回 (lstrcpyn_字节集 (欲取地址的数据, 欲取地址的数据, 0))

.子程序 取指针地址_文本型, 整数型, 公开
    .参数 欲取地址的数据, 文本型, 参考

    返回 (lstrcpyn_文本型 (欲取地址的数据, 欲取地址的数据, 0))

.子程序 取指针地址_子程序指针, 整数型, 公开
    .参数 欲取地址的数据, 子程序指针, 参考

    返回 (lstrcpyn_子程序指针 (欲取地址的数据, 欲取地址的数据, 0))

.子程序 指针_到整数, 整数型, 公开
    .参数 整数指针, 整数型

    置入代码 ({ 139, 69, 8, 139, 0, 201, 194, 4, 0 })
    返回 (0)

.子程序 指针_到文本, 文本型, 公开
    .参数 文本指针, 整数型
    .局部变量 长度, 整数型
    .局部变量 文本, 文本型

    长度 ＝ lstrlenA (文本指针) ＋ 1
    文本 ＝ 取空白文本 (长度)
    RtlMoveMemory (取指针_文本型 (文本), 文本指针, 长度)
    返回 (文本)

.子程序 指针_到字节集, 字节集, 公开
    .参数 字节集指针, 整数型
    .参数 数据长度, 整数型
    .局部变量 字节集, 字节集

    字节集 ＝ API_取空白字节集 (数据长度)
    RtlMoveMemory_int2Bytes (字节集, 字节集指针, 数据长度)
    返回 (字节集)

.子程序 指针_到字节集W, 字节集, 公开
    .参数 ptr, 整数型
    .局部变量 dwSize, 整数型

    .如果真 (ptr ≠ #NULL)
        dwSize ＝ lstrlenW (ptr)
        .如果真 (dwSize ＞ 0)
            返回 (指针到字节集 (ptr, dwSize × 2 ＋ 2))
        .如果真结束
        
    .如果真结束
    返回 ({ })

.子程序 指针_取低16位, 整数型, 公开, 已弃用！请使用 LOWORD
    .参数 参数, 整数型

    返回 (LOWORD (参数))

.子程序 指针_取高16位, 整数型, 公开, 已弃用！请使用 HIWORD
    .参数 参数, 整数型

    返回 (HIWORD (参数))

.子程序 指针_是否有效, 逻辑型, 公开, 判断一个子程序指针是否有效，有效返回真，否则返回假
    .参数 要判断的指针地址, 整数型

    返回 (IsBadStringPtrA (要判断的指针地址, 4) ＝ 0)

.子程序 指针_到字节型_汇编, 字节型, 公开
    .参数 指针, 整数型

    置入代码 ({ 139, 69, 8, 139, 0, 201, 194, 4, 0 })
    ' mov eax , dword ptr [ebp+08h]
    ' mov eax , dword ptr [eax]
    ' leave
    ' retn 0004h
    返回 (0)

.子程序 指针_到逻辑型_汇编, 逻辑型, 公开
    .参数 指针, 整数型

    置入代码 ({ 139, 69, 8, 139, 0, 201, 194, 4, 0 })
    ' mov eax , dword ptr [ebp+08h]
    ' mov eax , dword ptr [eax]
    ' leave
    ' retn 0004h
    返回 (假)

.子程序 指针_到短整数型_汇编, 短整数型, 公开
    .参数 指针, 整数型

    置入代码 ({ 139, 69, 8, 139, 0, 201, 194, 4, 0 })
    ' mov eax , dword ptr [ebp+08h]
    ' mov eax , dword ptr [eax]
    ' leave
    ' retn 0004h
    返回 (0)

.子程序 指针_到小数型_汇编, 小数型, 公开
    .参数 指针, 整数型
    .局部变量 Ret, 小数型

    置入代码 ({ 139, 69, 8, 139, 0, 137, 69, 252 })
    ' mov eax , dword ptr [ebp+08h]
    ' mov eax , dword ptr [eax]
    ' mov dword ptr [ebp-04h] , eax
    返回 (Ret)

.子程序 指针_到日期时间型_汇编, 日期时间型, 公开
    .参数 指针, 整数型
    .局部变量 Ret, 日期时间型

    置入代码 ({ 139, 69, 8, 255, 48, 143, 69, 248, 255, 112, 4, 143, 69, 252 })
    ' mov eax , dword ptr [ebp+08h]
    ' push dword ptr [eax]
    ' pop dword ptr [ebp-08h]
    ' push dword ptr [eax+04h]
    ' pop dword ptr [ebp-04h]
    返回 (Ret)

.子程序 指针_到双精度小数型_汇编, 双精度小数型, 公开
    .参数 指针, 整数型
    .局部变量 Ret, 双精度小数型

    置入代码 ({ 139, 69, 8, 255, 48, 143, 69, 248, 255, 112, 4, 143, 69, 252 })
    ' mov eax , dword ptr [ebp+08h]
    ' push dword ptr [eax]
    ' pop dword ptr [ebp-08h]
    ' push dword ptr [eax+04h]
    ' pop dword ptr [ebp-04h]
    返回 (Ret)

.子程序 指针_到长整数型_汇编, 长整数型, 公开
    .参数 指针, 整数型
    .局部变量 Ret, 长整数型

    置入代码 ({ 139, 69, 8, 255, 48, 143, 69, 248, 255, 112, 4, 143, 69, 252 })
    ' mov eax , dword ptr [ebp+08h]
    ' push dword ptr [eax]
    ' pop dword ptr [ebp-08h]
    ' push dword ptr [eax+04h]
    ' pop dword ptr [ebp-04h]
    返回 (Ret)

.子程序 LOWORD, 整数型, 公开, GET_X_LPARAM
    .参数 l, 整数型

    置入代码 ({ 139, 69, 8, 15, 183, 192, 201, 194, 4, 0 })
    ' mov eax, [ebp+08h]
    ' movzx eax, ax
    ' leave
    ' retn 0004h
    返回 (0)

.子程序 HIWORD, 整数型, 公开, GET_Y_LPARAM
    .参数 l, 整数型

    置入代码 ({ 139, 69, 8, 193, 232, 16, 15, 183, 192, 201, 194, 4, 0 })
    ' mov eax, [ebp+08h]
    ' shr eax, 10h
    ' movzx eax, ax
    ' leave
    ' retn 0004h
    返回 (0)

.子程序 LOBYTE, 整数型, 公开
    .参数 w, 整数型

    置入代码 ({ 139, 69, 8, 15, 182, 192, 201, 194, 4, 0 })
    ' mov eax, [ebp+08h]
    ' movzx eax, al
    ' leave
    ' retn 0004h
    返回 (0)

.子程序 HIBYTE, 整数型, 公开
    .参数 w, 整数型

    置入代码 ({ 139, 69, 8, 15, 182, 196, 201, 194, 4, 0 })
    ' mov eax, [ebp+08h]
    ' movzx eax, ah
    ' leave
    ' retn 0004h
    返回 (0)

.子程序 LOWPART, 整数型, 公开
    .参数 QuadPart, 长整数型

    置入代码 ({ 139, 69, 8, 201, 194, 8, 0 })
    ' mov eax,[ebp+8]
    ' leave
    ' ret 08
    返回 (0)

.子程序 HIGHPART, 整数型, 公开
    .参数 QuadPart, 长整数型

    置入代码 ({ 139, 69, 12, 201, 194, 8, 0 })
    ' mov eax,[ebp+12]
    ' leave
    ' ret 08
    返回 (0)

.子程序 xor64, 长整数型, 公开, 位异或
    .参数 arg1, 长整数型
    .参数 arg2, 长整数型

    置入代码 ({ 139, 69, 8, 139, 85, 12, 51, 69, 16, 51, 85, 20, 201, 194, 16, 0 })
    ' mov eax, dword ptr [ebp+08h]
    ' mov edx, dword ptr [ebp+0Ch]
    ' xor eax, dword ptr [ebp+10h]
    ' xor edx, dword ptr [ebp+14h]
    ' leave
    ' retn 0010h
    返回 (0)

.子程序 and64, 长整数型, 公开, 位与
    .参数 arg1, 长整数型
    .参数 arg2, 长整数型

    置入代码 ({ 139, 69, 8, 139, 85, 12, 35, 69, 16, 35, 85, 20, 201, 194, 16, 0 })
    ' mov eax, dword ptr [ebp+08h]
    ' mov edx, dword ptr [ebp+0Ch]
    ' and eax, dword ptr [ebp+10h]
    ' and edx, dword ptr [ebp+14h]
    ' leave
    ' retn 0010h
    返回 (0)

.子程序 or64, 长整数型, 公开, 位或
    .参数 arg1, 长整数型
    .参数 arg2, 长整数型

    置入代码 ({ 139, 69, 8, 139, 85, 12, 11, 69, 16, 11, 85, 20, 201, 194, 16, 0 })
    ' mov eax, dword ptr [ebp+08h]
    ' mov edx, dword ptr [ebp+0Ch]
    ' or eax, dword ptr [ebp+10h]
    ' or edx, dword ptr [ebp+14h]
    ' leave
    ' retn 0010h
    返回 (0)

.子程序 not64, 长整数型, 公开, 位取反
    .参数 arg1, 长整数型

    置入代码 ({ 139, 69, 8, 139, 85, 12, 247, 208, 247, 210, 201, 194, 8, 0 })
    ' mov eax, dword ptr [ebp+08h]
    ' mov edx, dword ptr [ebp+0Ch]
    ' not eax
    ' not edx
    ' leave
    ' retn 0008h
    返回 (0)

.子程序 shl64, 长整数型, 公开, 左移
    .参数 arg1, 长整数型
    .参数 arg2, 整数型

    置入代码 ({ 139, 69, 8, 139, 85, 12, 139, 77, 16, 128, 249, 64, 115, 14, 128, 249, 32, 115, 15, 15, 165, 194, 211, 224, 201, 194, 12, 0, 49, 192, 49, 210, 235, 246, 137, 194, 49, 192, 128, 225, 31, 211, 226, 235, 235 })
    ' mov eax, dword [ebp+0x08]
    ' mov edx, dword [ebp+0x0C]
    ' mov ecx, dword [ebp+0x10]
    ' cmp cl, 0x40
    ' jnc label2
    ' cmp cl, 0x20
    ' jnc label3
    ' shld edx, eax, cl
    ' shl eax, cl
    ' label1:
    ' leave
    ' retn 0x000C
    ' label2:
    ' xor eax, eax
    ' xor edx, edx
    ' jmp label1
    ' label3:
    ' mov edx, eax
    ' xor eax, eax
    ' and cl, 0x1F
    ' shl edx, cl
    ' jmp label1
    返回 (0)

.子程序 shr64, 长整数型, 公开, 右移
    .参数 arg1, 长整数型
    .参数 arg2, 整数型

    置入代码 ({ 139, 69, 8, 139, 85, 12, 139, 77, 16, 128, 249, 64, 115, 14, 128, 249, 32, 115, 16, 15, 173, 208, 211, 250, 201, 194, 12, 0, 193, 250, 31, 137, 208, 235, 245, 137, 208, 193, 250, 31, 128, 225, 31, 211, 248, 235, 233 })
    ' mov eax, dword [ebp+8]
    ' mov edx, dword [ebp+12]
    ' mov ecx, dword [ebp+16]
    ' cmp cl, 64
    ' jnc label2
    ' cmp cl, 32
    ' jnc label3
    ' shrd eax, edx, cl
    ' sar edx, cl
    ' label1:
    ' leave
    ' retn 12
    ' label2:
    ' sar edx, 31
    ' mov eax, edx
    ' jmp label1
    ' label3:
    ' mov eax, edx
    ' sar edx, 31
    ' and cl, 31
    ' sar eax, cl
    ' jmp label1
    返回 (0)

.版本 2

.程序集 集_进程线程
.程序集变量 集_许可证数组, 线程许可证, , "0"

.子程序 进程_名取句柄ex, 整数型, , 支持单个  汉族   响应时间10毫秒多  比 精易原版要快8-10倍
    .参数 进程名, 文本型
    .参数 PID, 整数型, 可空, 为了更加精准定位每个不同进程句柄   必须和 进程对应
    .局部变量 window, 精易_窗口信息, , "0"
    .局部变量 pcs, 整数型
    .局部变量 a, 整数型
    .局部变量 jcmz, 文本型, , "0"
    .局部变量 pidz, 整数型, , "0"
    .局部变量 hwnd, 整数型
    .局部变量 tp, 整数型

    ' 该例程收录自： https://bbs.125.la/forum.php?mod=viewthread&tid=14284196
    pcs ＝ 进程_枚举 (jcmz, pidz)
    .计次循环首 (pcs, a)
        .如果真 (进程名 ＝ jcmz [a]) ' 存在多个进程 这个 就得自己判断了  比如枚举进程数组判断  这是单处理子程序
            tp ＝ pidz [a]
            .如果真 (是否为空 (PID) ≠ 真) ' 表示纯在值
                .如果真 (PID ＝ pidz [a])
                    tp ＝ pidz [a]
                    跳出循环 ()
                .如果真结束
                
            .如果真结束
            
        .如果真结束
        处理事件 ()
    .计次循环尾 ()
    pcs ＝ 窗口_枚举 (window)
    .计次循环首 (pcs, a)
        .如果真 (window [a].进程ID ＝ tp)
            hwnd ＝ 窗口_取祖句柄 (window [a].窗口句柄)
            跳出循环 ()
        .如果真结束
        处理事件 ()
    .计次循环尾 ()
    返回 (hwnd)

.子程序 进程_禁止被打开, 逻辑型, 公开
    .局部变量 pAcl, 字节集

    ' 该例程收录自： https://bbs.125.la/thread-14194970-1-1.html
    pAcl ＝ 取空白字节集 (512)
    .如果真 (InitializeAcl (pAcl, 1024, 2) ＝ 假)
        返回 (假)
    .如果真结束
    .如果真 (SetSecurityInfo (-1, 6, 2147483652, 0, 0, pAcl, 0) ≠ 0)
        返回 (假)
    .如果真结束
    返回 (真)
    
    

.子程序 进程_强力结束进程, 逻辑型, 公开, 强制结束进程。
    .参数 hProcess, 整数型, , 进程句柄
    .参数 ExitStatus, 整数型, , 填0
    .局部变量 st, 整数型
    .局部变量 hJob, 整数型
    .局部变量 oa, OBJECT_ATTRIBUTES
    .局部变量 ret, 逻辑型

    ret ＝ 假
    oa.Length ＝ 24
    st ＝ ZwCreateJobObject (hJob, #JOB_OBJECT_ALL_ACCESS, oa)
    .如果真 (st ≥ 0)
        st ＝ ZwAssignProcessToJobObject (hJob, hProcess)
        .如果真 (st ≥ 0)
            st ＝ ZwTerminateJobObject (hJob, ExitStatus)
            .如果真 (st ≥ 0)
                ret ＝ 真
            .如果真结束
            
        .如果真结束
        ZwClose (hJob)
    .如果真结束
    .如果真 (ret ＝ 假)
        st ＝ ZwTerminateProcess (hProcess, ExitStatus)
        .如果真 (st ≥ 0)
            ret ＝ 真
        .如果真结束
        
    .如果真结束
    返回 (ret)

.子程序 进程_强力打开进程, 整数型, 公开, 和OpenProcess的函数填法相似
    .参数 dwDesiredAccess, 整数型
    .参数 bInhert, 逻辑型
    .参数 ProcessId, 整数型
    .局部变量 st, 整数型
    .局部变量 cid, CLIENT_ID
    .局部变量 oa, OBJECT_ATTRIBUTES
    .局部变量 NumOfHandle, 整数型
    .局部变量 pbi, PROCESS_BASIC_INFORMATION
    .局部变量 i, 整数型
    .局部变量 hProcessToDup, 整数型
    .局部变量 hProcessCur, 整数型
    .局部变量 hProcessToRet, 整数型
    .局部变量 h_info, SYSTEM_HANDLE_TABLE_ENTRY_INFO
    .局部变量 retlen, 整数型
    .局部变量 a, 字节集
    .局部变量 b, 整数型
    .局部变量 c, 字节集
    .局部变量 ret, 整数型

    oa.Length ＝ 24
    .如果真 (bInhert)
        oa.Attributes ＝ 位或 (oa.Attributes, #OBJ_INHERIT)
    .如果真结束
    cid.UniqueProcess ＝ ProcessId ＋ 1
    st ＝ ZwOpenProcess (hProcessToRet, dwDesiredAccess, oa, cid)
    .如果真 (st ≥ 0)
        ret ＝ hProcessToRet
        返回 (ret)
    .如果真结束
    retlen ＝ 1
    .循环判断首 ()
        a ＝ 取空白字节集 (retlen)
        ret ＝ ZwQuerySystemInformation_x (16, a, retlen, 0)
        
        .如果 (ret ＝ #STATUS_INFO_LENGTH_MISMATCH)
            retlen ＝ retlen × 2
            a ＝ 取空白字节集 (retlen)
        .否则
            跳出循环 ()
        .如果结束
        
    .循环判断尾 (ret ＝ #STATUS_INFO_LENGTH_MISMATCH)
    b ＝ 取指针_字节集 (a, a, 0)
    RtlMoveMemory_整数传址1 (NumOfHandle, b, 4)
    b ＝ b ＋ 4
    .计次循环首 (NumOfHandle, i)
        RtlMoveMemory_SYSTEM_HANDLE_TABLE_ENTRY_INFO (h_info, b, 16)
        .如果真 (h_info.ObjectTypeIndex ＝ #OB_TYPE_PROCESS)
            cid.UniqueProcess ＝ h_info.UniqueProcessId
            st ＝ ZwOpenProcess (hProcessToDup, #PROCESS_DUP_HANDLE, oa, cid)
            .如果真 (st ≥ 0)
                st ＝ ZwDuplicateObject (hProcessToDup, h_info.HandleValue, #ZwGetCurrentProcess, hProcessCur, #PROCESS_ALL_ACCESS, 0, #DUPLICATE_SAME_ATTRIBUTES)
                .如果真 (st ≥ 0)
                    st ＝ ZwQueryInformationProcess (hProcessCur, 0, pbi, 24, 0)
                    .如果真 (st ≥ 0)
                        .如果真 (pbi.UniqueProcessId ＝ ProcessId)
                            st ＝ ZwDuplicateObject (hProcessToDup, h_info.HandleValue, #ZwGetCurrentProcess, hProcessToRet, dwDesiredAccess, #OBJ_INHERIT, #DUPLICATE_SAME_ATTRIBUTES)
                            .如果真 (st ≥ 0)
                                ret ＝ hProcessToRet
                            .如果真结束
                            
                        .如果真结束
                        
                    .如果真结束
                    
                .如果真结束
                st ＝ ZwClose (hProcessCur)
            .如果真结束
            st ＝ ZwClose (hProcessToDup)
        .如果真结束
        b ＝ b ＋ 16
    .计次循环尾 ()
    返回 (ret)

.子程序 进程_PID取路径, 文本型, 公开, 解决了一个句柄泄漏问题
    .参数 PID, 整数型, , 进程ID
    .局部变量 handle, 整数型
    .局部变量 a, 文本型
    .局部变量 buf, 文本型

    handle ＝ OpenProcess (1024, 0, PID)
    .如果真 (handle ＝ 0)
        handle ＝ 进程_强力打开进程 (1024, 假, PID)
    .如果真结束
    buf ＝ 取空白文本 (512)
    .如果真 (GetProcessImageFileNameA (handle, buf, 512) ＝ 0)
        返回 (“”)
    .如果真结束
    CloseHandle (handle)
    buf ＝ DOS路径转换_ (buf)
    buf ＝ 删首尾空 (buf)
    .如果 (buf ＝ “”)
        返回 (“-”)
    .否则
        a ＝ buf
        a ＝ 子文本替换 (a, “\Device\HarddiskVolume6”, “H:”, , 1, 假)
        a ＝ 子文本替换 (a, “\Device\HarddiskVolume5”, “G:”, , 1, 假)
        a ＝ 子文本替换 (a, “\Device\HarddiskVolume4”, “F:”, , 1, 假)
        a ＝ 子文本替换 (a, “\Device\HarddiskVolume3”, “E:”, , 1, 假)
        a ＝ 子文本替换 (a, “\Device\HarddiskVolume2”, “D:”, , 1, 假)
        a ＝ 子文本替换 (a, “\Device\HarddiskVolume1”, “C:”, , 1, 假)
        返回 (a)
    .如果结束
    

.子程序 DOS路径转换_, 文本型
    .参数 txt, 文本型
    .局部变量 buf_, 文本型
    .局部变量 buf, 字节集
    .局部变量 size, 整数型
    .局部变量 数组, 字节集, , "0"
    .局部变量 驱动器数目, 整数型
    .局部变量 n, 整数型
    .局部变量 逻辑驱动器, 文本型, , "0"
    .局部变量 DOS设备, 文本型, , "0"
    .局部变量 局_数据, 文本型

    size ＝ GetLogicalDriveStringsA (0, { })
    buf ＝ 取空白字节集 (size)
    GetLogicalDriveStringsA (size, buf) ' 获取逻辑驱动器文本
    数组 ＝ 分割字节集 (buf, { 0 }, )
    驱动器数目 ＝ 取数组成员数 (数组) － 1
    .如果真 (驱动器数目 ＞ 0)
        重定义数组 (逻辑驱动器, 假, 驱动器数目)
        重定义数组 (DOS设备, 假, 驱动器数目)
        .计次循环首 (驱动器数目, n)
            buf ＝ 数组 [n]
            buf [取字节集长度 (buf)] ＝ 0
            逻辑驱动器 [n] ＝ 到文本 (buf)
            
            buf_ ＝ 取空白文本 (260)
            QueryDosDeviceA (逻辑驱动器 [n], buf_, 260)
            DOS设备 [n] ＝ buf_
            
            .如果真 (txt ≈ DOS设备 [n] ＋ “\”)
                返回 (子文本替换 (txt, DOS设备 [n], 逻辑驱动器 [n], 1, 1, 真))
            .如果真结束
            
        .计次循环尾 ()
    .如果真结束
    返回 (txt)

.子程序 进程_定位, 逻辑型, 公开, 通过进程PID定位进程
    .参数 PID, 整数型

    返回 (文件_定位W (进程_取路径W (PID), ))

.子程序 进程_内存使用, 双精度小数型, 公开, 查看指定进程ID的内存使用情况
    .参数 PID, 整数型
    .参数 返回单位, 整数型, 可空, 0=Byte，1=KB，2=MB，3=GB，默认为1
    .局部变量 hProcess, 整数型
    .局部变量 hModule, 整数型
    .局部变量 pfnAddress, 整数型
    .局部变量 dwSize, 整数型
    .局部变量 pMemInfo, 整数型
    .局部变量 nWorkingSize, 整数型

    .如果真 (是否为空 (返回单位) 或 返回单位 ＜ 0)
        返回单位 ＝ 1 ' KB
    .如果真结束
    hProcess ＝ OpenProcess (位或 (#PROCESS_QUERY_INFORMATION, #PROCESS_VM_READ), 0, PID)
    .如果真 (hProcess ≠ #NULL)
        dwSize ＝ 40 ' sizeof(PROCESS_MEMORY_COUNTERS)
        pMemInfo ＝ HeapAlloc (GetProcessHeap (), #HEAP_ZERO_MEMORY, dwSize)
        .如果真 (pMemInfo ≠ #NULL)
            .如果 (_WIN32_WINNT ≥ #_WIN32_WINNT_WIN7)
                hModule ＝ GetModuleHandleA (“Kernel32.dll”)
                .如果真 (hModule ≠ #NULL)
                    pfnAddress ＝ GetProcAddress (hModule, “K32GetProcessMemoryInfo”)
                    .如果真 (pfnAddress ≠ #NULL)
                        调用子程序_ (pfnAddress, hProcess, pMemInfo, dwSize, , , , , , , , , , , , )
                    .如果真结束
                    
                .如果真结束
                
            .否则
                GetProcessMemoryInfo (hProcess, pMemInfo, dwSize)
            .如果结束
            nWorkingSize ＝ __get (pMemInfo, 12) ' WorkingSetSize
            HeapFree (GetProcessHeap (), 0, pMemInfo)
        .如果真结束
        CloseHandle (hProcess)
        返回 (整数_有符号转无符号 (nWorkingSize) ÷ 求次方 (1024, 返回单位))
    .如果真结束
    返回 (0)

.子程序 进程_取命令行32, 文本型, 公开, 取指定进程ID的命令行.32位系统专用
    .参数 进程ID, 整数型
    .局部变量 进程句柄
    .局部变量 info, PROCESS_BASIC_INFORMATION
    .局部变量 a, 整数型
    .局部变量 b
    .局部变量 c, MEMORY_BASIC_INFORMATION
    .局部变量 buffer, 字节集
    .局部变量 len, 整数型

    RtlAdjustPrivilege (#SeDebugPrivilege, 1, 0, #NULL)
    进程句柄 ＝ OpenProcess (1024 ＋ 16, 0, 进程ID)
    ZwQueryInformationProcess (进程句柄, 0, info, 24, 0)
    buffer ＝ 取空白字节集 (4)
    ' [[peb+10h]+28h]进程运行目录,[[peb+10h]+3ch]进程路径,[[peb+10h]+44h]命令行
    NtReadVirtualMemory_Bin (进程句柄, info.PebBaseAddress ＋ 16, buffer, 4, 0)
    a ＝ 取字节集数据 (buffer, 3, )
    NtReadVirtualMemory_Bin (进程句柄, a ＋ 68, buffer, 4, 0) ' 68命令行, 60路径, 40运行目录
    b ＝ 取字节集数据 (buffer, 3, )
    VirtualQueryEx32 (进程句柄, b, c, 28)
    len ＝ c.RegionSize ＋ c.BaseAddress － b
    buffer ＝ 取空白字节集 (len)
    NtReadVirtualMemory_Bin (进程句柄, b, buffer, len, 0)
    CloseHandle (进程句柄)
    返回 (编码_Unicode到Ansi (buffer))

.子程序 进程_取用户名, 文本型, 公开, 获取指定进程的用户名
    .参数 进程PID, 整数型
    .局部变量 dwSize, 整数型
    .局部变量 pBuf, 整数型
    .局部变量 lRetVal, 整数型
    .局部变量 pCurBuf, 整数型
    .局部变量 dwProcessId, 整数型
    .局部变量 dwNextEntryOffset, 整数型
    .局部变量 qCreateTime, 长整数型
    .局部变量 pSid, 字节集
    .局部变量 szUserName, 文本型
    .局部变量 dwDomainName, 整数型
    .局部变量 szDomainName, 文本型

    NtQuerySystemInformation (#SystemProcessInformation, #NULL, 0, dwSize)
    .如果真 (dwSize ＝ 0)
        返回 (“”)
    .如果真结束
    pBuf ＝ LocalAlloc (#LMEM_ZEROINIT, dwSize)
    lRetVal ＝ NtQuerySystemInformation (#SystemProcessInformation, pBuf, dwSize, #NULL)
    .如果真 (lRetVal ≠ 0)
        LocalFree (pBuf)
        输出调试文本 (取错误信息文本_API (lRetVal, “Ntdll.dll”))
        返回 (“”)
    .如果真结束
    pCurBuf ＝ pBuf
    dwProcessId ＝ 指针_到整数 (pCurBuf ＋ 68)
    .判断循环首 (dwProcessId ≠ 进程PID)
        dwNextEntryOffset ＝ 指针_到整数 (pCurBuf)
        .如果真 (dwNextEntryOffset ＝ #NULL)
            跳出循环 ()
        .如果真结束
        pCurBuf ＝ pCurBuf ＋ dwNextEntryOffset
        dwProcessId ＝ 指针_到整数 (pCurBuf ＋ 68)
    .判断循环尾 ()
    .如果真 (dwProcessId ＝ 进程PID)
        qCreateTime ＝ 指针_到长整数型_汇编 (pCurBuf ＋ 32)
        dwSize ＝ 0
        WinStationGetProcessSid (#NULL, dwProcessId, qCreateTime, #NULL, dwSize)
        pSid ＝ 取空白字节集 (dwSize)
        .如果真 (WinStationGetProcessSid (#NULL, dwProcessId, qCreateTime, 取指针_字节集型 (pSid), dwSize) ＝ #NULL)
            LocalFree (pBuf)
            返回 (“服务关闭”)
        .如果真结束
        dwSize ＝ 0
        LookupAccountSidA (#NULL, 取指针_字节集型 (pSid), #NULL, dwSize, #NULL, dwDomainName, #NULL)
        szUserName ＝ 取空白文本 (dwSize)
        szDomainName ＝ 取空白文本 (dwDomainName)
        .如果真 (LookupAccountSidA (#NULL, 取指针_字节集型 (pSid), 取指针_文本型 (szUserName), dwSize, 取指针_文本型 (szDomainName), dwDomainName, #NULL))
            LocalFree (pBuf)
            返回 (szUserName)
        .如果真结束
        
    .如果真结束
    LocalFree (pBuf)
    返回 (“”)

.子程序 进程_取命令行, 文本型, 公开, 取指定进程ID的命令行.64位系统专用
    .参数 PID, 整数型
    .局部变量 pbi, PROCESS_BASIC_INFORMATION64
    .局部变量 Ldr, PEB_LDR_DATA
    .局部变量 RTL, RTL_USER_PROCESS_PARAMETERS
    .局部变量 局_缓冲区, 字节集
    .局部变量 hSnapShot, 整数型
    .局部变量 mod, LPMODULEENTRY32
    .局部变量 Process, 整数型
    .局部变量 局_命令行, 文本型

    RtlAdjustPrivilege (#SeDebugPrivilege, 1, 0, #NULL)
    Process ＝ OpenProcess (1040, 0, PID)
    .如果真 (Process ≠ 0)
        .如果真 (NtWow64QueryInformationProcess64_Basic (Process, 0, pbi, 48, 0) ＝ 0)
            .如果真 (NtWow64ReadVirtualMemory64_LDR (Process, pbi.PebBaseAddress, Ldr, 40, 0) ＝ 0)
                .如果真 (NtWow64ReadVirtualMemory64_Process (Process, Ldr.ProcessParameters ＋ 96, RTL, 32, 0) ＝ 0)
                    .如果真 (RTL.CommandLine.Buffer ＞ 0)
                        局_缓冲区 ＝ 取空白字节集 (RTL.CommandLine.Length)
                        NtWow64ReadVirtualMemory64_bin (Process, RTL.CommandLine.Buffer, 局_缓冲区, RTL.CommandLine.Length, 0)
                        局_命令行 ＝ 编码_Unicode到Ansi (局_缓冲区)
                    .如果真结束
                    
                .如果真结束
                
            .如果真结束
            
        .如果真结束
        
    .如果真结束
    CloseHandle (Process)
    返回 (局_命令行)

.子程序 进程_取命令行W, 字节集, 公开, 取指定进程pid的命令行
    .参数 pid, 整数型
    .局部变量 hProcess, 整数型
    .局部变量 lRes, 逻辑型
    .局部变量 isWow64, 逻辑型
    .局部变量 hHeap, 整数型
    .局部变量 arg1, 整数型, , , PROCESS_BASIC_INFORMATION
    .局部变量 arg2, 整数型, , , PEB
    .局部变量 arg3, 整数型, , , RTL_USER_PROCESS_PARAMETERS
    .局部变量 szCmdLine, 字节集

    hProcess ＝ OpenProcess (位或 (#PROCESS_QUERY_LIMITED_INFORMATION, #PROCESS_VM_READ), 0, pid)
    .如果真 (hProcess ≠ #NULL)
        lRes ＝ IsWow64Process (hProcess, isWow64) 且 isWow64 ＝ 假
        hHeap ＝ GetProcessHeap ()
        arg1 ＝ HeapAlloc (hHeap, #HEAP_ZERO_MEMORY, 选择 (lRes, 48, 24))
        .如果真 (arg1 ≠ #NULL)
            .如果 (lRes)
                .如果真 (NtWow64QueryInformationProcess64 (hProcess, #ProcessBasicInformation, arg1, 48, #NULL) ＝ #ERROR_SUCCESS)
                    arg2 ＝ HeapAlloc (hHeap, #HEAP_ZERO_MEMORY, 8)
                    .如果真 (arg2 ≠ #NULL)
                        .如果真 (NtWow64ReadVirtualMemory64 (hProcess, __get_int64 (arg1, 8) ＋ 32, arg2, 8, #NULL) ＝ #ERROR_SUCCESS)
                            arg3 ＝ HeapAlloc (hHeap, #HEAP_ZERO_MEMORY, 16)
                            .如果真 (arg3 ≠ #NULL)
                                .如果真 (NtWow64ReadVirtualMemory64 (hProcess, __get_int64 (arg2, 0) ＋ 112, arg3, 16, #NULL) ＝ #ERROR_SUCCESS)
                                    szCmdLine ＝ 取空白字节集 (__get_short (arg3, 2))
                                    NtWow64ReadVirtualMemory64 (hProcess, __get_int64 (arg3, 8), 取指针字节集_ (szCmdLine), __get_short (arg3, 2), #NULL)
                                .如果真结束
                                HeapFree (hHeap, 0, arg3)
                            .如果真结束
                            
                        .如果真结束
                        HeapFree (hHeap, 0, arg2)
                    .如果真结束
                    
                .如果真结束
                
            .否则
                
                .如果真 (NtQueryInformationProcess (hProcess, #ProcessBasicInformation, arg1, 24, #NULL) ＝ #ERROR_SUCCESS)
                    .如果真 (NtReadVirtualMemory (hProcess, __get (arg1, 4) ＋ 16, 取指针整数_ (arg2), 4, #NULL) ＝ #ERROR_SUCCESS)
                        arg3 ＝ HeapAlloc (hHeap, #HEAP_ZERO_MEMORY, 8)
                        .如果真 (arg3 ≠ #NULL)
                            .如果真 (NtReadVirtualMemory (hProcess, arg2 ＋ 64, arg3, 8, #NULL) ＝ #ERROR_SUCCESS)
                                szCmdLine ＝ 取空白字节集 (__get_short (arg3, 2))
                                NtReadVirtualMemory (hProcess, __get_int64 (arg3, 4), 取指针字节集_ (szCmdLine), __get_short (arg3, 2), #NULL)
                            .如果真结束
                            HeapFree (hHeap, 0, arg3)
                        .如果真结束
                        
                    .如果真结束
                    
                .如果真结束
                
            .如果结束
            HeapFree (hHeap, 0, arg1)
        .如果真结束
        CloseHandle (hProcess)
    .如果真结束
    返回 (szCmdLine)

.子程序 进程_是否被挂起, 逻辑型, 公开, 检测进程是否被暂停，亦可用于窗口是否假死
    .参数 进程PID, 整数型
    .参数 超时时间, 整数型, 可空, 检测窗口的响应时间，超时则为假死，单位：毫秒；可空，默认100毫秒
    .局部变量 返回值, 整数型
    .局部变量 结果, 整数型

    .如果真 (是否为空 (超时时间))
        超时时间 ＝ 100
    .如果真结束
    结果 ＝ 进程_ID取窗口句柄EX (进程PID)
    .如果真 (结果 ＝ 0)
        返回 (假)
    .如果真结束
    返回值 ＝ lms520_SendMessageTimeout (结果, #WM_GETTEXTLENGTH, 0, 0, #SMTO_NORMAL, 超时时间, 0)
    .判断开始 (返回值 ＝ 1)
        返回 (假)
    .默认
        返回 (真)
    .判断结束
    

.子程序 进程_是否被挂起1, 逻辑型, 公开, 检查进程的主线程状态是否为暂停。
    .参数 pid, 整数型
    .局部变量 lRes, 整数型
    .局部变量 uByteLen, 整数型
    .局部变量 pszMem, 整数型
    .局部变量 pProcessInfo, 整数型
    .局部变量 dwProcessId, 整数型
    .局部变量 dwWaitReason, 整数型
    .局部变量 uNextEntryDelta, 整数型

    lRes ＝ NtQuerySystemInformation (#SystemProcessInformation, #NULL, 0, uByteLen)
    pszMem ＝ LocalAlloc (#LMEM_ZEROINIT, uByteLen)
    lRes ＝ NtQuerySystemInformation (#SystemProcessInformation, pszMem, uByteLen, uByteLen)
    .如果真 (lRes ≠ #ERROR_SUCCESS)
        输出调试文本 (取错误信息文本_API (lRes, ))
        LocalFree (pszMem)
        返回 (假)
    .如果真结束
    pProcessInfo ＝ pszMem
    .循环判断首 ()
        pProcessInfo ＝ pProcessInfo ＋ uNextEntryDelta
        dwProcessId ＝ __get (pProcessInfo, 68) ' SYSTEM_PROCESSES => ProcessId
        .如果真 (dwProcessId ＝ pid)
            dwWaitReason ＝ __get (pProcessInfo, 240) ' SYSTEM_PROCESSES => Threads->WaitReason
            跳出循环 ()
        .如果真结束
        uNextEntryDelta ＝ __get (pProcessInfo, 0) ' SYSTEM_PROCESSES => NextEntryDelta
    .循环判断尾 (uNextEntryDelta ≠ 0)
    LocalFree (pszMem)
    返回 (dwWaitReason ＝ 5) ' Suspended

.子程序 进程_取程序路径, 文本型, 公开, 取指定进程的程序路径，成功返回程序路径，失败或进程不存在返回空文本
    .参数 进程ID, 整数型
    .局部变量 快照句柄, 整数型
    .局部变量 模块信息, 精易_模块信息
    .局部变量 路径, 文本型

    快照句柄 ＝ CreateToolhelp32Snapshot (8, 进程ID)
    .判断开始 (进程ID ＝ 4)
        CloseHandle (快照句柄)
        返回 (目录_取system32目录 ())
    .判断 (快照句柄 ＝ #INVALID_HANDLE_VALUE)
        返回 (进程_取路径 (进程ID))
    .默认
        
    .判断结束
    模块信息.size ＝ 1024
    ' Module32First 取到的路径存在大小写不符的问题，介意慎用！
    Module32First (快照句柄, 模块信息)
    路径 ＝ 到文本 (模块信息.模块完整路径)
    .判断开始 (取文本左边 (路径, 11) ＝ “\SystemRoot”)
        路径 ＝ 读环境变量 (“SystemRoot”) ＋ 子文本替换 (路径, “\SystemRoot”, “”, , 1, 假)
    .判断 (取文本左边 (路径, 4) ＝ “\??\”)
        路径 ＝ 子文本替换 (路径, “\??\”, “”, , 1, 假)
    .默认
        
    .判断结束
    CloseHandle (快照句柄)
    返回 (路径)

.子程序 进程_取路径, 文本型, 公开, 成功返回路径,失败返回空文本
    .参数 PID, 整数型, 可空

    返回 (编码_Unicode到Ansi (进程_取路径W (PID)))

.子程序 进程_取路径W, 字节集, 公开, 成功返回Unicode路径,失败返回空字节集
    .参数 ProcessID, 整数型, 可空
    .局部变量 hProcess, 整数型
    .局部变量 szPath, 字节集
    .局部变量 lRes, 整数型
    .局部变量 ulSize, 整数型
    .局部变量 pMem, 整数型
    .局部变量 nMaxCount, 短整数型
    .局部变量 pszBuf, 整数型

    .如果 (ProcessID ＝ 0)
        hProcess ＝ GetCurrentProcess ()
    .否则
        RtlAdjustPrivilege (#SeDebugPrivilege, 1, 0, #NULL) ' 启用特权
        hProcess ＝ OpenProcess (#PROCESS_QUERY_INFORMATION, 0, ProcessID)
        .如果真 (hProcess ＝ #NULL)
            返回 ({ })
        .如果真结束
        RtlAdjustPrivilege (#SeDebugPrivilege, 0, 0, #NULL) ' 禁用特权
    .如果结束
    lRes ＝ NtQueryInformationProcess (hProcess, #ProcessImageFileName, #NULL, 0, ulSize)
    .如果 (lRes ＝ #STATUS_INFO_LENGTH_MISMATCH)
        pMem ＝ HeapAlloc (GetProcessHeap (), #HEAP_ZERO_MEMORY, ulSize) ' UNICODE_STRING
        .如果真 (pMem ≠ #NULL)
            lRes ＝ NtQueryInformationProcess (hProcess, #ProcessImageFileName, pMem, ulSize, ulSize)
            .如果真 (lRes ＝ #STATUS_SUCCESS)
                nMaxCount ＝ __get_short (pMem, 2)
                pszBuf ＝ __get (pMem, 4)
                .如果真 (nMaxCount ＞ 0 且 pszBuf ≠ #NULL)
                    szPath ＝ 指针到字节集 (pszBuf, nMaxCount)
                .如果真结束
                
            .如果真结束
            HeapFree (GetProcessHeap (), 0, pMem)
        .如果真结束
        
    .否则
        输出调试文本 (取错误信息文本_API (lRes, “ntdll.dll”))
    .如果结束
    CloseHandle (hProcess)
    返回 (DosToLogicalDrive (szPath))

.子程序 进程_暂停, , 公开, 将指定进程暂停(无返回值)
    .参数 进程ID, 整数型, , 欲被暂停进程的进程ID
    .参数 状态, 逻辑型, 可空, 可空为假:恢复进程   真:暂停进程
    .局部变量 hProcess, 整数型

    hProcess ＝ OpenProcess (#PROCESS_ALL_ACCESS, 0, 进程ID)
    .如果 (状态)
        ZwSuspendProcess (hProcess)
    .否则
        ZwResumeProcess (hProcess)
    .如果结束
    CloseHandle (hProcess)

.子程序 进程_结束, 逻辑型, 公开, 结束指定进程。成功返回真，失败返回假。本命令为初级命令
    .参数 进程ID, 整数型, 可空, 如果为空或为0将结束自己
    .局部变量 hProcess, 整数型
    .局部变量 bRet, 逻辑型

    .如果 (进程ID ＝ 0)
        hProcess ＝ GetCurrentProcess ()
    .否则
        hProcess ＝ OpenProcess (#PROCESS_TERMINATE, 0, 进程ID)
    .如果结束
    .如果真 (hProcess ＝ #NULL)
        返回 (假)
    .如果真结束
    bRet ＝ TerminateProcess (hProcess, 0)
    CloseHandle (hProcess)
    返回 (bRet)

.子程序 进程_结束1, 逻辑型, 公开, 结束指定进程。成功返回真，失败返回假。本命令为初级命令
    .参数 进程名, 文本型, 可空, 欲结束的进程名,如果为空将结束自己
    .参数 是否区分大小写, 逻辑型, 可空, 默认为不区分,真=区分
    .局部变量 dwProcessId, 整数型

    dwProcessId ＝ 进程_名取ID (进程名, 是否区分大小写)
    .如果真 (dwProcessId ＝ 0)
        返回 (假)
    .如果真结束
    返回 (进程_结束 (dwProcessId))

.子程序 进程_枚举, 整数型, 公开, 失败返回0，成功返回进程数量
    .参数 进程名数组, 文本型, 参考 可空 数组, 返回的进程名 数组
    .参数 进程ID数组, 整数型, 参考 可空 数组, 返回的进程ID 数组
    .局部变量 信息, 精易_进程信息列表
    .局部变量 进程快照, 整数型
    .局部变量 是否存在, 整数型

    进程快照 ＝ CreateToolhelp32Snapshot (#TH32CS_SNAPALL, 0)
    .如果真 (进程快照 ＝ #INVALID_HANDLE_VALUE)
        返回 (0)
    .如果真结束
    清除数组 (进程名数组)
    清除数组 (进程ID数组)
    信息.dwSize ＝ 296 ' sizeof(PROCESSENTRY32)
    是否存在 ＝ Process32First (进程快照, 信息)
    .判断开始 (是否为空 (进程名数组) ＝ 假 且 是否为空 (进程ID数组) ＝ 假)
        .判断循环首 (是否存在 ≠ 0)
            加入成员 (进程名数组, 到文本 (信息.进程名称))
            加入成员 (进程ID数组, 信息.进程ID)
            是否存在 ＝ Process32Next (进程快照, 信息)
        .判断循环尾 ()
    .判断 (是否为空 (进程名数组) ＝ 假)
        .判断循环首 (是否存在 ≠ 0)
            加入成员 (进程名数组, 到文本 (信息.进程名称))
            是否存在 ＝ Process32Next (进程快照, 信息)
        .判断循环尾 ()
    .默认
        .判断循环首 (是否存在 ≠ 0)
            加入成员 (进程ID数组, 信息.进程ID)
            是否存在 ＝ Process32Next (进程快照, 信息)
        .判断循环尾 ()
        CloseHandle (进程快照)
        返回 (取数组成员数 (进程ID数组))
    .判断结束
    CloseHandle (进程快照)
    返回 (取数组成员数 (进程名数组))

.子程序 进程_取系统进程列表, 整数型, 公开, 失败返回0，成功返回进程数量
    .参数 进程信息数组, 精易_进程信息数组, 参考 数组
    .局部变量 pSystemProc, SYSTEM_PROCESSES
    .局部变量 ret, 整数型
    .局部变量 buffer, 整数型
    .局部变量 retLen, 整数型
    .局部变量 Str, 整数型
    .局部变量 进程信息, 精易_进程信息数组
    .局部变量 memaddr, 整数型

    清除数组 (进程信息数组)
    ret ＝ NtQuerySystemInformation (5, buffer, 0, retLen)
    memaddr ＝ LocalAlloc (64, retLen)
    buffer ＝ memaddr
    ret ＝ NtQuerySystemInformation (5, buffer, retLen, 0)
    .如果真 (ret ＝ 0)
        Str ＝ LocalAlloc (64, 512)
        CopyMemory_SYSTEM_PROCESSES (pSystemProc, buffer, 248)
        .判断循环首 (pSystemProc.NextEntryDelta ≠ 0)
            WideCharToMultiByte (936, 512, pSystemProc.ProcessName.缓冲区, -1, Str, pSystemProc.ProcessName.长度, 0, 0)
            进程信息.进程名称 ＝ 选择 (pSystemProc.ProcessName.缓冲区 ＝ 0, “System Idle Process”, 指针到文本 (Str))
            进程信息.进程标识符 ＝ pSystemProc.ProcessID
            进程信息.进程模块标识符 ＝ 0
            进程信息.父进程标识符 ＝ pSystemProc.InheritedFromProcessId
            进程信息.线程优先权 ＝ pSystemProc.BasePriority
            进程信息.线程数 ＝ pSystemProc.ThreadCount
            加入成员 (进程信息数组, 进程信息)
            buffer ＝ buffer ＋ pSystemProc.NextEntryDelta
            CopyMemory_SYSTEM_PROCESSES (pSystemProc, buffer, 248)
        .判断循环尾 ()
        WideCharToMultiByte (936, 512, pSystemProc.ProcessName.缓冲区, -1, Str, pSystemProc.ProcessName.长度, 0, 0)
        进程信息.进程名称 ＝ 选择 (pSystemProc.ProcessName.缓冲区 ＝ 0, “System Idle Process”, 指针到文本 (Str))
        进程信息.进程标识符 ＝ pSystemProc.ProcessID
        进程信息.进程模块标识符 ＝ 0
        进程信息.父进程标识符 ＝ pSystemProc.InheritedFromProcessId
        进程信息.线程优先权 ＝ pSystemProc.BasePriority
        进程信息.线程数 ＝ pSystemProc.ThreadCount
        加入成员 (进程信息数组, 进程信息)
        LocalFree (Str)
    .如果真结束
    LocalFree (memaddr)
    返回 (取数组成员数 (进程信息数组))

.子程序 进程_取同名ID, 整数型, 公开, 取相同名称进程，成功返回数量；失败返回-1
    .参数 进程名, 文本型
    .参数 进程ID数组, 整数型, 可空 数组, 返回进程ID的数组
    .参数 区分大小写, 逻辑型, 可空, 默认不区分进程名大小写

    返回 (进程_取同名IDW (编码_Ansi到Unicode (进程名, ), 进程ID数组, 区分大小写))

.子程序 进程_取同名IDW, 整数型, 公开, 取相同名称进程，成功返回数量；失败返回-1
    .参数 进程名, 字节集
    .参数 进程ID数组, 整数型, 可空 数组, 返回进程ID的数组
    .参数 区分大小写, 逻辑型, 可空, 默认不区分进程名大小写
    .局部变量 hSnapshot, 整数型
    .局部变量 pe32, PROCESSENTRY32W
    .局部变量 bRet, 逻辑型

    清除数组 (进程ID数组)
    hSnapshot ＝ CreateToolhelp32Snapshot (#TH32CS_SNAPALL, 0)
    .如果真 (hSnapshot ＝ #INVALID_HANDLE_VALUE)
        返回 (#INVALID_HANDLE_VALUE)
    .如果真结束
    pe32.dwSize ＝ 556
    bRet ＝ Process32FirstW (hSnapshot, pe32)
    .判断循环首 (bRet)
        .如果真 (文本_文本比较W (取数据_通用型_数组 (pe32.szExeFile), 取指针_字节集型 (进程名), 区分大小写) ＝ 0)
            加入成员 (进程ID数组, pe32.th32ProcessID)
        .如果真结束
        bRet ＝ Process32NextW (hSnapshot, pe32)
    .判断循环尾 ()
    CloseHandle (hSnapshot)
    返回 (取数组成员数 (进程ID数组))

.子程序 进程_ID是否有效, 逻辑型, 公开, 判断一个进程ID是否存在
    .参数 进程ID, 整数型
    .局部变量 bRet, 逻辑型
    .局部变量 dwNeeded, 整数型
    .局部变量 dwLen, 整数型
    .局部变量 pid, 整数型
    .局部变量 lpid, 整数型
    .局部变量 dwSize, 整数型
    .局部变量 i, 整数型

    .如果真 (进程ID ≠ 0)
        dwLen ＝ 1024 ' 预留进程数
        dwSize ＝ dwLen × 4
        lpid ＝ LocalAlloc (#LMEM_ZEROINIT, dwSize)
        bRet ＝ EnumProcesses (lpid, dwSize, dwNeeded)
        .如果真 (bRet)
            .变量循环首 (0, dwNeeded － 4, 4, i)
                pid ＝ __get (lpid, i)
                .如果真 (进程ID ＝ pid)
                    LocalFree (lpid)
                    返回 (真)
                .如果真结束
                
            .变量循环尾 ()
        .如果真结束
        LocalFree (lpid)
    .如果真结束
    返回 (假)

.子程序 进程_取ID数组, 整数型, 公开, 已弃用！请使用 进程_取同名ID
    .参数 进程名, 文本型, , 程序进程名
    .参数 进程ID数组, 整数型, 参考 数组, 返回的进程ID 数组
    .参数 区分大小写, 逻辑型, 可空, 默认不区分进程名大小写

    返回 (进程_取同名ID (进程名, 进程ID数组, 区分大小写))

.子程序 进程_名取ID, 整数型, 公开, 通过进程名取进程ID；失败返回0 
    .参数 进程名, 文本型, , 取要进程ID的进程名
    .参数 是否区分大小写, 逻辑型, 可空, 默认为不区分,真=区分
    .局部变量 局_进程信息, 精易_进程信息列表
    .局部变量 进程快照, 整数型
    .局部变量 是否存在, 整数型

    进程快照 ＝ CreateToolhelp32Snapshot (#TH32CS_SNAPPROCESS, 0)
    .如果真 (进程快照 ＝ #INVALID_HANDLE_VALUE)
        返回 (0)
    .如果真结束
    局_进程信息.dwSize ＝ 296 ' sizeof(PROCESSENTRY32)
    是否存在 ＝ Process32First (进程快照, 局_进程信息)
    .判断循环首 (是否存在 ≠ 0)
        .如果真 (文本比较 (进程名, 到文本 (局_进程信息.进程名称), 是否区分大小写) ＝ 0)
            CloseHandle (进程快照)
            返回 (局_进程信息.进程ID)
        .如果真结束
        是否存在 ＝ Process32Next (进程快照, 局_进程信息)
    .判断循环尾 ()
    CloseHandle (进程快照)
    返回 (0)

.子程序 进程_打开, 整数型, 公开, 通过目标窗口句柄或进程ID取进程句柄，成功返回进程句柄
    .参数 句柄或pid, 整数型, , 窗口句柄或进程ID
    .局部变量 hProcess, 整数型
    .局部变量 dwProcessID, 整数型

    dwProcessID ＝ 句柄或pid
    .如果真 (IsWindow (句柄或pid) ≠ 0)
        GetWindowThreadProcessId (句柄或pid, dwProcessID)
    .如果真结束
    hProcess ＝ OpenProcess (#PROCESS_ALL_ACCESS, 0, dwProcessID)
    返回 (hProcess)

.子程序 进程_打开1, 整数型, 公开, 通过目标进程ID取进程句柄，成功就返回进程句柄
    .参数 进程ID, 整数型, , 目标进程ID

    返回 (OpenProcess (#PROCESS_ALL_ACCESS, 0, 进程ID))

.子程序 进程_关闭, 逻辑型, 公开, 关闭已经打开的操作句柄
    .参数 进程句柄, 整数型, , 进程句柄,线程句柄

    返回 (CloseHandle (进程句柄))

.子程序 进程_创建, 整数型, 公开, 创建一个程序进程(成功返回进程ID,失败返回0)
    .参数 程序路径, 文本型, , 欲创建进程的执行路径
    .参数 命令行, 文本型, 可空, 附加上程序路径后的命令行参数
    .参数 运行目录, 文本型, 可空, 通常留空,特殊情况下使用
    .参数 进程结构, 精易_进程结构, 参考 可空, 接收进程结构信息的变量,如果不为空，产品的句柄用CloseHandle函数释放
    .局部变量 窗口结构, STARTUPINFO

    .如果真 (运行目录 ＝ “”)
        运行目录 ＝ 取文本左边 (程序路径, 倒找文本 (程序路径, “\”, , 假))
    .如果真结束
    CreateProcessA (取指针文本_ (程序路径), 命令行, 0, 0, 假, 0, 0, 取指针文本_ (运行目录), 窗口结构, 进程结构)
    .如果真 (是否为空 (进程结构))
        CloseHandle (进程结构.进程句柄)
        CloseHandle (进程结构.线程句柄)
    .如果真结束
    返回 (进程结构.进程标识符)

.子程序 进程_创建W, 整数型, 公开, 创建一个新进程并返回进程ID
    .参数 程序路径, 字节集, , 欲创建进程的执行路径
    .参数 命令行, 字节集, 可空, 附加上程序路径后的命令行参数
    .参数 是否等待, 逻辑型, 可空, 是否等待程序运行完毕
    .参数 显示方式, 整数型, 可空, 1、隐藏窗口；2、普通激活；3、最小化激活；4、最大化激活；5、普通不激活；6、最小化不激活；7、新桌面中隐藏创建；默认为“普通激活”
    .参数 运行目录, 字节集, 可空
    .参数 以挂起的方式创建, 逻辑型, 可空, 以挂起的方式创建进程
    .参数 挂起后的线程句柄, 整数型, 参考 可空, 以挂起的方式创建为真时才接收挂起后的线程句柄，不用时需要释放。
    .参数 目标进程PID, 整数型, 可空, 同一任务组ID留空或为假时以指定进程的令牌创建进程
    .参数 同一任务组ID, 逻辑型, 可空, 指定创建的进程任务组ID与目标进程一致
    .参数 要注入的DLL文件名, 字节集, 可空, 以挂起的方式创建必须为真
    .局部变量 dwSize, 整数型
    .局部变量 szCmdline, 字节集
    .局部变量 szDesktop, 字节集
    .局部变量 hDesktop, 整数型
    .局部变量 szPath, 字节集
    .局部变量 si, STARTUPINFO
    .局部变量 pi, PROCESS_INFORMATION
    .局部变量 dwFlags, 整数型
    .局部变量 hProcess, 整数型
    .局部变量 hToken, 整数型
    .局部变量 hNewToken, 整数型
    .局部变量 lRes, 逻辑型
    .局部变量 pAttributeList, 整数型
    .局部变量 pMem, 整数型
    .局部变量 pAddress, 整数型
    .局部变量 hThread, 整数型
    .局部变量 hDllModule, 整数型

    .如果真 (同一任务组ID)
        .如果真 (_WIN32_WINNT ＜ #_WIN32_WINNT_VISTA)
            输出调试文本 (#ERROR_NOTVERSION)
            返回 (0)
        .如果真结束
        
    .如果真结束
    dwSize ＝ 取字节集长度 (命令行)
    szCmdline ＝ 取空白字节集 (#MAX_PATH × 2) ' 可修改此字符串的内容，不能是常量字符串！
    .如果真 (dwSize ＞ 0)
        memcpy (取指针_字节集型 (szCmdline), 取指针_字节集型 (命令行), dwSize)
    .如果真结束
    si.cb ＝ 68 ' sizeof(STARTUPINFO)
    si.dwFlags ＝ #STARTF_USESHOWWINDOW
    .如果真 (显示方式 ＜ 1 或 显示方式 ＞ 7)
        显示方式 ＝ 2 ' 普通激活
    .如果真结束
    .如果 (显示方式 ＝ 7) ' 新桌面中隐藏创建
        szDesktop ＝ 编码_Ansi到Unicode (“Desktop”, )
        hDesktop ＝ CreateDesktopW (szDesktop, #NULL, #NULL, 0, 位或 (#GENERIC_ALL, #DESKTOP_CREATEWINDOW), #NULL) ' 创建一个新的桌面
        si.lpDesktop ＝ 取指针_字节集型 (szDesktop)
        si.wShowWindow ＝ #SW_HIDE
    .否则
        si.wShowWindow ＝ 多项选择 (显示方式, #SW_HIDE, #SW_SHOWNORMAL, #SW_SHOWMINIMIZED, #SW_SHOWMAXIMIZED, #SW_SHOWNOACTIVATE, #SW_MINIMIZE)
    .如果结束
    .如果 (运行目录 ＝ { })
        szPath ＝ 字节集_寻找取左 (程序路径, { 92, 0 }, -1) ＋ { 0, 0 }
    .否则
        szPath ＝ 运行目录
    .如果结束
    .如果真 (以挂起的方式创建)
        dwFlags ＝ #CREATE_SUSPENDED
    .如果真结束
    .如果 (目标进程PID ≠ 0)
        RtlAdjustPrivilege (#SeDebugPrivilege, 1, 0, #NULL) ' 启用特权
        hProcess ＝ OpenProcess (#PROCESS_ALL_ACCESS, 0, 目标进程PID)
        .如果真 (hProcess ≠ #NULL)
            .如果 (同一任务组ID)
                dwSize ＝ 0
                InitializeProcThreadAttributeList (#NULL, 1, 0, dwSize)
                dwFlags ＝ #EXTENDED_STARTUPINFO_PRESENT
                si.cb ＝ 72 ' sizeof(STARTUPINFOEX)
                pAttributeList ＝ HeapAlloc (GetProcessHeap (), #HEAP_ZERO_MEMORY, dwSize)
                .如果真 (pAttributeList ≠ #NULL)
                    InitializeProcThreadAttributeList (pAttributeList, 1, 0, dwSize)
                    .如果真 (UpdateProcThreadAttribute (pAttributeList, 0, #PROC_THREAD_ATTRIBUTE_PARENT_PROCESS, 取指针整数_ (hProcess), 4, #NULL, #NULL)) ' sizeof(HANDLE)
                        si.lpAttributeList ＝ pAttributeList
                    .如果真结束
                    lRes ＝ CreateProcessAsUserW (#NULL, 取指针_字节集型 (程序路径), 取指针_字节集型 (szCmdline), #NULL, #NULL, 假, dwFlags, #NULL, 取指针_字节集型 (szPath), si, pi)
                    DeleteProcThreadAttributeList (pAttributeList)
                    HeapFree (GetProcessHeap (), 0, pAttributeList)
                .如果真结束
                
            .否则
                .如果真 (OpenProcessToken (hProcess, 位或 (#TOKEN_DUPLICATE, #TOKEN_ASSIGN_PRIMARY, #TOKEN_QUERY), hToken))
                    .如果真 (DuplicateTokenEx (hToken, 位或 (#TOKEN_ADJUST_DEFAULT, #TOKEN_ADJUST_SESSIONID, #TOKEN_QUERY, #TOKEN_DUPLICATE, #TOKEN_ASSIGN_PRIMARY), #NULL, #SecurityImpersonation, #TokenPrimary, hNewToken))
                        lRes ＝ CreateProcessWithTokenW (hNewToken, 0, 取指针_字节集型 (程序路径), 取指针_字节集型 (szCmdline), dwFlags, #NULL, 取指针_字节集型 (szPath), si, pi)
                        CloseHandle (hNewToken)
                    .如果真结束
                    CloseHandle (hToken)
                .如果真结束
                
            .如果结束
            CloseHandle (hProcess)
        .如果真结束
        RtlAdjustPrivilege (#SeDebugPrivilege, 0, 0, #NULL) ' 禁用特权
    .否则
        lRes ＝ CreateProcessW (取指针_字节集型 (程序路径), 取指针_字节集型 (szCmdline), #NULL, #NULL, 假, dwFlags, #NULL, 取指针_字节集型 (szPath), si, pi)
    .如果结束
    .如果真 (lRes ＝ 假)
        .如果真 (hDesktop ≠ #NULL)
            CloseDesktop (hDesktop)
        .如果真结束
        返回 (0)
    .如果真结束
    .如果真 (以挂起的方式创建)
        .如果真 (文件_是否存在W (要注入的DLL文件名))
            dwSize ＝ 取字节集长度 (要注入的DLL文件名) ＋ 2
            pMem ＝ VirtualAllocEx (pi.hProcess, #NULL, dwSize, #MEM_COMMIT, #PAGE_READWRITE)
            .如果真 (pMem ≠ #NULL)
                WriteProcessMemory_字节集 (pi.hProcess, pMem, 要注入的DLL文件名 ＋ { 0, 0 }, dwSize, #NULL)
                pAddress ＝ GetProcAddress (GetModuleHandleA (“Kernel32.dll”), “LoadLibraryW”)
                hThread ＝ CreateRemoteThread (pi.hProcess, #NULL, 0, pAddress, pMem, 0, #NULL)
                .如果真 (hThread ≠ #NULL)
                    WaitForSingleObject (hThread, #INFINITE)
                    GetExitCodeThread (hThread, hDllModule)
                    CloseHandle (hThread)
                .如果真结束
                VirtualFreeEx (pi.hProcess, pMem, 0, #MEM_RELEASE)
            .如果真结束
            
        .如果真结束
        CloseHandle (pi.hProcess)
        .如果真 (hDesktop ≠ #NULL)
            CloseDesktop (hDesktop)
        .如果真结束
        挂起后的线程句柄 ＝ pi.hThread
        返回 (pi.dwProcessId)
    .如果真结束
    CloseHandle (pi.hThread)
    .如果 (是否等待)
        WaitForSingleObject (pi.hProcess, #INFINITE)
    .否则
        WaitForInputIdle (pi.hProcess, 1000) ' 毫秒
    .如果结束
    CloseHandle (pi.hProcess)
    .如果真 (hDesktop ≠ #NULL)
        CloseDesktop (hDesktop)
    .如果真结束
    返回 (pi.dwProcessId)

.子程序 进程_创建Ex, 整数型, 公开, 创建一个程序进程(成功返回进程ID,失败返回0)
    .参数 程序路径, 文本型, , 欲创建进程的执行路径
    .参数 命令行, 文本型, 可空, 附加上程序路径后的命令行参数
    .参数 是否等待, 逻辑型, 可空, 是否等待程序运行完毕,默认为假.
    .参数 显示方式, 整数型, 可空, 被运行程序窗口显示方式.参数值可以为以下常量之一:1 #隐藏窗口 2 #普通激活 3 #最小化激活 4 #最大化激活 5 #普通不激活 6 #最小化不激活.如果省略本参数,默认为“普通激活”方式.
    .参数 运行目录, 文本型, 可空, 通常留空,特殊情况下使用
    .参数 进程结构, 精易_进程结构, 参考 可空, 接收进程结构信息的变量,如果不为空，产品的句柄用CloseHandle函数释放
    .局部变量 窗口结构, STARTUPINFO

    .如果真 (运行目录 ＝ “”)
        运行目录 ＝ 取文本左边 (程序路径, 倒找文本 (程序路径, “\”, , 假))
    .如果真结束
    窗口结构.cb ＝ 68 ' sizeof(STARTUPINFO)
    .判断开始 (显示方式 ＝ 1)
        窗口结构.dwFlags ＝ 1
        窗口结构.wShowWindow ＝ 0
    .判断 (显示方式 ＝ 3)
        窗口结构.dwFlags ＝ 1
        窗口结构.wShowWindow ＝ 2
    .判断 (显示方式 ＝ 4)
        窗口结构.dwFlags ＝ 1
        窗口结构.wShowWindow ＝ 3
    .判断 (显示方式 ＝ 5)
        窗口结构.dwFlags ＝ 1
        窗口结构.wShowWindow ＝ 4
    .判断 (显示方式 ＝ 6)
        窗口结构.dwFlags ＝ 1
        窗口结构.wShowWindow ＝ 6
    .默认
        窗口结构.dwFlags ＝ 0
        窗口结构.wShowWindow ＝ 1
    .判断结束
    CreateProcessA (取指针文本_ (程序路径), 命令行, 0, 0, 假, 0, 0, 取指针文本_ (运行目录), 窗口结构, 进程结构)
    .如果 (是否等待)
        WaitForSingleObject (进程结构.进程句柄, -1)
    .否则
        WaitForInputIdle (进程结构.进程句柄, 1000)
    .如果结束
    .如果真 (是否为空 (进程结构))
        CloseHandle (进程结构.进程句柄)
        CloseHandle (进程结构.线程句柄)
    .如果真结束
    返回 (进程结构.进程标识符)

.子程序 进程_名取句柄, 整数型, 公开, 通过进程名取对应的窗口句柄；成功返回窗口句柄，失败返回0，返回-1表示找不到进程。
    .参数 进程名, 文本型, , 要取窗口句柄的进程名；
    .局部变量 pid
    .局部变量 hwnd

    pid ＝ 进程_名取ID (进程名)
    .如果真 (pid ≠ 0)
        返回 (进程_ID取窗口句柄 (pid, , , 100, 真))
    .如果真结束
    返回 (-1)

.子程序 进程_取自进程ID, 整数型, 公开, 取自身的进程ID，成功返回进程ID；失败返回0
    返回 (GetCurrentProcessId ())

.子程序 进程_ID取进程名, 文本型, 公开, 通过进程ID取得该进程执行文件名，也就是进程名;
    .参数 参数_进程ID, 整数型, , 该进程的ID;
    .局部变量 hProcessSnap, 整数型
    .局部变量 bool
    .局部变量 pe32, 精易_进程信息列表
    .局部变量 name, 文本型

    hProcessSnap ＝ CreateToolhelp32Snapshot (#TH32CS_SNAPPROCESS, 0)
    .如果真 (hProcessSnap ≠ #INVALID_HANDLE_VALUE)
        pe32.dwSize ＝ 296
        bool ＝ Process32Next (hProcessSnap, pe32)
        .判断循环首 (bool ≠ 0)
            .如果真 (pe32.进程ID ＝ 参数_进程ID)
                name ＝ 到文本 (pe32.进程名称)
                跳出循环 ()
            .如果真结束
            bool ＝ Process32Next (hProcessSnap, pe32)
        .判断循环尾 ()
        CloseHandle (hProcessSnap)
    .如果真结束
    返回 (name)

.子程序 进程_ID取窗口句柄, 整数型, 公开, 通过进程ID取得该进程的窗口句柄,超时则返回零;PS:返回的句柄不一定是祖句柄,只要满足条件就返回
    .参数 进程ID, 整数型, , 该进程的ID;
    .参数 窗口标题, 文本型, 可空, 模糊参数 如果为空,忽略此参数
    .参数 窗口类名, 文本型, 可空, 模糊参数 如果为空,忽略此参数
    .参数 超时, 整数型, 可空, 为空则无限循环
    .参数 是否可见, 逻辑型, 可空, 可空 默认为真,只查找可见的窗口;为假则查找包括不可见的窗口
    .局部变量 dwStartTime, 整数型
    .局部变量 dwEndTime, 整数型
    .局部变量 hWnd, 整数型
    .局部变量 dwProcessId, 整数型
    .局部变量 szClass, 文本型
    .局部变量 szTitle, 文本型

    .如果真 (是否为空 (是否可见))
        是否可见 ＝ 真
    .如果真结束
    dwStartTime ＝ GetTickCount ()
    dwEndTime ＝ 选择 (是否为空 (超时) 或 超时 ＜ 0, 31536000, 超时)
    .判断循环首 (GetTickCount () － dwStartTime ＜ dwEndTime)
        hWnd ＝ FindWindowExA (#NULL, hWnd, #NULL, #NULL)
        .如果真 (hWnd ＝ 0)
            跳出循环 ()
        .如果真结束
        .如果真 (是否可见)
            .如果真 (IsWindowVisible (hWnd) ＝ 假)
                到循环尾 ()
            .如果真结束
            
        .如果真结束
        GetWindowThreadProcessId (hWnd, dwProcessId)
        .如果真 (dwProcessId ＝ 进程ID 且 GetParent (hWnd) ＝ 0)
            szClass ＝ 窗口_取类名 (hWnd)
            szTitle ＝ 窗口_取标题 (hWnd)
            .判断开始 (是否为空 (窗口标题) 且 是否为空 (窗口类名))
                返回 (hWnd)
            .判断 (是否为空 (窗口标题))
                .如果真 (寻找文本 (szClass, 窗口类名, , 假) ≠ -1)
                    返回 (hWnd)
                .如果真结束
                
            .判断 (是否为空 (窗口类名))
                .如果真 (寻找文本 (szTitle, 窗口标题, , 假) ≠ -1)
                    返回 (hWnd)
                .如果真结束
                
            .判断 (寻找文本 (szClass, 窗口类名, , 假) ≠ -1 且 寻找文本 (szTitle, 窗口标题, , 假) ≠ -1)
                返回 (hWnd)
            .默认
                
            .判断结束
            
        .如果真结束
        处理事件 ()
    .判断循环尾 ()
    返回 (0)

.子程序 EnumParenthwnd, 整数型, 公开, 进程_ID取窗口句柄
    .参数 dwPid, 整数型
    .参数 EnumParentProc, 整数型, , int EnumParentProc(HWND hWnd)
    .局部变量 hWnd, 整数型
    .局部变量 dwProcessId, 整数型

    .判断循环首 (真)
        hWnd ＝ FindWindowExA (#NULL, hWnd, #NULL, #NULL)
        .如果真 (hWnd ＝ #NULL)
            跳出循环 ()
        .如果真结束
        GetWindowThreadProcessId (hWnd, dwProcessId)
        .如果真 (dwProcessId ＝ dwPid)
            .如果真 (程序_Call (EnumParentProc, hWnd, , , , ) ＝ 1)
                返回 (hWnd)
            .如果真结束
            
        .如果真结束
        
    .判断循环尾 ()
    返回 (#NULL)

.子程序 进程_ID取窗口句柄EX, 整数型, 公开, 通过枚举窗口信息对比来获取指定进程ID的窗口句柄
    .参数 进程ID, 整数型
    .局部变量 窗口信息, 精易_窗口信息, , "0"
    .局部变量 计次, 整数型

    清除数组 (窗口信息)
    窗口_枚举 (窗口信息)
    .计次循环首 (取数组成员数 (窗口信息), 计次)
        .如果真 (窗口信息 [计次].进程ID ＝ 进程ID)
            返回 (窗口_取祖句柄 (窗口信息 [计次].窗口句柄))
        .如果真结束
        
    .计次循环尾 ()
    返回 (0)

.子程序 进程_取线程数, 整数型, 公开, 通过进程ID或进程名获取指定进程线程数。
    .参数 进程ID或进程名, 文本型, , 不区分大小写
    .局部变量 hProcessSnap, 整数型
    .局部变量 bool, 整数型
    .局部变量 pe32, 精易_进程信息列表
    .局部变量 cntThreads, 整数型

    hProcessSnap ＝ CreateToolhelp32Snapshot (#TH32CS_SNAPPROCESS, 0)
    pe32.dwSize ＝ 296
    bool ＝ Process32Next (hProcessSnap, pe32)
    .判断循环首 (bool ＝ 1)
        .判断开始 (到整数 (进程ID或进程名) ≠ 0)
            .如果真 (到整数 (进程ID或进程名) ＝ pe32.进程ID)
                cntThreads ＝ pe32.cntThreads
                跳出循环 ()
            .如果真结束
            
        .判断 (文本比较 (进程ID或进程名, 到文本 (pe32.进程名称), 假) ＝ 0)
            cntThreads ＝ pe32.cntThreads
            跳出循环 ()
        .默认
            
        .判断结束
        bool ＝ Process32Next (hProcessSnap, pe32)
    .判断循环尾 ()
    CloseHandle (hProcessSnap)
    返回 (cntThreads)

.子程序 进程_ID取模块, 整数型, 公开, 失败为0，成功返回模块数量(该命令为高级成员命令)
    .参数 进程ID, 整数型, 可空, 为空 则取当前进程模块
    .参数 模块信息数组, 精易_模块信息, 参考 可空 数组, 返回的模块信息 数组
    .局部变量 快照句柄, 整数型
    .局部变量 模块信息, 精易_模块信息
    .局部变量 进程句柄, 整数型

    清除数组 (模块信息数组)
    快照句柄 ＝ CreateToolhelp32Snapshot (8, 进程ID)
    .如果真 (快照句柄 ＝ #INVALID_HANDLE_VALUE)
        返回 (0)
    .如果真结束
    模块信息.size ＝ 1024
    进程句柄 ＝ Module32First (快照句柄, 模块信息)
    .判断循环首 (进程句柄 ≠ 0)
        加入成员 (模块信息数组, 模块信息)
        进程句柄 ＝ Module32Next (快照句柄, 模块信息)
    .判断循环尾 ()
    CloseHandle (快照句柄)
    返回 (取数组成员数 (模块信息数组))

.子程序 进程_ID取模块句柄列表, 整数型, 公开, 检索指定进程中满足指定过滤条件的每个模块的句柄。
    .参数 进程ID, 整数型, 可空
    .参数 模块句柄列表, 整数型, 参考 可空 数组, 接收
    .局部变量 hProcess, 整数型
    .局部变量 dwSize, 整数型
    .局部变量 dwLen, 整数型
    .局部变量 phModule, 整数型

    清除数组 (模块句柄列表)
    .如果 (进程ID ＝ 0)
        hProcess ＝ GetCurrentProcess ()
    .否则
        hProcess ＝ OpenProcess (位或 (#PROCESS_QUERY_INFORMATION, #PROCESS_VM_READ), 0, 进程ID)
    .如果结束
    .如果真 (hProcess ＝ #NULL)
        返回 (0)
    .如果真结束
    EnumProcessModulesEx (hProcess, #NULL, 0, dwSize, #LIST_MODULES_ALL)
    .如果真 (dwSize ＝ 0)
        CloseHandle (hProcess)
        返回 (0)
    .如果真结束
    dwLen ＝ dwSize ÷ 4
    重定义数组 (模块句柄列表, 假, dwLen)
    phModule ＝ 取数据_通用型_数组 (模块句柄列表)
    .如果真 (EnumProcessModulesEx (hProcess, phModule, dwSize, #NULL, #LIST_MODULES_ALL) ＝ 假)
        CloseHandle (hProcess)
        清除数组 (模块句柄列表)
        返回 (0)
    .如果真结束
    CloseHandle (hProcess)
    删除成员 (模块句柄列表, 1, ) ' 第1个成员指向自身！！！
    dwLen ＝ 取数组成员数 (模块句柄列表)
    返回 (dwLen)

.子程序 进程_是否存在, 逻辑型, 公开, 判断指定进程是否存在(此判断与进程其它信息无关联)(存在返回真，不存在或失败返回假)
    .参数 进程名, 文本型, , 欲检测的进程名
    .参数 是否区分大小写, 逻辑型, 可空, 默认为不区分,真=区分
    .局部变量 信息, 精易_进程信息列表
    .局部变量 进程快照, 整数型
    .局部变量 是否存在, 整数型

    进程快照 ＝ CreateToolhelp32Snapshot (#TH32CS_SNAPALL, 0)
    .如果真 (进程快照 ＝ #INVALID_HANDLE_VALUE)
        返回 (假)
    .如果真结束
    信息.dwSize ＝ 296 ' sizeof(PROCESSENTRY32)
    是否存在 ＝ Process32First (进程快照, 信息)
    .判断循环首 (是否存在 ≠ 0)
        .如果真 (文本比较 (进程名, 到文本 (信息.进程名称), 是否区分大小写) ＝ 0)
            CloseHandle (进程快照)
            返回 (真)
        .如果真结束
        是否存在 ＝ Process32Next (进程快照, 信息)
    .判断循环尾 ()
    CloseHandle (进程快照)
    返回 (假)

.子程序 进程_提升权限, 逻辑型, 公开, 提升进程到指定权限( #备份  #启动  #关机  #调试)
    .参数 目标进程ID, 整数型, 可空, 为空表示当前进程ID
    .参数 权限类别, 文本型, 可空, 为空:#调试( #备份  #启动  #关机  #调试)
    .局部变量 hProcess, 整数型
    .局部变量 hToken, 整数型
    .局部变量 Luid, LUID
    .局部变量 tkp, TOKEN_PRIVILEGES
    .局部变量 bRet, 逻辑型

    .如果 (目标进程ID ＝ 0)
        hProcess ＝ GetCurrentProcess ()
    .否则
        hProcess ＝ OpenProcess (#PROCESS_ALL_ACCESS, 0, 目标进程ID)
    .如果结束
    .如果真 (hProcess ＝ 0)
        返回 (假)
    .如果真结束
    .如果真 (OpenProcessToken (hProcess, 位或 (#TOKEN_QUERY, #TOKEN_ADJUST_PRIVILEGES), hToken))
        .如果 (是否为空 (权限类别))
            LookupPrivilegeValueA (#NULL, #调试, Luid)
        .否则
            LookupPrivilegeValueA (#NULL, 权限类别, Luid)
        .如果结束
        tkp.PrivilegeCount ＝ 1
        tkp.LowPart ＝ Luid.LowPart
        tkp.HighPart ＝ Luid.HighPart
        tkp.Attributes ＝ #SE_PRIVILEGE_ENABLED
        ' tkp.Attributes ＝ #NULL  ' 禁用特权
        bRet ＝ AdjustTokenPrivileges (hToken, 假, tkp, 16, #NULL, #NULL) ' sizeof(TOKEN_PRIVILEGES)
        CloseHandle (hToken)
    .如果真结束
    CloseHandle (hProcess)
    返回 (bRet)

.子程序 进程_取模块句柄, 整数型, 公开, 获取指定模块名的句柄
    .参数 模块名, 文本型, 可空

    返回 (GetModuleHandleA (模块名))

.子程序 进程_取模块句柄1, 长整数型, 公开, 获取指定进程模块名的句柄
    .参数 pid, 整数型
    .参数 模块名称, 文本型
    .局部变量 ModuleInfo, 进程_模块信息, , "0"
    .局部变量 len, 整数型
    .局部变量 i, 整数型

    len ＝ 进程_枚举进程模块 (pid, ModuleInfo)
    .计次循环首 (len, i)
        .如果真 (文本比较 (模块名称, ModuleInfo [i].模块文件名, 假) ＝ 0)
            返回 (ModuleInfo [i].模块句柄)
        .如果真结束
        
    .计次循环尾 ()
    返回 (0)

.子程序 进程_取启动参数, 文本型, 公开, 取当前进程的命令行
    返回 (GetCommandLineA ())

.子程序 进程_提升权限到Debug, 逻辑型, 公开, 成功返回真，把一个进程的权限提升到调试级权限
    .参数 进程ID, 整数型, 可空, 可空为提升当前进程

    返回 (进程_提升权限 (进程ID, #调试))

.子程序 进程_取优先级, 整数型, 公开, 特殊进程需要特权，检索指定的进程的优先级。返回值：0=最高,1=高于标准,2=实时,3=标准,4=低于标准,5=低,返回-1表示无权限访问进程。
    .参数 进程ID, 整数型, 可空, 欲设置的进程标识符,可为空，即自身进程。
    .局部变量 hProcess
    .局部变量 Class
    .局部变量 Type

    hProcess ＝ 选择 (是否为空 (进程ID), GetCurrentProcess (), OpenProcess (1024, 0, 进程ID))
    .如果真 (hProcess ＝ 0)
        返回 (-1)
    .如果真结束
    Class ＝ GetPriorityClass (hProcess)
    .判断开始 (Class ＝ 256) ' #REALTIME_PRIORITY_CLASS =256
        Type ＝ 2
    .判断 (Class ＝ 128) ' #HIGH_PRIORITY_CLASS =128
        Type ＝ 0
    .判断 (Class ＝ 32768) ' #ABOVE_NORMAL_PRIORITY_CLASS =32768
        Type ＝ 1
    .判断 (Class ＝ 32) ' #NORMAL_PRIORITY_CLASS  =32
        Type ＝ 3
    .判断 (Class ＝ 16384) ' #BELOW_NORMAL_PRIORITY_CLASS  =16384
        Type ＝ 4
    .判断 (Class ＝ 64) ' #IDLE_PRIORITY_CLASS  =64
        Type ＝ 5
    .默认
        Type ＝ 0
    .判断结束
    CloseHandle (hProcess)
    返回 (Type)

.子程序 进程_置优先级, 逻辑型, 公开, 特殊进程需要特权，设置一个进程的优先级别,成功返回真，失败返回假。
    .参数 进程ID, 整数型, 可空, 欲设置的进程标识符,可为空，即自身进程。
    .参数 进程级别, 整数型, 可空, 可为空，默认即0最高。0=最高,1=高于标准,2=实时,3=标准,4=低于标准,5=低
    .局部变量 hProcess
    .局部变量 Bool, 逻辑型

    .如果真 (进程级别 ＝ 0)
        进程级别 ＝ 128 ' #HIGH_PRIORITY_CLASS
    .如果真结束
    .如果真 (进程级别 ＝ 1)
        进程级别 ＝ 32768 ' #ABOVE_NORMAL_PRIORITY_CLASS
    .如果真结束
    .如果真 (进程级别 ＝ 2)
        进程级别 ＝ 256 ' #REALTIME_PRIORITY_CLASS
    .如果真结束
    .如果真 (进程级别 ＝ 3)
        进程级别 ＝ 32 ' #NORMAL_PRIORITY_CLASS
    .如果真结束
    .如果真 (进程级别 ＝ 4)
        进程级别 ＝ 16384 ' #BELOW_NORMAL_PRIORITY_CLASS
    .如果真结束
    .如果真 (进程级别 ＝ 5)
        进程级别 ＝ 64 ' #IDLE_PRIORITY_CLASS
    .如果真结束
    .如果真 (是否为空 (进程级别) 或 进程级别 ＝ 0)
        进程级别 ＝ 128
    .如果真结束
    hProcess ＝ 选择 (是否为空 (进程ID), GetCurrentProcess (), OpenProcess (512, 0, 进程ID)) ' #PROCESS_SET_INFORMATION
    .如果真 (hProcess ＝ 0)
        返回 (假)
    .如果真结束
    Bool ＝ SetPriorityClass (hProcess, 进程级别)
    CloseHandle (hProcess)
    返回 (Bool)

.子程序 进程_取句柄数, 整数型, 公开, 特殊进程需要特权，获取指定进程句柄数量,与XP系统任务管理器功能一样，失败返回-1。
    .参数 进程ID, 整数型, 可空, 可为空，默认即当前进程。
    .局部变量 hProcess, 整数型
    .局部变量 Count, 整数型

    hProcess ＝ 选择 (是否为空 (进程ID), GetCurrentProcess (), OpenProcess (#PROCESS_ALL_ACCESS, 0, 进程ID))
    Count ＝ 选择 (GetProcessHandleCount (hProcess, Count), Count, -1)
    CloseHandle (hProcess)
    返回 (Count)

.子程序 进程_取IO读取计数, 长整数型, 公开, 特殊进程需要特权，获取指定进程IO读取计数,与XP系统任务管理器功能一样，失败返回-1。
    .参数 进程ID, 整数型, 可空, 可为空，默认即当前进程。
    .局部变量 hProcess, 整数型
    .局部变量 lpIoCounters, IO_COUNTERS
    .局部变量 Count, 长整数型

    hProcess ＝ 选择 (是否为空 (进程ID), GetCurrentProcess (), OpenProcess (#PROCESS_ALL_ACCESS, 0, 进程ID))
    Count ＝ 选择 (GetProcessIoCounters (hProcess, lpIoCounters), lpIoCounters.读取操作数量, -1)
    CloseHandle (hProcess)
    返回 (Count)

.子程序 进程_取IO读取字节, 长整数型, 公开, 特殊进程需要特权，获取指定进程IO读取字节数,与XP系统任务管理器功能一样，失败返回-1。
    .参数 进程ID, 整数型, 可空, 可为空，默认即当前进程。
    .局部变量 hProcess, 整数型
    .局部变量 lpIoCounters, IO_COUNTERS
    .局部变量 Count, 长整数型

    hProcess ＝ 选择 (是否为空 (进程ID), GetCurrentProcess (), OpenProcess (#PROCESS_ALL_ACCESS, 0, 进程ID))
    Count ＝ 选择 (GetProcessIoCounters (hProcess, lpIoCounters), lpIoCounters.读取字节数, -1)
    CloseHandle (hProcess)
    返回 (Count)

.子程序 进程_取IO其它计数, 长整数型, 公开, 特殊进程需要特权，获取指定进程IO其它计数,与XP系统任务管理器功能一样，失败返回-1。
    .参数 进程ID, 整数型, 可空, 可为空，默认即当前进程。
    .局部变量 hProcess, 整数型
    .局部变量 lpIoCounters, IO_COUNTERS
    .局部变量 Count, 长整数型

    hProcess ＝ 选择 (是否为空 (进程ID), GetCurrentProcess (), OpenProcess (#PROCESS_ALL_ACCESS, 0, 进程ID))
    Count ＝ 选择 (GetProcessIoCounters (hProcess, lpIoCounters), lpIoCounters.其它读写操作数量, -1)
    CloseHandle (hProcess)
    返回 (Count)

.子程序 进程_取IO其它字节, 长整数型, 公开, 特殊进程需要特权，获取指定进程IO其它字节,与XP系统任务管理器功能一样，失败返回-1。
    .参数 进程ID, 整数型, 可空, 可为空，默认即当前进程。
    .局部变量 hProcess, 整数型
    .局部变量 lpIoCounters, IO_COUNTERS
    .局部变量 Count, 长整数型

    hProcess ＝ 选择 (是否为空 (进程ID), GetCurrentProcess (), OpenProcess (#PROCESS_ALL_ACCESS, 0, 进程ID))
    Count ＝ 选择 (GetProcessIoCounters (hProcess, lpIoCounters), lpIoCounters.其它读写操作字节, -1)
    CloseHandle (hProcess)
    返回 (Count)

.子程序 进程_取IO写入计数, 长整数型, 公开, 特殊进程需要特权，获取指定进程IO写入计数,与XP系统任务管理器功能一样，失败返回-1。
    .参数 进程ID, 整数型, 可空, 可为空，默认即当前进程。
    .局部变量 hProcess, 整数型
    .局部变量 lpIoCounters, IO_COUNTERS
    .局部变量 Count, 长整数型

    hProcess ＝ 选择 (是否为空 (进程ID), GetCurrentProcess (), OpenProcess (#PROCESS_ALL_ACCESS, 0, 进程ID))
    Count ＝ 选择 (GetProcessIoCounters (hProcess, lpIoCounters), lpIoCounters.写入操作数量, -1)
    CloseHandle (hProcess)
    返回 (Count)

.子程序 进程_取IO写入字节, 长整数型, 公开, 特殊进程需要特权，获取指定进程IO写入字节,与XP系统任务管理器功能一样，失败返回-1。
    .参数 进程ID, 整数型, 可空, 可为空，默认即当前进程。
    .局部变量 hProcess, 整数型
    .局部变量 lpIoCounters, IO_COUNTERS
    .局部变量 Count, 长整数型

    hProcess ＝ 选择 (是否为空 (进程ID), GetCurrentProcess (), OpenProcess (#PROCESS_ALL_ACCESS, 0, 进程ID))
    Count ＝ 选择 (GetProcessIoCounters (hProcess, lpIoCounters), lpIoCounters.写入字节数, -1)
    CloseHandle (hProcess)
    返回 (Count)

.子程序 进程_取父ID, 整数型, 公开, 根据进程名或进程ID取出进程父ID，失败返回-1。
    .参数 参_ID或名称, 文本型, , 进程PID或进程名称
    .局部变量 局_返回值
    .局部变量 局_系统进程, SYSTEM_PROCESS_INFORMATION
    .局部变量 局_缓冲区
    .局部变量 局_所需尺寸
    .局部变量 局_下条数据, 整数型
    .局部变量 局_进程名, 文本型

    ZwQuerySystemInformation (#SystemProcessInformation, 0, 0, 局_所需尺寸)
    局_缓冲区 ＝ GlobalAlloc (64, 局_所需尺寸)
    局_返回值 ＝ ZwQuerySystemInformation (#SystemProcessInformation, 局_缓冲区, 局_所需尺寸, 局_所需尺寸)
    .如果真 (局_返回值 ＝ 0)
        局_下条数据 ＝ 局_缓冲区
        CopyMemory_system_process_information (局_系统进程, 局_缓冲区, 184)
        .判断循环首 (局_系统进程.NextEntryDelta ≠ 0)
            局_下条数据 ＝ 局_下条数据 ＋ 局_系统进程.NextEntryDelta
            CopyMemory_system_process_information (局_系统进程, 局_下条数据, 184)
            局_进程名 ＝ 编码_Unicode到Ansi (指针到字节集 (局_系统进程.ImageName.缓冲区, 局_系统进程.ImageName.长度))
            .如果真 (文本比较 (局_进程名, 参_ID或名称, 假) ＝ 0 或 到整数 (参_ID或名称) ＝ 局_系统进程.ProcessId)
                GlobalFree (局_缓冲区)
                返回 (局_系统进程.InheritedFromProcessId)
            .如果真结束
            处理事件 ()
        .判断循环尾 ()
    .如果真结束
    GlobalFree (局_缓冲区)
    返回 (-1)

.子程序 进程_守护, 逻辑型, 公开, 前台版会在运行目录下生成AutoRunApp.vbs隐藏文件，后台版会在运行目录下生成AutoRunApp.bat隐藏文件，注意：后台版需手动结束wscript.exe进程
    .参数 程序路径, 文本型, , 目标程序的完整路径
    .参数 后台守护, 逻辑型, 可空, 为假则以控制台前台显示

    返回 (进程_守护W (编码_Ansi到Unicode (程序路径, ), 后台守护))

.子程序 进程_守护W, 逻辑型, 公开, 前台版会在运行目录下生成AutoRunApp.vbs隐藏文件，后台版会在运行目录下生成AutoRunApp.bat隐藏文件，注意：后台版需手动结束wscript.exe进程
    .参数 程序路径, 字节集, , 目标程序的完整路径
    .参数 后台守护, 逻辑型, 可空, 为假则以控制台前台显示
    .局部变量 szCard, 字节集
    .局部变量 szPath, 字节集
    .局部变量 szTemp, 字节集
    .局部变量 dwRet, 整数型
    .局部变量 hFile, 整数型

    szCard ＝ 编码_Ansi到Unicode (“AutoRunApp”, )
    .如果真 (OpenEventW (#EVENT_ALL_ACCESS, 假, szCard) ≠ #NULL)
        返回 (假)
    .如果真结束
    CreateEventW (#NULL, 假, 假, szCard)
    .如果真 (_GetLastError () ＝ #ERROR_ALREADY_EXISTS)
        输出调试文本 (“当文件已存在时，无法创建该文件！”)
        返回 (假)
    .如果真结束
    szTemp ＝ 编码_Ansi到Unicode (选择 (后台守护, #AuAppVBs, #AuAppBat), 真)
    szPath ＝ 删除Unicode结尾空白字节 (文件_到短文件名W (程序路径), )
    szPath ＝ 子字节集替换 (szPath, { 92, 0 }, { 92, 0, 92, 0 }, , ) ' 转义
    szTemp ＝ 子字节集替换 (szTemp, 编码_Ansi到Unicode (“程序路径”, 真), szPath, , )
    szTemp ＝ 子字节集替换 (szTemp, 编码_Ansi到Unicode (“程序名”, 真), 字节集_寻找取右 (删除Unicode结尾空白字节 (程序路径, ), { 92, 0 }, -1), , )
    szPath ＝ 删除Unicode结尾空白字节 (目录_取运行目录W ()) ＋ 编码_Ansi到Unicode (选择 (后台守护, “\AutoRunApp.vbs”, “\AutoRunApp.bat”), )
    hFile ＝ CreateFileW (szPath, #GENERIC_WRITE, 位或 (#FILE_SHARE_READ, #FILE_SHARE_WRITE, #FILE_SHARE_DELETE), #NULL, #CREATE_ALWAYS, #FILE_ATTRIBUTE_HIDDEN, #NULL)
    .如果真 (hFile ＝ #INVALID_HANDLE_VALUE)
        返回 (假)
    .如果真结束
    .如果 (后台守护) ' 留个坑！以宽字符保存的BAT脚本似乎无法正常运行
        WriteFile (hFile, { 255, 254 }, 2, #NULL, #NULL) ' 以宽字符编码保存
    .否则
        szTemp ＝ W2A_CP (szTemp, m_CodePage)
    .如果结束
    WriteFile (hFile, szTemp, 取字节集长度 (szTemp), #NULL, #NULL)
    CloseHandle (hFile)
    dwRet ＝ ShellExecuteW (#NULL, 编码_Ansi到Unicode (“Open”, ), szPath, { 0, 0 }, { 0, 0 }, #SW_SHOW)
    返回 (dwRet ≥ 32)

.子程序 进程_终止进程, 逻辑型, 公开, 一个或多个任务进程结束
    .参数 进程名, 文本型
    .参数 完整路径, 文本型, 可空, 只终止指定路径的进程

    返回 (进程_终止进程W (编码_Ansi到Unicode (进程名, ), 编码_Ansi到Unicode (完整路径, )))

.子程序 进程_终止进程W, 逻辑型, 公开, 一个或多个任务进程结束
    .参数 进程名, 字节集, , 进程名->Unicode
    .参数 完整路径, 字节集, 可空, 只终止指定路径的进程
    .局部变量 hSnapshort, 整数型
    .局部变量 stcProcessInfo, PROCESSENTRY32W
    .局部变量 bRet, 逻辑型
    .局部变量 hProcess, 整数型
    .局部变量 len, 整数型
    .局部变量 KillName, 字节集

    len ＝ 取字节集长度 (进程名)
    hSnapshort ＝ CreateToolhelp32Snapshot (#TH32CS_SNAPPROCESS, 0)
    .如果真 (hSnapshort ＝ #INVALID_HANDLE_VALUE)
        返回 (假)
    .如果真结束
    stcProcessInfo.dwSize ＝ 556
    bRet ＝ Process32FirstW (hSnapshort, stcProcessInfo)
    .判断循环首 (bRet)
        KillName ＝ 到字节集 (stcProcessInfo.szExeFile)
        KillName ＝ 取字节集左边 (KillName, len)
        .如果真 (KillName ＝ 进程名)
            Sleep (1)
            .如果真 (是否为空 (完整路径) ＝ 假 且 取字节集长度 (完整路径) ＞ 3)
                .如果真 (进程_取路径W (stcProcessInfo.th32ProcessID) ≠ 完整路径)
                    bRet ＝ Process32NextW (hSnapshort, stcProcessInfo)
                    到循环尾 ()
                .如果真结束
                
            .如果真结束
            hProcess ＝ OpenProcess (#PROCESS_TERMINATE, 0, stcProcessInfo.th32ProcessID)
            TerminateProcess (hProcess, 0)
            CloseHandle (hProcess)
        .如果真结束
        bRet ＝ Process32NextW (hSnapshort, stcProcessInfo)
    .判断循环尾 ()
    CloseHandle (hSnapshort)
    返回 (真)

.子程序 进程_端口取PID, 整数型, 公开, 通过本地端口取出进程PID
    .参数 端口号, 整数型
    .局部变量 dwSize, 整数型
    .局部变量 pTable, 整数型
    .局部变量 dwNumEntries, 整数型
    .局部变量 TcpTable, MIB_TCPROW_OWNER_PID
    .局部变量 UdpTable, MIB_UDPROW_OWNER_PID
    .局部变量 dwRet, 整数型
    .局部变量 i, 整数型

    ' 检索TCP
    GetExtendedTcpTable (#NULL, dwSize, 真, #AF_INET, #TCP_TABLE_OWNER_PID_ALL, 0)
    .如果真 (dwSize ＝ 0)
        返回 (0)
    .如果真结束
    pTable ＝ LocalAlloc (#LMEM_ZEROINIT, dwSize)
    dwRet ＝ GetExtendedTcpTable (pTable, dwSize, 真, #AF_INET, #TCP_TABLE_OWNER_PID_ALL, 0)
    .如果真 (dwRet ＝ #NO_ERROR)
        dwNumEntries ＝ __get (pTable, 0) ' 开头4个字节是 MIB_TCPROW_OWNER_PID 结构的数量
        .计次循环首 (dwNumEntries, i)
            memcpy (取数据_通用型 (TcpTable), pTable ＋ 4 ＋ (i － 1) × 24, 24)
            .如果真 (端口号 ＝ 整数到端口 (TcpTable.dwLocalPort))
                LocalFree (pTable)
                返回 (TcpTable.dwOwningPid)
            .如果真结束
            
        .计次循环尾 ()
    .如果真结束
    LocalFree (pTable)
    ' 检索UDP
    dwSize ＝ 0
    GetExtendedUdpTable (#NULL, dwSize, 真, #AF_INET, #UDP_TABLE_OWNER_PID, 0)
    .如果真 (dwSize ＝ 0)
        返回 (0)
    .如果真结束
    pTable ＝ LocalAlloc (#LMEM_ZEROINIT, dwSize)
    dwRet ＝ GetExtendedUdpTable (pTable, dwSize, 真, #AF_INET, #UDP_TABLE_OWNER_PID, 0)
    .如果真 (dwRet ＝ #NO_ERROR)
        dwNumEntries ＝ __get (pTable, 0) ' 开头4个字节是 MIB_UDPROW_OWNER_PID 结构的数量
        .计次循环首 (dwNumEntries, i)
            memcpy (取数据_通用型 (UdpTable), pTable ＋ 4 ＋ (i － 1) × 12, 12)
            .如果真 (端口号 ＝ 整数到端口 (UdpTable.dwLocalPort))
                LocalFree (pTable)
                返回 (UdpTable.dwOwningPid)
            .如果真结束
            
        .计次循环尾 ()
    .如果真结束
    LocalFree (pTable)
    返回 (0)

.子程序 进程_PID取端口, 整数型, 公开, 通过进程PID取出本地端口
    .参数 PID, 整数型, , 进程ID
    .局部变量 dwSize, 整数型
    .局部变量 pTable, 整数型
    .局部变量 dwNumEntries, 整数型
    .局部变量 TcpTable, MIB_TCPROW_OWNER_PID
    .局部变量 UdpTable, MIB_UDPROW_OWNER_PID
    .局部变量 dwRet, 整数型
    .局部变量 i, 整数型

    ' 检索TCP
    GetExtendedTcpTable (#NULL, dwSize, 真, #AF_INET, #TCP_TABLE_OWNER_PID_ALL, 0)
    .如果真 (dwSize ＝ 0)
        返回 (0)
    .如果真结束
    pTable ＝ LocalAlloc (#LMEM_ZEROINIT, dwSize)
    dwRet ＝ GetExtendedTcpTable (pTable, dwSize, 真, #AF_INET, #TCP_TABLE_OWNER_PID_ALL, 0)
    .如果真 (dwRet ＝ #NO_ERROR)
        dwNumEntries ＝ __get (pTable, 0) ' 开头4个字节是 MIB_TCPROW_OWNER_PID 结构的数量
        .计次循环首 (dwNumEntries, i)
            memcpy (取数据_通用型 (TcpTable), pTable ＋ 4 ＋ (i － 1) × 24, 24)
            .如果真 (PID ＝ TcpTable.dwOwningPid)
                LocalFree (pTable)
                返回 (整数到端口 (TcpTable.dwLocalPort))
            .如果真结束
            
        .计次循环尾 ()
    .如果真结束
    LocalFree (pTable)
    ' 检索UDP
    dwSize ＝ 0
    GetExtendedUdpTable (#NULL, dwSize, 真, #AF_INET, #UDP_TABLE_OWNER_PID, 0)
    .如果真 (dwSize ＝ 0)
        返回 (0)
    .如果真结束
    pTable ＝ LocalAlloc (#LMEM_ZEROINIT, dwSize)
    dwRet ＝ GetExtendedUdpTable (pTable, dwSize, 真, #AF_INET, #UDP_TABLE_OWNER_PID, 0)
    .如果真 (dwRet ＝ #NO_ERROR)
        dwNumEntries ＝ __get (pTable, 0) ' 开头4个字节是 MIB_UDPROW_OWNER_PID 结构的数量
        .计次循环首 (dwNumEntries, i)
            memcpy (取数据_通用型 (UdpTable), pTable ＋ 4 ＋ (i － 1) × 12, 12)
            .如果真 (PID ＝ UdpTable.dwOwningPid)
                LocalFree (pTable)
                返回 (整数到端口 (UdpTable.dwLocalPort))
            .如果真结束
            
        .计次循环尾 ()
    .如果真结束
    LocalFree (pTable)
    返回 (0)

.子程序 整数到端口, 整数型, , ntohs
    .参数 Port, 整数型

    返回 (位或 (右移 (位与 (Port, 65280), 8), 左移 (位与 (Port, 255), 8)))

.子程序 进程_取进程启动时间, 文本型, 公开, 返回进程启动时间，如：20200813145000
    .参数 进程ID, 整数型, 可空, PID
    .局部变量 hProcess, 整数型
    .局部变量 CreateTime, FILETIME, , , 进程的创建时间
    .局部变量 ExitTime, FILETIME, , , 进程的退出时间
    .局部变量 KernelTime, FILETIME, , , 进程在内核模式下已执行的时间
    .局部变量 UserTime, FILETIME, , , 进程在用户模式下已执行的时间
    .局部变量 vTime, 日期时间型

    .如果 (进程ID ＝ 0)
        hProcess ＝ GetCurrentProcess ()
    .否则
        hProcess ＝ OpenProcess (#PROCESS_QUERY_LIMITED_INFORMATION, 0, 进程ID)
    .如果结束
    GetProcessTimes (hProcess, CreateTime, ExitTime, KernelTime, UserTime)
    CloseHandle (hProcess)
    vTime ＝ FileTimeToVariantTime (CreateTime)
    返回 (时间_格式化 (vTime, “yyyyMMdd”, “hhmmss”, 真))

.子程序 进程_DEP保护, 逻辑型, 公开, 数据执行保护开关; 成功返回真, 失败返回假
    .参数 dwFlags, 整数型, 可空, 如果DEP系统策略为OptIn或OptOut并且为该进程启用了DEP, 则将dwFlags设置为0将禁用该进程的DEP

    .如果真 (GetSystemDEPPolicy () ＜ 2)
        返回 (假)
    .如果真结束
    返回 (SetProcessDEPPolicy (dwFlags))

.子程序 进程_是否为64位, 逻辑型, 公开, 判断指定进程是否为64位
    .参数 进程ID, 整数型
    .局部变量 hProcess, 整数型
    .局部变量 isWow64, 逻辑型
    .局部变量 lRes, 逻辑型

    hProcess ＝ OpenProcess (#PROCESS_QUERY_INFORMATION, 0, 进程ID)
    .如果真 (hProcess ≠ 0)
        .如果真 (IsWow64Process (hProcess, isWow64) 且 isWow64 ＝ 假)
            lRes ＝ 真
        .如果真结束
        CloseHandle (hProcess)
    .如果真结束
    返回 (lRes)

.子程序 进程_取子进程IDW, 整数型, 公开, 取指定进程ID为父进程的子进程ID
    .参数 进程ID, 整数型
    .参数 子进程名, 字节集
    .局部变量 hSnapshort, 整数型
    .局部变量 pe32, PROCESSENTRY32W
    .局部变量 bRet, 逻辑型
    .局部变量 hProcess, 整数型
    .局部变量 pbi, PROCESS_BASIC_INFORMATION
    .局部变量 dwProcessId, 整数型

    hSnapshort ＝ CreateToolhelp32Snapshot (#TH32CS_SNAPPROCESS, 0)
    .如果真 (hSnapshort ＝ #INVALID_HANDLE_VALUE)
        返回 (#INVALID_HANDLE_VALUE)
    .如果真结束
    pe32.dwSize ＝ 556
    bRet ＝ Process32FirstW (hSnapshort, pe32)
    .判断循环首 (bRet)
        .如果真 (文本_文本比较W (取数据_通用型_数组 (pe32.szExeFile), 取指针_字节集型 (子进程名), ) ＝ 0)
            hProcess ＝ OpenProcess (#PROCESS_QUERY_INFORMATION, 0, pe32.th32ProcessID)
            bRet ＝ NtQueryInformationProcess (hProcess, #NULL, 取数据_通用型 (pbi), 24, #NULL) ≥ 0
            .如果真 (bRet)
                .如果真 (pbi.InheritedFromUniqueProcessId ＝ 进程ID)
                    dwProcessId ＝ pe32.th32ProcessID
                    跳出循环 ()
                .如果真结束
                
            .如果真结束
            CloseHandle (hProcess)
        .如果真结束
        bRet ＝ Process32NextW (hSnapshort, pe32)
    .判断循环尾 ()
    CloseHandle (hSnapshort)
    返回 (dwProcessId)

.子程序 进程_取子进程ID, 整数型, 公开, 取指定进程ID为父进程的子进程ID
    .参数 进程ID, 整数型
    .参数 子进程名, 文本型

    返回 (进程_取子进程IDW (进程ID, 编码_Ansi到Unicode (子进程名, )))

.子程序 进程_取远程会话ID, 整数型, 公开, 检索与指定进程关联的远程桌面服务会话
    .参数 进程ID, 整数型
    .局部变量 dwSessionId, 整数型

    ProcessIdToSessionId (进程ID, dwSessionId)
    返回 (dwSessionId)

.子程序 进程_DLL取自身信息, 进程_模块信息, 公开, 编译成DLL后被其他程序加载时用于查看自身模块信息
    .局部变量 hModule, 整数型
    .局部变量 hProcess, 整数型
    .局部变量 szBaseName, 文本型
    .局部变量 dwSize, 整数型
    .局部变量 szFileName, 文本型
    .局部变量 ModuleInfo, 进程_模块信息

    GetModuleHandleExA (位或 (#GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS, #GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT), hModule, hModule)
    .如果真 (hModule ≠ #NULL)
        hProcess ＝ GetCurrentProcess ()
        szBaseName ＝ 取空白文本 (#MAX_PATH)
        dwSize ＝ GetModuleBaseNameA (hProcess, hModule, szBaseName, #MAX_PATH)
        .如果真 (dwSize ＞ 0)
            ModuleInfo.模块文件名 ＝ szBaseName
        .如果真结束
        szFileName ＝ 取空白文本 (#MAX_PATH)
        dwSize ＝ GetModuleFileNameA (hModule, szFileName, #MAX_PATH)
        .如果真 (dwSize ＞ 0)
            ModuleInfo.模块完整路径 ＝ szFileName
        .如果真结束
        ModuleInfo.模块句柄 ＝ hModule
    .如果真结束
    返回 (ModuleInfo)

.子程序 进程_DLL取自身信息1, 进程_模块信息, 公开, 编译成DLL后被其他程序加载时用于查看自身模块信息
    .参数 模块名, 文本型, 可空
    .局部变量 hProcess, 整数型
    .局部变量 hModule, 整数型
    .局部变量 mbi, MEMORY_BASIC_INFORMATION
    .局部变量 ModuleInfo, 进程_模块信息
    .局部变量 szBaseName, 文本型
    .局部变量 szFileName, 文本型
    .局部变量 dwSize, 整数型

    hProcess ＝ GetCurrentProcess ()
    .如果 (是否为空 (模块名))
        hModule ＝ GetModuleHandleA1 (#NULL)
    .否则
        hModule ＝ GetModuleHandleA (模块名)
    .如果结束
    .如果真 (hModule ＝ #NULL)
        返回 (ModuleInfo)
    .如果真结束
    .如果真 (VirtualQueryEx32 (hProcess, hModule, mbi, 28) ＝ 0)
        返回 (ModuleInfo)
    .如果真结束
    szBaseName ＝ 取空白文本 (#MAX_PATH)
    dwSize ＝ GetModuleBaseNameA (hProcess, mbi.AllocationBase, szBaseName, #MAX_PATH)
    .如果真 (dwSize ＞ 0)
        ModuleInfo.模块文件名 ＝ szBaseName
    .如果真结束
    szFileName ＝ 取空白文本 (#MAX_PATH)
    dwSize ＝ GetModuleFileNameA (hModule, szFileName, #MAX_PATH)
    .如果真 (dwSize ＞ 0)
        ModuleInfo.模块完整路径 ＝ szFileName
    .如果真结束
    ModuleInfo.模块句柄 ＝ mbi.AllocationBase
    返回 (ModuleInfo)

.子程序 进程_句柄取进程ID, 整数型, 公开, 成功则返回值是进程标识符。失败返回值为零！
    .参数 进程句柄, 整数型, , 进程的句柄。句柄必须具有 PROCESS_QUERY_INFORMATION 或 PROCESS_QUERY_LIMITED_INFORMATION 访问权限。
    .局部变量 dwProcessId, 整数型

    dwProcessId ＝ GetProcessId (进程句柄)
    .如果真 (dwProcessId ＝ 0)
        输出调试文本 (取错误信息文本_API (, ))
    .如果真结束
    返回 (dwProcessId)

.子程序 进程_是否被调试, 逻辑型, 公开, 判断指定的进程是否正在调试
    .参数 进程句柄, 整数型, , hProcess
    .局部变量 isDebug, 逻辑型

    CheckRemoteDebuggerPresent (进程句柄, isDebug)
    返回 (isDebug)

.子程序 进程_取系统版本, , 公开
    .参数 进程ID, 整数型, 可空, 0
    .参数 主要版本号, 整数型, 参考 可空, OSMajorVersion
    .参数 次要版本号, 整数型, 参考 可空, OSMinorVersion
    .参数 内部版本号, 短整数型, 参考 可空, OSBuildNumber

    置入代码 ({ 100, 139, 29, 48, 0, 0, 0, 141, 155, 172, 0, 0, 0, 185, 3, 0, 0, 0, 139, 3, 139, 84, 205, 8, 137, 2, 131, 235, 4, 226, 243, 201, 194, 14, 0 })
    ' mov ebx, dword [fs:30h]
    ' lea ebx, dword [ebx+0ACh]
    ' mov ecx, 03h
    ' label1:
    ' mov eax, dword [ebx]
    ' mov edx, dword [ebp+ecx*8+08h]
    ' mov dword [edx], eax
    ' sub ebx, 04h
    ' loop label1
    ' leave
    ' retn 0Eh

.子程序 进程_取资源字符串, 文本型, 公开, 从与指定模块关联的可执行文件加载字符串资源，并将字符串复制到带有终止空字符的缓冲区中。
    .参数 模块名, 文本型
    .参数 标识符, 整数型

    返回 (编码_Unicode到Ansi (进程_取资源字符串W (编码_Ansi到Unicode (模块名, ), 标识符)))

.子程序 进程_取资源字符串W, 字节集, 公开, 从与指定模块关联的可执行文件加载字符串资源，并将字符串复制到带有终止空字符的缓冲区中。
    .参数 模块名, 字节集
    .参数 标识符, 整数型
    .局部变量 hIns, 整数型
    .局部变量 isLoad, 逻辑型
    .局部变量 pv, 整数型
    .局部变量 nSize, 整数型
    .局部变量 szBuf, 字节集

    hIns ＝ GetModuleHandleW (取指针_字节集型 (模块名))
    .如果真 (hIns ＝ #NULL)
        hIns ＝ LoadLibraryW (取指针_字节集型 (模块名))
        isLoad ＝ 真
    .如果真结束
    .如果真 (hIns ＝ #NULL)
        返回 ({ })
    .如果真结束
    pv ＝ LocalAlloc (#LMEM_ZEROINIT, 8)
    nSize ＝ LoadStringW (hIns, 标识符, pv, 0)
    .如果真 (nSize ＞ 0)
        szBuf ＝ 指针到字节集 (__get (pv, 0), nSize × 2) ＋ { 0, 0 }
    .如果真结束
    LocalFree (pv)
    .如果真 (isLoad 且 hIns ≠ #NULL)
        FreeLibrary (hIns)
    .如果真结束
    返回 (szBuf)

.子程序 进程_取执行权限级别, 整数型, 公开, 获取进程当前UAC的执行权限级别。0、低级；1、中级；2、高级；3、系统级；-1、未知。
    .参数 pid, 整数型, 可空
    .局部变量 hProcess, 整数型
    .局部变量 hToken, 整数型
    .局部变量 dwByteLen, 整数型
    .局部变量 pv, 整数型
    .局部变量 pSid, 整数型
    .局部变量 nSubAuthority, 整数型
    .局部变量 dwIntegrityLevel, 整数型

    .如果 (pid ＞ 0)
        hProcess ＝ OpenProcess (#PROCESS_QUERY_INFORMATION, 0, pid)
    .否则
        hProcess ＝ GetCurrentProcess ()
    .如果结束
    .如果真 (hProcess ＝ #NULL)
        返回 (-1)
    .如果真结束
    .如果真 (OpenProcessToken (hProcess, 位或 (#TOKEN_QUERY, #TOKEN_QUERY_SOURCE), hToken))
        GetTokenInformation (hToken, #TokenIntegrityLevel, #NULL, 0, 取指针整数_ (dwByteLen))
        pv ＝ LocalAlloc (#LMEM_ZEROINIT, dwByteLen)
        .如果真 (GetTokenInformation (hToken, #TokenIntegrityLevel, pv, dwByteLen, 取指针整数_ (dwByteLen)))
            pSid ＝ __get (pv, 0) ' TOKEN_INFORMATION_CLASS => Label.Sid
            nSubAuthority ＝ GetSidSubAuthorityCount (pSid)
            dwIntegrityLevel ＝ __get (GetSidSubAuthority (pSid, __get (nSubAuthority, 0) － 1), 0)
        .如果真结束
        LocalFree (pv)
        CloseHandle (hToken)
    .如果真结束
    CloseHandle (hProcess)
    .判断开始 (dwIntegrityLevel ＝ #SECURITY_MANDATORY_LOW_RID)
        返回 (0)
    .判断 (dwIntegrityLevel ≥ #SECURITY_MANDATORY_MEDIUM_RID 且 dwIntegrityLevel ＜ #SECURITY_MANDATORY_HIGH_RID)
        返回 (1)
    .判断 (dwIntegrityLevel ≥ #SECURITY_MANDATORY_HIGH_RID 且 dwIntegrityLevel ＜ #SECURITY_MANDATORY_SYSTEM_RID)
        返回 (2)
    .判断 (dwIntegrityLevel ≥ #SECURITY_MANDATORY_SYSTEM_RID)
        返回 (3)
    .默认
        返回 (-1)
    .判断结束
    

.子程序 进程_是否有管理员特权, 逻辑型, 公开, 判断指定程序是否运行在管理员身份下
    .参数 进程ID, 整数型, 可空
    .局部变量 hProcess, 整数型
    .局部变量 hToken, 整数型
    .局部变量 psidAdmin, 整数型
    .局部变量 pAuthority, 字节集
    .局部变量 dwCount, 整数型
    .局部变量 pTokenGroups, 整数型
    .局部变量 dwGroupCount, 整数型
    .局部变量 pSid, 整数型
    .局部变量 dwAttributes, 整数型
    .局部变量 isAdmin, 逻辑型
    .局部变量 i, 整数型

    .如果真 (进程ID ≤ 0)
        进程ID ＝ GetCurrentProcessId ()
    .如果真结束
    hProcess ＝ OpenProcess (#PROCESS_QUERY_LIMITED_INFORMATION, 0, 进程ID)
    .如果真 (hProcess ≠ #NULL)
        .如果真 (OpenProcessToken (hProcess, #TOKEN_QUERY, hToken))
            pAuthority ＝ { 0, 0, 0, 0, 0, 5 } ' SECURITY_NT_AUTHORITY
            .如果真 (AllocateAndInitializeSid (取指针_字节集型 (pAuthority), 2, #SECURITY_BUILTIN_DOMAIN_RID, #DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0, 0, 0, psidAdmin))
                GetTokenInformation (hToken, #TokenGroups, #NULL, 0, 取指针整数_ (dwCount))
                pTokenGroups ＝ LocalAlloc (#LMEM_ZEROINIT, dwCount)
                GetTokenInformation (hToken, #TokenGroups, pTokenGroups, dwCount, 取指针整数_ (dwCount))
                dwGroupCount ＝ __get (pTokenGroups, 0) ' TOKEN_GROUPS => GroupCount
                .变量循环首 (0, dwGroupCount － 1, 1, i)
                    pSid ＝ __get (pTokenGroups, 4 ＋ 8 × i) ' TOKEN_GROUPS => Groups[i].Sid
                    .如果真 (EqualSid (psidAdmin, pSid))
                        dwAttributes ＝ __get (pTokenGroups, 8 ＋ 8 × i) ' TOKEN_GROUPS => Groups[i].Attributes
                        isAdmin ＝ 位与 (dwAttributes, #SE_GROUP_USE_FOR_DENY_ONLY) ≠ #SE_GROUP_USE_FOR_DENY_ONLY
                        跳出循环 ()
                    .如果真结束
                    
                .变量循环尾 ()
                LocalFree (pTokenGroups)
                FreeSid (psidAdmin)
            .如果真结束
            CloseHandle (hToken)
        .如果真结束
        CloseHandle (hProcess)
    .如果真结束
    返回 (isAdmin)

.子程序 进程_枚举进程模块, 整数型, 公开, 遍历指定进程的模块信息
    .参数 pid, 整数型
    .参数 模块信息, 进程_模块信息, 参考 数组
    .局部变量 hProcess, 整数型
    .局部变量 is64System, 逻辑型
    .局部变量 isWow64, 逻辑型
    .局部变量 pbi, 整数型
    .局部变量 LdrAddress, 整数型
    .局部变量 ListEntry, 整数型
    .局部变量 CurrentModule, 整数型
    .局部变量 hFristModule, 整数型
    .局部变量 wMaximumLength, 短整数型
    .局部变量 pBuffer, 整数型
    .局部变量 wszBuffer, 字节集
    .局部变量 ModuleInfo, 进程_模块信息

    清除数组 (模块信息)
    hProcess ＝ OpenProcess (位或 (#PROCESS_QUERY_INFORMATION, #PROCESS_VM_READ), 0, pid)
    .如果真 (hProcess ≠ #NULL)
        is64System ＝ IsWow64Process (hProcess, isWow64) 且 isWow64 ＝ 假
        .如果 (is64System) ' x64
            pbi ＝ LocalAlloc (#LMEM_ZEROINIT, 48) ' sizeof(PROCESS_BASIC_INFORMATION64)
            .如果真 (pbi ≠ #NULL 且 NtWow64QueryInformationProcess64 (hProcess, #ProcessBasicInformation, pbi, 48, #NULL) ＝ #ERROR_SUCCESS)
                LdrAddress ＝ LocalAlloc (#LMEM_ZEROINIT, 8) ' sizeof(ULONG64)
                .如果真 (LdrAddress ≠ #NULL 且 NtWow64ReadVirtualMemory64 (hProcess, 指针_到长整数型_汇编 (pbi ＋ 8) ＋ 24, LdrAddress, 8, #NULL) ＝ #ERROR_SUCCESS)
                    ListEntry ＝ LocalAlloc (#LMEM_ZEROINIT, 16) ' sizeof(LIST_ENTRY64)
                    .如果真 (ListEntry ≠ #NULL 且 NtWow64ReadVirtualMemory64 (hProcess, 指针_到长整数型_汇编 (LdrAddress) ＋ 16, ListEntry, 16, #NULL) ＝ #ERROR_SUCCESS)
                        CurrentModule ＝ LocalAlloc (#LMEM_ZEROINIT, 160) ' sizeof(LDR_DATA_TABLE_ENTRY64)
                        .如果真 (CurrentModule ≠ #NULL 且 NtWow64ReadVirtualMemory64 (hProcess, 指针_到长整数型_汇编 (ListEntry), CurrentModule, 160, #NULL) ＝ #ERROR_SUCCESS)
                            hFristModule ＝ LocalAlloc (#LMEM_ZEROINIT, 8) ' sizeof(ULONG64)
                            .如果真 (hFristModule ≠ #NULL)
                                memcpy (hFristModule, CurrentModule ＋ 48, 8)
                                pBuffer ＝ LocalAlloc (#LMEM_ZEROINIT, 1024)
                                .判断循环首 (指针_到长整数型_汇编 (hFristModule) ≠ #NULL)
                                    .如果真 (NtWow64ReadVirtualMemory64 (hProcess, 指针_到长整数型_汇编 (CurrentModule), CurrentModule, 160, #NULL) ≠ #ERROR_SUCCESS)
                                        跳出循环 ()
                                    .如果真结束
                                    memcpy (hFristModule, CurrentModule ＋ 48, 8)
                                    .如果真 (指针_到长整数型_汇编 (hFristModule) ＝ #NULL)
                                        跳出循环 ()
                                    .如果真结束
                                    ModuleInfo.模块句柄 ＝ 指针_到长整数型_汇编 (hFristModule)
                                    wMaximumLength ＝ 指针_到短整数型_汇编 (CurrentModule ＋ 90)
                                    .如果真 (wMaximumLength ＞ 1024)
                                        暂停 ()
                                    .如果真结束
                                    memset (pBuffer, 0, 1024)
                                    NtWow64ReadVirtualMemory64 (hProcess, 指针_到长整数型_汇编 (CurrentModule ＋ 96), pBuffer, wMaximumLength, #NULL)
                                    wszBuffer ＝ 指针到字节集 (pBuffer, wMaximumLength)
                                    ModuleInfo.模块文件名 ＝ 编码_Unicode到Ansi (wszBuffer)
                                    wMaximumLength ＝ 指针_到短整数型_汇编 (CurrentModule ＋ 74)
                                    .如果真 (wMaximumLength ＞ 1024)
                                        暂停 ()
                                    .如果真结束
                                    memset (pBuffer, 0, 1024)
                                    NtWow64ReadVirtualMemory64 (hProcess, 指针_到长整数型_汇编 (CurrentModule ＋ 80), pBuffer, wMaximumLength, #NULL)
                                    wszBuffer ＝ 指针到字节集 (pBuffer, wMaximumLength)
                                    ModuleInfo.模块完整路径 ＝ 编码_Unicode到Ansi (wszBuffer)
                                    加入成员 (模块信息, ModuleInfo)
                                .判断循环尾 ()
                                LocalFree (pBuffer)
                                LocalFree (hFristModule)
                            .如果真结束
                            LocalFree (CurrentModule)
                        .如果真结束
                        LocalFree (ListEntry)
                    .如果真结束
                    LocalFree (LdrAddress)
                .如果真结束
                LocalFree (pbi)
            .如果真结束
            
        .否则
            pbi ＝ LocalAlloc (#LMEM_ZEROINIT, 24) ' sizeof(PROCESS_BASIC_INFORMATION32)
            .如果真 (pbi ≠ #NULL 且 NtQueryInformationProcess (hProcess, #ProcessBasicInformation, pbi, 24, #NULL) ＝ #ERROR_SUCCESS)
                .如果真 (NtReadVirtualMemory (hProcess, __get (pbi, 4) ＋ 12, 取指针整数_ (LdrAddress), 4, #NULL) ＝ #ERROR_SUCCESS)
                    ListEntry ＝ LocalAlloc (#LMEM_ZEROINIT, 8) ' sizeof(LIST_ENTRY32)
                    .如果真 (ListEntry ≠ #NULL 且 NtReadVirtualMemory (hProcess, LdrAddress ＋ 12, ListEntry, 8, #NULL) ＝ #ERROR_SUCCESS)
                        CurrentModule ＝ LocalAlloc (#LMEM_ZEROINIT, 84) ' sizeof(LDR_DATA_TABLE_ENTRY32)
                        .如果真 (CurrentModule ≠ #NULL 且 NtReadVirtualMemory (hProcess, __get (ListEntry, 0), CurrentModule, 84, #NULL) ＝ #ERROR_SUCCESS)
                            hFristModule ＝ __get (CurrentModule, 24)
                            pBuffer ＝ LocalAlloc (#LMEM_ZEROINIT, 1024)
                            .判断循环首 (hFristModule ≠ #NULL)
                                .如果真 (NtReadVirtualMemory (hProcess, __get (CurrentModule, 0), CurrentModule, 84, #NULL) ≠ #ERROR_SUCCESS)
                                    跳出循环 ()
                                .如果真结束
                                hFristModule ＝ __get (CurrentModule, 24)
                                .如果真 (hFristModule ＝ #NULL)
                                    跳出循环 ()
                                .如果真结束
                                ModuleInfo.模块句柄 ＝ 到长整数 (hFristModule)
                                wMaximumLength ＝ 指针_到短整数型_汇编 (CurrentModule ＋ 46)
                                .如果真 (wMaximumLength ＞ 1024)
                                    暂停 ()
                                .如果真结束
                                memset (pBuffer, 0, 1024)
                                NtReadVirtualMemory (hProcess, __get (CurrentModule, 48), pBuffer, wMaximumLength, #NULL)
                                wszBuffer ＝ 指针到字节集 (pBuffer, wMaximumLength)
                                ModuleInfo.模块文件名 ＝ 编码_Unicode到Ansi (wszBuffer)
                                wMaximumLength ＝ 指针_到短整数型_汇编 (CurrentModule ＋ 38)
                                .如果真 (wMaximumLength ＞ 1024)
                                    暂停 ()
                                .如果真结束
                                memset (pBuffer, 0, 1024)
                                NtReadVirtualMemory (hProcess, __get (CurrentModule, 40), pBuffer, wMaximumLength, #NULL)
                                wszBuffer ＝ 指针到字节集 (pBuffer, wMaximumLength)
                                ModuleInfo.模块完整路径 ＝ 子文本替换 (编码_Unicode到Ansi (wszBuffer), 目录_取特定目录 (, #CSIDL_SYSTEM), 目录_取特定目录 (, #CSIDL_SYSTEMX86), , 1, 假)
                                加入成员 (模块信息, ModuleInfo)
                            .判断循环尾 ()
                            LocalFree (pBuffer)
                            LocalFree (CurrentModule)
                        .如果真结束
                        LocalFree (ListEntry)
                    .如果真结束
                    
                .如果真结束
                LocalFree (pbi)
            .如果真结束
            
        .如果结束
        CloseHandle (hProcess)
    .如果真结束
    返回 (取数组成员数 (模块信息))

.子程序 进程_按用户名枚举进程, 整数型, 公开, 枚举在不同用户上下文中运行的进程
    .参数 用户名, 文本型, , SYSTEM
    .参数 进程ID数组, 整数型, 参考 数组

    返回 (进程_按用户名枚举进程W (编码_Ansi到Unicode (用户名, ), 进程ID数组))

.子程序 进程_按用户名枚举进程W, 整数型, 公开, 枚举在不同用户上下文中运行的进程
    .参数 用户名, 字节集, , SYSTEM
    .参数 进程ID数组, 整数型, 参考 数组
    .局部变量 pProcessInfo, 整数型, , , PWTS_PROCESS_INFO
    .局部变量 dwCount, 整数型
    .局部变量 pUserSid, 整数型
    .局部变量 dwProcessId, 整数型, , , ProcessId
    .局部变量 pwszName, 整数型
    .局部变量 dwNameSize, 整数型
    .局部变量 pwszDomainName, 整数型
    .局部变量 dwDomainNameSize, 整数型
    .局部变量 snu, 整数型
    .局部变量 i, 整数型

    清除数组 (进程ID数组)
    .如果真 (WTSEnumerateProcessesW (#NULL, 0, 1, pProcessInfo, dwCount))
        .变量循环首 (0, dwCount － 1, 1, i)
            pUserSid ＝ __get (pProcessInfo ＋ i × 16, 12)
            dwNameSize ＝ 0
            dwDomainNameSize ＝ 0
            LookupAccountSidW (#NULL, pUserSid, #NULL, dwNameSize, #NULL, dwDomainNameSize, snu)
            .如果真 (dwNameSize ＞ 0 且 dwDomainNameSize ＞ 0)
                pwszName ＝ LocalAlloc (#LMEM_ZEROINIT, (dwNameSize ＋ 1) × 2)
                pwszDomainName ＝ LocalAlloc (#LMEM_ZEROINIT, (dwDomainNameSize ＋ 1) × 2)
                .如果真 (pwszName ≠ #NULL 且 pwszDomainName ≠ #NULL)
                    .如果真 (LookupAccountSidW (#NULL, pUserSid, pwszName, dwNameSize, pwszDomainName, dwDomainNameSize, snu))
                        .如果真 (lstrcmpiW (pwszName, 用户名 ＋ { 0, 0 }) ＝ 0)
                            dwProcessId ＝ __get (pProcessInfo ＋ i × 16, 4)
                            加入成员 (进程ID数组, dwProcessId)
                        .如果真结束
                        
                    .如果真结束
                    
                .如果真结束
                .如果真 (pwszName ≠ #NULL)
                    LocalFree (pwszName)
                .如果真结束
                .如果真 (pwszDomainName ≠ #NULL)
                    LocalFree (pwszDomainName)
                .如果真结束
                
            .如果真结束
            
        .变量循环尾 ()
        WTSFreeMemory (pProcessInfo)
    .如果真结束
    返回 (取数组成员数 (进程ID数组))

.子程序 进程_取内存占用, 长整数型, 公开, 返回占用页的大小，以字节为单位。
    .参数 进程ID, 整数型
    .局部变量 PerformanceInformation, PERFORMANCE_INFORMATION
    .局部变量 dwSize, 整数型
    .局部变量 hProcess, 整数型
    .局部变量 dwCount, 整数型
    .局部变量 pwsi, 整数型
    .局部变量 dwFlags, 整数型
    .局部变量 i, 整数型
    .局部变量 n, 整数型

    dwSize ＝ 56 ' sizeof(PERFORMANCE_INFORMATION)
    PerformanceInformation.cb ＝ dwSize
    .如果真 (GetPerformanceInfo (PerformanceInformation, dwSize))
        hProcess ＝ OpenProcess (位或 (#PROCESS_VM_READ, #PROCESS_QUERY_INFORMATION), 0, 进程ID)
        .如果真 (hProcess ≠ #NULL)
            QueryWorkingSet (hProcess, 取指针整数_ (dwCount), 4)
            dwSize ＝ 4 ＋ dwCount × 4 ' sizeof(PSAPI_WORKING_SET_BLOCK)
            pwsi ＝ HeapAlloc (GetProcessHeap (), #HEAP_ZERO_MEMORY, dwSize)
            .如果真 (pwsi ≠ #NULL)
                __set (pwsi, 0, dwCount)
                .如果真 (QueryWorkingSet (hProcess, pwsi, dwSize))
                    dwCount ＝ __get (pwsi, 0)
                    .计次循环首 (dwCount, i)
                        dwFlags ＝ __get (pwsi, i × 4)
                        .如果真 (位与 (dwFlags, 256) ＝ 0)
                            n ＝ n ＋ 1
                        .如果真结束
                        
                    .计次循环尾 ()
                .如果真结束
                HeapFree (GetProcessHeap (), 0, pwsi)
            .如果真结束
            CloseHandle (hProcess)
        .如果真结束
        
    .如果真结束
    返回 (到长整数 (n × PerformanceInformation.PageSize))

.子程序 线程_DLL注入, 逻辑型, 公开, 创建远程线程注入DLL到目标进程
    .参数 目标进程ID, 整数型, , 要注入的进程ID
    .参数 要注入的DLL文件名, 文本型, , DLL名称
    .局部变量 hProcess, 整数型
    .局部变量 dwSize, 整数型
    .局部变量 pMem, 整数型
    .局部变量 pAddress, 整数型
    .局部变量 hThread, 整数型
    .局部变量 hDllModule, 整数型

    hProcess ＝ OpenProcess (#PROCESS_ALL_ACCESS, 0, 目标进程ID)
    .如果真 (hProcess ≠ #NULL)
        dwSize ＝ 取文本长度 (要注入的DLL文件名) ＋ 1
        pMem ＝ VirtualAllocEx (hProcess, #NULL, dwSize, #MEM_COMMIT, #PAGE_READWRITE)
        .如果真 (pMem ≠ #NULL)
            WriteProcessMemory_字节集 (hProcess, pMem, 到字节集 (要注入的DLL文件名) ＋ { 0 }, dwSize, #NULL)
            pAddress ＝ GetProcAddress (GetModuleHandleA (“Kernel32.dll”), “LoadLibraryA”)
            hThread ＝ CreateRemoteThread (hProcess, #NULL, 0, pAddress, pMem, 0, #NULL)
            .如果真 (hThread ≠ #NULL)
                WaitForSingleObject (hThread, #INFINITE)
                GetExitCodeThread (hThread, hDllModule)
                CloseHandle (hThread)
            .如果真结束
            VirtualFreeEx (hProcess, pMem, 0, #MEM_RELEASE)
        .如果真结束
        CloseHandle (hProcess)
    .如果真结束
    返回 (hDllModule ≠ #NULL)

.子程序 线程_DLL卸载, 逻辑型, 公开, 卸载目标进程中指定的DLL！注意，DLL不能是易语言原生编译的，否则调用该命令可能导致崩溃！
    .参数 目标进程ID, 整数型
    .参数 要注入的卸载文件名, 文本型
    .局部变量 hProcess, 整数型
    .局部变量 dwSize, 整数型
    .局部变量 pMem, 整数型
    .局部变量 pAddress, 整数型
    .局部变量 hThread, 整数型
    .局部变量 hDllModule, 整数型
    .局部变量 dwExitCode, 整数型

    hProcess ＝ OpenProcess (#PROCESS_ALL_ACCESS, 0, 目标进程ID)
    .如果真 (hProcess ≠ #NULL)
        dwSize ＝ 取文本长度 (要注入的卸载文件名) ＋ 1
        pMem ＝ VirtualAllocEx (hProcess, #NULL, dwSize, #MEM_COMMIT, #PAGE_READWRITE)
        .如果真 (pMem ≠ #NULL)
            WriteProcessMemory_字节集 (hProcess, pMem, 到字节集 (要注入的卸载文件名) ＋ { 0 }, dwSize, #NULL)
            pAddress ＝ GetProcAddress (GetModuleHandleA (“Kernel32.dll”), “GetModuleHandleA”)
            hThread ＝ CreateRemoteThread (hProcess, #NULL, 0, pAddress, pMem, 0, #NULL)
            .如果真 (hThread ≠ #NULL)
                WaitForSingleObject (hThread, #INFINITE)
                GetExitCodeThread (hThread, hDllModule)
                CloseHandle (hThread)
            .如果真结束
            VirtualFreeEx (hProcess, pMem, 0, #MEM_RELEASE)
            .如果真 (hDllModule ≠ #NULL)
                pAddress ＝ GetProcAddress (GetModuleHandleA (“Kernel32.dll”), “FreeLibrary”)
                hThread ＝ CreateRemoteThread (hProcess, #NULL, 0, pAddress, hDllModule, 0, #NULL)
                .如果真 (hThread ≠ #NULL)
                    WaitForSingleObject (hThread, #INFINITE)
                    GetExitCodeThread (hThread, dwExitCode)
                    CloseHandle (hThread)
                .如果真结束
                
            .如果真结束
            
        .如果真结束
        CloseHandle (hProcess)
    .如果真结束
    返回 (dwExitCode ＝ 1) ' TRUE

.子程序 线程_远程调用DLL命令, 逻辑型, 公开, 远程创建线程执行DLL命令
    .参数 目标进程ID, 整数型
    .参数 远程DLL文件名, 文本型, , 完整路径
    .参数 函数名, 文本型
    .参数 回调函数, 整数型, 可空, void ThreadProc(hProcess, lParam, dwFlags)
    .局部变量 szDllName, 文本型
    .局部变量 hDllModule, 整数型
    .局部变量 pFuncAddr, 整数型
    .局部变量 hProcess, 整数型
    .局部变量 aryBin, 字节集
    .局部变量 nMaxCount, 整数型
    .局部变量 pMem, 整数型
    .局部变量 hThread, 整数型
    .局部变量 aryPtr, 整数型, , "0"
    .局部变量 dwCount, 整数型
    .局部变量 i, 整数型

    szDllName ＝ 文件_取文件名 (远程DLL文件名, 真)
    hDllModule ＝ LoadLibraryA (远程DLL文件名)
    .如果真 (hDllModule ＝ #NULL)
        返回 (假)
    .如果真结束
    pFuncAddr ＝ GetProcAddress (hDllModule, 函数名)
    FreeLibrary (hDllModule)
    .如果真 (pFuncAddr ＝ #NULL)
        返回 (假)
    .如果真结束
    hProcess ＝ OpenProcess (#PROCESS_ALL_ACCESS, 0, 目标进程ID)
    .如果真 (hProcess ≠ #NULL)
        .如果真 (回调函数 ≠ #NULL)
            调用子程序_ (回调函数, hProcess, 取指针_通用型_数组 (aryPtr), #DLL_PROCESS_ATTACH, , , , , , , , , , , , )
            dwCount ＝ 取数组成员数 (aryPtr)
            .变量循环首 (dwCount, 1, -1, i)
                aryBin ＝ aryBin ＋ { 104 } ＋ 到字节集 (aryPtr [i])
            .变量循环尾 ()
        .如果真结束
        aryBin ＝ aryBin ＋ { 184 } ＋ 到字节集 (pFuncAddr) ＋ { 255, 208, 195 }
        nMaxCount ＝ 取字节集长度 (aryBin)
        pMem ＝ VirtualAllocEx (hProcess, #NULL, nMaxCount, #MEM_COMMIT, #PAGE_READWRITE)
        .如果真 (pMem ≠ #NULL)
            WriteProcessMemory_字节集 (hProcess, pMem, aryBin, nMaxCount, #NULL)
            hThread ＝ CreateRemoteThread (hProcess, #NULL, 0, pMem, #NULL, 0, #NULL)
            .如果真 (hThread ≠ #NULL)
                WaitForSingleObject (hThread, #INFINITE)
                .如果真 (回调函数 ≠ #NULL)
                    调用子程序_ (回调函数, hProcess, 取指针_通用型_数组 (aryPtr), #DLL_PROCESS_DETACH, , , , , , , , , , , , )
                .如果真结束
                CloseHandle (hThread)
            .如果真结束
            VirtualFreeEx (hProcess, pMem, 0, #MEM_RELEASE)
        .如果真结束
        CloseHandle (hProcess)
    .如果真结束
    返回 (真)

.子程序 线程_取中止线程退出代码, 整数型, 公开, 返回0表示该线程不存在(或句柄已被关闭),1线程已经执行完毕，2为正在运行,其他不论
    .参数 线程句柄, 整数型
    .局部变量 返回值, 整数型

    .判断开始 (GetExitCodeThread (线程句柄, 返回值) ＝ 0)
        返回 (0)
    .判断 (返回值 ＝ 259)
        返回 (2)
    .默认
        返回 (1)
    .判断结束
    

.子程序 线程_打开, 整数型, 公开, 成功返回线程句柄，失败返回0
    .参数 线程ID, 整数型, 可空, 目标线程ID

    返回 (OpenThread (2032639, 0, 线程ID))

.子程序 线程_取自线程ID, 整数型, 公开, GetCurrentThreadId,获取当前线程一个唯一的线程标识符
    返回 (GetCurrentThreadId ())

.子程序 线程_取自线程句柄, 整数型, 公开, GetCurrentThread,获取当前线程的一个伪句柄
    返回 (GetCurrentThread ())

.子程序 线程_初始化COM库, , 公开, 有时执行线程的时候，会自动关闭，此时，可以在多线程的程序里创建COM对象前先初始化，一个线程只能调用一次
    CoInitialize (0)

.子程序 线程_取消COM库, , 公开, 取消COM库的初始化，如果你在线程头部加入了 线程_初始化COM库 请在尾部加入此命令
    CoUninitialize ()

.子程序 线程_取ID, 整数型, 公开, 成功返回指定窗口的线程ID
    .参数 窗口句柄, 整数型, , 指定窗口句柄
    .局部变量 进程ID, 整数型, , , 用于装载进程ID的变量

    返回 (GetWindowThreadProcessId (窗口句柄, 进程ID))

.子程序 线程_销毁, 逻辑型, 公开, 强制终止正在运行的线程,成功返回真,失败返回假.
    .参数 线程句柄, 整数型, , 创建线程返回的句柄
    .局部变量 lpExitCode, 整数型

    GetExitCodeThread (线程句柄, lpExitCode)
    返回 (TerminateThread (线程句柄, lpExitCode))

.子程序 线程_关闭句柄, 逻辑型, 公开, 关闭一个线程句柄，关闭后线程继续运行，但无法对该句柄进行操作。
    .参数 线程句柄

    返回 (CloseHandle (线程句柄))

.子程序 线程_启动, 整数型, 公开, 成功返回线程句柄，失败返回0
    .参数 要启动的子程序, 子程序指针
    .参数 要传去子程序的参数, 整数型, 可空, 往子程序里面传递一个整数型的参数
    .参数 线程ID, 整数型, 参考 可空, 请提供一个整数型的变量，用于存放新创建的线程ID。

    返回 (CreateThread (0, 0, 到整数 (要启动的子程序), 要传去子程序的参数, 0, 取指针_通用型 (线程ID)))

.子程序 线程_启动1, 整数型, 公开, 成功返回线程句柄，失败返回0
    .参数 要启动的子程序, 整数型, , 如果是子程序指针，请直接使用到数值() 命令进行转换后再传入
    .参数 要传去子程序的参数, 整数型, 可空, 往子程序里面传递一个整数型的参数
    .参数 线程ID, 整数型, 参考 可空, 请提供一个整数型的变量，用于存放新创建的线程ID。

    返回 (CreateThread (0, 0, 要启动的子程序, 要传去子程序的参数, 0, 取指针_通用型 (线程ID)))

.子程序 线程_启动2, 逻辑型, 公开, 成功返回真，失败返回假。[Mr.Yang]
    .参数 要启动的子程序, 子程序指针
    .参数 要传去子程序的参数, 整数型, 可空, 往子程序里面传递一个整数型的参数
    .参数 线程句柄, 整数型, 参考 可空, 请提供一个整数型的变量，用于存放新创建的线程句柄
    .参数 线程ID, 整数型, 参考 可空, 请提供一个整数型的变量，用于存放新创建的线程ID。

    线程句柄 ＝ CreateThread (0, 0, 到整数 (要启动的子程序), 要传去子程序的参数, 0, 取指针_通用型 (线程ID))
    .如果真 (是否为空 (线程句柄))
        CloseHandle (线程句柄)
    .如果真结束
    .如果 (线程句柄 ≠ 0)
        返回 (真)
    .否则
        返回 (假)
    .如果结束
    

.子程序 线程_启动多参_整数型, 整数型, 公开, 成功返回线程句柄，失败返回0。
    .参数 子程序指针, 子程序指针
    .参数 参数1, 整数型, 可空, 线程传入参数1
    .参数 参数2, 整数型, 可空, 线程传入参数2
    .参数 参数3, 整数型, 可空, 线程传入参数3
    .参数 参数4, 整数型, 可空, 线程传入参数4
    .参数 参数5, 整数型, 可空, 线程传入参数5
    .参数 线程ID, 整数型, 参考 可空, 请提供一个整数型的变量，用于存放新创建的线程ID。
    .局部变量 pDataArray, 整数型
    .局部变量 hThread, 整数型

    pDataArray ＝ LocalAlloc (#LMEM_ZEROINIT, 24) ' sizeof(void*) * 6
    .如果真 (pDataArray ≠ #NULL)
        __set (pDataArray, 0, 到整数 (子程序指针))
        __set (pDataArray, 4, 参数1)
        __set (pDataArray, 8, 参数2)
        __set (pDataArray, 12, 参数3)
        __set (pDataArray, 16, 参数4)
        __set (pDataArray, 20, 参数5)
        hThread ＝ CreateThread (#NULL, 0, 到整数 (&ThreadParamFunc), pDataArray, 0, 取指针整数_ (线程ID))
    .如果真结束
    返回 (hThread)

.子程序 线程_启动多参_文本型, 整数型, 公开, 成功返回线程句柄，失败返回0。
    .参数 子程序指针, 子程序指针
    .参数 整数1, 整数型, 可空, 线程传入参数1
    .参数 文本1, 文本型, 可空, 线程传入参数2
    .参数 文本2, 文本型, 可空, 线程传入参数3
    .参数 文本3, 文本型, 可空, 线程传入参数4
    .参数 文本4, 文本型, 可空, 线程传入参数5
    .参数 线程ID, 整数型, 参考 可空, 请提供一个整数型的变量，用于存放新创建的线程ID。
    .局部变量 pdwSize, 整数型
    .局部变量 dwSize, 整数型
    .局部变量 pDataArray, 整数型
    .局部变量 hThread, 整数型
    .局部变量 i, 整数型

    pdwSize ＝ LocalAlloc (#LMEM_ZEROINIT, 16) ' sizeof(void*) * 4
    .如果真 (pdwSize ≠ #NULL)
        __set (pdwSize, 0, 取文本长度 (文本1))
        __set (pdwSize, 4, 取文本长度 (文本2))
        __set (pdwSize, 8, 取文本长度 (文本3))
        __set (pdwSize, 12, 取文本长度 (文本4))
        .变量循环首 (0, 3, 1, i)
            .如果真 (__get (pdwSize, i × 4) ＞ 0)
                dwSize ＝ dwSize ＋ 1
            .如果真结束
            dwSize ＝ dwSize ＋ __get (pdwSize, i × 4)
        .变量循环尾 ()
        pDataArray ＝ LocalAlloc (#LMEM_ZEROINIT, 24 ＋ dwSize) ' sizeof(void*) * 6 + dwSize
        .如果真 (pDataArray ≠ #NULL)
            __set (pDataArray, 0, 到整数 (子程序指针))
            __set (pDataArray, 4, 整数1)
            dwSize ＝ 24 ' 偏移
            .如果真 (__get (pdwSize, 0) ＞ 0)
                memcpy (pDataArray ＋ dwSize, 取指针_文本型 (文本1), __get (pdwSize, 0))
                __set (pDataArray, 8, pDataArray ＋ dwSize)
                dwSize ＝ dwSize ＋ __get (pdwSize, 0) ＋ 1
            .如果真结束
            .如果真 (__get (pdwSize, 4) ＞ 0)
                memcpy (pDataArray ＋ dwSize, 取指针_文本型 (文本2), __get (pdwSize, 4))
                __set (pDataArray, 12, pDataArray ＋ dwSize)
                dwSize ＝ dwSize ＋ __get (pdwSize, 4) ＋ 1
            .如果真结束
            .如果真 (__get (pdwSize, 8) ＞ 0)
                memcpy (pDataArray ＋ dwSize, 取指针_文本型 (文本3), __get (pdwSize, 8))
                __set (pDataArray, 16, pDataArray ＋ dwSize)
                dwSize ＝ dwSize ＋ __get (pdwSize, 8) ＋ 1
            .如果真结束
            .如果真 (__get (pdwSize, 12) ＞ 0)
                memcpy (pDataArray ＋ dwSize, 取指针_文本型 (文本4), __get (pdwSize, 12))
                __set (pDataArray, 20, pDataArray ＋ dwSize)
                dwSize ＝ dwSize ＋ __get (pdwSize, 12) ＋ 1
            .如果真结束
            hThread ＝ CreateThread (#NULL, 0, 到整数 (&ThreadParamFunc), pDataArray, 0, 取指针整数_ (线程ID))
        .如果真结束
        LocalFree (pdwSize)
    .如果真结束
    返回 (hThread)

.子程序 ThreadParamFunc, 整数型
    .参数 pDataArray, 整数型

    .如果真 (pDataArray ≠ #NULL)
        调用子程序_ (__get (pDataArray, 0), __get (pDataArray, 4), __get (pDataArray, 8), __get (pDataArray, 12), __get (pDataArray, 16), __get (pDataArray, 20), , , , , , , , , , )
        LocalFree (pDataArray)
    .如果真结束
    返回 (0)

.子程序 内部_处理线程参数, 整数型, , 返回线程句柄（传递栈指针 -> 参数数量 -> 标志 -> 内部处理参数 -> 创建一条线程）
    .参数 ebp, 整数型, , 栈地址
    .参数 num, 整数型, , 第几个参数是传入线程的参数，增加这么一个参数主要是方便增加参数，注意：增加的参数必须有可空标志。
    .参数 nCount, 整数型, , 参数数量
    .参数 nFlag, 整数型, , 参数值可以为以下常量： 1、#字节型； 2、#短整数型； 3、#整数型； 4、#长整数型； 5、#小数型； 6、#双精度小数型； 7、#逻辑型； 8、#日期时间型； 9、#子程序指针型； 10、#文本型。
    .局部变量 i, 整数型
    .局部变量 offset, 整数型, , , 栈参数偏移
    .局部变量 pAddr, 整数型, , , 参数栈地址
    .局部变量 pMem, 整数型, , , 作为参数传递过去的内存地址
    .局部变量 pArg, 整数型, , , 参数内存地址
    .局部变量 dwStrLen, 整数型, , , 文本长度
    .局部变量 tid, 整数型
    .局部变量 hThread, 整数型
    .局部变量 nTmp, 整数型

    .如果真 (ebp ＝ 0 或 __get (ebp, 8) ＝ 0)
        返回 (0)
    .如果真结束
    ' pMem 结构 +0=参数数量, +4=是否需要释放参数内存,+8=被调用的子程序
    ' +12第一个参数数据类型 +16第一个参数数据
    ' +20 第二个参数数据类型 +24第二个参数数据....以此类推
    .判断开始 (nFlag ＝ #整数型 或 nFlag ＝ #短整数型 或 nFlag ＝ #字节型 或 nFlag ＝ #子程序指针型 或 nFlag ＝ #逻辑型 或 nFlag ＝ #小数型)
        pMem ＝ LocalAlloc (#LMEM_ZEROINIT, nCount × 2 × 4 ＋ 12)
        __set (pMem, 4, 0) ' 不需要释放内存
        nFlag ＝ #整数型
    .判断 (nFlag ＝ #双精度小数型 或 nFlag ＝ #日期时间型 或 nFlag ＝ #长整数型)
        pMem ＝ LocalAlloc (#LMEM_ZEROINIT, nCount × 8 ＋ 12 ＋ nCount × 4)
        __set (pMem, 4, 0) ' 不需要释放内存
        nFlag ＝ #长整数型
    .判断 (nFlag ＝ #文本型 或 nFlag ＝ #字节集型)
        pMem ＝ LocalAlloc (#LMEM_ZEROINIT, nCount × 4 × 2 ＋ 12)
        __set (pMem, 4, 1) ' 需要释放内存
    .默认
        返回 (0)
    .判断结束
    __set (pMem, 8, __get (ebp, 8)) ' 记录被执行的子程序
    
    .计次循环首 (nCount, i) ' 有几个参数就循环几次
        ' 这里的ebp结构为,每个成员占4字节
        ' 有可空标志的在栈里占用8个字节,前4个是参数,后4个标记是否为空,1为非空 0为空
        ' 0 栈地址
        ' 4 返回地址
        ' 8 第一个参数地址
        ' 12 第二个参数地址
        ' 16 第二个参数是否为空
        ' 20 第三个参数
        ' 24 第三个参数是否为空,后面的都是这样
        offset ＝ (i ＋ num － 1) × 8 － 4 ' 这里从指定参数开始取,不明白怎么计算偏移的请仔细看上面的备注
        .如果真 (指针_到整数 (ebp ＋ offset ＋ 4) ＝ 0) ' 参数为空,不继续取后面的参数
            跳出循环 ()
        .如果真结束
        ' 走到这里表示参数不为空,取出参数的栈地址
        pAddr ＝ __get (ebp, offset) ' 这里取到的是栈地址
        ' pMem结构 +0=参数数量, +4=是否需要释放参数内存,+8=被调用的子程序
        ' +12第一个参数数据类型 +16第一个参数数据
        ' +20 第二个参数数据类型 +24第二个参数数据....以此类推
        .判断开始 (nFlag ＝ #整数型) ' 整数
            __set (pMem, i × 8 ＋ 4, #整数型) ' 其实这个要不要都无所谓,没用到,感觉有点浪费内存了,不过占用不是特别多,几百个字节而已
            __set (pMem, i × 8 ＋ 8, __get (pAddr, 0)) ' 第一次取到的是栈地址,需要取堆地址
        .判断 (nFlag ＝ #长整数型) ' 8字节
            nTmp ＝ i × 16 ' 8字节的每次递增两个参数的长度
            ' 长整数还得分别写入才行,因为格式是 数据类型,实际数据,不能直接拷贝8字节存进去
            __set (pMem, nTmp － 4, #长整数型)
            __set (pMem, nTmp ＋ 0, __get (pAddr, 0)) ' 取出低位 存到当前参数位置里
            __set (pMem, nTmp ＋ 4, #长整数型)
            __set (pMem, nTmp ＋ 8, __get (pAddr, 4)) ' 取出高位 存到下一个参数位置里
        .默认
            ' 文本和字节集都一起处理,在这里判断是文本还是字节集
            pAddr ＝ __get (pAddr, 0) ' 取堆地址
            .如果真 (pAddr ＝ 0)
                __set (pMem, i × 8 ＋ 4, #整数型) ' 为0那这个参数就传递0 当成整数传递
                __set (pMem, i × 8 ＋ 8, 0) ' 记录参数为0
                到循环尾 ()
            .如果真结束
            .如果真 (__get (pAddr － 8, 0) ＝ 1) ' 用户传的可能是堆地址,取数据_通用型()取到的值,只针对字节集
                pAddr ＝ pAddr － 8
            .如果真结束
            .判断开始 (__get (pAddr, 0) ＝ 1) ' 字节集格式 {1,0,0,0,长度}
                dwStrLen ＝ __get (pAddr ＋ 4, 0)
                pArg ＝ LocalAlloc (#LMEM_ZEROINIT, dwStrLen ＋ 8) ' 申请一块内存,保存参数数据,需要多8个字节,模拟E字节集结构
                __set (pArg, 0, 1)
                __set (pArg, 4, dwStrLen)
                RtlMoveMemory (pArg ＋ 8, pAddr ＋ 8, dwStrLen)
                __set (pMem, i × 8 ＋ 4, #字节集型) ' 记录这个参数为字节集型,在释放内存的时候会用到
                __set (pMem, i × 8 ＋ 8, pArg ＋ 8)
            .默认
                dwStrLen ＝ lstrlenA (pAddr)
                pArg ＝ LocalAlloc (#LMEM_ZEROINIT, dwStrLen ＋ 1) ' 申请一块内存,保存参数数据,文本需要多一个字节保存\0
                RtlMoveMemory (pArg, pAddr, dwStrLen)
                __set (pMem, i × 8 ＋ 4, #文本型) ' 记录这个参数为文本型,在释放内存的时候会用到
                __set (pMem, i × 8 ＋ 8, pArg)
            .判断结束
            
        .判断结束
        
    .计次循环尾 ()
    i ＝ i － 1 ' 不管是跳出循环 还是循环执行完,这个值都比参数数量多1
    .如果真 (nFlag ＝ #长整数型)
        ' 8字节算是两个参数,比如 子程序(长整数型) 那在子程序1里可以填两个整数型参数,或者一个长整数型参数,长整数8个字节64位
        ' 如果填写的是两个整数型参数的话,那么参数1就是这个长整数的低32位,参数2是高32位,参数3就是传入的下一个参数
        i ＝ i × 2 ' 如果能看懂下面的例子,就知道这里为什么要 *2 了
    .如果真结束
    __set (pMem, 0, i) ' 记录参数数量
    
    .如果真 (__get (ebp, 16) ＝ 1) ' 判断 "创建后挂起" 这个参数是否为空, =1表示不为空
        ' 第二个参数是 创建后挂起
        .判断开始 (__get (ebp, 12) ＝ 1) ' 判断 "创建后挂起" 这个参数是真还是假  =1就是填了真
            nTmp ＝ #CREATE_SUSPENDED ' 创建线程后挂起线程
        .默认
            nTmp ＝ 0 ' 填真的话就设置线程标志为0,立即启动
        .判断结束
        
    .如果真结束
    
    hThread ＝ CreateThread (0, 0, 到整数 (&内部_多参线程处理), pMem, nTmp, 取指针_通用型 (tid))
    .如果真 (__get (ebp, 24) ＝ 1) ' 第三个参数 "线程ID" 是否为空 =1不为空
        __set (__get (ebp, 20), 0, tid) ' 不为空就取出参数地址,并写入线程ID
    .如果真结束
    返回 (hThread)

.子程序 内部_多参线程处理, 整数型
    .参数 pMem, 整数型, , 前面处理参数后的这个内存
    .局部变量 i, 整数型
    .局部变量 arg, 整数型, , "0", 参数组
    .局部变量 ret, 整数型
    .局部变量 flag, 整数型, , , 是否需要释放参数内存
    .局部变量 dwLen, 整数型, , , 参数数量

    ' 参数位置从12开始记录,+0记录参数数量,+4记录是否需要释放内存,+8记录要执行的子程序,再下来才是参数数据
    ' 参数数据结构 数据类型,实际数据
    flag ＝ __get (pMem, 4)
    dwLen ＝ __get (pMem, 0)
    重定义数组 (arg, 假, dwLen)
    .计次循环首 (dwLen, i)
        arg [i] ＝ __get (pMem, i × 8 ＋ 8) ' 取出参数地址
    .计次循环尾 ()
    ret ＝ 调用子程序_数组 (__get (pMem, 8), arg, )
    .如果真 (flag ＞ 0)
        .计次循环首 (dwLen, i)
            .判断开始 (__get (pMem, i × 8 ＋ 4) ＝ #字节集型) ' 每个参数都记录数据类型,字节集需要-8
                LocalFree (arg [i] － 8)
            .默认
                LocalFree (arg [i])
            .判断结束
            
        .计次循环尾 ()
    .如果真结束
    LocalFree (pMem) ' 这个内存是必须释放的
    返回 (ret)

.子程序 线程_启动_文本型, 整数型, 公开, 成功返回线程句柄，失败返回0；只允许传入文本或字节集，堆指针。
    .参数 欲执行的子程序, 整数型, , 到整数 (&欲执行的子程序)
    .参数 创建后是否挂起线程, 逻辑型, 可空, 默认为假
    .参数 线程ID, 整数型, 参考 可空, 接收线程ID
    .参数 参数1, 通用型, 参考 可空, 只允许传入文本或字节集
    .参数 参数2, 通用型, 参考 可空, 只允许传入文本或字节集
    .参数 参数3, 通用型, 参考 可空, 只允许传入文本或字节集
    .参数 参数4, 通用型, 参考 可空, 只允许传入文本或字节集
    .参数 参数5, 通用型, 参考 可空, 只允许传入文本或字节集
    .参数 参数6, 通用型, 参考 可空, 只允许传入文本或字节集
    .参数 参数7, 通用型, 参考 可空, 只允许传入文本或字节集
    .参数 参数8, 通用型, 参考 可空, 只允许传入文本或字节集
    .参数 参数9, 通用型, 参考 可空, 只允许传入文本或字节集
    .参数 参数10, 通用型, 参考 可空, 只允许传入文本或字节集
    .局部变量 ebp, 整数型, , , 不要对这个变量进行赋值操作

    置入代码 ({ 137, 109, 252 }) ' 把ebp保存到变量里
    .如果真 (ebp ＝ 0)
        返回 (0)
    .如果真结束
    返回 (内部_处理线程参数 (ebp, 4, 10, #文本型)) ' 第4个参数开始是需要传到子程序里，这里有10个参数。

.子程序 线程_启动_4字节, 整数型, 公开, 成功返回线程句柄，失败返回0；只允许传入整数型、短整数型、字节型、逻辑型、子程序指针、小数型，所有参数必须是4字节。
    .参数 欲执行的子程序, 整数型, , 到整数 (&欲执行的子程序)
    .参数 创建后是否挂起线程, 逻辑型, 可空, 默认为假
    .参数 线程ID, 整数型, 参考 可空, 接收线程ID
    .参数 参数1, 通用型, 参考 可空, 只允许传入整数型、短整数型、字节型、逻辑型、子程序指针、小数型，所有参数必须是4字节。
    .参数 参数2, 通用型, 参考 可空, 只允许传入整数型、短整数型、字节型、逻辑型、子程序指针、小数型，所有参数必须是4字节。
    .参数 参数3, 通用型, 参考 可空, 只允许传入整数型、短整数型、字节型、逻辑型、子程序指针、小数型，所有参数必须是4字节。
    .参数 参数4, 通用型, 参考 可空, 只允许传入整数型、短整数型、字节型、逻辑型、子程序指针、小数型，所有参数必须是4字节。
    .参数 参数5, 通用型, 参考 可空, 只允许传入整数型、短整数型、字节型、逻辑型、子程序指针、小数型，所有参数必须是4字节。
    .参数 参数6, 通用型, 参考 可空, 只允许传入整数型、短整数型、字节型、逻辑型、子程序指针、小数型，所有参数必须是4字节。
    .参数 参数7, 通用型, 参考 可空, 只允许传入整数型、短整数型、字节型、逻辑型、子程序指针、小数型，所有参数必须是4字节。
    .参数 参数8, 通用型, 参考 可空, 只允许传入整数型、短整数型、字节型、逻辑型、子程序指针、小数型，所有参数必须是4字节。
    .参数 参数9, 通用型, 参考 可空, 只允许传入整数型、短整数型、字节型、逻辑型、子程序指针、小数型，所有参数必须是4字节。
    .参数 参数10, 通用型, 参考 可空, 只允许传入整数型、短整数型、字节型、逻辑型、子程序指针、小数型，所有参数必须是4字节。
    .局部变量 ebp, 整数型, , , 不要对这个变量进行赋值操作

    置入代码 ({ 137, 109, 252 }) ' 把ebp保存到变量里
    .如果真 (ebp ＝ 0)
        返回 (0)
    .如果真结束
    返回 (内部_处理线程参数 (ebp, 4, 10, #整数型)) ' 第4个参数开始是需要传到子程序里，这里有10个参数。

.子程序 线程_启动_8字节, 整数型, 公开, 成功返回线程句柄，失败返回0；只允许传入双精度小数型、日期时间型、长整数型，所有参数必须是8字节。
    .参数 欲执行的子程序, 整数型, , 到整数 (&欲执行的子程序)
    .参数 创建后是否挂起线程, 逻辑型, 可空, 默认为假
    .参数 线程ID, 整数型, 参考 可空, 接收线程ID
    .参数 参数1, 通用型, 参考 可空, 只允许传入双精度小数型、日期时间型、长整数型，所有参数必须是8字节
    .参数 参数2, 通用型, 参考 可空, 只允许传入双精度小数型、日期时间型、长整数型，所有参数必须是8字节
    .参数 参数3, 通用型, 参考 可空, 只允许传入双精度小数型、日期时间型、长整数型，所有参数必须是8字节
    .参数 参数4, 通用型, 参考 可空, 只允许传入双精度小数型、日期时间型、长整数型，所有参数必须是8字节
    .参数 参数5, 通用型, 参考 可空, 只允许传入双精度小数型、日期时间型、长整数型，所有参数必须是8字节
    .参数 参数6, 通用型, 参考 可空, 只允许传入双精度小数型、日期时间型、长整数型，所有参数必须是8字节
    .参数 参数7, 通用型, 参考 可空, 只允许传入双精度小数型、日期时间型、长整数型，所有参数必须是8字节
    .参数 参数8, 通用型, 参考 可空, 只允许传入双精度小数型、日期时间型、长整数型，所有参数必须是8字节
    .参数 参数9, 通用型, 参考 可空, 只允许传入双精度小数型、日期时间型、长整数型，所有参数必须是8字节
    .参数 参数10, 通用型, 参考 可空, 只允许传入双精度小数型、日期时间型、长整数型，所有参数必须是8字节
    .局部变量 ebp, 整数型, , , 不要对这个变量进行赋值操作

    ' 通用型参数最好打上参考，不然8字节的变量参数就占用8个字节，不好计算，打上参考的话，每个参数占4字节，因为传的是指针
    置入代码 ({ 137, 109, 252 }) ' 把ebp保存到变量里
    .如果真 (ebp ＝ 0)
        返回 (0)
    .如果真结束
    返回 (内部_处理线程参数 (ebp, 4, 10, #长整数型)) ' 第4个参数开始是需要传到子程序里，这里有10个参数。

.子程序 线程_创建许可证, 线程许可证, 公开, 创建并返回一个进入许可证数值，此许可证值用作进入程序中的指定许可代码区，以避免多线程冲突
    .局部变量 进入许可证, 线程许可证

    InitializeCriticalSection (进入许可证)
    加入成员 (集_许可证数组, 进入许可证)
    返回 (进入许可证)

.子程序 线程_删除许可证, , 公开, 删除由"创建进入许可证"命令所创建返回的进入许可证(该命令会在本类被销毁时自动被调用)
    .参数 进入许可证, 线程许可证, 可空, 留空则删除所有许可证
    .局部变量 i, 整数型

    .如果 (是否为空 (进入许可证))
        .计次循环首 (取数组成员数 (集_许可证数组), i)
            DeleteCriticalSection (集_许可证数组 [i])
        .计次循环尾 ()
        清除数组 (集_许可证数组)
    .否则
        DeleteCriticalSection (进入许可证)
    .如果结束
    

.子程序 线程_进入许可区, , 公开, 根据已经创建的许可证进入指定许可代码区，在此线程未退出之前，其它线程如要通过同一个进入许可证进入该许可代码区则必须先等待此线程退出许可代码区，从而保证了指定许可代码区在任何时候都只能有一条线程进入并执行
    .参数 进入许可证, 线程许可证

    EnterCriticalSection (进入许可证)

.子程序 线程_退出许可区, , 公开, 指示当前线程将退出许可代码区，并允许其它使用同一进入许可证的线程进入此许可代码区
    .参数 进入许可证, 线程许可证

    LeaveCriticalSection (进入许可证)

.子程序 线程_等待, 逻辑型, 公开, 等待一个线程，返回真表示线程运行结束，返回假表示已超时。
    .参数 线程句柄, 整数型
    .参数 超时, 整数型, 可空, 留空，则无限等待
    .局部变量 ret, 整数型
    .局部变量 时间, 整数型

    .如果真 (超时 ＝ 0)
        超时 ＝ -1
    .如果真结束
    时间 ＝ 取启动时间 ()
    .循环判断首 ()
        ret ＝ MsgWaitForMultipleObjects (1, 线程句柄, 假, 超时, 1215)
        .如果真 (超时 ≠ -1)
            .如果真 (取启动时间 () － 时间 ≥ 超时)
                ret ＝ 258
            .如果真结束
            
        .如果真结束
        处理事件 ()
    .循环判断尾 (ret ≠ 0 且 ret ≠ 258)
    返回 (ret ＝ 0)

.子程序 线程_挂起, 整数型, 公开, 将指定线程的执行挂起,注意，同一个线程可以被挂起多次，如果挂起多次，就要恢复多次。
    .参数 线程句柄, 整数型, , 要等待的线程句柄,用 线程_启动() 返回的;

    返回 (SuspendThread (线程句柄))

.子程序 线程_恢复, 整数型, 公开, 恢复执行挂起的一个线程。
    .参数 线程句柄, 整数型, , 要等待的线程句柄,用 线程_启动() 返回的;

    返回 (ResumeThread (线程句柄))

.子程序 线程_枚举, 整数型, 公开, 枚举指定进程ID中所有线程列表，成功返回线程数量，失败返回零。
    .参数 进程ID, 整数型
    .参数 线程列表, 整数型, 数组, 变量储存返回值。
    .局部变量 局_线程快照
    .局部变量 局_线程信息, 线程入口结构
    .局部变量 局_返回值, 逻辑型

    局_线程快照 ＝ CreateToolhelp32Snapshot (#TH32CS_SNAPTHREAD, 进程ID)
    .如果真 (局_线程快照 ≠ #INVALID_HANDLE_VALUE)
        清除数组 (线程列表)
        局_线程信息.结构大小 ＝ 28
        局_返回值 ＝ Thread32First (局_线程快照, 局_线程信息)
        .判断循环首 (局_返回值)
            .如果真 (局_线程信息.父进程ID ＝ 进程ID)
                加入成员 (线程列表, 局_线程信息.线程ID)
            .如果真结束
            局_返回值 ＝ Thread32Next (局_线程快照, 局_线程信息)
        .判断循环尾 ()
    .如果真结束
    CloseHandle (局_线程快照)
    返回 (取数组成员数 (线程列表))

.子程序 线程_置CPU, 整数型, 公开, 设置线程在指定CPU上运行
    .参数 参_线程句柄, 整数型
    .参数 参_CPU序号, 整数型, , CPU序号的或运算值：1（0001）代表只运行在CPU1，2（0010）代表只运行在CPU2，3（0011）代表可以运行在CPU1和CPU2，以此类推。

    返回 (SetThreadAffinityMask (参_线程句柄, 参_CPU序号))

.子程序 线程_取状态, 整数型, 公开, 0=线程已结束  1=线程正在运行  -1=线程句柄已失效或销毁
    .参数 参_线程句柄, 整数型
    .局部变量 m_WaitCode, 整数型

    m_WaitCode ＝ WaitForSingleObject (参_线程句柄, 0)
    .判断开始 (m_WaitCode ＝ 258)
        返回 (1)
    .判断 (m_WaitCode ＝ -1)
        返回 (-1)
    .默认
        返回 (m_WaitCode)
    .判断结束
    返回 (0)
    

.子程序 线程_取线程信息, 精易_线程信息, 公开, 获取指定线程的入口地址和映射文件的名称
    .参数 线程ID, 整数型
    .局部变量 hThread, 整数型
    .局部变量 lRes, 整数型
    .局部变量 ptbi, 整数型
    .局部变量 ThreadInfo, 精易_线程信息
    .局部变量 hProcess, 整数型

    hThread ＝ OpenThread (#THREAD_QUERY_INFORMATION, 0, 线程ID)
    .如果真 (hThread ≠ #NULL)
        lRes ＝ NtQueryInformationThread (hThread, #ThreadQuerySetWin32StartAddress, 取指针整数_ (ThreadInfo.线程入口), 4, #NULL) ' sizeof(DWORD)
        .如果真 (lRes ＝ #STATUS_SUCCESS 且 ThreadInfo.线程入口 ≠ 0)
            ptbi ＝ LocalAlloc (#LMEM_ZEROINIT, 28) ' sizeof(THREAD_BASIC_INFORMATION)
            .如果真 (ptbi ≠ #NULL)
                lRes ＝ NtQueryInformationThread (hThread, #ThreadBasicInformation, ptbi, 28, #NULL) ' sizeof(THREAD_BASIC_INFORMATION)
                .如果真 (lRes ＝ #STATUS_SUCCESS)
                    ThreadInfo.进程ID ＝ __get (ptbi, 8) ' ClientId.UniqueProcess
                    ThreadInfo.线程ID ＝ __get (ptbi, 12) ' ClientId.UniqueThread
                    hProcess ＝ OpenProcess (#PROCESS_QUERY_INFORMATION, 0, ThreadInfo.进程ID)
                    .如果真 (hProcess ≠ #NULL)
                        ThreadInfo.模块路径 ＝ 取空白文本 (1024)
                        GetMappedFileNameA (hProcess, ThreadInfo.线程入口, ThreadInfo.模块路径, 1024)
                        CloseHandle (hProcess)
                    .如果真结束
                    
                .如果真结束
                LocalFree (ptbi)
            .如果真结束
            
        .如果真结束
        CloseHandle (hThread)
    .如果真结束
    返回 (ThreadInfo)

.版本 2

.程序集 集_进程通信
.程序集变量 集_oldlong, 整数型
.程序集变量 集_标志文本数组, 文本型, , "0"
.程序集变量 集_消息编号数组, 整数型, , "0"
.程序集变量 集_数据数组, 字节集, , "0"
.程序集变量 集_指针数组, 整数型, , "0"
.程序集变量 集_窗口句柄, 整数型

.子程序 进程通信_接收端_初始化, , 公开, 监听前必需调用此子程序，只需使用一次，停止监听前不能再使用此子程序，否则会出错。
    .参数 参数_窗口句柄, 整数型, , 当前窗口句柄，可用 取窗口句柄() 得到。

    集_窗口句柄 ＝ 参数_窗口句柄
    集_oldlong ＝ SetWindowLongA (参数_窗口句柄, -4, 到整数 (&接收端_读数据))

.子程序 进程通信_接收端_开始监听, 逻辑型, 公开, 成功返回真，失败返回假。
    .参数 参数_标志文本, 文本型, , 可以为任意文本(不能为空文本)，但是不要和系统中已有的冲突。设置不同的标志文本，可绑定不同的子程序。
    .参数 参数_回调函数, 子程序指针, 可空, 接收到信息后要触发的子程序，不可多个标志文本绑定同个子程序，不需要可不填。
    .局部变量 局_计次, 整数型

    .如果真 (参数_标志文本 ＝ “”)
        返回 (假)
    .如果真结束
    .计次循环首 (取数组成员数 (集_标志文本数组), 局_计次) ' 判断是否有相同的标识文件存在
        .如果真 (集_标志文本数组 [局_计次] ＝ 参数_标志文本)
            返回 (假)
        .如果真结束
        
    .计次循环尾 () ' 判断是否有相同的标识文件存在
    
    加入成员 (集_消息编号数组, RegisterWindowMessageA (参数_标志文本))
    加入成员 (集_标志文本数组, 参数_标志文本)
    
    .如果真 (集_消息编号数组 [取数组成员数 (集_消息编号数组)] ＝ 0) ' 如果获取的消息编号为0,将其删除;
        删除成员 (集_标志文本数组, 取数组成员数 (集_标志文本数组), )
        删除成员 (集_消息编号数组, 取数组成员数 (集_消息编号数组), )
        返回 (假)
    .如果真结束
    
    .计次循环首 (取数组成员数 (集_消息编号数组) － 1, 局_计次) ' 判断 集_消息编号数组 是否有重复
        .如果真 (集_消息编号数组 [局_计次] ＝ 集_消息编号数组 [取数组成员数 (集_消息编号数组)])
            删除成员 (集_标志文本数组, 取数组成员数 (集_标志文本数组), )
            删除成员 (集_消息编号数组, 取数组成员数 (集_消息编号数组), )
            返回 (假)
        .如果真结束
        
    .计次循环尾 ()
    
    .计次循环首 (取数组成员数 (集_指针数组), 局_计次)
        .如果真 (集_指针数组 [局_计次] ＝ 到整数 (参数_回调函数))
            删除成员 (集_标志文本数组, 取数组成员数 (集_标志文本数组), )
            删除成员 (集_消息编号数组, 取数组成员数 (集_消息编号数组), )
            返回 (假)
        .如果真结束
        
    .计次循环尾 ()
    
    加入成员 (集_指针数组, 到整数 (参数_回调函数))
    加入成员 (集_数据数组, 到字节集 (“”))
    返回 (真)

.子程序 进程通信_接收端_关闭监听, , 公开, 关闭某监听，要恢复请直接开始(不用重新初始化)。
    .参数 参数_标志文本, 文本型
    .局部变量 计次, 整数型

    .计次循环首 (取数组成员数 (集_标志文本数组), 计次)
        .如果真 (集_标志文本数组 [计次] ＝ 参数_标志文本)
            删除成员 (集_消息编号数组, 计次, )
            删除成员 (集_标志文本数组, 计次, )
            删除成员 (集_数据数组, 计次, )
            删除成员 (集_指针数组, 计次, )
            跳出循环 ()
        .如果真结束
        
    .计次循环尾 ()

.子程序 进程通信_接收端_停止监听, , 公开, 关闭所有监听，要恢复请重新初始化。
    SetWindowLongA (集_窗口句柄, -4, 集_oldlong)
    清除数组 (集_标志文本数组)
    清除数组 (集_消息编号数组)
    清除数组 (集_数据数组)
    清除数组 (集_指针数组)

.子程序 进程通信_接收端_取出数据, 字节集, 公开, 回调函数或其它子程序可用此子程序取出接收到的数据。
    .参数 参数_标识文本, 文本型, , 接收端监听时设置的文本。
    .局部变量 局_计次, 整数型

    .计次循环首 (取数组成员数 (集_标志文本数组), 局_计次)
        .如果真 (集_标志文本数组 [局_计次] ＝ 参数_标识文本)
            返回 (集_数据数组 [局_计次])
        .如果真结束
        
    .计次循环尾 ()
    返回 ({ })

.子程序 进程通信_接收端_清除数据, , 公开, 清除某监听得到的数据(其它数据不变)，释放该数据所占的内存。
    .参数 参数_标志文本, 文本型
    .局部变量 局_计次, 整数型

    .计次循环首 (取数组成员数 (集_标志文本数组), 局_计次)
        .如果真 (集_标志文本数组 [局_计次] ＝ 参数_标志文本)
            集_数据数组 [局_计次] ＝ { }
            跳出循环 ()
        .如果真结束
        
    .计次循环尾 ()

.子程序 进程通信_接收端_清空数据, , 公开, 清空所有监听得到的所有数据，释放内存。
    重定义数组 (集_数据数组, 假, 取数组成员数 (集_数据数组))

.子程序 进程通信_发送端_发送数据, 逻辑型, 公开, 成功返回真，失败返回假。
    .参数 参数_窗口句柄, 整数型, , 接收端的窗口句柄。
    .参数 参数_标志文本, 文本型, , 接收端监听时设置的文本。
    .参数 参数_欲发送的数据, 字节集, , 要发送的数据。
    .局部变量 局_消息文本, 字节集
    .局部变量 局_标识文本, 字节集
    .局部变量 局_进程ID, 文本型, 静态
    .局部变量 局_消息号, 整数型
    .局部变量 局_PIDlen, 文本型

    局_消息号 ＝ RegisterWindowMessageA (参数_标志文本)
    .如果真 (局_进程ID ＝ “” 或 局_进程ID ＝ “0”)
        局_进程ID ＝ 到文本 (GetCurrentProcessId ())
    .如果真结束
    .如果真 (IsWindow (参数_窗口句柄) ≠ 0)
        局_标识文本 ＝ { 1 }
        局_消息文本 ＝ 到字节集 (到文本 (lstrcpynA_字节集 (局_标识文本, 局_标识文本, 0)) ＋ “$” ＋ 到文本 (取字节集长度 (参数_欲发送的数据)) ＋ “&” ＋ 到文本 (lstrcpynA_字节集 (参数_欲发送的数据, 参数_欲发送的数据, 0)))
        局_PIDlen ＝ 到文本 (取文本长度 (局_进程ID))
        SendMessageA (参数_窗口句柄, 局_消息号, 到整数 (局_PIDlen ＋ 局_进程ID ＋ 到文本 (取字节集长度 (局_消息文本))), lstrcpynA_字节集 (局_消息文本, 局_消息文本, 0))
        .如果真 (局_标识文本 ＝ { 2 })
            返回 (真)
        .如果真结束
        返回 (假)
    .如果真结束
    返回 (假)

.子程序 接收端_读数据, 整数型
    .参数 参数_窗口句柄, 整数型
    .参数 参数_消息号, 整数型
    .参数 参数_参数1, 整数型
    .参数 参数_参数2, 整数型
    .局部变量 局_消息文本, 文本型
    .局部变量 局_标识地址, 整数型
    .局部变量 局_len, 整数型
    .局部变量 局_drlen, 整数型
    .局部变量 局_hProcess, 整数型
    .局部变量 局_lpBuffer, 字节集
    .局部变量 局_计次, 整数型
    .局部变量 bin, 字节集

    .计次循环首 (取数组成员数 (集_消息编号数组), 局_计次)
        .如果真 (集_消息编号数组 [局_计次] ＝ 参数_消息号)
            局_消息文本 ＝ 到文本 (参数_参数1)
            局_len ＝ 到整数 (取文本左边 (局_消息文本, 1))
            局_消息文本 ＝ 取文本右边 (局_消息文本, 取文本长度 (局_消息文本) － 1)
            局_hProcess ＝ OpenProcess (#PROCESS_ALL_ACCESS, 0, 到整数 (取文本左边 (局_消息文本, 局_len)))
            局_drlen ＝ 到整数 (取文本右边 (局_消息文本, 取文本长度 (局_消息文本) － 局_len))
            局_lpBuffer ＝ 取空白字节集 (局_drlen)
            ReadProcessMemory_字节集 (局_hProcess, 参数_参数2, 局_lpBuffer, 局_drlen, 0)
            局_消息文本 ＝ 到文本 (局_lpBuffer)
            局_标识地址 ＝ 到整数 (取文本左边 (局_消息文本, 寻找文本 (局_消息文本, “$”, , 假) － 1))
            WriteProcessMemory_字节集 (局_hProcess, 局_标识地址, { 2 }, 1, 0)
            局_消息文本 ＝ 取文本右边 (局_消息文本, 取文本长度 (局_消息文本) － 寻找文本 (局_消息文本, “$”, , 假))
            局_drlen ＝ 到整数 (取文本左边 (局_消息文本, 寻找文本 (局_消息文本, “&”, , 假) － 1))
            局_len ＝ 到整数 (取文本右边 (局_消息文本, 取文本长度 (局_消息文本) － 寻找文本 (局_消息文本, “&”, , 假)))
            局_lpBuffer ＝ 取空白字节集 (局_drlen)
            ReadProcessMemory_字节集 (局_hProcess, 局_len, 局_lpBuffer, 局_drlen, 0)
            集_数据数组 [局_计次] ＝ 局_lpBuffer
            CloseHandle (局_hProcess)
            .如果真 (到整数 (集_指针数组 [局_计次]) ≠ 0)
                ' bin ＝ { 85, 139, 236, 255, 117, 20, 255, 117, 16, 255, 117, 12, 255, 85, 8, 201, 194, 16, 0 }
                ' CallWindowProcA (取指针_字节集型 (bin), 集_指针数组 [局_计次], 0, 0, 0)
                CallWindowProcA (取指针_字节集型 ({ 85, 139, 236, 255, 117, 20, 255, 117, 16, 255, 117, 12, 255, 85, 8, 201, 194, 16, 0 }), 集_指针数组 [局_计次], 0, 0, 0)
            .如果真结束
            跳出循环 ()
        .如果真结束
        
    .计次循环尾 ()
    返回 (CallWindowProcA (集_oldlong, 参数_窗口句柄, 参数_消息号, 参数_参数1, 参数_参数2))

.子程序 子程序1, , , '''分割线
    

.子程序 内存_远程创建内存_文本, 整数型, 公开, 创建成功后返回远程文本内存地址。可用来远程调用
    .参数 进程句柄, 整数型
    .参数 文本内容, 文本型

    返回 (内存_远程创建内存_字节集 (进程句柄, 到字节集 (文本内容) ＋ { 0 })) ' 0是文本终止符

.子程序 内存_远程创建内存_字节集, 整数型, 公开, 创建成功后返回远程字节集内存地址。可用来远程调用
    .参数 进程句柄, 整数型
    .参数 字节集内容, 字节集
    .局部变量 nMaxCount, 整数型
    .局部变量 pMem, 整数型
    .局部变量 lRes, 逻辑型

    nMaxCount ＝ 取字节集长度 (字节集内容)
    pMem ＝ VirtualAllocEx (进程句柄, #NULL, nMaxCount, #MEM_COMMIT, #PAGE_EXECUTE_READWRITE)
    .如果真 (pMem ＝ #NULL)
        输出调试文本 (取错误信息文本_API (, ))
        返回 (#NULL)
    .如果真结束
    lRes ＝ WriteProcessMemory_字节集 (进程句柄, pMem, 字节集内容, nMaxCount, #NULL)
    .如果真 (lRes ＝ 假)
        输出调试文本 (取错误信息文本_API (, ))
        VirtualFreeEx (进程句柄, pMem, 0, #MEM_RELEASE)
        返回 (#NULL)
    .如果真结束
    返回 (pMem)

.子程序 内存_远程调用子程序, 逻辑型, 公开, 在远程进程创建一条线程，成功返回真，失败返回假。会导致少数进程崩溃，暂未找到原因   调用实例：https://bbs.125.la/thread-14193109-1-1.html  
    .参数 进程句柄, 整数型
    .参数 远程子程序地址, 整数型
    .参数 参数, 整数型, 可空 数组, 只接受整数型数据，如需传递文本请自行创建远程文本内存，传入内存地址
    .参数 是否C调用, 逻辑型, 可空, 默认为APICALL(即_stdcall)，如果本函数为真则使用C调用(_cdcel)
    .参数 是否等待远程线程, 逻辑型, 可空, 如果为真，则等待远程线程执行完毕后才会返回。否则创建后立即返回(异步)
    .局部变量 远程函数字节集, 字节集
    .局部变量 数组成员数, 整数型
    .局部变量 j, 整数型
    .局部变量 内存地址, 整数型
    .局部变量 远程线程句柄, 整数型

    .如果真 (远程子程序地址 ＝ 0)
        返回 (假)
    .如果真结束
    ' 首先整理出远程内存call的字节集
    ' 思路如下, 倒序push参数, 将需要call的地址放入eax, 然后call eax。最后根据调用约定, 决定是否平衡堆栈
    ' 倒序遍历数组
    远程函数字节集 ＝ { }
    数组成员数 ＝ 取数组成员数 (参数)
    .如果真 (数组成员数 ＞ 63)
        ' 参数过多。后面有解释原因。虽然我觉得没必要解释什么← ←
        返回 (假)
    .如果真结束
    .计次循环首 (数组成员数, j)
        .如果 (参数 [数组成员数 － j ＋ 1] ＜ 255)
            ' 小于255(一个字节)的时候可以使用{106,内容}的方法push, 节约内存
            远程函数字节集 ＝ 远程函数字节集 ＋ { 106 } ＋ 到字节集 (到字节 (参数 [数组成员数 － j ＋ 1]))
        .否则
            ' 大于255(一个字节)的时候可以用{104,0,0,0,0}的方法push四字节内容
            远程函数字节集 ＝ 远程函数字节集 ＋ { 104 } ＋ 到字节集 (参数 [数组成员数 － j ＋ 1])
        .如果结束
        
    .计次循环尾 ()
    ' 然后应当将函数地址传入eax，方法为 {184,0,0,0,0,255,208}(0,0,0,0是远程子程序地址，255，208是call eax的意思)
    远程函数字节集 ＝ 远程函数字节集 ＋ { 184 } ＋ 到字节集 (远程子程序地址) ＋ { 255, 208 }
    ' 判断是否为C调用。如果是C调用, 根据_cdcel调用约定, 应当在call调用完毕后手动平衡堆栈
    .如果真 (是否C调用 ＝ 真)
        ' 平衡堆栈说明。使用 add esp,数量 来平衡堆栈。字节集为131,196,0，0是数量，不能超过255(PS:255相当于63个参数....一般人真不会超过255吧QwQ 所以上面加了个判断)
        远程函数字节集 ＝ 远程函数字节集 ＋ { 131, 196 } ＋ 到字节集 (到字节 (数组成员数 × 4))
    .如果真结束
    ' 最后添加返回的字节集机器码 ,ret{195}返回
    远程函数字节集 ＝ 远程函数字节集 ＋ { 195 }
    ' 接下来将字节集写到远程内存
    内存地址 ＝ 内存_远程创建内存_字节集 (进程句柄, 远程函数字节集)
    .如果真 (内存地址 ＝ 0)
        返回 (假)
    .如果真结束
    ' 创建远程线程
    远程线程句柄 ＝ CreateRemoteThread (进程句柄, 0, 0, 内存地址, 0, 0, 0)
    .如果真 (远程线程句柄 ＝ 0)
        输出调试文本 (“远程线程创建失败”)
        返回 (假)
    .如果真结束
    .如果 (是否等待远程线程 ＝ 真)
        WaitForSingleObject (远程线程句柄, -1)
        CloseHandle (远程线程句柄)
        内存_释放远程内存 (进程句柄, 内存地址)
        输出调试文本 (“远程资源已自动释放”)
        返回 (真)
    .否则
        ' 创建线程, 在线程等待。最后销毁相关数据
        ' 关于线程参数的一点说明
        ' 为了等待，需要传递三个参数：远程线程句柄，释放内存地址，进程PID
        ' 将通过一个长度为12的字节集来传递数据
        j ＝ VirtualAlloc (0, 12, #MEM_COMMIT, #PAGE_READWRITE)
        ' j是之前循环变量, 已经不需要了, 这里就直接拿来用
        写到内存 (到字节集 (远程线程句柄) ＋ 到字节集 (内存地址) ＋ 到字节集 (进程句柄), j, 12)
        CloseHandle (CreateThread (0, 0, 到整数 (&内部等待线程), j, 0, 0))
        ' 因为并不需要对线程做后续操作，所以直接关闭线程句柄，让线程自行运行完毕自动销毁即可。
    .如果结束
    返回 (真)

.子程序 内存_释放远程内存, 逻辑型, 公开, 释放在远程创建的内存，可以释放本模块创建的远程文本/字节集内存。
    .参数 进程句柄, 整数型
    .参数 远程内存地址, 整数型

    ' 释放内存
    .如果真 (VirtualFreeEx (进程句柄, 远程内存地址, 0, #MEM_RELEASE) ＝ 0)
        输出调试文本 (“释放内存失败”)
        返回 (假)
    .如果真结束
    返回 (真)

.子程序 内部等待线程
    .参数 参数地址, 整数型
    .局部变量 字节集, 字节集
    .局部变量 远程线程句柄, 整数型
    .局部变量 内存地址, 整数型
    .局部变量 进程PID, 整数型

    字节集 ＝ 指针到字节集 (参数地址, 12)
    ' 释放参数地址内存, 避免内存泄漏
    VirtualFree (参数地址, 0, #MEM_RELEASE)
    远程线程句柄 ＝ 取字节集数据 (字节集, #整数型, )
    内存地址 ＝ 取字节集数据 (字节集, #整数型, 5)
    进程PID ＝ 取字节集数据 (字节集, #整数型, 9)
    WaitForSingleObject (远程线程句柄, -1)
    CloseHandle (远程线程句柄)
    内存_释放远程内存 (进程PID, 内存地址)
    输出调试文本 (“远程资源已自动释放”)

.版本 2

.程序集 类_内存配置项, , 公开
.程序集变量 集_配置节, 配置节数据, , "0"
.程序集变量 集_保存文件名, 文本型

.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
    

.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
    写到文件 ()
    清除数组 (集_配置节)

.子程序 写配置项, 逻辑型, 公开, 将配置项写入内存
    .参数 节名称, 文本型
    .参数 配置项名称, 文本型
    .参数 欲写入值, 文本型
    .局部变量 项目是否存在, 逻辑型
    .局部变量 节名序号, 整数型
    .局部变量 临时_配置节, 配置节数据
    .局部变量 临时_配置项, 配置项数据
    .局部变量 i, 整数型
    .局部变量 o, 整数型

    .如果真 (节名称 ＝ “” 或 配置项名称 ＝ “”)
        返回 (假)
    .如果真结束
    欲写入值 ＝ 内部方法_换行符转换行符标识符 (欲写入值)
    .计次循环首 (取数组成员数 (集_配置节), i)
        .如果真 (集_配置节 [i].节名称 ＝ 节名称)
            节名序号 ＝ i
            .计次循环首 (取数组成员数 (集_配置节 [i].项), o)
                .如果真 (集_配置节 [i].项 [o].配置项名称 ＝ 配置项名称) ' 如果存在'节名称'且'配置项名称'也存在  ,则直接写入值
                    集_配置节 [i].项 [o].值 ＝ 欲写入值
                    项目是否存在 ＝ 真
                    跳出循环 ()
                .如果真结束
                
            .计次循环尾 ()
        .如果真结束
        
    .计次循环尾 ()
    .如果真 (节名序号 ＝ 0) ' 无此配置节 添加配置节 赋值配置节的序号
        临时_配置节.节名称 ＝ 节名称
        清除数组 (临时_配置节.项)
        加入成员 (集_配置节, 临时_配置节)
        节名序号 ＝ 取数组成员数 (集_配置节)
    .如果真结束
    .如果真 (取反 (项目是否存在)) ' 如果不存在就添加 节名称,配置项名称,值
        ' 临时_配置项.节名称 ＝ 节名称
        临时_配置项.配置项名称 ＝ 配置项名称
        临时_配置项.值 ＝ 欲写入值
        加入成员 (集_配置节 [节名序号].项, 临时_配置项)
        
        
    .如果真结束
    
    返回 (真)

.子程序 读配置项, 文本型, 公开, 返回 节名称->配置项名称->值
    .参数 节名称, 文本型
    .参数 配置项名称, 文本型
    .参数 默认文本, 文本型, 可空, 注明：如果指定配置项不存在，将返回此默认文本。如果指定配置项不存在且本参数被省略，将返回空文本。
    .局部变量 i, 整数型
    .局部变量 o, 整数型

    .如果真 (配置项名称 ＝ “” 或 节名称 ＝ “”)
        返回 (默认文本)
    .如果真结束
    .计次循环首 (取数组成员数 (集_配置节), i)
        .如果真 (集_配置节 [i].节名称 ＝ 节名称) ' 存在此配置节
            .计次循环首 (取数组成员数 (集_配置节 [i].项), o)
                .如果真 (集_配置节 [i].项 [o].配置项名称 ＝ 配置项名称)
                    返回 (内部方法_换行符标识符转换行符 (集_配置节 [i].项 [o].值))
                .如果真结束
                
            .计次循环尾 ()
            返回 (默认文本) ' 无对应配置项
        .如果真结束
        
    .计次循环尾 ()
    返回 (默认文本) ' 无对应配置节

.子程序 读配置项_整数, 整数型, 公开, 返回 节名称->配置项名称->值
    .参数 节名称, 文本型
    .参数 配置项名称, 文本型
    .参数 默认数值, , 可空, 注明：如果指定配置项不存在，将返回此默认数值。如果指定配置项不存在且本参数被省略，将返回0。
    .局部变量 i, 整数型
    .局部变量 o, 整数型

    .如果真 (配置项名称 ＝ “” 或 节名称 ＝ “”)
        返回 (默认数值)
    .如果真结束
    .计次循环首 (取数组成员数 (集_配置节), i)
        .如果真 (集_配置节 [i].节名称 ＝ 节名称) ' 存在此配置节
            .计次循环首 (取数组成员数 (集_配置节 [i].项), o)
                .如果真 (集_配置节 [i].项 [o].配置项名称 ＝ 配置项名称)
                    返回 (到数值 (内部方法_换行符标识符转换行符 (集_配置节 [i].项 [o].值)))
                .如果真结束
                
            .计次循环尾 ()
            返回 (默认数值) ' 无对应配置项
        .如果真结束
        
    .计次循环尾 ()
    返回 (默认数值) ' 无对应配置节

.子程序 删除配置项, 逻辑型, 公开, 返回删除是否i成功
    .参数 节名称, 文本型
    .参数 配置项名称, 文本型, 可空, 留空则删除'节名称'的所有'配置项'
    .局部变量 配置项_长度, 整数型
    .局部变量 i, 整数型
    .局部变量 o, 整数型

    .如果真 (节名称 ＝ “”)
        返回 (假)
    .如果真结束
    
    配置项_长度 ＝ 取数组成员数 (集_配置节)
    
    .如果 (是否为空 (配置项名称))
        .变量循环首 (配置项_长度, 1, -1, i)
            .如果真 (集_配置节 [i].节名称 ＝ 节名称) ' 删除节列表名称
                删除成员 (集_配置节, i, 1)
                跳出循环 ()
            .如果真结束
            
        .变量循环尾 ()
        
    .否则
        
        .变量循环首 (配置项_长度, 1, -1, i)
            .如果真 (集_配置节 [i].节名称 ＝ 节名称)
                .计次循环首 (取数组成员数 (集_配置节 [i].项), o)
                    .如果真 (集_配置节 [i].项 [o].配置项名称 ＝ 配置项名称)
                        删除成员 (集_配置节 [i].项, o, 1)
                        返回 (真)
                    .如果真结束
                    
                .计次循环尾 ()
            .如果真结束
            
        .变量循环尾 ()
    .如果结束
    返回 (真)

.子程序 清空, , 公开, 所有数据将丢失
    重定义数组 (集_配置节, 假, 0)

.子程序 取所有配置项, 整数型, 公开, 返回'配置项名'的数量
    .参数 节名称, 文本型, 可空, 留空取所有的配置项数目
    .参数 配置项_参考_数组, 配置项数据, 参考 可空 数组, 留空为不取
    .局部变量 配置项_长度, 整数型
    .局部变量 k, 整数型
    .局部变量 i, 整数型

    配置项_长度 ＝ 取数组成员数 (集_配置节)
    .如果真 (是否为空 (节名称))
        返回 (配置项_长度)
    .如果真结束
    
    .如果 (取反 (是否为空 (配置项_参考_数组)))
        重定义数组 (配置项_参考_数组, 假, 0)
        .计次循环首 (配置项_长度, i)
            .如果真 (集_配置节 [i].节名称 ＝ 节名称)
                配置项_参考_数组 ＝ 集_配置节 [i].项
                跳出循环 ()
            .如果真结束
            
        .计次循环尾 ()
        返回 (取数组成员数 (配置项_参考_数组))
        
    .否则
        
        .计次循环首 (配置项_长度, i)
            .如果真 (集_配置节 [i].节名称 ＝ 节名称)
                k ＝ k ＋ 1
            .如果真结束
            
        .计次循环尾 ()
        返回 (k)
    .如果结束
    
    

.子程序 取配置项名, 整数型, 公开, 返回'配置项名'的数量
    .参数 节名称, 文本型, , 留空取所有的配置项数目
    .参数 配置项名称_参考_数组, 文本型, 参考 数组
    .局部变量 k, 整数型
    .局部变量 i, 整数型

    .如果真 (节名称 ＝ “”)
        返回 (0)
    .如果真结束
    重定义数组 (配置项名称_参考_数组, 假, 0)
    .计次循环首 (取数组成员数 (集_配置节), i)
        .如果真 (集_配置节 [i].节名称 ＝ 节名称)
            .计次循环首 (取数组成员数 (集_配置节 [i].项), k)
                加入成员 (配置项名称_参考_数组, 集_配置节 [i].项 [k].配置项名称)
            .计次循环尾 ()
            跳出循环 ()
        .如果真结束
        
    .计次循环尾 ()
    返回 (取数组成员数 (配置项名称_参考_数组))
    
    

.子程序 取配置节名, 整数型, 公开, 返回'节名称'的数量
    .参数 节名称_参考_数组, 文本型, 参考 可空 数组, 接收节名称数组
    .局部变量 i, 整数型
    .局部变量 局_配置节数, 整数型

    局_配置节数 ＝ 取数组成员数 (集_配置节)
    .如果真 (取反 (是否为空 (节名称_参考_数组)))
        清除数组 (节名称_参考_数组)
        .计次循环首 (局_配置节数, i)
            加入成员 (节名称_参考_数组, 集_配置节 [i].节名称)
        .计次循环尾 ()
    .如果真结束
    返回 (局_配置节数)

.子程序 加载配置项_从文件, 逻辑型, 公开, 将一配置文件内容加载到内存配置中，但不管内存配置项如何变动不会对该配置文件进行任何修改。
    .参数 配置文件名路径, 文本型, , 例 c:\config.ini
    .参数 自动保存, 逻辑型, 可空, 类销毁时,是否自动保存配置到文件(配置文件名)
    .局部变量 执行结果, 逻辑型
    .局部变量 局_配置数据, 字节集

    集_保存文件名 ＝ 选择 (自动保存, 配置文件名路径, “”)
    .如果真 (文件是否存在 (配置文件名路径))
        局_配置数据 ＝ 读入文件 (配置文件名路径)
        执行结果 ＝ 内部方法_加载配置项 (局_配置数据)
    .如果真结束
    返回 (执行结果)

.子程序 内部方法_加载配置项, 逻辑型
    .参数 文本数据, 字节集
    .局部变量 局部_文本, 文本型
    .局部变量 当前节名, 文本型
    .局部变量 位置, 整数型
    .局部变量 数组_长度
    .局部变量 局_字集数组, 字节集, , "0"
    .局部变量 i, 整数型
    .局部变量 n, 整数型

    局_字集数组 ＝ 分割字节集 (文本数据, { 13, 10 }, )
    数组_长度 ＝ 取数组成员数 (局_字集数组)
    .如果真 (数组_长度 ＞ 0)
        重定义数组 (集_配置节, 假, 0)
        .计次循环首 (数组_长度, i)
            局部_文本 ＝ 删首尾空 (到文本 (局_字集数组 [i]))
            .如果真 (局部_文本 ≠ “”)
                .如果 (局部_文本 ≈ “[”)
                    n ＝ 寻找文本 (局部_文本, “]”, 2, 假)
                    .如果真 (n ≠ -1)
                        当前节名 ＝ 取文本中间 (局部_文本, 2, n － 2)
                    .如果真结束
                    
                .否则
                    位置 ＝ 寻找文本 (局部_文本, “=”, 0, 假)
                    .如果真 (位置 ≠ -1)
                        写配置项 (当前节名, 删首尾空 (取文本左边 (局部_文本, 位置 － 1)), 取文本右边 (局部_文本, 取文本长度 (局部_文本) － 位置))
                    .如果真结束
                    
                .如果结束
                
            .如果真结束
            处理事件 ()
        .计次循环尾 ()
        返回 (真)
    .如果真结束
    返回 (假)

.子程序 内部方法_换行符转换行符标识符, 文本型
    .参数 待转文本, 文本型

    返回 (子文本替换 (待转文本, #换行符, “{\r\n}”, , , 真)) ' 处理换行符

.子程序 内部方法_换行符标识符转换行符, 文本型
    .参数 待转文本, 文本型

    返回 (子文本替换 (待转文本, “{\r\n}”, #换行符, , , 真)) ' 处理换行符

.子程序 加载配置项_从内存, 逻辑型, 公开, 将一符合配置文件格式的内存数据加载到内存配置中。
    .参数 文本数据, 字节集

    返回 (内部方法_加载配置项 (文本数据))

.子程序 取配置数据, 字节集, 公开, 配置项的文件信息,用于下次加载
    .局部变量 配置项名数组, 文本型, , "0"
    .局部变量 节名称数组, 文本型, , "0"
    .局部变量 i, 整数型
    .局部变量 j, 整数型
    .局部变量 文件号, 整数型
    .局部变量 文件数据, 字节集

    文件号 ＝ 打开内存文件 ()
    .计次循环首 (取数组成员数 (集_配置节), i)
        写出文本 (文件号, “[”, 集_配置节 [i].节名称, “]”, #换行符)
        .计次循环首 (取数组成员数 (集_配置节 [i].项), j)
            写出文本 (文件号, 集_配置节 [i].项 [j].配置项名称, “=”, 内部方法_换行符转换行符标识符 (集_配置节 [i].项 [j].值), #换行符)
        .计次循环尾 ()
    .计次循环尾 ()
    移到文件首 (文件号)
    文件数据 ＝ 读入字节集 (文件号, 取文件长度 (文件号))
    关闭文件 (文件号)
    返回 (文件数据)

.子程序 写到文件, 逻辑型, 公开, 将当前内存配置内容写出到文件
    .参数 配置文件名, 文本型, 可空, 例： c:\config.ini,留空,则使用加载配置项_从文件()时提供的 '配置文件名路径'

    .如果真 (是否为空 (配置文件名))
        配置文件名 ＝ 集_保存文件名
    .如果真结束
    .如果真 (配置文件名 ＝ “”)
        返回 (假)
    .如果真结束
    返回 (写到文件 (配置文件名, 取配置数据 ()))
    

.版本 2

.程序集 类_日志输出, , 公开
.程序集变量 集_目录, 文本型
.程序集变量 集_日志名, 文本型
.程序集变量 集_控制台句柄, 整数型
.程序集变量 集_日志文件句柄, 整数型

.子程序 _初始化
    集_目录 ＝ 取运行目录 () ＋ “\Log\” ＋ 时间_格式化 (取现行时间 (), “yyyyMM\”)
    集_日志名 ＝ 时间_格式化 (取现行时间 (), “yyyy-MM-dd”) ＋ “.txt”

.子程序 _销毁
    .如果真 (集_控制台句柄 ＞ 0)
        FreeConsole ()
        集_控制台句柄 ＝ 0
    .如果真结束
    
    .如果真 (集_日志文件句柄 ＞ 0)
        关闭文件 (集_日志文件句柄)
        集_日志文件句柄 ＝ 0
    .如果真结束
    

.子程序 文件路径, 文本型, 公开, 获取与设置日志输出文件目录，请在【输出文件】日志前设置目录。
    .参数 参_目录, 文本型, 可空, 默认会在程序运行目录下生成(Log+年月)格式的目录
    .参数 参_文件名, 文本型, 可空

    .如果真 (集_日志文件句柄 ＞ 0)
        关闭文件 (集_日志文件句柄)
        集_日志文件句柄 ＝ 0
    .如果真结束
    .如果真 (取文本长度 (参_目录) ＞ 0)
        集_目录 ＝ 参_目录
        集_目录 ＝ 选择 (取文本右边 (集_目录, 1) ≠ “\”, 集_目录 ＋ “\”, 集_目录)
    .如果真结束
    .如果真 (取文本长度 (参_文件名) ＞ 0)
        集_日志名 ＝ 参_文件名
        集_日志名 ＝ 选择 (到小写 (取文本右边 (集_日志名, 4)) ≠ “.txt”, 集_日志名 ＋ “.txt”, 集_日志名)
    .如果真结束
    返回 (集_目录 ＋ 集_日志名)

.子程序 输出文件, 逻辑型, 公开, 输出内容到文件到
    .参数 参_内容, 文本型
    .参数 参_级别, 整数型, 可空, 默认为【信息】，或如下级别值：0=信息，1=警告，2=错误，3=调试
    .参数 参_信息框, 逻辑型, 可空, 默认不提示
    .局部变量 局_文件句柄, 整数型
    .局部变量 局_提示图标, 整数型
    .局部变量 局_返回值, 逻辑型

    .如果真 (参_级别 ＜ 0 或 参_级别 ＞ 3)
        参_级别 ＝ 0
    .如果真结束
    .如果真 (目录_是否存在 (集_目录) ＝ 假)
        目录_创建 (集_目录)
    .如果真结束
    .判断开始 (参_级别 ＝ 1)
        局_提示图标 ＝ #警告图标
    .判断 (参_级别 ＝ 2)
        局_提示图标 ＝ #错误图标
    .判断 (参_级别 ＝ 3)
        局_提示图标 ＝ #信息图标
    .默认
        局_提示图标 ＝ #信息图标
    .判断结束
    .如果真 (参_信息框)
        信息框 (参_内容, 局_提示图标, “日志输出”)
    .如果真结束
    
    .如果真 (集_日志文件句柄 ＝ 0)
        集_日志文件句柄 ＝ 打开文件 (文件路径 (), 5, 1)
        移到文件尾 (集_日志文件句柄)
    .如果真结束
    ' 局_文件句柄 ＝ 打开文件 (文件路径 (), 6, 1)
    
    局_返回值 ＝ 写出文本 (集_日志文件句柄, 取格式文本 (参_内容, 参_级别))
    
    返回 (局_返回值)

.子程序 输出控制台, 逻辑型, 公开, 输入日志内容到控制台
    .参数 参_内容, 文本型
    .参数 参_级别, 整数型, 可空, 默认为【信息】，或如下级别值：0=信息，1=警告，2=错误，3=调试
    .参数 参_标题, 文本型, 可空, 控制台标题，默认 程序日志
    .参数 参_写到文件, 逻辑型, 可空, 默认不出日志文件
    .局部变量 局_控制台属性, 整数型
    .局部变量 局_日志, 文本型
    .局部变量 匿名局部变量_逻辑型_63103, 逻辑型

    .如果 (AllocConsole ())
        集_控制台句柄 ＝ GetStdHandle (#STD_OUTPUT_HANDLE)
        SetConsoleTitleA (选择 (取文本长度 (参_标题) ＞ 0, 参_标题, “程序日志”))
    .否则
        集_控制台句柄 ＝ GetStdHandle (#STD_OUTPUT_HANDLE)
    .如果结束
    .如果真 (集_控制台句柄 ≠ 0)
        .如果真 (参_写到文件)
            输出文件 (参_内容, 参_级别)
        .如果真结束
        .判断开始 (参_级别 ＝ 1)
            局_控制台属性 ＝ #FOREGROUND_RED ＋ #FOREGROUND_INTENSITY
        .判断 (参_级别 ＝ 2)
            局_控制台属性 ＝ #FOREGROUND_RED ＋ #FOREGROUND_GREEN ＋ #FOREGROUND_INTENSITY
        .判断 (参_级别 ＝ 3)
            局_控制台属性 ＝ #FOREGROUND_RED ＋ #FOREGROUND_GREEN ＋ #FOREGROUND_BLUE ＋ #FOREGROUND_INTENSITY
        .默认
            局_控制台属性 ＝ #FOREGROUND_RED ＋ #FOREGROUND_GREEN ＋ #FOREGROUND_BLUE
        .判断结束
        局_日志 ＝ 取格式文本 (参_内容, 参_级别)
        SetConsoleTextAttribute (集_控制台句柄, 局_控制台属性)
        返回 (WriteConsoleA (集_控制台句柄, 局_日志, 取文本长度 (局_日志), 0, 0))
    .如果真结束
    返回 (假)

.子程序 输出易调试, , 公开, 只在调试模式下有效
    .参数 参_内容, 文本型
    .参数 参_级别, 整数型, 可空, 默认为【信息】，或如下级别值：0=信息，1=警告，2=错误，3=调试
    .参数 参_写到文件, 逻辑型, 可空, 默认不出日志文件
    .局部变量 局_日志, 文本型

    局_日志 ＝ 取格式文本 (参_内容, 参_级别)
    .如果真 (参_写到文件)
        输出文件 (参_内容, 参_级别)
    .如果真结束
    输出调试文本 (局_日志)

.子程序 输出调试器, , 公开, 输出到 调试器，编译模式下有效，可用DbgView 查看
    .参数 参_内容, 文本型
    .参数 参_级别, 整数型, 可空, 默认为【信息】，或如下级别值：0=信息，1=警告，2=错误，3=调试
    .参数 参_写到文件, 逻辑型, 可空, 默认不出日志文件
    .局部变量 局_日志, 文本型

    局_日志 ＝ 取格式文本 (参_内容, 参_级别)
    .如果真 (参_写到文件)
        输出文件 (参_内容, 参_级别)
    .如果真结束
    OutputDebugStringA (局_日志)

.子程序 输出编辑框, , 公开, 输出日志内容到编辑框
    .参数 参_编辑框句柄, 整数型
    .参数 参_内容, 文本型
    .参数 参_级别, 整数型, 可空, 默认为【信息】，或如下级别值：0=信息，1=警告，2=错误，3=调试
    .参数 参_写到文件, 逻辑型, 可空, 默认不出日志文件
    .局部变量 局_日志, 文本型

    局_日志 ＝ 取格式文本 (参_内容, 参_级别)
    .如果真 (参_写到文件)
        输出文件 (参_内容, 参_级别)
    .如果真结束
    .如果真 (IsWindow (参_编辑框句柄) ＝ 1)
        SendMessageA (参_编辑框句柄, #EM_REPLACESEL, 0, 取指针文本_ (局_日志))
    .如果真结束
    

.子程序 取格式文本, 文本型
    .参数 参_日志内容, 文本型
    .参数 参_日志级别, 整数型, 可空
    .局部变量 局_系统时间, 精易_时间
    .局部变量 局_格式, 文本型
    .局部变量 局_日期, 文本型
    .局部变量 局_时间, 文本型
    .局部变量 局_日志级别, 文本型

    .判断开始 (参_日志级别 ＝ 1)
        局_日志级别 ＝ “警告”
    .判断 (参_日志级别 ＝ 2)
        局_日志级别 ＝ “错误”
    .判断 (参_日志级别 ＝ 3)
        局_日志级别 ＝ “调试”
    .默认
        局_日志级别 ＝ “信息”
    .判断结束
    GetLocalTime (局_系统时间)
    局_日期 ＝ 取空白文本 (50)
    GetDateFormatA (0, 0, 局_系统时间, “yyyy-MM-dd ”, 局_日期, 50)
    局_时间 ＝ 取空白文本 (50)
    GetTimeFormatA (0, #TIME_FORCE24HOURFORMAT, 局_系统时间, “hh:mm:ss.”, 局_时间, 50)
    局_格式 ＝ 局_日期 ＋ 局_时间 ＋ 文本_自动补零 (到文本 (局_系统时间.毫), 3) ＋ “ ” ＋ 局_日志级别 ＋ “:” ＋ 参_日志内容 ＋ #换行符
    返回 (局_格式)

.版本 2

.程序集 类_配置项, , 公开, 本类由萧阳天编写；MSDN资料:http://msdn.microsoft.com/en-us/library/windows/desktop/ms724875(v=vs.85).aspx
.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
    

.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
    

.子程序 写入节, 逻辑型, 公开
    .参数 配置文件, 文本型
    .参数 节名称, 文本型
    .参数 写入内容, 字节集

    返回 (WritePrivateProfileSection (节名称, 写入内容, 配置文件))

.子程序 读取节, 字节集, 公开
    .参数 配置文件, 文本型
    .参数 节名称, 文本型
    .参数 缓冲区大小, 整数型, 可空
    .局部变量 sbuffer, 字节集
    .局部变量 Length

    .如果真 (缓冲区大小 ≤ 0)
        缓冲区大小 ＝ 32767
    .如果真结束
    sbuffer ＝ 取空白字节集 (缓冲区大小) ' The maximum profile section size is 32,767 characters.
    Length ＝ GetPrivateProfileSection (节名称, sbuffer, 缓冲区大小, 配置文件)
    返回 (取字节集左边 (sbuffer, Length))

.子程序 枚举节, 整数型, 公开, 返回配置文件中所有已有节名的数量。
    .参数 配置文件, 文本型
    .参数 节数组, 文本型, 数组, 变量储存返回值。
    .参数 缓冲区大小, 整数型, 可空
    .局部变量 Length
    .局部变量 sbuffer, 字节集
    .局部变量 Array, 字节集, , "0"
    .局部变量 cnt, 整数型

    .如果真 (缓冲区大小 ≤ 0)
        缓冲区大小 ＝ 32767
    .如果真结束
    清除数组 (节数组)
    sbuffer ＝ 取空白字节集 (缓冲区大小) ' The maximum profile section size is 32,767 characters.
    Length ＝ GetPrivateProfileSectionNames (sbuffer, 缓冲区大小, 配置文件)
    sbuffer ＝ 取字节集左边 (sbuffer, Length)
    Array ＝ 分割字节集 (sbuffer, { 0 }, )
    .计次循环首 (取数组成员数 (Array), cnt)
        加入成员 (节数组, 到文本 (Array [cnt]))
    .计次循环尾 ()
    返回 (取数组成员数 (Array))

.子程序 取节数, 整数型, 公开
    .参数 配置文件, 文本型
    .参数 缓冲区大小, 整数型, 可空
    .局部变量 Length
    .局部变量 sbuffer, 字节集
    .局部变量 Array, 字节集, , "0"

    .如果真 (缓冲区大小 ≤ 0)
        缓冲区大小 ＝ 32767
    .如果真结束
    sbuffer ＝ 取空白字节集 (缓冲区大小) ' The maximum profile section size is 32,767 characters.
    Length ＝ GetPrivateProfileSectionNames (sbuffer, 缓冲区大小, 配置文件)
    sbuffer ＝ 取字节集左边 (sbuffer, Length)
    Array ＝ 分割字节集 (sbuffer, { 0 }, )
    返回 (取数组成员数 (Array))

.子程序 删除节, 逻辑型, 公开, 注意，此命令将会删除指定节上所有项目，一但删除将无法挽回。成功返回真，失败返回假。
    .参数 配置文件, 文本型
    .参数 节名称, 文本型

    返回 (WritePrivateProfileString (节名称, 字符 (0), 字符 (0), 配置文件))

.子程序 读项文本, 文本型, 公开, 读取指定配置文件中指定项目的文本内容。本命令为初级命令。
    .参数 配置文件名, 文本型, , 指定配置文件的名称，通常以.ini作为文件名后缀。
    .参数 节名称, 文本型, , 包含欲读入配置项所处节的名称。
    .参数 配置项名称, 文本型, , 参数值指定欲读入配置项在其节中的名称。
    .参数 默认文本, 文本型, 可空, 可以被省略。如果指定配置项不存在，将返回此默认文本。如果指定配置项不存在且本参数被省略，将返回空文本。
    .参数 缓冲区大小, 整数型, 可空
    .局部变量 sbuffer, 文本型
    .局部变量 Length

    .如果真 (缓冲区大小 ≤ 0)
        缓冲区大小 ＝ 32767
    .如果真结束
    sbuffer ＝ 取空白文本 (缓冲区大小)
    Length ＝ GetPrivateProfileString (节名称, 配置项名称, 默认文本, sbuffer, 缓冲区大小, 配置文件名)
    返回 (取文本左边 (sbuffer, Length))

.子程序 写项文本, 逻辑型, 公开, 将指定文本内容写入指定配置项中或者删除指定的配置项或节，如果指定配置文件不存在，将会自动创建。成功返回真，失败返回假。本命令为初级命令。
    .参数 配置文件名, 文本型, , 指定配置文件的名称，通常以.ini作为文件名后缀。
    .参数 节名称, 文本型, , 包含欲写入配置项所处节的名称。
    .参数 配置项名称, 文本型, 可空, 可以被省略。参数值指定欲写入配置项在其节中的名称。如果参数值被省略，则删除指定节及其下的所有配置项。
    .参数 欲写入值, 文本型, 可空, 可以被省略。参数值指定欲写入到指定配置项中的文本。如果参数值被省略，则删除所指定配置项。

    返回 (WritePrivateProfileString (节名称, 配置项名称, 欲写入值, 配置文件名))

.子程序 删除项, 逻辑型, 公开, 注意，此命令将会删除指定节上指定配置项，一但删除将无法挽回。成功返回真，失败返回假。
    .参数 配置文件, 文本型
    .参数 节名称, 文本型
    .参数 配置项名称, 文本型

    返回 (WritePrivateProfileString (节名称, 配置项名称, 字符 (0), 配置文件))

.子程序 枚举项, 整数型, 公开
    .参数 配置文件, 文本型
    .参数 节名称, 文本型
    .参数 名称, 文本型, 数组, 变量储存返回值。
    .参数 值, 文本型, 数组
    .参数 缓冲区大小, 整数型, 可空
    .局部变量 sbuffer, 字节集
    .局部变量 Length
    .局部变量 Array, 字节集, , "0"
    .局部变量 i, 整数型
    .局部变量 Text, 文本型
    .局部变量 Number

    .如果真 (缓冲区大小 ≤ 0)
        缓冲区大小 ＝ 32767
    .如果真结束
    清除数组 (名称)
    清除数组 (值)
    sbuffer ＝ 取空白字节集 (缓冲区大小) ' The maximum profile section size is 32,767 characters.
    Length ＝ GetPrivateProfileSection (节名称, sbuffer, 缓冲区大小, 配置文件)
    sbuffer ＝ 取字节集左边 (sbuffer, Length)
    Array ＝ 分割字节集 (sbuffer, { 0 }, )
    .计次循环首 (取数组成员数 (Array), i)
        Text ＝ 到文本 (Array [i])
        Number ＝ 寻找文本 (Text, “=”, , 假)
        加入成员 (名称, 取文本左边 (Text, Number － 1))
        加入成员 (值, 取文本右边 (Text, 取文本长度 (Text) － Number))
    .计次循环尾 ()
    返回 (取数组成员数 (Array))

.子程序 取项数, 整数型, 公开
    .参数 配置文件, 文本型
    .参数 节名称, 文本型
    .参数 缓冲区大小, 整数型, 可空
    .局部变量 sbuffer, 字节集
    .局部变量 Length
    .局部变量 Array, 字节集, , "0"
    .局部变量 i, 整数型
    .局部变量 Text, 文本型
    .局部变量 Number

    .如果真 (缓冲区大小 ≤ 0)
        缓冲区大小 ＝ 32767
    .如果真结束
    sbuffer ＝ 取空白字节集 (缓冲区大小) ' The maximum profile section size is 32,767 characters.
    Length ＝ GetPrivateProfileSection (节名称, sbuffer, 缓冲区大小, 配置文件)
    sbuffer ＝ 取字节集左边 (sbuffer, Length)
    Array ＝ 分割字节集 (sbuffer, { 0 }, )
    返回 (取数组成员数 (Array))

.子程序 读项数值, 整数型, 公开, 读取指定配置文件中指定项目的文本内容。本命令为初级命令。
    .参数 配置文件名, 文本型, , 指定配置文件的名称，通常以.ini作为文件名后缀。
    .参数 节名称, 文本型, , 包含欲读入配置项所处节的名称。
    .参数 配置项名称, 文本型, , 参数值指定欲读入配置项在其节中的名称。
    .参数 默认数值, 整数型, 可空, 可以被省略。如果指定配置项不存在，将返回此默认文本。如果指定配置项不存在且本参数被省略，将返回空文本。

    返回 (GetPrivateProfileInt (到字节集 (节名称), 配置项名称, 默认数值, 配置文件名))

.子程序 写项结构, 逻辑型, 公开, 把指定数据结构以字节集方式存入配置项，成功返回真，失败返回假。
    .参数 配置文件名, 文本型
    .参数 节名称, 文本型
    .参数 配置项名称, 文本型
    .参数 数据结构, 字节集

    返回 (WritePrivateProfileStruct (配置项名称, 节名称, 数据结构, 取字节集长度 (数据结构), 配置文件名))

.子程序 读项结构, 字节集, 公开, 取回｛写项结构()｝写入的结构数据，失败返回Null。
    .参数 配置文件名, 文本型
    .参数 节名称, 文本型
    .参数 配置项名称, 文本型
    .参数 数据结构大小
    .局部变量 sbuffer, 字节集

    sbuffer ＝ 取空白字节集 (数据结构大小)
    GetPrivateProfileStruct (配置项名称, 节名称, sbuffer, 数据结构大小, 配置文件名)
    返回 (sbuffer)

.子程序 系统配置项注册表目录, , , HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\IniFileMapping\win.ini
    

.子程序 写系统节, 逻辑型, 公开, 注意：设置系统配置项可能造成系统不稳定，请谨慎。向系统Win.ini中写入配置项，成功返回真，失败返回假。
    .参数 节名称, 文本型
    .参数 内容, 字节集

    返回 (WriteProfileSection (节名称, 内容))

.子程序 读系统节, 字节集, 公开
    .参数 节名称, 文本型
    .参数 缓冲区大小, 整数型, 可空
    .局部变量 sbuffer, 字节集
    .局部变量 Length

    .如果真 (缓冲区大小 ≤ 0)
        缓冲区大小 ＝ 32767
    .如果真结束
    sbuffer ＝ 取空白字节集 (缓冲区大小 ＋ 1)
    Length ＝ GetProfileSection (节名称, sbuffer, 缓冲区大小)
    sbuffer ＝ 取字节集左边 (sbuffer, Length)
    返回 (sbuffer)

.子程序 枚举系统项, 整数型, 公开, 枚举系统win.ini中的配置项及值，失败返回Null。
    .参数 节名称, 文本型
    .参数 项名称, 文本型, 数组, 变量储存返回值。
    .参数 值, 文本型, 可空 数组, 变量储存返回值。
    .参数 缓冲区大小, 整数型, 可空
    .局部变量 sbuffer, 字节集
    .局部变量 Length
    .局部变量 Array, 字节集, , "0"
    .局部变量 cnt, 整数型
    .局部变量 Text, 文本型
    .局部变量 Number, 整数型

    .如果真 (缓冲区大小 ≤ 0)
        缓冲区大小 ＝ 32767
    .如果真结束
    清除数组 (项名称)
    清除数组 (值)
    sbuffer ＝ 取空白字节集 (缓冲区大小 ＋ 1)
    Length ＝ GetProfileSection (节名称, sbuffer, 缓冲区大小)
    sbuffer ＝ 取字节集左边 (sbuffer, Length)
    Array ＝ 分割字节集 (sbuffer, { 0 }, )
    .计次循环首 (取数组成员数 (Array), cnt)
        Text ＝ 到文本 (Array [cnt])
        Number ＝ 寻找文本 (Text, “=”, , 假)
        加入成员 (项名称, 取文本左边 (Text, Number － 1))
        加入成员 (值, 取文本右边 (Text, 取文本长度 (Text) － Number))
    .计次循环尾 ()
    返回 (取数组成员数 (Array))

.子程序 取系统项数, 整数型, 公开
    .参数 节名称, 文本型
    .参数 缓冲区大小, 整数型, 可空
    .局部变量 sbuffer, 字节集
    .局部变量 Length
    .局部变量 Array, 字节集, , "0"
    .局部变量 cnt, 整数型
    .局部变量 Text, 文本型
    .局部变量 Number, 整数型

    .如果真 (缓冲区大小 ≤ 0)
        缓冲区大小 ＝ 32767
    .如果真结束
    sbuffer ＝ 取空白字节集 (缓冲区大小 ＋ 1)
    Length ＝ GetProfileSection (节名称, sbuffer, 缓冲区大小)
    sbuffer ＝ 取字节集左边 (sbuffer, Length)
    Array ＝ 分割字节集 (sbuffer, { 0 }, )
    返回 (取数组成员数 (Array))

.子程序 读系统项文本, 文本型, 公开, 从系统Win.ini中读取指定配置项文本，失败失败Null。本命令为初级命令。
    .参数 节名称, 文本型, , 包含欲读入配置项所处节的名称。
    .参数 配置项名称, 文本型, , 参数值指定欲读入配置项在其节中的名称。
    .参数 默认文本, 文本型, 可空, 可以被省略。如果指定配置项不存在，将返回此默认文本。如果指定配置项不存在且本参数被省略，将返回空文本。
    .局部变量 sbuffer, 文本型
    .局部变量 Length

    sbuffer ＝ 取空白文本 (256)
    Length ＝ GetProfileString (节名称, 配置项名称, 默认文本, sbuffer, 256)
    返回 (取文本左边 (sbuffer, Length))

.子程序 写系统项文本, 逻辑型, 公开, 注意：设置系统配置项可能造成系统不稳定，请谨慎。向系统Win.ini配置项中写入文本值，成功返回真，失败返回假。
    .参数 节名称, 文本型, , 包含欲读入配置项所处节的名称。
    .参数 配置项名称, 文本型, , 参数值指定欲读入配置项在其节中的名称。
    .参数 欲写入值, 文本型

    返回 (WriteProfileString (节名称, 配置项名称, 欲写入值))

.子程序 读系统项数值, 整数型, 公开, 从系统Win.ini中读取指定配置项数值，失败失败Null。本命令为初级命令。
    .参数 节名称, 文本型, , 包含欲读入配置项所处节的名称。
    .参数 配置项名称, 文本型, , 参数值指定欲读入配置项在其节中的名称。
    .参数 默认数值, 整数型, 可空, 可以被省略。如果指定配置项不存在，将返回此默认文本。如果指定配置项不存在且本参数被省略，将返回空文本。

    返回 (GetProfileInt (节名称, 配置项名称, 默认数值)) ' 对应注册表；HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\IniFileMapping\win.ini

.版本 2

.程序集 类_配置项ex, , 公开, 本类由【果子】编写，简约读写配置项
.程序集变量 集_配置文件路径, 文本型
.程序集变量 集_加密密码, 文本型
.程序集变量 集_默认节名称, 文本型
.程序集变量 集_节名前缀, 文本型

.子程序 _初始化, , , 当基于本类的对象被创建后，此方法会被自动调用
    集_默认节名称 ＝ “System”

.子程序 _销毁, , , 当基于本类的对象被销毁前，此方法会被自动调用
    

.子程序 初始化, , 公开, 可重复初始化，重复初始化将直接覆盖前面的参数值
    .参数 配置文件路径, 文本型, 可空, 可空，默认为“程序根目录\Data\Config.ini”
    .参数 加密密码, 文本型, 可空, 可空，为空=不加密
    .参数 节名前缀, 文本型, 可空, 可空
    .局部变量 dir, 文本型

    .判断开始 (是否为空 (配置文件路径) 或 删首尾空 (配置文件路径) ＝ “”)
        目录_创建 (取运行目录 () ＋ “\Data”)
        集_配置文件路径 ＝ 取运行目录 () ＋ “\Data\Config.ini”
        
    .默认
        集_配置文件路径 ＝ 配置文件路径
        dir ＝ 目录_取父路径 (配置文件路径)
        .如果真 (目录_是否存在 (dir) ＝ 假)
            目录_创建 (dir)
        .如果真结束
        
    .判断结束
    集_加密密码 ＝ 删首尾空 (加密密码)
    集_节名前缀 ＝ 节名前缀

.子程序 写, 逻辑型, 公开
    .参数 节名称, 文本型, 可空, 可空，默认为System，包含欲写入配置项所处节的名称。
    .参数 配置项名称, 文本型, 可空, 可以被省略。参数值指定欲写入配置项在其节中的名称。如果参数值被省略，则删除指定节及其下的所有配置项。
    .参数 欲写入值, 文本型, 可空, 可以被省略。参数值指定欲写入到指定配置项中的文本。如果参数值被省略，则删除所指定配置项。
    .参数 加密, 逻辑型, 可空, 用系统自动的密码进行加密。
    .局部变量 局_文本, 文本型

    .如果真 (是否为空 (节名称) 或 删首尾空 (节名称) ＝ “”)
        节名称 ＝ 集_默认节名称
    .如果真结束
    
    .判断开始 (是否为空 (配置项名称) 或 删首尾空 (配置项名称) ＝ “”)
        返回 (写配置项 (集_配置文件路径, 集_节名前缀 ＋ 节名称, , ))
        
    .判断 (是否为空 (欲写入值))
        返回 (写配置项 (集_配置文件路径, 集_节名前缀 ＋ 节名称, 配置项名称, ))
    .默认
        
    .判断结束
    
    .如果真 (删首尾空 (配置项名称) ＝ “”)
        输出调试文本 (“配置项类：写失败，原因：【配置项名称】为空”)
        返回 (假)
    .如果真结束
    局_文本 ＝ 删首尾空 (子文本替换 (欲写入值, #换行符, “{#换行符}”, , , 真))
    
    
    .判断开始 (集_加密密码 ≠ “” 且 加密)
        局_文本 ＝ 文本_加密 (局_文本, 集_加密密码)
        
    .判断 (加密)
        局_文本 ＝ 文本_解密 (局_文本, “Wiha4w” ＋ 到文本 (4842 ÷ 5 × 564))
        
    .判断 (配置项名称 ＝ “User” 或 配置项名称 ＝ “Pass”) ' 如果是用户名，自动加密
        局_文本 ＝ 文本_加密 (局_文本, “Wiha4w” ＋ 到文本 (4842 ÷ 5 × 564))
    .默认
        
    .判断结束
    返回 (写配置项 (集_配置文件路径, 集_节名前缀 ＋ 节名称, 配置项名称, 局_文本))

.子程序 读, 文本型, 公开
    .参数 节名称, 文本型, 可空, 可空，默认为System，包含欲写入配置项所处节的名称。
    .参数 配置项名称, 文本型, , 参数值指定欲读入配置项在其节中的名称。
    .参数 默认文本, 文本型, 可空, 可以被省略。如果指定配置项不存在，将返回此默认文本。如果指定配置项不存在且本参数被省略，将返回空文本。
    .参数 解密, 逻辑型, 可空, 如果你在写的时候加密了，这里同样也要解决，用系统自动的密码进行解密。
    .局部变量 局_文本, 文本型
    .局部变量 局_默认文本, 文本型
    .局部变量 局_对比结果, 逻辑型

    .如果真 (是否为空 (节名称) 或 删首尾空 (节名称) ＝ “”)
        节名称 ＝ 集_默认节名称
    .如果真结束
    .如果真 (删首尾空 (配置项名称) ＝ “”)
        输出调试文本 (“配置项类：读失败，原因：【配置项名称】为空”)
        返回 (“”)
    .如果真结束
    局_默认文本 ＝ 取重复文本 (10, 字符 (1))
    局_文本 ＝ 读配置项 (集_配置文件路径, 集_节名前缀 ＋ 节名称, 配置项名称, 局_默认文本)
    局_对比结果 ＝ 局_文本 ＝ 局_默认文本
    .如果真 (局_对比结果)
        局_文本 ＝ 默认文本
    .如果真结束
    局_文本 ＝ 子文本替换 (局_文本, “{#换行符}”, #换行符, , , 真)
    局_文本 ＝ 子文本替换 (局_文本, “><br><”, #换行符, , , 真)
    .判断开始 (集_加密密码 ≠ “” 且 局_对比结果 ＝ 假 且 解密)
        局_文本 ＝ 文本_解密 (局_文本, 集_加密密码)
        
    .判断 (解密)
        局_文本 ＝ 文本_解密 (局_文本, “Wiha4w” ＋ 到文本 (4842 ÷ 5 × 564))
        
    .判断 (配置项名称 ＝ “User” 或 配置项名称 ＝ “Pass”) ' 如果是用户名，自动加密
        局_文本 ＝ 文本_解密 (局_文本, “Wiha4w” ＋ 到文本 (4842 ÷ 5 × 564))
    .默认
        
    .判断结束
    返回 (局_文本)

.子程序 置_默认节名称, , 公开, 默认节名称，当节名称留空时，以此节名称为主
    .参数 默认节名称, 文本型, , 当节名称留空时，以此节名称为主

    集_默认节名称 ＝ 删全部空 (默认节名称)

.子程序 置_节名前缀, , 公开
    .参数 节名前缀, 文本型

    集_节名前缀 ＝ 节名前缀

.子程序 批量保存, 逻辑型, 公开, 【编辑框，选择框，单选框，组合框】保存指定窗口上指定组件的内容，与"批量读取()"命令一起用的。【特别注意：组件的[标识]将作为保存配置的项名称，标识为空将不保存】
    .参数 父窗口, 窗口, , 直接填写顶级窗口就行了，如:_启动窗口。
    .参数 组件类型, 文本型, , 如：“编辑框、组合框、单选框”等等，多个组件请使用半角逗号分隔开。
    .局部变量 局_寻找句柄, 整数型
    .局部变量 局_计次, 整数型
    .局部变量 局_编辑框, 编辑框
    .局部变量 局_单选框, 单选框
    .局部变量 局_选择框, 选择框
    .局部变量 局_组合框, 组合框
    .局部变量 局_选择夹, 选择夹
    .局部变量 局_文本, 文本型
    .局部变量 局_组件数量, 整数型
    .局部变量 局_配置项名称, 文本型
    .局部变量 Arr, 文本型, , "0"

    .如果真 (是否已创建 (父窗口) ＝ 假)
        输出调试文本 (“配置项，批量保存失败，原因：参数【父窗口】为载入！”)
        返回 (假)
    .如果真结束
    
    .如果真 (删首尾空 (组件类型) ＝ “”)
        输出调试文本 (“配置项，批量保存失败，原因：参数【组件类型】为空！”)
        返回 (假)
    .如果真结束
    
    .判断开始 (寻找文本 (组件类型, “,”, , 假) ≠ -1)
        Arr ＝ 分割文本 (组件类型, “,”, )
        .计次循环首 (取数组成员数 (Arr), 局_计次)
            批量保存 (父窗口, Arr [局_计次])
        .计次循环尾 ()
        
    .默认
        局_寻找句柄 ＝ 寻找组件 (父窗口, , 组件类型, , )
        局_组件数量 ＝ 取找到组件数目 (局_寻找句柄)
        .计次循环首 (局_组件数量, 局_计次)
            .判断开始 (组件类型 ＝ “选择框”)
                局_选择框 ＝ 取所找到组件 (局_寻找句柄, 局_计次 － 1)
                局_配置项名称 ＝ 删首尾空 (局_选择框.标记)
                .如果真 (局_配置项名称 ＝ “”)
                    到循环尾 ()
                .如果真结束
                写 (集_默认节名称, 组件类型 ＋ “-” ＋ 局_配置项名称, 到文本 (局_选择框.选中))
                
            .判断 (组件类型 ＝ “单选框”)
                局_单选框 ＝ 取所找到组件 (局_寻找句柄, 局_计次 － 1)
                局_配置项名称 ＝ 删首尾空 (局_单选框.标记)
                .如果真 (局_配置项名称 ＝ “”)
                    到循环尾 ()
                .如果真结束
                写 (集_默认节名称, 组件类型 ＋ “-” ＋ 局_配置项名称, 到文本 (局_单选框.选中))
                
            .判断 (组件类型 ＝ “组合框”)
                局_组合框 ＝ 取所找到组件 (局_寻找句柄, 局_计次 － 1)
                局_配置项名称 ＝ 删首尾空 (局_组合框.标记)
                .如果真 (局_配置项名称 ＝ “”)
                    到循环尾 ()
                .如果真结束
                写 (集_默认节名称, 组件类型 ＋ “-” ＋ 局_配置项名称, 到文本 (局_组合框.现行选中项))
                .如果真 (局_组合框.现行选中项 ＝ -1 且 局_组合框.内容 ≠ “”)
                    写 (集_默认节名称, 组件类型 ＋ “-” ＋ 局_配置项名称 ＋ “-内容”, 局_组合框.内容, )
                .如果真结束
                
            .判断 (组件类型 ＝ “编辑框”)
                局_编辑框 ＝ 取所找到组件 (局_寻找句柄, 局_计次 － 1)
                局_配置项名称 ＝ 删首尾空 (局_编辑框.标记)
                局_文本 ＝ 子文本替换 (局_编辑框.内容, #换行符, “><br><”, , , 真)
                局_文本 ＝ 子文本替换 (局_文本, #引号, “%22”, , , 真)
                .如果真 (局_配置项名称 ＝ “”)
                    到循环尾 ()
                .如果真结束
                写 (集_默认节名称, 组件类型 ＋ “-” ＋ 局_配置项名称, 局_文本, )
                
            .判断 (组件类型 ＝ “选择夹”)
                局_选择夹 ＝ 取所找到组件 (局_寻找句柄, 局_计次 － 1)
                局_配置项名称 ＝ 删首尾空 (局_选择夹.标记)
                .如果真 (局_配置项名称 ＝ “”)
                    到循环尾 ()
                .如果真结束
                写 (集_默认节名称, 组件类型 ＋ “-” ＋ 局_配置项名称, 到文本 (局_选择夹.现行子夹), )
            .默认
                
            .判断结束
            
        .计次循环尾 ()
    .判断结束
    返回 (真)

.子程序 批量读取, 逻辑型, 公开, 读取指定窗口上指定组件的配置内容，与"批量保存()"命令一起用的。【特别注意：组件的[标识]将作为读取配置的项名称，标识为空将不读取】
    .参数 父窗口, 窗口, , 直接填写顶级窗口就行了，如:_启动窗口。
    .参数 组件类型, 文本型, , 如：“编辑框、组合框、单选框”等等，多个组件请使用半角逗号分隔开。
    .参数 例外组件, 文本型, 可空, 请输入不需要读取的组件标识名，如：User,Pass  多个请使用半角逗号分隔开
    .局部变量 局_寻找句柄, 整数型
    .局部变量 局_计次, 整数型
    .局部变量 局_编辑框, 编辑框
    .局部变量 局_单选框, 单选框
    .局部变量 局_选择框, 选择框
    .局部变量 局_组合框, 组合框
    .局部变量 局_选择夹, 选择夹
    .局部变量 局_组件数量, 整数型
    .局部变量 局_文本, 文本型
    .局部变量 局_配置项名称, 文本型
    .局部变量 Arr, 文本型, , "0"

    .如果真 (是否已创建 (父窗口) ＝ 假)
        输出调试文本 (“配置项，批量保存失败，原因：参数【父窗口】为载入！”)
        返回 (假)
    .如果真结束
    .如果真 (删首尾空 (组件类型) ＝ “”)
        输出调试文本 (“配置项，批量保存失败，原因：参数【组件类型】为空！”)
        返回 (假)
    .如果真结束
    
    .如果真 (删首尾空 (例外组件) ≠ “” 且 取文本右边 (例外组件, 1) ≠ “,”)
        例外组件 ＝ 例外组件 ＋ “,”
    .如果真结束
    
    
    .判断开始 (寻找文本 (组件类型, “,”, , 假) ≠ -1)
        Arr ＝ 分割文本 (组件类型, “,”, )
        .计次循环首 (取数组成员数 (Arr), 局_计次)
            批量读取 (父窗口, Arr [局_计次], 例外组件)
        .计次循环尾 ()
        
    .默认
        局_寻找句柄 ＝ 寻找组件 (父窗口, , 组件类型, , )
        局_组件数量 ＝ 取找到组件数目 (局_寻找句柄)
        .计次循环首 (局_组件数量, 局_计次)
            .判断开始 (组件类型 ＝ “选择框”)
                局_选择框 ＝ 取所找到组件 (局_寻找句柄, 局_计次 － 1)
                局_配置项名称 ＝ 删首尾空 (局_选择框.标记)
                .如果真 (局_配置项名称 ＝ “”)
                    到循环尾 ()
                .如果真结束
                .如果真 (例外组件 ≠ “”)
                    .如果真 (寻找文本 (例外组件, 局_配置项名称 ＋ “,”, , 假) ≠ -1)
                        到循环尾 ()
                    .如果真结束
                    
                .如果真结束
                局_文本 ＝ 读 (集_默认节名称, 组件类型 ＋ “-” ＋ 局_配置项名称, “”)
                .如果真 (局_文本 ＝ “”)
                    到循环尾 ()
                .如果真结束
                局_选择框.选中 ＝ 局_文本 ＝ “真”
                
            .判断 (组件类型 ＝ “单选框”)
                局_单选框 ＝ 取所找到组件 (局_寻找句柄, 局_计次 － 1)
                局_配置项名称 ＝ 删首尾空 (局_单选框.标记)
                .如果真 (局_配置项名称 ＝ “”)
                    到循环尾 ()
                .如果真结束
                .如果真 (例外组件 ≠ “”)
                    .如果真 (寻找文本 (例外组件, 局_配置项名称 ＋ “,”, , 假) ≠ -1)
                        到循环尾 ()
                    .如果真结束
                    
                .如果真结束
                局_文本 ＝ 读 (集_默认节名称, 组件类型 ＋ “-” ＋ 局_配置项名称, “”)
                .如果真 (局_文本 ＝ “”)
                    到循环尾 ()
                .如果真结束
                局_单选框.选中 ＝ 局_文本 ＝ “真”
                
            .判断 (组件类型 ＝ “组合框”)
                局_组合框 ＝ 取所找到组件 (局_寻找句柄, 局_计次 － 1)
                局_配置项名称 ＝ 删首尾空 (局_组合框.标记)
                .如果真 (局_配置项名称 ＝ “”)
                    到循环尾 ()
                .如果真结束
                .如果真 (例外组件 ≠ “”)
                    .如果真 (寻找文本 (例外组件, 局_配置项名称 ＋ “,”, , 假) ≠ -1)
                        到循环尾 ()
                    .如果真结束
                    
                .如果真结束
                局_文本 ＝ 读 (集_默认节名称, 组件类型 ＋ “-” ＋ 局_配置项名称, “”)
                .如果真 (局_文本 ＝ “”)
                    到循环尾 ()
                .如果真结束
                
                .如果 (局_文本 ＝ “-1”)
                    局_组合框.内容 ＝ 读 (集_默认节名称, 组件类型 ＋ “-” ＋ 局_配置项名称 ＋ “-内容”, “”, )
                    
                .否则
                    局_组合框.现行选中项 ＝ 到数值 (局_文本)
                .如果结束
                
                
            .判断 (组件类型 ＝ “编辑框”)
                局_编辑框 ＝ 取所找到组件 (局_寻找句柄, 局_计次 － 1)
                局_配置项名称 ＝ 删首尾空 (局_编辑框.标记)
                .如果真 (局_配置项名称 ＝ “”)
                    到循环尾 ()
                .如果真结束
                .如果真 (例外组件 ≠ “”)
                    .如果真 (寻找文本 (例外组件, 局_配置项名称 ＋ “,”, , 假) ≠ -1)
                        到循环尾 ()
                    .如果真结束
                    
                .如果真结束
                局_文本 ＝ 读 (集_默认节名称, 组件类型 ＋ “-” ＋ 局_配置项名称, “”)
                .如果真 (局_文本 ＝ “”)
                    到循环尾 ()
                .如果真结束
                局_文本 ＝ 子文本替换 (局_文本, “%22”, #引号, , , 真)
                局_编辑框.内容 ＝ 子文本替换 (局_文本, “><br><”, #换行符, , , 真)
                
            .判断 (组件类型 ＝ “选择夹”)
                局_选择夹 ＝ 取所找到组件 (局_寻找句柄, 局_计次 － 1)
                局_配置项名称 ＝ 删首尾空 (局_选择夹.标记)
                .如果真 (局_配置项名称 ＝ “”)
                    到循环尾 ()
                .如果真结束
                .如果真 (例外组件 ≠ “”)
                    .如果真 (寻找文本 (例外组件, 局_配置项名称 ＋ “,”, , 假) ≠ -1)
                        到循环尾 ()
                    .如果真结束
                    
                .如果真结束
                局_文本 ＝ 读 (集_默认节名称, 组件类型 ＋ “-” ＋ 局_配置项名称, “”)
                .如果真 (局_文本 ＝ “”)
                    到循环尾 ()
                .如果真结束
                局_选择夹.现行子夹 ＝ 到数值 (局_文本)
            .默认
                
            .判断结束
            
        .计次循环尾 ()
    .判断结束
    返回 (真)

.子程序 窗口位置_保存, , 公开
    .参数 窗口, 窗口
    .参数 是否保存窗口大小, 逻辑型, 可空, 可空，默认为假，不保存
    .局部变量 节点名, 文本型

    .如果真 (是否为调试版 ())
        输出调试文本 (“调试环境不会保存【窗口位置】”)
        返回 ()
    .如果真结束
    节点名 ＝ 取执行文件名 ()
    写 (节点名, “WinTop”, 到文本 (窗口.顶边), )
    写 (节点名, “WinLeft”, 到文本 (窗口.左边), )
    .如果真 (是否保存窗口大小)
        写 (节点名, “WinWidth”, 到文本 (窗口.宽度), )
        写 (节点名, “WinHeight”, 到文本 (窗口.高度), )
    .如果真结束
    
    写 (节点名, “Maximization”, 到文本 (窗口.位置), )

.子程序 窗口位置_读取, , 公开
    .参数 窗口, 窗口
    .参数 是否读取窗口大小, 逻辑型, 可空, 可空，默认为假，不保存
    .局部变量 精易_矩形, 精易_矩形
    .局部变量 节点名, 文本型

    节点名 ＝ 取执行文件名 ()
    .如果真 (读 (节点名, “Maximization”, “0”, ) ＝ “3”) ' 最大化
        窗口.位置 ＝ 3
        返回 ()
    .如果真结束
    
    精易_矩形.顶边 ＝ 到数值 (读 (节点名, “WinTop”, “-1”, ))
    精易_矩形.左边 ＝ 到数值 (读 (节点名, “WinLeft”, “-1”, ))
    .判断开始 (是否读取窗口大小)
        精易_矩形.右边 ＝ 到数值 (读 (节点名, “WinWidth”, “-1”, ))
        精易_矩形.底边 ＝ 到数值 (读 (节点名, “WinHeight”, “-1”, ))
        
    .默认
        精易_矩形.右边 ＝ -1
        精易_矩形.底边 ＝ -1
    .判断结束
    
    .判断开始 (精易_矩形.左边 ＜ 0)
        精易_矩形.左边 ＝ 0
        
    .判断 (精易_矩形.左边 ＞ 取屏幕宽度 () － 300)
        精易_矩形.左边 ＝ 取屏幕宽度 () ÷ 2
    .默认
        
    .判断结束
    
    .判断开始 (精易_矩形.顶边 ＜ 0)
        精易_矩形.顶边 ＝ 0
        
    .判断 (精易_矩形.顶边 ＞ 取屏幕高度 () － 300)
        精易_矩形.顶边 ＝ 取屏幕高度 () ÷ 2
    .默认
        
    .判断结束
    
    .如果真 (精易_矩形.顶边 ≠ -1)
        .判断开始 (精易_矩形.右边 ＝ -1)
            窗口.移动 (精易_矩形.左边, 精易_矩形.顶边, , )
            
        .默认
            窗口.移动 (精易_矩形.左边, 精易_矩形.顶边, 精易_矩形.右边, 精易_矩形.底边)
        .判断结束
        
    .如果真结束
    

.子程序 窗口位置_保存_New, , 公开, 保存指定窗口的显示状态和恢复、最小化和最大化的位置。
    .参数 窗口句柄, 整数型
    .参数 节点名, 文本型, , 唯一节点名
    .局部变量 lpwndpl, 整数型
    .局部变量 chwndpl, 文本型

    lpwndpl ＝ LocalAlloc (#LMEM_ZEROINIT, 44) ' sizeof(WINDOWPLACEMENT)
    .如果真 (lpwndpl ≠ #NULL)
        .如果真 (GetWindowPlacement (窗口句柄, lpwndpl))
            chwndpl ＝ 字节集_字节集到十六进制 (指针到字节集 (lpwndpl, 44))
            初始化 (, , )
            写 (节点名, “wndpl”, chwndpl, )
        .如果真结束
        LocalFree (lpwndpl)
    .如果真结束
    

.子程序 窗口位置_读取_New, , 公开, 恢复指定窗口的显示状态和恢复、最小化和最大化的位置。
    .参数 窗口句柄, 整数型
    .参数 节点名, 文本型, , 唯一节点名
    .参数 窗口显示状态, 整数型, 可空, #SW_xxx！留空默认为上一次保存的状态
    .局部变量 chwndpl, 字节集
    .局部变量 lpwndpl, 整数型

    初始化 (, , )
    chwndpl ＝ 字节集_十六进制到字节集 (读 (节点名, “wndpl”, , ))
    .如果真 (取字节集长度 (chwndpl) ＝ 44)
        lpwndpl ＝ 取指针_字节集型 (chwndpl)
        .如果真 (是否为空 (窗口显示状态) ＝ 假)
            __set (lpwndpl, 8, 窗口显示状态) ' showCmd
        .如果真结束
        SetWindowPlacement (窗口句柄, lpwndpl)
    .如果真结束
    

.版本 2

.程序集 集_键盘鼠标
.程序集变量 键盘锁定钩子句柄, 整数型
.程序集变量 鼠标锁定钩子句柄, 整数型
.程序集变量 鼠标锁定状态, 逻辑型
.程序集变量 记忆坐标变量, 精易_坐标
.程序集变量 移入移出事件, 精易_鼠标移入移出事件, , "0"
.程序集变量 是否移入, 逻辑型
.程序集变量 zTmp, 精易_鼠标移入移出事件
.程序集变量 临时句柄, , , , 当前控件的句柄
.程序集变量 nTmp, , , , 当前控件在数组中的存放位置
.程序集变量 集_键盘状态, 逻辑型, , , 真:锁全键盘(可空为假)假:锁定功能键与Win键Esc键F4键Tab键Print键Soroll键Pause键
.程序集变量 集_HOOK, 整数型
.程序集变量 集_监视事件, 子程序指针

.子程序 鼠标_监视_安装, , 公开
    .参数 响应监视事件, 子程序指针, , 响应监视事件,3个参数,都为整数型,第1个为键代码（1为左键，2为右键，3为中键，4为滚轮，5为侧键上，6为侧键下）,第2个为按键状态(1为按下，2为放开，4往上滚，5往下滚)，第3个参数为窗口句柄与坐标的指针集合（指针到文本即可取出信息  窗口句柄|X,Y）

    .如果真 (集_HOOK ≠ 0)
        返回 ()
    .如果真结束
    集_监视事件 ＝ 响应监视事件
    集_HOOK ＝ SetWindowsHookExA (14, &MousePro, GetModuleHandleA1 (0), 0) ' 14 WH_MOUSE_LL

.子程序 MousePro, 整数型
    .参数 nCode, 整数型
    .参数 wParam, 整数型
    .参数 lParam, 整数型
    .局部变量 Mouse, MOUSEHOOKSTRUCT
    .局部变量 hwnd, 整数型
    .局部变量 pid, 整数型
    .局部变量 局_键代码, 整数型
    .局部变量 局_键状态, 整数型
    .局部变量 局_信息, 文本型
    .局部变量 局_偏移, 整数型

    .如果真 (nCode ≥ 0) ' #HC_ACTION = 0
        RtlMoveMemory_MOUSEHOOKSTRUCT (Mouse, lParam, 20)
        .判断开始 (wParam ＝ #WM_MOUSEWHEEL) ' 鼠标滚动
            .判断开始 (右移 (Mouse.hwnd, 16) ＞ 0)
                局_键代码 ＝ 4
                局_键状态 ＝ 4
                ' 输出调试文本 (“滚轮向上”)
            .判断 (右移 (Mouse.hwnd, 16) ＜ 0)
                局_键代码 ＝ 4
                局_键状态 ＝ 5
                ' 输出调试文本 (“滚轮向下”)
            .默认
                
            .判断结束
            
        .判断 (wParam ＝ #WM_LBUTTONDOWN)
            局_键代码 ＝ 1
            局_键状态 ＝ 1
            ' 输出调试文本 (“鼠标左键按下”)
        .判断 (wParam ＝ #WM_LBUTTONUP)
            局_键代码 ＝ 1
            局_键状态 ＝ 2
            ' 输出调试文本 (“鼠标左键放开”)
        .判断 (wParam ＝ #WM_LBUTTONDBLCLK)
            局_键代码 ＝ 1
            局_键状态 ＝ 3
            ' 输出调试文本 (“鼠标左键双击”)
        .判断 (wParam ＝ #WM_RBUTTONDOWN)
            局_键代码 ＝ 2
            局_键状态 ＝ 1
            ' 输出调试文本 (“鼠标右键按下”)
        .判断 (wParam ＝ #WM_RBUTTONUP)
            局_键代码 ＝ 2
            局_键状态 ＝ 2
            ' 输出调试文本 (“鼠标右键放开”)
        .判断 (wParam ＝ #WM_RBUTTONDBLCLK)
            局_键代码 ＝ 2
            局_键状态 ＝ 3
            ' 输出调试文本 (“鼠标右键双击”)
        .判断 (wParam ＝ #WM_MBUTTONDOWN)
            局_键代码 ＝ 3
            局_键状态 ＝ 1
            ' 输出调试文本 (“鼠标中键按下”)
        .判断 (wParam ＝ #WM_MBUTTONUP)
            局_键代码 ＝ 3
            局_键状态 ＝ 2
            ' 输出调试文本 (“鼠标中键放开”)
        .判断 (wParam ＝ #WM_MBUTTONDBLCLK)
            局_键代码 ＝ 3
            局_键状态 ＝ 3
            ' 输出调试文本 (“鼠标中键双击”)
        .判断 (wParam ＝ 523) ' 鼠标侧键
            局_偏移 ＝ 右移 (Mouse.hwnd, 16)
            .判断开始 (局_偏移 ＝ 2)
                局_键代码 ＝ 5
                局_键状态 ＝ 1
                ' 输出调试文本 (“侧键上被按下”)
            .判断 (局_偏移 ＝ 1)
                局_键代码 ＝ 6
                局_键状态 ＝ 1
                ' 输出调试文本 (“侧键下被按下”)
            .默认
                
            .判断结束
            
        .判断 (wParam ＝ 524) ' 鼠标侧键
            局_偏移 ＝ 右移 (Mouse.hwnd, 16)
            .判断开始 (局_偏移 ＝ 2)
                局_键代码 ＝ 5
                局_键状态 ＝ 2
                ' 输出调试文本 (“侧键上被放开”)
            .判断 (局_偏移 ＝ 1)
                局_键代码 ＝ 6
                局_键状态 ＝ 2
                ' 输出调试文本 (“侧键下被放开”)
            .默认
                
            .判断结束
            
        .默认
            
        .判断结束
        hwnd ＝ WindowFromPoint (Mouse.pt.X, Mouse.pt.Y)
        局_信息 ＝ 到文本 (hwnd) ＋ “|” ＋ 到文本 (Mouse.pt.X) ＋ “,” ＋ 到文本 (Mouse.pt.Y)
        程序_执行整数子程序 (集_监视事件, 局_键代码, 局_键状态, 取指针文本_ (局_信息))
    .如果真结束
    返回 (CallNextHookEx (集_HOOK, nCode, wParam, lParam))

.子程序 鼠标_监视_卸载, 逻辑型, 公开
    .局部变量 局_结果, 逻辑型

    局_结果 ＝ UnhookWindowsHookEx (集_HOOK)
    .如果真 (局_结果)
        集_HOOK ＝ 0
    .如果真结束
    返回 (局_结果)
    

.子程序 鼠标_删除鼠标移入移出事件, 整数型, 公开, 本命令由【不想说话的树】提供
    .参数 组件句柄, 整数型
    .局部变量 i, 整数型
    .局部变量 局返回值

    .计次循环首 (取数组成员数 (移入移出事件), i)
        .如果真 (移入移出事件 [i].句柄 ＝ 组件句柄)
            局返回值 ＝ SetWindowLongA (移入移出事件 [i].句柄, -4, 移入移出事件 [i].消息钩子句柄)
            删除成员 (移入移出事件, i, )
            nTmp ＝ 0
            临时句柄 ＝ 0
            跳出循环 ()
        .如果真结束
        
    .计次循环尾 ()
    返回 (局返回值)

.子程序 鼠标_删除所有鼠标移入移出事件, , 公开
    .局部变量 i, 整数型

    .计次循环首 (取数组成员数 (移入移出事件), i)
        SetWindowLongA (移入移出事件 [i].句柄, -4, 移入移出事件 [i].消息钩子句柄)
    .计次循环尾 ()
    清除数组 (移入移出事件)
    nTmp ＝ 0
    临时句柄 ＝ 0

.子程序 鼠标_添加鼠标移入移出事件, , 公开, 添加鼠标移入移出事件
    .参数 句柄, , , 指定控件句柄可以是任何组件
    .参数 移入事件, 子程序指针
    .参数 移出事件, 子程序指针

    zTmp.句柄 ＝ 句柄
    zTmp.移入事件 ＝ 移入事件
    zTmp.移出事件 ＝ 移出事件
    zTmp.消息钩子句柄 ＝ SetWindowLongA (句柄, -4, 到整数 (&消息钩子回调))
    加入成员 (移入移出事件, zTmp)

.子程序 消息钩子回调, 整数型
    .参数 hWnd
    .参数 uMsg
    .参数 wParam
    .参数 lParam
    .局部变量 PrevProchWnd, 整数型
    .局部变量 i, 整数型, , , 计次变量
    .局部变量 个数

    个数 ＝ 取数组成员数 (移入移出事件)
    ' .如果真 (个数 ＝ 0)
        ' 返回 (1)
    ' .如果真结束
    
    .如果真 (临时句柄 ≠ hWnd) ' 确定只程序执行一次,这样可以防止程序多次运行,大大的提高了运行效率。
        临时句柄 ＝ hWnd
        .计次循环首 (个数, i)
            .如果真 (移入移出事件 [i].句柄 ＝ hWnd)
                ' 鼠标移入移出事件 (hWnd, 移入移出事件 [i].移入事件, 移入移出事件 [i].移出事件)
                nTmp ＝ i
                跳出循环 ()
            .如果真结束
            
        .计次循环尾 ()
    .如果真结束
    
    .如果真 (uMsg ＝ 512)
        鼠标移入移出事件 (hWnd, 移入移出事件 [nTmp].移入事件, 移入移出事件 [nTmp].移出事件)
        返回 (1)
    .如果真结束
    返回 (CallWindowProcA (移入移出事件 [nTmp].消息钩子句柄, hWnd, uMsg, wParam, lParam))

.子程序 鼠标移入移出事件, 整数型, , 移入返回1,移出返回2,移动中返回3
    .参数 控件句柄, 整数型
    .参数 移入事件, 子程序指针
    .参数 移出事件, 子程序指针

    处理事件 ()
    .如果 (窗口_取鼠标处窗口句柄 () ＝ 控件句柄)
        .如果真 (是否移入 ＝ 假)
            SetCapture (控件句柄)
            执行子程序_ (移入事件)
            是否移入 ＝ 真
            返回 (1)
        .如果真结束
        
    .否则
        执行子程序_ (移出事件)
        ReleaseCapture ()
        是否移入 ＝ 假
        返回 (2)
        
    .如果结束
    SetCapture (控件句柄)
    返回 (3)

.子程序 执行子程序_, 整数型, , 例子，执行子程序 (&子程序1, 100) 或 执行子程序1 (&子程序1, 1, 2, 3)
    .参数 子程序, 子程序指针
    .参数 参数一, 整数型, 可空
    .参数 参数二, 整数型, 可空
    .参数 参数三, 整数型, 可空
    .局部变量 bin, 字节集

    bin ＝ { 85, 139, 236, 255, 117, 20, 255, 117, 16, 255, 117, 12, 255, 85, 8, 201, 194, 16, 0 }
    返回 (CallWindowProcA (取指针_字节集型 (bin), 到整数 (子程序), 参数一, 参数二, 参数三))
    

.子程序 键鼠_锁定, 整数型, 公开, 阻塞键盘及鼠标事件到达应用程序【beineimao】
    .参数 状态, 逻辑型, , 真=锁定

    .如果 (状态) ' 如果想得到更多错误信息，可以 调用GetLastError()函数
        返回 (BlockInput (1))
    .否则
        返回 (BlockInput (0))
    .如果结束
    

.子程序 鼠标钩子处理, 整数型, , 锁鼠标
    .参数 code, 整数型
    .参数 鼠标标识, 整数型
    .参数 lp, 整数型

    .如果真 (鼠标锁定状态)
        返回 (1)
    .如果真结束
    .如果真 (鼠标标识 ＝ 513 或 鼠标标识 ＝ 514 或 鼠标标识 ＝ 515) ' 鼠标左键按下,鼠标左键放开,鼠标左键双击
        返回 (1)
    .如果真结束
    .如果真 (鼠标标识 ＝ 516 或 鼠标标识 ＝ 517 或 鼠标标识 ＝ 518) ' 鼠标右键按下,鼠标右键放开,鼠标右键双击
        返回 (1)
    .如果真结束
    返回 (CallNextHookEx (鼠标锁定钩子句柄, code, 鼠标标识, lp))

.子程序 子程序0, , , ●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●
    

.子程序 鼠标_带轨迹移动, , 公开
    .参数 起始x, 整数型, 可空, 空为鼠标当前坐标
    .参数 起始y, 整数型, 可空
    .参数 终点x, 整数型
    .参数 终点y, 整数型
    .参数 移动速度, 整数型, 可空
    .参数 窗口句柄, 整数型, 可空
    .局部变量 局_判断值, 逻辑型
    .局部变量 局_X, 整数型
    .局部变量 局_Y, 整数型
    .局部变量 临时坐标, 精易_坐标

    .如果真 (窗口句柄 ≠ 0)
        ClientToScreen (窗口句柄, 临时坐标)
        终点x ＝ 临时坐标.横 ＋ 终点x
        终点y ＝ 临时坐标.纵 ＋ 终点y
    .如果真结束
    
    .如果真 (是否为空 (起始x))
        起始x ＝ 取鼠标水平位置 ()
    .如果真结束
    .如果真 (是否为空 (起始y))
        起始y ＝ 取鼠标垂直位置 ()
    .如果真结束
    .如果真 (是否为空 (移动速度))
        移动速度 ＝ 1
    .如果真结束
    SetCursorPos (起始x, 起始y)
    .判断循环首 (局_判断值 ＝ 假)
        起始x ＝ 取鼠标水平位置 ()
        起始y ＝ 取鼠标垂直位置 ()
        .判断开始 (终点x ＞ 起始x)
            局_X ＝ 1
        .判断 (终点x ＜ 起始x)
            局_X ＝ -1
        .判断 (终点x ＝ 起始x)
            局_X ＝ 0
        .默认
            
        .判断结束
        
        .判断开始 (终点y ＞ 起始y)
            局_Y ＝ 1
        .判断 (终点y ＜ 起始y)
            局_Y ＝ -1
        .判断 (终点y ＝ 起始y)
            局_Y ＝ 0
        .默认
            
        .判断结束
        鼠标_相对移动 (局_X, 局_Y)
        .如果真 (起始x ＝ 终点x 且 起始y ＝ 终点y)
            局_判断值 ＝ 真
            ' 跳出循环 ()
        .如果真结束
        程序_延时 (移动速度, )
        处理事件 ()
    .判断循环尾 ()

.子程序 鼠标_相对移动
    .参数 参数_x
    .参数 参数_y
    .局部变量 x
    .局部变量 y

    x ＝ 取鼠标水平位置 ()
    y ＝ 取鼠标垂直位置 ()
    SetCursorPos (x ＋ 参数_x, y ＋ 参数_y)

.子程序 鼠标_捕获, , 公开, 捕获指定窗口的鼠标
    .参数 窗口句柄, 整数型

    SetCapture (窗口句柄)

.子程序 鼠标_释放, , 公开, 释放被捕获的鼠标
    ReleaseCapture ()

.子程序 鼠标_锁定, , 公开, 锁定鼠标键(锁定后,鼠标键无效)
    .参数 状态, 逻辑型, 可空, 真:完全锁定鼠标 (可空为假) 假:锁定鼠标左右键

    .如果真 (鼠标锁定钩子句柄 ≠ 0)
        UnhookWindowsHookEx (鼠标锁定钩子句柄)
    .如果真结束
    鼠标锁定状态 ＝ 状态
    鼠标锁定钩子句柄 ＝ SetWindowsHookExA (#WH_MOUSE_LL, &鼠标钩子处理, GetModuleHandleA1 (0), 0) ' 载入鼠标钩子

.子程序 鼠标_解锁, , 公开, 鼠标键解锁(锁定鼠标键锁定后,用来恢复鼠标的使用)
    .如果真 (鼠标锁定钩子句柄 ≠ 0)
        UnhookWindowsHookEx (鼠标锁定钩子句柄)
    .如果真结束
    

.子程序 鼠标_限制, , 公开, 限制鼠标的活动范围(无返回值)，参数留空为解除鼠标限制
    .参数 临时左边, 整数型, 可空, 可空，为0
    .参数 临时顶边, 整数型, 可空, 可空，为0
    .参数 临时宽度, 整数型, 可空, 可空，为屏幕宽度-临时左边
    .参数 临时高度, 整数型, 可空, 可空，为屏幕高度-临时顶边
    .局部变量 临时范围, 精易_矩形

    临时范围.左边 ＝ 临时左边
    临时范围.顶边 ＝ 临时顶边
    .判断开始 (临时宽度 ＝ 0)
        临时范围.右边 ＝ 取屏幕宽度 () － 临时左边
    .默认
        临时范围.右边 ＝ 临时宽度 ＋ 临时左边
    .判断结束
    .判断开始 (临时高度 ＝ 0)
        临时范围.底边 ＝ 取屏幕高度 () － 临时高度
    .默认
        临时范围.底边 ＝ 临时高度 ＋ 临时顶边
    .判断结束
    ClipCursor (临时范围)
    ' 输出调试文本 (GetLastError ())
    

.子程序 鼠标_按键, , 公开, 模拟鼠标按键(无返回值)
    .参数 键, 整数型, 可空, 可空:为左键  1 #左键   2 #右键   3 #中键
    .参数 控制, 整数型, 可空, 可空:为单击  1 #单击   2 #双击   3 #按下  4 #放开

    .如果真 (键 ＝ 1 或 键 ＝ 0)
        .如果真 (控制 ＝ 3)
            mouse_event (2, 0, 0, 0, 0)
        .如果真结束
        .如果真 (控制 ＝ 4)
            mouse_event (4, 0, 0, 0, 0)
        .如果真结束
        .如果真 (控制 ＝ 1 或 控制 ＝ 0)
            mouse_event (2, 0, 0, 0, 0)
            mouse_event (4, 0, 0, 0, 0)
        .如果真结束
        .如果真 (控制 ＝ 2)
            mouse_event (2, 0, 0, 0, 0)
            mouse_event (4, 0, 0, 0, 0)
            程序_延时 (GetDoubleClickTime ())
            mouse_event (2, 0, 0, 0, 0)
            mouse_event (4, 0, 0, 0, 0)
        .如果真结束
        
    .如果真结束
    .如果真 (键 ＝ 3)
        .如果真 (控制 ＝ 3)
            mouse_event (32, 0, 0, 0, 0)
        .如果真结束
        .如果真 (控制 ＝ 4)
            mouse_event (64, 0, 0, 0, 0)
        .如果真结束
        .如果真 (控制 ＝ 1 或 控制 ＝ 0)
            mouse_event (32, 0, 0, 0, 0)
            mouse_event (64, 0, 0, 0, 0)
        .如果真结束
        .如果真 (控制 ＝ 2)
            mouse_event (32, 0, 0, 0, 0)
            mouse_event (64, 0, 0, 0, 0)
            程序_延时 (GetDoubleClickTime ())
            mouse_event (32, 0, 0, 0, 0)
            mouse_event (64, 0, 0, 0, 0)
        .如果真结束
        
    .如果真结束
    .如果真 (键 ＝ 2)
        .如果真 (控制 ＝ 3)
            mouse_event (8, 0, 0, 0, 0)
        .如果真结束
        .如果真 (控制 ＝ 4)
            mouse_event (16, 0, 0, 0, 0)
        .如果真结束
        .如果真 (控制 ＝ 1 或 控制 ＝ 0)
            mouse_event (8, 0, 0, 0, 0)
            mouse_event (16, 0, 0, 0, 0)
        .如果真结束
        .如果真 (控制 ＝ 2)
            mouse_event (8, 0, 0, 0, 0)
            mouse_event (16, 0, 0, 0, 0)
            程序_延时 (GetDoubleClickTime ())
            mouse_event (8, 0, 0, 0, 0)
            mouse_event (16, 0, 0, 0, 0)
        .如果真结束
        
    .如果真结束
    

.子程序 鼠标_消息, , 公开, 向指定窗口发送鼠标动作消息(无返回值)
    .参数 窗口句柄, 整数型, 可空, 可空:为桌面超级列表框句柄  接收鼠标消息窗口句柄
    .参数 水平坐标, 整数型, 可空, 可空:为原水平坐标不变  移动目标鼠标水平坐标 (注:坐标为参数一窗口句柄中的坐标)
    .参数 垂直坐标, 整数型, 可空, 可空:为原垂直坐标不变  移动目标鼠标垂直坐标
    .参数 键, 整数型, 可空, 可空:为左键  1 #左键   2 #右键   3 #中键  4 #中键上滚动 5 #中键下滚动(滚动前后请按下放开中键)
    .参数 控制, 整数型, 可空, 可空:为单击  1 #单击   2 #双击   3 #按下  4 #放开
    .局部变量 坐标值, 整数型
    .局部变量 坐标, 精易_坐标

    .如果真 (窗口句柄 ＝ 0)
        窗口句柄 ＝ GetDesktopWindow ()
    .如果真结束
    ' 坐标 ＝ 鼠标_取窗口坐标 (窗口句柄)
    .如果真 (是否为空 (水平坐标))
        水平坐标 ＝ 2
    .如果真结束
    .如果真 (是否为空 (垂直坐标))
        垂直坐标 ＝ 2
    .如果真结束
    坐标值 ＝ 水平坐标 ＋ 垂直坐标 × 65536
    .如果真 (键 ＝ 4) ' 中键上滚动
        投递消息整数 (窗口句柄, 522, 7864336, 坐标值 ＋ 25100873)
        返回 ()
    .如果真结束
    .如果真 (键 ＝ 5) ' 中键下滚动
        投递消息整数 (窗口句柄, 522, -7864304, 坐标值 ＋ 25100873)
        返回 ()
    .如果真结束
    投递消息整数 (窗口句柄, 512, 2, 坐标值)
    .如果真 (键 ＝ 0 或 键 ＝ 1)
        .如果真 (控制 ＝ 0 或 控制 ＝ 1)
            投递消息整数 (窗口句柄, 513, 1, 坐标值) ' 左键按下
            投递消息整数 (窗口句柄, 514, 0, 坐标值) ' 左键放开
        .如果真结束
        .如果真 (控制 ＝ 2)
            投递消息整数 (窗口句柄, 513, 1, 坐标值)
            投递消息整数 (窗口句柄, 514, 0, 坐标值)
            投递消息整数 (窗口句柄, 515, 0, 坐标值) ' 双击左键
        .如果真结束
        .如果真 (控制 ＝ 3)
            投递消息整数 (窗口句柄, 513, 1, 坐标值)
        .如果真结束
        .如果真 (控制 ＝ 4)
            投递消息整数 (窗口句柄, 514, 0, 坐标值)
        .如果真结束
        返回 ()
    .如果真结束
    .如果真 (键 ＝ 2)
        .如果真 (控制 ＝ 0 或 控制 ＝ 1)
            投递消息整数 (窗口句柄, 516, 2, 坐标值) ' 右键按下
            投递消息整数 (窗口句柄, 517, 2, 坐标值) ' 右键放开
            
        .如果真结束
        .如果真 (控制 ＝ 2)
            投递消息整数 (窗口句柄, 516, 2, 坐标值)
            投递消息整数 (窗口句柄, 517, 2, 坐标值)
            投递消息整数 (窗口句柄, 518, 0, 坐标值) ' 双击右键
            
        .如果真结束
        .如果真 (控制 ＝ 3)
            投递消息整数 (窗口句柄, 516, 2, 坐标值)
            
        .如果真结束
        .如果真 (控制 ＝ 4)
            投递消息整数 (窗口句柄, 517, 2, 坐标值)
            
        .如果真结束
        投递消息整数 (窗口句柄, 123, 132782, 坐标值 ＋ 25100873) ' 右键放开
        返回 ()
    .如果真结束
    .如果真 (键 ＝ 3)
        .如果真 (控制 ＝ 0 或 控制 ＝ 1)
            投递消息整数 (窗口句柄, 519, 16, 坐标值) ' 中键按下
            投递消息整数 (窗口句柄, 520, 0, 坐标值) ' 中键放开
        .如果真结束
        .如果真 (控制 ＝ 2)
            投递消息整数 (窗口句柄, 519, 16, 坐标值)
            投递消息整数 (窗口句柄, 520, 0, 坐标值)
            投递消息整数 (窗口句柄, 521, 0, 坐标值) ' 双击中键
        .如果真结束
        .如果真 (控制 ＝ 3)
            投递消息整数 (窗口句柄, 519, 16, 坐标值)
        .如果真结束
        .如果真 (控制 ＝ 4)
            投递消息整数 (窗口句柄, 520, 0, 坐标值)
        .如果真结束
        返回 ()
    .如果真结束
    ' WM_MOUSEFIRST = 512
    ' WM_MOUSEMOVE = 512
    ' // 移动鼠标
    ' WM_LBUTTONDOWN = 513
    ' //按下鼠标左键
    ' WM_LBUTTONUP = 514
    ' //释放鼠标左键
    ' WM_LBUTTONDBLCLK = 515
    ' //双击鼠标左键
    ' WM_RBUTTONDOWN = 516
    ' //按下鼠标右键
    ' WM_RBUTTONUP = 517
    ' //释放鼠标右键
    ' WM_RBUTTONDBLCLK = 518
    ' //双击鼠标右键
    ' WM_MBUTTONDOWN = 519
    ' //按下鼠标中键
    ' WM_MBUTTONUP = 520
    ' //释放鼠标中键
    ' WM_MBUTTONDBLCLK = 521
    ' //双击鼠标中键
    ' WM_MOUSEWHEEL = 522
    ' 当鼠标轮子转动时发送此消息个当前有焦点的控件

.子程序 鼠标_记位, 精易_坐标, 公开, 记录当前鼠标坐标
    .局部变量 坐标, 精易_坐标

    记忆坐标变量.横 ＝ 0
    记忆坐标变量.纵 ＝ 0
    坐标 ＝ 鼠标_取位置 ()
    记忆坐标变量.横 ＝ 坐标.横
    记忆坐标变量.纵 ＝ 坐标.纵
    返回 (记忆坐标变量)

.子程序 鼠标_归位, , 公开, 恢复当前鼠标坐标到"鼠标_记位"的坐标点或移动鼠标到指定点(无返回值)
    .参数 坐标, 精易_坐标, 可空, 可空:恢复到上次记录的坐标点

    .如果 (是否为空 (坐标))
        鼠标_移动 (, 记忆坐标变量.横, 记忆坐标变量.纵)
    .否则
        鼠标_移动 (, 坐标.横, 坐标.纵)
    .如果结束
    

.子程序 鼠标_单击, , 公开, 鼠标操作，具体请看参数的备注
    .参数 窗口句柄
    .参数 横坐标, 整数型, 可空, 留空则取鼠标所在位置
    .参数 纵坐标, 整数型, 可空, 留空则取鼠标所在位置
    .参数 类型, 整数型, 可空, 1 = 鼠标左键单击；2 = 鼠标右键单击；3 = 鼠标左键按住不放；
    .局部变量 局_坐标, 精易_坐标
    .局部变量 局_标志

    局_坐标 ＝ 鼠标_取位置 ()
    类型 ＝ 选择 (类型 ＝ 0, 1, 类型)
    横坐标 ＝ 选择 (是否为空 (横坐标), 局_坐标.横, 横坐标)
    纵坐标 ＝ 选择 (是否为空 (纵坐标), 局_坐标.纵, 纵坐标)
    .如果真 (类型 ＞ 0 且 类型 ＜ 4)
        局_标志 ＝ 多项选择 (类型, 6, 24, 3)
        鼠标_移动 (窗口句柄, 横坐标, 纵坐标)
        mouse_event (局_标志, 横坐标, 纵坐标, 0, 0)
        鼠标_移动 (, 局_坐标.横, 局_坐标.纵)
    .如果真结束
    
    ' .判断开始 (类型 ＝ 1)
        ' 鼠标_移动 (窗口句柄, 横坐标, 纵坐标)
        ' mouse_event (6, 横坐标, 纵坐标, 0, 0)
        ' 鼠标_移动 (窗口句柄, 局_坐标.横, 局_坐标.纵)
    ' .判断 (类型 ＝ 2)
        ' 鼠标_移动 (窗口句柄, 横坐标, 纵坐标)
        ' mouse_event (24, 横坐标, 纵坐标, 0, 0)
        ' 鼠标_移动 (窗口句柄, 局_坐标.横, 局_坐标.纵)
    ' .判断 (类型 ＝ 3)
        ' 鼠标_移动 (窗口句柄, 横坐标, 纵坐标)
        ' mouse_event (2, 横坐标, 纵坐标, 0, 0)
        ' 鼠标_移动 (窗口句柄, 局_坐标.横, 局_坐标.纵)
    ' .默认
        
    ' .判断结束
    
    
    ' MOUSEEVENTF_MOVE 1 鼠标移动
    
    ' MOUSEEVENTF_LEFTDOWN 2 左键按下
    ' MOUSEEVENTF_LEFTUP 4 左键放开
    
    ' MOUSEEVENTF_RIGHTDOWN 8 右键按下
    ' MOUSEEVENTF_RIGHTUP 16 右键放开
    
    ' MOUSEEVENTF_MIDDLEDOWN 32 中键按下
    ' MOUSEEVENTF_MIDDLEUP 64 中键放开

.子程序 鼠标_移动, , 公开, 设置鼠标坐标
    .参数 窗口句柄, 整数型, 可空, 可空:相对桌面移动鼠标  句柄有效则相对窗口中坐标移动
    .参数 水平坐标, 整数型, , 水平坐标
    .参数 垂直坐标, 整数型, , 垂直坐标
    .局部变量 临时坐标, 精易_坐标

    .如果真 (窗口句柄 ≠ 0)
        ClientToScreen (窗口句柄, 临时坐标)
    .如果真结束
    SetCursorPos (临时坐标.横 ＋ 水平坐标, 临时坐标.纵 ＋ 垂直坐标)

.子程序 鼠标_取位置, 精易_坐标, 公开, 取鼠标在屏幕中的坐标位置；
    .局部变量 坐标, 精易_坐标

    GetCursorPos (坐标)
    返回 (坐标)

.子程序 鼠标_显示隐藏, , 公开, 设置鼠标指针的可视性,只能在自身窗口隐藏鼠标
    .参数 类型, 逻辑型, , 真 = 隐藏；假 = 显示；

    ShowCursor (取反 (类型))

.子程序 鼠标_改指针, , 公开, 只能改自身程序的鼠标指针；
    .参数 参_窗口句柄, 整数型, , 要改鼠标的窗口句柄
    .参数 参_光标路径, 文本型, 可空, 鼠标文件名路径；支持动态鼠标；
    .参数 参_光标指针, 整数型, 可空, #鼠标指针_
    .局部变量 L, 整数型

    .如果 (是否为空 (参_光标路径) ＝ 假 且 参_光标路径 ≠ “”)
        L ＝ LoadCursorFromFileA (参_光标路径)
    .否则
        L ＝ LoadCursorW (0, 参_光标指针)
    .如果结束
    SetClassLongA (参_窗口句柄, -12, L)

.子程序 鼠标_取窗口坐标, 精易_坐标, 公开, 取回鼠标当前在某个窗口上的坐标
    .参数 窗口句柄, 整数型, 可空, 如果提供窗口句柄，将返回鼠标在该窗口上的坐标；否则将取出屏幕中的坐标；
    .局部变量 光标位置, 精易_坐标
    .局部变量 坐标1, 精易_坐标

    .如果真 (窗口句柄 ≠ 0)
        坐标1 ＝ 窗口_取控件坐标 (窗口句柄)
    .如果真结束
    GetCursorPos (光标位置)
    光标位置.横 ＝ 光标位置.横 － 坐标1.横
    光标位置.纵 ＝ 光标位置.纵 － 坐标1.纵
    返回 (光标位置)

.子程序 鼠标_左右键交换, , 公开, 鼠标左右键交换
    .参数 是否交换, 逻辑型, , 真=左右键交换；假=恢复

    SwapMouseButton (是否交换)

.子程序 鼠标_取双击间隔时间, 整数型, 公开, 取鼠标双击间隔时间
    返回 (GetDoubleClickTime ())

.子程序 鼠标_取指针移动速度, 整数型, 公开, 检索当前鼠标速度
    .局部变量 iMouseSpeed, 整数型

    SystemParametersInfoW (#SPI_GETMOUSESPEED, 0, 取指针整数_ (iMouseSpeed), 0)
    返回 (iMouseSpeed)

.子程序 鼠标_设置指针移动速度, 逻辑型, 公开, 设置当前鼠标速度
    .参数 速度值, 整数型, , 1（最慢）和20（最快）

    返回 (SystemParametersInfoW (#SPI_SETMOUSESPEED, 0, 速度值, 位或 (#SPIF_UPDATEINIFILE, #SPIF_SENDCHANGE)))

.子程序 子程序2, , , ●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●
    

.子程序 键盘_取功能键状态, 整数型, 公开, 取键名的功能键组合，1.Ctrl键，2.Shift键，4.Alt键，其他为组合
    .参数 键名, 文本型, , 键名,如填:Ctrl键,将返回1，字母不区分大小写
    .局部变量 a, 整数型
    .局部变量 b, 整数型
    .局部变量 c, 整数型

    a ＝ 选择 (寻找文本 (键名, “Ctrl键”, , 真) ＝ -1, 0, 1)
    b ＝ 选择 (寻找文本 (键名, “Shift键”, , 真) ＝ -1, 0, 2)
    c ＝ 选择 (寻找文本 (键名, “Alt键”, , 真) ＝ -1, 0, 4)
    返回 (a ＋ b ＋ c)

.子程序 键盘_取功能键名, 文本型, 公开, 取功能键状态对应的键名，1.Ctrl键，2.Shift键，4.Alt键，其他为组合
    .参数 功能键状态, 整数型, , 功能键状态,如填1，将返回Ctrl键
    .局部变量 键名, 文本型

    .判断开始 (功能键状态 ＝ 1)
        键名 ＝ “Ctrl键”
    .判断 (功能键状态 ＝ 2)
        键名 ＝ “Shift键”
    .判断 (功能键状态 ＝ 3)
        键名 ＝ “Ctrl键” ＋ “Shift键”
    .判断 (功能键状态 ＝ 4)
        键名 ＝ “Alt键”
    .判断 (功能键状态 ＝ 5)
        键名 ＝ “Ctrl键” ＋ “Alt键”
    .判断 (功能键状态 ＝ 6)
        键名 ＝ “Shift键” ＋ “Alt键”
    .判断 (功能键状态 ＝ 7)
        键名 ＝ “Ctrl键” ＋ “Shift键” ＋ “Alt键”
    .默认
        键名 ＝ “”
    .判断结束
    返回 (键名)

.子程序 键盘_模拟输入, , 公开, 利用vbs脚本模拟键盘输入，感谢小磊提供
    .参数 字符, 文本型, , 待输入的字符
    .局部变量 vbs, 对象
    .局部变量 局_字符, 文本型

    局_字符 ＝ 字符
    局_字符 ＝ 子文本替换 (局_字符, “+”, “{+}”, , , 真)
    局_字符 ＝ 子文本替换 (局_字符, “^”, “{^}”, , , 真)
    局_字符 ＝ 子文本替换 (局_字符, “%”, “{%}”, , , 真)
    局_字符 ＝ 子文本替换 (局_字符, “~”, “{~}”, , , 真)
    CoInitialize (0)
    vbs.创建 (“wscript.shell”, )
    vbs.写属性 (“SendKeys”, 局_字符)
    CoUninitialize ()

.子程序 键盘_锁定, , 公开, 锁定所有键盘按键(锁定后,键盘无法操作) 
    .参数 状态, 逻辑型, 可空, 可空。真=锁全键盘(可空为假)，假=锁定功能键与Win键Esc键F4键Tab键Print键Soroll键Pause键

    .如果真 (键盘锁定钩子句柄 ≠ 0)
        UnhookWindowsHookEx (键盘锁定钩子句柄)
    .如果真结束
    集_键盘状态 ＝ 状态
    键盘锁定钩子句柄 ＝ SetWindowsHookExA (#WH_KEYBOARD_LL, &键盘钩子处理, GetModuleHandleA1 (0), 0)

.子程序 键盘钩子处理, 整数型, , 锁键盘
    .参数 icode, 整数型
    .参数 wParam, 整数型
    .参数 lParam, 整数型
    .局部变量 按键信息, MSG

    .如果真 (icode ＝ 0)
        RtlMoveMemory_MSG1 (按键信息, lParam, 28)
        .判断开始 (集_键盘状态 ＝ 假)
            .如果真 (按键信息.hwnd ＝ #Esc键 或 按键信息.hwnd ＝ #Tab键 或 按键信息.hwnd ＝ #F4键)
                返回 (1)
            .如果真结束
            
            .如果真 (按键信息.hwnd ＝ 44 或 按键信息.hwnd ＝ 145 或 按键信息.hwnd ＝ 19) ' Print键 Scroll键 Pause键
                返回 (1)
            .如果真结束
            
            .如果真 (按键信息.hwnd ＝ 91 或 按键信息.hwnd ＝ 92 或 按键信息.hwnd ＝ 93) ' 左右Win键与菜单键
                返回 (1)
            .如果真结束
            
            .如果真 (按键信息.hwnd ＝ 160 或 按键信息.hwnd ＝ 161) ' 左右Shift键
                返回 (1)
            .如果真结束
            
            .如果真 (按键信息.hwnd ＝ 162 或 按键信息.hwnd ＝ 163) ' 左右Ctrl键
                返回 (1)
            .如果真结束
            
            .如果真 (按键信息.hwnd ＝ 164 或 按键信息.hwnd ＝ 165) ' 左右Alt键
                返回 (1)
            .如果真结束
            
            返回 (0)
        .默认
            返回 (1)
        .判断结束
        
    .如果真结束
    返回 (CallNextHookEx (键盘锁定钩子句柄, icode, wParam, lParam))

.子程序 键盘_解锁, , 公开, 键盘解锁(键盘锁定后,用来恢复键盘的使用)
    .如果真 (键盘锁定钩子句柄 ≠ 0)
        UnhookWindowsHookEx (键盘锁定钩子句柄)
    .如果真结束
    

.子程序 键盘_单击, , 公开, 前台模拟键盘操作
    .参数 键代码, 整数型, , 键代码；如A是65，就直接输65
    .参数 状态, 整数型, 可空, 留空为单击；1按下   2放开

    .判断开始 (状态 ＝ 1)
        keybd_event (键代码, 0, 0, 0)
    .判断 (状态 ＝ 2)
        keybd_event (键代码, 0, 2, 0)
    .默认
        keybd_event (键代码, 0, 0, 0)
        处理事件 ()
        keybd_event (键代码, 0, 2, 0)
    .判断结束
    

.子程序 键盘_消息, , 公开, 向指定窗口句柄的窗口中发送按键消息(无返回值)
    .参数 窗口句柄, 整数型, , 接收消息的窗口句柄
    .参数 键代码, 整数型, , 按键的键代码
    .参数 状态, 整数型, 可空, 可空。默认为1  1=输入字符 2=1(废弃)  3=按下，4=放开，5=单击
    .参数 是否功能键, 逻辑型, 可空, 可空。默认为假：普通键   真:功能键 (为功能键可用于热键技能不输入字符)
    .局部变量 uMsg, 整数型
    .局部变量 nScan, 整数型
    .局部变量 lParam, 整数型

    .判断开始 (状态 ＝ 3) ' 按下
        uMsg ＝ 选择 (是否功能键, #WM_SYSKEYDOWN, #WM_KEYDOWN)
        nScan ＝ MapVirtualKeyA (键代码, #MAPVK_VK_TO_VSC)
        lParam ＝ 生成键盘消息lParam (1, nScan, 是否功能键, 假, 假, 假)
        PostMessageW (窗口句柄, uMsg, 键代码, lParam)
    .判断 (状态 ＝ 4) ' 放开
        uMsg ＝ 选择 (是否功能键, #WM_SYSKEYUP, #WM_KEYUP)
        nScan ＝ MapVirtualKeyA (键代码, #MAPVK_VK_TO_VSC)
        lParam ＝ 生成键盘消息lParam (1, nScan, 是否功能键, 假, 真, 真)
        PostMessageW (窗口句柄, uMsg, 键代码, lParam)
    .判断 (状态 ＝ 5) ' 单击 => 按下 + 放开
        键盘_消息 (窗口句柄, 键代码, 3, 是否功能键)
        键盘_消息 (窗口句柄, 键代码, 4, 是否功能键)
    .默认
        ' 输入字符
        .判断开始 (键代码 ＝ 58 或 键代码 ＝ 59)
            nScan ＝ MapVirtualKeyA (#VK_OEM_1, #MAPVK_VK_TO_VSC)
        .判断 (键代码 ＝ 43)
            nScan ＝ MapVirtualKeyA (#VK_OEM_PLUS, #MAPVK_VK_TO_VSC)
        .判断 (键代码 ＝ 44)
            nScan ＝ MapVirtualKeyA (#VK_OEM_COMMA, #MAPVK_VK_TO_VSC)
        .判断 (键代码 ＝ 45)
            nScan ＝ MapVirtualKeyA (#VK_OEM_MINUS, #MAPVK_VK_TO_VSC)
        .判断 (键代码 ＝ 46)
            nScan ＝ MapVirtualKeyA (#VK_OEM_PERIOD, #MAPVK_VK_TO_VSC)
        .判断 (键代码 ＝ 47 或 键代码 ＝ 63)
            nScan ＝ MapVirtualKeyA (#VK_OEM_2, #MAPVK_VK_TO_VSC)
        .判断 (键代码 ＝ 96 或 键代码 ＝ 126)
            nScan ＝ MapVirtualKeyA (#VK_OEM_3, #MAPVK_VK_TO_VSC)
        .判断 (键代码 ≥ 97 且 键代码 ≤ 122)
            nScan ＝ MapVirtualKeyA (键代码 － 32, #MAPVK_VK_TO_VSC)
        .默认
            nScan ＝ MapVirtualKeyA (键代码, #MAPVK_VK_TO_VSC)
        .判断结束
        lParam ＝ 生成键盘消息lParam (1, nScan, 是否功能键, 假, 假, 假)
        PostMessageW (窗口句柄, #WM_CHAR, 键代码, lParam)
    .判断结束
    

.子程序 键盘_组合按键, , 公开, 模拟一个组合按键；如:Ctrl+A
    .参数 键代码, 整数型, , 键代码；如：A(65)
    .参数 功能键码1, 整数型, , 功能键代码；如：ctrl(1) 或 #ctrl
    .参数 功能键码2, 整数型, 可空, 功能键代码(可以留空)
    .参数 功能键码3, 整数型, 可空, 功能键代码(可以留空)

    .如果真 (功能键码3 ≠ 0)
        keybd_event (功能键码3, 0, 0, 0)
    .如果真结束
    .如果真 (功能键码2 ≠ 0)
        keybd_event (功能键码2, 0, 0, 0)
    .如果真结束
    keybd_event (功能键码1, 0, 0, 0)
    keybd_event (键代码, 0, 0, 0)
    .如果真 (功能键码3 ≠ 0)
        keybd_event (功能键码3, 0, 2, 0)
    .如果真结束
    .如果真 (功能键码2 ≠ 0)
        keybd_event (功能键码2, 0, 2, 0)
    .如果真结束
    keybd_event (功能键码1, 0, 2, 0)
    keybd_event (键代码, 0, 2, 0)

.子程序 键盘_组合按键1, 整数型, 公开, 成功返回插入到键盘中的事件数，失败返回0。
    .参数 键代码, 整数型, 数组, { #VK_RMENU, #空格键, #N键 }
    .局部变量 dwCount, 整数型
    .局部变量 aryInput, INPUT, , "0"
    .局部变量 i, 整数型

    dwCount ＝ 取数组成员数 (键代码)
    重定义数组 (aryInput, 假, dwCount × 2)
    .计次循环首 (到整数 (dwCount × 2), i)
        aryInput [i].type ＝ #INPUT_KEYBOARD
        .如果 (i ＞ dwCount)
            aryInput [i].wVk ＝ 键代码 [dwCount － (i － dwCount) ＋ 1]
            aryInput [i].dwFlags ＝ #KEYEVENTF_KEYUP
        .否则
            aryInput [i].wVk ＝ 键代码 [i]
        .如果结束
        aryInput [i].wScan ＝ MapVirtualKeyA (aryInput [i].wVk, #MAPVK_VK_TO_VSC)
    .计次循环尾 ()
    返回 (SendInput (dwCount × 2, aryInput, 28)) ' sizeof(INPUT)

.子程序 键盘_键名取键代码, 整数型, 公开, 取键名的键代码(返回键代码)
    .参数 键名, 文本型, , 键名,如填:A键,将返回65的键代码
    .局部变量 按键码, 整数型

    .判断开始 (到小写 (键名) ＝ “win键”)
        按键码 ＝ 91
    .判断 (到小写 (键名) ＝ “ctrl键”)
        按键码 ＝ #Ctrl键
    .判断 (到小写 (键名) ＝ “shift键”)
        按键码 ＝ #Shift键
    .判断 (到小写 (键名) ＝ “alt键”)
        按键码 ＝ #Alt键
    .判断 (键名 ＝ “0键”)
        按键码 ＝ #键0
    .判断 (键名 ＝ “1键”)
        按键码 ＝ #键1
    .判断 (键名 ＝ “2键”)
        按键码 ＝ #键2
    .判断 (键名 ＝ “3键”)
        按键码 ＝ #键3
    .判断 (键名 ＝ “4键”)
        按键码 ＝ #键4
    .判断 (键名 ＝ “5键”)
        按键码 ＝ #键5
    .判断 (键名 ＝ “6键”)
        按键码 ＝ #键6
    .判断 (键名 ＝ “7键”)
        按键码 ＝ #键7
    .判断 (键名 ＝ “8键”)
        按键码 ＝ #键8
    .判断 (键名 ＝ “9键”)
        按键码 ＝ #键9
    .判断 (到大写 (键名) ＝ “A键”)
        按键码 ＝ #A键
    .判断 (到大写 (键名) ＝ “B键”)
        按键码 ＝ #B键
    .判断 (到大写 (键名) ＝ “C键”)
        按键码 ＝ #C键
    .判断 (到大写 (键名) ＝ “D键”)
        按键码 ＝ #D键
    .判断 (到大写 (键名) ＝ “E键”)
        按键码 ＝ #E键
    .判断 (到大写 (键名) ＝ “F键”)
        按键码 ＝ #F键
    .判断 (到大写 (键名) ＝ “G键”)
        按键码 ＝ #G键
    .判断 (到大写 (键名) ＝ “H键”)
        按键码 ＝ #H键
    .判断 (到大写 (键名) ＝ “I键”)
        按键码 ＝ #I键
    .判断 (到大写 (键名) ＝ “J键”)
        按键码 ＝ #J键
    .判断 (到大写 (键名) ＝ “K键”)
        按键码 ＝ #K键
    .判断 (到大写 (键名) ＝ “L键”)
        按键码 ＝ #L键
    .判断 (到大写 (键名) ＝ “M键”)
        按键码 ＝ #M键
    .判断 (到大写 (键名) ＝ “N键”)
        按键码 ＝ #N键
    .判断 (到大写 (键名) ＝ “O键”)
        按键码 ＝ #O键
    .判断 (到大写 (键名) ＝ “P键”)
        按键码 ＝ #P键
    .判断 (到大写 (键名) ＝ “Q键”)
        按键码 ＝ #Q键
    .判断 (到大写 (键名) ＝ “R键”)
        按键码 ＝ #R键
    .判断 (到大写 (键名) ＝ “S键”)
        按键码 ＝ #S键
    .判断 (到大写 (键名) ＝ “T键”)
        按键码 ＝ #T键
    .判断 (到大写 (键名) ＝ “U键”)
        按键码 ＝ #U键
    .判断 (到大写 (键名) ＝ “V键”)
        按键码 ＝ #V键
    .判断 (到大写 (键名) ＝ “W键”)
        按键码 ＝ #W键
    .判断 (到大写 (键名) ＝ “X键”)
        按键码 ＝ #X键
    .判断 (到大写 (键名) ＝ “Y键”)
        按键码 ＝ #Y键
    .判断 (到大写 (键名) ＝ “Z键”)
        按键码 ＝ #Z键
    .判断 (到大写 (键名) ＝ “F1键”)
        按键码 ＝ #F1键
    .判断 (到大写 (键名) ＝ “F2键”)
        按键码 ＝ #F2键
    .判断 (到大写 (键名) ＝ “F3键”)
        按键码 ＝ #F3键
    .判断 (到大写 (键名) ＝ “F4键”)
        按键码 ＝ #F4键
    .判断 (到大写 (键名) ＝ “F5键”)
        按键码 ＝ #F5键
    .判断 (到大写 (键名) ＝ “F6键”)
        按键码 ＝ #F6键
    .判断 (到大写 (键名) ＝ “F7键”)
        按键码 ＝ #F7键
    .判断 (到大写 (键名) ＝ “F8键”)
        按键码 ＝ #F8键
    .判断 (到大写 (键名) ＝ “F9键”)
        按键码 ＝ #F9键
    .判断 (到大写 (键名) ＝ “F10键”)
        按键码 ＝ #F10键
    .判断 (到大写 (键名) ＝ “F11键”)
        按键码 ＝ #F11键
    .判断 (到大写 (键名) ＝ “F12键”)
        按键码 ＝ #F12键
    .判断 (到大写 (键名) ＝ “F13键”)
        按键码 ＝ #F13键
    .判断 (到大写 (键名) ＝ “F14键”)
        按键码 ＝ #F14键
    .判断 (到大写 (键名) ＝ “F15键”)
        按键码 ＝ #F15键
    .判断 (到大写 (键名) ＝ “F16键”)
        按键码 ＝ #F16键
    .判断 (键名 ＝ “break键”)
        按键码 ＝ #Break键
    .判断 (键名 ＝ “Tab键”)
        按键码 ＝ #Tab键
    .判断 (键名 ＝ “回车键”)
        按键码 ＝ #回车键
    .判断 (到小写 (键名) ＝ “pause键”)
        按键码 ＝ #Pause键
    .判断 (到小写 (键名) ＝ “capsLock键”)
        按键码 ＝ #CapsLock键
    .判断 (到小写 (键名) ＝ “numLock键”)
        按键码 ＝ #NumLock键
    .判断 (到小写 (键名) ＝ “scrollLock键”)
        按键码 ＝ #ScrollLock键
    .判断 (到小写 (键名) ＝ “esc键”)
        按键码 ＝ #Esc键
    .判断 (键名 ＝ “空格键”)
        按键码 ＝ #空格键
    .判断 (到小写 (键名) ＝ “pageup键”)
        按键码 ＝ #PageUp键
    .判断 (到小写 (键名) ＝ “pagedown键”)
        按键码 ＝ #PageDown键
    .判断 (到小写 (键名) ＝ “home键”)
        按键码 ＝ #Home键
    .判断 (到小写 (键名) ＝ “end键”)
        按键码 ＝ #End键
    .判断 (键名 ＝ “左光标键”)
        按键码 ＝ #左光标键
    .判断 (键名 ＝ “上光标键”)
        按键码 ＝ #上光标键
    .判断 (键名 ＝ “右光标键”)
        按键码 ＝ #右光标键
    .判断 (键名 ＝ “下光标键”)
        按键码 ＝ #下光标键
    .判断 (到小写 (键名) ＝ “ins键”)
        按键码 ＝ #Ins键
    .判断 (到小写 (键名) ＝ “del键”)
        按键码 ＝ #Del键
    .判断 (键名 ＝ “分号键”)
        按键码 ＝ #分号键
    .判断 (键名 ＝ “等号键”)
        按键码 ＝ #等号键
    .判断 (键名 ＝ “逗号键”)
        按键码 ＝ #逗号键
    .判断 (键名 ＝ “减号键”)
        按键码 ＝ #减号键
    .判断 (键名 ＝ “圆点键”)
        按键码 ＝ #圆点键
    .判断 (键名 ＝ “除号键”)
        按键码 ＝ #除号键
    .判断 (键名 ＝ “反撇号键”)
        按键码 ＝ #反撇号键
    .判断 (键名 ＝ “左中括号键”)
        按键码 ＝ #左中括号键
    .判断 (键名 ＝ “右中括号键”)
        按键码 ＝ #右中括号键
    .判断 (键名 ＝ “斜杠键”)
        按键码 ＝ #斜杠键
    .判断 (键名 ＝ “单引号键”)
        按键码 ＝ #单引号键
    .判断 (键名 ＝ “乘号键”)
        按键码 ＝ 106
    .判断 (键名 ＝ “加号键”)
        按键码 ＝ 107
    .判断 (键名 ＝ “退格键”)
        按键码 ＝ #退格键
    .判断 (键名 ＝ “~”)
        按键码 ＝ 192
    .判断 (到小写 (键名) ＝ “左shift键”)
        按键码 ＝ 160
    .判断 (到小写 (键名) ＝ “右shift键”)
        按键码 ＝ 161
    .判断 (到大写 (键名) ＝ “左CTRL键”)
        按键码 ＝ 162
    .判断 (到大写 (键名) ＝ “右CTRL键”)
        按键码 ＝ 163
    .默认
        
    .判断结束
    返回 (按键码)

.子程序 键盘_键代码取键名, 文本型, 公开, 取键代码的键名(返回键名)
    .参数 键代码, 整数型, , 键代码,如填:65,将返回 A键
    .局部变量 文本, 文本型

    .判断开始 (键代码 ＝ #Ctrl键)
        文本 ＝ “Ctrl键”
    .判断 (键代码 ＝ #Shift键)
        文本 ＝ “Shift键”
    .判断 (键代码 ＝ #Alt键)
        文本 ＝ “Alt键”
    .判断 (键代码 ＝ #键0)
        文本 ＝ “0键”
    .判断 (键代码 ＝ #键1)
        文本 ＝ “1键”
    .判断 (键代码 ＝ #键2)
        文本 ＝ “2键”
    .判断 (键代码 ＝ #键3)
        文本 ＝ “3键”
    .判断 (键代码 ＝ #键4)
        文本 ＝ “4键”
    .判断 (键代码 ＝ #键5)
        文本 ＝ “5键”
    .判断 (键代码 ＝ #键6)
        文本 ＝ “6键”
    .判断 (键代码 ＝ #键7)
        文本 ＝ “7键”
    .判断 (键代码 ＝ #键8)
        文本 ＝ “8键”
    .判断 (键代码 ＝ #键9)
        文本 ＝ “9键”
    .判断 (键代码 ＝ #A键)
        文本 ＝ “A键”
    .判断 (键代码 ＝ #B键)
        文本 ＝ “B键”
    .判断 (键代码 ＝ #C键)
        文本 ＝ “C键”
    .判断 (键代码 ＝ #D键)
        文本 ＝ “D键”
    .判断 (键代码 ＝ #E键)
        文本 ＝ “E键”
    .判断 (键代码 ＝ #F键)
        文本 ＝ “F键”
    .判断 (键代码 ＝ #G键)
        文本 ＝ “G键”
    .判断 (键代码 ＝ #H键)
        文本 ＝ “H键”
    .判断 (键代码 ＝ #I键)
        文本 ＝ “I键”
    .判断 (键代码 ＝ #J键)
        文本 ＝ “J键”
    .判断 (键代码 ＝ #K键)
        文本 ＝ “K键”
    .判断 (键代码 ＝ #L键)
        文本 ＝ “L键”
    .判断 (键代码 ＝ #M键)
        文本 ＝ “M键”
    .判断 (键代码 ＝ #N键)
        文本 ＝ “N键”
    .判断 (键代码 ＝ #O键)
        文本 ＝ “O键”
    .判断 (键代码 ＝ #P键)
        文本 ＝ “P键”
    .判断 (键代码 ＝ #Q键)
        文本 ＝ “Q键”
    .判断 (键代码 ＝ #R键)
        文本 ＝ “R键”
    .判断 (键代码 ＝ #S键)
        文本 ＝ “S键”
    .判断 (键代码 ＝ #T键)
        文本 ＝ “T键”
    .判断 (键代码 ＝ #U键)
        文本 ＝ “U键”
    .判断 (键代码 ＝ #V键)
        文本 ＝ “V键”
    .判断 (键代码 ＝ #W键)
        文本 ＝ “W键”
    .判断 (键代码 ＝ #X键)
        文本 ＝ “X键”
    .判断 (键代码 ＝ #Y键)
        文本 ＝ “Y键”
    .判断 (键代码 ＝ #Z键)
        文本 ＝ “Z键”
    .判断 (键代码 ＝ #F1键)
        文本 ＝ “F1键”
    .判断 (键代码 ＝ #F2键)
        文本 ＝ “F2键”
    .判断 (键代码 ＝ #F3键)
        文本 ＝ “F3键”
    .判断 (键代码 ＝ #F4键)
        文本 ＝ “F4键”
    .判断 (键代码 ＝ #F5键)
        文本 ＝ “F5键”
    .判断 (键代码 ＝ #F6键)
        文本 ＝ “F6键”
    .判断 (键代码 ＝ #F7键)
        文本 ＝ “F7键”
    .判断 (键代码 ＝ #F8键)
        文本 ＝ “F8键”
    .判断 (键代码 ＝ #F9键)
        文本 ＝ “F9键”
    .判断 (键代码 ＝ #F10键)
        文本 ＝ “F10键”
    .判断 (键代码 ＝ #F11键)
        文本 ＝ “F11键”
    .判断 (键代码 ＝ #F12键)
        文本 ＝ “F12键”
    .判断 (键代码 ＝ #F13键)
        文本 ＝ “F13键”
    .判断 (键代码 ＝ #F14键)
        文本 ＝ “F14键”
    .判断 (键代码 ＝ #F15键)
        文本 ＝ “F15键”
    .判断 (键代码 ＝ #F16键)
        文本 ＝ “F16键”
    .判断 (键代码 ＝ #Break键)
        文本 ＝ “Break”
    .判断 (键代码 ＝ #回车键)
        文本 ＝ “回车键”
    .判断 (键代码 ＝ #Pause键)
        文本 ＝ “Pause键”
    .判断 (键代码 ＝ #CapsLock键)
        文本 ＝ “Caps Lock键”
    .判断 (键代码 ＝ #NumLock键)
        文本 ＝ “NumLock键”
    .判断 (键代码 ＝ #ScrollLock键)
        文本 ＝ “ScrollLock键”
    .判断 (键代码 ＝ #Esc键)
        文本 ＝ “Esc键”
    .判断 (键代码 ＝ #空格键)
        文本 ＝ “空格键”
    .判断 (键代码 ＝ #PageUp键)
        文本 ＝ “PageUp键”
    .判断 (键代码 ＝ #PageDown键)
        文本 ＝ “PageDown键”
    .判断 (键代码 ＝ #Home键)
        文本 ＝ “Home键”
    .判断 (键代码 ＝ #End键)
        文本 ＝ “End键”
    .判断 (键代码 ＝ #左光标键)
        文本 ＝ “左光标键”
    .判断 (键代码 ＝ #上光标键)
        文本 ＝ “上光标键”
    .判断 (键代码 ＝ #右光标键)
        文本 ＝ “右光标键”
    .判断 (键代码 ＝ #下光标键)
        文本 ＝ “下光标键”
    .判断 (键代码 ＝ #Ins键)
        文本 ＝ “Ins键”
    .判断 (键代码 ＝ #Del键)
        文本 ＝ “Del键”
    .判断 (键代码 ＝ #分号键)
        文本 ＝ “分号键”
    .判断 (键代码 ＝ #等号键)
        文本 ＝ “等号键”
    .判断 (键代码 ＝ #逗号键)
        文本 ＝ “逗号键”
    .判断 (键代码 ＝ #减号键)
        文本 ＝ “减号键”
    .判断 (键代码 ＝ #圆点键)
        文本 ＝ “圆点键”
    .判断 (键代码 ＝ #除号键)
        文本 ＝ “除号键”
    .判断 (键代码 ＝ #反撇号键)
        文本 ＝ “反撇号键”
    .判断 (键代码 ＝ #左中括号键)
        文本 ＝ “左中括号键”
    .判断 (键代码 ＝ #右中括号键)
        文本 ＝ “右中括号键”
    .判断 (键代码 ＝ #斜杠键)
        文本 ＝ “斜杠键”
    .判断 (键代码 ＝ #单引号键)
        文本 ＝ “单引号键”
    .判断 (键代码 ＝ 106)
        文本 ＝ “乘号键”
    .判断 (键代码 ＝ 107)
        文本 ＝ “加号键”
    .判断 (键代码 ＝ #退格键)
        文本 ＝ “退格键”
    .判断 (键代码 ＝ 91)
        文本 ＝ “Win键”
    .判断 (键代码 ＝ #Tab键)
        文本 ＝ “Tab键”
    .判断 (键代码 ＝ 192)
        文本 ＝ “~”
    .判断 (键代码 ＝ 160)
        文本 ＝ “左shift键”
    .判断 (键代码 ＝ 161)
        文本 ＝ “右shift键”
    .判断 (键代码 ＝ 162)
        文本 ＝ “左CTRL键”
    .判断 (键代码 ＝ 163)
        文本 ＝ “右CTRL键”
    .默认
        
    .判断结束
    返回 (文本)

.子程序 键盘_键代码取键名1, 文本型, 公开, 成功返回键代码的键名
    .参数 键代码, 整数型
    .局部变量 scanCode, 整数型
    .局部变量 szString, 文本型

    scanCode ＝ MapVirtualKeyA (键代码, #MAPVK_VK_TO_VSC)
    .如果真 (键代码 ＝ #左光标键 或 键代码 ＝ #上光标键 或 键代码 ＝ #右光标键 或 键代码 ＝ #下光标键 或 键代码 ＝ #PageUp键 或 键代码 ＝ #PageDown键 或 键代码 ＝ #End键 或 键代码 ＝ #Home键 或 键代码 ＝ #Ins键 或 键代码 ＝ #Del键 或 键代码 ＝ #VK_DIVIDE 或 键代码 ＝ #NumLock键)
        scanCode ＝ 位或 (scanCode, 256)
    .如果真结束
    szString ＝ 取空白文本 (256)
    GetKeyNameTextA (左移 (scanCode, 16), szString, 256)
    返回 (szString)

.子程序 键盘_取大小写状态, 逻辑型, 公开, 取当前的输入状态,返回真为大写,返回假则为小写
    返回 (GetKeyState (20))
    

.子程序 键盘_取小键盘状态, 逻辑型, 公开, 取当前的输入状态,返回真为开,返回假则为关
    返回 (GetKeyState (144))
    

.子程序 键盘_置键盘延迟, 逻辑型, 公开, 设置键盘重复延迟设置
    .参数 延迟, 整数型, , 最低为0，最高为3

    返回 (SystemParametersInfoA (#SPI_SETKEYBOARDDELAY, 延迟, #NULL, #SPIF_SENDCHANGE))

.子程序 键盘_取键盘延迟, 整数型, 公开, 检索键盘重复延迟设置
    .局部变量 dwDelay, 整数型

    SystemParametersInfoA (#SPI_GETKEYBOARDDELAY, 0, 取指针整数_ (dwDelay), 0)
    返回 (dwDelay)

.子程序 键盘_置键盘重复速度, 逻辑型, 公开, 设置键盘重复速度设置
    .参数 重复速度, 整数型, , 最低为0，最高为31

    返回 (SystemParametersInfoA (#SPI_SETKEYBOARDSPEED, 重复速度, 0, #SPIF_SENDCHANGE))

.子程序 键盘_取键盘重复速度, 整数型, 公开, 检索键盘重复速度设置
    .局部变量 dwSpeed, 整数型

    SystemParametersInfoA (#SPI_GETKEYBOARDSPEED, 0, 取指针整数_ (dwSpeed), 0)
    返回 (dwSpeed)

@echo off
 
set _task=程序名
set _svr=程序路径
 
:checkstart
tasklist|findstr /i %_task%&&goto checkag||goto startsvr
 
 
 
:startsvr
echo %time%
echo ********程序开始启动********
echo 程序重新启动于 %time% ,请检查系统日志 >> restart_service.txt
set/p=.<nul
for /L %%i in (1 1 2) do set /p a=.<nul&ping.exe /n 1 127.0.0.1>nul
echo .
start %_svr%
echo Wscript.Sleep WScript.Arguments(0) >%tmp%/delay.vbs
cscript //b //nologo %tmp%/delay.vbs 1000
echo ********程序启动完成********
goto checkstart
 
 
:checkag
echo %time% 程序运行正常,1秒后继续检查..
echo Wscript.Sleep WScript.Arguments(0) >%tmp%/delay.vbs
cscript //b //nologo %tmp%/delay.vbs 1000
goto checkstartOption Explicit
Dim wmi,proc,procs,proname,flag,WshShell
Do
    proname = "程序名"
    Set wmi = GetObject("winmgmts:{impersonationlevel=impersonate}!\\.\root\cimv2")
    Set procs = wmi.execquery("select * from win32_process")
    flag = True
    For Each proc In procs
        If StrComp(proc.name,proname) = 0 Then
            flag = False
            Exit For
        End If
    Next
    Set wmi = Nothing
    If flag Then
        Set WshShell = WScript.CreateObject("Wscript.Shell")
        WshShell.Run ("程序路径")
    End If
    WScript.sleep 1000 '检测间隔时间，这里是50秒    
LoopFunction GetSysInfo()
Dim wmi,str
Set wmi = GetObject("winmgmts:{impersonationLevel=impersonate}")

' -------------- 取计算机基本信息

Set system = wmi.InstancesOf("Win32_ComputerSystem")
For Each item In System
  str = str & "---计算机操作系统基本信息---" & vbCrLf
  str = str & "计算机名称:" & item.name & vbCrLf
  str = str & "状态:" & item.Status & vbCrLf
  str = str & "类型:" & item.SystemType & vbCrLf
  str = str & "生产厂家:" & item.Manufacturer & vbCrLf
  str = str & "型号:" & item.Model & vbCrLf
  str = str & "内存:" & Int(item.totalPhysicalMemory /1024 / 1024) & "Mb" & vbCrLf
  str = str & "域:" & item.domain & vbCrLf & vbCrLf
  str = str & "工作组:" & item.Workgroup & vbCrLf & vbCrLf

  str = str & "当前用户:" & item.username & vbCrLf
  str = str & "启动状态:" & item.Bootupstate & vbCrLf
  str = str & "注册给:" & item.PrimaryOwnerName & vbCrLf
  str = str & "系统类型:" & item.CreationClassName & vbCrLf
  str = str & "计算机描述:" & item.Description & vbCrLf
Next

' -------------- 取网卡MAC址

Set Objs = wmi.ExecQuery("Select MACAddress From Win32_NetworkAdapter Where ((MACAddress Is Not NULL) AND (Manufacturer <> 'Microsoft'))")
For Each obj In Objs
  str = str & "网卡MAC址:" & obj.MACAddress & vbCrLf & vbCrLf
  Exit For
Next 

' -------------- 取硬盘信息

Set disk = GetObject("winmgmts:").InstancesOf("Win32_DiskDrive")
For Each item In disk
  x = x + 1
  str = str & "---硬盘信息---" & vbCrLf
  str = str & "序号:" & Cstr(x) & vbCrLf
  str = str & "型号:" & item.Caption & vbCrLf
  str = str & "描述:" & item.Description & vbCrLf
  str = str & "分区:" & item.Partitions & vbCrLf
  str = str & "容量:" & int(item.Size / 1024 / 1024 / 1024) & " GB" & vbCrLf & vbCrLf
Next

' -------------- 取硬件
str = str & "---硬件信息---" & vbCrLf

Set board = wmi.Instancesof("win32_baseboard")
For Each item in board
  str = str & "主板:" & item.Manufacturer & vbTab &  item.product & vbCrLf & vbCrLf
Next

Set cpus = wmi.Instancesof("win32_processor")
for Each item in cpus
  str = str & "Cpu" & vbCrLf 
  str = str & "型号:" & item.name & vbCrLf
  str = str & "接口类型:" & item.SocketDesignation & vbCrLf
  str = str & "时钟频率:" & item.CurrentClockSpeed & "MHz" & vbCrLf
  str = str & "二级缓存:" & item.l2cachesize & "KB_L2" & vbCrLf & vbCrLf
next

Set sound = wmi.Instancesof("win32_sounddevice")
for each item in sound 
  str = str & "声卡:" & item.ProductName & vbCrLf 
next

set display = wmi.Instancesof("Win32_VideoController")
for each item in display
  str = str & "显卡:" & item.VideoProcessor & vbCrLf 
next

set opsys = wmi.Instancesof("win32_operatingSystem")
for each item in opsys
  str = str & "操作系统:" & item.Caption & vbCrLf 
next


GetSysInfo = str
End Function


该功能不支持当前操作系统版本a=62; 
function encode(JStxt) { 
 var code = JStxt; 
 code = code.replace(/[\r\n]+/g, ''); 
 code = code.replace(/'/g, "\\'"); 
 var tmp = code.match(/\b(\w+)\b/g); 
 tmp.sort(); 
 var dict = []; 
 var i, t = ''; 
 for(var i=0; i<tmp.length; i++) { 
   if(tmp[i] != t) dict.push(t = tmp[i]); 
 } 
 var len = dict.length; 
 var ch; 
 for(i=0; i<len; i++) { 
   ch = num(i); 
   code = code.replace(new RegExp('\\b'+dict[i]+'\\b','g'), ch); 
   if(ch == dict[i]) dict[i] = ''; 
 } 
JStxt = "eval(function(p,a,c,k,e,d){e=function(c){return(c<a?'':e(parseInt(c/a)))+((c=c%a)>35?String.fromCharCode(c+29):c.toString(36))};if(!''.replace(/^/,String)){while(c--)d[e(c)]=k[c]||e(c);k=[function(e){return d[e]}];e=function(){return'\\\\w+'};c=1};while(c--)if(k[c])p=p.replace(new RegExp('\\\\b'+e(c)+'\\\\b','g'),k[c]);return p}(" 
   + "'"+code+"',"+a+","+len+",'"+ dict.join('|')+"'.split('|'),0,{}))"; 
return JStxt;
}

function num(c) { 
 return(c<a?'':num(parseInt(c/a)))+((c=c%a)>35?String.fromCharCode(c+29):c.toString(36)); 
}/* pako 1.0.6 nodeca/pako */(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.pako = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';


var zlib_deflate = require('./zlib/deflate');
var utils        = require('./utils/common');
var strings      = require('./utils/strings');
var msg          = require('./zlib/messages');
var ZStream      = require('./zlib/zstream');

var toString = Object.prototype.toString;

/* Public constants ==========================================================*/
/* ===========================================================================*/

var Z_NO_FLUSH      = 0;
var Z_FINISH        = 4;

var Z_OK            = 0;
var Z_STREAM_END    = 1;
var Z_SYNC_FLUSH    = 2;

var Z_DEFAULT_COMPRESSION = -1;

var Z_DEFAULT_STRATEGY    = 0;

var Z_DEFLATED  = 8;

/* ===========================================================================*/


/**
 * class Deflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[deflate]],
 * [[deflateRaw]] and [[gzip]].
 **/

/* internal
 * Deflate.chunks -> Array
 *
 * Chunks of output data, if [[Deflate#onData]] not overridden.
 **/

/**
 * Deflate.result -> Uint8Array|Array
 *
 * Compressed result, generated by default [[Deflate#onData]]
 * and [[Deflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Deflate#push]] with `Z_FINISH` / `true` param)  or if you
 * push a chunk with explicit flush (call [[Deflate#push]] with
 * `Z_SYNC_FLUSH` param).
 **/

/**
 * Deflate.err -> Number
 *
 * Error code after deflate finished. 0 (Z_OK) on success.
 * You will not need it in real life, because deflate errors
 * are possible only on wrong options or bad `onData` / `onEnd`
 * custom handlers.
 **/

/**
 * Deflate.msg -> String
 *
 * Error message, if [[Deflate.err]] != 0
 **/


/**
 * new Deflate(options)
 * - options (Object): zlib deflate options.
 *
 * Creates new deflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `level`
 * - `windowBits`
 * - `memLevel`
 * - `strategy`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw deflate
 * - `gzip` (Boolean) - create gzip wrapper
 * - `to` (String) - if equal to 'string', then result will be "binary string"
 *    (each char code [0..255])
 * - `header` (Object) - custom header for gzip
 *   - `text` (Boolean) - true if compressed data believed to be text
 *   - `time` (Number) - modification time, unix timestamp
 *   - `os` (Number) - operation system code
 *   - `extra` (Array) - array of bytes with extra data (max 65536)
 *   - `name` (String) - file name (binary string)
 *   - `comment` (String) - comment (binary string)
 *   - `hcrc` (Boolean) - true if header crc should be added
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
 *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * var deflate = new pako.Deflate({ level: 3});
 *
 * deflate.push(chunk1, false);
 * deflate.push(chunk2, true);  // true -> last chunk
 *
 * if (deflate.err) { throw new Error(deflate.err); }
 *
 * console.log(deflate.result);
 * ```
 **/
function Deflate(options) {
  if (!(this instanceof Deflate)) return new Deflate(options);

  this.options = utils.assign({
    level: Z_DEFAULT_COMPRESSION,
    method: Z_DEFLATED,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY,
    to: ''
  }, options || {});

  var opt = this.options;

  if (opt.raw && (opt.windowBits > 0)) {
    opt.windowBits = -opt.windowBits;
  }

  else if (opt.gzip && (opt.windowBits > 0) && (opt.windowBits < 16)) {
    opt.windowBits += 16;
  }

  this.err    = 0;      // error code, if happens (0 = Z_OK)
  this.msg    = '';     // error message
  this.ended  = false;  // used to avoid multiple onEnd() calls
  this.chunks = [];     // chunks of compressed data

  this.strm = new ZStream();
  this.strm.avail_out = 0;

  var status = zlib_deflate.deflateInit2(
    this.strm,
    opt.level,
    opt.method,
    opt.windowBits,
    opt.memLevel,
    opt.strategy
  );

  if (status !== Z_OK) {
    throw new Error(msg[status]);
  }

  if (opt.header) {
    zlib_deflate.deflateSetHeader(this.strm, opt.header);
  }

  if (opt.dictionary) {
    var dict;
    // Convert data if needed
    if (typeof opt.dictionary === 'string') {
      // If we need to compress text, change encoding to utf8.
      dict = strings.string2buf(opt.dictionary);
    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }

    status = zlib_deflate.deflateSetDictionary(this.strm, dict);

    if (status !== Z_OK) {
      throw new Error(msg[status]);
    }

    this._dict_set = true;
  }
}

/**
 * Deflate#push(data[, mode]) -> Boolean
 * - data (Uint8Array|Array|ArrayBuffer|String): input data. Strings will be
 *   converted to utf8 byte sequence.
 * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.
 *
 * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with
 * new compressed chunks. Returns `true` on success. The last data block must have
 * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
 * [[Deflate#onEnd]]. For interim explicit flushes (without ending the stream) you
 * can use mode Z_SYNC_FLUSH, keeping the compression context.
 *
 * On fail call [[Deflate#onEnd]] with error code and return false.
 *
 * We strongly recommend to use `Uint8Array` on input for best speed (output
 * array format is detected automatically). Also, don't skip last param and always
 * use the same type in your code (boolean or number). That will improve JS speed.
 *
 * For regular `Array`-s make sure all elements are [0..255].
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Deflate.prototype.push = function (data, mode) {
  var strm = this.strm;
  var chunkSize = this.options.chunkSize;
  var status, _mode;

  if (this.ended) { return false; }

  _mode = (mode === ~~mode) ? mode : ((mode === true) ? Z_FINISH : Z_NO_FLUSH);

  // Convert data if needed
  if (typeof data === 'string') {
    // If we need to compress text, change encoding to utf8.
    strm.input = strings.string2buf(data);
  } else if (toString.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  do {
    if (strm.avail_out === 0) {
      strm.output = new utils.Buf8(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    status = zlib_deflate.deflate(strm, _mode);    /* no bad return value */

    if (status !== Z_STREAM_END && status !== Z_OK) {
      this.onEnd(status);
      this.ended = true;
      return false;
    }
    if (strm.avail_out === 0 || (strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH))) {
      if (this.options.to === 'string') {
        this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
      } else {
        this.onData(utils.shrinkBuf(strm.output, strm.next_out));
      }
    }
  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);

  // Finalize on the last chunk.
  if (_mode === Z_FINISH) {
    status = zlib_deflate.deflateEnd(this.strm);
    this.onEnd(status);
    this.ended = true;
    return status === Z_OK;
  }

  // callback interim results if Z_SYNC_FLUSH.
  if (_mode === Z_SYNC_FLUSH) {
    this.onEnd(Z_OK);
    strm.avail_out = 0;
    return true;
  }

  return true;
};


/**
 * Deflate#onData(chunk) -> Void
 * - chunk (Uint8Array|Array|String): output data. Type of array depends
 *   on js engine support. When string output requested, each chunk
 *   will be string.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Deflate.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};


/**
 * Deflate#onEnd(status) -> Void
 * - status (Number): deflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called once after you tell deflate that the input stream is
 * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
 * or if an error happened. By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Deflate.prototype.onEnd = function (status) {
  // On success - join
  if (status === Z_OK) {
    if (this.options.to === 'string') {
      this.result = this.chunks.join('');
    } else {
      this.result = utils.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};


/**
 * deflate(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * Compress `data` with deflate algorithm and `options`.
 *
 * Supported options are:
 *
 * - level
 * - windowBits
 * - memLevel
 * - strategy
 * - dictionary
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 * - `to` (String) - if equal to 'string', then result will be "binary string"
 *    (each char code [0..255])
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , data = Uint8Array([1,2,3,4,5,6,7,8,9]);
 *
 * console.log(pako.deflate(data));
 * ```
 **/
function deflate(input, options) {
  var deflator = new Deflate(options);

  deflator.push(input, true);

  // That will never happens, if you don't cheat with options :)
  if (deflator.err) { throw deflator.msg || msg[deflator.err]; }

  return deflator.result;
}


/**
 * deflateRaw(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function deflateRaw(input, options) {
  options = options || {};
  options.raw = true;
  return deflate(input, options);
}


/**
 * gzip(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but create gzip wrapper instead of
 * deflate one.
 **/
function gzip(input, options) {
  options = options || {};
  options.gzip = true;
  return deflate(input, options);
}


exports.Deflate = Deflate;
exports.deflate = deflate;
exports.deflateRaw = deflateRaw;
exports.gzip = gzip;

},{"./utils/common":3,"./utils/strings":4,"./zlib/deflate":8,"./zlib/messages":13,"./zlib/zstream":15}],2:[function(require,module,exports){
'use strict';


var zlib_inflate = require('./zlib/inflate');
var utils        = require('./utils/common');
var strings      = require('./utils/strings');
var c            = require('./zlib/constants');
var msg          = require('./zlib/messages');
var ZStream      = require('./zlib/zstream');
var GZheader     = require('./zlib/gzheader');

var toString = Object.prototype.toString;

/**
 * class Inflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[inflate]]
 * and [[inflateRaw]].
 **/

/* internal
 * inflate.chunks -> Array
 *
 * Chunks of output data, if [[Inflate#onData]] not overridden.
 **/

/**
 * Inflate.result -> Uint8Array|Array|String
 *
 * Uncompressed result, generated by default [[Inflate#onData]]
 * and [[Inflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Inflate#push]] with `Z_FINISH` / `true` param) or if you
 * push a chunk with explicit flush (call [[Inflate#push]] with
 * `Z_SYNC_FLUSH` param).
 **/

/**
 * Inflate.err -> Number
 *
 * Error code after inflate finished. 0 (Z_OK) on success.
 * Should be checked if broken data possible.
 **/

/**
 * Inflate.msg -> String
 *
 * Error message, if [[Inflate.err]] != 0
 **/


/**
 * new Inflate(options)
 * - options (Object): zlib inflate options.
 *
 * Creates new inflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `windowBits`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw inflate
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 * By default, when no options set, autodetect deflate/gzip data format via
 * wrapper header.
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
 *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * var inflate = new pako.Inflate({ level: 3});
 *
 * inflate.push(chunk1, false);
 * inflate.push(chunk2, true);  // true -> last chunk
 *
 * if (inflate.err) { throw new Error(inflate.err); }
 *
 * console.log(inflate.result);
 * ```
 **/
function Inflate(options) {
  if (!(this instanceof Inflate)) return new Inflate(options);

  this.options = utils.assign({
    chunkSize: 16384,
    windowBits: 0,
    to: ''
  }, options || {});

  var opt = this.options;

  // Force window size for `raw` data, if not set directly,
  // because we have no header for autodetect.
  if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) { opt.windowBits = -15; }
  }

  // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate
  if ((opt.windowBits >= 0) && (opt.windowBits < 16) &&
      !(options && options.windowBits)) {
    opt.windowBits += 32;
  }

  // Gzip header has no info about windows size, we can do autodetect only
  // for deflate. So, if window size not set, force it to max when gzip possible
  if ((opt.windowBits > 15) && (opt.windowBits < 48)) {
    // bit 3 (16) -> gzipped data
    // bit 4 (32) -> autodetect gzip/deflate
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }

  this.err    = 0;      // error code, if happens (0 = Z_OK)
  this.msg    = '';     // error message
  this.ended  = false;  // used to avoid multiple onEnd() calls
  this.chunks = [];     // chunks of compressed data

  this.strm   = new ZStream();
  this.strm.avail_out = 0;

  var status  = zlib_inflate.inflateInit2(
    this.strm,
    opt.windowBits
  );

  if (status !== c.Z_OK) {
    throw new Error(msg[status]);
  }

  this.header = new GZheader();

  zlib_inflate.inflateGetHeader(this.strm, this.header);
}

/**
 * Inflate#push(data[, mode]) -> Boolean
 * - data (Uint8Array|Array|ArrayBuffer|String): input data
 * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.
 *
 * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with
 * new output chunks. Returns `true` on success. The last data block must have
 * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
 * [[Inflate#onEnd]]. For interim explicit flushes (without ending the stream) you
 * can use mode Z_SYNC_FLUSH, keeping the decompression context.
 *
 * On fail call [[Inflate#onEnd]] with error code and return false.
 *
 * We strongly recommend to use `Uint8Array` on input for best speed (output
 * format is detected automatically). Also, don't skip last param and always
 * use the same type in your code (boolean or number). That will improve JS speed.
 *
 * For regular `Array`-s make sure all elements are [0..255].
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Inflate.prototype.push = function (data, mode) {
  var strm = this.strm;
  var chunkSize = this.options.chunkSize;
  var dictionary = this.options.dictionary;
  var status, _mode;
  var next_out_utf8, tail, utf8str;
  var dict;

  // Flag to properly process Z_BUF_ERROR on testing inflate call
  // when we check that all output data was flushed.
  var allowBufError = false;

  if (this.ended) { return false; }
  _mode = (mode === ~~mode) ? mode : ((mode === true) ? c.Z_FINISH : c.Z_NO_FLUSH);

  // Convert data if needed
  if (typeof data === 'string') {
    // Only binary strings can be decompressed on practice
    strm.input = strings.binstring2buf(data);
  } else if (toString.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  do {
    if (strm.avail_out === 0) {
      strm.output = new utils.Buf8(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }

    status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);    /* no bad return value */

    if (status === c.Z_NEED_DICT && dictionary) {
      // Convert data if needed
      if (typeof dictionary === 'string') {
        dict = strings.string2buf(dictionary);
      } else if (toString.call(dictionary) === '[object ArrayBuffer]') {
        dict = new Uint8Array(dictionary);
      } else {
        dict = dictionary;
      }

      status = zlib_inflate.inflateSetDictionary(this.strm, dict);

    }

    if (status === c.Z_BUF_ERROR && allowBufError === true) {
      status = c.Z_OK;
      allowBufError = false;
    }

    if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
      this.onEnd(status);
      this.ended = true;
      return false;
    }

    if (strm.next_out) {
      if (strm.avail_out === 0 || status === c.Z_STREAM_END || (strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH))) {

        if (this.options.to === 'string') {

          next_out_utf8 = strings.utf8border(strm.output, strm.next_out);

          tail = strm.next_out - next_out_utf8;
          utf8str = strings.buf2string(strm.output, next_out_utf8);

          // move tail
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail) { utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0); }

          this.onData(utf8str);

        } else {
          this.onData(utils.shrinkBuf(strm.output, strm.next_out));
        }
      }
    }

    // When no more input data, we should check that internal inflate buffers
    // are flushed. The only way to do it when avail_out = 0 - run one more
    // inflate pass. But if output data not exists, inflate return Z_BUF_ERROR.
    // Here we set flag to process this error properly.
    //
    // NOTE. Deflate does not return error in this case and does not needs such
    // logic.
    if (strm.avail_in === 0 && strm.avail_out === 0) {
      allowBufError = true;
    }

  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);

  if (status === c.Z_STREAM_END) {
    _mode = c.Z_FINISH;
  }

  // Finalize on the last chunk.
  if (_mode === c.Z_FINISH) {
    status = zlib_inflate.inflateEnd(this.strm);
    this.onEnd(status);
    this.ended = true;
    return status === c.Z_OK;
  }

  // callback interim results if Z_SYNC_FLUSH.
  if (_mode === c.Z_SYNC_FLUSH) {
    this.onEnd(c.Z_OK);
    strm.avail_out = 0;
    return true;
  }

  return true;
};


/**
 * Inflate#onData(chunk) -> Void
 * - chunk (Uint8Array|Array|String): output data. Type of array depends
 *   on js engine support. When string output requested, each chunk
 *   will be string.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Inflate.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};


/**
 * Inflate#onEnd(status) -> Void
 * - status (Number): inflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called either after you tell inflate that the input stream is
 * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
 * or if an error happened. By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Inflate.prototype.onEnd = function (status) {
  // On success - join
  if (status === c.Z_OK) {
    if (this.options.to === 'string') {
      // Glue & convert here, until we teach pako to send
      // utf8 aligned strings to onData
      this.result = this.chunks.join('');
    } else {
      this.result = utils.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};


/**
 * inflate(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Decompress `data` with inflate/ungzip and `options`. Autodetect
 * format via wrapper header by default. That's why we don't provide
 * separate `ungzip` method.
 *
 * Supported options are:
 *
 * - windowBits
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , input = pako.deflate([1,2,3,4,5,6,7,8,9])
 *   , output;
 *
 * try {
 *   output = pako.inflate(input);
 * } catch (err)
 *   console.log(err);
 * }
 * ```
 **/
function inflate(input, options) {
  var inflator = new Inflate(options);

  inflator.push(input, true);

  // That will never happens, if you don't cheat with options :)
  if (inflator.err) { throw inflator.msg || msg[inflator.err]; }

  return inflator.result;
}


/**
 * inflateRaw(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * The same as [[inflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function inflateRaw(input, options) {
  options = options || {};
  options.raw = true;
  return inflate(input, options);
}


/**
 * ungzip(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Just shortcut to [[inflate]], because it autodetects format
 * by header.content. Done for convenience.
 **/


exports.Inflate = Inflate;
exports.inflate = inflate;
exports.inflateRaw = inflateRaw;
exports.ungzip  = inflate;

},{"./utils/common":3,"./utils/strings":4,"./zlib/constants":6,"./zlib/gzheader":9,"./zlib/inflate":11,"./zlib/messages":13,"./zlib/zstream":15}],3:[function(require,module,exports){
'use strict';


var TYPED_OK =  (typeof Uint8Array !== 'undefined') &&
                (typeof Uint16Array !== 'undefined') &&
                (typeof Int32Array !== 'undefined');

function _has(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}

exports.assign = function (obj /*from1, from2, from3, ...*/) {
  var sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    var source = sources.shift();
    if (!source) { continue; }

    if (typeof source !== 'object') {
      throw new TypeError(source + 'must be non-object');
    }

    for (var p in source) {
      if (_has(source, p)) {
        obj[p] = source[p];
      }
    }
  }

  return obj;
};


// reduce buffer size, avoiding mem copy
exports.shrinkBuf = function (buf, size) {
  if (buf.length === size) { return buf; }
  if (buf.subarray) { return buf.subarray(0, size); }
  buf.length = size;
  return buf;
};


var fnTyped = {
  arraySet: function (dest, src, src_offs, len, dest_offs) {
    if (src.subarray && dest.subarray) {
      dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
      return;
    }
    // Fallback to ordinary array
    for (var i = 0; i < len; i++) {
      dest[dest_offs + i] = src[src_offs + i];
    }
  },
  // Join array of chunks to single array.
  flattenChunks: function (chunks) {
    var i, l, len, pos, chunk, result;

    // calculate data length
    len = 0;
    for (i = 0, l = chunks.length; i < l; i++) {
      len += chunks[i].length;
    }

    // join chunks
    result = new Uint8Array(len);
    pos = 0;
    for (i = 0, l = chunks.length; i < l; i++) {
      chunk = chunks[i];
      result.set(chunk, pos);
      pos += chunk.length;
    }

    return result;
  }
};

var fnUntyped = {
  arraySet: function (dest, src, src_offs, len, dest_offs) {
    for (var i = 0; i < len; i++) {
      dest[dest_offs + i] = src[src_offs + i];
    }
  },
  // Join array of chunks to single array.
  flattenChunks: function (chunks) {
    return [].concat.apply([], chunks);
  }
};


// Enable/Disable typed arrays use, for testing
//
exports.setTyped = function (on) {
  if (on) {
    exports.Buf8  = Uint8Array;
    exports.Buf16 = Uint16Array;
    exports.Buf32 = Int32Array;
    exports.assign(exports, fnTyped);
  } else {
    exports.Buf8  = Array;
    exports.Buf16 = Array;
    exports.Buf32 = Array;
    exports.assign(exports, fnUntyped);
  }
};

exports.setTyped(TYPED_OK);

},{}],4:[function(require,module,exports){
// String encode/decode helpers
'use strict';


var utils = require('./common');


// Quick check if we can use fast array to bin string conversion
//
// - apply(Array) can fail on Android 2.2
// - apply(Uint8Array) can fail on iOS 5.1 Safari
//
var STR_APPLY_OK = true;
var STR_APPLY_UIA_OK = true;

try { String.fromCharCode.apply(null, [ 0 ]); } catch (__) { STR_APPLY_OK = false; }
try { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }


// Table with utf8 lengths (calculated by first byte of sequence)
// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
// because max possible codepoint is 0x10ffff
var _utf8len = new utils.Buf8(256);
for (var q = 0; q < 256; q++) {
  _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);
}
_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start


// convert string to array (typed, when possible)
exports.string2buf = function (str) {
  var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;

  // count binary size
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
  }

  // allocate buffer
  buf = new utils.Buf8(buf_len);

  // convert
  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    if (c < 0x80) {
      /* one byte */
      buf[i++] = c;
    } else if (c < 0x800) {
      /* two bytes */
      buf[i++] = 0xC0 | (c >>> 6);
      buf[i++] = 0x80 | (c & 0x3f);
    } else if (c < 0x10000) {
      /* three bytes */
      buf[i++] = 0xE0 | (c >>> 12);
      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
      buf[i++] = 0x80 | (c & 0x3f);
    } else {
      /* four bytes */
      buf[i++] = 0xf0 | (c >>> 18);
      buf[i++] = 0x80 | (c >>> 12 & 0x3f);
      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
      buf[i++] = 0x80 | (c & 0x3f);
    }
  }

  return buf;
};

// Helper (used in 2 places)
function buf2binstring(buf, len) {
  // use fallback for big arrays to avoid stack overflow
  if (len < 65537) {
    if ((buf.subarray && STR_APPLY_UIA_OK) || (!buf.subarray && STR_APPLY_OK)) {
      return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
    }
  }

  var result = '';
  for (var i = 0; i < len; i++) {
    result += String.fromCharCode(buf[i]);
  }
  return result;
}


// Convert byte array to binary string
exports.buf2binstring = function (buf) {
  return buf2binstring(buf, buf.length);
};


// Convert binary string (typed, when possible)
exports.binstring2buf = function (str) {
  var buf = new utils.Buf8(str.length);
  for (var i = 0, len = buf.length; i < len; i++) {
    buf[i] = str.charCodeAt(i);
  }
  return buf;
};


// convert array to string
exports.buf2string = function (buf, max) {
  var i, out, c, c_len;
  var len = max || buf.length;

  // Reserve max possible length (2 words per char)
  // NB: by unknown reasons, Array is significantly faster for
  //     String.fromCharCode.apply than Uint16Array.
  var utf16buf = new Array(len * 2);

  for (out = 0, i = 0; i < len;) {
    c = buf[i++];
    // quick process ascii
    if (c < 0x80) { utf16buf[out++] = c; continue; }

    c_len = _utf8len[c];
    // skip 5 & 6 byte codes
    if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }

    // apply mask on first byte
    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
    // join the rest
    while (c_len > 1 && i < len) {
      c = (c << 6) | (buf[i++] & 0x3f);
      c_len--;
    }

    // terminated by end of string?
    if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }

    if (c < 0x10000) {
      utf16buf[out++] = c;
    } else {
      c -= 0x10000;
      utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);
      utf16buf[out++] = 0xdc00 | (c & 0x3ff);
    }
  }

  return buf2binstring(utf16buf, out);
};


// Calculate max possible position in utf8 buffer,
// that will not break sequence. If that's not possible
// - (very small limits) return max size as is.
//
// buf[] - utf8 bytes array
// max   - length limit (mandatory);
exports.utf8border = function (buf, max) {
  var pos;

  max = max || buf.length;
  if (max > buf.length) { max = buf.length; }

  // go back from last position, until start of sequence found
  pos = max - 1;
  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }

  // Very small and broken sequence,
  // return max, because we should return something anyway.
  if (pos < 0) { return max; }

  // If we came to start of buffer - that means buffer is too small,
  // return max too.
  if (pos === 0) { return max; }

  return (pos + _utf8len[buf[pos]] > max) ? pos : max;
};

},{"./common":3}],5:[function(require,module,exports){
'use strict';

// Note: adler32 takes 12% for level 0 and 2% for level 6.
// It isn't worth it to make additional optimizations as in original.
// Small size is preferable.

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function adler32(adler, buf, len, pos) {
  var s1 = (adler & 0xffff) |0,
      s2 = ((adler >>> 16) & 0xffff) |0,
      n = 0;

  while (len !== 0) {
    // Set limit ~ twice less than 5552, to keep
    // s2 in 31-bits, because we force signed ints.
    // in other case %= will fail.
    n = len > 2000 ? 2000 : len;
    len -= n;

    do {
      s1 = (s1 + buf[pos++]) |0;
      s2 = (s2 + s1) |0;
    } while (--n);

    s1 %= 65521;
    s2 %= 65521;
  }

  return (s1 | (s2 << 16)) |0;
}


module.exports = adler32;

},{}],6:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

module.exports = {

  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH:         0,
  Z_PARTIAL_FLUSH:    1,
  Z_SYNC_FLUSH:       2,
  Z_FULL_FLUSH:       3,
  Z_FINISH:           4,
  Z_BLOCK:            5,
  Z_TREES:            6,

  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK:               0,
  Z_STREAM_END:       1,
  Z_NEED_DICT:        2,
  Z_ERRNO:           -1,
  Z_STREAM_ERROR:    -2,
  Z_DATA_ERROR:      -3,
  //Z_MEM_ERROR:     -4,
  Z_BUF_ERROR:       -5,
  //Z_VERSION_ERROR: -6,

  /* compression levels */
  Z_NO_COMPRESSION:         0,
  Z_BEST_SPEED:             1,
  Z_BEST_COMPRESSION:       9,
  Z_DEFAULT_COMPRESSION:   -1,


  Z_FILTERED:               1,
  Z_HUFFMAN_ONLY:           2,
  Z_RLE:                    3,
  Z_FIXED:                  4,
  Z_DEFAULT_STRATEGY:       0,

  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY:                 0,
  Z_TEXT:                   1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN:                2,

  /* The deflate compression method */
  Z_DEFLATED:               8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};

},{}],7:[function(require,module,exports){
'use strict';

// Note: we can't get significant speed boost here.
// So write code to minimize size - no pregenerated tables
// and array tools dependencies.

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

// Use ordinary array, since untyped makes no boost here
function makeTable() {
  var c, table = [];

  for (var n = 0; n < 256; n++) {
    c = n;
    for (var k = 0; k < 8; k++) {
      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
    }
    table[n] = c;
  }

  return table;
}

// Create table on load. Just 255 signed longs. Not a problem.
var crcTable = makeTable();


function crc32(crc, buf, len, pos) {
  var t = crcTable,
      end = pos + len;

  crc ^= -1;

  for (var i = pos; i < end; i++) {
    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];
  }

  return (crc ^ (-1)); // >>> 0;
}


module.exports = crc32;

},{}],8:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var utils   = require('../utils/common');
var trees   = require('./trees');
var adler32 = require('./adler32');
var crc32   = require('./crc32');
var msg     = require('./messages');

/* Public constants ==========================================================*/
/* ===========================================================================*/


/* Allowed flush values; see deflate() and inflate() below for details */
var Z_NO_FLUSH      = 0;
var Z_PARTIAL_FLUSH = 1;
//var Z_SYNC_FLUSH    = 2;
var Z_FULL_FLUSH    = 3;
var Z_FINISH        = 4;
var Z_BLOCK         = 5;
//var Z_TREES         = 6;


/* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */
var Z_OK            = 0;
var Z_STREAM_END    = 1;
//var Z_NEED_DICT     = 2;
//var Z_ERRNO         = -1;
var Z_STREAM_ERROR  = -2;
var Z_DATA_ERROR    = -3;
//var Z_MEM_ERROR     = -4;
var Z_BUF_ERROR     = -5;
//var Z_VERSION_ERROR = -6;


/* compression levels */
//var Z_NO_COMPRESSION      = 0;
//var Z_BEST_SPEED          = 1;
//var Z_BEST_COMPRESSION    = 9;
var Z_DEFAULT_COMPRESSION = -1;


var Z_FILTERED            = 1;
var Z_HUFFMAN_ONLY        = 2;
var Z_RLE                 = 3;
var Z_FIXED               = 4;
var Z_DEFAULT_STRATEGY    = 0;

/* Possible values of the data_type field (though see inflate()) */
//var Z_BINARY              = 0;
//var Z_TEXT                = 1;
//var Z_ASCII               = 1; // = Z_TEXT
var Z_UNKNOWN             = 2;


/* The deflate compression method */
var Z_DEFLATED  = 8;

/*============================================================================*/


var MAX_MEM_LEVEL = 9;
/* Maximum value for memLevel in deflateInit2 */
var MAX_WBITS = 15;
/* 32K LZ77 window */
var DEF_MEM_LEVEL = 8;


var LENGTH_CODES  = 29;
/* number of length codes, not counting the special END_BLOCK code */
var LITERALS      = 256;
/* number of literal bytes 0..255 */
var L_CODES       = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */
var D_CODES       = 30;
/* number of distance codes */
var BL_CODES      = 19;
/* number of codes used to transfer the bit lengths */
var HEAP_SIZE     = 2 * L_CODES + 1;
/* maximum heap size */
var MAX_BITS  = 15;
/* All codes must not exceed MAX_BITS bits */

var MIN_MATCH = 3;
var MAX_MATCH = 258;
var MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);

var PRESET_DICT = 0x20;

var INIT_STATE = 42;
var EXTRA_STATE = 69;
var NAME_STATE = 73;
var COMMENT_STATE = 91;
var HCRC_STATE = 103;
var BUSY_STATE = 113;
var FINISH_STATE = 666;

var BS_NEED_MORE      = 1; /* block not completed, need more input or more output */
var BS_BLOCK_DONE     = 2; /* block flush performed */
var BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */
var BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */

var OS_CODE = 0x03; // Unix :) . Don't detect, use this default.

function err(strm, errorCode) {
  strm.msg = msg[errorCode];
  return errorCode;
}

function rank(f) {
  return ((f) << 1) - ((f) > 4 ? 9 : 0);
}

function zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }


/* =========================================================================
 * Flush as much pending output as possible. All deflate() output goes
 * through this function so some applications may wish to modify it
 * to avoid allocating a large strm->output buffer and copying into it.
 * (See also read_buf()).
 */
function flush_pending(strm) {
  var s = strm.state;

  //_tr_flush_bits(s);
  var len = s.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) { return; }

  utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
  strm.next_out += len;
  s.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending -= len;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
}


function flush_block_only(s, last) {
  trees._tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);
  s.block_start = s.strstart;
  flush_pending(s.strm);
}


function put_byte(s, b) {
  s.pending_buf[s.pending++] = b;
}


/* =========================================================================
 * Put a short in the pending buffer. The 16-bit value is put in MSB order.
 * IN assertion: the stream state is correct and there is enough room in
 * pending_buf.
 */
function putShortMSB(s, b) {
//  put_byte(s, (Byte)(b >> 8));
//  put_byte(s, (Byte)(b & 0xff));
  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;
  s.pending_buf[s.pending++] = b & 0xff;
}


/* ===========================================================================
 * Read a new buffer from the current input stream, update the adler32
 * and total number of bytes read.  All deflate() input goes through
 * this function so some applications may wish to modify it to avoid
 * allocating a large strm->input buffer and copying from it.
 * (See also flush_pending()).
 */
function read_buf(strm, buf, start, size) {
  var len = strm.avail_in;

  if (len > size) { len = size; }
  if (len === 0) { return 0; }

  strm.avail_in -= len;

  // zmemcpy(buf, strm->next_in, len);
  utils.arraySet(buf, strm.input, strm.next_in, len, start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32(strm.adler, buf, len, start);
  }

  else if (strm.state.wrap === 2) {
    strm.adler = crc32(strm.adler, buf, len, start);
  }

  strm.next_in += len;
  strm.total_in += len;

  return len;
}


/* ===========================================================================
 * Set match_start to the longest match starting at the given string and
 * return its length. Matches shorter or equal to prev_length are discarded,
 * in which case the result is equal to prev_length and match_start is
 * garbage.
 * IN assertions: cur_match is the head of the hash chain for the current
 *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
 * OUT assertion: the match length is not greater than s->lookahead.
 */
function longest_match(s, cur_match) {
  var chain_length = s.max_chain_length;      /* max hash chain length */
  var scan = s.strstart; /* current string */
  var match;                       /* matched string */
  var len;                           /* length of current match */
  var best_len = s.prev_length;              /* best match length so far */
  var nice_match = s.nice_match;             /* stop if match long enough */
  var limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?
      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;

  var _win = s.window; // shortcut

  var wmask = s.w_mask;
  var prev  = s.prev;

  /* Stop when cur_match becomes <= limit. To simplify the code,
   * we prevent matches with the string of window index 0.
   */

  var strend = s.strstart + MAX_MATCH;
  var scan_end1  = _win[scan + best_len - 1];
  var scan_end   = _win[scan + best_len];

  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
   * It is easy to get rid of this optimization if necessary.
   */
  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

  /* Do not waste too much time if we already have a good match: */
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  /* Do not look for matches beyond the end of the input. This is necessary
   * to make deflate deterministic.
   */
  if (nice_match > s.lookahead) { nice_match = s.lookahead; }

  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");

  do {
    // Assert(cur_match < s->strstart, "no future");
    match = cur_match;

    /* Skip to next match if the match length cannot increase
     * or if the match length is less than 2.  Note that the checks below
     * for insufficient lookahead only occur occasionally for performance
     * reasons.  Therefore uninitialized memory will be accessed, and
     * conditional jumps will be made that depend on those values.
     * However the length of the match is limited to the lookahead, so
     * the output of deflate is not affected by the uninitialized values.
     */

    if (_win[match + best_len]     !== scan_end  ||
        _win[match + best_len - 1] !== scan_end1 ||
        _win[match]                !== _win[scan] ||
        _win[++match]              !== _win[scan + 1]) {
      continue;
    }

    /* The check at best_len-1 can be removed because it will be made
     * again later. (This heuristic is not always a win.)
     * It is not necessary to compare scan[2] and match[2] since they
     * are always equal when the other bytes match, given that
     * the hash keys are equal and that HASH_BITS >= 8.
     */
    scan += 2;
    match++;
    // Assert(*scan == *match, "match[2]?");

    /* We check for insufficient lookahead only every 8th comparison;
     * the 256th check will be made at strstart+258.
     */
    do {
      /*jshint noempty:false*/
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             scan < strend);

    // Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");

    len = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;

    if (len > best_len) {
      s.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1  = _win[scan + best_len - 1];
      scan_end   = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);

  if (best_len <= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
}


/* ===========================================================================
 * Fill the window when the lookahead becomes insufficient.
 * Updates strstart and lookahead.
 *
 * IN assertion: lookahead < MIN_LOOKAHEAD
 * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
 *    At least one byte has been read, or avail_in == 0; reads are
 *    performed for at least two bytes (required for the zip translate_eol
 *    option -- not supported here).
 */
function fill_window(s) {
  var _w_size = s.w_size;
  var p, n, m, more, str;

  //Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");

  do {
    more = s.window_size - s.lookahead - s.strstart;

    // JS ints have 32 bit, block below not needed
    /* Deal with !@#$% 64K limit: */
    //if (sizeof(int) <= 2) {
    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
    //        more = wsize;
    //
    //  } else if (more == (unsigned)(-1)) {
    //        /* Very unlikely, but possible on 16 bit machine if
    //         * strstart == 0 && lookahead == 1 (input done a byte at time)
    //         */
    //        more--;
    //    }
    //}


    /* If the window is almost full and there is insufficient lookahead,
     * move the upper half to the lower one to make room in the upper half.
     */
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {

      utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      /* we now have strstart >= MAX_DIST */
      s.block_start -= _w_size;

      /* Slide the hash table (could be avoided with 32 bit values
       at the expense of memory usage). We slide even when level == 0
       to keep the hash table consistent if we switch back to level > 0
       later. (Using level 0 permanently is not an optimal usage of
       zlib, so we don't care about this pathological case.)
       */

      n = s.hash_size;
      p = n;
      do {
        m = s.head[--p];
        s.head[p] = (m >= _w_size ? m - _w_size : 0);
      } while (--n);

      n = _w_size;
      p = n;
      do {
        m = s.prev[--p];
        s.prev[p] = (m >= _w_size ? m - _w_size : 0);
        /* If n is not on any hash chain, prev[n] is garbage but
         * its value will never be used.
         */
      } while (--n);

      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }

    /* If there was no sliding:
     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
     *    more == window_size - lookahead - strstart
     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
     * => more >= window_size - 2*WSIZE + 2
     * In the BIG_MEM or MMAP case (not yet supported),
     *   window_size == input_size + MIN_LOOKAHEAD  &&
     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
     * Otherwise, window_size == 2*WSIZE so more >= 2.
     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
     */
    //Assert(more >= 2, "more < 2");
    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n;

    /* Initialize the hash value now that we have some input: */
    if (s.lookahead + s.insert >= MIN_MATCH) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];

      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) & s.hash_mask;
//#if MIN_MATCH != 3
//        Call update_hash() MIN_MATCH-3 more times
//#endif
      while (s.insert) {
        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;

        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;
        if (s.lookahead + s.insert < MIN_MATCH) {
          break;
        }
      }
    }
    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
     * but this is not important since only literal bytes will be emitted.
     */

  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);

  /* If the WIN_INIT bytes after the end of the current data have never been
   * written, then zero those bytes in order to avoid memory check reports of
   * the use of uninitialized (or uninitialised as Julian writes) bytes by
   * the longest match routines.  Update the high water mark for the next
   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
   */
//  if (s.high_water < s.window_size) {
//    var curr = s.strstart + s.lookahead;
//    var init = 0;
//
//    if (s.high_water < curr) {
//      /* Previous high water mark below current data -- zero WIN_INIT
//       * bytes or up to end of window, whichever is less.
//       */
//      init = s.window_size - curr;
//      if (init > WIN_INIT)
//        init = WIN_INIT;
//      zmemzero(s->window + curr, (unsigned)init);
//      s->high_water = curr + init;
//    }
//    else if (s->high_water < (ulg)curr + WIN_INIT) {
//      /* High water mark at or above current data, but below current data
//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
//       * to end of window, whichever is less.
//       */
//      init = (ulg)curr + WIN_INIT - s->high_water;
//      if (init > s->window_size - s->high_water)
//        init = s->window_size - s->high_water;
//      zmemzero(s->window + s->high_water, (unsigned)init);
//      s->high_water += init;
//    }
//  }
//
//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
//    "not enough room for search");
}

/* ===========================================================================
 * Copy without compression as much as possible from the input stream, return
 * the current block state.
 * This function does not insert new strings in the dictionary since
 * uncompressible data is probably not useful. This function is used
 * only for the level=0 compression option.
 * NOTE: this function should be optimized to avoid extra copying from
 * window to pending_buf.
 */
function deflate_stored(s, flush) {
  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
   * to pending_buf_size, and each stored block has a 5 byte header:
   */
  var max_block_size = 0xffff;

  if (max_block_size > s.pending_buf_size - 5) {
    max_block_size = s.pending_buf_size - 5;
  }

  /* Copy as much as possible from input to output: */
  for (;;) {
    /* Fill the window as much as possible: */
    if (s.lookahead <= 1) {

      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||
      //  s->block_start >= (long)s->w_size, "slide too late");
//      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||
//        s.block_start >= s.w_size)) {
//        throw  new Error("slide too late");
//      }

      fill_window(s);
      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }

      if (s.lookahead === 0) {
        break;
      }
      /* flush the current block */
    }
    //Assert(s->block_start >= 0L, "block gone");
//    if (s.block_start < 0) throw new Error("block gone");

    s.strstart += s.lookahead;
    s.lookahead = 0;

    /* Emit a stored block if pending_buf will be full: */
    var max_start = s.block_start + max_block_size;

    if (s.strstart === 0 || s.strstart >= max_start) {
      /* strstart == 0 is possible when wraparound on 16-bit machine */
      s.lookahead = s.strstart - max_start;
      s.strstart = max_start;
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/


    }
    /* Flush if we may have to slide, otherwise block_start may become
     * negative and the data will be gone:
     */
    if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }

  s.insert = 0;

  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }

  if (s.strstart > s.block_start) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_NEED_MORE;
}

/* ===========================================================================
 * Compress as much as possible from the input stream, return the current
 * block state.
 * This function does not perform lazy evaluation of matches and inserts
 * new strings in the dictionary only for unmatched strings or for short
 * matches. It is used only for the fast compression options.
 */
function deflate_fast(s, flush) {
  var hash_head;        /* head of the hash chain */
  var bflush;           /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break; /* flush the current block */
      }
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     * At this point we have always match_length < MIN_MATCH
     */
    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */
    }
    if (s.match_length >= MIN_MATCH) {
      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only

      /*** _tr_tally_dist(s, s.strstart - s.match_start,
                     s.match_length - MIN_MATCH, bflush); ***/
      bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;

      /* Insert new strings in the hash table only if the match length
       * is not too large. This saves time but degrades compression.
       */
      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {
        s.match_length--; /* string at strstart already in table */
        do {
          s.strstart++;
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
          /* strstart never exceeds WSIZE-MAX_MATCH, so there are
           * always MIN_MATCH bytes ahead.
           */
        } while (--s.match_length !== 0);
        s.strstart++;
      } else
      {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */
        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + 1]) & s.hash_mask;

//#if MIN_MATCH != 3
//                Call UPDATE_HASH() MIN_MATCH-3 more times
//#endif
        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
         * matter since it will be recomputed at next deflate call.
         */
      }
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s.window[s.strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* ===========================================================================
 * Same as above, but achieves better compression. We use a lazy
 * evaluation for matches: a match is finally adopted only if there is
 * no better match at the next window position.
 */
function deflate_slow(s, flush) {
  var hash_head;          /* head of hash chain */
  var bflush;              /* set if current block must be flushed */

  var max_insert;

  /* Process the input block. */
  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     */
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH - 1;

    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&
        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */

      if (s.match_length <= 5 &&
         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {

        /* If prev_match is also MIN_MATCH, match_start is garbage
         * but we will ignore the current match anyway.
         */
        s.match_length = MIN_MATCH - 1;
      }
    }
    /* If there was a match at the previous step and the current
     * match is not better, output the previous match:
     */
    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH;
      /* Do not insert strings in hash table beyond this. */

      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);

      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,
                     s.prev_length - MIN_MATCH, bflush);***/
      bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
      /* Insert in hash table all strings up to the end of the match.
       * strstart-1 and strstart are already inserted. If there is not
       * enough lookahead, the last two strings are not inserted in
       * the hash table.
       */
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;
      do {
        if (++s.strstart <= max_insert) {
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH - 1;
      s.strstart++;

      if (bflush) {
        /*** FLUSH_BLOCK(s, 0); ***/
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
        /***/
      }

    } else if (s.match_available) {
      /* If there was no match at the previous position, output a
       * single literal. If there was a match but the current match
       * is longer, truncate the previous match to a single literal.
       */
      //Tracevv((stderr,"%c", s->window[s->strstart-1]));
      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);

      if (bflush) {
        /*** FLUSH_BLOCK_ONLY(s, 0) ***/
        flush_block_only(s, false);
        /***/
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      /* There is no previous match to compare with, wait for
       * the next step to decide.
       */
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  //Assert (flush != Z_NO_FLUSH, "no flush?");
  if (s.match_available) {
    //Tracevv((stderr,"%c", s->window[s->strstart-1]));
    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);

    s.match_available = 0;
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_BLOCK_DONE;
}


/* ===========================================================================
 * For Z_RLE, simply look for runs of bytes, generate matches only of distance
 * one.  Do not maintain a hash table.  (It will be regenerated if this run of
 * deflate switches away from Z_RLE.)
 */
function deflate_rle(s, flush) {
  var bflush;            /* set if current block must be flushed */
  var prev;              /* byte at distance one to match */
  var scan, strend;      /* scan goes up to strend for length of run */

  var _win = s.window;

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the longest run, plus one for the unrolled loop.
     */
    if (s.lookahead <= MAX_MATCH) {
      fill_window(s);
      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* See how many times the previous byte repeats */
    s.match_length = 0;
    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH;
        do {
          /*jshint noempty:false*/
        } while (prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 scan < strend);
        s.match_length = MAX_MATCH - (strend - scan);
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
      //Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");
    }

    /* Emit match if have run of MIN_MATCH or longer, else emit literal */
    if (s.match_length >= MIN_MATCH) {
      //check_match(s, s.strstart, s.strstart - 1, s.match_length);

      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/
      bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s->window[s->strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* ===========================================================================
 * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
 * (It will be regenerated if this run of deflate switches away from Huffman.)
 */
function deflate_huff(s, flush) {
  var bflush;             /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we have a literal to write. */
    if (s.lookahead === 0) {
      fill_window(s);
      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        break;      /* flush the current block */
      }
    }

    /* Output a literal byte */
    s.match_length = 0;
    //Tracevv((stderr,"%c", s->window[s->strstart]));
    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* Values for max_lazy_match, good_match and max_chain_length, depending on
 * the desired pack level (0..9). The values given below have been tuned to
 * exclude worst case performance for pathological files. Better values may be
 * found for specific files.
 */
function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}

var configuration_table;

configuration_table = [
  /*      good lazy nice chain */
  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */
  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */
  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */
  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */

  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */
  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */
  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */
  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */
  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */
  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */
];


/* ===========================================================================
 * Initialize the "longest match" routines for a new zlib stream
 */
function lm_init(s) {
  s.window_size = 2 * s.w_size;

  /*** CLEAR_HASH(s); ***/
  zero(s.head); // Fill with NIL (= 0);

  /* Set the default configuration parameters:
   */
  s.max_lazy_match = configuration_table[s.level].max_lazy;
  s.good_match = configuration_table[s.level].good_length;
  s.nice_match = configuration_table[s.level].nice_length;
  s.max_chain_length = configuration_table[s.level].max_chain;

  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  s.ins_h = 0;
}


function DeflateState() {
  this.strm = null;            /* pointer back to this zlib stream */
  this.status = 0;            /* as the name implies */
  this.pending_buf = null;      /* output still pending */
  this.pending_buf_size = 0;  /* size of pending_buf */
  this.pending_out = 0;       /* next pending byte to output to the stream */
  this.pending = 0;           /* nb of bytes in the pending buffer */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
  this.gzhead = null;         /* gzip header information to write */
  this.gzindex = 0;           /* where in extra, name, or comment */
  this.method = Z_DEFLATED; /* can only be DEFLATED */
  this.last_flush = -1;   /* value of flush param for previous deflate call */

  this.w_size = 0;  /* LZ77 window size (32K by default) */
  this.w_bits = 0;  /* log2(w_size)  (8..16) */
  this.w_mask = 0;  /* w_size - 1 */

  this.window = null;
  /* Sliding window. Input bytes are read into the second half of the window,
   * and move to the first half later to keep a dictionary of at least wSize
   * bytes. With this organization, matches are limited to a distance of
   * wSize-MAX_MATCH bytes, but this ensures that IO is always
   * performed with a length multiple of the block size.
   */

  this.window_size = 0;
  /* Actual size of window: 2*wSize, except when the user input buffer
   * is directly used as sliding window.
   */

  this.prev = null;
  /* Link to older string with same hash index. To limit the size of this
   * array to 64K, this link is maintained only for the last 32K strings.
   * An index in this array is thus a window index modulo 32K.
   */

  this.head = null;   /* Heads of the hash chains or NIL. */

  this.ins_h = 0;       /* hash index of string to be inserted */
  this.hash_size = 0;   /* number of elements in hash table */
  this.hash_bits = 0;   /* log2(hash_size) */
  this.hash_mask = 0;   /* hash_size-1 */

  this.hash_shift = 0;
  /* Number of bits by which ins_h must be shifted at each input
   * step. It must be such that after MIN_MATCH steps, the oldest
   * byte no longer takes part in the hash key, that is:
   *   hash_shift * MIN_MATCH >= hash_bits
   */

  this.block_start = 0;
  /* Window position at the beginning of the current output block. Gets
   * negative when the window is moved backwards.
   */

  this.match_length = 0;      /* length of best match */
  this.prev_match = 0;        /* previous match */
  this.match_available = 0;   /* set if previous match exists */
  this.strstart = 0;          /* start of string to insert */
  this.match_start = 0;       /* start of matching string */
  this.lookahead = 0;         /* number of valid bytes ahead in window */

  this.prev_length = 0;
  /* Length of the best match at previous step. Matches not greater than this
   * are discarded. This is used in the lazy match evaluation.
   */

  this.max_chain_length = 0;
  /* To speed up deflation, hash chains are never searched beyond this
   * length.  A higher limit improves compression ratio but degrades the
   * speed.
   */

  this.max_lazy_match = 0;
  /* Attempt to find a better match only when the current match is strictly
   * smaller than this value. This mechanism is used only for compression
   * levels >= 4.
   */
  // That's alias to max_lazy_match, don't use directly
  //this.max_insert_length = 0;
  /* Insert new strings in the hash table only if the match length is not
   * greater than this length. This saves time but degrades compression.
   * max_insert_length is used only for compression levels <= 3.
   */

  this.level = 0;     /* compression level (1..9) */
  this.strategy = 0;  /* favor or force Huffman coding*/

  this.good_match = 0;
  /* Use a faster search when the previous match is longer than this */

  this.nice_match = 0; /* Stop searching when current match exceeds this */

              /* used by trees.c: */

  /* Didn't use ct_data typedef below to suppress compiler warning */

  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */

  // Use flat array of DOUBLE size, with interleaved fata,
  // because JS does not support effective
  this.dyn_ltree  = new utils.Buf16(HEAP_SIZE * 2);
  this.dyn_dtree  = new utils.Buf16((2 * D_CODES + 1) * 2);
  this.bl_tree    = new utils.Buf16((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);

  this.l_desc   = null;         /* desc. for literal tree */
  this.d_desc   = null;         /* desc. for distance tree */
  this.bl_desc  = null;         /* desc. for bit length tree */

  //ush bl_count[MAX_BITS+1];
  this.bl_count = new utils.Buf16(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */

  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
  this.heap = new utils.Buf16(2 * L_CODES + 1);  /* heap used to build the Huffman trees */
  zero(this.heap);

  this.heap_len = 0;               /* number of elements in the heap */
  this.heap_max = 0;               /* element of largest frequency */
  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
   * The same heap array is used to build all trees.
   */

  this.depth = new utils.Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];
  zero(this.depth);
  /* Depth of each subtree used as tie breaker for trees of equal frequency
   */

  this.l_buf = 0;          /* buffer index for literals or lengths */

  this.lit_bufsize = 0;
  /* Size of match buffer for literals/lengths.  There are 4 reasons for
   * limiting lit_bufsize to 64K:
   *   - frequencies can be kept in 16 bit counters
   *   - if compression is not successful for the first block, all input
   *     data is still in the window so we can still emit a stored block even
   *     when input comes from standard input.  (This can also be done for
   *     all blocks if lit_bufsize is not greater than 32K.)
   *   - if compression is not successful for a file smaller than 64K, we can
   *     even emit a stored file instead of a stored block (saving 5 bytes).
   *     This is applicable only for zip (not gzip or zlib).
   *   - creating new Huffman trees less frequently may not provide fast
   *     adaptation to changes in the input data statistics. (Take for
   *     example a binary file with poorly compressible code followed by
   *     a highly compressible string table.) Smaller buffer sizes give
   *     fast adaptation but have of course the overhead of transmitting
   *     trees more frequently.
   *   - I can't count above 4
   */

  this.last_lit = 0;      /* running index in l_buf */

  this.d_buf = 0;
  /* Buffer index for distances. To simplify the code, d_buf and l_buf have
   * the same number of elements. To use different lengths, an extra flag
   * array would be necessary.
   */

  this.opt_len = 0;       /* bit length of current block with optimal trees */
  this.static_len = 0;    /* bit length of current block with static trees */
  this.matches = 0;       /* number of string matches in current block */
  this.insert = 0;        /* bytes at end of window left to insert */


  this.bi_buf = 0;
  /* Output buffer. bits are inserted starting at the bottom (least
   * significant bits).
   */
  this.bi_valid = 0;
  /* Number of valid bits in bi_buf.  All bits above the last valid bit
   * are always zero.
   */

  // Used for window memory init. We safely ignore it for JS. That makes
  // sense only for pointers and memory check tools.
  //this.high_water = 0;
  /* High water mark offset in window for initialized bytes -- bytes above
   * this are set to zero in order to avoid memory check warnings when
   * longest match routines access bytes past the input.  This is then
   * updated to the new high water mark.
   */
}


function deflateResetKeep(strm) {
  var s;

  if (!strm || !strm.state) {
    return err(strm, Z_STREAM_ERROR);
  }

  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;

  s = strm.state;
  s.pending = 0;
  s.pending_out = 0;

  if (s.wrap < 0) {
    s.wrap = -s.wrap;
    /* was made negative by deflate(..., Z_FINISH); */
  }
  s.status = (s.wrap ? INIT_STATE : BUSY_STATE);
  strm.adler = (s.wrap === 2) ?
    0  // crc32(0, Z_NULL, 0)
  :
    1; // adler32(0, Z_NULL, 0)
  s.last_flush = Z_NO_FLUSH;
  trees._tr_init(s);
  return Z_OK;
}


function deflateReset(strm) {
  var ret = deflateResetKeep(strm);
  if (ret === Z_OK) {
    lm_init(strm.state);
  }
  return ret;
}


function deflateSetHeader(strm, head) {
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  if (strm.state.wrap !== 2) { return Z_STREAM_ERROR; }
  strm.state.gzhead = head;
  return Z_OK;
}


function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
  if (!strm) { // === Z_NULL
    return Z_STREAM_ERROR;
  }
  var wrap = 1;

  if (level === Z_DEFAULT_COMPRESSION) {
    level = 6;
  }

  if (windowBits < 0) { /* suppress zlib wrapper */
    wrap = 0;
    windowBits = -windowBits;
  }

  else if (windowBits > 15) {
    wrap = 2;           /* write gzip wrapper instead */
    windowBits -= 16;
  }


  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||
    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
    strategy < 0 || strategy > Z_FIXED) {
    return err(strm, Z_STREAM_ERROR);
  }


  if (windowBits === 8) {
    windowBits = 9;
  }
  /* until 256-byte window bug fixed */

  var s = new DeflateState();

  strm.state = s;
  s.strm = strm;

  s.wrap = wrap;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;

  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);

  s.window = new utils.Buf8(s.w_size * 2);
  s.head = new utils.Buf16(s.hash_size);
  s.prev = new utils.Buf16(s.w_size);

  // Don't need mem init magic for JS.
  //s.high_water = 0;  /* nothing written to s->window yet */

  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */

  s.pending_buf_size = s.lit_bufsize * 4;

  //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);
  //s->pending_buf = (uchf *) overlay;
  s.pending_buf = new utils.Buf8(s.pending_buf_size);

  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)
  //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);
  s.d_buf = 1 * s.lit_bufsize;

  //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;
  s.l_buf = (1 + 2) * s.lit_bufsize;

  s.level = level;
  s.strategy = strategy;
  s.method = method;

  return deflateReset(strm);
}

function deflateInit(strm, level) {
  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
}


function deflate(strm, flush) {
  var old_flush, s;
  var beg, val; // for gzip header write only

  if (!strm || !strm.state ||
    flush > Z_BLOCK || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
  }

  s = strm.state;

  if (!strm.output ||
      (!strm.input && strm.avail_in !== 0) ||
      (s.status === FINISH_STATE && flush !== Z_FINISH)) {
    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);
  }

  s.strm = strm; /* just in case */
  old_flush = s.last_flush;
  s.last_flush = flush;

  /* Write the header */
  if (s.status === INIT_STATE) {

    if (s.wrap === 2) { // GZIP header
      strm.adler = 0;  //crc32(0L, Z_NULL, 0);
      put_byte(s, 31);
      put_byte(s, 139);
      put_byte(s, 8);
      if (!s.gzhead) { // s->gzhead == Z_NULL
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, s.level === 9 ? 2 :
                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                     4 : 0));
        put_byte(s, OS_CODE);
        s.status = BUSY_STATE;
      }
      else {
        put_byte(s, (s.gzhead.text ? 1 : 0) +
                    (s.gzhead.hcrc ? 2 : 0) +
                    (!s.gzhead.extra ? 0 : 4) +
                    (!s.gzhead.name ? 0 : 8) +
                    (!s.gzhead.comment ? 0 : 16)
                );
        put_byte(s, s.gzhead.time & 0xff);
        put_byte(s, (s.gzhead.time >> 8) & 0xff);
        put_byte(s, (s.gzhead.time >> 16) & 0xff);
        put_byte(s, (s.gzhead.time >> 24) & 0xff);
        put_byte(s, s.level === 9 ? 2 :
                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                     4 : 0));
        put_byte(s, s.gzhead.os & 0xff);
        if (s.gzhead.extra && s.gzhead.extra.length) {
          put_byte(s, s.gzhead.extra.length & 0xff);
          put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);
        }
        if (s.gzhead.hcrc) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
        }
        s.gzindex = 0;
        s.status = EXTRA_STATE;
      }
    }
    else // DEFLATE header
    {
      var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;
      var level_flags = -1;

      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
        level_flags = 0;
      } else if (s.level < 6) {
        level_flags = 1;
      } else if (s.level === 6) {
        level_flags = 2;
      } else {
        level_flags = 3;
      }
      header |= (level_flags << 6);
      if (s.strstart !== 0) { header |= PRESET_DICT; }
      header += 31 - (header % 31);

      s.status = BUSY_STATE;
      putShortMSB(s, header);

      /* Save the adler32 of the preset dictionary: */
      if (s.strstart !== 0) {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 0xffff);
      }
      strm.adler = 1; // adler32(0L, Z_NULL, 0);
    }
  }

//#ifdef GZIP
  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */

      while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            break;
          }
        }
        put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);
        s.gzindex++;
      }
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (s.gzindex === s.gzhead.extra.length) {
        s.gzindex = 0;
        s.status = NAME_STATE;
      }
    }
    else {
      s.status = NAME_STATE;
    }
  }
  if (s.status === NAME_STATE) {
    if (s.gzhead.name/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */
      //int val;

      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.name.length) {
          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);

      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.gzindex = 0;
        s.status = COMMENT_STATE;
      }
    }
    else {
      s.status = COMMENT_STATE;
    }
  }
  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */
      //int val;

      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.comment.length) {
          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);

      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.status = HCRC_STATE;
      }
    }
    else {
      s.status = HCRC_STATE;
    }
  }
  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
      }
      if (s.pending + 2 <= s.pending_buf_size) {
        put_byte(s, strm.adler & 0xff);
        put_byte(s, (strm.adler >> 8) & 0xff);
        strm.adler = 0; //crc32(0L, Z_NULL, 0);
        s.status = BUSY_STATE;
      }
    }
    else {
      s.status = BUSY_STATE;
    }
  }
//#endif

  /* Flush as much pending output as possible */
  if (s.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      /* Since avail_out is 0, deflate will be called again with
       * more output space, but possibly with both pending and
       * avail_in equal to zero. There won't be anything to do,
       * but this is not an error situation so make sure we
       * return OK instead of BUF_ERROR at next call of deflate:
       */
      s.last_flush = -1;
      return Z_OK;
    }

    /* Make sure there is something to do and avoid duplicate consecutive
     * flushes. For repeated and useless calls with Z_FINISH, we keep
     * returning Z_STREAM_END instead of Z_BUF_ERROR.
     */
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&
    flush !== Z_FINISH) {
    return err(strm, Z_BUF_ERROR);
  }

  /* User must not provide more input after the first FINISH: */
  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR);
  }

  /* Start a new block or continue the current one.
   */
  if (strm.avail_in !== 0 || s.lookahead !== 0 ||
    (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {
    var bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :
      (s.strategy === Z_RLE ? deflate_rle(s, flush) :
        configuration_table[s.level].func(s, flush));

    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        /* avoid BUF_ERROR next call, see above */
      }
      return Z_OK;
      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
       * of deflate should use the same flush parameter to make sure
       * that the flush is complete. So we don't have to output an
       * empty block here, this will be done at next call. This also
       * ensures that for a very small output buffer, we emit at most
       * one empty block.
       */
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        trees._tr_align(s);
      }
      else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */

        trees._tr_stored_block(s, 0, 0, false);
        /* For a full flush, this empty block will be recognized
         * as a special marker by inflate_sync().
         */
        if (flush === Z_FULL_FLUSH) {
          /*** CLEAR_HASH(s); ***/             /* forget history */
          zero(s.head); // Fill with NIL (= 0);

          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */
        return Z_OK;
      }
    }
  }
  //Assert(strm->avail_out > 0, "bug2");
  //if (strm.avail_out <= 0) { throw new Error("bug2");}

  if (flush !== Z_FINISH) { return Z_OK; }
  if (s.wrap <= 0) { return Z_STREAM_END; }

  /* Write the trailer */
  if (s.wrap === 2) {
    put_byte(s, strm.adler & 0xff);
    put_byte(s, (strm.adler >> 8) & 0xff);
    put_byte(s, (strm.adler >> 16) & 0xff);
    put_byte(s, (strm.adler >> 24) & 0xff);
    put_byte(s, strm.total_in & 0xff);
    put_byte(s, (strm.total_in >> 8) & 0xff);
    put_byte(s, (strm.total_in >> 16) & 0xff);
    put_byte(s, (strm.total_in >> 24) & 0xff);
  }
  else
  {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler & 0xffff);
  }

  flush_pending(strm);
  /* If avail_out is zero, the application will call deflate again
   * to flush the rest.
   */
  if (s.wrap > 0) { s.wrap = -s.wrap; }
  /* write the trailer only once! */
  return s.pending !== 0 ? Z_OK : Z_STREAM_END;
}

function deflateEnd(strm) {
  var status;

  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
    return Z_STREAM_ERROR;
  }

  status = strm.state.status;
  if (status !== INIT_STATE &&
    status !== EXTRA_STATE &&
    status !== NAME_STATE &&
    status !== COMMENT_STATE &&
    status !== HCRC_STATE &&
    status !== BUSY_STATE &&
    status !== FINISH_STATE
  ) {
    return err(strm, Z_STREAM_ERROR);
  }

  strm.state = null;

  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
}


/* =========================================================================
 * Initializes the compression dictionary from the given byte
 * sequence without producing any compressed output.
 */
function deflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;

  var s;
  var str, n;
  var wrap;
  var avail;
  var next;
  var input;
  var tmpDict;

  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
    return Z_STREAM_ERROR;
  }

  s = strm.state;
  wrap = s.wrap;

  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {
    return Z_STREAM_ERROR;
  }

  /* when using zlib wrappers, compute Adler-32 for provided dictionary */
  if (wrap === 1) {
    /* adler32(strm->adler, dictionary, dictLength); */
    strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
  }

  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */

  /* if dictionary would fill window, just replace the history */
  if (dictLength >= s.w_size) {
    if (wrap === 0) {            /* already empty otherwise */
      /*** CLEAR_HASH(s); ***/
      zero(s.head); // Fill with NIL (= 0);
      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    /* use the tail */
    // dictionary = dictionary.slice(dictLength - s.w_size);
    tmpDict = new utils.Buf8(s.w_size);
    utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  /* insert dictionary into window and hash */
  avail = strm.avail_in;
  next = strm.next_in;
  input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s);
  while (s.lookahead >= MIN_MATCH) {
    str = s.strstart;
    n = s.lookahead - (MIN_MATCH - 1);
    do {
      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;

      s.prev[str & s.w_mask] = s.head[s.ins_h];

      s.head[s.ins_h] = str;
      str++;
    } while (--n);
    s.strstart = str;
    s.lookahead = MIN_MATCH - 1;
    fill_window(s);
  }
  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap;
  return Z_OK;
}


exports.deflateInit = deflateInit;
exports.deflateInit2 = deflateInit2;
exports.deflateReset = deflateReset;
exports.deflateResetKeep = deflateResetKeep;
exports.deflateSetHeader = deflateSetHeader;
exports.deflate = deflate;
exports.deflateEnd = deflateEnd;
exports.deflateSetDictionary = deflateSetDictionary;
exports.deflateInfo = 'pako deflate (from Nodeca project)';

/* Not implemented
exports.deflateBound = deflateBound;
exports.deflateCopy = deflateCopy;
exports.deflateParams = deflateParams;
exports.deflatePending = deflatePending;
exports.deflatePrime = deflatePrime;
exports.deflateTune = deflateTune;
*/

},{"../utils/common":3,"./adler32":5,"./crc32":7,"./messages":13,"./trees":14}],9:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function GZheader() {
  /* true if compressed data believed to be text */
  this.text       = 0;
  /* modification time */
  this.time       = 0;
  /* extra flags (not used when writing a gzip file) */
  this.xflags     = 0;
  /* operating system */
  this.os         = 0;
  /* pointer to extra field or Z_NULL if none */
  this.extra      = null;
  /* extra field length (valid if extra != Z_NULL) */
  this.extra_len  = 0; // Actually, we don't need it in JS,
                       // but leave for few code modifications

  //
  // Setup limits is not necessary because in js we should not preallocate memory
  // for inflate use constant limit in 65536 bytes
  //

  /* space at extra (only when reading header) */
  // this.extra_max  = 0;
  /* pointer to zero-terminated file name or Z_NULL */
  this.name       = '';
  /* space at name (only when reading header) */
  // this.name_max   = 0;
  /* pointer to zero-terminated comment or Z_NULL */
  this.comment    = '';
  /* space at comment (only when reading header) */
  // this.comm_max   = 0;
  /* true if there was or will be a header crc */
  this.hcrc       = 0;
  /* true when done reading gzip header (not used when writing a gzip file) */
  this.done       = false;
}

module.exports = GZheader;

},{}],10:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

// See state defs from inflate.js
var BAD = 30;       /* got a data error -- remain here until reset */
var TYPE = 12;      /* i: waiting for type bits, including last-flag bit */

/*
   Decode literal, length, and distance codes and write out the resulting
   literal and match bytes until either not enough input or output is
   available, an end-of-block is encountered, or a data error is encountered.
   When large enough input and output buffers are supplied to inflate(), for
   example, a 16K input buffer and a 64K output buffer, more than 95% of the
   inflate execution time is spent in this routine.

   Entry assumptions:

        state.mode === LEN
        strm.avail_in >= 6
        strm.avail_out >= 258
        start >= strm.avail_out
        state.bits < 8

   On return, state.mode is one of:

        LEN -- ran out of enough output space or enough available input
        TYPE -- reached end of block code, inflate() to interpret next block
        BAD -- error in block data

   Notes:

    - The maximum input bits used by a length/distance pair is 15 bits for the
      length code, 5 bits for the length extra, 15 bits for the distance code,
      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
      Therefore if strm.avail_in >= 6, then there is enough input to avoid
      checking for available input while decoding.

    - The maximum bytes that a single length/distance pair can output is 258
      bytes, which is the maximum length that can be coded.  inflate_fast()
      requires strm.avail_out >= 258 for each loop to avoid checking for
      output space.
 */
module.exports = function inflate_fast(strm, start) {
  var state;
  var _in;                    /* local strm.input */
  var last;                   /* have enough input while in < last */
  var _out;                   /* local strm.output */
  var beg;                    /* inflate()'s initial strm.output */
  var end;                    /* while out < end, enough space available */
//#ifdef INFLATE_STRICT
  var dmax;                   /* maximum distance from zlib header */
//#endif
  var wsize;                  /* window size or zero if not using window */
  var whave;                  /* valid bytes in the window */
  var wnext;                  /* window write index */
  // Use `s_window` instead `window`, avoid conflict with instrumentation tools
  var s_window;               /* allocated sliding window, if wsize != 0 */
  var hold;                   /* local strm.hold */
  var bits;                   /* local strm.bits */
  var lcode;                  /* local strm.lencode */
  var dcode;                  /* local strm.distcode */
  var lmask;                  /* mask for first level of length codes */
  var dmask;                  /* mask for first level of distance codes */
  var here;                   /* retrieved table entry */
  var op;                     /* code bits, operation, extra bits, or */
                              /*  window position, window bytes to copy */
  var len;                    /* match length, unused bytes */
  var dist;                   /* match distance */
  var from;                   /* where to copy match from */
  var from_source;


  var input, output; // JS specific, because we have no pointers

  /* copy state to local variables */
  state = strm.state;
  //here = state.here;
  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
//#ifdef INFLATE_STRICT
  dmax = state.dmax;
//#endif
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;


  /* decode literals and length/distances until end-of-block or not enough
     input data or output space */

  top:
  do {
    if (bits < 15) {
      hold += input[_in++] << bits;
      bits += 8;
      hold += input[_in++] << bits;
      bits += 8;
    }

    here = lcode[hold & lmask];

    dolen:
    for (;;) { // Goto emulation
      op = here >>> 24/*here.bits*/;
      hold >>>= op;
      bits -= op;
      op = (here >>> 16) & 0xff/*here.op*/;
      if (op === 0) {                          /* literal */
        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
        //        "inflate:         literal '%c'\n" :
        //        "inflate:         literal 0x%02x\n", here.val));
        output[_out++] = here & 0xffff/*here.val*/;
      }
      else if (op & 16) {                     /* length base */
        len = here & 0xffff/*here.val*/;
        op &= 15;                           /* number of extra bits */
        if (op) {
          if (bits < op) {
            hold += input[_in++] << bits;
            bits += 8;
          }
          len += hold & ((1 << op) - 1);
          hold >>>= op;
          bits -= op;
        }
        //Tracevv((stderr, "inflate:         length %u\n", len));
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = dcode[hold & dmask];

        dodist:
        for (;;) { // goto emulation
          op = here >>> 24/*here.bits*/;
          hold >>>= op;
          bits -= op;
          op = (here >>> 16) & 0xff/*here.op*/;

          if (op & 16) {                      /* distance base */
            dist = here & 0xffff/*here.val*/;
            op &= 15;                       /* number of extra bits */
            if (bits < op) {
              hold += input[_in++] << bits;
              bits += 8;
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
            }
            dist += hold & ((1 << op) - 1);
//#ifdef INFLATE_STRICT
            if (dist > dmax) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break top;
            }
//#endif
            hold >>>= op;
            bits -= op;
            //Tracevv((stderr, "inflate:         distance %u\n", dist));
            op = _out - beg;                /* max distance in output */
            if (dist > op) {                /* see if copy from window */
              op = dist - op;               /* distance back in window */
              if (op > whave) {
                if (state.sane) {
                  strm.msg = 'invalid distance too far back';
                  state.mode = BAD;
                  break top;
                }

// (!) This block is disabled in zlib defaults,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//                if (len <= op - whave) {
//                  do {
//                    output[_out++] = 0;
//                  } while (--len);
//                  continue top;
//                }
//                len -= op - whave;
//                do {
//                  output[_out++] = 0;
//                } while (--op > whave);
//                if (op === 0) {
//                  from = _out - dist;
//                  do {
//                    output[_out++] = output[from++];
//                  } while (--len);
//                  continue top;
//                }
//#endif
              }
              from = 0; // window index
              from_source = s_window;
              if (wnext === 0) {           /* very common case */
                from += wsize - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              else if (wnext < op) {      /* wrap around window */
                from += wsize + wnext - op;
                op -= wnext;
                if (op < len) {         /* some from end of window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = 0;
                  if (wnext < len) {  /* some from start of window */
                    op = wnext;
                    len -= op;
                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);
                    from = _out - dist;      /* rest from output */
                    from_source = output;
                  }
                }
              }
              else {                      /* contiguous in window */
                from += wnext - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              while (len > 2) {
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                len -= 3;
              }
              if (len) {
                output[_out++] = from_source[from++];
                if (len > 1) {
                  output[_out++] = from_source[from++];
                }
              }
            }
            else {
              from = _out - dist;          /* copy direct from output */
              do {                        /* minimum length is three */
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                len -= 3;
              } while (len > 2);
              if (len) {
                output[_out++] = output[from++];
                if (len > 1) {
                  output[_out++] = output[from++];
                }
              }
            }
          }
          else if ((op & 64) === 0) {          /* 2nd level distance code */
            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
            continue dodist;
          }
          else {
            strm.msg = 'invalid distance code';
            state.mode = BAD;
            break top;
          }

          break; // need to emulate goto via "continue"
        }
      }
      else if ((op & 64) === 0) {              /* 2nd level length code */
        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
        continue dolen;
      }
      else if (op & 32) {                     /* end-of-block */
        //Tracevv((stderr, "inflate:         end of block\n"));
        state.mode = TYPE;
        break top;
      }
      else {
        strm.msg = 'invalid literal/length code';
        state.mode = BAD;
        break top;
      }

      break; // need to emulate goto via "continue"
    }
  } while (_in < last && _out < end);

  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;

  /* update state and return */
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));
  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));
  state.hold = hold;
  state.bits = bits;
  return;
};

},{}],11:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var utils         = require('../utils/common');
var adler32       = require('./adler32');
var crc32         = require('./crc32');
var inflate_fast  = require('./inffast');
var inflate_table = require('./inftrees');

var CODES = 0;
var LENS = 1;
var DISTS = 2;

/* Public constants ==========================================================*/
/* ===========================================================================*/


/* Allowed flush values; see deflate() and inflate() below for details */
//var Z_NO_FLUSH      = 0;
//var Z_PARTIAL_FLUSH = 1;
//var Z_SYNC_FLUSH    = 2;
//var Z_FULL_FLUSH    = 3;
var Z_FINISH        = 4;
var Z_BLOCK         = 5;
var Z_TREES         = 6;


/* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */
var Z_OK            = 0;
var Z_STREAM_END    = 1;
var Z_NEED_DICT     = 2;
//var Z_ERRNO         = -1;
var Z_STREAM_ERROR  = -2;
var Z_DATA_ERROR    = -3;
var Z_MEM_ERROR     = -4;
var Z_BUF_ERROR     = -5;
//var Z_VERSION_ERROR = -6;

/* The deflate compression method */
var Z_DEFLATED  = 8;


/* STATES ====================================================================*/
/* ===========================================================================*/


var    HEAD = 1;       /* i: waiting for magic header */
var    FLAGS = 2;      /* i: waiting for method and flags (gzip) */
var    TIME = 3;       /* i: waiting for modification time (gzip) */
var    OS = 4;         /* i: waiting for extra flags and operating system (gzip) */
var    EXLEN = 5;      /* i: waiting for extra length (gzip) */
var    EXTRA = 6;      /* i: waiting for extra bytes (gzip) */
var    NAME = 7;       /* i: waiting for end of file name (gzip) */
var    COMMENT = 8;    /* i: waiting for end of comment (gzip) */
var    HCRC = 9;       /* i: waiting for header crc (gzip) */
var    DICTID = 10;    /* i: waiting for dictionary check value */
var    DICT = 11;      /* waiting for inflateSetDictionary() call */
var        TYPE = 12;      /* i: waiting for type bits, including last-flag bit */
var        TYPEDO = 13;    /* i: same, but skip check to exit inflate on new block */
var        STORED = 14;    /* i: waiting for stored size (length and complement) */
var        COPY_ = 15;     /* i/o: same as COPY below, but only first time in */
var        COPY = 16;      /* i/o: waiting for input or output to copy stored block */
var        TABLE = 17;     /* i: waiting for dynamic block table lengths */
var        LENLENS = 18;   /* i: waiting for code length code lengths */
var        CODELENS = 19;  /* i: waiting for length/lit and distance code lengths */
var            LEN_ = 20;      /* i: same as LEN below, but only first time in */
var            LEN = 21;       /* i: waiting for length/lit/eob code */
var            LENEXT = 22;    /* i: waiting for length extra bits */
var            DIST = 23;      /* i: waiting for distance code */
var            DISTEXT = 24;   /* i: waiting for distance extra bits */
var            MATCH = 25;     /* o: waiting for output space to copy string */
var            LIT = 26;       /* o: waiting for output space to write literal */
var    CHECK = 27;     /* i: waiting for 32-bit check value */
var    LENGTH = 28;    /* i: waiting for 32-bit length (gzip) */
var    DONE = 29;      /* finished check, done -- remain here until reset */
var    BAD = 30;       /* got a data error -- remain here until reset */
var    MEM = 31;       /* got an inflate() memory error -- remain here until reset */
var    SYNC = 32;      /* looking for synchronization bytes to restart inflate() */

/* ===========================================================================*/



var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
//var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);

var MAX_WBITS = 15;
/* 32K LZ77 window */
var DEF_WBITS = MAX_WBITS;


function zswap32(q) {
  return  (((q >>> 24) & 0xff) +
          ((q >>> 8) & 0xff00) +
          ((q & 0xff00) << 8) +
          ((q & 0xff) << 24));
}


function InflateState() {
  this.mode = 0;             /* current inflate mode */
  this.last = false;          /* true if processing last block */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
  this.havedict = false;      /* true if dictionary provided */
  this.flags = 0;             /* gzip header method and flags (0 if zlib) */
  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */
  this.check = 0;             /* protected copy of check value */
  this.total = 0;             /* protected copy of output count */
  // TODO: may be {}
  this.head = null;           /* where to save gzip header information */

  /* sliding window */
  this.wbits = 0;             /* log base 2 of requested window size */
  this.wsize = 0;             /* window size or zero if not using window */
  this.whave = 0;             /* valid bytes in the window */
  this.wnext = 0;             /* window write index */
  this.window = null;         /* allocated sliding window, if needed */

  /* bit accumulator */
  this.hold = 0;              /* input bit accumulator */
  this.bits = 0;              /* number of bits in "in" */

  /* for string and stored block copying */
  this.length = 0;            /* literal or length of data to copy */
  this.offset = 0;            /* distance back to copy string from */

  /* for table and code decoding */
  this.extra = 0;             /* extra bits needed */

  /* fixed and dynamic code tables */
  this.lencode = null;          /* starting table for length/literal codes */
  this.distcode = null;         /* starting table for distance codes */
  this.lenbits = 0;           /* index bits for lencode */
  this.distbits = 0;          /* index bits for distcode */

  /* dynamic table building */
  this.ncode = 0;             /* number of code length code lengths */
  this.nlen = 0;              /* number of length code lengths */
  this.ndist = 0;             /* number of distance code lengths */
  this.have = 0;              /* number of code lengths in lens[] */
  this.next = null;              /* next available space in codes[] */

  this.lens = new utils.Buf16(320); /* temporary storage for code lengths */
  this.work = new utils.Buf16(288); /* work area for code table building */

  /*
   because we don't have pointers in js, we use lencode and distcode directly
   as buffers so we don't need codes
  */
  //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */
  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */
  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */
  this.sane = 0;                   /* if false, allow invalid distance too far */
  this.back = 0;                   /* bits back of last unprocessed length/lit */
  this.was = 0;                    /* initial length of match */
}

function inflateResetKeep(strm) {
  var state;

  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = ''; /*Z_NULL*/
  if (state.wrap) {       /* to support ill-conceived Java test suite */
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.dmax = 32768;
  state.head = null/*Z_NULL*/;
  state.hold = 0;
  state.bits = 0;
  //state.lencode = state.distcode = state.next = state.codes;
  state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
  state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);

  state.sane = 1;
  state.back = -1;
  //Tracev((stderr, "inflate: reset\n"));
  return Z_OK;
}

function inflateReset(strm) {
  var state;

  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);

}

function inflateReset2(strm, windowBits) {
  var wrap;
  var state;

  /* get the state */
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;

  /* extract wrap request from windowBits parameter */
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  }
  else {
    wrap = (windowBits >> 4) + 1;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }

  /* set number of window bits, free window if different */
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }

  /* update state and reset the rest of it */
  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset(strm);
}

function inflateInit2(strm, windowBits) {
  var ret;
  var state;

  if (!strm) { return Z_STREAM_ERROR; }
  //strm.msg = Z_NULL;                 /* in case we return an error */

  state = new InflateState();

  //if (state === Z_NULL) return Z_MEM_ERROR;
  //Tracev((stderr, "inflate: allocated\n"));
  strm.state = state;
  state.window = null/*Z_NULL*/;
  ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK) {
    strm.state = null/*Z_NULL*/;
  }
  return ret;
}

function inflateInit(strm) {
  return inflateInit2(strm, DEF_WBITS);
}


/*
 Return state with length and distance decoding tables and index sizes set to
 fixed code decoding.  Normally this returns fixed tables from inffixed.h.
 If BUILDFIXED is defined, then instead this routine builds the tables the
 first time it's called, and returns those tables the first time and
 thereafter.  This reduces the size of the code by about 2K bytes, in
 exchange for a little execution time.  However, BUILDFIXED should not be
 used for threaded applications, since the rewriting of the tables and virgin
 may not be thread-safe.
 */
var virgin = true;

var lenfix, distfix; // We have no pointers in JS, so keep tables separate

function fixedtables(state) {
  /* build fixed huffman tables if first call (may not be thread safe) */
  if (virgin) {
    var sym;

    lenfix = new utils.Buf32(512);
    distfix = new utils.Buf32(32);

    /* literal/length table */
    sym = 0;
    while (sym < 144) { state.lens[sym++] = 8; }
    while (sym < 256) { state.lens[sym++] = 9; }
    while (sym < 280) { state.lens[sym++] = 7; }
    while (sym < 288) { state.lens[sym++] = 8; }

    inflate_table(LENS,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });

    /* distance table */
    sym = 0;
    while (sym < 32) { state.lens[sym++] = 5; }

    inflate_table(DISTS, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });

    /* do this just once */
    virgin = false;
  }

  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
}


/*
 Update the window with the last wsize (normally 32K) bytes written before
 returning.  If window does not exist yet, create it.  This is only called
 when a window is already in use, or when output has been written during this
 inflate call, but the end of the deflate stream has not been reached yet.
 It is also called to create a window for dictionary data when a dictionary
 is loaded.

 Providing output buffers larger than 32K to inflate() should provide a speed
 advantage, since only the last 32K of output is copied to the sliding window
 upon return from inflate(), and since all distances after the first 32K of
 output will fall in the output data, making match copies simpler and faster.
 The advantage may be dependent on the size of the processor's data caches.
 */
function updatewindow(strm, src, end, copy) {
  var dist;
  var state = strm.state;

  /* if it hasn't been done already, allocate space for the window */
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;

    state.window = new utils.Buf8(state.wsize);
  }

  /* copy state->wsize or less output bytes into the circular window */
  if (copy >= state.wsize) {
    utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
    state.wnext = 0;
    state.whave = state.wsize;
  }
  else {
    dist = state.wsize - state.wnext;
    if (dist > copy) {
      dist = copy;
    }
    //zmemcpy(state->window + state->wnext, end - copy, dist);
    utils.arraySet(state.window, src, end - copy, dist, state.wnext);
    copy -= dist;
    if (copy) {
      //zmemcpy(state->window, end - copy, copy);
      utils.arraySet(state.window, src, end - copy, copy, 0);
      state.wnext = copy;
      state.whave = state.wsize;
    }
    else {
      state.wnext += dist;
      if (state.wnext === state.wsize) { state.wnext = 0; }
      if (state.whave < state.wsize) { state.whave += dist; }
    }
  }
  return 0;
}

function inflate(strm, flush) {
  var state;
  var input, output;          // input/output buffers
  var next;                   /* next input INDEX */
  var put;                    /* next output INDEX */
  var have, left;             /* available input and output */
  var hold;                   /* bit buffer */
  var bits;                   /* bits in bit buffer */
  var _in, _out;              /* save starting available input and output */
  var copy;                   /* number of stored or match bytes to copy */
  var from;                   /* where to copy match bytes from */
  var from_source;
  var here = 0;               /* current decoding table entry */
  var here_bits, here_op, here_val; // paked "here" denormalized (JS specific)
  //var last;                   /* parent table entry */
  var last_bits, last_op, last_val; // paked "last" denormalized (JS specific)
  var len;                    /* length to copy for repeats, bits to drop */
  var ret;                    /* return code */
  var hbuf = new utils.Buf8(4);    /* buffer for gzip header crc calculation */
  var opts;

  var n; // temporary var for NEED_BITS

  var order = /* permutation of code lengths */
    [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];


  if (!strm || !strm.state || !strm.output ||
      (!strm.input && strm.avail_in !== 0)) {
    return Z_STREAM_ERROR;
  }

  state = strm.state;
  if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */


  //--- LOAD() ---
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits;
  //---

  _in = have;
  _out = left;
  ret = Z_OK;

  inf_leave: // goto emulation
  for (;;) {
    switch (state.mode) {
      case HEAD:
        if (state.wrap === 0) {
          state.mode = TYPEDO;
          break;
        }
        //=== NEEDBITS(16);
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */
          state.check = 0/*crc32(0L, Z_NULL, 0)*/;
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0);
          //===//

          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          state.mode = FLAGS;
          break;
        }
        state.flags = 0;           /* expect zlib header */
        if (state.head) {
          state.head.done = false;
        }
        if (!(state.wrap & 1) ||   /* check if zlib header allowed */
          (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {
          strm.msg = 'incorrect header check';
          state.mode = BAD;
          break;
        }
        if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {
          strm.msg = 'unknown compression method';
          state.mode = BAD;
          break;
        }
        //--- DROPBITS(4) ---//
        hold >>>= 4;
        bits -= 4;
        //---//
        len = (hold & 0x0f)/*BITS(4)*/ + 8;
        if (state.wbits === 0) {
          state.wbits = len;
        }
        else if (len > state.wbits) {
          strm.msg = 'invalid window size';
          state.mode = BAD;
          break;
        }
        state.dmax = 1 << len;
        //Tracev((stderr, "inflate:   zlib header ok\n"));
        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
        state.mode = hold & 0x200 ? DICTID : TYPE;
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        break;
      case FLAGS:
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.flags = hold;
        if ((state.flags & 0xff) !== Z_DEFLATED) {
          strm.msg = 'unknown compression method';
          state.mode = BAD;
          break;
        }
        if (state.flags & 0xe000) {
          strm.msg = 'unknown header flags set';
          state.mode = BAD;
          break;
        }
        if (state.head) {
          state.head.text = ((hold >> 8) & 1);
        }
        if (state.flags & 0x0200) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = TIME;
        /* falls through */
      case TIME:
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (state.head) {
          state.head.time = hold;
        }
        if (state.flags & 0x0200) {
          //=== CRC4(state.check, hold)
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          hbuf[2] = (hold >>> 16) & 0xff;
          hbuf[3] = (hold >>> 24) & 0xff;
          state.check = crc32(state.check, hbuf, 4, 0);
          //===
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = OS;
        /* falls through */
      case OS:
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (state.head) {
          state.head.xflags = (hold & 0xff);
          state.head.os = (hold >> 8);
        }
        if (state.flags & 0x0200) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = EXLEN;
        /* falls through */
      case EXLEN:
        if (state.flags & 0x0400) {
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.length = hold;
          if (state.head) {
            state.head.extra_len = hold;
          }
          if (state.flags & 0x0200) {
            //=== CRC2(state.check, hold);
            hbuf[0] = hold & 0xff;
            hbuf[1] = (hold >>> 8) & 0xff;
            state.check = crc32(state.check, hbuf, 2, 0);
            //===//
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
        }
        else if (state.head) {
          state.head.extra = null/*Z_NULL*/;
        }
        state.mode = EXTRA;
        /* falls through */
      case EXTRA:
        if (state.flags & 0x0400) {
          copy = state.length;
          if (copy > have) { copy = have; }
          if (copy) {
            if (state.head) {
              len = state.head.extra_len - state.length;
              if (!state.head.extra) {
                // Use untyped array for more convenient processing later
                state.head.extra = new Array(state.head.extra_len);
              }
              utils.arraySet(
                state.head.extra,
                input,
                next,
                // extra field is limited to 65536 bytes
                // - no need for additional size check
                copy,
                /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                len
              );
              //zmemcpy(state.head.extra + len, next,
              //        len + copy > state.head.extra_max ?
              //        state.head.extra_max - len : copy);
            }
            if (state.flags & 0x0200) {
              state.check = crc32(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            state.length -= copy;
          }
          if (state.length) { break inf_leave; }
        }
        state.length = 0;
        state.mode = NAME;
        /* falls through */
      case NAME:
        if (state.flags & 0x0800) {
          if (have === 0) { break inf_leave; }
          copy = 0;
          do {
            // TODO: 2 or 1 bytes?
            len = input[next + copy++];
            /* use constant limit because in js we should not preallocate memory */
            if (state.head && len &&
                (state.length < 65536 /*state.head.name_max*/)) {
              state.head.name += String.fromCharCode(len);
            }
          } while (len && copy < have);

          if (state.flags & 0x0200) {
            state.check = crc32(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          if (len) { break inf_leave; }
        }
        else if (state.head) {
          state.head.name = null;
        }
        state.length = 0;
        state.mode = COMMENT;
        /* falls through */
      case COMMENT:
        if (state.flags & 0x1000) {
          if (have === 0) { break inf_leave; }
          copy = 0;
          do {
            len = input[next + copy++];
            /* use constant limit because in js we should not preallocate memory */
            if (state.head && len &&
                (state.length < 65536 /*state.head.comm_max*/)) {
              state.head.comment += String.fromCharCode(len);
            }
          } while (len && copy < have);
          if (state.flags & 0x0200) {
            state.check = crc32(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          if (len) { break inf_leave; }
        }
        else if (state.head) {
          state.head.comment = null;
        }
        state.mode = HCRC;
        /* falls through */
      case HCRC:
        if (state.flags & 0x0200) {
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          if (hold !== (state.check & 0xffff)) {
            strm.msg = 'header crc mismatch';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
        }
        if (state.head) {
          state.head.hcrc = ((state.flags >> 9) & 1);
          state.head.done = true;
        }
        strm.adler = state.check = 0;
        state.mode = TYPE;
        break;
      case DICTID:
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        strm.adler = state.check = zswap32(hold);
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = DICT;
        /* falls through */
      case DICT:
        if (state.havedict === 0) {
          //--- RESTORE() ---
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits;
          //---
          return Z_NEED_DICT;
        }
        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
        state.mode = TYPE;
        /* falls through */
      case TYPE:
        if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case TYPEDO:
        if (state.last) {
          //--- BYTEBITS() ---//
          hold >>>= bits & 7;
          bits -= bits & 7;
          //---//
          state.mode = CHECK;
          break;
        }
        //=== NEEDBITS(3); */
        while (bits < 3) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.last = (hold & 0x01)/*BITS(1)*/;
        //--- DROPBITS(1) ---//
        hold >>>= 1;
        bits -= 1;
        //---//

        switch ((hold & 0x03)/*BITS(2)*/) {
          case 0:                             /* stored block */
            //Tracev((stderr, "inflate:     stored block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = STORED;
            break;
          case 1:                             /* fixed block */
            fixedtables(state);
            //Tracev((stderr, "inflate:     fixed codes block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = LEN_;             /* decode codes */
            if (flush === Z_TREES) {
              //--- DROPBITS(2) ---//
              hold >>>= 2;
              bits -= 2;
              //---//
              break inf_leave;
            }
            break;
          case 2:                             /* dynamic block */
            //Tracev((stderr, "inflate:     dynamic codes block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = TABLE;
            break;
          case 3:
            strm.msg = 'invalid block type';
            state.mode = BAD;
        }
        //--- DROPBITS(2) ---//
        hold >>>= 2;
        bits -= 2;
        //---//
        break;
      case STORED:
        //--- BYTEBITS() ---// /* go to byte boundary */
        hold >>>= bits & 7;
        bits -= bits & 7;
        //---//
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {
          strm.msg = 'invalid stored block lengths';
          state.mode = BAD;
          break;
        }
        state.length = hold & 0xffff;
        //Tracev((stderr, "inflate:       stored length %u\n",
        //        state.length));
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = COPY_;
        if (flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case COPY_:
        state.mode = COPY;
        /* falls through */
      case COPY:
        copy = state.length;
        if (copy) {
          if (copy > have) { copy = have; }
          if (copy > left) { copy = left; }
          if (copy === 0) { break inf_leave; }
          //--- zmemcpy(put, next, copy); ---
          utils.arraySet(output, input, next, copy, put);
          //---//
          have -= copy;
          next += copy;
          left -= copy;
          put += copy;
          state.length -= copy;
          break;
        }
        //Tracev((stderr, "inflate:       stored end\n"));
        state.mode = TYPE;
        break;
      case TABLE:
        //=== NEEDBITS(14); */
        while (bits < 14) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;
        //--- DROPBITS(5) ---//
        hold >>>= 5;
        bits -= 5;
        //---//
        state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;
        //--- DROPBITS(5) ---//
        hold >>>= 5;
        bits -= 5;
        //---//
        state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;
        //--- DROPBITS(4) ---//
        hold >>>= 4;
        bits -= 4;
        //---//
//#ifndef PKZIP_BUG_WORKAROUND
        if (state.nlen > 286 || state.ndist > 30) {
          strm.msg = 'too many length or distance symbols';
          state.mode = BAD;
          break;
        }
//#endif
        //Tracev((stderr, "inflate:       table sizes ok\n"));
        state.have = 0;
        state.mode = LENLENS;
        /* falls through */
      case LENLENS:
        while (state.have < state.ncode) {
          //=== NEEDBITS(3);
          while (bits < 3) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);
          //--- DROPBITS(3) ---//
          hold >>>= 3;
          bits -= 3;
          //---//
        }
        while (state.have < 19) {
          state.lens[order[state.have++]] = 0;
        }
        // We have separate tables & no pointers. 2 commented lines below not needed.
        //state.next = state.codes;
        //state.lencode = state.next;
        // Switch to use dynamic table
        state.lencode = state.lendyn;
        state.lenbits = 7;

        opts = { bits: state.lenbits };
        ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
        state.lenbits = opts.bits;

        if (ret) {
          strm.msg = 'invalid code lengths set';
          state.mode = BAD;
          break;
        }
        //Tracev((stderr, "inflate:       code lengths ok\n"));
        state.have = 0;
        state.mode = CODELENS;
        /* falls through */
      case CODELENS:
        while (state.have < state.nlen + state.ndist) {
          for (;;) {
            here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          if (here_val < 16) {
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            state.lens[state.have++] = here_val;
          }
          else {
            if (here_val === 16) {
              //=== NEEDBITS(here.bits + 2);
              n = here_bits + 2;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              if (state.have === 0) {
                strm.msg = 'invalid bit length repeat';
                state.mode = BAD;
                break;
              }
              len = state.lens[state.have - 1];
              copy = 3 + (hold & 0x03);//BITS(2);
              //--- DROPBITS(2) ---//
              hold >>>= 2;
              bits -= 2;
              //---//
            }
            else if (here_val === 17) {
              //=== NEEDBITS(here.bits + 3);
              n = here_bits + 3;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              len = 0;
              copy = 3 + (hold & 0x07);//BITS(3);
              //--- DROPBITS(3) ---//
              hold >>>= 3;
              bits -= 3;
              //---//
            }
            else {
              //=== NEEDBITS(here.bits + 7);
              n = here_bits + 7;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              len = 0;
              copy = 11 + (hold & 0x7f);//BITS(7);
              //--- DROPBITS(7) ---//
              hold >>>= 7;
              bits -= 7;
              //---//
            }
            if (state.have + copy > state.nlen + state.ndist) {
              strm.msg = 'invalid bit length repeat';
              state.mode = BAD;
              break;
            }
            while (copy--) {
              state.lens[state.have++] = len;
            }
          }
        }

        /* handle error breaks in while */
        if (state.mode === BAD) { break; }

        /* check for end-of-block code (better have one) */
        if (state.lens[256] === 0) {
          strm.msg = 'invalid code -- missing end-of-block';
          state.mode = BAD;
          break;
        }

        /* build code tables -- note: do not change the lenbits or distbits
           values here (9 and 6) without reading the comments in inftrees.h
           concerning the ENOUGH constants, which depend on those values */
        state.lenbits = 9;

        opts = { bits: state.lenbits };
        ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
        // We have separate tables & no pointers. 2 commented lines below not needed.
        // state.next_index = opts.table_index;
        state.lenbits = opts.bits;
        // state.lencode = state.next;

        if (ret) {
          strm.msg = 'invalid literal/lengths set';
          state.mode = BAD;
          break;
        }

        state.distbits = 6;
        //state.distcode.copy(state.codes);
        // Switch to use dynamic table
        state.distcode = state.distdyn;
        opts = { bits: state.distbits };
        ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
        // We have separate tables & no pointers. 2 commented lines below not needed.
        // state.next_index = opts.table_index;
        state.distbits = opts.bits;
        // state.distcode = state.next;

        if (ret) {
          strm.msg = 'invalid distances set';
          state.mode = BAD;
          break;
        }
        //Tracev((stderr, 'inflate:       codes ok\n'));
        state.mode = LEN_;
        if (flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case LEN_:
        state.mode = LEN;
        /* falls through */
      case LEN:
        if (have >= 6 && left >= 258) {
          //--- RESTORE() ---
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits;
          //---
          inflate_fast(strm, _out);
          //--- LOAD() ---
          put = strm.next_out;
          output = strm.output;
          left = strm.avail_out;
          next = strm.next_in;
          input = strm.input;
          have = strm.avail_in;
          hold = state.hold;
          bits = state.bits;
          //---

          if (state.mode === TYPE) {
            state.back = -1;
          }
          break;
        }
        state.back = 0;
        for (;;) {
          here = state.lencode[hold & ((1 << state.lenbits) - 1)];  /*BITS(state.lenbits)*/
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if (here_bits <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        if (here_op && (here_op & 0xf0) === 0) {
          last_bits = here_bits;
          last_op = here_op;
          last_val = here_val;
          for (;;) {
            here = state.lencode[last_val +
                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((last_bits + here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          //--- DROPBITS(last.bits) ---//
          hold >>>= last_bits;
          bits -= last_bits;
          //---//
          state.back += last_bits;
        }
        //--- DROPBITS(here.bits) ---//
        hold >>>= here_bits;
        bits -= here_bits;
        //---//
        state.back += here_bits;
        state.length = here_val;
        if (here_op === 0) {
          //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
          //        "inflate:         literal '%c'\n" :
          //        "inflate:         literal 0x%02x\n", here.val));
          state.mode = LIT;
          break;
        }
        if (here_op & 32) {
          //Tracevv((stderr, "inflate:         end of block\n"));
          state.back = -1;
          state.mode = TYPE;
          break;
        }
        if (here_op & 64) {
          strm.msg = 'invalid literal/length code';
          state.mode = BAD;
          break;
        }
        state.extra = here_op & 15;
        state.mode = LENEXT;
        /* falls through */
      case LENEXT:
        if (state.extra) {
          //=== NEEDBITS(state.extra);
          n = state.extra;
          while (bits < n) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.length += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
          //--- DROPBITS(state.extra) ---//
          hold >>>= state.extra;
          bits -= state.extra;
          //---//
          state.back += state.extra;
        }
        //Tracevv((stderr, "inflate:         length %u\n", state.length));
        state.was = state.length;
        state.mode = DIST;
        /* falls through */
      case DIST:
        for (;;) {
          here = state.distcode[hold & ((1 << state.distbits) - 1)];/*BITS(state.distbits)*/
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if ((here_bits) <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        if ((here_op & 0xf0) === 0) {
          last_bits = here_bits;
          last_op = here_op;
          last_val = here_val;
          for (;;) {
            here = state.distcode[last_val +
                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((last_bits + here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          //--- DROPBITS(last.bits) ---//
          hold >>>= last_bits;
          bits -= last_bits;
          //---//
          state.back += last_bits;
        }
        //--- DROPBITS(here.bits) ---//
        hold >>>= here_bits;
        bits -= here_bits;
        //---//
        state.back += here_bits;
        if (here_op & 64) {
          strm.msg = 'invalid distance code';
          state.mode = BAD;
          break;
        }
        state.offset = here_val;
        state.extra = (here_op) & 15;
        state.mode = DISTEXT;
        /* falls through */
      case DISTEXT:
        if (state.extra) {
          //=== NEEDBITS(state.extra);
          n = state.extra;
          while (bits < n) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.offset += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
          //--- DROPBITS(state.extra) ---//
          hold >>>= state.extra;
          bits -= state.extra;
          //---//
          state.back += state.extra;
        }
//#ifdef INFLATE_STRICT
        if (state.offset > state.dmax) {
          strm.msg = 'invalid distance too far back';
          state.mode = BAD;
          break;
        }
//#endif
        //Tracevv((stderr, "inflate:         distance %u\n", state.offset));
        state.mode = MATCH;
        /* falls through */
      case MATCH:
        if (left === 0) { break inf_leave; }
        copy = _out - left;
        if (state.offset > copy) {         /* copy from window */
          copy = state.offset - copy;
          if (copy > state.whave) {
            if (state.sane) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break;
            }
// (!) This block is disabled in zlib defaults,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//          Trace((stderr, "inflate.c too far\n"));
//          copy -= state.whave;
//          if (copy > state.length) { copy = state.length; }
//          if (copy > left) { copy = left; }
//          left -= copy;
//          state.length -= copy;
//          do {
//            output[put++] = 0;
//          } while (--copy);
//          if (state.length === 0) { state.mode = LEN; }
//          break;
//#endif
          }
          if (copy > state.wnext) {
            copy -= state.wnext;
            from = state.wsize - copy;
          }
          else {
            from = state.wnext - copy;
          }
          if (copy > state.length) { copy = state.length; }
          from_source = state.window;
        }
        else {                              /* copy from output */
          from_source = output;
          from = put - state.offset;
          copy = state.length;
        }
        if (copy > left) { copy = left; }
        left -= copy;
        state.length -= copy;
        do {
          output[put++] = from_source[from++];
        } while (--copy);
        if (state.length === 0) { state.mode = LEN; }
        break;
      case LIT:
        if (left === 0) { break inf_leave; }
        output[put++] = state.length;
        left--;
        state.mode = LEN;
        break;
      case CHECK:
        if (state.wrap) {
          //=== NEEDBITS(32);
          while (bits < 32) {
            if (have === 0) { break inf_leave; }
            have--;
            // Use '|' instead of '+' to make sure that result is signed
            hold |= input[next++] << bits;
            bits += 8;
          }
          //===//
          _out -= left;
          strm.total_out += _out;
          state.total += _out;
          if (_out) {
            strm.adler = state.check =
                /*UPDATE(state.check, put - _out, _out);*/
                (state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out));

          }
          _out = left;
          // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too
          if ((state.flags ? hold : zswap32(hold)) !== state.check) {
            strm.msg = 'incorrect data check';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          //Tracev((stderr, "inflate:   check matches trailer\n"));
        }
        state.mode = LENGTH;
        /* falls through */
      case LENGTH:
        if (state.wrap && state.flags) {
          //=== NEEDBITS(32);
          while (bits < 32) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          if (hold !== (state.total & 0xffffffff)) {
            strm.msg = 'incorrect length check';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          //Tracev((stderr, "inflate:   length matches trailer\n"));
        }
        state.mode = DONE;
        /* falls through */
      case DONE:
        ret = Z_STREAM_END;
        break inf_leave;
      case BAD:
        ret = Z_DATA_ERROR;
        break inf_leave;
      case MEM:
        return Z_MEM_ERROR;
      case SYNC:
        /* falls through */
      default:
        return Z_STREAM_ERROR;
    }
  }

  // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"

  /*
     Return from inflate(), updating the total counts and the check value.
     If there was no progress during the inflate() call, return a buffer
     error.  Call updatewindow() to create and/or update the window state.
     Note: a memory error from inflate() is non-recoverable.
   */

  //--- RESTORE() ---
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits;
  //---

  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&
                      (state.mode < CHECK || flush !== Z_FINISH))) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
      state.mode = MEM;
      return Z_MEM_ERROR;
    }
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap && _out) {
    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
      (state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out));
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) +
                    (state.mode === TYPE ? 128 : 0) +
                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if (((_in === 0 && _out === 0) || flush === Z_FINISH) && ret === Z_OK) {
    ret = Z_BUF_ERROR;
  }
  return ret;
}

function inflateEnd(strm) {

  if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {
    return Z_STREAM_ERROR;
  }

  var state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK;
}

function inflateGetHeader(strm, head) {
  var state;

  /* check state */
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;
  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR; }

  /* save header structure */
  state.head = head;
  head.done = false;
  return Z_OK;
}

function inflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;

  var state;
  var dictid;
  var ret;

  /* check state */
  if (!strm /* == Z_NULL */ || !strm.state /* == Z_NULL */) { return Z_STREAM_ERROR; }
  state = strm.state;

  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR;
  }

  /* check for correct dictionary identifier */
  if (state.mode === DICT) {
    dictid = 1; /* adler32(0, null, 0)*/
    /* dictid = adler32(dictid, dictionary, dictLength); */
    dictid = adler32(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR;
    }
  }
  /* copy dictionary to window using updatewindow(), which will amend the
   existing dictionary if appropriate */
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR;
  }
  state.havedict = 1;
  // Tracev((stderr, "inflate:   dictionary set\n"));
  return Z_OK;
}

exports.inflateReset = inflateReset;
exports.inflateReset2 = inflateReset2;
exports.inflateResetKeep = inflateResetKeep;
exports.inflateInit = inflateInit;
exports.inflateInit2 = inflateInit2;
exports.inflate = inflate;
exports.inflateEnd = inflateEnd;
exports.inflateGetHeader = inflateGetHeader;
exports.inflateSetDictionary = inflateSetDictionary;
exports.inflateInfo = 'pako inflate (from Nodeca project)';

/* Not implemented
exports.inflateCopy = inflateCopy;
exports.inflateGetDictionary = inflateGetDictionary;
exports.inflateMark = inflateMark;
exports.inflatePrime = inflatePrime;
exports.inflateSync = inflateSync;
exports.inflateSyncPoint = inflateSyncPoint;
exports.inflateUndermine = inflateUndermine;
*/

},{"../utils/common":3,"./adler32":5,"./crc32":7,"./inffast":10,"./inftrees":12}],12:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var utils = require('../utils/common');

var MAXBITS = 15;
var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
//var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);

var CODES = 0;
var LENS = 1;
var DISTS = 2;

var lbase = [ /* Length codes 257..285 base */
  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
];

var lext = [ /* Length codes 257..285 extra */
  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78
];

var dbase = [ /* Distance codes 0..29 base */
  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
  8193, 12289, 16385, 24577, 0, 0
];

var dext = [ /* Distance codes 0..29 extra */
  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
  28, 28, 29, 29, 64, 64
];

module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts)
{
  var bits = opts.bits;
      //here = opts.here; /* table entry for duplication */

  var len = 0;               /* a code's length in bits */
  var sym = 0;               /* index of code symbols */
  var min = 0, max = 0;          /* minimum and maximum code lengths */
  var root = 0;              /* number of index bits for root table */
  var curr = 0;              /* number of index bits for current table */
  var drop = 0;              /* code bits to drop for sub-table */
  var left = 0;                   /* number of prefix codes available */
  var used = 0;              /* code entries in table used */
  var huff = 0;              /* Huffman code */
  var incr;              /* for incrementing code, index */
  var fill;              /* index for replicating entries */
  var low;               /* low bits for current root entry */
  var mask;              /* mask for low root bits */
  var next;             /* next available space in table */
  var base = null;     /* base value table to use */
  var base_index = 0;
//  var shoextra;    /* extra bits table to use */
  var end;                    /* use base and extra for symbol > end */
  var count = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */
  var offs = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */
  var extra = null;
  var extra_index = 0;

  var here_bits, here_op, here_val;

  /*
   Process a set of code lengths to create a canonical Huffman code.  The
   code lengths are lens[0..codes-1].  Each length corresponds to the
   symbols 0..codes-1.  The Huffman code is generated by first sorting the
   symbols by length from short to long, and retaining the symbol order
   for codes with equal lengths.  Then the code starts with all zero bits
   for the first code of the shortest length, and the codes are integer
   increments for the same length, and zeros are appended as the length
   increases.  For the deflate format, these bits are stored backwards
   from their more natural integer increment ordering, and so when the
   decoding tables are built in the large loop below, the integer codes
   are incremented backwards.

   This routine assumes, but does not check, that all of the entries in
   lens[] are in the range 0..MAXBITS.  The caller must assure this.
   1..MAXBITS is interpreted as that code length.  zero means that that
   symbol does not occur in this code.

   The codes are sorted by computing a count of codes for each length,
   creating from that a table of starting indices for each length in the
   sorted table, and then entering the symbols in order in the sorted
   table.  The sorted table is work[], with that space being provided by
   the caller.

   The length counts are used for other purposes as well, i.e. finding
   the minimum and maximum length codes, determining if there are any
   codes at all, checking for a valid set of lengths, and looking ahead
   at length counts to determine sub-table sizes when building the
   decoding tables.
   */

  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }

  /* bound code lengths, force root to be within code lengths */
  root = bits;
  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) { break; }
  }
  if (root > max) {
    root = max;
  }
  if (max === 0) {                     /* no symbols to code at all */
    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */
    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;
    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;


    //table.op[opts.table_index] = 64;
    //table.bits[opts.table_index] = 1;
    //table.val[opts.table_index++] = 0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;

    opts.bits = 1;
    return 0;     /* no symbols, but wait for decoding to report error */
  }
  for (min = 1; min < max; min++) {
    if (count[min] !== 0) { break; }
  }
  if (root < min) {
    root = min;
  }

  /* check for an over-subscribed or incomplete set of lengths */
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    }        /* over-subscribed */
  }
  if (left > 0 && (type === CODES || max !== 1)) {
    return -1;                      /* incomplete set */
  }

  /* generate offsets into symbol table for each length for sorting */
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }

  /* sort symbols by length, by symbol order within each length */
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }

  /*
   Create and fill in decoding tables.  In this loop, the table being
   filled is at next and has curr index bits.  The code being used is huff
   with length len.  That code is converted to an index by dropping drop
   bits off of the bottom.  For codes where len is less than drop + curr,
   those top drop + curr - len bits are incremented through all values to
   fill the table with replicated entries.

   root is the number of index bits for the root table.  When len exceeds
   root, sub-tables are created pointed to by the root entry with an index
   of the low root bits of huff.  This is saved in low to check for when a
   new sub-table should be started.  drop is zero when the root table is
   being filled, and drop is root when sub-tables are being filled.

   When a new sub-table is needed, it is necessary to look ahead in the
   code lengths to determine what size sub-table is needed.  The length
   counts are used for this, and so count[] is decremented as codes are
   entered in the tables.

   used keeps track of how many table entries have been allocated from the
   provided *table space.  It is checked for LENS and DIST tables against
   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
   the initial root table size constants.  See the comments in inftrees.h
   for more information.

   sym increments through all symbols, and the loop terminates when
   all codes of length max, i.e. all codes, have been processed.  This
   routine permits incomplete codes, so another loop after this one fills
   in the rest of the decoding tables with invalid code markers.
   */

  /* set up for code type */
  // poor man optimization - use if-else instead of switch,
  // to avoid deopts in old v8
  if (type === CODES) {
    base = extra = work;    /* dummy value--not used */
    end = 19;

  } else if (type === LENS) {
    base = lbase;
    base_index -= 257;
    extra = lext;
    extra_index -= 257;
    end = 256;

  } else {                    /* DISTS */
    base = dbase;
    extra = dext;
    end = -1;
  }

  /* initialize opts for loop */
  huff = 0;                   /* starting code */
  sym = 0;                    /* starting code symbol */
  len = min;                  /* starting code length */
  next = table_index;              /* current table to fill in */
  curr = root;                /* current table index bits */
  drop = 0;                   /* current bits to drop from code for index */
  low = -1;                   /* trigger new sub-table when len > root */
  used = 1 << root;          /* use root table entries */
  mask = used - 1;            /* mask for comparing low */

  /* check available table space */
  if ((type === LENS && used > ENOUGH_LENS) ||
    (type === DISTS && used > ENOUGH_DISTS)) {
    return 1;
  }

  /* process all codes and make table entries */
  for (;;) {
    /* create table entry */
    here_bits = len - drop;
    if (work[sym] < end) {
      here_op = 0;
      here_val = work[sym];
    }
    else if (work[sym] > end) {
      here_op = extra[extra_index + work[sym]];
      here_val = base[base_index + work[sym]];
    }
    else {
      here_op = 32 + 64;         /* end of block */
      here_val = 0;
    }

    /* replicate for those indices with low len bits equal to huff */
    incr = 1 << (len - drop);
    fill = 1 << curr;
    min = fill;                 /* save offset to next table */
    do {
      fill -= incr;
      table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;
    } while (fill !== 0);

    /* backwards increment the len-bit code huff */
    incr = 1 << (len - 1);
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }

    /* go to next symbol, update count, len */
    sym++;
    if (--count[len] === 0) {
      if (len === max) { break; }
      len = lens[lens_index + work[sym]];
    }

    /* create new sub-table if needed */
    if (len > root && (huff & mask) !== low) {
      /* if first time, transition to sub-tables */
      if (drop === 0) {
        drop = root;
      }

      /* increment past last table */
      next += min;            /* here min is 1 << curr */

      /* determine length of next table */
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max) {
        left -= count[curr + drop];
        if (left <= 0) { break; }
        curr++;
        left <<= 1;
      }

      /* check for enough space */
      used += 1 << curr;
      if ((type === LENS && used > ENOUGH_LENS) ||
        (type === DISTS && used > ENOUGH_DISTS)) {
        return 1;
      }

      /* point entry in root table to sub-table */
      low = huff & mask;
      /*table.op[low] = curr;
      table.bits[low] = root;
      table.val[low] = next - opts.table_index;*/
      table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;
    }
  }

  /* fill in remaining table entry if code is incomplete (guaranteed to have
   at most one remaining entry, since if the code is incomplete, the
   maximum code length that was allowed to get this far is one bit) */
  if (huff !== 0) {
    //table.op[next + huff] = 64;            /* invalid code marker */
    //table.bits[next + huff] = len - drop;
    //table.val[next + huff] = 0;
    table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;
  }

  /* set return parameters */
  //opts.table_index += used;
  opts.bits = root;
  return 0;
};

},{"../utils/common":3}],13:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

module.exports = {
  2:      'need dictionary',     /* Z_NEED_DICT       2  */
  1:      'stream end',          /* Z_STREAM_END      1  */
  0:      '',                    /* Z_OK              0  */
  '-1':   'file error',          /* Z_ERRNO         (-1) */
  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */
  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */
  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */
  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */
  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */
};

},{}],14:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var utils = require('../utils/common');

/* Public constants ==========================================================*/
/* ===========================================================================*/


//var Z_FILTERED          = 1;
//var Z_HUFFMAN_ONLY      = 2;
//var Z_RLE               = 3;
var Z_FIXED               = 4;
//var Z_DEFAULT_STRATEGY  = 0;

/* Possible values of the data_type field (though see inflate()) */
var Z_BINARY              = 0;
var Z_TEXT                = 1;
//var Z_ASCII             = 1; // = Z_TEXT
var Z_UNKNOWN             = 2;

/*============================================================================*/


function zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }

// From zutil.h

var STORED_BLOCK = 0;
var STATIC_TREES = 1;
var DYN_TREES    = 2;
/* The three kinds of block type */

var MIN_MATCH    = 3;
var MAX_MATCH    = 258;
/* The minimum and maximum match lengths */

// From deflate.h
/* ===========================================================================
 * Internal compression state.
 */

var LENGTH_CODES  = 29;
/* number of length codes, not counting the special END_BLOCK code */

var LITERALS      = 256;
/* number of literal bytes 0..255 */

var L_CODES       = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */

var D_CODES       = 30;
/* number of distance codes */

var BL_CODES      = 19;
/* number of codes used to transfer the bit lengths */

var HEAP_SIZE     = 2 * L_CODES + 1;
/* maximum heap size */

var MAX_BITS      = 15;
/* All codes must not exceed MAX_BITS bits */

var Buf_size      = 16;
/* size of bit buffer in bi_buf */


/* ===========================================================================
 * Constants
 */

var MAX_BL_BITS = 7;
/* Bit length codes must not exceed MAX_BL_BITS bits */

var END_BLOCK   = 256;
/* end of block literal code */

var REP_3_6     = 16;
/* repeat previous bit length 3-6 times (2 bits of repeat count) */

var REPZ_3_10   = 17;
/* repeat a zero length 3-10 times  (3 bits of repeat count) */

var REPZ_11_138 = 18;
/* repeat a zero length 11-138 times  (7 bits of repeat count) */

/* eslint-disable comma-spacing,array-bracket-spacing */
var extra_lbits =   /* extra bits for each length code */
  [0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0];

var extra_dbits =   /* extra bits for each distance code */
  [0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];

var extra_blbits =  /* extra bits for each bit length code */
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7];

var bl_order =
  [16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];
/* eslint-enable comma-spacing,array-bracket-spacing */

/* The lengths of the bit length codes are sent in order of decreasing
 * probability, to avoid transmitting the lengths for unused bit length codes.
 */

/* ===========================================================================
 * Local data. These are initialized only once.
 */

// We pre-fill arrays with 0 to avoid uninitialized gaps

var DIST_CODE_LEN = 512; /* see definition of array dist_code below */

// !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1
var static_ltree  = new Array((L_CODES + 2) * 2);
zero(static_ltree);
/* The static literal tree. Since the bit lengths are imposed, there is no
 * need for the L_CODES extra codes used during heap construction. However
 * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
 * below).
 */

var static_dtree  = new Array(D_CODES * 2);
zero(static_dtree);
/* The static distance tree. (Actually a trivial tree since all codes use
 * 5 bits.)
 */

var _dist_code    = new Array(DIST_CODE_LEN);
zero(_dist_code);
/* Distance codes. The first 256 values correspond to the distances
 * 3 .. 258, the last 256 values correspond to the top 8 bits of
 * the 15 bit distances.
 */

var _length_code  = new Array(MAX_MATCH - MIN_MATCH + 1);
zero(_length_code);
/* length code for each normalized match length (0 == MIN_MATCH) */

var base_length   = new Array(LENGTH_CODES);
zero(base_length);
/* First normalized length for each code (0 = MIN_MATCH) */

var base_dist     = new Array(D_CODES);
zero(base_dist);
/* First normalized distance for each code (0 = distance of 1) */


function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {

  this.static_tree  = static_tree;  /* static tree or NULL */
  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */
  this.extra_base   = extra_base;   /* base index for extra_bits */
  this.elems        = elems;        /* max number of elements in the tree */
  this.max_length   = max_length;   /* max bit length for the codes */

  // show if `static_tree` has data or dummy - needed for monomorphic objects
  this.has_stree    = static_tree && static_tree.length;
}


var static_l_desc;
var static_d_desc;
var static_bl_desc;


function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;     /* the dynamic tree */
  this.max_code = 0;            /* largest code with non zero frequency */
  this.stat_desc = stat_desc;   /* the corresponding static tree */
}



function d_code(dist) {
  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
}


/* ===========================================================================
 * Output a short LSB first on the stream.
 * IN assertion: there is enough room in pendingBuf.
 */
function put_short(s, w) {
//    put_byte(s, (uch)((w) & 0xff));
//    put_byte(s, (uch)((ush)(w) >> 8));
  s.pending_buf[s.pending++] = (w) & 0xff;
  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;
}


/* ===========================================================================
 * Send a value on a given number of bits.
 * IN assertion: length <= 16 and value fits in length bits.
 */
function send_bits(s, value, length) {
  if (s.bi_valid > (Buf_size - length)) {
    s.bi_buf |= (value << s.bi_valid) & 0xffff;
    put_short(s, s.bi_buf);
    s.bi_buf = value >> (Buf_size - s.bi_valid);
    s.bi_valid += length - Buf_size;
  } else {
    s.bi_buf |= (value << s.bi_valid) & 0xffff;
    s.bi_valid += length;
  }
}


function send_code(s, c, tree) {
  send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);
}


/* ===========================================================================
 * Reverse the first len bits of a code, using straightforward code (a faster
 * method would use a table)
 * IN assertion: 1 <= len <= 15
 */
function bi_reverse(code, len) {
  var res = 0;
  do {
    res |= code & 1;
    code >>>= 1;
    res <<= 1;
  } while (--len > 0);
  return res >>> 1;
}


/* ===========================================================================
 * Flush the bit buffer, keeping at most 7 bits in it.
 */
function bi_flush(s) {
  if (s.bi_valid === 16) {
    put_short(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;

  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 0xff;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
}


/* ===========================================================================
 * Compute the optimal bit lengths for a tree and update the total bit length
 * for the current block.
 * IN assertion: the fields freq and dad are set, heap[heap_max] and
 *    above are the tree nodes sorted by increasing frequency.
 * OUT assertions: the field len is set to the optimal bit length, the
 *     array bl_count contains the frequencies for each bit length.
 *     The length opt_len is updated; static_len is also updated if stree is
 *     not null.
 */
function gen_bitlen(s, desc)
//    deflate_state *s;
//    tree_desc *desc;    /* the tree descriptor */
{
  var tree            = desc.dyn_tree;
  var max_code        = desc.max_code;
  var stree           = desc.stat_desc.static_tree;
  var has_stree       = desc.stat_desc.has_stree;
  var extra           = desc.stat_desc.extra_bits;
  var base            = desc.stat_desc.extra_base;
  var max_length      = desc.stat_desc.max_length;
  var h;              /* heap index */
  var n, m;           /* iterate over the tree elements */
  var bits;           /* bit length */
  var xbits;          /* extra bits */
  var f;              /* frequency */
  var overflow = 0;   /* number of elements with bit length too large */

  for (bits = 0; bits <= MAX_BITS; bits++) {
    s.bl_count[bits] = 0;
  }

  /* In a first pass, compute the optimal bit lengths (which may
   * overflow in the case of the bit length tree).
   */
  tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */

  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n * 2 + 1]/*.Len*/ = bits;
    /* We overwrite tree[n].Dad which is no longer needed */

    if (n > max_code) { continue; } /* not a leaf node */

    s.bl_count[bits]++;
    xbits = 0;
    if (n >= base) {
      xbits = extra[n - base];
    }
    f = tree[n * 2]/*.Freq*/;
    s.opt_len += f * (bits + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);
    }
  }
  if (overflow === 0) { return; }

  // Trace((stderr,"\nbit length overflow\n"));
  /* This happens for example on obj2 and pic of the Calgary corpus */

  /* Find the first bit length which could increase: */
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) { bits--; }
    s.bl_count[bits]--;      /* move one leaf down the tree */
    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */
    s.bl_count[max_length]--;
    /* The brother of the overflow item also moves one step up,
     * but this does not affect bl_count[max_length]
     */
    overflow -= 2;
  } while (overflow > 0);

  /* Now recompute all bit lengths, scanning in increasing frequency.
   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
   * lengths instead of fixing only the wrong ones. This idea is taken
   * from 'ar' written by Haruhiko Okumura.)
   */
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];
    while (n !== 0) {
      m = s.heap[--h];
      if (m > max_code) { continue; }
      if (tree[m * 2 + 1]/*.Len*/ !== bits) {
        // Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
        s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;
        tree[m * 2 + 1]/*.Len*/ = bits;
      }
      n--;
    }
  }
}


/* ===========================================================================
 * Generate the codes for a given tree and bit counts (which need not be
 * optimal).
 * IN assertion: the array bl_count contains the bit length statistics for
 * the given tree and the field len is set for all tree elements.
 * OUT assertion: the field code is set for all tree elements of non
 *     zero code length.
 */
function gen_codes(tree, max_code, bl_count)
//    ct_data *tree;             /* the tree to decorate */
//    int max_code;              /* largest code with non zero frequency */
//    ushf *bl_count;            /* number of codes at each bit length */
{
  var next_code = new Array(MAX_BITS + 1); /* next code value for each bit length */
  var code = 0;              /* running code value */
  var bits;                  /* bit index */
  var n;                     /* code index */

  /* The distribution counts are first used to generate the code values
   * without bit reversal.
   */
  for (bits = 1; bits <= MAX_BITS; bits++) {
    next_code[bits] = code = (code + bl_count[bits - 1]) << 1;
  }
  /* Check that the bit counts in bl_count are consistent. The last code
   * must be all ones.
   */
  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
  //        "inconsistent bit counts");
  //Tracev((stderr,"\ngen_codes: max_code %d ", max_code));

  for (n = 0;  n <= max_code; n++) {
    var len = tree[n * 2 + 1]/*.Len*/;
    if (len === 0) { continue; }
    /* Now reverse the bits */
    tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);

    //Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
  }
}


/* ===========================================================================
 * Initialize the various 'constant' tables.
 */
function tr_static_init() {
  var n;        /* iterates over tree elements */
  var bits;     /* bit counter */
  var length;   /* length value */
  var code;     /* code value */
  var dist;     /* distance index */
  var bl_count = new Array(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */

  // do check in _tr_init()
  //if (static_init_done) return;

  /* For some embedded targets, global variables are not initialized: */
/*#ifdef NO_INIT_GLOBAL_POINTERS
  static_l_desc.static_tree = static_ltree;
  static_l_desc.extra_bits = extra_lbits;
  static_d_desc.static_tree = static_dtree;
  static_d_desc.extra_bits = extra_dbits;
  static_bl_desc.extra_bits = extra_blbits;
#endif*/

  /* Initialize the mapping length (0..255) -> length code (0..28) */
  length = 0;
  for (code = 0; code < LENGTH_CODES - 1; code++) {
    base_length[code] = length;
    for (n = 0; n < (1 << extra_lbits[code]); n++) {
      _length_code[length++] = code;
    }
  }
  //Assert (length == 256, "tr_static_init: length != 256");
  /* Note that the length 255 (match length 258) can be represented
   * in two different ways: code 284 + 5 bits or code 285, so we
   * overwrite length_code[255] to use the best encoding:
   */
  _length_code[length - 1] = code;

  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
  dist = 0;
  for (code = 0; code < 16; code++) {
    base_dist[code] = dist;
    for (n = 0; n < (1 << extra_dbits[code]); n++) {
      _dist_code[dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: dist != 256");
  dist >>= 7; /* from now on, all distances are divided by 128 */
  for (; code < D_CODES; code++) {
    base_dist[code] = dist << 7;
    for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {
      _dist_code[256 + dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: 256+dist != 512");

  /* Construct the codes of the static literal tree */
  for (bits = 0; bits <= MAX_BITS; bits++) {
    bl_count[bits] = 0;
  }

  n = 0;
  while (n <= 143) {
    static_ltree[n * 2 + 1]/*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  while (n <= 255) {
    static_ltree[n * 2 + 1]/*.Len*/ = 9;
    n++;
    bl_count[9]++;
  }
  while (n <= 279) {
    static_ltree[n * 2 + 1]/*.Len*/ = 7;
    n++;
    bl_count[7]++;
  }
  while (n <= 287) {
    static_ltree[n * 2 + 1]/*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  /* Codes 286 and 287 do not exist, but we must include them in the
   * tree construction to get a canonical Huffman tree (longest code
   * all ones)
   */
  gen_codes(static_ltree, L_CODES + 1, bl_count);

  /* The static distance tree is trivial: */
  for (n = 0; n < D_CODES; n++) {
    static_dtree[n * 2 + 1]/*.Len*/ = 5;
    static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);
  }

  // Now data ready and we can init static trees
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES, MAX_BL_BITS);

  //static_init_done = true;
}


/* ===========================================================================
 * Initialize a new block.
 */
function init_block(s) {
  var n; /* iterates over tree elements */

  /* Initialize the trees. */
  for (n = 0; n < L_CODES;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }
  for (n = 0; n < D_CODES;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }
  for (n = 0; n < BL_CODES; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }

  s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;
  s.opt_len = s.static_len = 0;
  s.last_lit = s.matches = 0;
}


/* ===========================================================================
 * Flush the bit buffer and align the output on a byte boundary
 */
function bi_windup(s)
{
  if (s.bi_valid > 8) {
    put_short(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    //put_byte(s, (Byte)s->bi_buf);
    s.pending_buf[s.pending++] = s.bi_buf;
  }
  s.bi_buf = 0;
  s.bi_valid = 0;
}

/* ===========================================================================
 * Copy a stored block, storing first the length and its
 * one's complement if requested.
 */
function copy_block(s, buf, len, header)
//DeflateState *s;
//charf    *buf;    /* the input data */
//unsigned len;     /* its length */
//int      header;  /* true if block header must be written */
{
  bi_windup(s);        /* align on byte boundary */

  if (header) {
    put_short(s, len);
    put_short(s, ~len);
  }
//  while (len--) {
//    put_byte(s, *buf++);
//  }
  utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
  s.pending += len;
}

/* ===========================================================================
 * Compares to subtrees, using the tree depth as tie breaker when
 * the subtrees have equal frequency. This minimizes the worst case length.
 */
function smaller(tree, n, m, depth) {
  var _n2 = n * 2;
  var _m2 = m * 2;
  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||
         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));
}

/* ===========================================================================
 * Restore the heap property by moving down the tree starting at node k,
 * exchanging a node with the smallest of its two sons if necessary, stopping
 * when the heap property is re-established (each father smaller than its
 * two sons).
 */
function pqdownheap(s, tree, k)
//    deflate_state *s;
//    ct_data *tree;  /* the tree to restore */
//    int k;               /* node to move down */
{
  var v = s.heap[k];
  var j = k << 1;  /* left son of k */
  while (j <= s.heap_len) {
    /* Set j to the smallest of the two sons: */
    if (j < s.heap_len &&
      smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
      j++;
    }
    /* Exit if v is smaller than both sons */
    if (smaller(tree, v, s.heap[j], s.depth)) { break; }

    /* Exchange v with the smallest son */
    s.heap[k] = s.heap[j];
    k = j;

    /* And continue down the tree, setting j to the left son of k */
    j <<= 1;
  }
  s.heap[k] = v;
}


// inlined manually
// var SMALLEST = 1;

/* ===========================================================================
 * Send the block data compressed using the given Huffman trees
 */
function compress_block(s, ltree, dtree)
//    deflate_state *s;
//    const ct_data *ltree; /* literal tree */
//    const ct_data *dtree; /* distance tree */
{
  var dist;           /* distance of matched string */
  var lc;             /* match length or unmatched char (if dist == 0) */
  var lx = 0;         /* running index in l_buf */
  var code;           /* the code to send */
  var extra;          /* number of extra bits to send */

  if (s.last_lit !== 0) {
    do {
      dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);
      lc = s.pending_buf[s.l_buf + lx];
      lx++;

      if (dist === 0) {
        send_code(s, lc, ltree); /* send a literal byte */
        //Tracecv(isgraph(lc), (stderr," '%c' ", lc));
      } else {
        /* Here, lc is the match length - MIN_MATCH */
        code = _length_code[lc];
        send_code(s, code + LITERALS + 1, ltree); /* send the length code */
        extra = extra_lbits[code];
        if (extra !== 0) {
          lc -= base_length[code];
          send_bits(s, lc, extra);       /* send the extra length bits */
        }
        dist--; /* dist is now the match distance - 1 */
        code = d_code(dist);
        //Assert (code < D_CODES, "bad d_code");

        send_code(s, code, dtree);       /* send the distance code */
        extra = extra_dbits[code];
        if (extra !== 0) {
          dist -= base_dist[code];
          send_bits(s, dist, extra);   /* send the extra distance bits */
        }
      } /* literal or match pair ? */

      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,
      //       "pendingBuf overflow");

    } while (lx < s.last_lit);
  }

  send_code(s, END_BLOCK, ltree);
}


/* ===========================================================================
 * Construct one Huffman tree and assigns the code bit strings and lengths.
 * Update the total bit length for the current block.
 * IN assertion: the field freq is set for all tree elements.
 * OUT assertions: the fields len and code are set to the optimal bit length
 *     and corresponding code. The length opt_len is updated; static_len is
 *     also updated if stree is not null. The field max_code is set.
 */
function build_tree(s, desc)
//    deflate_state *s;
//    tree_desc *desc; /* the tree descriptor */
{
  var tree     = desc.dyn_tree;
  var stree    = desc.stat_desc.static_tree;
  var has_stree = desc.stat_desc.has_stree;
  var elems    = desc.stat_desc.elems;
  var n, m;          /* iterate over heap elements */
  var max_code = -1; /* largest code with non zero frequency */
  var node;          /* new node being created */

  /* Construct the initial heap, with least frequent element in
   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
   * heap[0] is not used.
   */
  s.heap_len = 0;
  s.heap_max = HEAP_SIZE;

  for (n = 0; n < elems; n++) {
    if (tree[n * 2]/*.Freq*/ !== 0) {
      s.heap[++s.heap_len] = max_code = n;
      s.depth[n] = 0;

    } else {
      tree[n * 2 + 1]/*.Len*/ = 0;
    }
  }

  /* The pkzip format requires that at least one distance code exists,
   * and that at least one bit should be sent even if there is only one
   * possible code. So to avoid special checks later on we force at least
   * two codes of non zero frequency.
   */
  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);
    tree[node * 2]/*.Freq*/ = 1;
    s.depth[node] = 0;
    s.opt_len--;

    if (has_stree) {
      s.static_len -= stree[node * 2 + 1]/*.Len*/;
    }
    /* node is 0 or 1 so it does not have extra bits */
  }
  desc.max_code = max_code;

  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
   * establish sub-heaps of increasing lengths:
   */
  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }

  /* Construct the Huffman tree by repeatedly combining the least two
   * frequent nodes.
   */
  node = elems;              /* next internal node of the tree */
  do {
    //pqremove(s, tree, n);  /* n = node of least frequency */
    /*** pqremove ***/
    n = s.heap[1/*SMALLEST*/];
    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];
    pqdownheap(s, tree, 1/*SMALLEST*/);
    /***/

    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */

    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */
    s.heap[--s.heap_max] = m;

    /* Create a new node father of n and m */
    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;
    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
    tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;

    /* and insert the new node in the heap */
    s.heap[1/*SMALLEST*/] = node++;
    pqdownheap(s, tree, 1/*SMALLEST*/);

  } while (s.heap_len >= 2);

  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];

  /* At this point, the fields freq and dad are set. We can now
   * generate the bit lengths.
   */
  gen_bitlen(s, desc);

  /* The field len is now set, we can generate the bit codes */
  gen_codes(tree, max_code, s.bl_count);
}


/* ===========================================================================
 * Scan a literal or distance tree to determine the frequencies of the codes
 * in the bit length tree.
 */
function scan_tree(s, tree, max_code)
//    deflate_state *s;
//    ct_data *tree;   /* the tree to be scanned */
//    int max_code;    /* and its largest code of non zero frequency */
{
  var n;                     /* iterates over all tree elements */
  var prevlen = -1;          /* last emitted length */
  var curlen;                /* length of current code */

  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

  var count = 0;             /* repeat count of the current code */
  var max_count = 7;         /* max repeat count */
  var min_count = 4;         /* min repeat count */

  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;

    } else if (count < min_count) {
      s.bl_tree[curlen * 2]/*.Freq*/ += count;

    } else if (curlen !== 0) {

      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }
      s.bl_tree[REP_3_6 * 2]/*.Freq*/++;

    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;

    } else {
      s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;
    }

    count = 0;
    prevlen = curlen;

    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;

    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;

    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}


/* ===========================================================================
 * Send a literal or distance tree in compressed form, using the codes in
 * bl_tree.
 */
function send_tree(s, tree, max_code)
//    deflate_state *s;
//    ct_data *tree; /* the tree to be scanned */
//    int max_code;       /* and its largest code of non zero frequency */
{
  var n;                     /* iterates over all tree elements */
  var prevlen = -1;          /* last emitted length */
  var curlen;                /* length of current code */

  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

  var count = 0;             /* repeat count of the current code */
  var max_count = 7;         /* max repeat count */
  var min_count = 4;         /* min repeat count */

  /* tree[max_code+1].Len = -1; */  /* guard already set */
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;

    } else if (count < min_count) {
      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);

    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s, curlen, s.bl_tree);
        count--;
      }
      //Assert(count >= 3 && count <= 6, " 3_6?");
      send_code(s, REP_3_6, s.bl_tree);
      send_bits(s, count - 3, 2);

    } else if (count <= 10) {
      send_code(s, REPZ_3_10, s.bl_tree);
      send_bits(s, count - 3, 3);

    } else {
      send_code(s, REPZ_11_138, s.bl_tree);
      send_bits(s, count - 11, 7);
    }

    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;

    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;

    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}


/* ===========================================================================
 * Construct the Huffman tree for the bit lengths and return the index in
 * bl_order of the last bit length code to send.
 */
function build_bl_tree(s) {
  var max_blindex;  /* index of last bit length code of non zero freq */

  /* Determine the bit length frequencies for literal and distance trees */
  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);

  /* Build the bit length tree: */
  build_tree(s, s.bl_desc);
  /* opt_len now includes the length of the tree representations, except
   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
   */

  /* Determine the number of bit length codes to send. The pkzip format
   * requires that at least 4 bit length codes be sent. (appnote.txt says
   * 3 but the actual value used is 4.)
   */
  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {
      break;
    }
  }
  /* Update opt_len to include the bit length tree and counts */
  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  //Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
  //        s->opt_len, s->static_len));

  return max_blindex;
}


/* ===========================================================================
 * Send the header for a block using dynamic Huffman trees: the counts, the
 * lengths of the bit length codes, the literal tree and the distance tree.
 * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
 */
function send_all_trees(s, lcodes, dcodes, blcodes)
//    deflate_state *s;
//    int lcodes, dcodes, blcodes; /* number of codes for each tree */
{
  var rank;                    /* index in bl_order */

  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
  //        "too many codes");
  //Tracev((stderr, "\nbl counts: "));
  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */
  send_bits(s, dcodes - 1,   5);
  send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */
  for (rank = 0; rank < blcodes; rank++) {
    //Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);
  }
  //Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */
  //Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */
  //Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
}


/* ===========================================================================
 * Check if the data type is TEXT or BINARY, using the following algorithm:
 * - TEXT if the two conditions below are satisfied:
 *    a) There are no non-portable control characters belonging to the
 *       "black list" (0..6, 14..25, 28..31).
 *    b) There is at least one printable character belonging to the
 *       "white list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
 * - BINARY otherwise.
 * - The following partially-portable control characters form a
 *   "gray list" that is ignored in this detection algorithm:
 *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
 * IN assertion: the fields Freq of dyn_ltree are set.
 */
function detect_data_type(s) {
  /* black_mask is the bit mask of black-listed bytes
   * set bits 0..6, 14..25, and 28..31
   * 0xf3ffc07f = binary 11110011111111111100000001111111
   */
  var black_mask = 0xf3ffc07f;
  var n;

  /* Check for non-textual ("black-listed") bytes. */
  for (n = 0; n <= 31; n++, black_mask >>>= 1) {
    if ((black_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {
      return Z_BINARY;
    }
  }

  /* Check for textual ("white-listed") bytes. */
  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||
      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {
    return Z_TEXT;
  }
  for (n = 32; n < LITERALS; n++) {
    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {
      return Z_TEXT;
    }
  }

  /* There are no "black-listed" or "white-listed" bytes:
   * this stream either is empty or has tolerated ("gray-listed") bytes only.
   */
  return Z_BINARY;
}


var static_init_done = false;

/* ===========================================================================
 * Initialize the tree data structures for a new zlib stream.
 */
function _tr_init(s)
{

  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }

  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);
  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);

  s.bi_buf = 0;
  s.bi_valid = 0;

  /* Initialize the first block of the first file: */
  init_block(s);
}


/* ===========================================================================
 * Send a stored block
 */
function _tr_stored_block(s, buf, stored_len, last)
//DeflateState *s;
//charf *buf;       /* input block */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */
  copy_block(s, buf, stored_len, true); /* with header */
}


/* ===========================================================================
 * Send one empty static block to give enough lookahead for inflate.
 * This takes 10 bits, of which 7 may remain in the bit buffer.
 */
function _tr_align(s) {
  send_bits(s, STATIC_TREES << 1, 3);
  send_code(s, END_BLOCK, static_ltree);
  bi_flush(s);
}


/* ===========================================================================
 * Determine the best encoding for the current block: dynamic trees, static
 * trees or store, and output the encoded block to the zip file.
 */
function _tr_flush_block(s, buf, stored_len, last)
//DeflateState *s;
//charf *buf;       /* input block, or NULL if too old */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  var opt_lenb, static_lenb;  /* opt_len and static_len in bytes */
  var max_blindex = 0;        /* index of last bit length code of non zero freq */

  /* Build the Huffman trees unless a stored block is forced */
  if (s.level > 0) {

    /* Check if the file is binary or text */
    if (s.strm.data_type === Z_UNKNOWN) {
      s.strm.data_type = detect_data_type(s);
    }

    /* Construct the literal and distance trees */
    build_tree(s, s.l_desc);
    // Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));

    build_tree(s, s.d_desc);
    // Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));
    /* At this point, opt_len and static_len are the total bit lengths of
     * the compressed block data, excluding the tree representations.
     */

    /* Build the bit length tree for the above two trees, and get the index
     * in bl_order of the last bit length code to send.
     */
    max_blindex = build_bl_tree(s);

    /* Determine the best encoding. Compute the block lengths in bytes. */
    opt_lenb = (s.opt_len + 3 + 7) >>> 3;
    static_lenb = (s.static_len + 3 + 7) >>> 3;

    // Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
    //        s->last_lit));

    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }

  } else {
    // Assert(buf != (char*)0, "lost buf");
    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
  }

  if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {
    /* 4: two words for the lengths */

    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
     * Otherwise we can't have processed more than WSIZE input bytes since
     * the last block flush, because compression would have been
     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
     * transform a block into a stored block.
     */
    _tr_stored_block(s, buf, stored_len, last);

  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {

    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
    compress_block(s, static_ltree, static_dtree);

  } else {
    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s, s.dyn_ltree, s.dyn_dtree);
  }
  // Assert (s->compressed_len == s->bits_sent, "bad compressed size");
  /* The above check is made mod 2^32, for files larger than 512 MB
   * and uLong implemented on 32 bits.
   */
  init_block(s);

  if (last) {
    bi_windup(s);
  }
  // Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
  //       s->compressed_len-7*last));
}

/* ===========================================================================
 * Save the match info and tally the frequency counts. Return true if
 * the current block must be flushed.
 */
function _tr_tally(s, dist, lc)
//    deflate_state *s;
//    unsigned dist;  /* distance of matched string */
//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
{
  //var out_length, in_length, dcode;

  s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist >>> 8) & 0xff;
  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;

  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;
  s.last_lit++;

  if (dist === 0) {
    /* lc is the unmatched char */
    s.dyn_ltree[lc * 2]/*.Freq*/++;
  } else {
    s.matches++;
    /* Here, lc is the match length - MIN_MATCH */
    dist--;             /* dist = match distance - 1 */
    //Assert((ush)dist < (ush)MAX_DIST(s) &&
    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
    //       (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");

    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]/*.Freq*/++;
    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;
  }

// (!) This block is disabled in zlib defaults,
// don't enable it for binary compatibility

//#ifdef TRUNCATE_BLOCK
//  /* Try to guess if it is profitable to stop the current block here */
//  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {
//    /* Compute an upper bound for the compressed length */
//    out_length = s.last_lit*8;
//    in_length = s.strstart - s.block_start;
//
//    for (dcode = 0; dcode < D_CODES; dcode++) {
//      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);
//    }
//    out_length >>>= 3;
//    //Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
//    //       s->last_lit, in_length, out_length,
//    //       100L - out_length*100L/in_length));
//    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {
//      return true;
//    }
//  }
//#endif

  return (s.last_lit === s.lit_bufsize - 1);
  /* We avoid equality with lit_bufsize because of wraparound at 64K
   * on 16 bit machines and because stored blocks are restricted to
   * 64K-1 bytes.
   */
}

exports._tr_init  = _tr_init;
exports._tr_stored_block = _tr_stored_block;
exports._tr_flush_block  = _tr_flush_block;
exports._tr_tally = _tr_tally;
exports._tr_align = _tr_align;

},{"../utils/common":3}],15:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function ZStream() {
  /* next input byte */
  this.input = null; // JS specific, because we have no pointers
  this.next_in = 0;
  /* number of bytes available at input */
  this.avail_in = 0;
  /* total number of input bytes read so far */
  this.total_in = 0;
  /* next output byte should be put there */
  this.output = null; // JS specific, because we have no pointers
  this.next_out = 0;
  /* remaining free space at output */
  this.avail_out = 0;
  /* total number of bytes output so far */
  this.total_out = 0;
  /* last error message, NULL if no error */
  this.msg = ''/*Z_NULL*/;
  /* not visible by applications */
  this.state = null;
  /* best guess about the data type: binary or text */
  this.data_type = 2/*Z_UNKNOWN*/;
  /* adler32 value of the uncompressed data */
  this.adler = 0;
}

module.exports = ZStream;

},{}],"/":[function(require,module,exports){
// Top level file is just a mixin of submodules & constants
'use strict';

var assign    = require('./lib/utils/common').assign;

var deflate   = require('./lib/deflate');
var inflate   = require('./lib/inflate');
var constants = require('./lib/zlib/constants');

var pako = {};

assign(pako, deflate, inflate, constants);

module.exports = pako;

},{"./lib/deflate":1,"./lib/inflate":2,"./lib/utils/common":3,"./lib/zlib/constants":6}]},{},[])("/")
});










function Gzip_Encrypt(text){
var Gzip = pako.gzip(decodeURI(text), { to: '' });
return Gzip;
}

function Gzip_Decrypt(text){
var array= text.split(",") 
    var data        = pako.inflate(array);  
return data;
}Accept: */*
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN
User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.198 Safari/537.36
Tab	9
NewLine	10
excl	33
quot	34
num	35
dollar	36
percnt	37
amp	38
apos	39
lpar	40
rpar	41
ast	42
plus	43
comma	44
period	46
sol	47
colon	58
semi	59
lt	60
equals	61
gt	62
quest	63
commat	64
lsqb	91
bsol	92
rsqb	93
Hat	94
lowbar	95
grave	96
lcub	123
verbar	124
rcub	125
nbsp	160
iexcl	161
cent	162
pound	163
curren	164
yen	165
brvbar	166
sect	167
Dot	168
copy	169
ordf	170
laquo	171
not	172
shy	173
reg	174
macr	175
deg	176
plusmn	177
sup2	178
sup3	179
acute	180
micro	181
para	182
middot	183
cedil	184
sup1	185
ordm	186
raquo	187
frac14	188
frac12	189
frac34	190
iquest	191
Agrave	192
Aacute	193
Acirc	194
Atilde	195
Auml	196
Aring	197
AElig	198
Ccedil	199
Egrave	200
Eacute	201
Ecirc	202
Euml	203
Igrave	204
Iacute	205
Icirc	206
Iuml	207
ETH	208
Ntilde	209
Ograve	210
Oacute	211
Ocirc	212
Otilde	213
Ouml	214
times	215
Oslash	216
Ugrave	217
Uacute	218
Ucirc	219
Uuml	220
Yacute	221
THORN	222
szlig	223
agrave	224
aacute	225
acirc	226
atilde	227
auml	228
aring	229
aelig	230
ccedil	231
egrave	232
eacute	233
ecirc	234
euml	235
igrave	236
iacute	237
icirc	238
iuml	239
eth	240
ntilde	241
ograve	242
oacute	243
ocirc	244
otilde	245
ouml	246
divide	247
oslash	248
ugrave	249
uacute	250
ucirc	251
uuml	252
yacute	253
thorn	254
yuml	255
Amacr	256
amacr	257
Abreve	258
abreve	259
Aogon	260
aogon	261
Cacute	262
cacute	263
Ccirc	264
ccirc	265
Cdot	266
cdot	267
Ccaron	268
ccaron	269
Dcaron	270
dcaron	271
Dstrok	272
dstrok	273
Emacr	274
emacr	275
Edot	278
edot	279
Eogon	280
eogon	281
Ecaron	282
ecaron	283
Gcirc	284
gcirc	285
Gbreve	286
gbreve	287
Gdot	288
gdot	289
Gcedil	290
Hcirc	292
hcirc	293
Hstrok	294
hstrok	295
Itilde	296
itilde	297
Imacr	298
imacr	299
Iogon	302
iogon	303
Idot	304
imath	305
IJlig	306
ijlig	307
Jcirc	308
jcirc	309
Kcedil	310
kcedil	311
kgreen	312
Lacute	313
lacute	314
Lcedil	315
lcedil	316
Lcaron	317
lcaron	318
Lmidot	319
lmidot	320
Lstrok	321
lstrok	322
Nacute	323
nacute	324
Ncedil	325
ncedil	326
Ncaron	327
ncaron	328
napos	329
ENG	330
eng	331
Omacr	332
omacr	333
Odblac	336
odblac	337
OElig	338
oelig	339
Racute	340
racute	341
Rcedil	342
rcedil	343
Rcaron	344
rcaron	345
Sacute	346
sacute	347
Scirc	348
scirc	349
Scedil	350
scedil	351
Scaron	352
scaron	353
Tcedil	354
tcedil	355
Tcaron	356
tcaron	357
Tstrok	358
tstrok	359
Utilde	360
utilde	361
Umacr	362
umacr	363
Ubreve	364
ubreve	365
Uring	366
uring	367
Udblac	368
udblac	369
Uogon	370
uogon	371
Wcirc	372
wcirc	373
Ycirc	374
ycirc	375
Yuml	376
Zacute	377
zacute	378
Zdot	379
zdot	380
Zcaron	381
zcaron	382
fnof	402
imped	437
gacute	501
jmath	567
circ	710
caron	711
breve	728
dot	729
ring	730
ogon	731
tilde	732
dblac	733
DownBreve	785
UnderBar	818
Alpha	913
Beta	914
Gamma	915
Delta	916
Epsilon	917
Zeta	918
Eta	919
Theta	920
Iota	921
Kappa	922
Lambda	923
Mu	924
Nu	925
Xi	926
Omicron	927
Pi	928
Rho	929
Sigma	931
Tau	932
Upsilon	933
Phi	934
Chi	935
Psi	936
Omega	937
alpha	945
beta	946
gamma	947
delta	948
epsiv	949
zeta	950
eta	951
theta	952
iota	953
kappa	954
lambda	955
mu	956
nu	957
xi	958
omicron	959
pi	960
rho	961
sigmav	962
sigma	963
tau	964
upsi	965
phi	966
chi	967
psi	968
omega	969
thetav	977
Upsi	978
straightphi	981
piv	982
Gammad	988
gammad	989
kappav	1008
rhov	1009
epsi	1013
bepsi	1014
IOcy	1025
DJcy	1026
GJcy	1027
Jukcy	1028
DScy	1029
Iukcy	1030
YIcy	1031
Jsercy	1032
LJcy	1033
NJcy	1034
TSHcy	1035
KJcy	1036
Ubrcy	1038
DZcy	1039
Acy	1040
Bcy	1041
Vcy	1042
Gcy	1043
Dcy	1044
IEcy	1045
ZHcy	1046
Zcy	1047
Icy	1048
Jcy	1049
Kcy	1050
Lcy	1051
Mcy	1052
Ncy	1053
Ocy	1054
Pcy	1055
Rcy	1056
Scy	1057
Tcy	1058
Ucy	1059
Fcy	1060
KHcy	1061
TScy	1062
CHcy	1063
SHcy	1064
SHCHcy	1065
HARDcy	1066
Ycy	1067
SOFTcy	1068
Ecy	1069
YUcy	1070
YAcy	1071
acy	1072
bcy	1073
vcy	1074
gcy	1075
dcy	1076
iecy	1077
zhcy	1078
zcy	1079
icy	1080
jcy	1081
kcy	1082
lcy	1083
mcy	1084
ncy	1085
ocy	1086
pcy	1087
rcy	1088
scy	1089
tcy	1090
ucy	1091
fcy	1092
khcy	1093
tscy	1094
chcy	1095
shcy	1096
shchcy	1097
hardcy	1098
ycy	1099
softcy	1100
ecy	1101
yucy	1102
yacy	1103
iocy	1105
djcy	1106
gjcy	1107
jukcy	1108
dscy	1109
iukcy	1110
yicy	1111
jsercy	1112
ljcy	1113
njcy	1114
tshcy	1115
kjcy	1116
ubrcy	1118
dzcy	1119
ensp	8194
emsp	8195
emsp13	8196
emsp14	8197
numsp	8199
puncsp	8200
thinsp	8201
hairsp	8202
ZeroWidthSpace	8203
zwnj	8204
zwj	8205
lrm	8206
rlm	8207
hyphen	8208
ndash	8211
mdash	8212
horbar	8213
Verbar	8214
lsquo	8216
rsquo	8217
lsquor	8218
ldquo	8220
rdquo	8221
ldquor	8222
dagger	8224
Dagger	8225
bull	8226
nldr	8229
hellip	8230
permil	8240
pertenk	8241
prime	8242
Prime	8243
tprime	8244
bprime	8245
lsaquo	8249
rsaquo	8250
oline	8254
caret	8257
hybull	8259
frasl	8260
bsemi	8271
qprime	8279
MediumSpace	8287
NoBreak	8288
ApplyFunction	8289
InvisibleTimes	8290
InvisibleComma	8291
euro	8364
tdot	8411
DotDot	8412
Copf	8450
incare	8453
gscr	8458
hamilt	8459
Hfr	8460
quaternions	8461
planckh	8462
planck	8463
Iscr	8464
image	8465
Lscr	8466
ell	8467
Nopf	8469
numero	8470
copysr	8471
weierp	8472
Popf	8473
rationals	8474
Rscr	8475
real	8476
reals	8477
rx	8478
trade	8482
integers	8484
ohm	8486
mho	8487
Zfr	8488
iiota	8489
angst	8491
bernou	8492
Cfr	8493
escr	8495
Escr	8496
Fscr	8497
phmmat	8499
order	8500
alefsym	8501
beth	8502
gimel	8503
daleth	8504
CapitalDifferentialD	8517
DifferentialD	8518
ExponentialE	8519
ImaginaryI	8520
frac13	8531
frac23	8532
frac15	8533
frac25	8534
frac35	8535
frac45	8536
frac16	8537
frac56	8538
frac18	8539
frac38	8540
frac58	8541
frac78	8542
larr	8592
uarr	8593
rarr	8594
darr	8595
harr	8596
varr	8597
nwarr	8598
nearr	8599
searr	8600
swarr	8601
nlarr	8602
nrarr	8603
rarrw	8605
Larr	8606
Uarr	8607
Rarr	8608
Darr	8609
larrtl	8610
rarrtl	8611
LeftTeeArrow	8612
UpTeeArrow	8613
map	8614
DownTeeArrow	8615
larrhk	8617
rarrhk	8618
larrlp	8619
rarrlp	8620
harrw	8621
nharr	8622
lsh	8624
rsh	8625
ldsh	8626
rdsh	8627
crarr	8629
cularr	8630
curarr	8631
olarr	8634
orarr	8635
lharu	8636
lhard	8637
uharr	8638
uharl	8639
rharu	8640
rhard	8641
dharr	8642
dharl	8643
rlarr	8644
udarr	8645
lrarr	8646
llarr	8647
uuarr	8648
rrarr	8649
ddarr	8650
lrhar	8651
rlhar	8652
nlArr	8653
nhArr	8654
nrArr	8655
lArr	8656
uArr	8657
rArr	8658
dArr	8659
hArr	8660
vArr	8661
nwArr	8662
neArr	8663
seArr	8664
swArr	8665
lAarr	8666
rAarr	8667
zigrarr	8669
larrb	8676
rarrb	8677
duarr	8693
loarr	8701
roarr	8702
hoarr	8703
forall	8704
comp	8705
part	8706
exist	8707
nexist	8708
empty	8709
nabla	8711
isin	8712
notin	8713
niv	8715
notni	8716
prod	8719
coprod	8720
sum	8721
minus	8722
mnplus	8723
plusdo	8724
setmn	8726
lowast	8727
compfn	8728
radic	8730
prop	8733
infin	8734
angrt	8735
ang	8736
angmsd	8737
angsph	8738
mid	8739
nmid	8740
par	8741
npar	8742
and	8743
or	8744
cap	8745
cup	8746
int	8747
Int	8748
tint	8749
conint	8750
Conint	8751
Cconint	8752
cwint	8753
cwconint	8754
awconint	8755
there4	8756
becaus	8757
ratio	8758
Colon	8759
minusd	8760
mDDot	8762
homtht	8763
sim	8764
bsim	8765
ac	8766
acd	8767
wreath	8768
nsim	8769
esim	8770
sime	8771
nsime	8772
cong	8773
simne	8774
ncong	8775
asymp	8776
nap	8777
ape	8778
apid	8779
bcong	8780
asympeq	8781
bump	8782
bumpe	8783
esdot	8784
eDot	8785
efDot	8786
erDot	8787
colone	8788
ecolon	8789
ecir	8790
cire	8791
wedgeq	8793
veeeq	8794
trie	8796
equest	8799
ne	8800
equiv	8801
nequiv	8802
le	8804
ge	8805
lE	8806
gE	8807
lnE	8808
gnE	8809
Lt	8810
Gt	8811
twixt	8812
NotCupCap	8813
nlt	8814
ngt	8815
nle	8816
nge	8817
lsim	8818
gsim	8819
nlsim	8820
ngsim	8821
lg	8822
gl	8823
ntlg	8824
ntgl	8825
pr	8826
sc	8827
prcue	8828
sccue	8829
prsim	8830
scsim	8831
npr	8832
nsc	8833
sub	8834
sup	8835
nsub	8836
nsup	8837
sube	8838
supe	8839
nsube	8840
nsupe	8841
subne	8842
supne	8843
cupdot	8845
uplus	8846
sqsub	8847
sqsup	8848
sqsube	8849
sqsupe	8850
sqcap	8851
sqcup	8852
oplus	8853
ominus	8854
otimes	8855
osol	8856
odot	8857
ocir	8858
oast	8859
odash	8861
plusb	8862
minusb	8863
timesb	8864
sdotb	8865
vdash	8866
dashv	8867
top	8868
bottom	8869
models	8871
vDash	8872
Vdash	8873
Vvdash	8874
VDash	8875
nvdash	8876
nvDash	8877
nVdash	8878
nVDash	8879
prurel	8880
vltri	8882
vrtri	8883
ltrie	8884
rtrie	8885
origof	8886
imof	8887
mumap	8888
hercon	8889
intcal	8890
veebar	8891
barvee	8893
angrtvb	8894
lrtri	8895
xwedge	8896
xvee	8897
xcap	8898
xcup	8899
diam	8900
sdot	8901
sstarf	8902
divonx	8903
bowtie	8904
ltimes	8905
rtimes	8906
lthree	8907
rthree	8908
bsime	8909
cuvee	8910
cuwed	8911
Sub	8912
Sup	8913
Cap	8914
Cup	8915
fork	8916
epar	8917
ltdot	8918
gtdot	8919
Ll	8920
Gg	8921
leg	8922
gel	8923
cuepr	8926
cuesc	8927
nprcue	8928
nsccue	8929
nsqsube	8930
nsqsupe	8931
lnsim	8934
gnsim	8935
prnsim	8936
scnsim	8937
nltri	8938
nrtri	8939
nltrie	8940
nrtrie	8941
vellip	8942
ctdot	8943
utdot	8944
dtdot	8945
disin	8946
isinsv	8947
isins	8948
isindot	8949
notinvc	8950
notinvb	8951
isinE	8953
nisd	8954
xnis	8955
nis	8956
notnivc	8957
notnivb	8958
barwed	8965
Barwed	8966
lceil	8968
rceil	8969
lfloor	8970
rfloor	8971
drcrop	8972
dlcrop	8973
urcrop	8974
ulcrop	8975
bnot	8976
profline	8978
profsurf	8979
telrec	8981
target	8982
ulcorn	8988
urcorn	8989
dlcorn	8990
drcorn	8991
frown	8994
smile	8995
lang	9001
rang	9002
cylcty	9005
profalar	9006
topbot	9014
ovbar	9021
solbar	9023
angzarr	9084
lmoust	9136
rmoust	9137
tbrk	9140
bbrk	9141
bbrktbrk	9142
OverParenthesis	9180
UnderParenthesis	9181
OverBrace	9182
UnderBrace	9183
trpezium	9186
elinters	9191
blank	9251
oS	9416
boxh	9472
boxv	9474
boxdr	9484
boxdl	9488
boxur	9492
boxul	9496
boxvr	9500
boxvl	9508
boxhd	9516
boxhu	9524
boxvh	9532
boxH	9552
boxV	9553
boxdR	9554
boxDr	9555
boxDR	9556
boxdL	9557
boxDl	9558
boxDL	9559
boxuR	9560
boxUr	9561
boxUR	9562
boxuL	9563
boxUl	9564
boxUL	9565
boxvR	9566
boxVr	9567
boxVR	9568
boxvL	9569
boxVl	9570
boxVL	9571
boxHd	9572
boxhD	9573
boxHD	9574
boxHu	9575
boxhU	9576
boxHU	9577
boxvH	9578
boxVh	9579
boxVH	9580
uhblk	9600
lhblk	9604
block	9608
blk14	9617
blk12	9618
blk34	9619
squ	9633
squf	9642
EmptyVerySmallSquare	9643
rect	9645
marker	9646
fltns	9649
xutri	9651
utrif	9652
utri	9653
rtrif	9656
rtri	9657
xdtri	9661
dtrif	9662
dtri	9663
ltrif	9666
ltri	9667
loz	9674
cir	9675
tridot	9708
xcirc	9711
ultri	9720
urtri	9721
lltri	9722
EmptySmallSquare	9723
FilledSmallSquare	9724
starf	9733
star	9734
phone	9742
female	9792
male	9794
spades	9824
clubs	9827
hearts	9829
diams	9830
sung	9834
flat	9837
natur	9838
sharp	9839
check	10003
cross	10007
malt	10016
sext	10038
VerticalSeparator	10072
lbbrk	10098
rbbrk	10099
lobrk	10214
robrk	10215
lang	10216
rang	10217
Lang	10218
Rang	10219
loang	10220
roang	10221
xlarr	10229
xrarr	10230
xharr	10231
xlArr	10232
xrArr	10233
xhArr	10234
xmap	10236
dzigrarr	10239
nvlArr	10498
nvrArr	10499
nvHarr	10500
Map	10501
lbarr	10508
rbarr	10509
lBarr	10510
rBarr	10511
RBarr	10512
DDotrahd	10513
UpArrowBar	10514
DownArrowBar	10515
Rarrtl	10518
latail	10521
ratail	10522
lAtail	10523
rAtail	10524
larrfs	10525
rarrfs	10526
larrbfs	10527
rarrbfs	10528
nwarhk	10531
nearhk	10532
searhk	10533
swarhk	10534
nwnear	10535
nesear	10536
seswar	10537
swnwar	10538
rarrc	10547
cudarrr	10549
ldca	10550
rdca	10551
cudarrl	10552
larrpl	10553
curarrm	10556
cularrp	10557
rarrpl	10565
harrcir	10568
Uarrocir	10569
lurdshar	10570
ldrushar	10571
LeftRightVector	10574
RightUpDownVector	10575
DownLeftRightVector	10576
LeftUpDownVector	10577
LeftVectorBar	10578
RightVectorBar	10579
RightUpVectorBar	10580
RightDownVectorBar	10581
DownLeftVectorBar	10582
DownRightVectorBar	10583
LeftUpVectorBar	10584
LeftDownVectorBar	10585
LeftTeeVector	10586
RightTeeVector	10587
RightUpTeeVector	10588
RightDownTeeVector	10589
DownLeftTeeVector	10590
DownRightTeeVector	10591
LeftUpTeeVector	10592
LeftDownTeeVector	10593
lHar	10594
uHar	10595
rHar	10596
dHar	10597
luruhar	10598
ldrdhar	10599
ruluhar	10600
rdldhar	10601
lharul	10602
llhard	10603
rharul	10604
lrhard	10605
udhar	10606
duhar	10607
RoundImplies	10608
erarr	10609
simrarr	10610
larrsim	10611
rarrsim	10612
rarrap	10613
ltlarr	10614
gtrarr	10616
subrarr	10617
suplarr	10619
lfisht	10620
rfisht	10621
ufisht	10622
dfisht	10623
lopar	10629
ropar	10630
lbrke	10635
rbrke	10636
lbrkslu	10637
rbrksld	10638
lbrksld	10639
rbrkslu	10640
langd	10641
rangd	10642
lparlt	10643
rpargt	10644
gtlPar	10645
ltrPar	10646
vzigzag	10650
vangrt	10652
angrtvbd	10653
ange	10660
range	10661
dwangle	10662
uwangle	10663
angmsdaa	10664
angmsdab	10665
angmsdac	10666
angmsdad	10667
angmsdae	10668
angmsdaf	10669
angmsdag	10670
angmsdah	10671
bemptyv	10672
demptyv	10673
cemptyv	10674
raemptyv	10675
laemptyv	10676
ohbar	10677
omid	10678
opar	10679
operp	10681
olcross	10683
odsold	10684
olcir	10686
ofcir	10687
olt	10688
ogt	10689
cirscir	10690
cirE	10691
solb	10692
bsolb	10693
boxbox	10697
trisb	10701
rtriltri	10702
LeftTriangleBar	10703
RightTriangleBar	10704
race	10714
iinfin	10716
infintie	10717
nvinfin	10718
eparsl	10723
smeparsl	10724
eqvparsl	10725
lozf	10731
RuleDelayed	10740
dsol	10742
xodot	10752
xoplus	10753
xotime	10754
xuplus	10756
xsqcup	10758
qint	10764
fpartint	10765
cirfnint	10768
awint	10769
rppolint	10770
scpolint	10771
npolint	10772
pointint	10773
quatint	10774
intlarhk	10775
pluscir	10786
plusacir	10787
simplus	10788
plusdu	10789
plussim	10790
plustwo	10791
mcomma	10793
minusdu	10794
loplus	10797
roplus	10798
Cross	10799
timesd	10800
timesbar	10801
smashp	10803
lotimes	10804
rotimes	10805
otimesas	10806
Otimes	10807
odiv	10808
triplus	10809
triminus	10810
tritime	10811
iprod	10812
amalg	10815
capdot	10816
ncup	10818
ncap	10819
capand	10820
cupor	10821
cupcap	10822
capcup	10823
cupbrcap	10824
capbrcup	10825
cupcup	10826
capcap	10827
ccups	10828
ccaps	10829
ccupssm	10832
And	10835
Or	10836
andand	10837
oror	10838
orslope	10839
andslope	10840
andv	10842
orv	10843
andd	10844
ord	10845
wedbar	10847
sdote	10854
simdot	10858
congdot	10861
easter	10862
apacir	10863
apE	10864
eplus	10865
pluse	10866
Esim	10867
Colone	10868
Equal	10869
eDDot	10871
equivDD	10872
ltcir	10873
gtcir	10874
ltquest	10875
gtquest	10876
les	10877
ges	10878
lesdot	10879
gesdot	10880
lesdoto	10881
gesdoto	10882
lesdotor	10883
gesdotol	10884
lap	10885
gap	10886
lne	10887
gne	10888
lnap	10889
gnap	10890
lEg	10891
gEl	10892
lsime	10893
gsime	10894
lsimg	10895
gsiml	10896
lgE	10897
glE	10898
lesges	10899
gesles	10900
els	10901
egs	10902
elsdot	10903
egsdot	10904
el	10905
eg	10906
siml	10909
simg	10910
simlE	10911
simgE	10912
LessLess	10913
GreaterGreater	10914
glj	10916
gla	10917
ltcc	10918
gtcc	10919
lescc	10920
gescc	10921
smt	10922
lat	10923
smte	10924
late	10925
bumpE	10926
pre	10927
sce	10928
prE	10931
scE	10932
prnE	10933
scnE	10934
prap	10935
scap	10936
prnap	10937
scnap	10938
Pr	10939
Sc	10940
subdot	10941
supdot	10942
subplus	10943
supplus	10944
submult	10945
supmult	10946
subedot	10947
supedot	10948
subE	10949
supE	10950
subsim	10951
supsim	10952
subnE	10955
supnE	10956
csub	10959
csup	10960
csube	10961
csupe	10962
subsup	10963
supsub	10964
subsub	10965
supsup	10966
suphsub	10967
supdsub	10968
forkv	10969
topfork	10970
mlcp	10971
Dashv	10980
Vdashl	10982
Barv	10983
vBar	10984
vBarv	10985
Vbar	10987
Not	10988
bNot	10989
rnmid	10990
cirmid	10991
midcir	10992
topcir	10993
nhpar	10994
parsim	10995
parsl	11005
fflig	64256
filig	64257
fllig	64258
ffilig	64259
ffllig	64260
Ascr	119964
Cscr	119966
Dscr	119967
Gscr	119970
Jscr	119973
Kscr	119974
Nscr	119977
Oscr	119978
Pscr	119979
Qscr	119980
Sscr	119982
Tscr	119983
Uscr	119984
Vscr	119985
Wscr	119986
Xscr	119987
Yscr	119988
Zscr	119989
ascr	119990
bscr	119991
cscr	119992
dscr	119993
fscr	119995
hscr	119997
iscr	119998
jscr	119999
kscr	120000
lscr	120001
mscr	120002
nscr	120003
pscr	120005
qscr	120006
rscr	120007
sscr	120008
tscr	120009
uscr	120010
vscr	120011
wscr	120012
xscr	120013
yscr	120014
zscr	120015
Afr	120068
Bfr	120069
Dfr	120071
Efr	120072
Ffr	120073
Gfr	120074
Jfr	120077
Kfr	120078
Lfr	120079
Mfr	120080
Nfr	120081
Ofr	120082
Pfr	120083
Qfr	120084
Sfr	120086
Tfr	120087
Ufr	120088
Vfr	120089
Wfr	120090
Xfr	120091
Yfr	120092
afr	120094
bfr	120095
cfr	120096
dfr	120097
efr	120098
ffr	120099
gfr	120100
hfr	120101
ifr	120102
jfr	120103
kfr	120104
lfr	120105
mfr	120106
nfr	120107
ofr	120108
pfr	120109
qfr	120110
rfr	120111
sfr	120112
tfr	120113
ufr	120114
vfr	120115
wfr	120116
xfr	120117
yfr	120118
zfr	120119
Aopf	120120
Bopf	120121
Dopf	120123
Eopf	120124
Fopf	120125
Gopf	120126
Iopf	120128
Jopf	120129
Kopf	120130
Lopf	120131
Mopf	120132
Oopf	120134
Sopf	120138
Topf	120139
Uopf	120140
Vopf	120141
Wopf	120142
Xopf	120143
Yopf	120144
aopf	120146
bopf	120147
copf	120148
dopf	120149
eopf	120150
fopf	120151
gopf	120152
hopf	120153
iopf	120154
jopf	120155
kopf	120156
lopf	120157
mopf	120158
nopf	120159
oopf	120160
popf	120161
qopf	120162
ropf	120163
sopf	120164
topf	120165
uopf	120166
vopf	120167
wopf	120168
xopf	120169
yopf	120170
zopf	120171function get__nodeValue(str_json,recursion){for(var i in str_json){var a=Object.prototype.toString.call(str_json[i]);if(a=="[object Object]"||a=="[object Array]"){if(recursion){get__nodeValue(str_json[i],recursion)}}else if(a=="[object String]"||a=="[object Number]"||a=="[object Boolean]"){str_all.push(str_json[i])}}return str_all}function get__count(c){var obj=Object.prototype.toString.call(c);if(obj=='[object Array]'){return c.length}else{return 0}}function get__name_All(a){var obj=Object.prototype.toString.call(a);if(obj=='[object Object]'){var ary=new Array();for(var key in a){if(typeof a[key]!=='function'){ary.push(key)}}return ary.join('\r\n')}else{return''}}function get__extend(target,source){if(Object.prototype.toString.call(target)=='[object Array]'){for(var i=0;i<source.length;i++){target.push(source[i])}return target}else{var str_obj;for(var obj in source){str_obj=typeof target[obj];if(str_obj=='string'||str_obj=='boolean'||str_obj=='undefined'){target[obj]=source[obj]}else if(str_obj=='number'){target=target.concat(source)}else if(str_obj=='object'){target[obj]=get__extend(target[obj],source[obj])}}return target}}if(typeof JSON!=='object'){JSON={}}(function(){'use strict';function f(n){return n<10?'0'+n:n}if(typeof Date.prototype.toJSON!=='function'){Date.prototype.toJSON=function(key){return isFinite(this.valueOf())?this.getUTCFullYear()+'-'+f(this.getUTCMonth()+1)+'-'+f(this.getUTCDate())+'T'+f(this.getUTCHours())+':'+f(this.getUTCMinutes())+':'+f(this.getUTCSeconds())+'Z':null};String.prototype.toJSON=Number.prototype.toJSON=Boolean.prototype.toJSON=function(key){return this.valueOf()}}var cx=/[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,escapable=/[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,gap,indent,meta={'\b':'\\b','\t':'\\t','\n':'\\n','\f':'\\f','\r':'\\r','"':'\\"','\\':'\\\\'},rep;function quote(string){escapable.lastIndex=0;return escapable.test(string)?'"'+string.replace(escapable,function(a){var c=meta[a];return typeof c==='string'?c:'\\u'+('0000'+a.charCodeAt(0).toString(16)).slice(-4)})+'"':'"'+string+'"'}function str(key,holder){var i,k,v,length,mind=gap,partial,value=holder[key];if(value&&typeof value==='object'&&typeof value.toJSON==='function'){value=value.toJSON(key)}if(typeof rep==='function'){value=rep.call(holder,key,value)}switch(typeof value){case'string':return quote(value);case'number':return isFinite(value)?String(value):'null';case'boolean':case'null':return String(value);case'object':if(!value){return'null'}gap+=indent;partial=[];if(Object.prototype.toString.apply(value)==='[object Array]'){length=value.length;for(i=0;i<length;i+=1){partial[i]=str(i,value)||'null'}v=partial.length===0?'[]':gap?'[\n'+gap+partial.join(',\n'+gap)+'\n'+mind+']':'['+partial.join(',')+']';gap=mind;return v}if(rep&&typeof rep==='object'){length=rep.length;for(i=0;i<length;i+=1){k=rep[i];if(typeof k==='string'){v=str(k,value);if(v){partial.push(quote(k)+(gap?': ':':')+v)}}}}else{for(k in value){if(Object.prototype.hasOwnProperty.call(value,k)){v=str(k,value);if(v){partial.push(quote(k)+(gap?': ':':')+v)}}}}v=partial.length===0?'{}':gap?'{\n'+gap+partial.join(',\n'+gap)+'\n'+mind+'}':'{'+partial.join(',')+'}';gap=mind;return v}}if(typeof JSON.stringify!=='function'){JSON.stringify=function(value,replacer,space){var i;gap='';indent='';if(typeof space==='number'){for(i=0;i<space;i+=1){indent+=' '}}else if(typeof space==='string'){indent=space}rep=replacer;if(replacer&&typeof replacer!=='function'&&(typeof replacer!=='object'||typeof replacer.length!=='number')){throw new Error('JSON.stringify');}return str('',{'':value})}}if(typeof JSON.parse!=='function'){JSON.parse=function(text,reviver){var j;function walk(holder,key){var k,v,value=holder[key];if(value&&typeof value==='object'){for(k in value){if(Object.prototype.hasOwnProperty.call(value,k)){v=walk(value,k);if(v!==undefined){value[k]=v}else{delete value[k]}}}}return reviver.call(holder,key,value)}text=String(text);cx.lastIndex=0;if(cx.test(text)){text=text.replace(cx,function(a){return'\\u'+('0000'+a.charCodeAt(0).toString(16)).slice(-4)})}if(/^[\],:{}\s]*$/.test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,'@').replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,']').replace(/(?:^|:|,)(?:\s*\[)+/g,''))){j=eval('('+text+')');return typeof reviver==='function'?walk({'':j},''):j}throw new SyntaxError('JSON.parse');}}if(!Object.prototype.toJSONString){Object.prototype.toJSONString=function(filter){return JSON.stringify(this,filter)};Object.prototype.parseJSON=function(filter){return JSON.parse(this,filter)}}}());//  json2.js
//  2016-10-28
if (typeof JSON !== "object") {
    JSON = {};
}

(function () {
    "use strict";

    var rx_one = /^[\],:{}\s]*$/;
    var rx_two = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g;
    var rx_three = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
    var rx_four = /(?:^|:|,)(?:\s*\[)+/g;
    var rx_escapable = /[\\"\u0000-\u001f\u007f-\u009f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;
    var rx_dangerous = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;

    function f(n) {
        return n < 10
            ? "0" + n
            : n;
    }

    function this_value() {
        return this.valueOf();
    }

    if (typeof Date.prototype.toJSON !== "function") {

        Date.prototype.toJSON = function () {

            return isFinite(this.valueOf())
                ? this.getUTCFullYear() + "-" +
                        f(this.getUTCMonth() + 1) + "-" +
                        f(this.getUTCDate()) + "T" +
                        f(this.getUTCHours()) + ":" +
                        f(this.getUTCMinutes()) + ":" +
                        f(this.getUTCSeconds()) + "Z"
                : null;
        };

        Boolean.prototype.toJSON = this_value;
        Number.prototype.toJSON = this_value;
        String.prototype.toJSON = this_value;
    }

    var gap;
    var indent;
    var meta;
    var rep;


    function quote(string) {

        rx_escapable.lastIndex = 0;
        return rx_escapable.test(string)
            ? "\"" + string.replace(rx_escapable, function (a) {
                var c = meta[a];
                return typeof c === "string"
                    ? c
                    : "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4);
            }) + "\""
            : "\"" + string + "\"";
    }


    function str(key, holder) {
        var i;
        var k;
        var v;
        var length;
        var mind = gap;
        var partial;
        var value = holder[key];

        if (value && typeof value === "object" &&
                typeof value.toJSON === "function") {
            value = value.toJSON(key);
        }

        if (typeof rep === "function") {
            value = rep.call(holder, key, value);
        }

       switch (typeof value) {
        case "string":
            return quote(value);

        case "number":
            return isFinite(value)
                ? String(value)
                : "null";
        case "boolean":
        case "null":
            return String(value);
        case "object":
            if (!value) {
                return "null";
            }
            gap += indent;
            partial = [];
            if (Object.prototype.toString.apply(value) === "[object Array]") {
                length = value.length;
                for (i = 0; i < length; i += 1) {
                    partial[i] = str(i, value) || "null";
                }
                v = partial.length === 0
                    ? "[]"
                    : gap
                        ? "[\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "]"
                        : "[" + partial.join(",") + "]";
                gap = mind;
                return v;
            }
            if (rep && typeof rep === "object") {
                length = rep.length;
                for (i = 0; i < length; i += 1) {
                    if (typeof rep[i] === "string") {
                        k = rep[i];
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (
                                gap
                                    ? ": "
                                    : ":"
                            ) + v);
                        }
                    }
                }
            } else {
                for (k in value) {
                    if (Object.prototype.hasOwnProperty.call(value, k)) {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (
                                gap
                                    ? ": "
                                    : ":"
                            ) + v);
                        }
                    }
                }
            }
            v = partial.length === 0
                ? "{}"
                : gap
                    ? "{\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "}"
                    : "{" + partial.join(",") + "}";
            gap = mind;
            return v;
        }
    }
    if (typeof JSON.stringify !== "function") {
        meta = {    // table of character substitutions
            "\b": "\\b",
            "\t": "\\t",
            "\n": "\\n",
            "\f": "\\f",
            "\r": "\\r",
            "\"": "\\\"",
            "\\": "\\\\"
        };
        JSON.stringify = function (value, replacer, space) {
            var i;
            gap = "";
            indent = "";
            if (typeof space === "number") {
                for (i = 0; i < space; i += 1) {
                    indent += " ";
                }
            } else if (typeof space === "string") {
                indent = space;
            }
            rep = replacer;
            if (replacer && typeof replacer !== "function" &&
                    (typeof replacer !== "object" ||
                    typeof replacer.length !== "number")) {
                throw new Error("JSON.stringify");
            }
            return str("", {"": value});
        };
    }
    if (typeof JSON.parse !== "function") {
        JSON.parse = function (text, reviver) {
            var j;

            function walk(holder, key) {
                var k;
                var v;
                var value = holder[key];
                if (value && typeof value === "object") {
                    for (k in value) {
                        if (Object.prototype.hasOwnProperty.call(value, k)) {
                            v = walk(value, k);
                            if (v !== undefined) {
                                value[k] = v;
                            } else {
                                delete value[k];
                            }
                        }
                    }
                }
                return reviver.call(holder, key, value);
            }
            text = String(text);
            rx_dangerous.lastIndex = 0;
            if (rx_dangerous.test(text)) {
                text = text.replace(rx_dangerous, function (a) {
                    return "\\u" +
                            ("0000" + a.charCodeAt(0).toString(16)).slice(-4);
                });
            }
            if (
                rx_one.test(
                    text
                        .replace(rx_two, "@")
                        .replace(rx_three, "]")
                        .replace(rx_four, "")
                )
            ) {
                j = eval("(" + text + ")");
                return (typeof reviver === "function")
                    ? walk({"": j}, "")
                    : j;
            }
            throw new SyntaxError("JSON.parse");
        };
    }
}());function ysjs(str){return jsmin("",str,2)}
String.prototype.has=function(c){return this.indexOf(c)>-1;};function jsmin(comment,input,level){if(input===undefined){input=comment;comment='';level=2;}else if(level===undefined||level<1||level>3){level=2;}if(comment.length>0){comment+='\n';}var a='',b='',EOF=-1,LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz',DIGITS='0123456789',ALNUM=LETTERS+DIGITS+'_$\\',theLookahead=EOF;function isAlphanum(c){return c!=EOF&&(ALNUM.has(c)||c.charCodeAt(0)>126);}function get(){var c=theLookahead;if(get.i==get.l){return EOF;}theLookahead=EOF;if(c==EOF){c=input.charAt(get.i);++get.i;}if(c>=' '||c=='\n'){return c;}if(c=='\r'){return'\n';}return' ';}get.i=0;get.l=input.length;function peek(){theLookahead=get();return theLookahead;}function next(){var c=get();if(c=='/'){switch(peek()){case'/':for(;;){c=get();if(c<='\n'){return c;}}break;case'*':get();for(;;){switch(get()){case'*':if(peek()=='/'){get();return' ';}break;case EOF:throw'Error: Unterminated comment.';}}break;default:return c;}}return c;}function action(d){var r=[];if(d==1){r.push(a);}if(d<3){a=b;if(a=='\''||a=='"'){for(;;){r.push(a);a=get();if(a==b){break;}if(a<='\n'){throw'Error: unterminated string literal: '+a;}if(a=='\\'){r.push(a);a=get();}}}}b=next();if(b=='/'&&'(,=:[!&|'.has(a)){r.push(a);r.push(b);for(;;){a=get();if(a=='/'){break;}else if(a=='\\'){r.push(a);a=get();}else if(a<='\n'){throw'Error: unterminated Regular Expression literal';}r.push(a);}b=next();}return r.join('');}function m(){var r=[];a='\n';r.push(action(3));while(a!=EOF){switch(a){case' ':if(isAlphanum(b)){r.push(action(1));}else{r.push(action(2));}break;case'\n':switch(b){case'{':case'[':case'(':case'+':case'-':r.push(action(1));break;case' ':r.push(action(3));break;default:if(isAlphanum(b)){r.push(action(1));}else{if(level==1&&b!='\n'){r.push(action(1));}else{r.push(action(2));}}}break;default:switch(b){case' ':if(isAlphanum(a)){r.push(action(1));break;}r.push(action(3));break;case'\n':if(level==1&&a!='\n'){r.push(action(1));}else{switch(a){case'}':case']':case')':case'+':case'-':case'"':case'\'':if(level==3){r.push(action(3));}else{r.push(action(1));}break;default:if(isAlphanum(a)){r.push(action(1));}else{r.push(action(3));}}}break;default:r.push(action(1));break;}}}return r.join('');}jsmin.oldSize=input.length;ret=m(input);jsmin.newSize=ret.length;return comment+ret;}

function js_beautify(js_source_text,options){var input,output,token_text,last_type,last_text,last_last_text,last_word,flags,flag_store,indent_string;var whitespace,wordchar,punct,parser_pos,line_starters,digits;var prefix,token_type,do_block_just_closed;var wanted_newline,just_added_newline,n_newlines;var preindent_string='';options=options?options:{};var opt_brace_style;if(options.space_after_anon_function!==undefined&&options.jslint_happy===undefined){options.jslint_happy=options.space_after_anon_function}if(options.braces_on_own_line!==undefined){opt_brace_style=options.braces_on_own_line?"expand":"collapse"}opt_brace_style=options.brace_style?options.brace_style:(opt_brace_style?opt_brace_style:"collapse");var opt_indent_size=options.indent_size?options.indent_size:4,opt_indent_char=options.indent_char?options.indent_char:' ',opt_preserve_newlines=typeof options.preserve_newlines==='undefined'?true:options.preserve_newlines,opt_break_chained_methods=typeof options.break_chained_methods==='undefined'?false:options.break_chained_methods,opt_max_preserve_newlines=typeof options.max_preserve_newlines==='undefined'?false:options.max_preserve_newlines,opt_jslint_happy=options.jslint_happy==='undefined'?false:options.jslint_happy,opt_keep_array_indentation=typeof options.keep_array_indentation==='undefined'?false:options.keep_array_indentation,opt_space_before_conditional=typeof options.space_before_conditional==='undefined'?true:options.space_before_conditional,opt_unescape_strings=typeof options.unescape_strings==='undefined'?false:options.unescape_strings;just_added_newline=false;var input_length=js_source_text.length;function trim_output(eat_newlines){eat_newlines=typeof eat_newlines==='undefined'?false:eat_newlines;while(output.length&&(output[output.length-1]===' '||output[output.length-1]===indent_string||output[output.length-1]===preindent_string||(eat_newlines&&(output[output.length-1]==='\n'||output[output.length-1]==='\r')))){output.pop()}}function trim(s){return s.replace(/^\s\s*|\s\s*$/,'')}function split_newlines(s){s=s.replace(/\x0d/g,'');var out=[],idx=s.indexOf("\n");while(idx!==-1){out.push(s.substring(0,idx));s=s.substring(idx+1);idx=s.indexOf("\n")}if(s.length){out.push(s)}return out}function force_newline(){var old_keep_array_indentation=opt_keep_array_indentation;opt_keep_array_indentation=false;print_newline();opt_keep_array_indentation=old_keep_array_indentation}function print_newline(ignore_repeated,reset_statement_flags){flags.eat_next_space=false;if(opt_keep_array_indentation&&is_array(flags.mode)){return}ignore_repeated=typeof ignore_repeated==='undefined'?true:ignore_repeated;reset_statement_flags=typeof reset_statement_flags==='undefined'?true:reset_statement_flags;if(reset_statement_flags){flags.if_line=false;flags.chain_extra_indentation=0}trim_output();if(!output.length){return}if(output[output.length-1]!=="\n"||!ignore_repeated){just_added_newline=true;output.push("\n")}if(preindent_string){output.push(preindent_string)}for(var i=0;i<flags.indentation_level+flags.chain_extra_indentation;i+=1){output.push(indent_string)}if(flags.var_line&&flags.var_line_reindented){output.push(indent_string)}}function print_single_space(){if(last_type==='TK_COMMENT'){return print_newline()}if(flags.eat_next_space){flags.eat_next_space=false;return}var last_output=' ';if(output.length){last_output=output[output.length-1]}if(last_output!==' '&&last_output!=='\n'&&last_output!==indent_string){output.push(' ')}}function print_token(){just_added_newline=false;flags.eat_next_space=false;output.push(token_text)}function indent(){flags.indentation_level+=1}function remove_indent(){if(output.length&&output[output.length-1]===indent_string){output.pop()}}function set_mode(mode){if(flags){flag_store.push(flags)}flags={previous_mode:flags?flags.mode:'BLOCK',mode:mode,var_line:false,var_line_tainted:false,var_line_reindented:false,in_html_comment:false,if_line:false,chain_extra_indentation:0,in_case_statement:false,in_case:false,case_body:false,eat_next_space:false,indentation_level:(flags?flags.indentation_level+((flags.var_line&&flags.var_line_reindented)?1:0):0),ternary_depth:0}}function is_array(mode){return mode==='[EXPRESSION]'||mode==='[INDENTED-EXPRESSION]'}function is_expression(mode){return in_array(mode,['[EXPRESSION]','(EXPRESSION)','(FOR-EXPRESSION)','(COND-EXPRESSION)'])}function restore_mode(){do_block_just_closed=flags.mode==='DO_BLOCK';if(flag_store.length>0){var mode=flags.mode;flags=flag_store.pop();flags.previous_mode=mode}}function all_lines_start_with(lines,c){for(var i=0;i<lines.length;i++){var line=trim(lines[i]);if(line.charAt(0)!==c){return false}}return true}function is_special_word(word){return in_array(word,['case','return','do','if','throw','else'])}function in_array(what,arr){for(var i=0;i<arr.length;i+=1){if(arr[i]===what){return true}}return false}function look_up(exclude){var local_pos=parser_pos;var c=input.charAt(local_pos);while(in_array(c,whitespace)&&c!==exclude){local_pos++;if(local_pos>=input_length){return 0}c=input.charAt(local_pos)}return c}function get_next_token(){var i;var resulting_string;n_newlines=0;if(parser_pos>=input_length){return['','TK_EOF']}wanted_newline=false;var c=input.charAt(parser_pos);parser_pos+=1;var keep_whitespace=opt_keep_array_indentation&&is_array(flags.mode);if(keep_whitespace){var whitespace_count=0;while(in_array(c,whitespace)){if(c==="\n"){trim_output();output.push("\n");just_added_newline=true;whitespace_count=0}else{if(c==='\t'){whitespace_count+=4}else if(c==='\r'){}else{whitespace_count+=1}}if(parser_pos>=input_length){return['','TK_EOF']}c=input.charAt(parser_pos);parser_pos+=1}if(just_added_newline){for(i=0;i<whitespace_count;i++){output.push(' ')}}}else{while(in_array(c,whitespace)){if(c==="\n"){n_newlines+=((opt_max_preserve_newlines)?(n_newlines<=opt_max_preserve_newlines)?1:0:1)}if(parser_pos>=input_length){return['','TK_EOF']}c=input.charAt(parser_pos);parser_pos+=1}if(opt_preserve_newlines){if(n_newlines>1){for(i=0;i<n_newlines;i+=1){print_newline(i===0);just_added_newline=true}}}wanted_newline=n_newlines>0}if(in_array(c,wordchar)){if(parser_pos<input_length){while(in_array(input.charAt(parser_pos),wordchar)){c+=input.charAt(parser_pos);parser_pos+=1;if(parser_pos===input_length){break}}}if(parser_pos!==input_length&&c.match(/^[0-9]+[Ee]$/)&&(input.charAt(parser_pos)==='-'||input.charAt(parser_pos)==='+')){var sign=input.charAt(parser_pos);parser_pos+=1;var t=get_next_token();c+=sign+t[0];return[c,'TK_WORD']}if(c==='in'){return[c,'TK_OPERATOR']}if(wanted_newline&&last_type!=='TK_OPERATOR'&&last_type!=='TK_EQUALS'&&!flags.if_line&&(opt_preserve_newlines||last_text!=='var')){print_newline()}return[c,'TK_WORD']}if(c==='('||c==='['){return[c,'TK_START_EXPR']}if(c===')'||c===']'){return[c,'TK_END_EXPR']}if(c==='{'){return[c,'TK_START_BLOCK']}if(c==='}'){return[c,'TK_END_BLOCK']}if(c===';'){return[c,'TK_SEMICOLON']}if(c==='/'){var comment='';var inline_comment=true;if(input.charAt(parser_pos)==='*'){parser_pos+=1;if(parser_pos<input_length){while(parser_pos<input_length&&!(input.charAt(parser_pos)==='*'&&input.charAt(parser_pos+1)&&input.charAt(parser_pos+1)==='/')){c=input.charAt(parser_pos);comment+=c;if(c==="\n"||c==="\r"){inline_comment=false}parser_pos+=1;if(parser_pos>=input_length){break}}}parser_pos+=2;if(inline_comment&&n_newlines===0){return['/*'+comment+'*/','TK_INLINE_COMMENT']}else{return['/*'+comment+'*/','TK_BLOCK_COMMENT']}}if(input.charAt(parser_pos)==='/'){comment=c;while(input.charAt(parser_pos)!=='\r'&&input.charAt(parser_pos)!=='\n'){comment+=input.charAt(parser_pos);parser_pos+=1;if(parser_pos>=input_length){break}}if(wanted_newline){print_newline()}return[comment,'TK_COMMENT']}}if(c==="'"||c==='"'||(c==='/'&&((last_type==='TK_WORD'&&is_special_word(last_text))||(last_text===')'&&in_array(flags.previous_mode,['(COND-EXPRESSION)','(FOR-EXPRESSION)']))||(last_type==='TK_COMMA'||last_type==='TK_COMMENT'||last_type==='TK_START_EXPR'||last_type==='TK_START_BLOCK'||last_type==='TK_END_BLOCK'||last_type==='TK_OPERATOR'||last_type==='TK_EQUALS'||last_type==='TK_EOF'||last_type==='TK_SEMICOLON')))){var sep=c;var esc=false;var esc1=0;var esc2=0;resulting_string=c;if(parser_pos<input_length){if(sep==='/'){var in_char_class=false;while(esc||in_char_class||input.charAt(parser_pos)!==sep){resulting_string+=input.charAt(parser_pos);if(!esc){esc=input.charAt(parser_pos)==='\\';if(input.charAt(parser_pos)==='['){in_char_class=true}else if(input.charAt(parser_pos)===']'){in_char_class=false}}else{esc=false}parser_pos+=1;if(parser_pos>=input_length){return[resulting_string,'TK_STRING']}}}else{while(esc||input.charAt(parser_pos)!==sep){resulting_string+=input.charAt(parser_pos);if(esc1&&esc1>=esc2){esc1=parseInt(resulting_string.substr(-esc2),16);if(esc1&&esc1>=0x20&&esc1<=0x7e){esc1=String.fromCharCode(esc1);resulting_string=resulting_string.substr(0,resulting_string.length-esc2-2)+(((esc1===sep)||(esc1==='\\'))?'\\':'')+esc1}esc1=0}if(esc1){esc1++}else if(!esc){esc=input.charAt(parser_pos)==='\\'}else{esc=false;if(opt_unescape_strings){if(input.charAt(parser_pos)==='x'){esc1++;esc2=2}else if(input.charAt(parser_pos)==='u'){esc1++;esc2=4}}}parser_pos+=1;if(parser_pos>=input_length){return[resulting_string,'TK_STRING']}}}}parser_pos+=1;resulting_string+=sep;if(sep==='/'){while(parser_pos<input_length&&in_array(input.charAt(parser_pos),wordchar)){resulting_string+=input.charAt(parser_pos);parser_pos+=1}}return[resulting_string,'TK_STRING']}if(c==='#'){if(output.length===0&&input.charAt(parser_pos)==='!'){resulting_string=c;while(parser_pos<input_length&&c!=='\n'){c=input.charAt(parser_pos);resulting_string+=c;parser_pos+=1}output.push(trim(resulting_string)+'\n');print_newline();return get_next_token()}var sharp='#';if(parser_pos<input_length&&in_array(input.charAt(parser_pos),digits)){do{c=input.charAt(parser_pos);sharp+=c;parser_pos+=1}while(parser_pos<input_length&&c!=='#'&&c!=='=');if(c==='#'){}else if(input.charAt(parser_pos)==='['&&input.charAt(parser_pos+1)===']'){sharp+='[]';parser_pos+=2}else if(input.charAt(parser_pos)==='{'&&input.charAt(parser_pos+1)==='}'){sharp+='{}';parser_pos+=2}return[sharp,'TK_WORD']}}if(c==='<'&&input.substring(parser_pos-1,parser_pos+3)==='<!--'){parser_pos+=3;c='<!--';while(input.charAt(parser_pos)!=='\n'&&parser_pos<input_length){c+=input.charAt(parser_pos);parser_pos++}flags.in_html_comment=true;return[c,'TK_COMMENT']}if(c==='-'&&flags.in_html_comment&&input.substring(parser_pos-1,parser_pos+2)==='-->'){flags.in_html_comment=false;parser_pos+=2;if(wanted_newline){print_newline()}return['-->','TK_COMMENT']}if(c==='.'){return[c,'TK_DOT']}if(in_array(c,punct)){while(parser_pos<input_length&&in_array(c+input.charAt(parser_pos),punct)){c+=input.charAt(parser_pos);parser_pos+=1;if(parser_pos>=input_length){break}}if(c===','){return[c,'TK_COMMA']}else if(c==='='){return[c,'TK_EQUALS']}else{return[c,'TK_OPERATOR']}}return[c,'TK_UNKNOWN']}indent_string='';while(opt_indent_size>0){indent_string+=opt_indent_char;opt_indent_size-=1}while(js_source_text&&(js_source_text.charAt(0)===' '||js_source_text.charAt(0)==='\t')){preindent_string+=js_source_text.charAt(0);js_source_text=js_source_text.substring(1)}input=js_source_text;last_word='';last_type='TK_START_EXPR';last_text='';last_last_text='';output=[];do_block_just_closed=false;whitespace="\n\r\t ".split('');wordchar='abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_$'.split('');digits='0123456789'.split('');punct='+ - * / % & ++ -- = += -= *= /= %= == === != !== > < >= <= >> << >>> >>>= >>= <<= && &= | || ! !! , : ? ^ ^= |= ::';punct+=' <%= <% %> <?= <? ?>';punct=punct.split(' ');line_starters='continue,try,throw,return,var,if,switch,case,default,for,while,break,function'.split(',');flag_store=[];set_mode('BLOCK');parser_pos=0;while(true){var t=get_next_token();token_text=t[0];token_type=t[1];if(token_type==='TK_EOF'){break}switch(token_type){case'TK_START_EXPR':if(token_text==='['){if(last_type==='TK_WORD'||last_text===')'){if(in_array(last_text,line_starters)){print_single_space()}set_mode('(EXPRESSION)');print_token();break}if(flags.mode==='[EXPRESSION]'||flags.mode==='[INDENTED-EXPRESSION]'){if(last_last_text===']'&&last_text===','){if(flags.mode==='[EXPRESSION]'){flags.mode='[INDENTED-EXPRESSION]';if(!opt_keep_array_indentation){indent()}}set_mode('[EXPRESSION]');if(!opt_keep_array_indentation){print_newline()}}else if(last_text==='['){if(flags.mode==='[EXPRESSION]'){flags.mode='[INDENTED-EXPRESSION]';if(!opt_keep_array_indentation){indent()}}set_mode('[EXPRESSION]');if(!opt_keep_array_indentation){print_newline()}}else{set_mode('[EXPRESSION]')}}else{set_mode('[EXPRESSION]')}}else{if(last_word==='for'){set_mode('(FOR-EXPRESSION)')}else if(in_array(last_word,['if','while'])){set_mode('(COND-EXPRESSION)')}else{set_mode('(EXPRESSION)')}}if(last_text===';'||last_type==='TK_START_BLOCK'){print_newline()}else if(last_type==='TK_END_EXPR'||last_type==='TK_START_EXPR'||last_type==='TK_END_BLOCK'||last_text==='.'){if(wanted_newline){print_newline()}}else if(last_type!=='TK_WORD'&&last_type!=='TK_OPERATOR'){print_single_space()}else if(last_word==='function'||last_word==='typeof'){if(opt_jslint_happy){print_single_space()}}else if(in_array(last_text,line_starters)||last_text==='catch'){if(opt_space_before_conditional){print_single_space()}}print_token();break;case'TK_DOT':if(is_special_word(last_text)){print_single_space()}else if(last_text===')'){if(opt_break_chained_methods||wanted_newline){flags.chain_extra_indentation=1;print_newline(true,false)}}print_token();break;case'TK_END_EXPR':if(token_text===']'){if(opt_keep_array_indentation){if(last_text==='}'){remove_indent();print_token();restore_mode();break}}else{if(flags.mode==='[INDENTED-EXPRESSION]'){if(last_text===']'){restore_mode();print_newline();print_token();break}}}}restore_mode();print_token();break;case'TK_START_BLOCK':if(last_word==='do'){set_mode('DO_BLOCK')}else{set_mode('BLOCK')}if(opt_brace_style==="expand"||opt_brace_style==="expand-strict"){var empty_braces=false;if(opt_brace_style==="expand-strict"){empty_braces=(look_up()==='}');if(!empty_braces){print_newline(true)}}else{if(last_type!=='TK_OPERATOR'){if(last_text==='='||(is_special_word(last_text)&&last_text!=='else')){print_single_space()}else{print_newline(true)}}}print_token();if(!empty_braces){indent()}}else{if(last_type!=='TK_OPERATOR'&&last_type!=='TK_START_EXPR'){if(last_type==='TK_START_BLOCK'){print_newline()}else{print_single_space()}}else{if(is_array(flags.previous_mode)&&last_text===','){if(last_last_text==='}'){print_single_space()}else{print_newline()}}}indent();print_token()}break;case'TK_END_BLOCK':restore_mode();if(opt_brace_style==="expand"||opt_brace_style==="expand-strict"){if(last_text!=='{'){print_newline()}print_token()}else{if(last_type==='TK_START_BLOCK'){if(just_added_newline){remove_indent()}else{trim_output()}}else{if(is_array(flags.mode)&&opt_keep_array_indentation){opt_keep_array_indentation=false;print_newline();opt_keep_array_indentation=true}else{print_newline()}}print_token()}break;case'TK_WORD':if(do_block_just_closed){print_single_space();print_token();print_single_space();do_block_just_closed=false;break}prefix='NONE';if(token_text==='function'){if(flags.var_line&&last_type!=='TK_EQUALS'){flags.var_line_reindented=true}if((just_added_newline||last_text===';')&&last_text!=='{'&&last_type!=='TK_BLOCK_COMMENT'&&last_type!=='TK_COMMENT'){n_newlines=just_added_newline?n_newlines:0;if(!opt_preserve_newlines){n_newlines=1}for(var i=0;i<2-n_newlines;i++){print_newline(false)}}if(last_type==='TK_WORD'){if(last_text==='get'||last_text==='set'||last_text==='new'||last_text==='return'){print_single_space()}else{print_newline()}}else if(last_type==='TK_OPERATOR'||last_text==='='){print_single_space()}else if(is_expression(flags.mode)){}else{print_newline()}print_token();last_word=token_text;break}if(token_text==='case'||(token_text==='default'&&flags.in_case_statement)){print_newline();if(flags.case_body){flags.indentation_level--;flags.case_body=false;remove_indent()}print_token();flags.in_case=true;flags.in_case_statement=true;break}if(last_type==='TK_END_BLOCK'){if(!in_array(token_text.toLowerCase(),['else','catch','finally'])){prefix='NEWLINE'}else{if(opt_brace_style==="expand"||opt_brace_style==="end-expand"||opt_brace_style==="expand-strict"){prefix='NEWLINE'}else{prefix='SPACE';print_single_space()}}}else if(last_type==='TK_SEMICOLON'&&(flags.mode==='BLOCK'||flags.mode==='DO_BLOCK')){prefix='NEWLINE'}else if(last_type==='TK_SEMICOLON'&&is_expression(flags.mode)){prefix='SPACE'}else if(last_type==='TK_STRING'){prefix='NEWLINE'}else if(last_type==='TK_WORD'){if(last_text==='else'){trim_output(true)}prefix='SPACE'}else if(last_type==='TK_START_BLOCK'){prefix='NEWLINE'}else if(last_type==='TK_END_EXPR'){print_single_space();prefix='NEWLINE'}if(in_array(token_text,line_starters)&&last_text!==')'){if(last_text==='else'){prefix='SPACE'}else{prefix='NEWLINE'}}if(flags.if_line&&last_type==='TK_END_EXPR'){flags.if_line=false}if(in_array(token_text.toLowerCase(),['else','catch','finally'])){if(last_type!=='TK_END_BLOCK'||opt_brace_style==="expand"||opt_brace_style==="end-expand"||opt_brace_style==="expand-strict"){print_newline()}else{trim_output(true);print_single_space()}}else if(prefix==='NEWLINE'){if(is_special_word(last_text)){print_single_space()}else if(last_type!=='TK_END_EXPR'){if((last_type!=='TK_START_EXPR'||token_text!=='var')&&last_text!==':'){if(token_text==='if'&&last_word==='else'&&last_text!=='{'){print_single_space()}else{flags.var_line=false;flags.var_line_reindented=false;print_newline()}}}else if(in_array(token_text,line_starters)&&last_text!==')'){flags.var_line=false;flags.var_line_reindented=false;print_newline()}}else if(is_array(flags.mode)&&last_text===','&&last_last_text==='}'){print_newline()}else if(prefix==='SPACE'){print_single_space()}print_token();last_word=token_text;if(token_text==='var'){flags.var_line=true;flags.var_line_reindented=false;flags.var_line_tainted=false}if(token_text==='if'){flags.if_line=true}if(token_text==='else'){flags.if_line=false}break;case'TK_SEMICOLON':print_token();flags.var_line=false;flags.var_line_reindented=false;if(flags.mode==='OBJECT'){flags.mode='BLOCK'}break;case'TK_STRING':if(last_type==='TK_END_EXPR'&&in_array(flags.previous_mode,['(COND-EXPRESSION)','(FOR-EXPRESSION)'])){print_single_space()}else if(last_type==='TK_COMMENT'||last_type==='TK_STRING'||last_type==='TK_START_BLOCK'||last_type==='TK_END_BLOCK'||last_type==='TK_SEMICOLON'){print_newline()}else if(last_type==='TK_WORD'){print_single_space()}else{if(opt_preserve_newlines&&wanted_newline&&flags.mode!=='OBJECT'){print_newline();output.push(indent_string)}}print_token();break;case'TK_EQUALS':if(flags.var_line){flags.var_line_tainted=true}print_single_space();print_token();print_single_space();break;case'TK_COMMA':if(flags.var_line){if(is_expression(flags.mode)||last_type==='TK_END_BLOCK'){flags.var_line_tainted=false}if(flags.var_line_tainted){print_token();flags.var_line_reindented=true;flags.var_line_tainted=false;print_newline();break}else{flags.var_line_tainted=false}print_token();print_single_space();break}if(last_type==='TK_COMMENT'){print_newline()}if(last_type==='TK_END_BLOCK'&&flags.mode!=="(EXPRESSION)"){print_token();if(flags.mode==='OBJECT'&&last_text==='}'){print_newline()}else{print_single_space()}}else{if(flags.mode==='OBJECT'){print_token();print_newline()}else{print_token();print_single_space()}}break;case'TK_OPERATOR':var space_before=true;var space_after=true;if(is_special_word(last_text)){print_single_space();print_token();break}if(token_text==='*'&&last_type==='TK_DOT'&&!last_last_text.match(/^\d+$/)){print_token();break}if(token_text===':'&&flags.in_case){flags.case_body=true;indent();print_token();print_newline();flags.in_case=false;break}if(token_text==='::'){print_token();break}if(in_array(token_text,['--','++','!'])||(in_array(token_text,['-','+'])&&(in_array(last_type,['TK_START_BLOCK','TK_START_EXPR','TK_EQUALS','TK_OPERATOR'])||in_array(last_text,line_starters)||last_text==','))){space_before=false;space_after=false;if(last_text===';'&&is_expression(flags.mode)){space_before=true}if(last_type==='TK_WORD'&&in_array(last_text,line_starters)){space_before=true}if(flags.mode==='BLOCK'&&(last_text==='{'||last_text===';')){print_newline()}}else if(token_text===':'){if(flags.ternary_depth===0){if(flags.mode==='BLOCK'){flags.mode='OBJECT'}space_before=false}else{flags.ternary_depth-=1}}else if(token_text==='?'){flags.ternary_depth+=1}if(space_before){print_single_space()}print_token();if(space_after){print_single_space()}break;case'TK_BLOCK_COMMENT':var lines=split_newlines(token_text);var j;if(all_lines_start_with(lines.slice(1),'*')){print_newline();output.push(lines[0]);for(j=1;j<lines.length;j++){print_newline();output.push(' ');output.push(trim(lines[j]))}}else{if(lines.length>1){print_newline()}else{if(last_type==='TK_END_BLOCK'){print_newline()}else{print_single_space()}}for(j=0;j<lines.length;j++){output.push(lines[j]);output.push("\n")}}if(look_up('\n')!=='\n'){print_newline()}break;case'TK_INLINE_COMMENT':print_single_space();print_token();if(is_expression(flags.mode)){print_single_space()}else{force_newline()}break;case'TK_COMMENT':if(last_text===','&&!wanted_newline){trim_output(true)}if(last_type!=='TK_COMMENT'){if(wanted_newline){print_newline()}else{print_single_space()}}print_token();print_newline();break;case'TK_UNKNOWN':print_token();break}last_last_text=last_text;last_type=token_type;last_text=token_text}var sweet_code=preindent_string+output.join('').replace(/[\r\n ]+$/,'');return sweet_code}if(typeof exports!=="undefined"){exports.js_beautify=js_beautify}function FJsDecoder(msg)
{
    var jsdecoder;
    jsdecoder = new JsDecoder();
    jsdecoder.s = msg;
    code = jsdecoder.decode();
    return code;
}

/*
 * DO NOT REMOVE THIS NOTICE
 *
 * PROJECT:   JsDecoder
 * VERSION:   1.1.0
 * COPYRIGHT: (c) 2004-2008 Cezary Tomczak
 * LINK:      http://code.gosu.pl
 * LICENSE:   GPL
 */

function JsDecoder()
{
    this.s = '';
    this.len = 0;
    
    this.i = 0;
    this.lvl = 0; /* indent level */
    this.code = [''];
    this.row = 0;
    this.switches = [];

    this.lastWord = '';
    this.nextChar = '';
    this.prevChar = '';
    this.isAssign = false;

    this.decode = function ()
    {
        this.s = this.s.replace(/[\r\n\f]+/g, "\n");
        this.len = this.s.length;
        while (this.i < this.len)
        {
            var c = this.s.charAt(this.i);
            this.charInit();
            this.switch_c(c);
            this.i++;
        }
        return this.code.join("\n");
    };
    this.switch_c = function(c)
    {
        switch (c)
        {
            case "\n":
                this.linefeed(); 
                break;

            case ' ':
            case "\t":
                this.space();
                break;

            case '{':  this.blockBracketOn();  break;
            case '}':  this.blockBracketOff(); break;

            case ':':  this.colon();     break;
            case ';':  this.semicolon(); break;

            case '(':  this.bracketOn();        break;
            case ')':  this.bracketOff();       break;
            case '[':  this.squareBracketOn();  break;
            case ']':  this.squareBracketOff(); break;

            case '"':
            case "'":
                this.quotation(c);
                break;

            case '/':
                if ('/' == this.nextChar) {
                    this.lineComment();
                } else if ('*' == this.nextChar) {
                    this.comment();
                } else {
                    this.slash();
                }
                break;

            case ',':  this.comma(); break;
            case '.':  this.dot(); break;

            case '~':
            case '^':
                this.symbol1(c);
                break;

            case '-': case '+': case '*': case '%':
            case '<': case '=': case '>': case '?':
            case ':': case '&': case '|': case '/':
                this.symbol2(c);
                break;

            case '!':
                if ('=' == this.nextChar) {
                    this.symbol2(c);
                } else {
                    this.symbol1(c);
                }
                break;

            default:
                if (/\w/.test(c)) { this.alphanumeric(c); }
                else { this.unknown(c); }
                break;
        }
        c = this.s.charAt(this.i);
        if (!/\w/.test(c)) {
            this.lastWord = '';
        }
    };
    this.blockBracketOn = function ()
    {
        this.isAssign = false;
        var nextNW = this.nextNonWhite(this.i);
        if ('}' == nextNW) {
            var ss = (this.prevChar == ')' ? ' ' : '');
            this.write(ss+'{');
            this.lvl++;
            return;
            
        }
        if (/^\s*switch\s/.test(this.getCurrentLine())) {
            this.switches.push(this.lvl);
        }
        var line = this.getCurrentLine();
        var line_row = this.row;
        var re = /(,)\s*(\w+\s*:\s*function\s*\([^\)]*\)\s*)$/;
        if (re.test(line)) {
            this.replaceLine(this.code[line_row].replace(re, '$1'));
            this.writeLine();
            var match = re.exec(line);
            this.write(match[2]);
        }

        /* example: return {
            title: 'Jack Slocum',
            iconCls: 'user'}
            After return bracket cannot be on another line
        */
        if (/^\s*return\s*/.test(this.code[this.row])) {
            if (/^\s*return\s+\w+/.test(this.code[this.row])) {
                this.writeLine();
            } else if (this.prevChar != ' ') {
                this.write(' ');
            }
            this.write('{');
            this.writeLine();
            this.lvl++;
            return;
        }

        if (/function\s*/.test(this.code[this.row]) || this.isBlockBig()) {
            this.writeLine();
        } else {
            if (this.prevChar != ' ' && this.prevChar != "\n" && this.prevChar != '(') {
                /*  && this.prevChar != '(' && this.prevChar != '[' */
                this.write(' ');
            }
        }
        this.write('{');
        this.lvl++;
        if ('{' != nextNW) {
            this.writeLine();
        }
    };
    this.isBlockBig = function()
    {
        var i = this.i + 1;
        var count = 0;
        var opened = 0;
        var closed = 0;
        while (i < this.len - 1)
        {
            i++;
            var c = this.s.charAt(i);
            if (/\s/.test(c)) {
                continue;
            }
            if ('}' == c && opened == closed) {
                break;
            }
            if ('{' == c) { opened++; }
            if ('}' == c) { closed++; }
            count++;
            if (count > 80) {
                return true;
            }
        }
        return (count > 80);
    };
    this.blockBracketOff = function ()
    {
        var nextNW = this.nextNonWhite(this.i);
        var prevNW = this.prevNonWhite(this.i);
        var line = this.getCurrentLine();

        if (prevNW != '{')
        {
            if (line.length && nextNW != ';' && nextNW != '}' && nextNW != ')' && nextNW != ',') {
                //this.semicolon();
                this.writeLine();
            } else if (line.length && prevNW != ';' && nextNW == '}' && this.isAssign) {
                this.semicolon();
            } else if (line.length && this.isAssign && prevNW != ';') {
                this.semicolon();
            } else if (line.length && prevNW != ';') {
                if (/^\s*(else)?\s*return[\s(]+/i.test(line)) {
                    this.semicolon();
                } else {
                    this.writeLine();
                }
            }
        }
        this.write('}');

        if (',' == nextNW) {
            this.write(',');
            this.goNextNonWhite();
        }
        var next3 = this.nextManyNW(3);
        if (next3 == '(),') {
            this.write('(),');
            this.goNextManyNW('(),');
            this.writeLine();
        }
        else if (next3 == '();') {
            this.write('();');
            this.goNextManyNW('();');
            this.writeLine();
        }
        else if (next3 == '():') {
            this.write('()');
            this.goNextManyNW('()');
            this.write(' : ');
            this.goNextNonWhite();
        }
        else
        {
            if ('{' == prevNW) {
                if (',' == nextNW && this.getCurrentLine().length < 80) {
                    this.write(' ');
                } else {
                    if (this.nextWord() || '}' == nextNW) {
                        this.writeLine();
                    }
                }
            } else {
                if (')' != nextNW && ']' != nextNW) {
                    if (',' == nextNW && /^[\s\w,]+\)/.test(this.s.substr(this.i, 20))) {
                        this.write(' ');
                    } else {
                        this.writeLine();
                    }
                }
            }
        }
        this.lvl--;

        if (this.switches.length && this.switches[this.switches.length - 1] == this.lvl)
        {
            var row = this.row - 1;
            var spaces1 = str_repeat(' ', this.lvl * 4);
            var spaces2 = str_repeat(' ', (this.lvl + 1) * 4);
            var sw1 = new RegExp('^'+spaces1+'(switch\\s|{)');
            var sw2 = new RegExp('^'+spaces2+'(case|default)[\\s:]');
            var sw3 = new RegExp('^'+spaces2+'[^\\s]');
            while (row > 0) {
                row--;
                if (sw1.test(this.code[row])) {
                    break;
                }
                if (sw2.test(this.code[row])) {
                    continue;
                }
                this.replaceLine('    ' + this.code[row], row);
                /*
                if (sw3.test(this.code[row])) {
                    this.replaceLine('    ' + this.code[row], row);
                }
                */
            }
            this.switches.pop();
        }

        // fix missing brackets for sub blocks

        if (this.sub) {
            return;
        }

        var re1 = /^(\s*else\s*if)\s*\(/;
        var re2 = /^(\s*else)\s+[^{]+/;

        var part = this.s.substr(this.i+1, 100);
        
        if (re1.test(part)) {
            this.i += re1.exec(part)[1].length;
            this.write('else if');
            this.lastWord = 'if';
            //debug(this.getCurrentLine(), 're1');
            this.fixSub('else if');
            //debug(this.getCurrentLine(), 're1 after');
        } else if (re2.test(part)) {
            this.i += re2.exec(part)[1].length;
            this.write('else');
            this.lastWord = 'else';
            //debug(this.getCurrentLine(), 're2');
            this.fixSub('else');
            //debug(this.getCurrentLine(), 're2 after');
        }
    };
    this.bracketOn = function ()
    {
        if (this.isKeyword() && this.prevChar != ' ' && this.prevChar != "\n") {
            this.write(' (');
        } else {
            this.write('(');
        }
    };
    this.bracketOff = function ()
    {
        this.write(')');
        /*
        if (/\w/.test(this.nextNonWhite(this.i))) {
            this.semicolon();
        }
        */
        if (this.sub) {
            return;
        }
        var re = new RegExp('^\\s*(if|for|while|do)\\s*\\([^{}]+\\)$', 'i');
        var line = this.getCurrentLine();
        if (re.test(line)) {
            var c = this.nextNonWhite(this.i);
            if ('{' != c && ';' != c && ')' != c) {
                var opened = 0;
                var closed = 0;
                var foundFirst = false;
                var semicolon = false;
                var fix = false;
                for (var k = 0; k < line.length; k++) {
                    if (line.charAt(k) == '(') {
                        foundFirst = true;
                        opened++;
                    }
                    if (line.charAt(k) == ')') {
                        closed++;
                        if (foundFirst && opened == closed) {
                            if (k == line.length - 1) {
                                fix = true;
                            } else {
                                break;
                            }
                        }
                    }
                }
                if (fix) {
                    //alert(this.s.substr(this.i));
                    //throw 'asdas';
                    //alert(line);
                    this.fixSub(re.exec(line)[1]);
                    /*
                    this.writeLine();
                    this.lvl2++;
                    var indent = '';
                    for (var j = 0; j < this.lvl2; j++) {
                        indent += '    ';
                    }
                    this.write(indent);
                    */
                }
            }
        }
    };
    this.sub = false;
    
    this.orig_i = null;
    this.orig_lvl = null;
    this.orig_code = null;
    this.orig_row = null;
    this.orig_switches = null;

    this.restoreOrig = function (omit_i)
    {
        this.sub = false;
        
        if (!omit_i) { this.i = this.orig_i; }
        this.lvl = this.orig_lvl;
        this.code = this.orig_code;
        this.row = this.orig_row;
        this.switches = this.orig_switches;

        this.prevCharInit();
        
        this.lastWord = '';
        this.charInit();
        this.isAssign = false;
    };
    this.combineSub = function ()
    {
        //debug(this.orig_code, 'orig_code');
        for (i = 0; i < this.code.length; i++) {
            var line = this.orig_code[this.orig_row];
            if (0 == i && line.length) {
                if (line.substr(line.length-1, 1) != ' ') {
                    this.orig_code[this.orig_row] += ' ';
                }
                this.orig_code[this.orig_row] += this.code[i].trim();
            } else {
                this.orig_code[this.orig_row+i] = this.code[i];
            }
        }
        //debug(this.code, 'sub_code');
        //debug(this.orig_code, 'code');
    };
    this.fixSub = function (keyword)
    {
        // repair missing {}: for, if, while, do, else, else if

        if (this.sub) {
            return;
        }

        if ('{' == this.nextNonWhite(this.i)) {
            return;
        }

        var firstWord = this.nextWord();

        //debug(this.code, 'fixSub('+keyword+') start');

        this.orig_i = this.i;
        this.orig_lvl = this.lvl;
        this.orig_code = this.code;
        this.orig_row = this.row;
        this.orig_switches = this.switches;
        
        this.sub = true;
        this.code = [''];
        this.prevChar = '';
        this.row = 0;
        this.switches = [];
        this.isAssign = false;

        this.i++;

        var b1 = 0;
        var b2 = 0;
        var b3 = 0;

        if ('else if' == keyword) {
            var first_b2_closed = false;
        }

        var found = false;

        /*
            try catch
            switch
            while do
            if else else else...

            todo: nestings
            if ()
                if () 
                    if ()
                        for ()
                            if () asd();
                    else
                        asd();
                else
                    if ()
                        try {
                        } catch {}
            else
            if ()
        */
        var b1_lastWord = false;
        var b2_lastWord = false;

        while (!found && this.i < this.len)
        {
            var c = this.s.charAt(this.i);
            this.charInit();
            switch (c)
            {
                case '{': b1++; break;
                case '}':
                    b1--;
                    // case: for(){if (!c.m(g))c.g(f, n[t] + g + ';')}
                    if (0 == b1 && 0 == b2 && 0 == b3 && this.lvl-1 == this.orig_lvl)
                    {
                        var nextWord = this.nextWord();
                        if ('switch' == firstWord) {
                            found = true;
                            break;
                        }
                        if ('try' == firstWord && 'catch' == b1_lastWord) {
                            found = true;
                            break;
                        }
                        if ('while' == firstWord && 'do' == b1_lastWord) {
                            found = true;
                            break;
                        }
                        if ('if' == firstWord) {
                            // todo
                        }
                        if ('if' == keyword && 'else' == nextWord && 'if' != firstWord) {
                            found = true;
                            break;
                        }
                        b1_lastWord = nextWord;
                    }
                    break;
                case '(': b2++; break;
                case ')':
                    b2--;
                    if ('else if' == keyword && 0 == b2 && !first_b2_closed) {
                        if (this.nextNonWhite(this.i) == '{') {
                            this.write(c);
                            this.combineSub();
                            this.restoreOrig(true);
                            //debug(this.code, 'fixSub('+keyword+') b2 return');
                            //debug(this.s.charAt(this.i), ' b2 current char');
                            return;
                        }
                        // do not restore orig i
                        this.write(c);
                        this.combineSub();
                        this.restoreOrig(true);
                        this.fixSub('if');
                        //debug(this.code, 'fixSub('+keyword+') b2 return');
                        return;
                    }
                    break;
                case '[': b3++; break;
                case ']': b3--; break;
                case ';':
                    //debug(this.getCurrentLine(), 'semicolon');
                    //debug([b1, b2, b3]);
                    if (0 == b1 && 0 == b2 && 0 == b3 && this.lvl == this.orig_lvl && 'if' != firstWord) {
                        found = true;
                    }
                    break;
            }
            if (-1 == b1 && b2 == 0 && b3 == 0 && this.prevNonWhite(this.i) != '}') {
                this.write(';');
                this.i--;
                found = true;
            } else if (b1 < 0 || b2 < 0 || b3 < 0) {
                found = false;
                break;
            } else {
                this.switch_c(c);
            }
            this.i++;
        }
        this.i--;

        if (found)
        {
            /*
            var re = /^\s*(else\s+[\s\S]*)$/;
            if ('if' == keyword && re.test(this.getCurrentLine())) {
                this.i = this.i - re.exec(this.getCurrentLine())[1].length;
                this.code[this.row] = '';
            }
            */
            this.s = this.s.substr(0, this.orig_i+1) + '{' + this.code.join("\n") + '}' + this.s.substr(this.i+1);
            this.len = this.s.length;
        }

        //debug("{\n" + this.code.join("\n") + '}', 'fixSub('+keyword+') result');
        //debug(found, 'found');

        this.restoreOrig(false);
    };
    this.squareBracketOn = function ()
    {
        this.checkKeyword();
        this.write('[');
    };
    this.squareBracketOff = function ()
    {
        this.write(']');
    };
    this.isKeyword = function ()
    {
        // Check if this.lastWord is a keyword
        return this.lastWord.length && this.keywords.indexOf(this.lastWord) != -1;
    };
    this.linefeed = function () {};
    this.space = function ()
    {
        if (!this.prevChar.length) {
            return;
        }
        if (' ' == this.prevChar || "\n" == this.prevChar) {
            return;
        }
        if ('}' == this.prevChar && ']' == this.nextChar) {
            //return;
        }
        this.write(' ');
        return;
        
        /*
        if (this.isKeyword()) {
            this.write(' ');
            this.lastWord = '';
        } else {
            var multi = ['in', 'new'];
            for (var i = 0; i < multi.length; i++) {
                var isKeywordNext = true;
                for (var j = 0; j < multi[i].length; j++) {
                    if (multi[i][j] != this.s.charAt(this.i + 1 + j)) {
                        isKeywordNext = false;
                        break;
                    }
                }
                if (isKeywordNext) {
                    this.write(' ');
                    this.lastWord = '';
                    break;
                }
            }
        }
        */
    };
    this.checkKeyword = function ()
    {
        if (this.isKeyword() && this.prevChar != ' ' && this.prevChar != "\n") {
            this.write(' ');
        }
    };
    this.nextWord = function ()
    {
        var i = this.i;
        var word = '';
        while (i < this.len - 1)
        {
            i++;
            var c = this.s.charAt(i);
            if (word.length) {
                if (/\s/.test(c)) {
                    break;
                } else if (/\w/.test(c)) {
                    word += c;
                } else {
                    break;
                }
            } else {
                if (/\s/.test(c)) {
                    continue;
                } else if (/\w/.test(c)) {
                    word += c;
                } else {
                    break;
                }
            }
        }
        if (word.length) {
            return word;
        }
        return false;
    };
    this.nextManyNW = function(many)
    {
        var ret = '';
        var i = this.i;
        while (i < this.len - 1)
        {
            i++;
            var c = this.s.charAt(i);
            if (!/^\s+$/.test(c)) {
                ret += c;
                if (ret.length == many) {
                    return ret;
                }
            }
        }
        return false;
    }
    this.goNextManyNW = function (cc)
    {
        var ret = '';
        var i = this.i;
        while (i < this.len - 1)
        {
            i++;
            var c = this.s.charAt(i);
            if (!/^\s+$/.test(c)) {
                ret += c;
                if (ret == cc) {
                    this.i = i;
                    this.charInit();
                    return true;
                }
                if (ret.length >= cc.length) {
                    return false;
                }
            }
        }
        return false;
    };
    this.nextNonWhite = function (i)
    {
        while (i < this.len - 1)
        {
            i++;
            var c = this.s.charAt(i);
            if (!/^\s+$/.test(c)) {
                return c;
            }
        }
        return false;
    };
    this.prevNonWhite = function (i)
    {
        while (i > 0)
        {
            i--;
            var c = this.s.charAt(i);
            if (!/^\s+$/.test(c)) {
                return c;
            }
        }
        return false;
    };
    this.goNextNonWhite = function ()
    {
        // you need to write() this nonWhite char when calling this func
        var i = this.i;
        while (i < this.len - 1)
        {
            i++;
            var c = this.s.charAt(i);
            if (!/^\s+$/.test(c)) {
                this.i = i;
                this.charInit();
                return true;
            }
        }
        return false;
    };
    this.colon = function ()
    {
        //alert(this.getCurrentLine());
        /* case 6: expr ? stat : stat */
        var line = this.getCurrentLine();
        if (/^\s*case\s/.test(line) || /^\s*default$/.test(line)) {
            this.write(':');
            this.writeLine();
        } else {
            this.symbol2(':');
        }
    };
    this.isStart = function ()
    {
        return this.getCurrentLine().length === 0;
    };
    this.backLine = function ()
    {
        if (!this.isStart) {
            throw 'backLine() may be called only at the start of the line';
        }
        this.code.length = this.code.length-1;
        this.row--;
    };
    this.semicolon = function ()
    {
        /* for statement: for (i = 1; i < len; i++) */
        this.isAssign = false;
        if (this.isStart()) {
            this.backLine();
        }
        this.write(';');
        if (/^\s*for\s/.test(this.getCurrentLine())) {
            this.write(' ');
        } else {
            this.writeLine();
        }
    };
    this.quotation = function (quotation)
    {
        this.checkKeyword();
        var escaped = false;
        this.write(quotation);
        while (this.i < this.len - 1) {
            this.i++;
            var c = this.s.charAt(this.i);
            if ('\\' == c) {
                escaped = (escaped ? false : true);
            }
            this.write(c);
            if (c == quotation) {
                if (!escaped) {
                    break;
                }
            }
            if ('\\' != c) {
                escaped = false;
            }
        }
        //debug(this.getCurrentLine(), 'quotation');
        //debug(this.s.charAt(this.i), 'char');
    };
    this.lineComment = function ()
    {
        this.write('//');
        this.i++;
        while (this.i < this.len - 1) {
            this.i++;
            var c = this.s.charAt(this.i);
            if ("\n" == c) {
                this.writeLine();
                break;
            }
            this.write(c);
        }
    };
    this.comment = function ()
    {
        this.write('/*');
        this.i++;
        var c = '';
        var prevC = '';
        while (this.i < this.len - 1)
        {
            this.i++;
            prevC = c;
            c = this.s.charAt(this.i);
            if (' ' == c || "\t" == c || "\n" == c) {
                if (' ' == c) {
                    if (this.getCurrentLine().length > 100) {
                        this.writeLine();
                    } else {
                        this.write(' ', true);
                    }
                } else if ("\t" == c) {
                    this.write('    ', true);
                } else if ("\n" == c) {
                    this.writeLine();
                }
            } else {
                this.write(c, true);
            }
            if ('/' == c && '*' == prevC) {
                break;
            }
        }
        this.writeLine();
    };
    this.slash = function ()
    {
        /*
        divisor /= or *\/ (4/5 , a/5)
        regexp /\w/ (//.test() , var asd = /some/;)
        asd /= 5;
        bbb = * / (4/5)
        asd =( a/5);
        regexp = /\w/;
        /a/.test();
        var asd = /some/;
        obj = { sasd : /pattern/ig }
        */
        var a_i = this.i - 1;
        var a_c = this.s.charAt(a_i);
        for (a_i = this.i - 1; a_i >= 0; a_i--) {
            var c2 = this.s.charAt(a_i);
            if (' ' == c2 || '\t' == c2) {
                continue;
            }
            a_c = this.s.charAt(a_i);
            break;
        }
        var a = /^\w+$/.test(a_c) || ']' == a_c || ')' == a_c;
        var b = ('*' == this.prevChar);
        if (a || b) {
            if (a) {
                if ('=' == this.nextChar) {
                    var ss = this.prevChar == ' ' ? '' : ' ';
                    this.write(ss+'/');
                } else {
                    this.write(' / ');
                }
            } else if (b) {
                this.write('/ ');
            }
        } else if (')' == this.prevChar) {
            this.write(' / ');
        } else {
            var ret = '';
            if ('=' == this.prevChar || ':' == this.prevChar) {
                ret += ' /';
            } else {
                ret += '/';
            }
            var escaped = false;
            while (this.i < this.len - 1) {
                this.i++;
                var c = this.s.charAt(this.i);
                if ('\\' == c) {
                    escaped = (escaped ? false : true);
                }
                ret += c;
                if ('/' == c) {
                    if (!escaped) {
                        break;
                    }
                }
                if ('\\' != c) {
                    escaped = false;
                }
            }
            this.write(ret);
        }
    };
    this.comma = function ()
    {
        /*
         * function arguments seperator
         * array values seperator
         * object values seperator
         */
        this.write(', ');
        var line = this.getCurrentLine();
        if (line.replace(' ', '').length > 100) {
            this.writeLine();
        }
    };
    this.dot = function ()
    {
        this.write('.');
    };
    this.symbol1 = function (c)
    {
        if ('=' == this.prevChar && '!' == c) {
            this.write(' '+c);
        } else {
            this.write(c);
        }
    };
    this.symbol2 = function (c)
    {
        // && !p
        // ===
        if ('+' == c || '-' == c) {
            if (c == this.nextChar || c == this.prevChar) {
                this.write(c);
                return;
            }
        }
        var ss = (this.prevChar == ' ' ? '' : ' ');
        var ss2 = ' ';
        if ('(' == this.prevChar) {
            ss = '';
            ss2 = '';
        }
        if ('-' == c && ('>' == this.prevChar || '>' == this.prevChar)) {
            this.write(' '+c);
            return;
        }
        if (this.symbols2.indexOf(this.prevChar) != -1) {
            if (this.symbols2.indexOf(this.nextChar) != -1) {
                this.write(c + (this.nextChar == '!' ? ' ' : ''));
            } else {
                this.write(c + ss2);
            }
        } else {
            if (this.symbols2.indexOf(this.nextChar) != -1) {
                this.write(ss + c);
            } else {
                this.write(ss + c + ss2);
            }
        }
        if ('=' == c && /^[\w\]]$/.test(this.prevNonWhite(this.i)) && /^[\w\'\"\[]$/.test(this.nextNonWhite(this.i))) {
            this.isAssign = true;
        }
    };
    this.alphanumeric = function (c)
    {
        /* /[a-zA-Z0-9_]/ == /\w/ */
        if (this.lastWord) {
            this.lastWord += c;
        } else {
            this.lastWord = c;
        }
        if (')' == this.prevChar) {
            c = ' '+c;
        }
        this.write(c);
    };
    this.unknown = function (c)
    {
        //throw 'Unknown char: "'+c+'" , this.i = ' + this.i;
        this.write(c);
    };

    this.charInit = function ()
    {
        /*
        if (this.i > 0) {
            //this.prevChar = this.s.charAt(this.i - 1);
            var line = this.code[this.row];
            if (line.length) {
                this.prevChar = line.substr(line.length-1, 1);
            } else {
                this.prevChar = '';
            }
        } else {
            this.prevChar = '';
        }
        */
        if (this.len - 1 === this.i) {
            this.nextChar = '';
        } else {
            this.nextChar = this.s.charAt(this.i + 1);
        }
    };
    this.write = function (s, isComment)
    {
        if (isComment) {
            if (!/\s/.test(s)) {
                if (this.code[this.row].length < this.lvl * 4) {
                    this.code[this.row] += str_repeat(' ', this.lvl * 4 - this.code[this.row].length);
                }
            }
            this.code[this.row] += s;
        } else {
            if (0 === this.code[this.row].length) {
                var lvl = ('}' == s ? this.lvl - 1 : this.lvl);
                for (var i = 0; i < lvl; i++) {
                    this.code[this.row] += '    ';
                }
                    this.code[this.row] += s;
            } else {
                this.code[this.row] += s;
            }
        }
        this.prevCharInit();
    };
    this.writeLine = function ()
    {
        this.code.push('');
        this.row++;
        this.prevChar = "\n";
    };
    this.replaceLine = function (line, row)
    {
        if ('undefined' == typeof row) {
            row = false;
        }
        if (row !== false) {
            if (!/^\d+$/.test(row) || row < 0 || row > this.row) {
                throw 'replaceLine() failed: invalid row='+row;
            }
        }
        if (row !== false) {
            this.code[row] = line;
        } else {
            this.code[this.row] = line;
        }
        if (row === false || row == this.row) {
            this.prevCharInit();
        }
    };
    this.prevCharInit = function ()
    {
        this.prevChar = this.code[this.row].charAt(this.code[this.row].length - 1);
    };
    this.writeTab = function ()
    {
        this.write('    ');
        this.prevChar = ' ';
    };
    this.getCurrentLine = function ()
    {
        return this.code[this.row];
    };

    this.symbols1 = '~!^';
    this.symbols2 = '-+*%<=>?:&|/!';
    this.keywords = ['abstract', 'boolean', 'break', 'byte', 'case', 'catch', 'char', 'class',
        'const', 'continue', 'default', 'delete', 'do', 'double', 'else', 'extends', 'false',
        'final', 'finally', 'float', 'for', 'function', 'goto', 'if', 'implements', 'import',
        'in', 'instanceof', 'int', 'interface', 'long', 'native', 'new', 'null', 'package',
        'private', 'protected', 'public', 'return', 'short', 'static', 'super', 'switch',
        'synchronized', 'this', 'throw', 'throws', 'transient', 'true', 'try', 'typeof', 'var',
        'void', 'while', 'with'];
}

if (typeof Array.prototype.indexOf == 'undefined') {
    /* Finds the index of the first occurence of item in the array, or -1 if not found */
    Array.prototype.indexOf = function(item) {
        for (var i = 0; i < this.length; i++) {
            if ((typeof this[i] == typeof item) && (this[i] == item)) {
                return i;
            }
        }
        return -1;
    };
}
if (!String.prototype.trim) {
    String.prototype.trim = function() {
        return this.replace(/^\s*|\s*$/g, '');
    };
}

function str_repeat(str, repeat)
{
    ret = '';
    for (var i = 0; i < repeat; i++) {
        ret += str;
    }
    return ret;
}

var debug_w;
function debug (arr, name)
{
    if (!debug_w) 
    {
        var width = 600;
        var height = 600;
        var x = (screen.width/2-width/2);
        var y = (screen.height/2-height/2);
        debug_w = window.open('', '', 'scrollbars=yes,resizable=yes,width='+width+',height='+height+',screenX='+(x)+',screenY='+y+',left='+x+',top='+y);
        debug_w.document.open();
        debug_w.document.write('<html><head><style>body{margin: 1em;padding: 0;font-family: courier new; font-size: 12px;}h1,h2{margin: 0.2em 0;}</style></head><body><h1>Debug</h1></body></html>');
        debug_w.document.close();
    }
    var ret = '';
    if ('undefined' !== typeof name && name.length) {
        ret = '<h2>'+name+'</h2>'+"\n";
    }
    if ('object' === typeof arr) {
        for (var i = 0; i < arr.length; i++) {
            ret += '['+i+'] => '+arr[i]+"\n";
        }
    } else if ('string' == typeof arr) {
        ret += arr;
    } else {
        try { ret += arr.toString(); } catch (e) {}
        ret += ' ('+typeof arr+')';
    }
    debug_w.document.body.innerHTML += '<pre>'+ret+'</pre>';
}



console.log(FJsDecoder('var jsdecoder;function do_decode(msg){jsdecoder=new JsDecoder();jsdecoder.s = msg;code=jsdecoder.decode();return code;}</script>'));

Function MACAddress() 
Dim mc,mo
    Set mc=GetObject("Winmgmts:").InstancesOf("Win32_NetworkAdapterConfiguration")
    For Each mo In mc
        If mo.IPEnabled=True Then
           MACAddress= mo.MacAddress
           Exit For
        End If
    Next 
End FunctionDate.prototype.format=function(fmt){var o={"M+":this.getMonth()+1,"d+":this.getDate(),"h+":this.getHours(),"m+":this.getMinutes(),"s+":this.getSeconds(),"q+":Math.floor((this.getMonth()+3)/3),"S":this.getMilliseconds()};if(/(y+)/.test(fmt)){fmt=fmt.replace(RegExp.$1,(this.getFullYear()+"").substr(4-RegExp.$1.length))}for(var k in o){if(new RegExp("("+k+")").test(fmt)){fmt=fmt.replace(RegExp.$1,(RegExp.$1.length==1)?(o[k]):(("00"+o[k]).substr((""+o[k]).length)))}}return fmt}
function to16on(str){
    var a = [],i = 0;
    for (; 
    i < str.length ;
    ) a[i] = ("00" + str.charCodeAt(i ++).toString(16)).slice(-4);
    return "\\u" + a.join("\\u");
}
function to16un(str) {
    return unescape(str.replace(/\\/g, "%"));
}
function to10on(str){
    var a = [], i = 0;
    for (; 
    i < str.length ;
    ) a[i] = str.charCodeAt(i ++);
    return "&#" + a.join(";&#") + ";";
}
function to10un(str){
    return str.replace(/&#(x)?([^&]{1,5});?/g, function (a, b, c) {
        return String.fromCharCode(parseInt(c,b?16:10));
    });
}Function Getcpuid() 
Dim cpuSet,cpu
    Set cpuSet = GetObject("winmgmts:{impersonationLevel=impersonate}").InstancesOf("Win32_Processor")
    For Each cpu In cpuSet
      getcpuid=cpu.ProcessorId
      exit for
    Next
end Function58.67.160.0-58.67.160.255
58.83.66.0-58.83.127.255
58.242.0.0-58.243.255.255
59.110.0.0-59.110.0.255
60.166.0.0-60.175.255.255
61.132.128.0-61.133.191.255
61.190.0.0-61.191.255.255
61.232.117.0-61.232.117.255
61.235.36.0-61.235.47.255
61.237.13.0-61.237.185.255
61.241.128.0-61.241.159.255
116.60.8.0-116.60.8.255
117.57.0.0-117.57.255.255
117.64.0.0-117.71.255.255
117.75.0.0-117.75.0.255
121.36.176.0-121.36.176.255
121.46.224.0-121.46.250.255
121.68.0.0-121.68.0.255
121.251.0.0-121.251.47.255
121.255.0.0-121.255.255.255
122.13.129.0-122.13.223.255
122.92.0.0-122.92.209.255
123.59.64.0-123.59.64.255
123.196.0.0-123.196.84.255
123.253.108.0-123.253.108.255
124.68.192.0-124.68.192.255
124.73.0.0-124.73.255.255
124.112.0.0-124.113.255.255
124.172.191.0-124.173.239.255
124.248.16.0-124.248.16.255
202.38.64.0-202.38.96.255
202.97.18.0-202.97.18.255
202.102.192.0-202.102.223.255
202.111.192.0-202.111.255.255
202.127.200.0-202.127.207.255
202.141.160.0-202.141.191.255
203.93.4.0-203.93.54.255
203.196.7.0-203.196.7.255
210.15.28.0-210.15.79.255
210.23.32.0-210.23.32.255
210.45.0.0-210.45.255.255
210.51.240.0-210.52.250.211
210.76.208.0-210.76.208.255
211.70.40.0-211.70.191.255
211.86.128.0-211.86.255.255
211.91.66.0-211.91.118.255
211.138.176.0-211.138.191.255
211.141.160.0-211.141.255.255
211.146.232.0-211.146.239.255
211.160.168.0-211.160.171.255
211.162.0.0-211.164.59.255
211.167.136.0-211.167.136.255
218.22.0.0-218.23.255.255
218.30.222.0-218.30.222.255
218.104.64.0-218.104.79.255
218.106.80.0-218.106.95.255
218.185.192.0-218.185.223.255
219.231.0.0-219.231.63.255
219.243.247.0-219.243.247.255
220.114.128.0-220.114.151.255
220.178.0.0-220.180.255.255
220.189.85.34-220.189.85.38
220.192.129.0-220.192.134.255
220.195.160.0-220.195.255.255
220.205.120.0-220.205.123.255
220.248.225.0-220.248.255.255
221.130.112.0-221.130.112.255
222.48.0.0-222.48.255.255
222.195.0.0-222.195.127.255
222.207.0.0-222.207.127.255
58.30.0.0-58.31.255.255
58.83.128.0-58.83.255.255
58.116.0.0-58.119.255.255
58.128.0.0-58.135.255.255
58.194.224.0-58.195.15.255
58.206.224.0-58.207.15.255
59.64.16.0-59.65.255.255
59.108.0.0-59.109.255.255
59.151.0.0-59.151.127.255
60.30.103.0-60.30.132.255
60.194.0.0-60.195.255.255
60.206.0.0-60.207.255.255
60.247.0.0-60.247.2.255
60.253.128.0-60.253.255.255
61.4.80.0-61.4.191.255
61.48.0.0-61.51.255.255
61.135.0.0-61.135.255.255
61.148.0.0-61.149.255.255
61.232.0.0-61.233.31.255
61.237.129.0-61.237.255.255
116.58.208.0-116.58.223.255
116.90.184.0-116.90.191.255
116.193.16.0-116.193.31.255
116.213.64.0-116.214.79.255
116.242.0.0-116.243.255.255
117.53.48.0-117.53.191.255
117.72.0.0-117.74.79.255
117.103.128.0-117.103.143.255
117.106.0.0-117.107.255.255
117.112.0.0-117.119.255.255
118.144.0.0-118.144.127.255
118.146.0.0-118.146.255.255
121.4.0.0-121.5.255.255
121.40.68.0-121.40.68.255
121.47.0.0-121.47.255.255
121.51.126.0-121.51.195.255
121.70.65.0-121.70.81.16
121.100.161.0-121.100.255.255
121.194.0.0-121.195.191.255
122.9.47.0-122.9.47.255
122.49.0.0-122.49.63.255
122.67.142.0-122.67.255.255
122.70.9.0-122.70.14.255
122.102.0.0-122.102.79.255
122.152.192.0-122.152.255.255
122.200.64.0-122.200.127.255
123.99.128.0-123.100.31.255
123.103.0.0-123.103.47.255
123.108.128.0-123.108.223.255
123.112.0.0-123.122.255.255
123.125.0.0-123.127.255.255
123.199.128.0-123.199.255.255
124.14.235.0-124.14.235.255
124.16.0.0-124.17.255.255
124.20.0.0-124.20.111.255
124.40.112.0-124.40.127.255
124.42.0.0-124.42.127.255
124.64.0.0-124.65.255.255
124.108.40.0-124.108.47.255
124.126.0.0-124.126.80.255
124.192.0.0-124.193.255.255
124.202.0.0-124.207.255.255
124.242.0.0-124.242.255.255
124.250.0.0-124.251.255.255
124.254.0.0-124.254.63.255
125.33.0.0-125.35.127.255
125.96.0.0-125.98.255.255
125.208.0.0-125.208.63.255
132.246.27.0-132.246.27.255
159.226.0.0-159.226.255.255
161.207.0.0-161.207.16.255
162.105.207.185-162.105.207.192
168.160.224.0-168.160.255.255
202.0.110.0-202.0.110.255
202.3.77.0-202.4.255.255
202.10.64.0-202.10.79.255
202.12.19.0-202.12.19.255
202.14.88.0-202.14.238.255
202.38.8.0-202.38.191.255
202.41.142.0-202.41.255.255
202.43.144.0-202.43.159.255
202.60.112.0-202.60.127.255
202.85.208.0-202.85.223.255
202.90.224.0-202.97.58.6
202.99.0.0-202.99.63.255
202.106.0.0-202.106.255.255
202.108.0.0-202.108.255.255
202.112.0.0-202.112.240.0
202.122.32.0-202.123.111.255
202.127.40.0-202.127.255.255
202.142.16.0-202.142.31.255
202.148.96.0-202.149.234.255
202.152.176.0-202.152.191.255
202.165.176.0-202.165.223.255
202.179.240.0-202.179.255.255
202.189.81.0-202.189.95.255
202.204.0.0-202.205.255.255
202.234.0.0-202.234.255.255
203.81.16.0-203.81.31.255
203.83.56.0-203.83.63.255
203.86.32.0-203.87.90.255
203.90.0.0-203.93.222.127
203.95.96.0-203.95.111.255
203.100.192.0-203.100.207.255
203.119.24.0-203.119.35.255
203.128.128.0-203.128.159.255
203.130.32.0-203.130.63.255
203.134.240.0-203.135.175.255
203.148.0.0-203.148.63.255
203.158.16.0-203.158.23.255
203.163.73.0-203.163.73.255
203.174.96.0-203.174.127.255
203.187.161.0-203.187.191.255
203.191.16.0-203.192.31.255
203.196.0.0-203.196.3.255
203.207.80.0-203.209.255.255
203.212.0.0-203.212.95.255
210.5.29.0-210.5.29.255
210.12.0.0-210.15.110.255
210.25.128.0-210.25.160.255
210.31.0.0-210.31.175.255
210.51.0.0-210.53.130.255
210.72.12.0-210.79.255.255
210.82.0.0-210.82.237.255
210.144.136.0-210.144.142.255
210.192.96.0-210.192.127.255
211.68.16.0-211.68.123.255
211.71.16.0-211.71.255.255
211.81.0.0-211.82.127.255
211.88.0.0-211.90.64.255
211.93.168.0-211.94.190.255
211.98.8.0-211.103.255.255
211.136.24.0-211.136.95.255
211.144.0.0-211.147.159.255
211.150.0.0-211.157.255.255
211.159.80.0-211.162.232.255
211.166.0.0-211.167.255.255
218.30.0.0-218.30.254.255
218.96.0.0-218.97.255.255
218.99.0.0-218.99.255.255
218.104.208.0-218.104.209.255
218.106.160.0-218.107.191.255
218.205.128.0-218.206.95.255
218.240.0.0-218.241.255.255
218.243.0.0-218.247.255.255
218.249.0.0-218.249.255.255
219.72.0.0-219.72.254.255
219.141.132.0-219.143.255.255
219.158.0.0-219.158.255.255
219.224.20.0-219.228.79.255
219.231.64.0-219.232.255.255
219.234.80.0-219.239.255.255
219.242.0.0-219.243.224.255
220.101.192.0-220.101.255.255
220.113.0.0-220.113.132.255
220.181.0.0-220.181.255.255
220.192.0.0-220.192.253.255
220.194.0.0-220.194.63.255
220.205.40.0-220.207.179.255
220.231.0.0-220.231.63.255
220.248.224.0-220.252.255.255
221.122.1.0-221.123.255.255
221.130.33.0-221.131.219.255
221.174.0.0-221.174.19.255
221.216.0.0-221.223.255.255
221.238.169.0-221.238.173.255
222.28.0.0-222.29.255.255
222.31.64.0-222.31.191.255
222.35.0.0-222.35.255.255
222.62.96.0-222.62.111.255
222.128.0.0-222.131.255.255
222.199.50.0-222.199.223.255
222.249.0.0-222.249.255.255
58.22.0.0-58.23.255.255
58.58.74.0-58.59.100.255
58.101.0.0-58.101.223.255
58.195.32.0-58.195.63.255
59.56.0.0-59.61.255.255
59.77.64.0-59.77.255.255
59.79.192.0-59.79.255.255
59.199.0.0-59.199.47.255
60.179.136.0-60.179.136.255
60.205.47.0-60.205.203.255
61.29.208.0-61.29.215.255
61.131.0.0-61.131.127.255
61.154.0.0-61.154.255.255
61.232.90.0-61.232.107.255
61.234.192.0-61.234.227.255
61.237.14.0-61.237.22.255
61.241.192.0-61.241.223.255
116.205.128.0-116.205.255.255
116.217.0.0-116.217.231.255
117.24.0.0-117.31.255.255
117.48.66.0-117.48.74.255
117.79.148.0-117.79.151.255
121.36.80.0-121.36.187.255
121.40.240.0-121.41.247.255
121.46.232.0-121.46.239.255
121.71.9.0-121.71.127.255
121.204.0.0-121.207.255.255
122.13.128.0-122.13.128.255
122.198.32.0-122.198.36.255
123.253.77.0-123.253.141.255
124.21.192.0-124.21.242.255
124.72.0.0-124.72.255.255
124.156.64.0-124.156.94.255
124.248.0.0-124.248.31.255
125.77.0.0-125.79.255.255
125.116.168.0-125.116.171.255
125.213.0.0-125.213.87.255
125.254.192.0-125.254.255.255
159.226.97.0-159.226.150.255
202.97.17.0-202.97.40.66
202.101.96.0-202.101.159.255
202.109.192.0-202.109.255.255
202.127.116.0-202.127.119.255
202.153.48.0-202.153.63.255
203.93.1.0-203.93.247.255
203.190.96.0-203.190.111.255
203.207.248.0-203.207.248.55
210.12.55.0-210.16.190.255
210.34.23.244-210.34.255.255
210.52.64.0-210.53.61.255
210.72.61.0-210.72.61.255
211.80.145.0-211.80.255.255
211.89.0.0-211.89.31.255
211.97.104.0-211.98.146.255
211.138.132.0-211.138.159.255
211.143.144.0-211.143.223.255
211.146.248.0-211.146.255.255
211.148.224.0-211.148.255.255
211.156.80.0-211.156.93.255
211.160.173.0-211.163.127.255
218.5.0.0-218.6.127.255
218.30.146.0-218.30.146.255
218.66.0.0-218.67.127.255
218.85.0.0-218.86.127.255
218.104.128.0-218.107.223.255
218.193.32.0-218.193.255.255
218.207.96.0-218.207.137.255
218.240.28.0-218.240.162.255
218.246.35.0-218.246.47.255
219.220.96.0-219.220.127.255
219.229.48.0-219.229.191.255
219.232.128.0-219.232.159.255
219.243.252.0-219.243.252.255
220.113.160.0-220.113.223.255
220.115.0.0-220.115.15.255
220.160.0.0-220.162.255.255
220.189.92.27-220.189.92.157
220.192.64.0-220.192.72.255
220.200.0.0-220.200.63.255
220.205.104.0-220.207.68.255
220.249.128.0-220.250.39.255
221.122.67.0-221.122.67.255
221.175.27.0-221.175.120.255
222.47.0.0-222.47.255.255
222.73.208.0-222.73.227.188
222.76.0.0-222.79.255.255
222.205.160.0-222.205.255.255
222.215.235.0-222.215.235.255
58.206.160.0-58.207.47.255
59.76.0.0-59.76.191.255
60.13.0.0-60.13.63.255
60.164.0.0-60.165.255.255
61.128.0.0-61.128.0.255
61.134.64.0-61.134.95.255
61.159.64.0-61.159.127.255
61.178.0.0-61.178.255.255
61.232.236.0-61.232.243.255
61.234.0.0-61.234.156.255
61.237.26.0-61.237.95.255
61.241.160.0-61.241.175.255
117.75.160.0-117.75.223.255
117.101.128.0-117.101.128.255
118.205.0.0-118.205.255.255
121.100.160.0-121.100.160.255
125.74.0.0-125.76.127.255
159.226.136.0-159.226.138.255
202.38.126.224-202.38.127.191
202.97.16.0-202.97.66.255
202.100.64.0-202.100.95.255
202.136.224.0-202.136.239.255
202.201.0.0-202.201.111.255
210.12.32.0-210.12.187.255
210.26.0.0-210.26.127.255
210.53.193.0-210.53.195.50
210.72.51.0-210.72.51.255
210.75.249.0-210.75.249.255
210.77.64.0-210.77.79.255
210.82.198.0-210.82.198.255
211.92.248.0-211.92.255.255
211.98.121.0-211.98.248.255
211.139.80.0-211.139.95.255
211.165.192.0-211.165.192.255
218.30.167.0-218.30.167.255
218.203.160.0-218.203.223.255
219.243.231.0-219.243.231.255
219.246.0.0-219.246.255.255
220.192.200.0-220.192.203.255
220.200.139.0-220.200.147.255
220.205.85.0-220.205.88.255
221.7.32.0-221.7.63.255
222.23.0.0-222.23.191.255
222.57.0.0-222.57.127.255
58.60.0.0-58.63.255.255
58.66.232.0-58.66.239.255
58.82.96.0-58.82.103.255
58.99.190.0-58.99.191.255
58.194.8.0-58.194.31.255
58.206.32.0-58.207.143.255
58.248.0.0-58.255.255.255
59.32.0.0-59.43.255.255
59.107.0.0-59.107.255.255
59.191.82.0-59.191.95.255
60.204.128.0-60.205.143.255
61.26.103.0-61.26.103.255
61.28.0.0-61.29.240.255
61.140.0.0-61.146.255.255
61.232.127.0-61.232.132.255
61.234.96.0-61.235.131.255
61.242.0.0-61.242.127.255
116.4.0.0-116.7.255.255
116.16.0.0-116.31.255.255
116.56.0.0-116.56.105.255
116.60.11.0-116.62.63.255
116.76.0.0-116.77.255.255
116.199.0.0-116.199.127.255
116.215.11.0-116.216.107.255
116.254.199.52-116.254.201.255
117.48.235.0-117.48.235.255
117.75.147.0-117.75.147.255
117.121.0.0-117.121.127.255
118.24.193.0-118.24.221.255
118.144.128.0-118.144.128.255
118.147.0.0-118.147.127.255
118.192.0.0-118.192.127.255
119.32.20.0-119.32.31.255
119.38.133.0-119.38.162.255
119.40.128.0-119.40.255.255
119.120.0.0-119.122.255.255
119.125.0.0-119.125.255.255
119.128.0.0-119.128.255.255
119.147.96.0-119.147.98.255
121.8.0.0-121.15.255.255
121.32.0.0-121.36.255.255
121.40.0.0-121.40.23.255
121.51.0.0-121.51.125.255
121.55.52.0-121.55.55.255
121.201.0.0-121.201.255.255
122.0.128.0-122.0.255.255
122.8.32.0-122.9.187.255
122.11.62.0-122.11.62.255
122.48.81.0-122.48.115.255
122.51.0.0-122.51.255.255
122.198.0.0-122.198.31.255
123.49.160.0-123.49.255.255
123.57.192.0-123.65.159.255
123.151.33.0-123.151.80.255
123.242.0.0-123.242.65.255
123.249.128.0-123.249.155.255
123.253.0.0-123.253.10.255
124.15.62.0-124.15.88.255
124.20.112.0-124.21.191.255
124.29.0.0-124.29.127.255
124.40.128.0-124.40.191.255
124.172.129.0-124.173.255.255
124.240.0.0-124.240.127.255
124.248.42.0-124.248.127.255
125.31.192.0-125.31.255.255
125.88.0.0-125.95.255.255
125.169.0.0-125.169.255.255
125.171.0.0-125.171.255.255
125.216.0.0-125.218.255.255
159.226.144.0-159.226.242.255
202.38.140.0-202.38.172.255
202.41.152.0-202.41.159.255
202.70.0.0-202.70.31.255
202.74.8.0-202.74.15.255
202.90.0.0-202.90.3.255
202.93.0.0-202.93.3.255
202.96.128.0-202.97.64.255
202.103.128.0-202.105.255.255
202.112.48.0-202.112.55.255
202.116.0.0-202.116.255.255
202.131.208.0-202.131.223.255
202.149.184.0-202.149.184.255
202.168.69.0-202.168.190.255
202.173.224.0-202.173.255.255
202.189.80.0-202.189.80.255
202.192.0.0-202.192.255.255
203.86.0.0-203.86.31.255
203.88.32.0-203.88.221.255
203.91.32.0-203.91.63.255
203.93.0.0-203.93.255.255
203.99.80.0-203.99.95.255
203.118.192.0-203.118.218.255
203.128.96.0-203.128.127.255
203.132.32.0-203.132.63.255
203.175.128.0-203.175.157.255
203.207.171.0-203.208.19.255
210.5.0.0-210.5.31.255
210.12.9.0-210.14.254.255
210.21.0.0-210.22.35.255
210.25.252.1-210.25.255.255
210.38.0.0-210.39.255.255
210.51.121.0-210.53.201.255
210.72.0.0-210.78.95.255
210.83.32.0-210.83.255.255
210.156.110.0-210.156.110.255
210.185.192.0-210.186.24.255
211.66.32.0-211.66.255.255
211.88.4.0-211.88.4.255
211.95.192.0-211.98.175.255
211.136.12.0-211.136.255.255
211.139.128.0-211.139.255.255
211.146.208.0-211.148.223.255
211.152.65.0-211.152.190.255
211.154.62.0-211.156.255.255
211.159.0.0-211.163.79.255
211.167.0.0-211.167.31.255
218.13.0.0-218.21.70.106
218.30.18.0-218.30.130.255
218.97.177.0-218.97.239.255
218.104.160.0-218.104.199.255
218.106.128.0-218.107.63.255
218.192.0.0-218.192.255.255
218.204.160.0-218.204.255.255
218.240.64.0-218.241.63.255
218.246.232.0-218.247.63.255
219.128.0.0-219.137.255.255
219.222.0.0-219.223.255.255
219.227.0.0-219.227.255.255
219.232.160.0-219.232.191.255
219.234.96.0-219.235.223.255
219.243.239.0-219.243.242.255
220.112.0.0-220.115.167.255
220.154.128.0-220.154.220.255
220.192.32.0-220.192.63.255
220.198.0.0-220.199.255.255
220.205.90.0-220.205.207.255
220.207.24.0-220.207.219.255
220.231.128.0-220.231.255.255
220.242.0.0-220.243.39.255
220.249.192.0-220.249.255.255
221.4.0.0-221.5.127.255
221.133.227.0-221.133.237.255
221.172.0.0-221.172.255.255
222.16.8.0-222.17.175.255
222.50.0.0-222.50.255.255
222.125.0.0-222.126.166.255
222.200.0.0-222.203.191.255
222.248.0.0-222.248.255.255
58.59.128.0-58.59.255.255
58.66.208.0-58.67.159.255
58.82.0.0-58.83.31.255
59.107.96.0-59.107.127.255
59.111.129.0-59.111.180.255
59.155.0.0-59.155.175.255
59.191.65.0-59.191.127.255
61.29.201.0-61.29.239.255
61.139.192.0-61.139.255.255
61.232.150.0-61.232.155.255
61.234.32.0-61.235.195.255
61.240.224.0-61.241.191.255
116.1.0.0-116.1.255.255
116.8.0.0-116.11.255.255
116.252.0.0-116.253.255.255
121.31.0.0-121.31.255.255
122.13.31.0-122.13.207.255
122.15.16.0-122.15.31.255
123.150.0.0-123.151.14.255
123.249.56.0-123.249.63.255
124.173.0.0-124.173.176.255
124.226.0.0-124.227.255.255
125.73.0.0-125.73.255.255
125.217.0.0-125.217.7.255
125.254.128.0-125.254.175.255
202.97.21.0-202.97.40.58
202.103.192.0-202.103.255.255
202.193.0.0-202.193.255.255
203.88.223.0-203.88.223.255
203.91.96.0-203.91.111.255
203.93.187.128-203.93.187.255
210.12.18.0-210.14.251.255
210.36.0.0-210.36.255.255
210.52.99.0-210.53.125.255
210.75.128.0-210.75.159.255
211.89.152.0-211.89.153.255
211.97.64.0-211.98.173.255
211.136.17.0-211.136.20.255
211.138.240.0-211.138.255.255
211.146.126.0-211.146.126.255
211.160.204.0-211.160.207.255
211.163.88.0-211.163.93.255
218.21.64.0-218.21.127.255
218.65.128.0-218.65.255.255
218.204.0.0-218.204.63.255
219.159.64.0-219.159.255.255
219.232.64.0-219.232.94.255
219.234.32.0-219.234.47.255
219.243.240.0-219.243.240.255
220.173.0.0-220.173.255.255
220.192.20.0-220.192.23.255
220.200.112.0-220.200.244.255
220.207.4.0-220.207.244.255
221.7.128.0-221.7.255.255
222.52.0.0-222.52.255.255
222.83.128.0-222.84.255.255
222.203.0.0-222.203.255.255
222.216.0.0-222.218.255.255
222.223.222.0-222.223.223.255
58.16.0.0-58.16.255.255
58.42.0.0-58.42.255.255
58.82.251.0-58.82.251.255
59.51.119.0-59.51.255.255
59.63.224.0-59.63.231.255
61.159.128.0-61.159.191.255
61.189.128.0-61.189.255.255
61.236.165.0-61.236.207.255
61.243.32.0-61.243.54.255
119.0.0.0-119.1.255.255
121.36.188.0-121.36.190.255
121.49.192.0-121.49.207.255
123.249.0.0-123.249.64.255
159.226.151.0-159.226.151.255
202.97.69.0-202.98.223.255
202.100.202.65-202.101.95.255
203.88.222.0-203.88.222.255
203.93.219.0-203.93.219.127
210.14.247.0-210.14.250.255
210.40.0.0-210.40.175.255
211.83.160.0-211.83.175.255
211.92.136.0-211.92.143.255
211.98.139.0-211.98.139.255
211.139.0.0-211.139.15.255
211.146.127.0-211.146.127.255
211.160.242.0-211.160.242.255
218.86.128.0-218.86.255.255
218.194.224.0-218.194.255.255
218.201.192.0-218.201.255.255
219.129.78.228-219.129.78.230
219.141.0.0-219.141.131.255
219.151.0.0-219.151.31.255
219.243.237.0-219.243.237.255
220.171.192.0-220.172.255.255
220.192.184.0-220.192.187.255
220.197.176.0-220.197.222.255
221.13.0.0-221.13.63.255
222.19.128.0-222.19.191.255
222.54.0.0-222.54.255.255
222.85.128.0-222.87.255.255
222.198.192.0-222.198.251.255
58.66.194.0-58.66.206.255
59.49.128.0-59.50.243.255
59.107.57.0-59.107.79.255
59.151.48.0-59.151.53.255
60.13.64.0-60.13.127.255
61.133.245.134-61.133.245.170
61.186.0.0-61.186.63.255
61.235.224.0-61.235.238.255
61.240.240.0-61.240.247.255
61.243.124.0-61.243.127.255
116.13.0.0-116.13.7.255
121.58.0.0-121.58.127.255
123.66.6.0-123.66.6.255
124.66.0.0-124.66.127.255
124.172.190.0-124.172.190.255
124.225.0.0-124.225.255.255
125.72.128.0-125.72.136.255
125.217.64.0-125.217.115.255
202.100.192.0-202.100.255.255
203.207.176.0-203.207.176.255
210.14.186.0-210.14.255.255
210.37.0.0-210.37.255.255
210.52.95.0-210.53.207.255
210.72.56.0-210.72.56.255
210.168.1.0-210.168.1.255
211.97.96.0-211.97.103.255
211.138.160.0-211.138.175.255
211.163.89.0-211.163.89.255
218.77.128.0-218.77.255.255
218.92.19.14-218.93.252.154
219.243.241.0-219.243.241.255
220.174.0.0-220.174.255.255
220.192.24.0-220.192.27.255
220.200.96.0-220.200.111.255
220.207.180.0-220.207.181.255
221.11.128.0-221.11.223.255
221.199.224.0-221.199.255.255
222.17.176.0-222.17.255.255
222.61.0.0-222.61.127.255
58.83.156.0-58.83.156.255
58.207.224.0-58.207.247.255
59.67.192.0-59.67.247.255
60.0.0.0-60.10.255.255
60.24.131.0-60.26.254.255
60.28.58.26-60.28.61.62
60.30.96.0-60.30.96.255
61.55.0.0-61.55.255.255
61.133.214.226-61.134.191.255
61.159.0.0-61.159.63.255
61.181.112.0-61.182.255.255
61.232.23.0-61.235.159.255
61.237.16.0-61.237.224.255
61.240.128.0-61.240.159.255
116.216.0.0-116.216.214.255
117.11.124.0-117.11.124.255
118.25.136.0-118.25.253.255
119.81.0.0-119.81.255.255
121.16.0.0-121.29.255.255
121.36.20.0-121.36.63.255
121.40.24.0-121.40.215.255
121.42.0.0-121.43.255.255
121.70.88.0-121.70.127.255
121.193.192.0-121.193.255.255
121.195.192.0-121.195.255.255
122.0.64.0-122.0.127.255
123.56.128.0-123.56.252.255
123.180.0.0-123.183.255.255
124.196.139.0-124.196.184.255
124.236.0.0-124.240.104.255
124.249.141.0-124.249.165.255
125.36.144.0-125.36.144.255
125.67.64.13-125.67.64.18
159.226.157.0-159.226.157.255
202.8.128.0-202.8.159.255
202.99.86.0-202.99.191.255
202.107.194.50-202.107.194.66
202.113.112.0-202.113.127.255
202.152.180.0-202.152.180.255
202.180.128.0-202.180.159.255
202.206.0.0-202.207.127.255
203.135.96.0-203.135.111.255
203.187.172.0-203.187.172.255
210.12.14.0-210.12.238.255
210.31.192.0-210.31.255.255
210.52.11.0-210.52.230.255
210.73.39.0-210.73.39.255
210.82.53.185-210.82.255.255
211.68.124.0-211.68.191.255
211.81.64.0-211.82.255.255
211.90.8.0-211.90.71.255
211.94.33.0-211.94.248.219
211.98.15.0-211.99.64.72
211.138.0.0-211.138.15.255
211.143.48.0-211.143.143.255
211.146.66.0-211.146.87.255
211.151.239.0-211.152.196.255
211.161.48.0-211.161.51.255
211.163.40.0-211.163.47.255
211.166.126.0-211.166.151.255
218.11.0.0-218.12.255.255
218.67.244.250-218.69.224.78
218.106.180.0-218.106.180.255
218.207.64.0-218.207.67.255
218.246.232.0-218.246.237.255
219.148.0.0-219.148.159.255
219.150.32.0-219.150.102.210
219.226.128.0-219.226.255.255
219.243.64.0-219.243.226.255
220.192.73.0-220.192.79.255
220.194.192.0-220.196.78.255
220.205.64.0-220.205.73.255
221.123.152.0-221.123.152.255
221.173.0.0-221.173.23.255
221.192.0.0-221.198.238.255
221.238.0.231-221.239.48.255
222.30.136.0-222.30.255.255
222.36.0.242-222.36.121.255
222.38.0.0-222.38.249.255
222.222.0.0-222.223.240.255
58.207.200.0-58.207.223.255
59.39.146.73-59.39.146.78
59.53.172.146-59.53.172.150
59.69.128.0-59.70.255.255
60.194.42.130-60.194.42.255
61.52.0.0-61.54.255.255
61.133.252.0-61.133.252.255
61.136.64.0-61.136.216.25
61.146.40.186-61.146.42.6
61.158.128.0-61.158.255.255
61.163.0.0-61.163.255.255
61.168.0.0-61.168.255.255
61.232.145.0-61.233.127.255
61.242.192.0-61.242.223.255
116.255.128.0-116.255.255.255
121.41.0.0-121.41.3.255
122.78.0.0-122.78.187.255
122.112.0.0-122.115.255.255
122.206.0.0-122.206.191.255
123.4.0.0-123.15.255.255
123.52.0.0-123.55.255.255
123.96.168.0-123.96.168.255
123.101.0.0-123.101.255.255
123.149.0.0-123.149.255.255
123.160.0.0-123.163.255.255
124.240.128.0-124.240.191.255
125.40.0.0-125.47.255.255
125.93.48.42-125.93.72.70
125.219.0.0-125.219.171.255
202.102.224.0-202.102.255.255
202.110.64.0-202.111.159.255
202.196.0.0-202.197.218.255
203.93.116.0-203.93.183.255
203.171.224.0-203.171.239.255
210.12.4.0-210.12.129.255
210.42.142.0-210.43.147.255
210.51.248.0-210.52.59.255
210.76.0.0-210.76.31.255
210.82.248.0-210.82.248.255
211.67.80.0-211.67.191.255
211.69.0.0-211.69.223.255
211.84.0.0-211.84.255.255
211.91.67.185-211.91.215.255
211.98.106.0-211.98.237.255
211.138.16.0-211.138.31.255
211.142.96.0-211.142.207.255
211.146.104.0-211.146.111.255
211.152.191.0-211.152.191.255
211.161.128.0-211.161.143.255
211.163.28.0-211.163.29.255
211.165.254.0-211.165.255.255
211.167.88.145-211.167.88.149
218.14.76.126-218.15.47.47
218.27.99.177-218.29.255.255
218.62.64.190-218.62.121.70
218.94.10.42-218.94.10.75
218.106.130.70-218.106.131.66
218.196.160.0-218.196.255.255
218.198.0.0-218.198.255.255
218.206.192.0-218.206.255.255
218.246.224.0-218.246.239.255
219.72.60.0-219.72.60.255
219.147.41.2-219.148.140.188
219.150.32.102-219.150.255.255
219.154.0.0-219.158.193.255
219.243.245.0-219.243.245.255
220.114.64.0-220.114.71.255
220.179.38.70-220.179.38.122
220.192.144.0-220.192.151.255
220.202.64.0-220.202.95.255
220.205.110.0-220.205.113.255
220.207.76.0-220.207.147.255
221.4.230.10-221.4.230.94
221.13.128.0-221.15.255.255
221.176.128.0-221.176.237.255
222.15.78.0-222.15.78.255
222.21.0.0-222.22.223.255
222.40.4.0-222.40.255.255
222.55.128.0-222.55.255.255
222.60.128.0-222.60.255.255
222.85.0.0-222.86.166.255
222.88.0.0-222.89.255.255
222.136.0.0-222.143.255.255
222.161.3.3-222.161.3.53
222.167.134.0-222.167.134.255
58.155.0.0-58.155.103.255
58.194.0.0-58.194.127.255
60.11.0.0-60.11.255.255
60.14.0.0-60.15.255.255
60.218.0.0-60.219.255.255
60.252.0.0-60.252.255.255
61.47.128.0-61.47.191.255
61.138.0.0-61.138.63.255
61.158.0.0-61.158.200.255
61.167.0.0-61.167.255.255
61.180.128.0-61.180.255.255
61.232.176.0-61.233.191.255
61.236.80.0-61.237.223.255
61.243.192.0-61.243.223.255
116.212.160.0-116.212.175.255
122.64.71.0-122.64.88.255
122.156.0.0-122.159.255.255
123.164.0.0-123.167.255.255
125.58.128.0-125.58.255.255
125.211.0.0-125.211.255.255
125.223.0.0-125.223.127.255
159.226.160.0-159.226.160.255
202.63.248.0-202.63.251.255
202.97.56.0-202.97.255.255
202.118.128.0-202.118.255.255
202.180.231.0-202.180.231.255
202.198.106.0-202.198.111.255
203.90.128.0-203.90.221.255
203.93.125.0-203.93.215.255
210.2.0.0-210.2.31.255
210.12.30.0-210.13.79.255
210.46.0.0-210.47.127.255
210.52.28.0-210.52.194.255
210.74.94.0-210.74.121.255
210.76.32.0-210.76.63.255
210.82.132.0-210.83.63.255
211.93.24.0-211.93.140.186
211.98.90.0-211.98.240.255
211.137.224.0-211.137.255.255
211.145.84.0-211.145.84.255
211.152.194.0-211.152.194.255
211.154.48.0-211.154.48.255
211.160.140.0-211.160.143.255
211.163.9.0-211.163.15.255
218.7.0.0-218.10.255.255
218.30.250.0-218.30.250.255
218.97.192.0-218.97.223.255
218.203.0.0-218.203.95.255
218.244.192.0-218.244.207.255
218.246.160.0-218.246.191.255
219.147.64.0-219.147.255.255
219.217.192.0-219.217.207.255
219.235.64.0-219.235.127.255
219.239.36.128-219.239.36.191
219.243.255.0-219.243.255.255
220.192.216.0-220.192.223.255
220.201.192.0-220.201.255.255
220.207.184.0-220.207.187.255
221.206.0.0-221.212.255.255
222.27.128.0-222.27.255.255
222.32.0.0-222.32.255.255
222.56.128.0-222.57.255.255
222.92.4.216-222.92.4.223
222.170.0.0-222.172.127.255
58.19.0.0-58.19.255.255
58.48.0.0-58.55.255.255
58.195.0.0-58.195.7.255
58.198.155.0-58.198.155.255
58.207.144.0-58.207.159.255
59.68.0.0-59.69.127.255
59.71.128.0-59.71.255.255
59.172.0.0-59.175.255.255
61.29.194.0-61.29.194.255
61.136.130.0-61.136.255.255
61.183.0.0-61.184.255.255
61.232.204.0-61.235.33.255
61.242.160.0-61.242.191.255
116.207.0.0-116.211.255.255
116.214.240.0-116.214.240.255
116.216.240.0-116.216.243.255
118.21.44.0-118.21.44.255
118.25.44.0-118.25.44.255
119.36.0.0-119.36.255.255
119.96.0.0-119.96.255.255
121.40.224.0-121.41.238.255
121.60.0.0-121.63.255.255
122.48.0.0-122.48.1.255
122.82.8.0-122.82.164.255
122.86.12.0-122.86.12.255
122.204.0.0-122.204.223.255
123.57.127.0-123.57.127.255
123.253.113.0-123.253.113.255
124.156.0.0-124.156.3.255
124.240.98.0-124.240.98.255
125.220.0.0-125.221.127.255
159.226.124.0-159.226.163.255
202.94.9.0-202.94.9.255
202.97.35.66-202.97.67.255
202.103.0.0-202.103.63.255
202.110.128.0-202.110.191.255
202.112.20.0-202.112.20.255
202.114.22.197-202.114.255.255
202.127.146.0-202.127.159.255
202.197.128.0-202.197.175.255
202.205.48.0-202.205.63.255
203.93.5.0-203.93.239.255
203.100.32.0-203.100.47.255
203.207.166.0-203.208.7.255
210.5.20.0-210.5.143.255
210.12.16.0-210.12.236.255
210.22.202.0-210.22.205.255
210.42.0.0-210.42.175.255
210.51.200.0-210.53.6.255
210.72.44.0-210.72.44.255
210.74.126.0-210.74.136.255
210.76.195.0-210.77.246.255
211.67.0.0-211.67.79.255
211.69.144.0-211.69.191.255
211.85.0.0-211.85.215.255
211.91.120.0-211.91.183.255
211.98.102.0-211.99.64.255
211.137.48.0-211.137.79.255
211.146.33.0-211.147.223.255
211.151.128.0-211.151.129.255
211.154.55.0-211.154.57.255
211.156.130.0-211.156.139.255
211.161.120.0-211.163.26.255
218.28.43.0-218.28.44.255
218.75.20.56-218.75.20.59
218.104.96.0-218.104.111.255
218.106.112.0-218.106.127.255
218.197.0.0-218.197.191.255
218.199.0.0-218.200.159.255
218.246.33.0-218.246.237.255
219.72.62.0-219.72.199.255
219.138.0.0-219.140.255.255
219.159.159.206-219.159.241.71
219.243.243.0-219.243.243.255
220.112.208.0-220.115.223.255
220.192.135.0-220.192.143.255
220.202.0.0-220.203.63.255
220.205.224.0-220.205.231.255
220.207.136.0-220.207.159.255
220.249.64.0-220.249.127.255
221.2.195.194-221.2.195.198
221.123.64.0-221.123.79.255
221.232.0.0-221.235.255.255
222.20.128.0-222.21.250.255
222.42.0.0-222.42.255.255
222.240.165.132-222.240.165.134
58.20.0.0-58.20.255.255
58.44.0.0-58.47.255.255
58.207.120.0-58.207.255.255
59.46.48.0-59.46.191.255
59.51.0.0-59.51.118.255
59.71.0.0-59.71.127.255
59.155.192.0-59.155.255.255
59.191.70.0-59.191.71.255
60.17.129.0-60.17.140.255
60.190.238.161-60.190.238.178
60.205.240.0-60.205.240.255
61.29.242.0-61.29.255.255
61.137.0.0-61.137.127.255
61.150.128.0-61.150.255.255
61.155.57.21-61.155.65.66
61.186.64.0-61.187.255.255
61.232.143.0-61.232.148.255
61.234.228.0-61.237.143.255
61.240.232.0-61.242.216.37
116.216.128.0-116.216.176.0
117.45.224.0-117.45.255.255
118.126.65.0-118.126.197.255
118.248.0.0-118.249.255.255
119.39.0.0-119.39.255.255
121.46.128.0-121.46.194.255
121.51.196.0-121.51.255.255
121.71.0.0-121.71.60.255
122.7.52.0-122.7.52.255
122.13.224.0-122.13.224.255
122.48.119.0-122.48.126.255
122.51.64.0-122.51.96.255
122.186.0.0-122.186.255.255
122.207.0.0-122.207.63.255
123.56.64.0-123.56.64.255
123.68.0.0-123.69.15.255
123.253.76.0-123.253.221.255
124.23.45.0-124.23.45.255
124.147.128.0-124.147.177.255
124.228.0.0-124.233.255.255
125.39.0.0-125.39.0.255
125.221.128.0-125.221.255.255
159.226.152.0-159.226.152.255
202.103.64.0-202.103.127.255
202.197.0.0-202.197.255.255
203.93.208.0-203.93.211.255
210.12.59.0-210.13.83.255
210.15.30.0-210.15.30.255
210.22.48.0-210.22.62.255
210.42.176.0-210.43.255.255
210.52.81.0-210.53.56.255
210.168.71.0-210.168.71.255
211.67.208.0-211.67.255.255
211.69.48.0-211.69.255.255
211.85.216.0-211.85.255.255
211.91.216.0-211.91.247.255
211.98.62.0-211.98.172.255
211.138.224.0-211.138.239.255
211.142.208.0-211.143.47.255
211.146.240.0-211.146.247.255
211.161.116.0-211.161.119.255
218.75.128.0-218.77.127.255
218.104.144.0-218.104.159.255
218.196.0.0-218.196.159.255
219.72.104.0-219.72.238.255
219.159.159.156-219.159.241.148
219.243.244.0-219.243.244.255
220.154.230.0-220.154.230.255
220.159.242.0-220.159.242.255
220.168.0.0-220.170.255.255
220.176.216.31-220.176.216.40
220.192.152.0-220.192.159.255
220.202.96.0-220.202.255.255
220.205.176.0-220.205.183.255
220.207.220.0-220.207.235.255
220.248.160.0-220.248.191.255
222.21.212.0-222.22.255.255
222.36.128.0-222.36.255.255
222.38.250.0-222.40.3.255
222.42.157.0-222.42.159.255
222.47.121.0-222.48.95.255
222.51.0.0-222.51.255.255
222.58.128.0-222.58.255.255
222.240.0.0-222.247.255.255
58.21.0.0-58.21.255.255
58.155.128.0-58.155.167.255
58.244.0.0-58.245.255.255
59.72.0.0-59.73.255.255
61.138.128.0-61.139.191.255
61.161.1.0-61.161.63.255
61.232.169.0-61.232.174.255
61.235.48.0-61.235.63.255
61.237.12.0-61.237.20.255
61.243.224.0-61.243.255.255
118.88.0.0-118.88.255.255
118.244.64.0-118.245.66.255
121.69.0.0-121.70.63.255
122.10.0.0-122.10.127.255
122.12.140.0-122.12.255.255
122.15.32.0-122.15.62.255
122.69.82.0-122.69.221.255
122.136.0.0-122.143.255.255
122.248.48.0-122.248.63.255
123.57.157.0-123.57.157.255
123.172.0.0-123.173.255.255
123.190.85.0-123.190.85.255
124.200.224.0-124.200.235.255
124.234.0.0-124.235.255.255
125.32.0.0-125.32.255.255
125.222.192.0-125.223.255.255
159.226.122.0-159.226.165.255
202.38.164.0-202.38.167.255
202.97.38.0-202.98.31.255
202.111.160.0-202.111.191.255
202.181.112.0-202.181.127.255
202.198.0.0-202.198.255.255
203.93.111.31-203.93.187.63
210.12.11.0-210.13.74.255
210.47.0.0-210.47.63.255
210.52.51.0-210.52.191.255
210.82.166.0-210.83.56.255
211.79.141.41-211.79.141.42
211.93.64.0-211.93.79.255
211.98.84.0-211.98.191.255
211.137.208.0-211.137.223.255
211.140.209.0-211.141.79.255
211.146.124.0-211.146.124.255
211.149.0.0-211.149.255.255
211.165.37.0-211.165.37.255
218.27.0.0-218.27.255.255
218.62.0.0-218.62.127.255
219.131.221.66-219.131.221.76
219.149.192.0-219.150.31.255
219.217.0.0-219.217.127.255
219.243.254.0-219.243.254.255
220.192.240.0-220.192.247.255
220.201.153.0-220.201.191.255
221.8.0.0-221.9.255.255
221.122.128.0-221.122.185.255
222.27.0.0-222.27.159.255
222.34.0.0-222.34.255.255
222.39.80.0-222.39.80.152
222.62.224.0-222.62.224.255
222.160.0.0-222.163.255.255
222.168.0.0-222.169.255.255
58.67.180.0-58.67.247.255
58.192.0.0-58.193.255.255
58.207.96.0-58.223.255.255
58.240.0.0-58.241.255.255
60.204.208.0-60.205.31.255
61.29.146.0-61.29.147.255
61.132.0.0-61.132.127.255
61.147.0.0-61.147.255.255
61.155.0.0-61.155.255.255
61.160.0.0-61.160.255.255
61.177.0.0-61.177.255.255
61.232.46.0-61.232.116.255
61.237.68.0-61.237.175.255
61.241.0.0-61.241.63.255
117.60.0.0-117.63.255.255
117.76.135.0-117.76.135.255
117.78.128.0-117.95.255.255
118.147.129.0-118.147.154.255
121.41.160.0-121.41.255.255
121.55.51.0-121.55.63.255
121.224.0.0-121.239.255.255
121.248.0.0-121.248.71.255
122.86.169.0-122.97.255.255
122.192.0.0-122.195.255.255
123.56.43.0-123.57.121.255
123.132.75.0-123.132.75.255
123.253.68.0-123.253.127.255
124.20.80.0-124.20.80.255
124.71.128.0-124.71.179.255
124.173.152.0-124.173.155.255
124.220.0.0-124.223.255.255
159.226.71.0-159.226.121.255
202.38.2.0-202.38.143.255
202.92.0.0-202.92.3.255
202.97.26.0-202.97.27.255
202.102.0.0-202.102.127.255
202.111.0.0-202.111.127.255
202.119.64.0-202.119.255.255
202.127.12.0-202.127.15.255
202.160.168.0-202.160.168.255
202.195.0.0-202.195.255.255
203.93.134.0-203.93.243.255
203.135.112.4-203.135.118.255
203.191.146.0-203.191.146.255
210.12.27.0-210.13.95.255
210.15.6.0-210.16.191.255
210.22.36.0-210.22.219.255
210.28.0.0-210.29.239.255
210.51.192.0-210.53.108.255
210.72.74.0-210.74.241.255
210.78.27.0-210.78.31.255
210.185.200.0-210.185.200.255
211.65.0.0-211.65.255.255
211.70.0.0-211.70.255.255
211.87.0.0-211.87.127.255
211.89.32.0-211.90.212.255
211.98.23.99-211.98.148.255
211.100.134.0-211.100.143.255
211.103.0.0-211.103.127.255
211.138.192.0-211.139.127.255
211.143.224.0-211.143.255.255
211.146.224.0-211.146.231.255
211.148.64.0-211.148.127.255
211.152.224.0-211.152.255.255
211.156.180.227-211.156.191.255
211.160.180.0-211.160.183.255
211.162.16.0-211.164.16.255
211.167.130.0-211.167.139.255
218.1.99.185-218.4.255.255
218.30.129.0-218.30.138.255
218.90.0.0-218.94.255.255
218.104.32.0-218.107.255.255
218.205.0.0-218.206.159.255
218.244.176.0-218.244.191.255
219.72.132.0-219.72.164.255
219.219.0.0-219.219.239.255
219.230.0.0-219.230.255.255
219.235.12.0-219.235.12.255
219.243.246.0-219.243.246.255
220.114.87.0-220.114.127.255
220.192.96.0-220.192.111.255
220.195.125.0-220.197.19.255
220.200.220.0-220.200.220.255
220.207.96.0-220.207.111.255
221.6.0.0-221.6.255.255
221.12.21.4-221.12.21.28
221.122.0.0-221.122.0.255
221.130.0.0-221.131.191.255
221.174.128.0-221.174.255.255
221.224.0.0-221.231.255.255
222.45.0.0-222.45.255.255
222.49.128.0-222.49.255.255
222.56.248.0-222.56.255.255
222.59.128.0-222.59.255.255
222.73.227.181-222.73.227.188
222.92.0.0-222.95.255.255
222.184.0.0-222.195.175.255
58.17.0.0-58.17.127.255
58.66.128.0-58.67.127.255
58.82.128.0-58.82.223.255
59.50.244.0-59.50.255.255
59.52.0.0-59.55.255.255
59.62.0.0-59.63.239.255
59.111.71.0-59.111.124.255
60.200.0.0-60.205.130.255
61.131.128.0-61.132.135.108
61.145.71.252-61.145.119.59
61.180.0.0-61.180.127.255
61.190.90.10-61.191.20.238
61.233.208.0-61.233.255.255
61.235.0.0-61.235.35.255
61.242.128.0-61.242.159.255
116.204.19.0-116.204.20.255
116.215.67.0-116.216.210.255
117.21.0.0-117.21.255.255
117.40.0.0-117.45.223.255
117.48.44.0-117.48.60.255
117.51.0.0-117.51.255.255
117.76.192.0-117.76.243.255
117.127.16.0-117.127.255.255
118.147.128.0-118.147.255.255
118.212.0.0-118.212.255.255
121.36.113.0-121.36.127.255
121.51.150.0-121.51.157.255
121.55.11.0-121.55.31.255
121.68.128.0-121.68.255.255
121.192.128.0-121.192.135.255
122.8.96.0-122.8.255.255
122.13.70.0-122.13.123.255
122.17.64.0-122.17.127.255
123.56.233.0-123.56.245.255
124.172.192.0-124.172.255.255
124.248.2.0-124.248.23.255
202.97.22.0-202.97.22.255
202.101.192.0-202.101.255.255
202.109.128.0-202.109.191.255
202.127.125.0-202.127.125.255
210.15.13.0-210.15.109.255
210.22.206.0-210.22.253.255
210.35.0.0-210.35.255.255
210.51.228.0-210.51.228.255
210.53.8.0-210.53.10.255
211.89.128.0-211.89.129.255
211.91.248.0-211.92.7.255
211.98.46.0-211.98.251.255
211.138.208.0-211.138.223.255
211.141.80.0-211.141.159.255
211.146.88.0-211.146.128.20
211.161.112.0-211.163.200.255
211.167.138.0-211.167.138.255
218.64.0.0-218.65.127.255
218.87.0.0-218.87.255.255
218.95.0.0-218.95.127.255
218.193.192.0-218.193.237.152
218.204.64.0-218.204.159.255
219.136.71.8-219.136.71.15
219.220.0.0-219.220.63.255
219.228.192.0-219.229.255.255
219.243.251.0-219.243.251.255
220.114.224.0-220.114.231.255
220.175.0.0-220.177.255.255
220.192.160.0-220.192.167.255
220.203.0.0-220.204.108.255
220.242.48.0-220.242.48.255
220.248.192.0-220.248.223.255
221.12.180.0-221.13.132.6
222.15.153.0-222.15.153.255
222.49.0.0-222.49.127.255
222.88.74.50-222.88.76.60
222.204.0.0-222.204.127.255
222.223.241.0-222.223.255.255
58.154.0.0-58.154.255.255
58.194.32.0-58.194.63.255
58.206.64.0-58.207.175.255
59.44.0.0-59.47.255.255
59.73.0.0-59.73.191.255
59.79.112.0-59.79.113.255
60.2.89.0-60.2.89.255
60.16.0.0-60.23.255.255
60.30.134.0-60.30.142.255
61.137.128.0-61.137.255.255
61.161.128.0-61.161.255.255
61.176.0.0-61.176.255.255
61.189.0.0-61.189.127.255
61.232.60.0-61.232.166.255
61.235.7.0-61.237.242.255
61.243.128.0-61.243.191.255
116.2.0.0-116.3.255.255
117.58.0.0-117.58.127.255
117.78.0.0-117.78.127.255
117.147.0.0-117.147.255.255
118.25.0.0-118.25.199.255
118.147.160.0-118.147.191.255
119.112.0.0-119.116.255.255
119.118.0.0-119.119.255.255
121.40.32.0-121.40.239.255
121.70.72.0-121.70.255.255
122.66.0.0-122.67.141.255
123.56.0.0-123.56.127.255
123.177.0.0-123.177.255.255
123.184.0.0-123.191.255.255
123.244.0.0-123.247.255.255
124.6.64.0-124.6.127.255
124.92.0.0-124.95.255.255
124.248.32.0-124.248.63.255
125.222.0.0-125.222.191.255
159.226.159.0-159.226.238.255
168.160.121.0-168.160.122.255
202.38.173.0-202.38.173.255
202.93.110.0-202.93.110.255
202.96.64.0-202.97.191.255
202.107.0.0-202.107.127.255
202.110.0.0-202.110.63.255
202.118.0.0-202.118.127.255
202.199.0.0-202.199.255.255
203.79.0.0-203.80.159.255
203.93.15.0-203.93.217.255
203.100.96.0-203.100.127.255
203.135.99.0-203.135.109.255
203.207.121.0-203.207.127.255
210.12.24.0-210.12.220.255
210.30.0.0-210.30.255.255
210.47.128.0-210.47.255.255
210.52.10.0-210.52.187.255
210.56.192.0-210.56.223.255
210.72.128.0-210.74.158.255
210.76.160.0-210.76.191.255
210.82.168.0-210.83.221.255
210.211.0.0-210.211.15.255
211.93.80.0-211.93.151.255
211.98.36.0-211.98.184.255
211.136.23.0-211.137.47.255
211.140.192.0-211.140.255.255
211.161.17.0-211.161.19.255
211.163.1.0-211.163.2.255
211.165.0.0-211.166.206.255
218.24.0.0-218.25.255.255
218.30.170.0-218.30.170.255
218.58.75.135-218.58.75.141
218.60.0.0-218.62.47.186
218.106.192.0-218.106.207.255
219.148.192.0-219.149.127.255
219.216.0.0-219.217.191.255
219.234.64.0-219.234.79.255
219.243.253.0-219.243.253.255
220.192.224.0-220.192.238.255
220.201.0.0-220.201.199.255
220.207.208.0-220.207.211.255
221.12.180.0-221.12.190.61
221.122.134.0-221.122.254.255
221.200.0.0-221.203.255.255
222.26.0.0-222.26.255.255
222.33.0.0-222.33.255.255
222.62.114.0-222.63.255.255
58.18.0.0-58.18.255.255
59.53.70.0-59.53.75.255
60.31.0.0-60.31.255.255
61.134.96.0-61.134.127.255
61.138.64.0-61.138.127.255
61.232.167.0-61.233.63.255
61.237.72.0-61.237.73.255
61.240.160.0-61.240.191.255
116.95.0.0-116.95.255.255
116.112.0.0-116.117.255.255
116.204.128.0-116.204.179.255
121.56.0.0-121.57.255.255
121.193.0.0-121.193.95.255
123.178.0.0-123.179.255.255
123.197.12.0-123.197.12.255
124.67.0.0-124.67.255.255
202.99.224.0-202.99.255.255
202.207.0.0-202.207.159.255
203.93.214.0-203.93.214.255
210.12.75.0-210.12.185.255
210.31.176.0-210.31.191.255
211.82.128.0-211.82.191.255
211.90.72.0-211.90.79.255
211.93.153.0-211.93.163.255
211.98.25.0-211.98.241.255
211.138.80.0-211.138.95.255
211.163.30.0-211.163.30.255
218.21.128.0-218.21.255.255
218.30.135.0-218.30.135.255
218.202.64.0-218.202.143.255
219.147.96.0-219.148.191.255
219.159.0.0-219.159.63.255
219.225.122.0-219.225.255.255
219.243.228.0-219.243.228.255
220.192.28.0-220.192.31.255
220.195.32.0-220.195.63.255
220.205.82.0-220.205.84.255
221.199.128.0-221.199.207.255
222.31.192.0-222.31.255.255
222.39.0.0-222.39.255.255
222.57.253.0-222.57.253.255
222.74.0.0-222.74.255.255
222.199.64.0-222.199.100.255
59.76.192.0-59.76.255.255
61.133.192.0-61.133.223.255
61.232.244.0-61.232.246.255
61.243.112.0-61.243.119.255
121.51.144.0-121.51.158.255
122.9.16.0-122.9.46.255
124.224.0.0-124.224.255.255
202.100.96.0-202.100.127.255
202.201.112.0-202.201.159.255
210.12.5.0-210.13.78.255
210.27.192.0-210.27.255.255
210.53.194.0-210.53.194.255
211.93.0.0-211.93.7.255
211.98.125.0-211.98.229.255
211.138.48.0-211.138.63.255
211.160.43.0-211.160.43.255
211.163.188.0-211.163.188.255
218.1.106.98-218.1.106.198
218.21.0.0-218.21.47.255
218.30.173.0-218.30.173.255
218.58.77.50-218.58.80.170
218.95.128.0-218.95.223.255
218.203.96.0-218.203.159.255
219.243.232.0-219.243.232.255
219.247.128.0-219.247.191.255
220.192.206.0-220.192.207.255
220.200.150.0-220.200.150.255
220.205.114.0-220.205.115.255
221.11.224.0-221.11.255.255
221.199.0.0-221.199.127.255
222.23.192.0-222.23.255.255
222.58.0.0-222.58.127.255
222.75.0.0-222.75.255.255
58.82.192.0-58.82.207.255
59.75.192.0-59.75.209.255
61.133.224.0-61.133.255.255
61.236.160.0-61.236.175.255
61.243.120.0-61.243.123.255
117.75.242.0-117.75.250.255
118.213.0.0-118.213.255.255
125.72.0.0-125.72.255.255
159.226.155.0-159.226.155.255
202.100.128.0-202.100.159.255
202.167.235.128-202.167.236.255
210.12.204.0-210.12.216.255
210.27.128.0-210.27.191.255
211.93.8.0-211.93.15.255
211.98.253.0-211.98.255.255
211.138.64.0-211.138.79.255
211.163.128.0-211.163.128.255
218.95.224.0-218.95.255.255
218.206.160.0-218.206.175.255
219.243.230.0-219.243.230.255
219.247.192.0-219.247.255.255
220.167.128.0-220.167.255.255
220.192.249.0-220.192.249.255
220.200.245.0-220.200.255.255
220.205.89.0-220.205.89.255
221.207.0.0-221.207.63.255
222.59.0.0-222.59.127.255
58.14.0.0-58.15.255.255
58.56.0.0-58.59.127.255
58.194.160.0-58.195.31.255
58.207.68.0-58.207.71.255
59.80.0.0-59.83.255.255
60.208.0.0-60.217.255.255
60.232.0.0-60.233.255.255
60.235.0.0-60.235.255.255
61.4.64.0-61.4.79.255
61.133.0.0-61.133.127.255
61.155.103.201-61.156.255.255
61.162.0.0-61.162.255.255
61.179.0.0-61.179.255.255
61.232.42.0-61.234.67.255
61.237.17.0-61.237.17.255
61.240.64.0-61.240.127.255
117.76.0.0-117.76.69.255
121.250.0.0-121.251.210.255
122.4.0.0-122.7.255.255
123.98.0.0-123.98.127.255
123.128.0.0-123.135.255.255
123.168.0.0-123.171.255.255
123.232.0.0-123.235.255.255
124.128.0.0-124.135.255.255
124.201.0.0-124.201.255.255
159.226.158.0-159.226.158.255
168.160.152.0-168.160.152.255
202.11.207.0-202.11.207.255
202.38.156.0-202.38.156.255
202.93.88.0-202.93.88.255
202.102.128.0-202.102.191.255
202.110.192.0-202.110.255.255
202.136.48.0-202.136.63.255
202.173.8.0-202.173.15.255
202.194.0.0-202.194.255.255
203.93.0.128-203.93.188.63
203.207.150.0-203.207.153.255
210.12.3.0-210.12.246.255
210.44.0.0-210.44.255.255
210.52.0.0-210.53.84.255
210.72.156.0-210.72.158.255
210.74.134.0-210.74.142.255
210.76.128.0-210.77.240.255
210.82.131.0-210.83.134.255
211.64.0.0-211.64.255.255
211.86.0.0-211.87.255.255
211.89.253.0-211.90.7.255
211.97.168.0-211.99.127.255
211.137.176.0-211.137.207.255
211.146.32.0-211.146.103.255
211.155.0.0-211.155.15.255
211.161.65.0-211.161.79.255
211.163.48.0-211.163.63.255
211.165.64.0-211.165.80.255
218.4.201.92-218.4.201.95
218.23.1.118-218.25.78.6
218.30.165.0-218.30.165.255
218.56.0.0-218.59.255.255
218.75.39.158-218.75.108.14
218.98.0.0-218.98.255.255
218.104.0.0-218.104.15.255
218.106.224.0-218.106.255.255
218.201.96.0-218.201.191.255
218.244.160.0-218.244.165.255
219.146.0.0-219.148.51.13
219.218.0.0-219.218.223.255
219.231.128.0-219.231.255.255
219.243.248.0-219.243.248.255
220.192.80.0-220.193.255.255
220.205.124.0-220.205.135.255
220.207.192.0-220.207.207.255
221.0.0.0-221.3.127.255
221.173.88.0-221.175.26.255
221.177.14.0-221.177.15.255
221.182.177.0-221.182.177.255
221.214.0.0-221.215.255.255
221.229.119.178-221.230.21.127
222.43.0.0-222.43.255.255
222.132.0.0-222.135.255.255
222.173.0.0-222.176.23.255
222.194.0.0-222.195.255.255
222.206.0.0-222.207.255.255
222.221.253.85-222.222.43.231
59.48.0.0-59.49.127.255
59.63.160.0-59.63.216.255
60.190.135.26-60.191.45.148
60.220.0.0-60.223.255.255
61.134.192.0-61.134.255.255
61.186.167.166-61.186.167.172
61.232.36.0-61.233.143.255
61.237.144.0-61.237.159.255
61.240.32.0-61.240.63.255
116.62.15.0-116.62.15.255
118.72.0.0-118.79.255.255
118.81.0.0-118.81.255.255
121.30.0.0-121.30.255.255
121.100.128.0-121.100.247.255
123.75.0.0-123.75.255.255
123.174.0.0-123.175.255.255
124.126.130.0-124.126.130.255
124.163.0.0-124.167.255.255
124.200.0.0-124.200.75.255
159.226.156.0-159.226.156.255
202.97.128.0-202.97.159.255
202.99.192.0-202.99.223.255
202.106.119.0-202.106.119.255
202.207.128.0-202.207.255.255
203.93.113.192-203.93.166.95
203.207.98.0-203.207.140.255
210.12.13.0-210.13.243.255
210.31.96.0-210.31.127.255
210.52.56.0-210.52.198.255
210.79.64.0-210.79.127.255
210.82.138.0-210.82.251.255
211.82.0.0-211.82.63.255
211.90.80.0-211.90.87.255
211.92.141.181-211.93.167.255
211.98.16.0-211.98.244.255
211.138.96.0-211.138.111.255
211.142.0.0-211.142.95.255
211.145.95.0-211.146.120.255
211.166.152.0-211.166.167.255
218.0.5.98-218.1.121.202
218.3.55.0-218.3.55.255
218.26.0.0-218.26.255.255
218.94.1.197-218.94.11.92
218.244.62.0-218.244.95.255
219.147.32.0-219.147.47.255
219.149.128.0-219.150.100.122
219.226.72.0-219.226.95.255
219.234.0.0-219.234.31.255
219.243.128.0-219.243.227.255
220.176.160.47-220.176.160.59
220.192.176.0-220.192.179.255
220.194.128.0-220.194.191.255
220.207.132.0-220.207.241.255
221.131.8.0-221.131.63.255
221.204.0.0-221.205.255.255
221.230.0.135-221.230.8.255
221.238.131.12-221.239.84.242
222.31.0.0-222.31.63.255
222.37.0.0-222.37.255.255
222.48.108.1-222.48.108.4
222.89.11.130-222.89.70.54
222.186.125.192-222.186.125.255
222.199.0.0-222.199.49.255
222.240.138.130-222.240.142.114
58.195.128.0-58.195.135.255
58.206.96.0-58.207.199.255
59.74.0.0-59.75.255.255
60.179.136.0-60.179.136.255
61.134.0.0-61.134.63.255
61.150.0.0-61.150.127.255
61.178.237.0-61.178.237.255
61.185.0.0-61.185.255.255
61.232.196.0-61.232.203.255
61.236.208.0-61.236.255.255
61.243.96.0-61.243.111.255
117.22.0.0-117.23.255.255
117.32.0.0-117.39.255.255
117.75.128.0-117.75.128.255
118.24.248.0-118.24.248.255
121.46.127.0-121.46.127.255
121.59.124.0-121.59.124.255
122.77.0.0-122.77.255.255
123.89.110.0-123.89.110.255
123.138.0.0-123.139.255.255
123.197.0.0-123.197.97.255
124.22.0.0-124.23.255.255
124.47.0.0-124.47.63.255
124.89.0.0-124.89.127.255
124.114.0.0-124.116.255.255
124.172.32.0-124.172.63.255
125.76.128.0-125.76.255.255
159.226.139.0-159.226.154.255
202.97.65.0-202.97.65.255
202.100.0.0-202.100.63.255
202.117.60.255-202.117.255.255
202.130.33.0-202.130.33.255
202.150.16.0-202.150.31.255
202.200.0.0-202.200.255.255
203.93.39.0-203.93.41.255
203.152.64.0-203.152.95.255
210.12.19.0-210.13.253.255
210.27.0.0-210.27.127.255
210.52.154.0-210.52.154.255
210.72.144.0-210.72.151.255
210.74.129.0-210.74.159.255
210.77.253.0-210.77.253.255
210.83.0.0-210.83.15.255
210.87.128.0-210.87.191.255
211.92.179.0-211.92.247.255
211.98.100.0-211.98.234.255
211.137.112.0-211.137.143.255
211.145.197.0-211.145.197.255
211.163.180.0-211.165.231.255
218.30.15.0-218.30.160.255
218.106.208.0-218.106.223.255
218.195.0.0-218.195.127.255
218.200.0.0-218.200.63.255
218.246.128.0-218.246.143.255
219.72.78.0-219.72.78.255
219.144.0.0-219.145.255.255
219.243.229.0-219.245.255.255
220.114.244.0-220.114.247.255
220.192.192.0-220.192.255.255
220.200.136.0-220.200.199.255
220.205.74.0-220.205.77.255
220.207.128.0-220.207.131.255
221.11.0.0-221.11.127.255
222.15.59.0-222.15.59.255
222.24.0.0-222.25.199.255
222.41.0.0-222.41.255.255
222.90.0.0-222.91.255.255
58.24.0.0-58.25.255.255
58.32.0.0-58.41.255.255
58.194.64.0-58.194.95.255
58.196.128.0-58.196.191.255
58.198.0.0-58.198.127.255
58.207.16.0-58.207.39.255
58.246.0.0-58.247.255.255
59.78.64.0-59.79.127.255
60.63.0.0-60.63.255.255
61.8.160.0-61.8.175.255
61.87.192.0-61.87.255.255
61.129.0.0-61.129.255.255
61.151.0.0-61.152.255.255
61.165.0.0-61.165.255.255
61.169.0.0-61.173.255.255
61.232.17.0-61.232.76.255
61.240.192.0-61.240.215.255
116.58.128.0-116.58.143.255
116.192.0.0-116.193.63.255
116.215.19.0-116.215.80.255
116.224.0.0-116.239.255.255
116.246.0.0-116.247.255.255
117.74.128.0-117.74.255.255
117.103.16.0-117.103.31.255
118.24.222.0-118.24.222.255
118.26.0.0-118.26.255.255
118.126.0.0-118.126.255.255
121.37.0.0-121.37.32.255
121.55.8.0-121.55.50.255
121.76.0.0-121.77.255.255
121.201.128.0-121.201.132.255
122.8.0.0-122.9.55.255
122.51.97.0-122.51.111.255
122.144.128.0-122.144.255.255
123.0.128.0-123.0.191.255
123.49.128.0-123.49.159.255
123.136.80.0-123.136.95.255
123.253.6.0-123.253.176.255
124.28.192.0-124.28.255.255
124.74.0.0-124.79.255.255
124.108.8.0-124.108.15.255
124.175.97.0-124.175.97.255
124.200.64.0-124.200.191.255
124.243.192.0-124.243.255.255
125.98.131.0-125.98.191.255
125.215.0.0-125.215.63.255
159.226.50.0-159.226.131.255
167.139.0.0-167.139.255.255
202.22.248.0-202.22.255.255
202.38.0.0-202.38.169.255
202.76.240.0-202.76.240.255
202.95.81.0-202.97.58.6
202.101.0.0-202.101.63.255
202.109.0.0-202.109.127.255
202.112.40.0-202.112.47.255
202.120.64.0-202.122.7.255
202.127.0.0-202.127.145.255
202.130.248.0-202.131.63.255
202.136.208.0-202.136.223.255
202.158.160.0-202.158.200.255
202.168.67.0-202.168.67.255
202.170.216.0-202.170.216.255
203.86.8.0-203.86.15.255
203.93.2.0-203.95.8.255
203.110.160.0-203.110.191.255
203.156.192.0-203.156.255.255
203.166.160.0-203.166.191.255
203.176.168.0-203.176.175.255
203.184.80.0-203.184.95.255
203.207.144.0-203.207.144.255
210.5.19.0-210.5.159.255
210.12.76.0-210.15.76.255
210.22.45.0-210.22.255.255
210.35.64.0-210.35.127.255
210.51.20.0-210.52.228.255
210.72.8.0-210.75.74.255
210.78.17.0-210.78.26.255
210.210.159.0-210.210.159.255
211.80.0.0-211.80.127.255
211.90.200.0-211.90.200.255
211.95.0.0-211.95.127.255
211.98.33.0-211.98.235.255
211.100.128.0-211.100.191.255
211.102.0.0-211.102.29.255
211.136.96.0-211.136.191.255
211.144.64.0-211.144.223.255
211.146.192.0-211.148.63.255
211.152.20.0-211.152.159.255
211.154.64.0-211.154.155.255
211.156.0.0-211.156.175.255
211.159.97.0-211.162.207.255
211.166.98.0-211.167.159.255
218.1.0.0-218.1.255.255
218.28.152.114-218.28.152.182
218.30.255.0-218.30.255.255
218.78.0.0-218.83.255.255
218.97.32.0-218.97.190.255
218.193.128.0-218.193.175.255
218.202.224.0-218.202.255.255
218.240.128.0-218.240.128.255
218.242.0.0-218.242.255.255
218.244.96.0-218.244.127.255
218.246.240.0-218.246.255.255
219.220.128.0-219.220.255.255
219.228.0.0-219.228.191.255
219.233.0.0-219.233.255.255
219.235.0.0-219.235.15.255
219.243.249.0-219.243.249.255
220.112.64.0-220.115.255.255
220.152.128.0-220.152.255.255
220.192.8.0-220.192.15.255
220.196.0.0-220.196.116.255
220.205.0.0-220.207.247.255
220.232.64.0-220.232.127.255
220.234.0.0-220.234.255.255
220.248.0.0-220.248.127.255
221.130.176.0-221.130.207.255
221.133.224.0-221.133.255.255
221.137.0.0-221.137.255.255
221.239.128.0-221.239.255.255
222.15.56.0-222.15.56.255
222.44.0.0-222.44.255.255
222.62.42.0-222.62.42.255
222.64.0.0-222.73.255.255
222.88.64.138-222.88.76.70
222.204.128.0-222.205.159.255
58.66.0.0-58.67.95.255
58.82.104.0-58.82.111.255
58.206.0.0-58.206.31.255
59.54.82.0-59.54.127.255
59.191.0.0-59.191.67.255
60.255.0.0-60.255.255.255
61.139.0.0-61.139.127.255
61.157.0.0-61.157.255.255
61.186.172.0-61.186.172.255
61.188.0.0-61.188.255.255
61.232.213.0-61.232.231.255
61.235.202.0-61.237.94.255
61.243.0.0-61.243.121.255
116.254.128.0-116.254.199.255
118.112.0.0-118.125.255.255
118.197.0.0-118.197.255.255
119.4.0.0-119.5.217.255
119.45.255.0-119.45.255.255
121.48.0.0-121.49.5.255
121.68.16.0-121.68.127.255
121.201.112.0-121.201.115.255
122.14.195.0-122.14.195.255
123.196.192.0-123.196.255.255
123.249.67.0-123.249.127.255
124.14.128.0-124.14.151.255
124.147.192.0-124.147.255.255
124.161.0.0-124.161.255.255
124.172.10.0-124.173.230.255
125.64.0.0-125.71.255.255
159.226.140.0-159.226.167.255
202.97.24.0-202.98.159.255
202.112.14.0-202.112.16.255
202.115.0.0-202.115.255.255
202.127.121.0-202.127.121.255
202.166.130.0-202.166.130.255
202.202.176.0-202.202.191.255
203.93.86.0-203.93.219.159
203.135.119.0-203.135.119.255
203.207.180.0-203.207.189.255
210.12.29.0-210.12.248.255
210.15.123.0-210.15.127.255
210.41.56.0-210.41.255.255
210.51.232.0-210.53.23.255
210.74.81.0-210.75.239.255
210.79.244.0-210.79.244.255
211.83.32.0-211.83.255.255
211.92.53.129-211.92.99.255
211.95.128.0-211.95.191.255
211.98.110.0-211.98.217.255
211.137.85.0-211.137.105.255
211.146.164.0-211.147.207.255
211.162.128.0-211.163.23.255
211.165.65.0-211.165.132.255
218.6.128.0-218.6.255.255
218.21.76.154-218.21.77.148
218.62.85.3-218.62.178.255
218.88.0.0-218.89.255.255
218.99.32.0-218.99.32.255
218.104.200.0-218.104.223.255
218.106.136.0-218.106.138.255
218.194.0.0-218.194.95.255
218.200.160.0-218.200.239.255
218.203.224.0-218.203.255.255
218.205.224.0-218.205.255.255
218.246.192.0-218.246.223.255
219.221.128.0-219.221.223.255
219.232.224.0-219.232.224.255
219.234.48.0-219.234.63.255
219.243.234.0-219.243.234.255
220.112.128.0-220.112.191.255
220.115.64.0-220.115.109.255
220.166.0.0-220.167.127.255
220.192.168.0-220.192.175.255
220.197.20.0-220.197.175.255
220.205.32.0-220.205.175.255
220.207.168.0-220.207.175.255
220.248.128.0-220.248.159.255
221.10.0.0-221.10.255.255
221.236.0.0-221.237.255.255
222.18.0.0-222.19.63.255
222.53.0.0-222.53.255.255
222.88.188.230-222.88.188.233
222.168.108.202-222.168.146.62
222.180.163.123-222.180.191.255
222.196.0.0-222.197.255.255
222.208.0.0-222.215.255.255
58.194.96.0-58.194.119.255
58.206.128.0-58.207.63.255
59.67.0.0-59.67.255.255
60.24.0.0-60.30.255.255
61.136.0.0-61.136.63.255
61.181.0.0-61.181.255.255
61.232.16.0-61.232.27.255
61.234.70.0-61.234.95.255
61.240.0.0-61.240.31.255
117.8.0.0-117.15.255.255
121.193.128.0-121.193.163.255
123.57.128.0-123.57.159.255
123.151.15.0-123.151.255.255
124.196.0.0-124.196.255.255
124.249.0.0-124.249.255.255
125.35.128.0-125.39.255.255
125.254.177.0-125.254.190.255
159.226.177.0-159.226.236.255
202.99.64.0-202.99.127.255
202.113.0.0-202.113.248.255
202.122.64.0-202.122.95.255
202.143.16.0-202.143.31.255
202.164.0.0-202.164.15.255
203.93.52.0-203.93.222.255
203.207.128.0-203.207.136.255
210.12.7.0-210.13.254.255
210.31.128.0-210.31.159.255
210.51.244.224-210.52.165.255
210.75.244.0-210.75.248.255
210.82.128.0-210.82.234.255
210.166.2.0-210.166.2.255
211.68.112.0-211.68.255.255
211.81.8.0-211.81.63.255
211.94.191.0-211.95.84.255
211.98.13.0-211.98.13.255
211.102.95.0-211.103.95.255
211.137.144.0-211.137.175.255
211.146.66.0-211.146.79.255
211.148.160.0-211.148.191.255
211.152.195.0-211.152.195.255
211.156.48.0-211.156.63.255
211.160.54.0-211.160.179.255
218.25.161.38-218.25.172.33
218.27.134.15-218.27.176.166
218.30.175.0-218.30.189.255
218.62.66.206-218.62.77.190
218.67.128.0-218.69.255.255
218.104.16.0-218.104.31.255
219.140.189.85-219.140.194.174
219.150.33.0-219.150.111.255
219.226.0.0-219.226.11.255
219.243.0.0-219.243.225.255
220.113.130.0-220.113.144.255
220.115.16.0-220.115.25.255
220.192.16.0-220.192.19.255
220.194.64.0-220.194.127.255
220.205.78.0-220.206.212.255
221.129.0.0-221.129.255.255
221.196.0.0-221.198.255.255
221.215.12.0-221.215.12.3
221.238.0.0-221.239.127.255
222.30.0.0-222.30.135.255
222.36.0.0-222.36.127.255
222.82.242.86-222.82.254.10
222.168.128.14-222.168.140.70
59.75.80.0-59.75.95.255
61.185.21.75-61.185.28.181
61.236.120.0-61.236.120.255
124.31.0.0-124.31.1.255
202.98.224.0-202.98.255.255
202.200.16.0-202.200.23.255
210.12.219.0-210.13.80.255
210.41.0.0-210.41.31.255
211.92.245.0-211.92.245.255
211.139.64.0-211.139.79.255
211.163.31.0-211.163.31.255
219.151.32.0-219.151.127.255
219.243.238.0-219.243.238.255
220.182.0.0-220.182.63.255
220.192.204.0-220.192.205.255
220.200.136.97-220.200.136.101
220.207.242.0-220.207.246.255
221.13.64.0-221.13.95.255
222.19.64.0-222.19.111.255
58.207.64.0-58.207.67.255
59.75.128.0-59.75.247.255
60.12.88.203-60.13.255.255
61.128.96.0-61.128.127.255
61.138.224.0-61.138.255.255
61.232.252.0-61.234.143.255
61.237.15.0-61.237.241.255
61.243.64.0-61.243.95.255
121.46.64.0-121.46.126.255
124.88.0.0-124.88.255.255
124.117.0.0-124.119.255.255
125.213.112.0-125.213.127.255
159.226.132.0-159.226.135.255
202.100.160.0-202.100.191.255
202.107.128.0-202.107.191.255
202.201.160.0-202.201.255.255
203.93.22.0-203.93.217.191
210.12.19.160-210.13.242.255
210.26.128.0-210.26.255.255
210.52.20.0-210.53.192.255
210.82.172.0-210.82.235.255
211.93.16.0-211.93.23.255
211.98.127.0-211.98.252.255
211.138.32.0-211.138.47.255
211.163.32.0-211.163.39.255
211.165.200.0-211.165.201.255
218.31.0.0-218.31.255.255
218.62.28.88-218.62.34.29
218.84.0.0-218.84.255.255
218.195.128.0-218.195.255.255
218.202.144.0-218.202.223.255
219.243.233.0-219.243.233.255
219.247.0.0-219.247.116.255
220.171.0.0-220.171.191.255
220.192.208.0-220.192.215.255
220.200.200.0-220.200.212.255
221.7.0.0-221.7.31.255
222.25.200.0-222.25.255.255
222.60.0.0-222.60.127.255
222.62.72.0-222.62.79.255
222.80.0.0-222.83.127.255
58.66.240.0-58.67.141.255
58.207.72.0-58.207.79.255
59.53.61.0-59.53.61.255
59.111.12.0-59.111.32.255
59.155.176.0-59.155.191.255
59.191.64.0-59.191.81.255
60.160.0.0-60.161.255.255
60.205.0.0-60.205.133.255
61.138.192.0-61.138.223.255
61.159.192.0-61.159.255.255
61.166.0.0-61.166.255.255
61.232.232.0-61.232.235.255
61.243.55.0-61.243.63.255
116.52.0.0-116.55.255.255
116.248.0.0-116.249.255.255
121.36.40.0-121.36.136.255
121.49.128.0-121.49.191.255
121.51.129.0-121.51.192.255
121.58.182.0-121.58.182.255
123.57.184.0-123.57.191.255
123.60.0.0-123.60.63.255
124.172.0.0-124.172.13.255
125.213.102.0-125.213.111.255
159.226.69.0-159.226.249.255
202.38.130.0-202.38.131.255
202.97.19.0-202.98.191.255
202.165.244.0-202.165.244.255
202.203.0.0-202.203.255.255
203.89.0.0-203.89.3.255
203.93.68.0-203.93.159.255
210.14.188.0-210.14.249.255
210.40.176.0-210.40.255.255
210.51.235.248-210.51.235.255
210.72.88.0-210.72.88.255
210.82.192.0-210.82.192.255
211.83.176.0-211.83.191.255
211.92.144.0-211.92.240.255
211.98.72.0-211.98.174.255
211.139.16.0-211.139.31.255
211.146.112.0-211.146.115.255
211.155.96.0-211.155.111.255
211.163.80.0-211.163.94.255
218.62.128.0-218.63.255.255
218.104.210.0-218.104.215.255
218.106.139.0-218.106.139.255
218.194.96.0-218.194.223.255
218.202.0.0-218.202.63.255
218.206.32.0-218.206.63.255
219.221.240.0-219.221.255.255
219.243.236.0-219.243.236.255
220.163.0.0-220.165.255.255
220.192.188.0-220.192.191.255
220.197.223.0-220.197.255.255
220.207.188.0-220.207.252.255
221.3.128.0-221.3.255.255
221.213.0.0-221.213.255.255
222.19.192.0-222.19.255.255
222.56.0.0-222.56.247.255
222.172.128.0-222.172.255.255
222.197.192.0-222.197.244.255
222.219.0.0-222.221.255.255
222.223.212.0-222.223.221.255
58.82.112.0-58.82.239.255
58.87.64.0-58.87.127.255
58.100.0.0-58.101.255.255
58.195.248.0-58.195.255.255
58.206.192.0-58.206.223.255
59.79.128.0-59.79.191.255
60.12.0.0-60.12.255.255
60.55.0.0-60.55.255.255
60.162.0.0-60.163.255.255
60.175.207.0-60.191.255.255
60.205.32.0-60.205.243.255
61.29.241.0-61.29.241.255
61.130.0.0-61.130.255.255
61.153.0.0-61.153.255.255
61.164.0.0-61.164.255.255
61.174.0.0-61.175.255.255
61.232.78.0-61.232.84.255
61.234.176.0-61.234.191.255
61.237.84.0-61.237.85.255
61.241.64.0-61.241.127.255
116.89.144.0-116.89.159.255
116.204.0.0-116.204.255.255
116.216.255.0-116.216.255.255
118.91.0.0-118.91.255.255
121.0.16.0-121.0.31.255
121.40.216.0-121.41.222.255
121.46.0.0-121.46.223.255
121.55.0.0-121.55.7.255
121.192.0.0-121.192.23.255
122.9.56.0-122.9.56.255
122.48.128.0-122.48.199.255
122.85.241.0-122.85.241.255
122.198.37.0-122.198.63.255
122.224.0.0-122.247.255.255
123.96.0.0-123.97.255.255
123.123.0.0-123.124.255.255
123.137.0.0-123.137.255.255
123.148.0.0-123.148.255.255
123.152.0.0-123.159.255.255
123.249.156.0-123.249.207.255
124.89.128.0-124.91.255.255
124.156.96.0-124.156.255.255
124.160.0.0-124.160.255.255
124.172.92.0-124.174.139.255
124.200.76.0-124.200.255.255
124.249.224.0-124.249.239.255
125.104.0.0-125.127.255.255
125.210.0.0-125.210.255.255
202.75.208.0-202.75.223.255
202.91.224.0-202.91.255.255
202.96.96.0-202.97.68.255
202.101.160.0-202.101.191.255
202.107.192.0-202.107.255.255
202.170.217.0-202.170.224.255
203.93.130.0-203.93.251.255
203.175.192.0-203.175.255.255
203.207.251.0-203.207.255.255
210.15.0.0-210.15.107.255
210.22.194.0-210.22.194.255
210.32.0.0-210.33.255.255
210.51.66.0-210.52.243.255
210.83.64.0-210.83.223.255
211.80.128.0-211.80.159.255
211.90.44.0-211.91.85.255
211.98.37.0-211.98.144.255
211.100.130.0-211.100.133.255
211.138.112.0-211.138.131.255
211.140.0.0-211.140.191.255
211.146.128.0-211.146.158.255
211.155.224.0-211.155.239.255
211.163.112.0-211.163.119.255
211.167.141.0-211.167.153.255
218.0.0.0-218.1.7.255
218.30.139.0-218.30.139.255
218.71.0.0-218.75.127.255
218.106.0.0-218.106.111.255
218.108.0.0-218.109.255.255
218.205.48.0-218.205.127.255
219.82.0.0-219.82.255.255
219.243.250.0-219.243.250.255
220.184.0.0-220.192.128.255
220.195.72.0-220.195.158.255
220.203.8.0-220.203.10.255
220.205.160.0-220.205.223.255
220.207.112.0-220.207.127.255
221.12.0.0-221.12.191.255
221.136.0.0-221.136.255.255
221.238.176.0-221.238.179.255
222.46.0.0-222.46.255.255
222.61.128.0-222.61.227.255
222.205.0.0-222.205.127.255
58.17.128.0-58.17.255.255
58.43.0.0-58.43.255.255
58.83.32.0-58.83.65.255
58.144.0.0-58.144.255.255
58.207.80.0-58.207.95.255
59.53.52.0-59.53.67.255
59.63.240.0-59.63.255.255
61.128.15.0-61.128.255.255
61.161.0.0-61.161.127.255
61.186.128.0-61.186.255.255
61.232.224.0-61.232.226.255
61.235.196.0-61.235.247.255
61.242.224.0-61.242.255.255
117.59.0.0-117.59.255.255
117.75.130.0-117.75.237.255
121.49.0.0-121.49.5.255
121.68.1.0-121.68.15.255
121.89.151.0-121.89.151.255
123.144.0.0-123.147.255.255
123.151.28.0-123.151.31.255
123.197.121.0-123.197.121.255
124.21.243.0-124.21.255.255
124.162.0.0-124.162.255.255
125.32.13.158-125.32.13.206
125.62.0.0-125.62.63.255
125.80.0.0-125.87.255.255
125.213.88.0-125.213.101.255
125.254.176.0-125.254.191.255
202.98.32.0-202.98.63.255
202.120.128.0-202.120.141.255
202.131.22.0-202.131.22.255
202.202.0.0-202.202.255.255
203.93.30.0-203.93.221.255
203.135.112.0-203.135.127.255
203.161.192.0-203.161.223.255
203.207.190.0-203.207.190.255
210.41.32.0-210.41.63.255
210.53.24.0-210.53.27.255
210.74.123.0-210.74.154.255
210.77.160.0-210.77.175.255
211.83.0.0-211.83.231.255
211.92.8.0-211.92.135.255
211.98.112.0-211.98.223.255
211.136.11.0-211.136.11.255
211.139.32.0-211.139.63.255
211.144.160.0-211.144.175.255
211.151.100.0-211.151.100.255
211.155.114.0-211.155.127.255
211.158.0.0-211.158.255.255
211.162.208.0-211.162.215.255
218.21.48.0-218.21.63.255
218.30.158.0-218.30.158.255
218.62.8.24-218.62.75.214
218.70.0.0-218.70.255.255
218.194.128.0-218.194.191.255
218.201.0.0-218.201.95.255
218.206.0.0-218.207.63.255
218.244.0.0-218.244.31.255
218.246.48.0-218.246.63.255
219.151.128.0-219.153.255.255
219.221.0.0-219.221.127.255
219.243.235.0-219.243.235.255
220.114.0.0-220.114.243.255
220.182.240.0-220.182.240.255
220.192.174.0-220.192.182.255
220.200.64.0-220.200.95.255
220.207.228.0-220.207.233.255
221.5.128.0-221.5.255.255
221.7.64.0-221.8.31.182
221.13.96.0-221.13.127.255
221.130.252.0-221.130.252.255
221.178.0.0-221.180.255.255
221.238.237.0-221.238.238.255
222.19.112.0-222.19.127.255
222.55.0.0-222.55.127.255
222.168.9.114-222.168.128.2
222.176.5.0-222.183.255.255
222.196.16.0-222.196.31.255
222.198.0.0-222.198.255.255
222.223.53.0-222.223.211.255037|IBM037|IBM EBCDIC美国 - 加拿大
437|IBM437|OEM美国
500|IBM500|IBM EBCDIC International
708|ASMO-708|阿拉伯语（ASMO 708）
709||阿拉伯语（ASMO-449 +，BCON V4）
710||阿拉伯语 - 透明阿拉伯
720|DOS-720|阿拉伯语（透明ASMO）; 阿拉伯语（DOS）
737|ibm737|OEM希腊语（原名437G）; 希腊语（DOS）
775|ibm775|OEM波罗的海; 波罗的海（DOS）
850|ibm850|OEM多语种拉丁语1; 西欧（DOS）
852|ibm852|OEM拉丁文2; 中欧（DOS）
855|IBM855|OEM西里尔文（主要是俄罗斯）
857|ibm857|OEM土耳其; 土耳其语（DOS）
858|IBM00858|OEM多语言拉丁语1 +欧元符号
860|IBM860|OEM葡萄牙语; 葡萄牙语（DOS）
861|ibm861|OEM冰岛; 冰岛语（DOS）
862|DOS-862|OEM希伯来语; 希伯来语（DOS）
863|IBM863|OEM法国加拿大人; 法语加拿大人（DOS）
864|IBM864|OEM阿拉伯语; 阿拉伯语（864）
865|IBM865|OEM北欧; 北欧（DOS）
866|CP866|OEM俄罗斯; 西里尔文（DOS）
869|ibm869|OEM现代希腊语; 希腊语，现代（DOS）
870|IBM870|IBM EBCDIC Multilingual / ROECE（Latin 2）; IBM EBCDIC多语种拉丁语2
874|窗户-874|ANSI / OEM Thai（ISO 8859-11）; 泰语（Windows）
875|cp875|IBM EBCDIC希腊现代版
932|shift_jis访问|ANSI / OEM日语; 日语（Shift-JIS）
936|GB2312|ANSI / OEM简体中文（中国，新加坡）; 简体中文（GB2312）
949|ks_c_5601-1987|ANSI / OEM韩语（统一韩语代码）
950|中文|ANSI / OEM繁体中文（台湾;中国香港特别行政区）; 繁体中文（Big5）
1026|IBM1026|IBM EBCDIC土耳其语（拉丁语5）
1047|IBM01047|IBM EBCDIC Latin 1 / Open System
1140|IBM01140|IBM EBCDIC美国 - 加拿大（037 +欧元符号）; IBM EBCDIC（美国 - 加拿大 - 欧元）
1141|IBM01141|IBM EBCDIC德国（20273 +欧元符号）; IBM EBCDIC（德国 - 欧元）
1142|IBM01142|IBM EBCDIC丹麦 - 挪威（20277 +欧元符号）; IBM EBCDIC（丹麦 - 挪威 - 欧元）
1143|IBM01143|IBM EBCDIC芬兰 - 瑞典（20278 +欧元符号）; IBM EBCDIC（芬兰 - 瑞典 - 欧元）
1144|IBM01144|IBM EBCDIC意大利（20280 +欧元符号）; IBM EBCDIC（意大利 - 欧元）
1145|IBM01145|IBM EBCDIC拉丁美洲 - 西班牙（20284 +欧元符号）; IBM EBCDIC（西班牙 - 欧元）
1146|IBM01146|IBM EBCDIC英国（20285 +欧元符号）; IBM EBCDIC（英国 - 欧元）
1147|IBM01147|IBM EBCDIC France（20297 +欧元符号）; IBM EBCDIC（法国 - 欧元）
1148|IBM01148|IBM EBCDIC International（500 +欧元符号）; IBM EBCDIC（国际 - 欧元）
1149|IBM01149|IBM EBCDIC Icelandic（20871 +欧元符号）; IBM EBCDIC（冰岛 - 欧元）
1200|UTF-16|Unicode UTF-16，小端字节顺序（ISO 10646的BMP）; 仅适用于托管应用程序
1201|unicodeFFFE|Unicode UTF-16，大端字节顺序; 仅适用于托管应用程序
1250|窗户-1250|ANSI中欧; 中欧（Windows）
1251|窗户-1251|ANSI西里尔文; 西里尔文（Windows）
1252|窗口1252|ANSI Latin 1; 西欧（Windows）
1253|窗户-1253|ANSI希腊语; 希腊语（Windows）
1254|窗户-1254|ANSI土耳其语; 土耳其语（Windows）
1255|窗户-1255|ANSI希伯来语; 希伯来语（Windows）
1256|窗户-1256|ANSI阿拉伯语; 阿拉伯语（Windows）
1257|窗户-1257|ANSI波罗的海; 波罗的海（Windows）
1258|窗户-1258|ANSI / OEM越南语; 越南语（Windows）
1361|裘哈|韩国人（Johab）
10000|苹果|MAC罗马; 西欧（Mac）
10001|X-MAC-日本|日语（Mac）
10002|X-MAC-chinesetrad|MAC繁体中文（Big5）; 繁体中文（Mac）
10003|X-MAC-韩国|韩语（Mac）
10004|X-MAC-阿拉伯语|阿拉伯语（Mac）
10005|X-MAC-希伯来语|希伯来语（Mac）
10006|X-MAC-希腊|希腊语（Mac）
10007|X-MAC-西里尔|西里尔文（Mac）
10008|X-MAC-chinesesimp|MAC简体中文（GB 2312）; 简体中文（Mac）
10010|X-MAC-罗马尼亚|罗马尼亚语（Mac）
10017|X-MAC-乌克兰|乌克兰语（Mac）
10021|X-MAC泰|泰语（Mac）
10029|X-MAC-CE|MAC拉丁文2; 中欧（Mac）
10079|X-MAC-冰岛|冰岛语（Mac）
10081|X-MAC-土耳其|土耳其语（Mac）
10082|X-MAC-克罗地亚|克罗地亚语（Mac）
12000|UTF-32|Unicode UTF-32，小端字节顺序; 仅适用于托管应用程序
12001|UTF-32BE|Unicode UTF-32，大端字节顺序; 仅适用于托管应用程序
20000|X-Chinese_CNS|CNS台湾; 繁体中文（CNS）
20001|X-cp20001|TCA台湾
20002|x_Chinese，倚天|台湾; 繁体中文（Eten）
20003|X-cp20003|IBM5550台湾
20004|X-cp20004|TeleText台湾
20005|X-cp20005|王台湾
20105|X-IA5|IA5（IRV国际字母第5号，7位）; 西欧（IA5）
20106|X-IA5德|IA5德语（7位）
20107|X-IA5瑞典|IA5瑞典语（7位）
20108|X-IA5挪威|IA5挪威语（7位）
20127|US-ASCII|US-ASCII（7位）
20261|X-cp20261|T.61
20269|X-cp20269|ISO 6937非间距重音
20273|IBM273|IBM EBCDIC德国
20277|IBM277|IBM EBCDIC丹麦 - 挪威
20278|IBM278|IBM EBCDIC芬兰 - 瑞典
20280|IBM280|IBM EBCDIC意大利
20284|IBM284|IBM EBCDIC拉丁美洲 - 西班牙
20285|IBM285|IBM EBCDIC英国
20290|IBM290|IBM EBCDIC日语片假名扩展
20297|IBM297|IBM EBCDIC France
20420|IBM420|IBM EBCDIC阿拉伯语
20423|IBM423|IBM EBCDIC希腊语
20424|IBM424|IBM EBCDIC希伯来语
20833|X-EBCDIC-KoreanExtended|IBM EBCDIC Korean Extended
20838|IBM泰|IBM EBCDIC Thai
20866|KOI8-R|俄语（KOI8-R）; 西里尔文（KOI8-R）
20871|IBM871|IBM EBCDIC冰岛语
20880|IBM880|IBM EBCDIC西里尔语俄语
20905|IBM905|IBM EBCDIC土耳其语
20924|IBM00924|IBM EBCDIC Latin 1 /开放系统（1047 +欧元符号）
20932|EUC-JP|日语（JIS 0208-1990和0212-1990）
20936|X-cp20936|简体中文（GB2312）; 简体中文（GB2312-80）
20949|X-cp20949|韩国万松
21025|CP1025|IBM EBCDIC Cyrillic Serbian-Bulgarian
21027||（废弃）
21866|KOI8-U|乌克兰语（KOI8-U）; 西里尔文（KOI8-U）
28591|ISO-8859-1|ISO 8859-1拉丁文1; 西欧（ISO）
28592|ISO-8859-2|ISO 8859-2中欧; 中欧（ISO）
28593|ISO-8859-3|ISO 8859-3拉丁文3
28594|ISO-8859-4|ISO 8859-4波罗的海
28595|ISO-8859-5|ISO 8859-5西里尔文
28596|ISO-8859-6|ISO 8859-6阿拉伯文
28597|ISO-8859-7|ISO 8859-7希腊语
28598|ISO-8859-8|ISO 8859-8希伯来语; 希伯来语（ISO-Visual）
28599|ISO-8859-9|ISO 8859-9土耳其语
28603|ISO-8859-13|ISO 8859-13爱沙尼亚语
28605|ISO-8859-15|ISO 8859-15拉丁文9
29001|X-欧罗巴|欧罗巴3
38598|ISO-8859-8-I|ISO 8859-8希伯来语; 希伯来语（ISO-Logical）
50220|ISO-2022-JP|ISO 2022日语，没有半宽片假名; 日语（JIS）
50221|csISO2022JP|带有半宽片假名的ISO 2022日语; 日语（JIS-Allow 1字节假名）
50222|ISO-2022-JP|ISO 2022日本JIS X 0201-1989; 日语（JIS-Allow 1字节假名 - SO / SI）
50225|ISO-2022-KR|ISO 2022韩语
50227|X-cp50227|ISO 2022简体中文; 简体中文（ISO 2022）
50229||ISO 2022繁体中文
50930||EBCDIC日语（片假名）扩展
50931||EBCDIC美国 - 加拿大和日本
50933||EBCDIC韩语扩展和韩语
50935||EBCDIC简体中文扩展和简体中文
50936||EBCDIC简体中文
50937||EBCDIC美国 - 加拿大和繁体中文
50939||EBCDIC日语（拉丁语）扩展和日语
51932|EUC-JP|EUC日语
51936|EUC-CN|EUC简体中文; 简体中文（EUC）
51949|EUC-KR|EUC韩语
51950||EUC繁体中文
52936|HZ-GB-2312|HZ-GB2312简体中文; 简体中文（HZ）
54936|GB18030|Windows XP及更高版本： GB18030简体中文（4字节）; 简体中文（GB18030）
57002|X-ISCII-DE|ISCII梵文
57003|的x ISCII待|ISCII孟加拉语
57004|的x ISCII-TA|ISCII泰米尔语
57005|的x ISCII-TE|ISCII泰卢固语
57006|的x ISCII-作为|ISCII阿萨姆
57007|的x ISCII-或|ISCII Odia
57008|X-ISCII-KA|ISCII卡纳达语
57009|X-ISCII-MA|ISCII马拉雅拉姆语
57010|X-ISCII区|ISCII古吉拉特语
57011|X-ISCII-PA|ISCII旁遮普语
65000|UTF-7|Unicode（UTF-7）
65001|UTF-8|Unicode（UTF-8）\/:*?"<>|@echo off 
@ping 127.0.0.1 -n 秒数 >nul
start "" "<文件名>"
del Restart.batvar window = this;
var document = window;
var getMonthWeek = function(a, b, c) {
var date = new Date(a, parseInt(b) - 1, c),
w = date.getDay(),
d = date.getDate();
return Math.ceil((d + 6 - w) / 7);
};
var getYearWeek = function(a, b, c) {
var date1 = new Date(a, parseInt(b) - 1, c),
date2 = new Date(a, 0, 1),
d = Math.round((date1.valueOf() - date2.valueOf()) / 86400000);
return Math.ceil((d + ((date2.getDay() + 1) - 1)) / 7);
};
function test() {
var today = new Date();
var y = today.getFullYear();
var m = today.getMonth() + 1;
var d = today.getDate();
var quarter = "";
var result = getYearWeek(y, m, d);
if (m < 4) {
    quarter = 1;
    week = result;
} else if (m < 7) {
    quarter = 2;
    week = result - getYearWeek(y, 4, 1);
    var day = new Date(y, 4, 1);
    if (day.getDay() > 1) {
        week += 1;
    }
} else if (m < 10) {
    quarter = 3;
    week = result - getYearWeek(y, 7, 1);
    var day = new Date(y, 7, 1);
    if (day.getDay() > 1) {
        week += 1;
    }
} else {
    quarter = 4;
    week = result - getYearWeek(y, 10, 1);
    var day = new Date(y, 10, 1);
    if (day.getDay() > 1) {
        week += 1;
    }
}
return getYearWeek(y, m, d) + "==" + getMonthWeek(y, m, d) + "==" + week;
}赵钱孙李周吴郑王冯陈褚卫蒋沈韩杨朱秦尤许何吕施张孔曹严华金魏陶姜戚谢邹喻柏水窦章云苏潘葛奚范彭郎鲁韦昌马苗凤花方俞任袁柳酆鲍史唐费廉岑薛雷贺倪汤滕殷罗毕郝邬安常乐于时傅皮卞齐康伍余元卜顾孟平黄和穆萧尹姚邵湛汪祁毛禹狄米贝明臧计伏成戴谈宋茅庞熊纪舒屈项祝董梁杜阮蓝闵席季麻强贾路娄危江童颜郭梅盛林刁钟徐邱骆高夏蔡田樊胡凌霍虞万支柯昝管卢莫柯房裘缪干解应宗丁宣贲邓郁单杭洪包诸左石崔吉钮龚程嵇邢滑裴陆荣翁荀羊于惠甄曲家封芮羿储靳汲邴糜松井段富巫乌焦巴弓牧隗山谷车侯宓蓬全郗班仰秋仲伊宫宁仇栾暴甘钭历戎祖武符刘景詹束龙叶幸司韶郜黎蓟溥印宿白怀蒲邰从鄂索咸籍赖卓蔺屠蒙池乔阳郁胥能苍双闻莘党翟谭贡劳逄姬申扶堵冉宰郦雍却璩桑桂濮牛寿通边扈燕冀浦尚农温别庄晏柴瞿阎充慕连茹习宦艾鱼容向古易慎戈廖庾终暨居衡步都耿满弘匡国文寇广禄阙东欧殳沃利蔚越夔隆师巩厍聂晁勾敖融冷訾辛阚那简饶空曾毋沙乜养鞠须丰巢关蒯相查后荆红游竺权逮盍益桓公@echo off 
@ping 127.0.0.1 -n 3 >nul
move /y "被移动文件" "目录" 
start "被移动文件"
@ping 127.0.0.1 -n 1 >nul
del 123.bat
┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃模块开发：广大易友    版本：V11.1.5                               ┃
┣━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
┃模块说明：使用易语言核心支持库 + API完成 　   授权：开源&永久免费 ┃◆精易论坛       〓 https://bbs.125.la/
┣━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
┃使用注意：精易模块纯绿色,为了确保安全,请务必到〖精易论坛〗下载    ┃◆易语言助手     〓 http://e.125.la/
┣━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
┃特别声明：部分代码是取自前辈们的，集合在一起只是方便大家使用！    ┃◆精易编程助手   〓 http://soft.125.la/
┣━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
┃使用声明：请勿使用本模块编写有损他人利益的软件,造成的后果全部自负 ┃◆精易模块官网   〓 http://ec.125.la/
┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛  fso.DeleteFile("  Dim fso
  Set fso = CreateObject("Scripting.FileSystemObject")
  Wscript.Sleep(1000)
  fso.DeleteFile("
